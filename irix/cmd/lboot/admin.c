/*
 * Copyright 1988-1996, Silicon Graphics, Inc.
 * All Rights Reserved.
 *
 * This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
 * the contents of this file may not be disclosed to third parties, copied or
 * duplicated in any form, in whole or in part, without the prior written
 * permission of Silicon Graphics, Inc.
 *
 * RESTRICTED RIGHTS LEGEND:
 * Use, duplication or disclosure by the Government is subject to restrictions
 * as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
 * and Computer Software clause at DFARS 252.227-7013, and/or in similar or
 * successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
 * rights reserved under the Copyright Laws of the United States.
 */
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include "lboot.h"
#include "boothdr.h"

char	tmp_dev_admin_dot_c[100];
char	tmp_drv_admin_dot_c[100];

/*
 * print out the { <name> , <parameter-name> , <parameter-value>  } 
 * entry in the device administration info table
 */
char **
device_admin(char *name ,char **argv,int *argc,FILE *fp)
{
	/* arg count should atleast be 3 since argv is
	 * expected to have the following strings
	 * "<parameter name>" "=" "<parameter value>" 
	 */

	if (*argc < 3)
		return NULL;

	/* print the 
	 * "{ <name> , <parameter-name> , " 
	 * part of the table entry
	 */ 
	fprintf(fp,"\t{\"%s\" , \"%s\" ,",name,*argv++);

	if (strcmp(*argv++,"="))
		return NULL;

	*argc -= 2;

	/* start printing the 
	 * "<parameter-value> " 
	 * part of the table entry
	 */
	fprintf(fp,"\"");
       
	while (*argc &&
	       strcmp(*argv,",")) {
		fprintf(fp,"%s",*argv++);
		(*argc)--;
	}


	if (*argc) {
		/* we encountered a comma which acts a separator
		 * for mutiple <parameter-name>=<parameter-value>
		 * strings. skip over it
		 */
		argv++;
		(*argc)--;
	}

	/* print the trailing quote and closing paranthesis
	 * of the table entry
	 */
	fprintf(fp,"\" },\n");

	return argv;
}

/*
 * generate the typedef for the table entry structure followed by
 * the name of the administration table
 */
void
generate_dev_admin_table_head(FILE *fp)
{

#define DAT_DEV_HEADSTR  "\n#include <sys/driver.h>\n"			 	\
                         "dev_admin_info_t 	dev_admin_table[] = {\n"

	fprintf(fp,DAT_DEV_HEADSTR);
}
/*
 * generate the typedef for the table entry structure followed by
 * the name of the administration table
 */
void
generate_drv_admin_table_head(FILE *fp)
{

#define DAT_DRV_HEADSTR  "\n#include <sys/driver.h>\n"			       	\
                         "dev_admin_info_t 	drv_admin_table[] = {\n"

	fprintf(fp,DAT_DRV_HEADSTR);
}

/* generate a dummy entry { "" , "" , ""   }  at the end of the
 * table and closing paranthesis of the table followed by a semicolon
 * to end the static declaration of the administration table
 */
void
generate_dev_admin_table_tail(FILE *fp)
{
	fprintf(fp,DAT_DEV_TAILSTR);
}
/* generate a dummy entry { "" , "" , ""   }  at the end of the
 * table and closing paranthesis of the table followed by a semicolon
 * to end the static declaration of the administration table
 */
void
generate_drv_admin_table_tail(FILE *fp)
{
	fprintf(fp,DAT_DRV_TAILSTR);
}

void
init_dev_admin(void)
{
	char *tmpdir=getenv("TMPDIR");
	pid_t mypid=getpid();

	if (!tmpdir)
		tmpdir="/tmp";
	sprintf(tmp_dev_admin_dot_c, "%s/dev_admin%d.c", tmpdir, mypid);
	sprintf(tmp_drv_admin_dot_c, "%s/drv_admin%d.c", tmpdir, mypid);
}

/*
 * Generate the entries in the driver admin table from the driver 
 * master files.
 */
void
drv_admin_table_add(void)
{
	struct driver 		*dp;
	struct master		*mp;
	extern struct driver 	*driver;
	FILE *fp;
	int	i;

	if ((fp = fopen(tmp_drv_admin_dot_c,"r+")) == NULL)
		return;

	fseek64(fp,0,SEEK_END);	/* skip over all the previous
				 * material in temporary drv_admin.c
				 * file
				 */

	/* Back up by length equal to the tail of the table */
	fseek64(fp,-(long)DAT_DRV_TAILLEN,SEEK_END);


	/* Handle the driver admin hints specified thru 
	 * driver master files. These files have 
	 * already been parsed and the info is stored
	 * in the master structure associated with 
	 * the driver. Grab that info and write out
	 * into the drv_admin_table in master.c which 
	 * is going to be generated by lboot.
	 */
	for (dp = driver; dp != 0 ; dp = dp->next) {
		register admin_t *al;

		mp = dp->opthdr;
		if (!mp)
			continue;
		if (!mp->nadmins)
			continue;
		al = (admin_t *) POINTER(mp->o_admin, mp);
		for (i = 0 ; i < mp->nadmins && al; i++,al++) {
			register char *name,*val;

			/* Get the admin pair <name,value> 
			 * by offsetting into the master structure
			 * for this driver.
			 */
			name=POINTER(al->admin_name,mp);
			val=POINTER(al->admin_val,mp);
			
			fprintf(fp,"\t{ \"%s\" , \"%s\", \"%s\" },\n",
				mp->prefix,name,val);
		}
	}
	/* Write out the tail of the table */
	generate_drv_admin_table_tail(fp);
	fflush(fp);
	fclose(fp);

}
/*
 * normally if a device / driver administration directive exists
 * in the system.gen file a temporary file is created which is then
 * appended to the master.c file. if no such temporary file is created
 * then a dummy declaration of the administration info table is created in
 * a temporary file which is then appended to master.c
 */
void
print_dev_admin(void)
{
	char		cmd[2048];
	struct stat	buf;


	if (stat(tmp_dev_admin_dot_c,&buf) == -1) {

		/* if there are of no device / driver administration 
		 * directives  create a dummy table declaration in a
		 * temporary file
		 */
		FILE *fp;
		if ((fp = fopen(tmp_dev_admin_dot_c,"w")) == NULL)
			return;
		generate_dev_admin_table_head(fp);
		generate_dev_admin_table_tail(fp);
 		fflush(fp);
		fclose(fp);
	}
	if (stat(tmp_drv_admin_dot_c,&buf) == -1) {

		/* if there are of no device / driver administration 
		 * directives  create a dummy table declaration in a
		 * temporary file
		 */
		FILE *fp;
		if ((fp = fopen(tmp_drv_admin_dot_c,"w")) == NULL)
			return;
		generate_drv_admin_table_head(fp);
		generate_drv_admin_table_tail(fp);
 		fflush(fp);
		fclose(fp);
	}
	/* Add the admin hints from the driver master files
	 * into the drv_admin_table being generated.
	 */
	drv_admin_table_add();
	/* append the temporary file to the end of master.c */
	sprintf(cmd,"cat %s >> %s/master.c\n",
		tmp_dev_admin_dot_c,
		slash_runtime);
	system(cmd);

	/* remove the temporary file */
	sprintf(cmd,"/bin/rm %s\n",tmp_dev_admin_dot_c);
	system(cmd);
	sprintf(cmd,"cat %s >> %s/master.c\n",
		tmp_drv_admin_dot_c,
		slash_runtime);
	system(cmd);

	/* remove the temporary file */
	sprintf(cmd,"/bin/rm %s\n",tmp_drv_admin_dot_c);
	system(cmd);
}
