#ifndef _NV_EVENT_H_
#define _NV_EVENT_H_
/*
 * event.h -- This is the basic include file that define netvisualyzer events.
 * 
 * $Revision: 1.5 $
 * 
 * contained herein are the definitions of the actual events generated and
 * received by netvis applications and the classes that support them.
 */
 
/*
 * Copyright 1992 Silicon Graphics, Inc.  All rights reserved.
 *
 * This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
 * the contents of this file may not be disclosed to third parties, copied or
 * duplicated in any form, in whole or in part, without the prior written
 * permission of Silicon Graphics, Inc.
 *
 * RESTRICTED RIGHTS LEGEND:
 * Use, duplication or disclosure by the Government is subject to restrictions
 * as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
 * and Computer Software clause at DFARS 252.227-7013, and/or in similar or
 * successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
 * rights reserved under the Copyright Laws of the United States.
 */

#include <unistd.h>
#include <sys/types.h>
#include <sys/time.h>
#include <stdio.h>

typedef int	eventID;
typedef int EV_stat;
class EV_msg;
class EV_clnt_msg;
class EV_srvr_msg;

#define NULL 0
#define EV_OK 0


/* Events are divided into two major categories. Those 
 * generated by NetVisualyzer tools and those handled (received) by 
 * NetVisualyzer tools.
 * 
 * Within those generated by netvisualyzer there are three basic categories, 
 * a generic application startup and shutdown,  an object detection type, 
 * and a rate report.
 * 
 * The basic motivation for the definitions here is that the API provides
 * a single interface to the NV tools and a single set of events across
 * all tools. The class derivations and the event types would proliferate
 * if the decision was to have a particular set of types and classes for 
 * each application.
 * 
 * NOTE - WARNING
 *  Please update the eventStrings.h file as event types,  object types, 
 *  alarm levels, and rate bases are added or change.
 */

// general events for all NV applications
const eventID NV_OTHER			=   0;	// unknown, use "otherData" only
const eventID NV_STARTUP		=   1;	// application start    
const eventID NV_SHUTDOWN		=   2;	// application stop
const eventID NV_START_SNOOP		=   3;	// on a new or different interface
const eventID NV_STOP_SNOOP		=   4;	// no longer on an interface

// detection events (netlook and netttop)
const eventID NV_NEW_NODE		=   10; // saw new node
const eventID NV_NEW_NET	 	=   11; // saw new network
const eventID NV_CONVERSE_START	 	=   12; // traffic btw node pair begins
const eventID NV_CONVERSE_STOP		=   13; // traffic btw node pair ends
const eventID NV_NEW_PROTO	 	=   14; // saw new protocol
const eventID NV_NEW_TOPN		=   15; // new list of top traffic contributors

// rate events (netgraph and nettop)
const eventID NV_RATE_THRESH_HI_MET	=   30; // rate crossed hi threshold
const eventID NV_RATE_THRESH_HI_UN_MET	=   31; // rate returned below hi
const eventID NV_RATE_THRESH_LO_MET	=   32; // rate crossed lo threshold
const eventID NV_RATE_THRESH_LO_UN_MET	=   33; // rate returned above lo

// pseudo event for library connection setup with the server
const eventID NV_REGISTER		=   50; // not for app use

// events for the Log manager
const eventID NV_LOG_START		=   60; // logical start of event log
const eventID NV_LOG_END		=   61; // logical end of event log

// events received

// netlook handled events
const eventID NV_HIGHLIGHT		=   70; //hilight (and display) object

const eventID NV_LAST_EVENT		=   70;

const eventID NV_MAX_EVENT		=   128;

/*
 * Event alarm levels. Each event has an associated alarm level.
 * EV_LEVEL_CLEAR is used to clear a previous alarm.
 */
 
enum EV_level {
    EV_LEVEL_INFO,
    EV_LEVEL_MINOR,
    EV_LEVEL_MAJOR, 
    EV_LEVEL_CRTICAL,
    EV_LEVEL_CLEAR
};

/*
 * class EV_objID
 * This classes defines how nameable/adressable objects on the network can
 * be identified. NV tools can know one or more of: name,  net (usually IP)
 * address,  and MAC address (ethernet, FDDI, tokenring). Objects that fall
 * into this category are nodes, hosts, interfaces, networks.
 */
 
class EV_objID {
//friend class EV_event;
friend class EV_handler;    // XXXX temp for testing
friend class EV_msg;
friend class EV_clnt_msg;
friend class EV_srvr_msg;
public:
    EV_objID(char *n = NULL,  char *a = NULL,  char *m = NULL);
    ~EV_objID(void);
    void setName(char *);
    void setAddr(char *);
    void setMACAddr(char *);
    char *getName(void);
    char *getAddr(void);
    char *getMACAddr(void);
protected:
    char *name;
    char *addr;
    char *MACAddr;
};

/*
 * Used to automatically fill in the source host of an event
 */
class EV_localHost : public EV_objID{
friend class EV_event;
friend class EV_handler;
private:
    EV_localHost(void);
    ~EV_localHost(void);
};

/*
 * Used by the event library to determine whether the user is the event server
 * and to make sure it gets the pid for the app.
 */
class EV_application{
friend class  EV_handler; 
public:
    char *getAppName(void);
    char *getUserName(void);
    inline pid_t getPID(void);
    inline uid_t getUID(void);
private:
    char *appName;
    pid_t pid;
    uid_t uid;
    char *userName;
    EV_application(void);
    EV_application(char *n);
    ~EV_application(void);
    void setAppName(char *);
    void setUserName(char *);
};

/*
 * class EV_data
 *  This class defines the common event data that all event types share.
 *  The filter should be supplied by the 
 *  application so that the event can be place in context. otherData is
 *  an arbitrary string that the application can inlcude in the event.
 */

class EV_data {
public:
    EV_data(void);
    ~EV_data(void);
    void setFilter(char *);
    void setOtherData(char *);
    char *getFilter (void);
    char *getOtherData (void);
protected:
    char *filter;
    EV_objID interface;
    char *otherData;
};

/*
 * class EV_obj_detect
 *  This class defines the content of object detection events.
 *  The application fills in only the necessary objects that triggered
 *  the event. 	
 */

enum objectType {
    OBJ_OTHER,	    // user EV_data::otherData to describe
    OBJ_NODE, 
    OBJ_NET, 
    OBJ_CONVERSE, 
    OBJ_PROTO
};

class EV_obj_detect : public virtual EV_data {
friend class EV_handler;    // XXXX temp for testing
public:
    EV_obj_detect(void);
    EV_obj_detect(objectType);
    inline void setObjType (objectType);    // used for internal consistency
    inline void setBytes(uint);		// for the CONVERSE_STOP events
    inline void setPkts(uint);		// for the CONVERSE_STOP events
    void setProto(char *protocol);
    inline uint getBytes(void);		// for the CONVERSE_STOP events
    inline uint getPkts(void);		// for the CONVERSE_STOP events
    inline objectType getObjType(void);
    char *getProto(void);
protected:
    char *protocol;
    objectType	objType;
    EV_objID node;
    EV_objID net;
    EV_objID pair1;
    EV_objID pair2;
    uint converseBytes;
    uint conversePkts;
};

typedef float rateType;

enum rateBase {
    BYTE_BASED, 
    PACKET_BASED, 
    PERCENT_UTIL, 
    PERCENT_BYTES, 
    PERCENT_PKTS, 
    PERCENT_N_BYTES, 
    PERCENT_N_PKTS
};

/*
 * class EV_rate
 *  This class defines the data for rate-based events. For the event
 *  the application fills in the rate and the threshold and rate "units".
 */
 
typedef char *objectList;  //XXXX to be changed to list of EV_objIDs

class EV_rate : public virtual EV_data {
public:
    EV_rate(void);
    EV_rate(rateType currentRate,  rateType threshold,  
	    rateBase ratebase, rateType bofrate, objectList *olist = NULL);
   ~EV_rate(void);
    inline void setRate (rateType);
    inline void setThreshRate (rateType);
    inline void setRateBase (rateBase);
    inline void setRateOfBase(rateType);   
    void setTopNList (objectList *);
    inline rateType getRate (void);
    inline rateType getThreshRate (void);
    inline rateBase getRateBase (void);
    inline rateType getRateOfBase(void);
//    objectList *getTopNList (void);
protected:
    rateType rate;
    rateType thresholdRate;
    rateBase base;
    rateType baseRate;			// e.g. for %N-bytes or %N-packets
    objectList *topNList;   
};

/*
 * class EV_event
 *  This class fully defines the events as the application uses them.
 *  It is required that the eventType is supplied upon instantiation. This
 *  is the class that provides the application interface to event data.
 */
 
typedef time_t	EV_timeStamp;
 
class EV_event : public EV_obj_detect,  public EV_rate{
friend class EV_handler;    
friend class EV_msg;
friend class EV_clnt_msg;
friend class EV_srvr_msg;
friend class EV_logger;
public:
    EV_event(void);
    // startup, shutdown, and snoop events
    EV_event(const eventID, EV_objID *interface = NULL, 
	     char *flt = NULL);
    EV_event(const eventID, char  *interface, 
	     char *flt = NULL);
    // object detection events
    EV_event(const eventID, objectType, EV_objID *interface = NULL,
	     char *flt = NULL, EV_objID *node=NULL, EV_objID *net = NULL, 
	     EV_objID *n1 = NULL,  EV_objID *n2 = NULL,
	     uint bytes = 0, uint pkts = 0, char *proto = NULL);
    EV_event(const eventID, objectType, char *interface,
	     char *flt = NULL, char *node=NULL, char *net = NULL, 
	     char *n1 = NULL,  char *n2 = NULL,
	     uint bytes = 0, uint pkts = 0, char *proto = NULL);
    // rate events
    EV_event(const eventID, float rt, float thresh,  rateBase rbase, 
	     rateType bofrate = 0.0, EV_objID *intrfce = NULL, 
	     char *flt = NULL, objectList *olist = NULL);  
    EV_event(const eventID, float rt, float thresh,  rateBase rbase, 
	     rateType bofrate = 0.0, char *intrfce = NULL, 
	     char *flt = NULL, objectList *olist = NULL);  
    ~EV_event(void);
    inline void setType(const eventID);
    void setNodeName(char *);
    void setNodeAddr(char *);
    void setNodeMACAddr(char *);
    void setNetName(char *);
    void setNetAddr(char *);
    void setInterfaceName(char *);
    void setInterfaceAddr(char *);
    void setEndPt1Name (char *);
    void setEndPt1Addr (char *);
    void setEndPt1MACAddr (char *);
    void setEndPt2Name (char *);
    void setEndPt2Addr (char *);
    void setEndPt2MACAddr (char *);
    inline const eventID getType(void);
    inline EV_timeStamp getTimeStamp(void);
    inline EV_level getAlarmLevel(void);
    char *getSrcApp (void);
    inline pid_t getPID (void);
    char *getUserName (void);
    inline int getUID (void);
    char *getSrcHostName (void);
    char *getSrcHostAddr (void);
    char *getNodeName(void);
    char *getNodeAddr(void);
    char *getNodeMACAddr(void);
    char *getNetName(void);
    char *getNetAddr(void);
    char *getInterfaceName(void);
    char *getInterfaceAddr(void);
    char *getEndPt1Name (void);
    char *getEndPt1Addr (void);
    char *getEndPt1MACAddr (void);
    char *getEndPt2Name (void);
    char *getEndPt2Addr (void);
    char *getEndPt2MACAddr (void);
    inline objectList *getTopNodes(void);
    void dump(FILE *fd = stdout);
protected:
    eventID		evType; 
    EV_objID		srcHost;
    char		*srcApp;
    pid_t		pid;
    char		*userName;
    int			uid;
    EV_timeStamp	timeSent;
    EV_level		alarmLevel;
    void setUserName (char *n);
    void setSrcApp (char *n);
};

/*
 * EV_handler class is the class the application uses to send, and receive 
 * events and to get the file descriptor for event I/O
 */
typedef int EV_handle;

class EV_handler : public EV_application{
friend class EV_server;
public:
    EV_handler (EV_handle *h, char *app, struct timeval *timeout = NULL);
    ~EV_handler (void);    
    void reg (const eventID event);       // want to handle this event
    void unregister (const eventID event); // don't want to see this event
    EV_stat send (EV_event *event);
    EV_stat receive (EV_event *event);
protected:
    char regList[NV_MAX_EVENT + 1];    
    EV_localHost localHost;
private:
    static EV_handle handle;
    EV_msg *msg;
    char noSendList[NV_MAX_EVENT + 1];
    void setNoSends(char *noSends);
};

//  inline public function definitions

pid_t
EV_application::getPID (void) {
    return (pid);
}

uid_t
EV_application::getUID (void) {
    return (uid);
}


// Detection events

void
EV_obj_detect::setObjType (objectType obj) {
    objType = obj;
}

void
EV_obj_detect::setBytes(uint b) {
    converseBytes = b;
}

void
EV_obj_detect::setPkts (uint p) {
    conversePkts = p;
}


objectType
EV_obj_detect::getObjType() {
    return (objType);
}

uint
EV_obj_detect::getBytes (void) {
    return (converseBytes);
}

uint
EV_obj_detect::getPkts (void) {
    return (conversePkts);
}

// Rate Events

void
EV_rate::setRate (rateType r) {
    rate = r;
}

void
EV_rate::setThreshRate(rateType t) {
    thresholdRate = t;
}

void
EV_rate::setRateBase (rateBase rbase) {
    base = rbase;
}

void
EV_rate::setRateOfBase(rateType bofrate) {
    baseRate = bofrate;
}

rateType 
EV_rate::getRate (void) {
    return (rate);
}

rateType
EV_rate::getThreshRate (void) {
    return (thresholdRate);
}

rateBase
EV_rate::getRateBase (void) {
    return (base);
}

rateType
EV_rate::getRateOfBase(void) {
    return(baseRate);
}

void
EV_event::setType(const eventID id) {
   evType = id; 
}

const eventID
EV_event::getType(void) {
    return (evType);
}

EV_timeStamp
EV_event::getTimeStamp(void) {
    return (timeSent);
}

EV_level
EV_event::getAlarmLevel(void) {
    return (alarmLevel);
}

pid_t
EV_event::getPID() {
    return (pid);
}

int
EV_event::getUID() {
    return (uid);
}

objectList *
EV_event::getTopNodes (void) {
    return (topNList);
}

#endif 
