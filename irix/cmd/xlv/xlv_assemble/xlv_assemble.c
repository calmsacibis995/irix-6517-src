/**************************************************************************
 *                                                                        *
 *            Copyright (C) 1993-1994, Silicon Graphics, Inc.             *
 *                                                                        *
 *  These coded instructions, statements, and computer programs  contain  *
 *  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
 *  are protected by Federal copyright law.  They  may  not be disclosed  *
 *  to  third  parties  or copied or duplicated in any form, in whole or  *
 *  in part, without the prior written consent of Silicon Graphics, Inc.  *
 *                                                                        *
 **************************************************************************/
#ident "$Revision: 1.75 $"
/*
 * Driver routine to locate all XLV volumes on system.
 */
#include <stdio.h>
#include <stdlib.h>
#include <syslog.h>
#include <errno.h>
#include <stdarg.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <bstring.h>
#include <diskinfo.h>
#include <fcntl.h>
#include <string.h>
#include <sys/debug.h>
#include <sys/syssgi.h>
#include <sys/major.h>
#include <sys/sysmacros.h>
#include <sys/uuid.h>
#include <sys/xlv_base.h>
#include <sys/xlv_tab.h>
#include <sys/xlv_vh.h>
#include <sys/xlv_attr.h>
#include <pathnames.h>
#include <diskinvent.h>
#include <xlv_oref.h>
#include <xlv_lab.h>
#include <xlv_plexd.h>
#include <xlv_utils.h>		/* for XLV_DEV_* pathname constants */
#include <xlv_cap.h>

#define	XLV_ASSEMBLE_SUCCESS		0
#define	XLV_ASSEMBLE_FAILED		1
#define	XLV_ASSEMBLE_NEED_PLEXD		2
#define XLV_ASSEMBLE_SELECT_FAILED	3
int exitcode;

static xlv_vh_entry_t	*xlv_vh_list = NULL;

/*
 * We need to goto .. because the base path is /dev/dsk/xlv or
 * /dev/rdsk/xlv and we want the nodes created in /dev/dsk and
 * /dev/rdsk. (They need to be at the top level directories because
 * certain scripts expect to find them there.
 *
 * /etc/bcheckrc, via devnm(1m), looks at these nodes to
 * set /dev/root and /dev/rroot 
 */
#define XLV_RSVD_ROOT_VOL_NAME	"/dev/xlv_root"

/*
 * The root volume header is generated by subsituting "vh" for the
 * last two chars (which would have been the partition number s0) from
 * the root volume name. This is the way inst(1m) does it, so this is
 * need for installation onto the disk volume header.
 */
#define XLV_RSVD_ROOT_VH_NAME	"/dev/xlv_rovh"

#define	_PATH_ROOT_VOLHDR	"/dev/rvh"
#define _PATH_ROOT_VOL          "/dev/root"
#define _PATH_RROOT_VOL         "/dev/rroot"

/* if rootvol:
 *   creat block dev's for /dev/root /dev/xlv_root  192,0
 *   create char symlinks for /dev/rvh and /dev/xlv_rovh -> actual disk
 */

/*
 * Option flags
 */
static int	f_kernel = 1;		/* set kernel configuration */
static int	f_plex_revive = 1;
static int	f_local = 1;		/* assemble locally created volumes */
static int	f_quiet = 0;
static int	f_terse = 0;
static int	f_verbose = 0;
static int	f_full_revive = 0;	/* always revive from one ve */
static char	*nodename = NULL;
static char	*rootname = NULL;


static void
errprintf(char *fmt, ...)
{
	va_list args;

	va_start(args, fmt);
	vfprintf(stderr, fmt, args);
	va_end(args);
}


static void
slog(int priority, char *msg, void *arg)
{
        openlog("xlv_assemble", LOG_PID|LOG_NOWAIT|LOG_CONS|LOG_PERROR,
		LOG_USER);
        syslog(LOG_USER | priority, msg, arg);
        closelog();
}


static void
usage(void)
{
#define	emsg(msg)	fprintf(stderr, msg)

	emsg("usage: xlv_assemble [-h nodename] [-alnq] [-r root] "
		"[-s select-list] [-tvKP]\n");
	emsg("\t-a         Use all volumes - opposite of the -l option .\n");
	emsg("\t-f         Perform a full revive of all volumes.\n");
	emsg("\t-h host    Use ""host"" as the local nodename.\n");
	emsg("\t-l         Only use volume that were made on this system.\n");
	emsg("\t-n         Nop; don't write to kernel.\n");
	emsg("\t-q         Be quiet and don't display status messages.\n");
	emsg("\t-r root    Use ""root"" as the root directory.\n");
	emsg("\t-s list    Selectively assemble the comma separated "
			   "list of volumes\n");
	emsg("\t-t         Display terse status messages.\n");
	emsg("\t-v         Display verbose status messages.\n");
	emsg("\t-K         Don't write configuration to Kernel driver.\n");
	emsg("\t-P         Don't initiate plex revives.\n");
	exit(1);

#undef	emsg
}


/*
 * Definitions needed for creating a bit mask to correspond
 * to the presence or absence of XLV subvolume devices.
 */
#define SVWORDS		20
#define	BITSPERWORD	32			/* 0-31, 32-63, 64-95, ... */
#define	NSVS		(SVWORDS*BITSPERWORD)	/* num of subvols supported */
#define MAXSV		(NSVS-1)
#define	ksvword(n)	((n)/BITSPERWORD)

typedef struct {
	__uint32_t bits[SVWORDS];     /* max of 320 subvol's (0 - 319) */
} ksvset_t;

#define ksvmask(n)       (1L<<((n)%BITSPERWORD))
#define ksvaddset(s,i)   ((void)((s)->bits[ksvword(i)] |= ksvmask(i)))
#define ksvdelset(s,i)   ((void)((s)->bits[ksvword(i)] &= ~ksvmask(i)))

/*
 * Check if the given subvolume number is in the given subvolume set.
 * Examine the bit corresponding to the subvol number.
 */
static unsigned
ksvismember (ksvset_t *set, int sv)
{
	unsigned	ismember;

	if (set == 0) {			/* cannot be a member of a null set */
		ismember = 0;
	} else if (sv > MAXSV) {	/* limitation of data structure */
		ismember = 0;
	} else {
		ismember = set->bits[ksvword(sv)] & ksvmask(sv);
	}
	return (ismember);
} /* end of ksvismember() */


/*
 * Create the subvolume set for the kernel. Enumerate the subvolumes
 * in the kernel and set the corresponding bit in the set mask for each
 * subvolume dev_t.
 */
static ksvset_t *
make_ksvset (void)
{
	ksvset_t		*set;
	xlv_tab_subvol_t	*svp;
	xlv_attr_req_t		req;
	xlv_attr_cursor_t	cursor;
	int			st;

	if (f_full_revive == 1)
		return (NULL);
	
	set = malloc(sizeof(ksvset_t));
	bzero(set, sizeof(ksvset_t));
	if (set == NULL) {
		printf("Cannot malloc a subvol set; doing full revive.\n");
		goto done;
	}

	if (0 > syssgi(SGI_XLV_ATTR_CURSOR, &cursor)) {
		printf("Failed to get a XLV cursor; doing full revive.\n");
		free(set);
		set = NULL;
		goto done;
	}

	if (NULL == (svp = get_subvol_space())) {
		printf("Cannot malloc a subvolume entry; doing full revive.\n");
		free(set);
		set = NULL;
		goto done;
	}

	req.attr = XLV_ATTR_SUBVOL;
	req.ar_svp = svp;

	st = 0;
	while (st == 0) {
		st = syssgi(SGI_XLV_ATTR_GET, &cursor, &req);
		if (st < 0) {
			int err = oserror();
			if (ENFILE != err && ENOENT != err)
				perror("syssgi(SGI_XLV_ATTR_GET) failed.");
		} else {
			ksvaddset(set, minor(svp->dev));
		}
	}

done:
	return (set);

} /* end of make_ksvset() */

static void
make_xlv_device_dir(void)
{
	int		i;
	struct stat	buf;
	char		msg[1024];
	char		*dir[2] = {XLV_DEV_BLKPATH, XLV_DEV_RAWPATH};
	mode_t		mode = S_IRWXU|S_IRWXG|S_IROTH|S_IXOTH;
	char		dev_path[XLV_MAXDEVPATHLEN];

	/*
	 * Make sure the XLV device directories exist.
	 */
	for (i=0; i < 2; i++) {

		xlv_root_pathname(dev_path, dir[i]);

		if (stat(dev_path, &buf) < 0) {
			if (ENOENT != oserror()) {
				sprintf(msg, "Cannot access %s", dev_path);
				goto error;
			}
			if ( 0 > mkdir(dev_path, mode)) {
				sprintf(msg, "Cannot create %s", dev_path);
				goto error;
			}
		}
	}
	return;

error:
	perror(msg);
	exit(1);
}


/*
 * Create a volume header for the root volume. The volume header
 * should be the volume header of the primary root disk device.
 *
 * Note that this is not the same as a logical volume header.
 */
static void
make_xlv_root_vh(xlv_tab_t	*xlv_tab)
{
	xlv_tab_subvol_t	*svp;
	xlv_tab_plex_t		*plexp;

	int	i;
	int	method;
	dev_t	nulldev;
	dev_t	rootdisk;	/* root disk device */
	dev_t	vhdev;		/* volume header dev_t */
	dev_t	tmpdev;
	char    devpath[MAXPATHLEN];
	int     devpathlen = sizeof(devpath);

	svp = &xlv_tab->subvolume[XLV_TAB_UUID_BOOT_DATA];
	if (! XLV_SUBVOL_EXISTS(svp)) {
		/*
		 * No root volume so don't bother making the volume header.
		 */
		return;
	}

	nulldev = makedev(0, 0);

	/* 
	 * Find the root disk device using the following methods.
	 * Stop when the device is found.
	 *
	 * (1) Get root device from kernel.
	 * (2) Stat "/dev/rvh" and compare st_rdev with the dev_t's of
	 *     the root volume plexes. One of the root plex should be
	 *     using that disk device.
	 * (3) Use the first plex's disk device.
	 */

	/*
	 * Method 1 - Get the root device directly from the kernel.
	 */
	rootdisk = xlv_get_rootdevice();
	if (nulldev != rootdisk) {
		method = 1;
		goto mknodes;
	}

        /*
         * Method 2 - Use existing device node /dev/rvh
         */
        rootdisk = name_to_dev(_PATH_ROOT_VOLHDR);
        if (nulldev != rootdisk) {
                for (i = 0; i < svp->num_plexes; i++) {
                        plexp = svp->plex[i];
                        if (plexp == NULL)
                                continue;
                        ASSERT(plexp->num_vol_elmnts == 1);
                        ASSERT(plexp->vol_elmnts[0].grp_size == 1);
                        tmpdev = DP_DEV(plexp->vol_elmnts[0].disk_parts[0]);
                        if (rootdisk == tmpdev) {
                                method = 2;
                                goto mknodes;
                        }
                }
                /* No match */
        }

	/*
	 * Method 3 - First root plex disk.
	 */
	for (i = 0; i < svp->num_plexes; i++) {
		plexp = svp->plex[i];
		if (NULL == plexp)
			continue;
		ASSERT(plexp->num_vol_elmnts == 1);
		ASSERT(plexp->vol_elmnts[0].grp_size == 1);
		tmpdev = DP_DEV(plexp->vol_elmnts[0].disk_parts[0]);
		rootdisk = tmpdev;
		method = 3;
		goto mknodes;
	}

	/* unable to find primary root plex partition? */
	printf("xlv_assemble: unable to determine root plex, "
	       "/dev/rvh and /dev/xlv_rovh will not be set\n");
	return;

	/*
	 * Got the disk so create the volume header device nodes.
	 */
mknodes:
	if (dev_to_partpath(rootdisk, DSK_PART_VH,
			    S_IFCHR, devpath, &devpathlen, NULL) == NULL) {
		perror("xlv_assemble: unable to create root device entries in /dev");
		exit(1);
	}

	if (!f_quiet && f_verbose) {
		char *str;
		switch(method) {
		    case 1:
			str = "root disk device";
			break;
		    case 2:
			str = _PATH_ROOT_VOLHDR;
			break;
		    case 3:
			str = "first root plex disk device";
			break;
		}
		printf("xlv_assemble: Setting xlv root vh to %s (0x%x)\n",
			str, vhdev);
	}

	/* unlink & create "/dev/xlv_rovh" */
	unlink(XLV_RSVD_ROOT_VH_NAME);
	if (symlink(devpath, XLV_RSVD_ROOT_VH_NAME) == -1)
		perror("xlv_assemble: unable to create " XLV_RSVD_ROOT_VH_NAME);

	/* unlink & create "/dev/rvh" */
	unlink(_PATH_ROOT_VOLHDR);
	if (symlink(devpath, _PATH_ROOT_VOLHDR) == -1)
		perror("xlv_assemble: unable to create " _PATH_ROOT_VOLHDR);

	/*
	 * Create the reserved devices for the root volume. This always
	 * has the minor number of 0.
	 * Note: the nodename for the root volume is always NULL.
         *
         * XLV devices are still 'old style' dev_t's so we can create
         * the nodes directly.  No need to use the hwg. 
	 */
	/* create "/dev/xlv_root" */
	unlink(XLV_RSVD_ROOT_VOL_NAME);
	if (cap_mknod(XLV_RSVD_ROOT_VOL_NAME,
		      S_IFBLK|S_IRUSR|S_IWUSR, makedev(XLV_MAJOR, 0)) < 0) 
		perror("xlv_assemble: unable to create" XLV_RSVD_ROOT_VOL_NAME); 
	/* create "/dev/root" */
	unlink(_PATH_ROOT_VOL);
	if (cap_mknod(_PATH_ROOT_VOL, S_IFBLK|S_IRUSR|S_IWUSR, makedev(XLV_MAJOR, 0)) < 0)
		perror("xlv_assemble: unable to create" _PATH_ROOT_VOL);

	/* create "/dev/rroot" */
	unlink(_PATH_RROOT_VOL);
	if (cap_mknod(_PATH_RROOT_VOL, S_IFCHR|S_IRUSR|S_IWUSR, makedev(XLV_MAJOR, 0)) < 0)
		perror("xlv_assemble: unable to create" _PATH_RROOT_VOL);


} /* end of make_xlv_root_vh() */


/*
 * Make an xlv_tab_vol dense, starting at the gap pointed to by
 * empty_vol_p.
 * This routine will also adjust any required pointers in xlv_tab.
 */
static void
xlv_tab_compact_vol (xlv_tab_vol_t   		*xlv_tab_vol,
		     xlv_tab_vol_entry_t	*empty_vol_p)
{
	xlv_tab_vol_entry_t     *vol_p;
	unsigned		empty_vol_index, num_vol_entries_to_move, v;

	empty_vol_index = empty_vol_p - xlv_tab_vol->vol;
	num_vol_entries_to_move = xlv_tab_vol->max_vols - (empty_vol_index+1);
	if (num_vol_entries_to_move > 0) {
		bcopy (&xlv_tab_vol->vol[empty_vol_index+1],
		       empty_vol_p,
		       num_vol_entries_to_move * sizeof(xlv_tab_vol_entry_t));
	}

	/*
	 * Now zero out the last entry. It's been shifted up.
	 */
	bzero (&xlv_tab_vol->vol[xlv_tab_vol->max_vols-1],
	       sizeof(xlv_tab_vol_entry_t));

	/*
	 * Go through the current set of volumes and adjust all the vol_p
	 * pointers of their subvolumes.
	 */
	for (v = empty_vol_index; v < xlv_tab_vol->num_vols; v++) {
		vol_p = &xlv_tab_vol->vol[v];
		ASSERT (vol_p);
		if (vol_p->log_subvol) 
			vol_p->log_subvol->vol_p = vol_p;
		if (vol_p->data_subvol) 
			vol_p->data_subvol->vol_p = vol_p;
		if (vol_p->rt_subvol) 
			vol_p->rt_subvol->vol_p = vol_p;

	}
}


/*
 * Handle the final filtering of the the xlv_vol_tab.  The
 * algorithm works as follows:
 * Keep those items currently in the kernel (which have valid disk labels).
 * Keep those items in the select list.
 * Create devices for complete volumes we're passing to the kernel.
 */
void
selective_assemble(xlv_tab_vol_t *xlv_tab_vol, xlv_tab_t *xlv_tab,
		   char *selectlist, ksvset_t *ksvlist)
{
#define NSELECT_ENTRIES		1023
	char 			*select[NSELECT_ENTRIES+1];
	xlv_tab_vol_entry_t	*vol_p;
	dev_t 			dev;
	int			nselect, i, v, ksv;
	boolean_t		selected, localvol, bad;

	v = 0;

	if (NULL == selectlist) {
		/* Not selective assemble */
		i = 0;
		select[0] = NULL;
	} else {
		for (i = 0; i < NSELECT_ENTRIES; i++) {
			select[i] = strtok(selectlist, ",");
			selectlist = NULL;
	
			if (select[i] == NULL)
				break;
		}
	}

	if (i == NSELECT_ENTRIES) {
		fprintf(stderr, "WARNING: only first %d volumes specified"
				"for selective assemble will be processed\n",
			NSELECT_ENTRIES);

		/* ensure loop termination later */
		select[i] = NULL;
	}

	/* we've selected this many specific items to assemble */
	nselect = i;

	while (v < xlv_tab_vol->num_vols) {

		bad = B_FALSE;
		selected = B_FALSE;
		vol_p = &xlv_tab_vol->vol[v];
		localvol = xlv_local_volume(vol_p);

		for (i = 0; select[i]; i++) {
			if (strcmp(select[i], vol_p->name) == 0) {
				selected = B_TRUE;
				nselect--;
				break;
			}
		}

		/* everyone needs a data subvol */
	    	ASSERT(vol_p->data_subvol);

		dev = vol_p->data_subvol->dev;
	    	ksv = ksvismember(ksvlist, minor(dev));

		if (select[0]) {
			/* if not selected and not part of the kernel */
			if (!selected && !ksv)
				bad = B_TRUE;
		} else if (f_local && !ksv) {
			/* not a local vol and not already part of the kernel*/
			if (!localvol)
				bad = B_TRUE;
		}

		if (bad) {
			if (!f_quiet) {
				errprintf (
				"Removing XLV Volume \"%.*s\" : not local\n",
					sizeof(xlv_name_t), vol_p->name);
			}
			xlv_remove_vol(xlv_tab_vol, v);
			/* don't increment and do this slot again */ 
		} else {
			/* create device if sending this config to the kernel*/
			if (f_kernel) {
				char *owner = (localvol ? NULL : 
							  vol_p->nodename);

				xlv_create_node_pair(vol_p->name, owner,
							dev, xlv_tab);
			}
			v++;
		}
	}

	/* at least one select entry failed */
	if (nselect != 0)
		exitcode = XLV_ASSEMBLE_SELECT_FAILED;

	return;

} /* end of selective_assemble() */

/*
 * Go through the xlv_tab and xlv_tab_vol and disable any volumes that
 * are plexed.
 */
static void
disable_plexed_volumes (xlv_tab_vol_t	*xlv_tab_vol,
			xlv_tab_t       *xlv_tab)
{
        unsigned int            sv;
        xlv_tab_subvol_t        *xlv_p;
	xlv_tab_vol_entry_t	*vol_p;

        for (sv=0; sv < xlv_tab->max_subvols; sv++) {
                xlv_p = &xlv_tab->subvolume[sv];
                if (XLV_SUBVOL_EXISTS(xlv_p) && xlv_p->num_plexes > 1) {

			vol_p = xlv_p->vol_p;
			slog(LOG_ERR,
		"System not licensed for Disk Plexing Option.", NULL);
			slog(LOG_ERR,
		"Disabling plexed volume: %.14s.", vol_p->name);
			slog(LOG_ERR,
		"Please check nodelock license at %s/etc/flexlm/license.dat.",
			(rootname) ? rootname : "");

			if (vol_p->log_subvol) {
				bzero (vol_p->log_subvol,
				       sizeof(xlv_tab_subvol_t));
				xlv_tab->num_subvols--;
			}
			if (vol_p->data_subvol) {
                                bzero (vol_p->data_subvol,
                                       sizeof(xlv_tab_subvol_t));
                                xlv_tab->num_subvols--;
                        }
			if (vol_p->rt_subvol) {
                                bzero (vol_p->rt_subvol,
                                       sizeof(xlv_tab_subvol_t));
                                xlv_tab->num_subvols--;
                        }

			bzero (vol_p, sizeof(xlv_tab_vol_entry_t));
			xlv_tab_vol->num_vols--;

			/*
			 * XLV assumes that xlv_tab_vol (unlike xlv_tab)
			 * is dense. So we need to compact the table
			 * and adjust any xlv_tab entries that point to
			 * it.
			 */
			xlv_tab_compact_vol (xlv_tab_vol, vol_p);
                }
        }
}


static void
print_vol_name(xlv_tab_vol_t *tab)
{
	xlv_tab_vol_entry_t	*vol;
	unsigned		v;

	for (v = 0, vol = tab->vol; v < tab->num_vols; v++, vol++) {
		printf ("XLV Volume \"%.*s\" [%s]\n",
			sizeof(xlv_name_t),
			vol->name,
			xlv_vol_state_str((unsigned int) vol->state));
	}
}


/*
 * Go through all the subvolumes and initiate plex revives where
 * necessary. Note that we will continue trying to revive other subvolumes 
 * even if we encounter an error with one subvolume.
 */
static int
initiate_plex_revives (xlv_tab_t        *xlv_tab)
{
        unsigned int            sv;
        int                     return_code;
        xlv_tab_subvol_t        *xlv_p;

        return_code = 0;
        for (sv=0; sv < xlv_tab->max_subvols; sv++) {
                xlv_p = &xlv_tab->subvolume[sv];
                if (XLV_SUBVOL_EXISTS(xlv_p) && xlv_p->num_plexes > 1) {
                        if (xlv_tab_revive_subvolume (xlv_p)) {
                perror ("xlv_assemble: unable to initiate plex revive");
                                return_code = -1;
                        }
                        
                }
        }
        return return_code;
}


/*
 * Count the number of subvolumes with mirrors.
 */
static int
mirrored_subvol(xlv_tab_t	*xlv_tab)
{
	unsigned		sv;
	int			mirrors;
	xlv_tab_subvol_t	*xlv_p;

	mirrors = 0;
	for (sv=0; sv < xlv_tab->max_subvols; sv++) {
		xlv_p = &xlv_tab->subvolume[sv];
		if (XLV_SUBVOL_EXISTS(xlv_p) && xlv_p->num_plexes > 1) {
			mirrors++;
		}
	}
	return mirrors;
}

/*
 * Shrink the xlv_tab_vol and xlv_tab so that it reflects only
 * the number of entries actually required for the current 
 * configuration. Note that this operation preserves gaps.
 */
static void
shrink_xlv_tab (xlv_tab_vol_t	*xlv_tab_vol,
		xlv_tab_t	*xlv_tab)
{
	int		i;
	unsigned	st;

	for (i = xlv_tab_vol->max_vols-1; i >= 0; i--) {
		if (! uuid_is_nil (&xlv_tab_vol->vol[i].uuid, &st)) {
			xlv_tab_vol->max_vols = i+1;
			break;
		}
	}

	for (i = xlv_tab->max_subvols-1; i >= 0; i--) {
		if (XLV_SUBVOL_EXISTS (&xlv_tab->subvolume[i])) {
			xlv_tab->max_subvols = i+1;
			break;
		}
	}
}


/*
 * Compare two volume element's states. Pick the one that should be
 * active. Change any "older" active ve to stale state.
 *
 * Return value:
 *	-1 = neither volume element is good
 *	 0 = both volume elmements are good
 *	 1 = vol element 1 is better; ve 2 is stale (from active) or empty
 *	 2 = vol element 2 is better; ve 1 is stale (from active) or empty
 *
 * Never choose volume elements with state "offline" or "incomplete".
 * When comparing a volume element in "offline" or "incomplete" state,
 * always pick the other volume element.
 *
 *	 4   (100) = Pick one depending on timestamp. The one picked is
 *		     active and the other is stale. If the timestamps
 *		     are the same, pick both.
 *	 4+1 (101) = Pick one depending on timestamp. If the timestamps
 *		     are the same, pick vol element 1. The one picked is
 *		     active and the other is stale.
 *	 4+2 (110) = Pick one depending on timestamp. If the timestamps
 *		     are the same, pick vol element 2.
 *	 8+1 (1001) = Pick vol element 1 and mark it active
 *	 8+2 (1010) = Pick vol elmemnt 2 and mark it active
 */
static int
ve_state_cmp (
	xlv_tab_vol_elmnt_t *vep1,
	xlv_tab_vol_elmnt_t *vep2,
	int ksv)			/* this subvolume is in the kernel */
{
	static int state_array[6][6] = {
	/*      vep2  |   empty  clean  active  stale  offline  incomplete */
	/* vep1|---------------------------------------------------------- */
	/* empty      */ { -1,   8+2,      2,     -1,      1,         1  },
	/* clean      */ {8+1,     4,    4+1,    8+1,    8+1,         1  },
	/* active     */ {  1,   4+2,    4+1,      1,      1,         1  },
	/* stale      */ { -1,   8+2,      2,     -1,     -1,         1  },
	/* offline    */ {  2,   8+2,      2,     -1,     -1,        -1  },
	/* incomplete */ {  2,     2,      2,      2,     -1,        -1  },
	};

	int	retvalue;
	int	action;

ASSERT(XLV_VE_STATE_EMPTY == 0);
ASSERT(XLV_VE_STATE_CLEAN == 1);
ASSERT(XLV_VE_STATE_ACTIVE == 2);
ASSERT(XLV_VE_STATE_STALE == 3);
ASSERT(XLV_VE_STATE_OFFLINE == 4);
ASSERT(XLV_VE_STATE_INCOMPLETE == 5);

	if (vep1 && vep2)
		action = state_array [(unsigned)vep1->state]
				     [(unsigned)vep2->state];
	else if (!vep1)
		action = state_array [(unsigned)XLV_VE_STATE_EMPTY]
				     [(unsigned)vep2->state];
	else /* !vep2 */
		action = state_array [(unsigned)vep1->state]
				     [XLV_VE_STATE_EMPTY];

	switch (action) {
	case -1:
		retvalue = -1;
		break;
        case 1:
                vep1->state = XLV_VE_STATE_ACTIVE;
                retvalue = 1;
                break;
        case 2:
                vep2->state = XLV_VE_STATE_ACTIVE;
                retvalue = 2;
                break;
	case 4:
		if (vep1->veu_timestamp == vep2->veu_timestamp) {
			vep1->state = XLV_VE_STATE_ACTIVE;
			vep2->state = XLV_VE_STATE_ACTIVE;
			retvalue = 0;
		} else if (vep1->veu_timestamp > vep2->veu_timestamp) {
			vep1->state = XLV_VE_STATE_ACTIVE;
			vep2->state = XLV_VE_STATE_STALE;
			retvalue = 1;
		} else {
			vep1->state = XLV_VE_STATE_STALE;
			vep2->state = XLV_VE_STATE_ACTIVE;
			retvalue = 2;
		}
		break;
	case 4+1:
		if (vep1->veu_timestamp == vep2->veu_timestamp) {
			/*
			 * If this volume is in the kernel then both
			 * ve's are truly active so don't change their
			 * states on the xlv disk labels.
			 *
			 * However, if this volume is new, choose one
			 * ve to be active.
			 */
			if (ksv == 0) {
				/*
				 * Subvolume is not in the kernel
				 * so we got to chose one.
				 *
				 * XXX For consistency, always pick the one
				 * with the lowest uuid. Of course this
				 * change must also be made in the kernel.
				 *
				 * uint_t st;
				 *
				 * if (uuid_compare(&vep1->uuid,
				 *		    &vep2->uuid, &st) < 1)
				 *	pick vep1
				 * else
				 *	pick vep2
				 */
				vep1->state = XLV_VE_STATE_ACTIVE;
				vep2->state = XLV_VE_STATE_STALE;
			}
			retvalue = 1;
		} else if (vep1->veu_timestamp > vep2->veu_timestamp) {
                        vep1->state = XLV_VE_STATE_ACTIVE;
                        vep2->state = XLV_VE_STATE_STALE;
                        retvalue = 1;
                } else {
                        vep1->state = XLV_VE_STATE_STALE;
                        vep2->state = XLV_VE_STATE_ACTIVE;
                        retvalue = 2;
                }
                break;
	case 4+2:
		ASSERT(vep1->state == XLV_VE_STATE_ACTIVE);
		if (vep1->veu_timestamp == vep2->veu_timestamp) {
			/*
			 * vep1->state == XLV_VE_STATE_ACTIVE
			 * vep1->state == XLV_VE_STATE_CLEAN
			 *
			 * Ve 1 must have been transitioned from the
			 * clean state. This is the case when there
			 * are more two mirrors for the ve. 
			 */
			ASSERT(vep2->state == XLV_VE_STATE_CLEAN);
			vep2->state = XLV_VE_STATE_ACTIVE;
                        retvalue = 2;
		} else if (vep1->veu_timestamp < vep2->veu_timestamp) {
                        vep1->state = XLV_VE_STATE_STALE;
                        vep2->state = XLV_VE_STATE_ACTIVE;
                        retvalue = 2;
                } else {
                        vep1->state = XLV_VE_STATE_ACTIVE;
                        vep2->state = XLV_VE_STATE_STALE;
                        retvalue = 1;
                }
                break;
	case 8+1:
		vep1->state = XLV_VE_STATE_ACTIVE;
		retvalue = 1;
		break;
	case 8+2:
		vep2->state = XLV_VE_STATE_ACTIVE;
		retvalue = 2;
		break;
	default:
		ASSERT (0);
		retvalue = -1;
		break;
	}

	return (retvalue);

} /* end of ve_state_cmp() */


/*
 * Pick the volume elements in the subvolumes which are "good".
 * Good volume elements are either in "clean" or "active" states.
 * They also have the most recent timestamp. Volume elements
 * that are not "good" should be: empty|stale|offline|incomplete ...
 *
 * Return:
 *	0 - No choice made because there is only one plex.
 *	    Don't need to update the disk labels (if the ve state is active).
 *	1 - Chose between plex ve's. Update the xlv disk labels.
 *
 * Note:
 *	If there is only one plex and the ve state is empty then
 *	set the state to active and return 1 so the disk labels
 *	are updated.
 */
static int
choose_subvol_pieces (xlv_tab_subvol_t *svp,
		      ve_table_entry_t *table,
		      int	       num_rows,
		      int	       ksv)		/* is a kernel sv */
{
	int			p, row, insert;
	int			ve_idx, idx;
	int			cmp_count;
	xlv_tab_vol_elmnt_t	*cmp_order[XLV_MAX_PLEXES];
	xlv_tab_vol_elmnt_t	*vep;

	/*
	 * Special case when there are no mirrors. In other words,
	 * there is only a sinlge plex. In this case, the plex ve
	 * state should be active.
	 *
	 * Note: The algorithm can handle a single plex, but a
	 * check here is faster.
	 */
	if ((svp->num_plexes == 1) && (svp->plex[0])) {
		int	update = 0;

		vep = &svp->plex[0]->vol_elmnts[0];
		for (idx=0; idx < svp->plex[0]->num_vol_elmnts; idx++, vep++) {
			if ((vep->state == XLV_VE_STATE_EMPTY) ||
			    (vep->state == XLV_VE_STATE_CLEAN)) {
				vep->state = XLV_VE_STATE_ACTIVE; 
				update++;
			}
		}

		return ((update) ? 1 : 0);
	}

	/*
	 * Main loop to find primary volume elements.
	 */
	for (row = 0; row < num_rows; row++) {
		cmp_count = 0;
		bzero(cmp_order, sizeof(cmp_order));

		/*
		 * Compare vol element states to find primary copy.
		 *
		 * First determine the order of the comparsion.
		 * Sort by timestamp (which is the second order
		 * criteria when both ve are in a good state).
		 */

		for (p = 0; p < XLV_MAX_PLEXES; p++) {
			ve_idx = table[row].plex_ve_idx[p];
			if (ve_idx == -1)
				continue;	/* plex isn't part of row */

			vep = &svp->plex[p]->vol_elmnts[ve_idx];

			/*
			 * Find a place for ve in the cmp_order table.
			 */
			for (insert = 0; insert < cmp_count; insert++) {
				if (vep->veu_timestamp >
				    cmp_order[insert]->veu_timestamp)
					break;	/* insert here */
			}
			
			/*
			 * Insert entry -- "insert" is the index of
			 * the new entry. Move all following entries
			 * over one. Start migration from the back.
			 */
			for (idx = cmp_count; idx > insert; idx--) {
				cmp_order[idx] = cmp_order[idx-1];
			}
			cmp_order[insert] = vep;
			cmp_count++;
		}

		/*
		 * The comparison order have been established so do it.
		 */
		if (cmp_count > 1) {
			/*
			 * More than one volume element covers this
			 * address space so find the "best" one.
			 */
			vep = cmp_order[0];
			for (idx = 1; idx < cmp_count; idx++) {
				if (2 == ve_state_cmp(vep, cmp_order[idx], ksv))
					vep = cmp_order[idx];
			}
		}
		/*
		 * Mark the chosen volume element active.
		 *
		 * Note that the chosen volume element cannot be
		 * "offline" nor "incomplete" because incomplete
		 * volumes should have been filtered out.
		 */
		if (vep->state == XLV_VE_STATE_OFFLINE ||
		    vep->state == XLV_VE_STATE_INCOMPLETE) {
			ASSERT(0);
			continue;
		}
		vep->state = XLV_VE_STATE_ACTIVE;

	} /* finish one row */

	return(1);

} /* end of choose_subvol_pieces() */


/*
 * For each subvolume, choose the primary volume elements spanning the
 * address space and update the ve state. Also update the on-disk labels.
 *
 * We only want to process new subvolumes, that is subvolumes that
 * are not in the kernel. If the kernel knows about a subvolume then that
 * subvolume must be either up-to-date (revived) or in the process of
 * being being updated (reviving). So check to see if the subvolume is
 * configured in the kernel and pass that information to the volume element
 * comparison function.
 *
 * NOTE: The xlv_labd(1m) must be running so that the volume element states
 * can be updated in the labels. The first time a mirrored subvolume is
 * revived, xlv_assemble(1m) marks the mirrored volume element "stale"
 * and let's the kernel update the state to "active". If the xlv_labd(1m)
 * is not running, the label will always have the ve state as "stale"
 * and we will always be doing full revives.
 */
static void
choose_tab_vol_pieces ( xlv_tab_vol_t	*xlv_tab_vol, ksvset_t *ksvset )
{
	xlv_tab_vol_entry_t	*vol_p;
	xlv_tab_subvol_t	*svp;
	xlv_oref_t		oref;
#ifdef DEBUG_TABLE
	ve_table_entry_t	table[10];
	int			max = 10;
#else
	ve_table_entry_t	*table;
	int			max = XLV_MAX_VE_DEPTH;
#endif
	int	ksv;	/* is a subvolume in the running kernel */
	int	v;
	int	rows;
	int	status;

	XLV_OREF_INIT(&oref);

#ifndef DEBUG_TABLE
	table = malloc(sizeof(*table) * XLV_MAX_VE_DEPTH);
	if (table == NULL) {
		errprintf("choose_tab_vol_pieces() failed: malloc\n");
		exit(1);
	}
#endif

	/*
	 * Only process subvolumes that are not members of the kernel set
	 */
	for (v = 0; v < xlv_tab_vol->num_vols; v++) {

                vol_p = &xlv_tab_vol->vol[v];
		XLV_OREF_SET_VOL(&oref, vol_p);

		if ((svp = vol_p->log_subvol) != NULL) {
			ksv = ksvismember(ksvset, minor(svp->dev));
			rows = xlv_fill_subvol_ve_table (svp, table, max);
			if (rows && choose_subvol_pieces(
						svp, table, rows, ksv)) {
				XLV_OREF_SUBVOL(&oref) = svp;
				xlv_lab2_write_oref_component (
					&xlv_vh_list, &oref,
					XLV_OBJ_TYPE_LOG_SUBVOL,
					NULL, NULL, &status,
					XLV_LAB_WRITE_FULL);
			}
		}

		if ((svp = vol_p->data_subvol) != NULL) {
			ksv = ksvismember(ksvset, minor(svp->dev));
			rows = xlv_fill_subvol_ve_table (svp, table, max);
			if (rows && choose_subvol_pieces(
						svp, table, rows, ksv)) {
				XLV_OREF_SUBVOL(&oref) = svp;
				xlv_lab2_write_oref_component (
					&xlv_vh_list, &oref,
					XLV_OBJ_TYPE_DATA_SUBVOL,
					NULL, NULL, &status,
					XLV_LAB_WRITE_FULL);
			}
		}

		if ((svp = vol_p->rt_subvol) != NULL) {
			ksv = ksvismember(ksvset, minor(svp->dev));
			rows = xlv_fill_subvol_ve_table (svp, table, max);
			if (rows && choose_subvol_pieces(
						svp, table, rows, ksv)) {
				XLV_OREF_SUBVOL(&oref) = svp;
				xlv_lab2_write_oref_component (
					&xlv_vh_list, &oref,
					XLV_OBJ_TYPE_RT_SUBVOL,
					NULL, NULL, &status,
					XLV_LAB_WRITE_FULL);
			}
		}
        }

} /* end of choose_tab_vol_pieces() */


/*
 * Print out the error code returned by xlv_tab_set syssgi().
 *
 * These error numbers are defined in kern/sys/xlv_base.h
 */
static char XLVE_BLOCK_MAP_INVAL_STR[] =
  "The plexes do not form a consistent address space\n";
static char XLVE_SUBVOL_TYPE_INVAL_STR[] =
  "Invalid subvolume type (not data, log, or rt)\n";
static char XLVE_NUM_PLEXES_INVAL_STR[] =
  "Number of plexes must be between 1 and 4\n";
static char XLVE_NUM_VES_INVAL_STR[] =
  "Number of volume elements must be between 1 and 128\n";
static char XLVE_VERS_INVAL_STR[] =
  "This version of xlv_assemble is incompatible with the running kernel\n";
static char XLVE_SUBVOL_INCOMPLETE_STR[] =
  "Disk drives which are known to the kernel were not found.  Please use\n"
  "xlv_shutdown(1M) to deconfigure these disks before using xlv_assemble(1M).\n"
  "Check the syslog file for more information\n";

static char E2BIG_STR[] =
  "Not enough kernel space allocated for XLV volumes.\n"
  "Please reconfigure kernel with a larger XLV_MAXVOLS value.\n";
static char EBUSY_STR[] =
  "Someone else is currently running xlv_assemble.\n";
static char CANT_SET_VOL_CONFIG_STR[] =
  "xlv_assemble: unable to set volume configuration.\n";


static void
print_xlv_tab_set_error (void)
{
	int err = errno;

	errprintf(CANT_SET_VOL_CONFIG_STR);
	switch (err) {
		case XLVE_BLOCK_MAP_INVAL: 
			errprintf (XLVE_BLOCK_MAP_INVAL_STR);
			break;
		case XLVE_SUBVOL_TYPE_INVAL:
			errprintf (XLVE_SUBVOL_TYPE_INVAL_STR);
			break;
		case XLVE_NUM_PLEXES_INVAL:
			errprintf (XLVE_NUM_PLEXES_INVAL_STR);
			break;
		case XLVE_NUM_VES_INVAL:
			errprintf (XLVE_NUM_VES_INVAL_STR);
			break;
		case XLVE_VOL_VERS_INVAL:
		case XLVE_SUBVOL_VERS_INVAL:
			errprintf (XLVE_VERS_INVAL_STR);
			break;
		case XLVE_SUBVOL_INCOMPLETE:
			errprintf(XLVE_SUBVOL_INCOMPLETE_STR);
			break;
		case E2BIG:
			errprintf (E2BIG_STR);
			break;
		case EBUSY:
			errprintf (EBUSY_STR);
			break;
		default:
			perror("xlv_assemble");
			break;
	}
}


/*
 * M a i n ( )
 */
void
main (int argc, char **argv)
{
	xlv_tab_vol_t	*xlv_tab_vol;
	xlv_tab_t	*xlv_tab;
	ksvset_t	*ksvlist;	/* kernel subvolume list */
	unsigned	size_subvols, size_vols;
	int		status;
	int		ch;
	int		plexd_required;
	int		read_flags;
	int		maxlocks, maxvols;
	int		licensed_for_plexing;
	char 		*selectlist = NULL;
	char		*env_args;
	int 		retrycnt = 0;

	if (cap_envl (0, CAP_DEVICE_MGT, 0) == -1) {
		errprintf("%s: must be started by super-user\n", argv[0]);
		exit(1);
	}

	/*
	 * Get default arguments from the environment variable.
	 */
	env_args = getenv("XLV_ASSEMBLE_ARGS");
	if (env_args) {
		int	ac = 0;
		char	*av[50];	  /* Temporary argument vector */
		char    args_line[1024];

#define	ARG_DELIMIT	" \n\t\r"

		strcpy(args_line, env_args);
		av[0] = '\0';
		ac = 1;
		if (0 != (av[1] = strtok(args_line, ARG_DELIMIT))) {
			ac = 2;
			while(0 != (av[ac] = strtok(0, ARG_DELIMIT)))
				++ac;
		}

		while ((ch = getopt(ac, av, "afh:lnqr:s:tvKP")) != EOF) {
		    switch((char)ch) {
			case 'a':	f_local = 0;		break;
			case 'f':	f_full_revive = 1;	break;
			case 'h':	nodename = optarg;	break;
			case 'l':	f_local = 1; 		break;
			case 'n':	f_kernel = 0;		break;
			case 'q':	f_quiet = 1;		break;
			case 'r':	rootname = optarg;	break;
			case 's':	f_local = 0; 
					selectlist = optarg; 	break;
			case 't':	f_terse = 1;		break;
			case 'v':	f_verbose = XLV_PRINT_ALL; break;
			case 'K':	f_kernel = 0;		break;
			case 'P':	f_plex_revive = 0;	break;
			default:	break;
		    }
		}
		optind = 1;	/* reset */
	}

	/*
	 * Parse the command line for options.
	 */
	while ((ch = getopt(argc, argv, "afh:lnqr:s:tvKP")) != EOF) {
		switch((char)ch) {
		case 'a':
			f_local = 0;
			break;
		case 'f':
			f_full_revive = 1;
			break;
		case 'h':
			nodename = optarg;		/* local nodename */
			break;
		case 'l':
			f_local = 1;
			break;
		case 'n':
			f_kernel = 0;
			break;
		case 'q':
			f_quiet = 1;
			break;
		case 'r':
			rootname = optarg;		/* root directory */
			break;
		case 's':				/* selective assemble*/
			f_local = 0; 
			selectlist = optarg; 	
			break;
		case 't':
			f_terse = 1;
			break;
		case 'v':
			f_verbose = XLV_PRINT_ALL;
			break;
		case 'K':
			f_kernel = 0;
			break;
		case 'P':
			f_plex_revive = 0;		/* don't do plex copy */
			break;
		default:
			usage();
		}
	}

	if (argc -= optind)
		usage();

	if (nodename)
		xlv_setnodename(nodename);

	if (rootname && !xlv_setrootname(rootname)) {
		char buf[500];

		sprintf (buf, "xlv_assemble cannot set \"%s\" as root dir",
			 rootname);
		perror(buf);
		exit(1);
	}

	/*
	 * Check to see if we are licensed for plexing. 
	 */
	if (f_kernel) {
		if (!f_quiet) {
			printf(
		"xlv_assemble: Checking for Disk Plexing Option ... ");
			fflush(NULL);
		}
		licensed_for_plexing = check_plexing_license (rootname);
		if (!f_quiet) {
			printf("done\n");
		}
	}

	/*
	 * We don't want to make the array too large as the current
	 * syssgi call will allocate the same amount of storage in
	 * kernel heap.
	 */
	maxlocks = get_max_kernel_locks();
	if (maxlocks > 0) {
		/*
		 * The maximum number of volumes is based upon the
		 * number of locks available.
		 */
		maxvols = maxlocks/XLV_SUBVOLS_PER_VOL;
	} else {
		maxvols = XLV_MAX_VOLS;
		maxlocks = XLV_MAX_SUBVOLS;
	}

	size_vols = sizeof(xlv_tab_vol_t) +
				(maxvols-1) * sizeof(xlv_tab_vol_entry_t);
	xlv_tab_vol = (xlv_tab_vol_t *) malloc (size_vols);
	/*
	 * Need to zero the "uuid" field in each vol entry. The library
	 * uses the uuid to determine if there's an entry there.
	 */
	bzero (xlv_tab_vol, size_vols);
	xlv_tab_vol->max_vols = maxvols;

	size_subvols = sizeof(xlv_tab_t) +
				(maxlocks-1) * sizeof(xlv_tab_subvol_t);
	xlv_tab = (xlv_tab_t *) malloc (size_subvols);
	/*
	 * We actually only need to zero the vol_p pointer in each
	 * entry.  Otherwise, the kernel code will think that there's
	 * an entry there.
	 */
	bzero (xlv_tab, size_subvols);
	xlv_tab->max_subvols = maxlocks;

	status = 0;
	/* always read all drives to ensure that we never filter out any
	 * existing xlv_tab_vol entries for the kernel
	 */
	read_flags = XLV_READ_ALL;
	if (f_kernel) {
		make_xlv_device_dir();
	} else {
		read_flags |= XLV_READ_NO_CONVERT;
	}
	xlv_lab2_read (&xlv_vh_list, xlv_tab_vol, xlv_tab, read_flags, &status);

	if (status) {
		/*
		 * Failed to read in the volume and subvolume tables.
		 */
		errno = status;
		print_xlv_tab_set_error();
		exit(1);
	}

	if (xlv_vh_list == NULL)
		goto finish;		/* No XLV volumes */

	if (!f_quiet) {
		if (f_terse) {
			print_vol_name (xlv_tab_vol);
		} else {
			xlv_tab_print (xlv_tab_vol, xlv_tab, f_verbose);
		}
	}

	/*
	 * If we are not licensed for plexing, disable
	 * all plexed volumes.
	 *
	 * XXX Maybe xlv_assemble(1m) should exit(1) instead of
	 * removing the plexed volume.
	 */
	if (f_kernel && !licensed_for_plexing) {
		disable_plexed_volumes (xlv_tab_vol, xlv_tab);
	}

	/* determine which kernel sub volumes are present */
	ksvlist = make_ksvset();

	/*
	 * Plex Volume Element Check
	 * Check that corresponding volume elements in every plex
	 * are the same size. Or should this be done in the library?
	 * Or in xlv_make(1m)?
	 *
	 * Answer: xlv_make(1m) and xlv_mgr(1m) checks for this.
	 */

	/*
	 * Now reduce the xlv_tab_vol ad xlv_tab so that we don't leave
	 * unused space at the end. We need to do this because the 
	 * kernel may not have enough entries for all the subvolumes
	 * that we have.
	 * Note that we can't just set max_subvols to be num_subvols
	 * because xlv_tab is sparse.
	 */
	shrink_xlv_tab(xlv_tab_vol, xlv_tab);


	/*
	 * Check for missing disk parts.
	 *
	 * Only handle good "complete" volumes. Missing volume
	 * elements are okay iff they are mirrored and the mirrored
	 * volume elements are available. Ignore (remove) volumes
	 * which are missing pieces that are mirrored.
	 */
	xlv_filter_complete_vol(xlv_tab_vol, f_quiet);

	/*
	 * Handle "valid" volumes -- remove volumes that are "invalid"
	 * for this system. Invalid volumes are too big to handle.
	 */
	xlv_filter_valid_vol(xlv_tab_vol, f_quiet);

	/* 
	 * Filter out volumes which don't match the selection criterion
	 * or aren't already part of the kernel
	 */
	selective_assemble(xlv_tab_vol, xlv_tab, selectlist, ksvlist);

	if (f_kernel) {
		/*
		 * If there are complete xlv volumes, pass the volume
		 * geometry into the kernel so that we can do I/O on them.
		 */
		if (xlv_tab_vol->num_vols > 0) {
			
			/*
			 * Pick a primary volume elements and
			 * make volume element state transition.
			 */
			choose_tab_vol_pieces(xlv_tab_vol, ksvlist);
#if 0
			if (f_verbose && !f_quiet) {
				printf("\n*** After state transition ***\n");
				xlv_tab_print (xlv_tab_vol, xlv_tab, f_verbose);
			}
#endif
			/*
			 * The plex deamon must be started when
			 * there are mirrors.
			 */
			plexd_required = mirrored_subvol(xlv_tab);

			if (f_plex_revive && plexd_required) {
				int fd;

				/*
				 * Look for the plex daemon so
				 * revive request can be serviced.
				 */
				fd = open (XLV_PLEXD_RQST_FIFO,
					   O_NDELAY | O_WRONLY);
				if (0 > fd) {
				perror("xlv_assemble: cannot open xlv_plexd");
					_exit(XLV_ASSEMBLE_NEED_PLEXD);
				} else {
					close(fd);
				}
			}

			/*
			 * Pass the configuration to the kernel.
			 */
			if (!f_quiet) {
				printf(
			"xlv_assemble: Setting kernel configuration ... ");
				fflush(NULL);
			}
			while (cap_dev_syssgi(SGI_XLV_SET_TAB, xlv_tab_vol, xlv_tab)) {
				/* retry if we're out of memory, since we're
				 * not sleeping in the kernel */
				if (errno == ENOMEM) {
					if (retrycnt == 2 ||
					   (retrycnt && !(retrycnt % 900))) {
						slog(LOG_CRIT,
						"Out of kernel memory for "
						"XLV buffers.  Retried for "
						"%d seconds", 
						(void *)(retrycnt * 2));
					}
					if (!f_quiet) {
						printf("no kernel memory: "
						       "retrying again %d\n", 
						 	retrycnt);
						sleep(2);
						printf("xlv_assemble: Setting "
						  "kernel configuration ... ");
						fflush(NULL);
					}
					retrycnt++;
					continue;
				} else if (!f_quiet) {
					printf("error\n");
				}
				print_xlv_tab_set_error();
				_exit(1);
			}

			if (retrycnt) {
				slog(LOG_WARNING, 
					"Kernel memory allocation succeded "
					"after %d seconds", 
					(void *)(retrycnt * 2));
			}
			if (!f_quiet) {
				printf("done\n");
			}
			if (f_plex_revive &&
			    (0 > initiate_plex_revives(xlv_tab))) {
				errprintf (
			"xlv_assemble: failed to initiate plex requests.\n");
				_exit(1);
			}

			/*
			 * Create device node for root volume header.
			 */
			make_xlv_root_vh(xlv_tab);
		}
		else {
			if (!f_quiet)
				errprintf ("No xlv volumes found\n");
		}
	}

finish:
	exit(exitcode);

} /* end of main() */
