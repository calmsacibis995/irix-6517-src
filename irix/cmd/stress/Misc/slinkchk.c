#ident "$Revision: 1.6 $"

/*
** 1) Create a file1 of random size in /usr/tmp
** 2) Symlink another files of the same file system /usr/tmp
** 3) read and compare file1 and other symlinked files
** 5) zero out the contents of the original file1, create another file2
**    then symlink file1 to file2, now read and compare all the files
** 6) Changing the contents of any file of the symlink list, then
**   read and compare all the files again
** 7) Access permission are implicitly check via comparison
** 8) remove all symlinked files and make sure the terminal link is still there
** 
** slinkchk [-p path to put the test files ] [-s max file size] [-l max level of symlink]
** [-c count of how many times to repeat test] [-v]
*/
#include <stdio.h>
#include <getopt.h>
#include <wait.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>

unsigned long maxfsize = 16*1024;	/* max file size is 16K */
int linklevel = 4;	/* at most 4 link */
unsigned long count = 1;		/* no repeat */
int verbose;		/* default to be silent */
char *path1 = "/usr/tmp/";

#define CREATE	0
#define APPEND	1
void Usage(void);
void dotest(void);
int write_file(char *fname, size_t fsize, int seed, int mode);
int create_slink(char *fname, int linklevel, pid_t pid);
void compare_files(char *f1, char *f2, int linklevel, pid_t pid);
void compare(char *f1, char *f2);
void clean_up(char *f1, char *f2, int linklevel, pid_t pid);

int
main(int argc, char **argv)
{
	int err = 0;
	int c;

	while ((c = getopt(argc, argv, "vp:s:l:c:")) != EOF) {
		switch (c) {
		case 'p':
			path1 = optarg;
			break;
		case 's':
			maxfsize = strtoul(optarg, (char **) 0, 0);
			if (maxfsize == 0)
				err++;
			maxfsize = (maxfsize / sizeof(int)) * sizeof(int);
			break;
	
		case 'l':
			linklevel = (int)strtoul(optarg, (char **) 0, 0);
			if (linklevel == 0)
				err++;
			break;

		case 'c':
			count = strtoul(optarg, (char **) 0, 0);
			if (count == 0)
				err++;
			break;
		case 'v':
			verbose++;
			break;

		default:
			err++;
			break;
		}

	}

	if (err) {
		Usage();
		exit(1);
	}
	fprintf(stdout,"Create symlinked files and compare contents\n");
	while (count--)  {
		if (verbose)
			fprintf(stdout,"slinkchk:Loops remaining %d\n", count);
		dotest();
	} 
	return 0;
}

void
Usage(void)
{
	fprintf(stderr,"slinkchk [-p path to put test files] [-s max file size] [-l max level of symlink] [-c count of how many times to repeat test] [-v]\n"); 
	exit(1);
}

void
dotest(void)
{
	char fname1[80], fname2[80];
	pid_t pid = getpid();

	if (*(path1+strlen(path1)) != '/') {
		strcat(path1,"/");
	}
	/* create a file1 of file size maxfsize */
	sprintf(fname1,"%sfile1.%d",path1,pid);
	write_file(fname1, maxfsize, pid, CREATE);

	/* create the number of symlink files */
	create_slink(fname1, linklevel, pid);	

	/* read and compare fname1 versus all the symlinked files */
	compare_files(fname1, (char *)0, linklevel, pid);

	/* create a file2 of file size maxfsize */
	sprintf(fname2,"%sfile2.%d",path1,pid);
	write_file(fname2, maxfsize, ~pid, CREATE);

	
	/* symlink fname1 point to fname2 */
	if (unlink(fname1) == -1) {
		fprintf(stderr,"can't unlink %s\n",fname1);
		exit(1);
	}
	if (symlink(fname2, fname1) == -1) {
		fprintf(stderr,"can't symlink %s to %s\n",fname1, fname2);
		exit(1);
	}
	/* read and compare fname1 versus all the symlinked files and fname2 */
	compare_files(fname1, fname2, linklevel, pid);

	/* change content of fname1 then read and compare all others */
	write_file(fname1, maxfsize, 0, APPEND);
	compare_files(fname1, fname2, linklevel, pid);

	clean_up(fname1,fname2,linklevel, pid);
}

/*
** create a file 'fname' of size 'fsize', fill it with data
** generated by rand() with seed of 'seed'
*/
int
write_file(char *fname, size_t fsize, int seed, int mode)
{
	int i;
	int data;
	FILE *fd;


	if (mode == CREATE) {	
		if ((fd = fopen(fname, "w")) == NULL) {
			fprintf(stderr,"Can't create file %s\n",fname);
			exit(1);
		}
	}
	else /* must be append */
	{
		if ((fd = fopen(fname, "a")) == NULL) {
			fprintf(stderr,"Can't create file %s\n",fname);
			exit(1);
		}
	}

	fsize = fsize/sizeof(data);	/* file size in words */

	srand(seed);
	for (i=0; i<fsize; i++) {
		data = rand();
		if (fwrite((char *)&data, sizeof(data), 1, fd) != 1) {
			fprintf(stderr,"Can't write to file %s\n",fname);
			exit(1);
		}
	}

	if (fclose(fd) == EOF) {
		fprintf(stderr,"Can't close file %s\n",fname);
		exit(1);
	}
	return(0);
}


/*
**
** create a max of 'linklevel' files all of which are symlinked to
** 'fname' 
*/
int
create_slink(char *fname, int linklevel, pid_t pid)
{
	char sname[80];

	while (linklevel--) {	
		sprintf(sname,"%ssfile%d.%d",path1,linklevel,pid);
		/* symlink sname point to fname */
		if (symlink(fname, sname) == -1) {
			fprintf(stderr,"Can't symlink %s to %s\n",sname,fname);
			exit(1);
		}
	}
	return(0);
}

/*
** compare files
*/
void
compare_files(char *f1, char *f2, int linklevel, pid_t pid)
{
	char sname[80];

	while (linklevel--) {
		sprintf(sname,"%ssfile%d.%d",path1,linklevel,pid);
		compare(f1,sname);
	}
	if (f2 && *f2) 
		compare(f1, f2);
}

#define CMPPATH	"/bin/cmp"

void
compare(char *f1, char *f2)
{
	pid_t cid;

	if ((cid = fork()) == 0) {
		execl(CMPPATH, CMPPATH, f1, f2, NULL);
		perror("slinkchk:execl failed");
		exit(-1);
	} else {
		int statloc = 0;
		int rid;

		if (cid == -1) {
			fprintf(stderr,"Can't fork /bin/cmp\n");
			exit(1);
		}
		rid = wait(&statloc);
		if (rid != cid) {
			fprintf(stderr,"wait for /bin/cmp failed!\n");
			exit(1);
		}
		else if ((statloc & 0xff) == 0) {
			statloc >>= 8;		
			statloc &= 0xff;
			if (!statloc) 
				return;
		}
		fprintf(stderr,"Compare failed for %s and %s\n",f1,f2);
		exit(1);
	}
}

/*
** f2 is the terminal link
** After removing all the symlinks, check to make sure that 
** f2 is still arond before removing it
*/
void
clean_up(char *f1, char *f2, int linklevel, pid_t pid)
{
	char sname[80];
	struct stat sb;

	while (linklevel--) {
		sprintf(sname,"%ssfile%d.%d",path1,linklevel,pid);
		if (unlink(sname) == -1) {
			fprintf(stderr,"can't unlink %s",sname);
			exit(1);
		}
	}
	if (unlink(f1) == -1) {
		fprintf(stderr,"can't unlink %s",f1);
		exit(1);
	}
	/* 
	** 
	*/
	if (stat(f2,&sb) == -1) {
		fprintf(stderr,"slinkchk: can't stat file %s",f2);
		exit(1);
	}
	if ((sb.st_mode & S_IFMT) == S_IFREG && sb.st_size == maxfsize*2) {
		if (unlink(f2) == -1) {
			fprintf(stderr,"can't unlink %s",f1);
			exit(1);
		}
	}
	else {
		fprintf(stderr,"Terminal link %s is affected by removing sym links\n",f2);
		exit(1);
	}
}	
