
/////////////////////////////////////////////////////////////
//
// Source file for Restart
//
//    This file is generated by RapidApp 1.2
//
//    This class is derived from RestartUI which 
//    implements the user interface created in 
//    RapidApp. This class contains virtual
//    functions that are called from the user interface.
//
//    When you modify this source, limit your changes to 
//    modifying the sections between the
//    "//---- Start/End editable code block" markers
//
//    This will allow RapidApp to integrate changes more easily
//
//    This class is a ViewKit user interface "component".
//    For more information on how components are used, see the
//    "ViewKit Programmers' Manual", and the RapidApp
//    User's Guide.
/////////////////////////////////////////////////////////////

#include <time.h>
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <pwd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/dir.h>
#include "Restart.h"
#include <Vk/VkEZ.h>
#include <Sgm/Finder.h> 
#include <Sgm/RubberBoard.h> 
#include <Xm/Label.h> 
#include <Xm/List.h> 
#include <Xm/PushB.h> 
#include <Xm/ScrolledW.h> 
#include <Xm/Separator.h> 
#include <Xm/ToggleB.h> 
#include <Vk/VkResource.h>
#include <Vk/VkOptionMenu.h>
#include <Vk/VkMenuItem.h>


extern void VkUnimplemented ( Widget, const char * );

///////////////////////////////////////////////////////////////////////////////
// The following non-container elements are created by RestartUI and are
// available as protected data members inherited by this class
//
//  XmLabel		    _label
//  XmSeparator		    _separator1
//  XmSeparator		    _separator2
//  XmPushButton		    _but_ls
//  XmList		    _lsList
//  SgFinder		    _finder_statef
//  XmToggleButton		    _tog_cdir
//  XmToggleButton		    _tog_rdir
//  XmPushButton		    _but_restart
//  VkOptionMenu *		    _forkMenu
//  VkMenuItem *		    _origpid
//  VkMenuItem *		    _anypid
//  XmPushButton		    _info
//  XmPushButton		    _remove
//
///////////////////////////////////////////////////////////////////////////////

//---- Start editable code block: headers and declarations

//---- End editable code block: headers and declarations


//---- Restart Constructor

Restart::Restart(const char *name, Widget parent) : 
                   RestartUI(name, parent) 
{ 
    // This constructor calls RestartUI(parent, name)
    // which calls RestartUI::create() to create
    // the widgets for this component. Any code added here
    // is called after the component's interface has been built

    //---- Start editable code block: Restart constructor

    RestFlags = 0;
    RestPath[0] = 0;
    if ((RestCwd = getcwd(0, CPATHLEN)) == 0)
	perror("Cannot find cwd ");
    else
	SgFinderSetTextString(_finder_statef, RestCwd);

    //---- End editable code block: Restart constructor
}    // End Constructor

Restart::Restart(const char *name) : 
                   RestartUI(name) 
 { 
    // This constructor calls RestartUI(name)
    // which does not create any widgets. Usually, this
    // constructor is not used

    //---- Start editable code block: Restart constructor 2
    
    //---- End editable code block: Restart constructor 2
}    // End Constructor


Restart::~Restart()
{
    // The base class destructors are responsible for
    // destroying all widgets and objects used in this component.
    // Only additional items created directly in this class
    // need to be freed here.

    //---- Start editable code block: Restart destructor

    //---- End editable code block: Restart destructor
}    // End Destructor


const char * Restart::className() // classname
{
    return ("Restart");
} // End className()

void Restart::cv_ls ( Widget w, XtPointer callData )
{
    //---- Start editable code block: Restart cv_ls
    XmPushButtonCallbackStruct *cbs = (XmPushButtonCallbackStruct*) callData;
    XmString    *linePtrs;
    char path[CPATHLEN];
    DIR *dirp;
    struct direct  *direct;
    int numString = 0, n;
    struct stat sdata;
    char buf[128];

    if ((dirp = opendir(RestCwd)) == NULL) {
        fprintf(stderr,"Cannot open %s directory (%s)\n", RestCwd, STRERR);
        return;
    }
    while (direct = readdir(dirp))
	numString++;

    getpasswd();
    linePtrs = (XmString *)malloc(numString*sizeof(XmString));
    n = 0;
    rewinddir(dirp);
    while ((direct = readdir(dirp)) && n < numString) {
	sprintf(path, "%s/%s", RestCwd, direct->d_name);	
	if (stat(path, &sdata) < 0) {
		perror("stat");
		continue;
	}
	sprintf(buf, "  %-54s  %-8s %24s\n", direct->d_name, 
		finduname(sdata.st_uid), ctime(&sdata.st_mtime));
	linePtrs[n++] = XmStringCreateLocalized(buf);
    }
    closedir(dirp);
    XtVaSetValues(w, XmNitems, linePtrs, XmNitemCount, n, NULL);
    free(linePtrs);

    //---- End editable code block: Restart cv_ls
}    // End Restart::cv_ls()


void Restart::cv_statef ( Widget w, XtPointer callData )
{
    //---- Start editable code block: Restart cv_statef
    XmAnyCallbackStruct *cbs = (XmAnyCallbackStruct*) callData;

    // Read what user entered as cwd
    XtFree(RestCwd);
    RestCwd = SgFinderGetTextString(w);

    //---- End editable code block: Restart cv_statef
}    // End Restart::cv_statef()


void Restart::cv_statef_change ( Widget w, XtPointer callData )
{
    //---- Start editable code block: Restart cv_statef_change
    XmAnyCallbackStruct *cbs = (XmAnyCallbackStruct*) callData;

    XtFree(RestCwd);
    RestCwd = SgFinderGetTextString(w);

    //---- End editable code block: Restart cv_statef_change
}    // End Restart::cv_statef_change()


void Restart::doAnypid ( Widget w, XtPointer callData )
{
    //---- Start editable code block: Restart doAnypid
    XmPushButtonCallbackStruct *cbs = (XmPushButtonCallbackStruct*) callData;

    RestFlags |= CKPT_RESTART_ANY_PID;

    //---- End editable code block: Restart doAnypid
}    // End Restart::doAnypid()

void Restart::doBut_restart ( Widget w, XtPointer callData )
{
    //---- Start editable code block: Restart doBut_restart
    XmPushButtonCallbackStruct *cbs = (XmPushButtonCallbackStruct*) callData;
    u_long type;
    ckpt_attr_t attr;
    char attrfile[CPATHLEN];
    char buf[CPATHLEN];
    int fd;
    int stat;
    int child;

    if (RestPath[0] == 0) {
	printf("Please select a statefile to restart from\n");
	return;
    }
    if (ckpt_getattr(RestPath, CKPT_ATTR_ID|CKPT_ATTR_TYPE, &attr) != 0)
	return;

    sprintf(attrfile, "%s.%d.%d", CKPT_ATTRFILE_GUI, getuid(), attr.ckpt_id);
    unlink(attrfile);	// clean up left-overs
    if ((fd = open(attrfile, O_CREAT|O_EXCL|O_WRONLY, S_IRUSR|S_IWUSR)) < 0) {
        perror("Failed to open");
        return;
    }
    sprintf(buf, "CKPT %s %d {\n", ckpt_type_str(attr.ckpt_type), attr.ckpt_id);
    write(fd, buf, strlen(buf));

    if (RestFlags & CKPT_RESTART_NEW_CWD) {
	sprintf(buf, "\tCDIR:	IGNORE\n");
	write(fd, buf, strlen(buf));
    }
    if (RestFlags & CKPT_RESTART_NEW_ROOT) {
	sprintf(buf, "\tRDIR:	IGNORE\n");
	write(fd, buf, strlen(buf));
    }
    if (RestFlags & CKPT_RESTART_ANY_PID) {
	sprintf(buf, "\tFORK:	ANY\n");
	write(fd, buf, strlen(buf));
    }
    write(fd, "}\n", 2);
    fsync(fd);

    if ((child = fork()) == 0) {
	int i;
	close(fd);
	for (i = 3; i < getdtablehi();  ++i) { /* JIA */
	    close(i);
	}
	execl(CPR, CPR, "-r", RestPath, 0);
	fprintf(stderr, "Failed to restart job (%s)\n", STRERR);
    }
    wait(&stat);
    close(fd); // keep the file excl opened until restart has read it

    //---- End editable code block: Restart doBut_restart
}    // End Restart::doBut_restart()


void Restart::doInfo ( Widget w, XtPointer callData )
{
    //---- Start editable code block: Restart doInfo
    XmPushButtonCallbackStruct *cbs = (XmPushButtonCallbackStruct*) callData;
    int stat;

    if (RestPath[0] == 0) {
	printf("Please select a statefile to get CPR info from\n");
	return;
    }
    if (fork() == 0) {
	execl(CPR, CPR, "-i", RestPath, 0);
	fprintf(stderr, "Failed to get CPR info (%s)\n", STRERR);
    }
    wait(&stat);

    //---- End editable code block: Restart doInfo
}    // End Restart::doInfo()


void Restart::doOrigpid ( Widget w, XtPointer callData )
{
    //---- Start editable code block: Restart doOrigpid
    XmPushButtonCallbackStruct *cbs = (XmPushButtonCallbackStruct*) callData;

    RestFlags &= ~CKPT_RESTART_ANY_PID;

    //---- End editable code block: Restart doOrigpid
}    // End Restart::doOrigpid()


void Restart::doRemove ( Widget w, XtPointer callData )
{
    //---- Start editable code block: Restart doRemove
    XmPushButtonCallbackStruct *cbs = (XmPushButtonCallbackStruct*) callData;
    int child, stat;

    if (RestPath[0] == 0) {
	printf("Please select a statefile to remove\n");
	return;
    }
    if ((child = fork()) == 0) {
	execl(CPR, CPR, "-D", RestPath, 0);
	fprintf(stderr, "Failed to restart job (%s)\n", STRERR);
	return;
    }
    if (child < 0) {
	perror("Failed to fork");
	return;
    }
    child = wait(&stat);
    if (WIFEXITED(stat) == 0 || WEXITSTATUS(stat) != 0)
	perror("Failed to wait");

    return;
    //---- End editable code block: Restart doRemove
}    // End Restart::doRemove()


void Restart::ls_select_one ( Widget w, XtPointer callData )
{
    //---- Start editable code block: Restart ls_select_one
    XmListCallbackStruct *cbs = (XmListCallbackStruct*) callData;
    int i = 0;
    char buf[128];
    char *p = (char *)cbs->item;

    FINDSPACE(p);
    SKIPSPACE(p);
    while (!SPACE(*p) && !ISEND(*p)) 
	buf[i++] = *(p++);
    buf[i] = 0;

    sprintf(RestPath, "%s/%s", RestCwd, buf);

    //---- End editable code block: Restart ls_select_one
}    // End Restart::ls_select_one()


void Restart::setTog_cdir ( Widget w, XtPointer callData )
{
    //---- Start editable code block: Restart setTog_cdir
    XmToggleButtonCallbackStruct *cbs = (XmToggleButtonCallbackStruct*) callData;
    static char select = 0;

    if (select == 0) {
    	RestFlags |= CKPT_RESTART_NEW_CWD;
	select = 1;
    } else {
	RestFlags &= ~CKPT_RESTART_NEW_CWD;
	select = 0;
    }

    //---- End editable code block: Restart setTog_cdir
}    // End Restart::setTog_cdir()


void Restart::setTog_rdir ( Widget w, XtPointer callData )
{
    //---- Start editable code block: Restart setTog_rdir
    XmToggleButtonCallbackStruct *cbs = (XmToggleButtonCallbackStruct*) callData;
    static char select = 0;

    if (select == 0) {
    	RestFlags |= CKPT_RESTART_NEW_ROOT;
	select = 1;
    } else {
	RestFlags &= ~CKPT_RESTART_NEW_ROOT;
	select = 0;
    }

    //---- End editable code block: Restart setTog_rdir
}    // End Restart::setTog_rdir()

///////////////////////////////////////////////////////////////////
// static creation function, for importing class into rapidapp
// or dynamically loading, using VkComponent::loadComponent
///////////////////////////////////////////////////////////////////

VkComponent *Restart::CreateRestart( const char *name, Widget parent ) 
{  
    VkComponent *obj =  new Restart ( name, parent );
    return ( obj );
} // End CreateRestart

///////////////////////////////////////////////////////////////////
// Function for accessing a description of the dynamic interface
// to this class.
///////////////////////////////////////////////////////////////////

// WARNING: This structure is different than that used with 1.1 RapidApp.
// See the RapidApp release notes for details

struct InterfaceMap {
  char  *resourceName;
  char  *methodName;
  char  *argType;
  char  *definingClass; // Optional, if not this class
  void (VkCallbackObject::*method)(...); // Reserved, do not set
};

void *Restart::RegisterRestartInterface()
{ 
    // This structure registers information about this class
    // that allows RapidApp to create and manipulate an instance.
    // Each entry provides a resource name that will appear in the
    // resource manager palette when an instance of this class is
    // selected, the name of the member function as a string,
    // the type of the single argument to this function, and an.
    // optional argument indicating the class that defines this function.
    // All member functions must have the form
    //  
    //     void memberFunction ( Type );
    //
    // where "Type" is one of:
    //    const char *    (Use XmRString)
    //    Boolean         (Use XmRBoolean)
    //    int             (Use XmRInt)
    //    float           (Use XmRFloat)
    //    No argument     (Use VkRNoArg or "NoArg"
    //    A filename      (Use VkRFilename or "Filename")
    //    An enumeration  (Use "Enumeration:ClassName:Type: VALUE1, VALUE2, VALUE3")
    //    A callback      (Use XmRCallback)


    static InterfaceMap map[] = {
    //---- Start editable code block: RestartUI resource table

      // { "resourceName", "setAttribute", XmRString},
    //---- End editable code block: RestartUI resource table
      { NULL }, // MUST be NULL terminated
    };

    return map;
} // End RegisterRestartInterface()


//---- End of generated code

//---- Start editable code block: End of generated code

//---- End editable code block: End of generated code
