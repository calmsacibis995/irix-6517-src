/*-
 * $Header: /proj/irix6.5.7m/isms/irix/lib/libc/src/gen/RCS/engine.c,v 1.19 1998/06/12 22:58:35 holzen Exp $
 * Copyright (c) 1992, 1993, 1994 Henry Spencer.
 * Copyright (c) 1992, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Henry Spencer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)engine.c	8.5 (Berkeley) 3/20/94
 */

/*
 * The matching engine and friends.  This file is #included by regexec.c
 * after suitable #defines of a variety of macros used herein, so that
 * different state representations can be used without duplicating masses
 * of code.
 */

#ifdef SNAMES
#define	matcher	smatcher
#define	fast	sfast
#define	slow	sslow
#define	dissect	sdissect
#define	backref	sbackref
#define	step	sstep
#define	print	sprint
#define	at	sat
#define	match	smat
#define cs_memberof scs_memberof
#define isword  sisword
#define crule  scrule
#endif
#ifdef LNAMES
#define	matcher	lmatcher
#define	fast	lfast
#define	slow	lslow
#define	dissect	ldissect
#define	backref	lbackref
#define	step	lstep
#define	print	lprint
#define	at	lat
#define	match	lmat
#define cs_memberof lcs_memberof
#define isword  lisword
#define crule   lcrule
#endif

/* another structure passed up and down to avoid zillions of parameters */
struct match {
	struct re_guts *g;
	int eflags;
	void *pmatch;		/* [nsub+1] (0 element unused) */
  	wchar_t *offp;		/* offsets work from here */
  	wchar_t *beginp;	/* start of string -- virtual NUL precedes */
  	wchar_t *endp;		/* end of string -- virtual NUL here */
        wchar_t *coldp;		/* can be no match starting before here */
  	wchar_t **lastpos;	/* [nplus+1] */
	STATEVARS;
	states st;		/* current states */
	states fresh;		/* states for a fresh start */
	states tmp;		/* temporary */
	states empty;		/* empty set of states */
};

/* ========= begin header generated by ./mkh ========= */
#ifdef __cplusplus
extern "C" {
#endif

/* === engine.c === */
static int matcher (register struct re_guts *g, char *string, size_t nmatch, regmatch_t pmatch[], int eflags, int new);
static wchar_t *dissect (register struct match *m, wchar_t *start, wchar_t *stop, sopno startst, sopno stopst, int new);
static wchar_t *backref (register struct match *m, wchar_t *start, wchar_t *stop, sopno startst, sopno stopst, sopno lev, int new);
static wchar_t *fast (register struct match *m, wchar_t *start, wchar_t *stop, sopno startst, sopno stopst, int new);
static wchar_t *slow (register struct match *m, wchar_t *start, wchar_t *stop, sopno startst, sopno stopst, int new);
static states step (register struct re_guts *g, sopno start, sopno stop, states bef, wint_t *ch, states aft);
static int cs_memberof(cset *, wchar_t *);
static int isword(wchar_t);
static int crule(const void *first, const void *second);
   
/* definitions of hardwired wchar_t character codes */

#define WC_NEWLINE (0L | '\n')

/* Note the following values are assumed to never be equal to a valid
 * wchar_t value.  Although this is technically possible, it is not
 * the case for any currently supported encoding (and it is very
 * likely to remain that way).
 */

#define	NOTHING	(OUT)
#define	BOL	(OUT-1)
#define	EOL	(OUT-2)
#define	BOLEOL	(OUT-3)
#define	BOW	(OUT-4)
#define	EOW	(OUT-5)

#define	NONCHAR(c)	((c) >= EOW && (c) <= OUT)

#ifdef REDEBUG
static void print (struct match *m, char *caption, states st, wint_t ch, FILE *d); 
#endif
#ifdef REDEBUG
static void at (struct match *m, char *title, wchar_t *start, wchar_t *stop, sopno startst, sopno stopst, int new);
#endif
#ifdef REDEBUG
static char *pchar (wint_t ch);
#endif

#ifdef __cplusplus
}
#endif
/* ========= end header generated by ./mkh ========= */

#ifdef REDEBUG
#define	SP(t, s, c)	print(m, t, s, c, stdout)
#define	AT(t, p1, p2, s1, s2, n)	at(m, t, p1, p2, s1, s2, n)
#define	NOTE(str)	{ if (m->eflags&REG_TRACE) printf("=%s\n", (str)); }
#else
#define	SP(t, s, c)	/* nothing */
#define	AT(t, p1, p2, s1, s2, n)	/* nothing */
#define	NOTE(s)	/* nothing */
#endif





/*
 - matcher - the actual matching engine
 == static int matcher(register struct re_guts *g, char *string, \
 ==	size_t nmatch, regmatch_t pmatch[], int eflags, int new);
 */
static int			/* 0 success, REG_NOMATCH failure */
matcher(register struct re_guts *g, char *string, size_t nmatch,
		regmatch_t pmatch[], int eflags, int new)
{
        register wchar_t *endp;
	register int i;
	struct match mv;
	register struct match *m = &mv;
	register wchar_t *dp;
	register const sopno gf = g->firststate+1;	/* +1 for OEND */
	register const sopno gl = g->laststate;
	wchar_t *start;
	wchar_t *stop;
	sgi_regmatch_t	*sgi_pmatch;
	sgi_regmatch_t	*sgi_pmatch1;
	regmatch_t	*abi_pmatch;
	int mask = 0;

	/* support for converting input string to wchar_t */
	wchar_t *result;
	size_t string_len, result_len;

	if(!new)
		mask = OREG_NOSUB;
	else
		mask = REG_NOSUB;

	/* simplify the situation where possible */
	if (g->cflags&mask)
		nmatch = 0L;

	/* Converting input to wchar_t */
	string_len = strlen ( string );
	result_len = ( string_len + 1 ) * sizeof(wchar_t);

	/* Note that memory allocated using alloca does not need to be freed */
	if ((result = (wchar_t *) alloca((unsigned int) result_len )) == NULL)
	  if (!new)
	    return(OREG_ESPACE);
	  else
	    return(REG_ESPACE);

	if ( mbstowcs ( result, string, result_len ) == -1 )
	{
	    /* assume encoding is Latin-1 (ISO8859-1) */
	    for (i = 0; i < string_len ; i++)
		result[i] = (wchar_t) string[i];
	    result[i] = L'\0';
	}

	if (eflags&REG_STARTEND) {
		if(new) {
			start = result + pmatch[0].rm_so;
			stop = result + pmatch[0].rm_eo;
		} else {
			sgi_pmatch = (sgi_regmatch_t *)pmatch;
			start = result + sgi_pmatch[0].rm_so;
			stop = result+ sgi_pmatch[0].rm_eo;
		}
	} else {
		start = result;
		stop = start + wcslen(result);
	}
	if (stop < start)
		return(REG_INVARG);

	/* prescreening; this does wonders for this rather slow code */
	if (g->must != NULL) {
		for (dp = start; dp < stop; dp++)
			if (*dp == g->must[0] && stop - dp >= g->mlen &&
			    memcmp(dp, g->must, (size_t) (g->mlen*sizeof(wchar_t))) == 0)
				break;
		if (dp == stop)	/* we didn't find g->must */
			if(!new)
				return(OREG_NOMATCH);
			else
				return(REG_NOMATCH);
	}
	/* match struct setup */
	m->g = g;
	m->eflags = eflags;
	m->pmatch = NULL;
	m->lastpos = NULL;
	m->offp = result;
	m->beginp = start;
	m->endp = stop;
	STATESETUP(m, 4, new);
	SETUP(m->st);
	SETUP(m->fresh);
	SETUP(m->tmp);
	SETUP(m->empty);
	CLEAR(m->empty);

	/* this loop does only one repetition except for backrefs */
	for (;;) {
		endp = fast(m, start, stop, gf, gl, new);
		if (endp == NULL) {		/* a miss */
			STATETEARDOWN(m);
			if(!new)
				return(OREG_NOMATCH);
			else
				return(REG_NOMATCH);
		}
		if (nmatch == 0L && !g->backrefs)
			break;		/* no further info needed */

		/* where? */
		assert(m->coldp != NULL);
		for (;stop > m->coldp;) {
			NOTE("finding start");
			endp = slow(m, m->coldp, stop, gf, gl, new);
			if (endp != NULL)
				break;
			assert(m->coldp < m->endp);
			m->coldp++;
		}
		if (nmatch == 1L && !g->backrefs)
			break;		/* no further info needed */

		/* oh my, he wants the subexpressions... */
		if(new) {
			if (m->pmatch == NULL)
				m->pmatch = (regmatch_t *)
					memalign(sizeof(__int64_t),
						(m->g->nsub + 1) *
							sizeof(regmatch_t));
			if (m->pmatch == NULL) {
				STATETEARDOWN(m);
				return(REG_ESPACE);
			}
		} else {
			if (m->pmatch == NULL)
				m->pmatch = (sgi_regmatch_t *)
					memalign(sizeof(__int64_t),
						(m->g->nsub + 1) *
						sizeof(sgi_regmatch_t));
			if (m->pmatch == NULL) {
				STATETEARDOWN(m);
				return(OREG_ESPACE);
			}
		}
		for (i = 1; i <= m->g->nsub; i++)
			if(new) {
				abi_pmatch = (regmatch_t *)m->pmatch;
				abi_pmatch[i].rm_so = abi_pmatch[i].rm_eo = -1;
			} else {
				sgi_pmatch = (sgi_regmatch_t *)m->pmatch;
				sgi_pmatch[i].rm_so = sgi_pmatch[i].rm_eo = -1;
			}
		if (!(m->coldp && *m->coldp))
			break;

		if (!g->backrefs && !(m->eflags&REG_BACKR)) {
			NOTE("dissecting");
			dp = dissect(m, m->coldp, endp, gf, gl, new);
		} else {
			if (g->nplus > 0 && m->lastpos == NULL)
				m->lastpos = (wchar_t **)malloc((g->nplus+1) *
							sizeof(wchar_t *));
			if (g->nplus > 0 && m->lastpos == NULL) {
				free(m->pmatch);
				STATETEARDOWN(m);
				if(!new)
					return(OREG_ESPACE);
				else
					return(REG_ESPACE);
			}
			NOTE("backref dissect");
			dp = backref(m, m->coldp, endp, gf, gl, (sopno)0, new);
			if(new) {
				abi_pmatch = (regmatch_t *)m->pmatch;
				if (abi_pmatch[1].rm_eo == -1)
					abi_pmatch[1].rm_eo = endp - m->offp;
			} else {
				sgi_pmatch = (sgi_regmatch_t *)m->pmatch;
				if (sgi_pmatch[1].rm_eo == -1)
					sgi_pmatch[1].rm_eo = endp - m->offp;
			}
		}
		if (dp != NULL)
			break;

		/* uh-oh... we couldn't find a subexpression-level match */
		assert(g->backrefs);	/* must be back references doing it */
		assert(g->nplus == 0 || m->lastpos != NULL);
		for (;;) {
			if (dp != NULL || endp <= m->coldp)
				break;		/* defeat */
			NOTE("backoff");
			endp = slow(m, m->coldp, endp-1, gf, gl, new);
			if (endp == NULL)
				break;		/* defeat */
			/* try it on a shorter possibility */
#ifndef NDEBUG
			for (i = 1; i <= m->g->nsub; i++) {
				if(new) {
					abi_pmatch = (regmatch_t *)m->pmatch;
					assert(abi_pmatch[i].rm_so == -1);
					assert(abi_pmatch[i].rm_eo == -1);
				} else {
					sgi_pmatch =(sgi_regmatch_t *)m->pmatch;
					assert(sgi_pmatch[i].rm_so == -1);
					assert(sgi_pmatch[i].rm_eo == -1);
				}
			}
#endif
			NOTE("backoff dissect");
			dp = backref(m, m->coldp, endp, gf, gl, (sopno)0, new);
		}
		assert(dp == NULL || dp == endp);
		if (dp != NULL)		/* found a shorter one */
			break;

		/* despite initial appearances, there is no match here */
		NOTE("false alarm");
		start = m->coldp + 1;	/* recycle starting later */
		assert(start <= stop);
	}
	/* fill in the details if requested */
	if (nmatch > 0L) {
		if(new) {
			pmatch[0].rm_so = m->coldp - m->offp;
			pmatch[0].rm_eo = (endp > stop ? stop : endp) - m->offp;
		} else {
			sgi_pmatch = (sgi_regmatch_t *)pmatch;
			sgi_pmatch[0].rm_so = m->coldp - m->offp;
			sgi_pmatch[0].rm_eo = 
				(endp > stop ? stop : endp) - m->offp;
		}
	}
	if (nmatch > 1L) {
		if(new) {
			abi_pmatch = (regmatch_t *)m->pmatch;
			assert(abi_pmatch != NULL);
		} else {
			sgi_pmatch = (sgi_regmatch_t *)m->pmatch;
			assert(sgi_pmatch != NULL);
		}
		for (i = 1; i < nmatch; i++) {
			if (i <= m->g->nsub) {
				if(new) {
					abi_pmatch = (regmatch_t *)m->pmatch;
					pmatch[i] = abi_pmatch[i];
				} else {
					sgi_pmatch = 
						(sgi_regmatch_t *)m->pmatch;
					sgi_pmatch1 = (sgi_regmatch_t *)pmatch;
					sgi_pmatch1[i] = sgi_pmatch[i];
				}
			} else {
				if(new) {
					pmatch[i].rm_so = -1L;
					pmatch[i].rm_eo = -1L;
				} else {
					sgi_pmatch = (sgi_regmatch_t *)pmatch;
					sgi_pmatch[i].rm_so = -1L;
					sgi_pmatch[i].rm_eo = -1L;
				}
			}
		}
	}

	/* The values contained by the pmatch structures refer
	 * to wchar_t pointers and not bytes as required by the spec.
	 * The only way to find how many bytes are used by a wchar_t
	 * string is to convert them back to multibyte. This is only
	 * done is MB_CUR_MAX != 1, otherwise wc pointers are equal to byte
	 * pointers.
	 * The conversion assumes that so < eo, and only converts characters
	 * between so and eo to find out the byte position of eo.
	 */

	if ( MB_CUR_MAX != 1 )
	{
	    wchar_t	wc_tmp;
	    ssize_t	so, eo, so_new, len;

	    for (i = 0; i < nmatch ; i++)
	    {
		if ( new )
		{
		    so = pmatch[i].rm_so;
		    eo = pmatch[i].rm_eo;
		}
		else
		{
		    so = ( (sgi_regmatch_t *) pmatch ) [i].rm_so;
		    eo = ( (sgi_regmatch_t *) pmatch ) [i].rm_eo;
		}

		if ( so == -1 )
		    /* No more matches to look at */
		    break;

		/* Terminate buffer at so */
		wc_tmp = result [ so ];
		result [ so ] = NULL;
		/* Get length of initial segment */
		if ( ( len = (ssize_t) wcstombs ( NULL, result, 0 ) ) == -1 )
		    return ( new ? REG_NOMATCH : OREG_NOMATCH );

		/* Restore character at so */
		result [ so ] = wc_tmp;
		/* The so pointer (in bytes) is equal to the length
		   returned by the conversion */
		so_new = len;

		/* Terminate buffer at eo */
		wc_tmp = result [ eo ];
		result [ eo ] = NULL;

		/* Get length of the segment between eo and so */
		if ( ( len = (ssize_t) wcstombs ( NULL, result + so , 0 ) ) == -1 )
		    return ( new ? REG_NOMATCH : OREG_NOMATCH );

		/* Restore character at so */
		result [ eo ] = wc_tmp;

		if ( new )
		{
		    pmatch[i].rm_so = so_new;
		    pmatch[i].rm_eo = so_new + len ;
		}
		else
		{
		    ( (sgi_regmatch_t *) pmatch ) [i].rm_so = so_new;
		    ( (sgi_regmatch_t *) pmatch ) [i].rm_eo = so_new + len;
		}
	    }
	}


	if (m->pmatch != NULL)
		free((char *)m->pmatch);
	if (m->lastpos != NULL)
		free((wchar_t *)m->lastpos);

	STATETEARDOWN(m);
	return(0);
}

/*
 - dissect - figure out what matched what, no back references
 == static char *dissect(register struct match *m, char *start, \
 ==	char *stop, sopno startst, sopno stopst, int new);
 */
static wchar_t *			/* == stop (success) always */
dissect(register struct match *m, wchar_t *start, wchar_t * stop,
		 sopno startst, sopno stopst, int new)
{
	register int i;
	register sopno ss;	/* start sop of current subRE */
	register sopno es;	/* end sop of current subRE */
	register wchar_t *sp;	/* start of string matched by it */
	register wchar_t *stp;	/* string matched by it cannot pass here */
	register wchar_t *rest;	/* start of rest of string */
	register wchar_t *tail;	/* string unmatched by rest of RE */
	register sopno ssub;	/* start sop of subsubRE */
	register sopno esub;	/* end sop of subsubRE */
	register wchar_t *ssp;	/* start of string matched by subsubRE */
	register wchar_t *sep;	/* end of string matched by subsubRE */
	register wchar_t *oldssp;	/* previous ssp */
	register regmatch_t	*abi_pmatch;
	register sgi_regmatch_t	*sgi_pmatch;
#ifndef NDEBUG
	register wchar_t *dp;
#endif

	AT("diss", start, stop, startst, stopst, new);
	sp = start;
	for (ss = startst; ss < stopst; ss = es) {
		/* identify end of subRE */
		es = ss;
		switch (OP(m->g->strip[es])) {
		case OPLUS_:
		case OQUEST_:
			es += OPND(m->g->strip[es]);
			break;
		case OCH_:
			while (OP(m->g->strip[es]) != O_CH)
				es += OPND(m->g->strip[es]);
			break;
		}
		es++;

		/* figure out what it matched */
		switch (OP(m->g->strip[ss])) {
		case OEND:
			assert(nope);
			break;
		case OCHAR:
			sp++;
			break;
		case OBOL:
		case OEOL:
		case OBOW:
		case OEOW:
			break;
		case OANY:
		case OANYOF:
			sp++;
			break;
		case OBACK_:
		case O_BACK:
			assert(nope);
			break;
		/* cases where length of match is hard to find */
		case OQUEST_:
			stp = stop;
			for (;;) {
				/* how long could this one be? */
				rest = slow(m, sp, stp, ss, es, new);
				assert(rest != NULL);	/* it did match */
				/* could the rest match the rest? */
				tail = slow(m, rest, stop, es, stopst, new);
				if (tail == stop)
					break;		/* yes! */
				/* no -- try a shorter match for this one */
				stp = rest - 1;
				assert(stp >= sp);	/* it did work */
			}
			ssub = ss + 1;
			esub = es - 1;
			/* did innards match? */
			if (slow(m, sp, rest, ssub, esub, new) != NULL) {
#ifdef NDEBUG
				(void) dissect(m, sp, rest, ssub, esub, new);
#else
				dp = dissect(m, sp, rest, ssub, esub, new);
				assert(dp == rest);
#endif
			} else		/* no */
				assert(sp == rest);
			sp = rest;
			break;
		case OPLUS_:
			stp = stop;
			for (;;) {
				/* how long could this one be? */
				rest = slow(m, sp, stp, ss, es, new);
				assert(rest != NULL);	/* it did match */
				/* could the rest match the rest? */
				tail = slow(m, rest, stop, es, stopst, new);
				if (tail == stop)
					break;		/* yes! */
				/* no -- try a shorter match for this one */
				stp = rest - 1;
				assert(stp >= sp);	/* it did work */
			}
			ssub = ss + 1;
			esub = es - 1;
			ssp = sp;
			oldssp = ssp;
			for (;;) {	/* find last match of innards */
				sep = slow(m, ssp, rest, ssub, esub, new);
				if (sep == NULL || sep == ssp)
					break;	/* failed or matched null */
				oldssp = ssp;	/* on to next try */
				ssp = sep;
			}
			if (sep == NULL) {
				/* last successful match */
				sep = ssp;
				ssp = oldssp;
			}
			assert(sep == rest);	/* must exhaust substring */
			assert(slow(m, ssp, sep, ssub, esub, new) == rest);
			if(new) {
				abi_pmatch = (regmatch_t *)m->pmatch;
				if ((abi_pmatch[1].rm_so == -1) && 
								(ssp && !*ssp))
					ssp = sp;
			} else {
				sgi_pmatch = (sgi_regmatch_t *)m->pmatch;
				if ((sgi_pmatch[1].rm_so == -1) && 
								(ssp && !*ssp))
					ssp = sp;
			}
#ifdef NDEBUG
			(void)dissect(m, ssp, sep, ssub, esub, new);
#else
			dp = dissect(m, ssp, sep, ssub, esub, new);
			assert(dp == sep);
#endif
			sp = rest;
			break;
		case OCH_:
			stp = stop;
			for (;;) {
				/* how long could this one be? */
				rest = slow(m, sp, stp, ss, es, new);
				assert(rest != NULL);	/* it did match */
				/* could the rest match the rest? */
				tail = slow(m, rest, stop, es, stopst, new);
				if (tail == stop)
					break;		/* yes! */
				/* no -- try a shorter match for this one */
				stp = rest - 1;
				assert(stp >= sp);	/* it did work */
			}
			ssub = ss + 1;
			esub = ss + (sopno) OPND(m->g->strip[ss]) - 1;
			assert(OP(m->g->strip[esub]) == OOR1);
			for (;;) {	/* find first matching branch */
				if (slow(m, sp, rest, ssub, esub, new) == rest)
					break;	/* it matched all of it */
				/* that one missed, try next one */
				assert(OP(m->g->strip[esub]) == OOR1);
				esub++;
				assert(OP(m->g->strip[esub]) == OOR2);
				ssub = esub + 1;
				esub += OPND(m->g->strip[esub]);
				if (OP(m->g->strip[esub]) == OOR2)
					esub--;
				else
					assert(OP(m->g->strip[esub]) == O_CH);
			}
#ifdef NDEBUG
			(void) dissect(m, sp, rest, ssub, esub, new);
#else
			dp = dissect(m, sp, rest, ssub, esub, new);
			assert(dp == rest);
#endif
			sp = rest;
			break;
		case O_PLUS:
		case O_QUEST:
		case OOR1:
		case OOR2:
		case O_CH:
			assert(nope);
			break;
		case OLPAREN:
			i = (int )OPND(m->g->strip[ss]);
			assert(0 < i && i <= m->g->nsub);
			if(new) {
				abi_pmatch = (regmatch_t *)m->pmatch;
				abi_pmatch[i].rm_so = sp - m->offp;
			} else {
				sgi_pmatch = (sgi_regmatch_t *)m->pmatch;
				sgi_pmatch[i].rm_so = sp - m->offp;
			}
			break;
		case ORPAREN:
			i = (int )OPND(m->g->strip[ss]);
			assert(0 < i && i <= m->g->nsub);
			if(new) {
				abi_pmatch = (regmatch_t *)m->pmatch;
				abi_pmatch[i].rm_eo = sp - m->offp;
			} else {
				sgi_pmatch = (sgi_regmatch_t *)m->pmatch;
				sgi_pmatch[i].rm_eo = sp - m->offp;
			}
			break;
		default:		/* uh oh */
			assert(nope);
			break;
		}
	}
	assert(sp == stop);
	return(sp);
}

/*
 - backref - figure out what matched what, figuring in back references
 == static char *backref(register struct match *m, char *start, \
 ==	char *stop, sopno startst, sopno stopst, sopno lev, int new);
 */
static wchar_t *	/* == stop (success) or NULL (failure) */
backref(register struct match *m, wchar_t *start, wchar_t *stop, 
		 sopno startst, sopno stopst, sopno lev, int new)
{
	register long i;
	register sopno ss;	/* start sop of current subRE */
	register wchar_t *sp;	/* start of string matched by it */
	register sopno ssub;	/* start sop of subsubRE */
	register sopno esub;	/* end sop of subsubRE */
	register wchar_t *ssp;	/* start of string matched by subsubRE */
	register wchar_t *dp;
	register size_t len;
	register int hard;
	register sop s;
	register cset *cs;
	register int backr;
	register int mask;
	register sgi_regoff_t	sgi_offsave;
	register regoff_t	abi_offsave;
	register regmatch_t	*abi_pmatch;
	register sgi_regmatch_t	*sgi_pmatch;

	AT("back", start, stop, startst, stopst, new);
	sp = start;

	/* get as far as we can with easy stuff */
	hard = 0;
	for (ss = startst; !hard && ss < stopst; ss++)
		switch (OP(s = m->g->strip[ss])) {
		case OCHAR:
		  /* Note that if we have to special-case MBS handling, we
		     should reinstate OMBCHAR case */
			if (sp == stop || *sp++ != m->g->mbs[OPND(s)])
				return(NULL);
			break;
		case OANY:
			if (sp == stop)
				return(NULL);
			sp++;
			break;
		case OANYOF:
			cs = &m->g->sets[OPND(s)];
			if (sp == stop || !cs_memberof(cs, sp++))
				return(NULL);
			break;
		case OBOL:
			if(!new)
				mask = OREG_NEWLINE;
			else
				mask = REG_NEWLINE;
			if ( (sp == m->beginp && !(m->eflags&REG_NOTBOL)) ||
					(sp < m->endp && *(sp-1) == WC_NEWLINE &&
						(m->g->cflags&mask)) )
					{ /* yes */ }
				else
					return(NULL);
			break;
		case OEOL:
			if(!new)
				mask = OREG_NEWLINE;
			else
				mask = REG_NEWLINE;
			if ( (sp == m->endp && !(m->eflags&REG_NOTEOL)) ||
					(sp < m->endp && *sp == WC_NEWLINE &&
						(m->g->cflags&mask)) )
				{ /* yes */ }
			else
				return(NULL);
			break;
		case OBOW:
			if(!new)
				mask = OREG_NEWLINE;
			else
				mask = REG_NEWLINE;
			if (( (sp == m->beginp && !(m->eflags&REG_NOTBOL)) ||
			      (sp < m->endp && *(sp-1) == WC_NEWLINE &&
			       (m->g->cflags&mask)) ||
			      (sp > m->beginp && !isword(*(sp-1))) ) &&
			    (sp < m->endp && isword(*sp)) )
				{ /* yes */ }
			else
				return(NULL);
			break;
		case OEOW:
			if(!new)
				mask = OREG_NEWLINE;
			else
				mask = REG_NEWLINE;
			if (( (sp == m->endp && !(m->eflags&REG_NOTEOL)) ||
			      (sp < m->endp && *sp == WC_NEWLINE &&
			       (m->g->cflags&mask)) ||
			      (sp < m->endp && !isword(*sp)) ) &&
			    (sp > m->beginp && isword(*(sp-1))) )
				{ /* yes */ }
			else
				return(NULL);
			break;
		case O_QUEST:
			break;
		case OOR1:	/* matches null but needs to skip */
			ss++;
			s = m->g->strip[ss];
			do {
				assert(OP(s) == OOR2);
				ss += OPND(s);
			} while (OP(s = m->g->strip[ss]) != O_CH);
			/* note that the ss++ gets us past the O_CH */
			break;
		default:	/* have to make a choice */
			hard = 1;
			break;
		}
	if (!hard) {		/* that was it! */
		if (sp != stop)
			return(NULL);
		return(sp);
	}
	ss--;			/* adjust for the for's final increment */

	/* the hard stuff */
	AT("hard", sp, stop, ss, stopst, new);
	s = m->g->strip[ss];
	switch (OP(s)) {
	case OBACK_:		/* the vilest depths */
		i = (long )OPND(s);
		assert(0 < i && i <= m->g->nsub);
		backr = 0;
		if(new) {
			abi_pmatch = (regmatch_t *)m->pmatch;
			if ((sp > m->offp) && (abi_pmatch[i].rm_so == -1))
				backr++;
			if (!backr && abi_pmatch[i].rm_eo == -1)
				return(NULL);
	
			assert(!backr && abi_pmatch[i].rm_so != -1);
			if (backr && 
			   (dp = backref(m, sp, stop, ss+1, stopst, lev, new)))
				return(dp);
	
			if ((abi_pmatch[i].rm_eo == -1) || 
				(abi_pmatch[i].rm_so == -1))
				return (NULL);
	
			len = abi_pmatch[i].rm_eo - abi_pmatch[i].rm_so;
			assert(stop - m->beginp >= len);
			if (sp > stop - len)
				return(NULL);	/* not enough left to match */
			ssp = m->offp + abi_pmatch[i].rm_so;
		} else {
			sgi_pmatch = (sgi_regmatch_t *)m->pmatch;
			if ((sp > m->offp) && (sgi_pmatch[i].rm_so == -1L))
				backr++;
			if (!backr && sgi_pmatch[i].rm_eo == -1L)
				return(NULL);
	
			assert(!backr && sgi_pmatch[i].rm_so != -1L);
			if (backr && 
			   (dp = backref(m, sp, stop, ss+1, stopst, lev, new)))
				return(dp);
	
			if ((sgi_pmatch[i].rm_eo == -1L) || 
				(sgi_pmatch[i].rm_so == -1L))
				return (NULL);
	
			len = sgi_pmatch[i].rm_eo - sgi_pmatch[i].rm_so;
			assert(stop - m->beginp >= len);
			if (sp > stop - len)
				return(NULL);	/* not enough left to match */
			ssp = m->offp + sgi_pmatch[i].rm_so;
		}
		if (memcmp(sp, ssp, sizeof ( wchar_t ) * len ) != 0)
			return(NULL);

		while (m->g->strip[ss] != SOP(O_BACK, i))
			ss++;
		return(backref(m, sp+len, stop, ss+1, stopst, lev, new));
	case OQUEST_:		/* to null or not */
		dp = backref(m, sp, stop, ss+1, stopst, lev, new);
		if (dp != NULL)
			return(dp);	/* not */
		return(backref(m, sp, stop, ss+(sopno)OPND(s)+1, stopst, lev, new));
	case OPLUS_:
		assert(m->lastpos != NULL);
		assert(lev+1 <= m->g->nplus);
		m->lastpos[lev+1] = sp;
		return(backref(m, sp, stop, ss+1, stopst, lev+1, new));
	case O_PLUS:
		if (sp == m->lastpos[lev])	/* last pass matched null */
			return(backref(m, sp, stop, ss+1, stopst, lev-1, new));
		/* try another pass */
		m->lastpos[lev] = sp;
		dp = backref(m, sp, stop, ss-(sopno)OPND(s)+1, stopst, lev, new);
		if (dp == NULL)
			return(backref(m, sp, stop, ss+1, stopst, lev-1, new));
		else
			return(dp);
	case OCH_:		/* find the right one, if any */
		ssub = ss + 1;
		esub = ss + (sopno)OPND(s) - 1;
		assert(OP(m->g->strip[esub]) == OOR1);
		for (;;) {	/* find first matching branch */
			dp = backref(m, sp, stop, ssub, esub, lev, new);
			if (dp != NULL)
				return(dp);
			/* that one missed, try next one */
			if (OP(m->g->strip[esub]) == O_CH) /* last try */
				return(backref(m, sp, stop, ss+1, 
							stopst, lev, new));
			esub++;
			assert(OP(m->g->strip[esub]) == OOR2);
			ssub = esub + 1;
			esub += OPND(m->g->strip[esub]);
			if (OP(m->g->strip[esub]) == OOR2)
				esub--;
			else
				assert(OP(m->g->strip[esub]) == O_CH);
		}
	case OLPAREN:		/* must undo assignment if rest fails */
		i = (long)OPND(s);
		assert(0 < i && i <= m->g->nsub);
		if(new) {
			abi_pmatch = (regmatch_t *)m->pmatch;
			abi_offsave = abi_pmatch[i].rm_so;
			abi_pmatch[i].rm_so = sp - m->offp;
		} else {
			sgi_pmatch = (sgi_regmatch_t *)m->pmatch;
			sgi_offsave = sgi_pmatch[i].rm_so;
			sgi_pmatch[i].rm_so = sp - m->offp;
		}
		dp = backref(m, sp, stop, ss+1, stopst, lev, new);

		if (dp != NULL)
			return(dp);
		if(new) {
			abi_pmatch = (regmatch_t *)m->pmatch;
			if (abi_offsave != -1)
				abi_pmatch[i].rm_so = abi_offsave;
		} else {
			sgi_pmatch = (sgi_regmatch_t *)m->pmatch;
			if (sgi_offsave != -1L)
				sgi_pmatch[i].rm_so = sgi_offsave;
		}
		return(NULL);
	case ORPAREN:		/* must undo assignment if rest fails */
		i = (long)OPND(s);
		assert(0 < i && i <= m->g->nsub);
		if(new) {
			abi_pmatch = (regmatch_t *)m->pmatch;
			abi_offsave = abi_pmatch[i].rm_eo;
			abi_pmatch[i].rm_eo = sp - m->offp;
		} else {
			sgi_pmatch = (sgi_regmatch_t *)m->pmatch;
			sgi_offsave = sgi_pmatch[i].rm_eo;
			sgi_pmatch[i].rm_eo = sp - m->offp;
		}
		dp = backref(m, sp, stop, ss+1, stopst, lev, new);
		if (dp != NULL)
			return(dp);
		if(new) {
			abi_pmatch = (regmatch_t *)m->pmatch;
			if (abi_offsave != -1L)
				abi_pmatch[i].rm_eo = abi_offsave;
		} else {
			sgi_pmatch = (sgi_regmatch_t *)m->pmatch;
			if (sgi_offsave != -1L)
				sgi_pmatch[i].rm_eo = sgi_offsave;
		}
		return(NULL);
	case O_BACK:
		return(sp);
	default:		/* uh oh */
		assert(nope);
		break;
	}

	/* "can't happen" */
	assert(nope);
	/* NOTREACHED */
}

/*
 - fast - step through the string at top speed
 == static char *fast(register struct match *m, char *start, \
 ==	char *stop, sopno startst, sopno stopst, int new);
 */
static wchar_t *			/* where tentative match ended, or NULL */
fast(register struct match *m, wchar_t *start, wchar_t *stop,
		 sopno startst, sopno stopst, int new)
{
	register states st = m->st;
	register states fresh = m->fresh;
	register states tmp = m->tmp;
	register wchar_t *p = start;
	wint_t c = (start == m->beginp) ? OUT : *(start-1);
	wint_t lastc;	/* previous c */
	int flagch;
	register int i;
	register wchar_t *coldp; /* last p after which no match was underway */
	register int	mask;

	CLEAR(st);
	SET1(st, startst);
	lastc = NOTHING;
	st = step(m->g, startst, stopst, st, &lastc, st); /* was NOTHING */
	ASSIGN(fresh, st);
	SP("start", st, *p);
	coldp = NULL;
	for (;;) {
		/* next character */
		lastc = c;
		c = (p == m->endp) ? OUT : *p;
		if (EQ(st, fresh))
			coldp = p;

		/* is there an EOL and/or BOL between lastc and c? */
		flagch = '\0';
		i = 0;
		if(!new)
			mask = OREG_NEWLINE;
		else
			mask = REG_NEWLINE;
		if ( (lastc == WC_NEWLINE && m->g->cflags&mask && c != OUT) ||
				(lastc == OUT && !(m->eflags&REG_NOTBOL)) ) {
			flagch = BOL;
			i = m->g->nbol;
		}
		if ( (c == WC_NEWLINE && m->g->cflags&mask) ||
			    (c == OUT && !(m->eflags&REG_NOTEOL)) ) {
			flagch = (flagch == BOL) ? BOLEOL : EOL;
			i += m->g->neol;
		}
		if (i != 0) {
			for (; i > 0; i--)
				st=step(m->g, startst, stopst, st, (wint_t *) &flagch, st);
			SP("boleol", st, c);
		}

		/* how about a word boundary? */
		if ( (flagch == BOL || (lastc != OUT && !isword(lastc))) &&
					(c != OUT && isword(c)) ) {
			flagch = BOW;
		}
		if ( (lastc != OUT && isword(lastc)) &&
				(flagch == EOL || (c != OUT && !isword(c))) ) {
			flagch = EOW;
		}
		if (flagch == BOW || flagch == EOW) {
			st = step(m->g, startst, stopst, st, (wint_t *) &flagch, st);
			SP("boweow", st, c);
		}

		/* are we done? */
		if (ISSET(st, stopst) || p == stop)
			break;		/* NOTE BREAK OUT */

		/* no, we must deal with this character */
		ASSIGN(tmp, st);
		ASSIGN(st, fresh);
		assert(c != OUT);
		st = step(m->g, startst, stopst, tmp, p, st);
		SP("aft", st, c);
		lastc = NOTHING;
		assert(EQ(step(m->g, startst, stopst, st, &lastc, st), st));
		p++;
	}

	assert(coldp != NULL);
	m->coldp = coldp;
	if (ISSET(st, stopst))
		return(((p >= stop)? p : (p+1)));
	else
		return(NULL);
}

/*
 - slow - step through the string more deliberately
 == static char *slow(register struct match *m, char *start, \
 ==	char *stop, sopno startst, sopno stopst, int new);
 */
static wchar_t *			/* where it ended */
slow(register struct match *m, wchar_t *start, wchar_t *stop,
		 sopno startst, sopno stopst, int new)
{
	register states st = m->st;
	register states empty = m->empty;
	register states tmp = m->tmp;
	register wchar_t *p = start;
	wint_t c = (start == m->beginp) ? OUT : *(start-1);
	wint_t lastc;	/* previous c */
	int flagch;
	register int i;
	register wchar_t *matchp;	/* last p at which a match ended */
	register int	mask;

	AT("slow", start, stop, startst, stopst, new);
	CLEAR(st);
	SET1(st, startst);
	SP("sstart", st, *p);
	lastc = NOTHING;
	st = step(m->g, startst, stopst, st, &lastc, st);
	matchp = NULL;
	for (;p;) {
		/* next character */
		lastc = c;
		c = (p == m->endp) ? OUT : *p;

		/* is there an EOL and/or BOL between lastc and c? */
		flagch = '\0';
		i = 0;
		if(!new)
			mask = OREG_NEWLINE;
		else
			mask = REG_NEWLINE;
		if ( (lastc == WC_NEWLINE && m->g->cflags&mask && c != OUT) ||
				(lastc == OUT && !(m->eflags&REG_NOTBOL)) ) {
			flagch = BOL;
			i = m->g->nbol;
		}
		if ( (c == WC_NEWLINE && m->g->cflags&mask) ||
				(c == OUT && !(m->eflags&REG_NOTEOL)) ) {
			flagch = (flagch == BOL) ? BOLEOL : EOL;
			i += m->g->neol;
		}
		if (i != 0) {
			for (; i > 0; i--)
				st = step(m->g, startst, stopst, st, (wint_t *) &flagch, st);
			SP("sboleol", st, c);
		}

		/* how about a word boundary? */
		if ( (flagch == BOL || (lastc != OUT && !isword(lastc))) &&
					(c != OUT && isword(c)) ) {
			flagch = BOW;
		}
		if ( (lastc != OUT && isword(lastc)) &&
				(flagch == EOL || (c != OUT && !isword(c))) ) {
			flagch = EOW;
		}
		if (flagch == BOW || flagch == EOW) {
			st = step(m->g, startst, stopst, st, (wint_t *) &flagch, st);
			SP("sboweow", st, c);
		}

		/* are we done? */
		if (ISSET(st, stopst))
			matchp = p;
		if (EQ(st, empty) || p == stop)
			break;		/* NOTE BREAK OUT */

		/* no, we must deal with this character */
		ASSIGN(tmp, st);
		ASSIGN(st, empty);
		assert(c != OUT);
		st = step(m->g, startst, stopst, tmp, p, st);
		SP("saft", st, c);
		lastc = NOTHING;
		assert(EQ(step(m->g, startst, stopst, st, &lastc, st), st));
		p++;
	}

	return(matchp);
}


/*
 - step - map set of states reachable before char to set reachable after
 == static states step(register struct re_guts *g, sopno start, sopno stop, \
 ==	register states bef, wint_t ch, register states aft);
 == #define	BOL	(OUT+1)
 == #define	EOL	(BOL+1)
 == #define	BOLEOL	(BOL+2)
 == #define	NOTHING	(BOL+3)
 == #define	BOW	(BOL+4)
 == #define	EOW	(BOL+5)
 == #define	CODEMAX	(BOL+5)		// highest code used
 == #define	NONCHAR(c)	((c) > CHAR_MAX)
 == #define	NNONCHAR	(CODEMAX-CHAR_MAX)
 */
static states
step(register struct re_guts *g,
	sopno start,		/* start state within strip */
	sopno stop, 		/* state after stop state within strip */
	register states bef,	/* states reachable before */
	wint_t *str,			/* character or NONCHAR code */
	register states aft)	/* states already known reachable after */
{
	register cset *cs;
	register sop s;
	register sopno pc;
	register onestate here;		/* note, macros know this name */
	register sopno look;
	register sop i;
	wchar_t ch = *str;

	for (pc = start, INIT(here, pc); pc != stop; pc++, INC(here)) {
		s = g->strip[pc];
		switch (OP(s)) {
		case OEND:
			assert(pc == stop-1);
			break;
		case OCHAR:
			/* only characters can match */
			assert(!NONCHAR(ch) || ch != g->mbs[OPND(s)]);
			if (ch == g->mbs[OPND(s)])
				FWD(aft, bef, 1L);
			break;
		case OBOL:
			if (ch == BOL || ch == BOLEOL)
				FWD(aft, bef, 1L);
			break;
		case OEOL:
			if (ch == EOL || ch == BOLEOL)
				FWD(aft, bef, 1L);
			break;
		case OBOW:
			if (ch == BOW)
				FWD(aft, bef, 1L);
			break;
		case OEOW:
			if (ch == EOW)
				FWD(aft, bef, 1L);
			break;
		case OANY:
			if (!NONCHAR(ch))
				FWD(aft, bef, 1L);
			break;
		case OANYOF:
                        cs = &g->sets[OPND(s)];
			if (!NONCHAR(ch) && cs_memberof(cs, str))
				FWD(aft, bef, 1L);
			break;
		case OBACK_:		/* ignored here */
		case O_BACK:
			FWD(aft, aft, 1L);
			break;
		case OPLUS_:		/* forward, this is just an empty */
			FWD(aft, aft, 1L);
			break;
		case O_PLUS:		/* both forward and back */
			FWD(aft, aft, 1L);
			i = (sop)ISSETBACK(aft, OPND(s));
			BACK(aft, aft, OPND(s));
			if (!i && ISSETBACK(aft, OPND(s))) {
				/* oho, must reconsider loop body */
				pc -= OPND(s) + 1;
				INIT(here, pc);
			}
			break;
		case OQUEST_:		/* two branches, both forward */
			FWD(aft, aft, 1L);
			FWD(aft, aft, OPND(s));
			break;
		case O_QUEST:		/* just an empty */
			FWD(aft, aft, 1L);
			break;
		case OLPAREN:		/* not significant here */
		case ORPAREN:
			FWD(aft, aft, 1L);
			break;
		case OCH_:		/* mark the first two branches */
			FWD(aft, aft, 1L);
			assert(OP(g->strip[pc+OPND(s)]) == OOR2);
			FWD(aft, aft, OPND(s));
			break;
		case OOR1:		/* done a branch, find the O_CH */
			if (ISSTATEIN(aft, here)) {
				for (look = 1;
					OP(s = g->strip[pc+look]) != O_CH;
						look += OPND(s))
					assert(OP(s) == OOR2);
				FWD(aft, aft, look);
			}
			break;
		case OOR2:		/* propagate OCH_'s marking */
			FWD(aft, aft, 1L);
			if (OP(g->strip[pc+OPND(s)]) != O_CH) {
				assert(OP(g->strip[pc+OPND(s)]) == OOR2);
				FWD(aft, aft, OPND(s));
			}
			break;
		case O_CH:		/* just empty */
			FWD(aft, aft, 1L);
			break;
		default:		/* ooooops... */
			assert(nope);
			break;
		}
	}

	return(aft);
}


/*
 - cs_memberof - check for character in character set
 == static int cs_memberof(cset *cs, wchar_t *wc)
 */

static int cs_memberof(cset *cs, wchar_t *wstring)
{

  int i, retval = 0;
  wchar_t wc = *wstring;

    /* How to do it:
     * 
     * If range flag set, check if character is within range
     * If not, then:
     *   if the character is in the wchar_t ASCII range,
     *   do a quick bit vector check.  
     *   OR search the cs->wcs buffer for the character
     *   OR search the multicharacter collation element list
     */

  if (cs->range)
    /* fast search option */
    retval = ((cs->range_min <= wc) && (wc <= cs->range_max));

  if (retval == 0) /* not found yet */
    {
      /* first check cs->multis */
      if (wc < 256)
        retval = CHIN(cs, wc);
      else 
        {
	  if (cs->sorted) 
	    { 
	    if (bsearch((void*)&wc, (void*) (cs->wcs), cs->nwcs, 
			            (size_t)sizeof(wchar_t), crule) == NULL) 
	      {
	      retval = 0;
	      }
	    else 
	      {
	      retval = 1;
	      }
	    }
	  else
	    {
	    /* unsorted, exhaustive search will have to do */
	    for (i = 0; i < cs->nwcs && retval == 0; i ++)
		if (wc == cs->wcs[i])
		   retval = 1;
	    }
        }
    }

  /* nothing else worked, try multicharacter element */
  if (retval == 0 && cs->nmultis != 0)
    {
      char *p;
      size_t len;
      int found;
      for (p = cs->multis; *p != '\0'; p += len + 1)
	{
	found = 1;
	len = strlen(p);
	for (i = 0; i < len && found; i++)
	  found = ((wchar_t) p[i] == wstring[i]);
	if (found)
	   break;
	}
      retval = found;
    }

  /* if inverted, reverse polarity of the answer */
  if (cs->inverted) 
    retval = !retval;
   
  return(retval);
}

static int crule(const void *first, const void *second)
{
    if ( *(wchar_t *)first > *(wchar_t *)second )
	return 1;
    if ( *(wchar_t *)first < *(wchar_t *)second )
	return -1;

    return 0;
}

/*
 - isword - is this character part of a 'word'?
 == static int isword(wchar_t wc)
 */

static int isword(wchar_t wc)
{
  /* a naive attempt */
  return(iswalnum(wc) || (wc) == (wchar_t) '_');

  /* Problem: Note that iswalnum works ONLY on POSIX wchar_t encoding */
}


#ifdef REDEBUG
/*
 - print - print a set of states
 == #ifdef REDEBUG
 == static void print(struct match *m, char *caption, states st, \
 ==	int ch, FILE *d);
 == #endif
 */
static void
print( struct match *m, char *caption, states st, wint_t ch, FILE *d)
{
	register struct re_guts *g = m->g;
	register int i;
	register ulong_t first = 1;

	if (!(m->eflags&REG_TRACE))
		return;

	fprintf(d, "%s", caption);
	if (ch != 0L)
		fprintf(d, " %s", pchar(ch));
	for (i = 0; i < g->nstates; i++)
		if (ISSET(st, i)) {
			fprintf(d, "%s%d", (first) ? "\t" : ", ", i);
			first = 0;
		}
	fprintf(d, "\n");
}

/* 
 - at - print current situation
 == #ifdef REDEBUG
 == static void at(struct match *m, char *title, char *start, char *stop, \
 ==					sopno startst, sopno stopst, int new);
 == #endif
 */
static void
at(struct match *m, char *title, wchar_t *start, wchar_t *stop,
	 sopno startst, sopno stopst, int new)
{
	if (!(m->eflags&REG_TRACE))
		return;

	printf("%s %s-", title, pchar(*start));
	printf("%s ", pchar(*stop));
	printf("%ld-%ld\n", (long)startst, (long)stopst);
}

#ifndef PCHARDONE
#define	PCHARDONE	/* never again */
/*
 - pchar - make a character printable
 == #ifdef REDEBUG
 == static char *pchar(int ch);
 == #endif
 *
 * Is this identical to regchar() over in debug.c?  Well, yes.  But a
 * duplicate here avoids having a debugging-capable regexec.o tied to
 * a matching debug.o, and this is convenient.  It all disappears in
 * the non-debug compilation anyway, so it doesn't matter much.
 */
static char *			/* -> representation */
pchar(wint_t ch)
{
	static char pbuf[10];

	/* check for an ASCII subset Unicode character */

	if (ch <= CHAR_MAX)
	  sprintf(pbuf, "%c", (char) ch);
	else
	  sprintf(pbuf, "\\%o", ch);
	return(pbuf);
}
#endif
#endif

#undef	matcher
#undef	fast
#undef	slow
#undef	dissect
#undef	backref
#undef	step
#undef	print
#undef	at
#undef	match
#undef  cs_memberof
#undef  isword
#undef  crule
