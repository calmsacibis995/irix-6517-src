**************************************************************************
*									 *
*  Copyright (C) 1986-1996  Silicon Graphics, Inc.			 *
*									 *
*  These coded instructions, statements, and computer programs  contain  *
*  unpublished  proprietary  information of Silicon Graphics, Inc., and  *
*  are protected by Federal copyright law.  They  may  not be disclosed  *
*  to  third  parties  or copied or duplicated in any form, in whole or  *
*  in part, without the prior written consent of Silicon Graphics, Inc.  *
*									 *
**************************************************************************

*
* This file is used to control the configuration of the operating system.
* Its is read by the lboot(1) command which builds the /unix file.  The
* syntax of this file is described in system(4).  For more information on
* system configuration, see autoconfig(1), lboot(1), system(4), master(4),
* and systune(1).
*
* $Revision: 1.788 $
*
#if defined(IP20) || defined(IP22) || defined(IP26) || defined(IP28) || defined(IP30) || defined(IP32) || defined(IPMHSIM) || defined(SN0) || defined(SN1)
#undef VMEBUS
#else
#define VMEBUS
#endif
#if defined(IP22) || defined(IP26) || defined(IP28)
#define EISABUS
#endif
#if defined(IP20) || defined(IP22) || defined(IP26) || defined(IP28)
#define GIOBUS
#endif
#if defined(IP19) || defined(IP21) || defined(IP25)
#define	EV_EPC
#endif
#if defined(IP30) || defined(SN0) || defined(IP32) || defined (SN1)
#define PCIBUS
#endif
#if defined(IP30) || defined(SN0) || defined (SN1)
#define XTALKBUS
#endif
#if defined(IP30)
#define NEWGIOBUS
#endif

#ifdef VMEBUS
*
* VME Address, Interrupt Level and VME Vectors for SGI IRIS-4D Systems
*==========================================================================
*
* ADDRESS SPACE
*    1.	All IPn generate ONLY data accesses to
*	the VME bus.  Thus code access privilege is superfluous for all
*	envisioned systems.  Both can generate both non-privileged and
*	supervisor-only cycles.
*    2. IP20, IP22, IP26, IP28 and IP30 do not support VME space.
*
* Privilege codes:
*    np/s	non-privileged/supervisor access
*    c/d	code/data access
*
* Access sizes:
*    b/w/l	byte/word/long access
*
* A16 space:
*
*    VMUX has 16-bit registers and decodes a 128-byte address space:
*       vmux 0  0011 1000 0xxx xxx0         s/np, d, w	3800-387F
*
* Other 3rd-party Peripheral boards use the third quadrant of A16:
*		10xx xxxx xxxx xxxx
* XX GSE
*	gse	1001 0000 0010 aaaa	    np, ?, ??	9020-903F
*    IKON Hardcopy uses 16 bytes of A16
*	ikon	1001 0010 0000 aaaa	    s, ?, ??	9200-921F
*	if_ipg2	1010 110a aaaa aaaa			AC00-
*	if_ipg3	1010 111a aaaa aaaa			    -AFFF
*    2nd pair of FDDIXPress FDDI needs 512/board
*	if_ipg0	1011 001a aaaa aaaa			B200-
*	if_ipg1	1011 010a aaaa aaaa			    -B5FF
*
* A16 Space Reserved for Customer Boards:
*		011x xxxx xxxx xxxx	    s/np	6000-7FFF
*		11xx xxxx xxxx xxxx	    s/np	C000-FFFF
*
* A24 space:
*
*    A24 controllers must DMA to kernel buffers visible in this region
*    and copy the data to arbitrary RAM locations.
*
*    In IP19, bottom 8MB of A24 space, (both privileged and non-privileged)
*    is reserved to map kernel buffers to IO address space for doing DMA.
*    Drivers should call dma mapping routines to get the IO address to be
*    handed to controller.
*    This range is also used by VME bus diagnostic routines in prom.
*
*	IPn RAM	0aaa aaaa aaaa aaaa aaaa aaaa	s/np, c/d, b/w/l
*
*    The top 8MB of privileged A24 space is allocated to 3rd party boards:
*    CMC ENP-10 Ethernet (Obsolete)
*	if_enp3	1101 100a aaaa aaaa aaaa aaaa	s
*	if_enp2	1101 101a aaaa aaaa aaaa aaaa	s
*	if_enp1	1101 110a aaaa aaaa aaaa aaaa	s
*	if_enp0	1101 111a aaaa aaaa aaaa aaaa	s
*    Central Data SIO
*	cdsio	1111 0000 aaaa aaaa aaaa aaaa	s
*	cdsio	1111 0001 aaaa aaaa aaaa aaaa	s
*	cdsio	1111 0010 aaaa aaaa aaaa aaaa	s
*	cdsio	1111 0011 aaaa aaaa aaaa aaaa	s
*
* A24 Space Reserved for Customer Boards:
*		1000 xxxx xxxx xxxx xxxx xxxx    s
*		1001 xxxx xxxx xxxx xxxx xxxx    s
*		1100 xxxx xxxx xxxx xxxx xxxx    s
*		(bottom 8Mb + 172kb reserved by SGI in a24 np)
*		1xxx xxxx xxxx xxxx xxxx xxxx    np
*
* A32 space (non-privileged only):
*
*    The IPn RAM occupy up to 256 Mbytes in the A32 space:
*	RAM	0000 aaaa aaaa aaaa aaaa aaaa aaaa aaaa	    np, c/d, b/w/l
*
*    All SGI 4D systems have at least 64MB reserved for controllers to use
*    for their large, on-board buffers, starting at 0x18000000.  The bottom
*    half is used for SGI-supported boards, the top half reserved for
*    customer boards.
*    See additional comments below for information about systems with two VME buses.
*
*    In IP19, top 2GB of A32 space, (both privileged and non-privileged)
*    is reserved to map kernel buffers to IO address space for doing DMA.
*    Drivers should call dma mapping routines to get the IO address to be
*    handed to controller.
*    This range is also used by VME bus diagnostic routines in prom.
*
* A32 Space Reserved for SGI Boards
*		0001 00xx xxxx xxxx xxxx xxxx xxxx xxxx     np
*		0001 100x xxxx xxxx xxxx xxxx xxxx xxxx     np
*
*    CMC FXP-130 use 1 Mbytes in the A32 space:
*	if_fxp3 0001 1001 1000 00aa aaaa aaaa aaaa aaaa	    np, d, b/w/l
*	if_fxp2	0001 1001 1000 01aa aaaa aaaa aaaa aaaa	    np, d, b/w/l
*	if_fxp1	0001 1001 1000 10aa aaaa aaaa aaaa aaaa	    np, d, b/w/l
*	if_fxp0	0001 1001 1000 11aa aaaa aaaa aaaa aaaa	    np, d, b/w/l
*
* A32 Space Reserved for Customer Boards:
*		0001 01xx xxxx xxxx xxxx xxxx xxxx xxxx     np
*		0001 101x xxxx xxxx xxxx xxxx xxxx xxxx     np
*		001x xxxx xxxx xxxx xxxx xxxx xxxx xxxx     s  ('IP19' only)
*		001x xxxx xxxx xxxx xxxx xxxx xxxx xxxx     np ('IP19' only)
*
********************************************************
********************************************************
*
* INTERRUPT LEVELS AND VECTORS
*  The VME interrupt levels are assigned as follows (IRQ1 is the lowest
*  priority; IRQ7 is the highest priority) IRQ vectors are no longer re
*  reserved: 
*	IRQ4	ikc
*	IRQ5	cdsio
*	IRQ4	if_fxp
*	IRQ4	if_enp	(Obsolete)
*
#endif /* VME */
#if defined(GIOBUS)
*==========================================================================
* GIO bus addresses
*
* The Indigo and Indy have two GIO bus connectors.  Each GIO bus device
* identifies itself to the system by answering a long read with an "ID" value.
* IDs are either 8 or 32 bits long.  IDs less than 128 are 8 bits long,
* with the most significant 24 bits read from the slot undefined.
*
* 32-bit:
*    Slot GFX address range is physical 0xbf000000 - 0xbf3fffff
*    Slot 0   address range is physical 0xbf400000 - 0xbf5fffff
*    Slot 1   address range is physical 0xbf600000 - 0xbf7fffff
*
* 64-bit:
*    Slot GFX address range is physical 0x900000001f000000 - 0x900000001f3fffff
*    Slot 0   address range is physical 0x900000001f400000 - 0x900000001f5fffff
*    Slot 1   address range is physical 0x900000001f600000 - 0x900000001f7fffff
*
* Indigo2 (all models) have three physical connectors, but only two physical
* slots, SLOTGFX and SLOT0. 
*
/* probe address */
#if !defined(_MIPS3_ADDRSPACE)
#if defined(IP22)
#define HPC_SYS_ID	0xBFBD9858
#define HPC_1_ID_ADDR   0xBFB00000
#define HPC_2_ID_ADDR   0xBF980000
#define HPC_HOLLY_1_LIO	0xBFB001C3
#define HPC_HOLLY_2_LIO	0xBF9801C3
#define GIO_SLOTGFX	0xBF000000
#define HPC3_NOT_HPC1	0xBFB02000
#endif
#define GIO_SLOT0	0xBF400000
#define GIO_SLOT1	0xBF600000
#endif
#if defined(_MIPS3_ADDRSPACE)
#if defined(IP22)
#define HPC_SYS_ID	0x900000001FBD9858
#define HPC_1_ID_ADDR   0x900000001FB00000
#define HPC_2_ID_ADDR   0x900000001F980000
#define HPC_HOLLY_1_LIO	0x900000001FB001C3
#define HPC_HOLLY_2_LIO	0x900000001F9801C3
#define GIO_SLOTGFX	0x900000001F000000
#define HPC3_NOT_HPC1	0x900000001FB02000
#endif
#if defined(IP26) || defined(IP28)
#define GIO_SLOTGFX	0x900000001F000000
#define GIO_SLOT0	0x900000001F400000
#else
#define GIO_SLOT0	0x900000001F400000
#define GIO_SLOT1	0x900000001F600000
#endif
#endif

*
* GIO bus IDs
*
* Each GIO bus device identifies itself to the system by answering a
* read with an "ID" value.  IDs are either 8 or 32 bits long.  IDs less
* than 128 are 8 bits long, with the most significant 24 bits read from
* the slot undefined.
*
* 32-bit IDs are currently divided into
*	bits 0-6        the product ID; ranges from 0x00 to 0x7F.
*	bit 7		0=GIO Product ID is 8 bits wide
*			1=GIO Product ID is 32 bits wide.
*	bits 15-8       manufacturer version for the product.
*	bit 16		0=GIO32 and GIO32-bis, 1=GIO64.
*	bit 17		0=no ROM present
*			1=ROM present on this board AND next three words
*				space define the ROM.
*	bits 31-18	up to manufacturer.
* Note that this may change in future 32-bit IDs
*
* IDs above 0x50/0xd0 are of 3rd party boards.
*
* Contact the Developer Program to allocate new IDs, recently Rick McLeod.
*
* This list must match the list in major.h
*
* 8-bit IDs
*	0x01		XPI low cost FDDI
*	0x02		GTR TokenRing (no longer supported)
*	0x04		Synchronous ISDN
*	0x06		Canon Interface
*	0x08		JPEG (Double Wide)
*	0x09		JPEG (Single Wide)
*	0x0a		XPI mez. FDDI device 0
*	0x0b		XPI mez. FDDI device 1
*	0x0e		E-Plex 8-port Ethernet
*	0x30		Lyon Lamb IVAS
*	0xb8		GIO 100BaseTX Fast Ethernet (gfe)
*
* 32-bit IDs
*	0x85		ATM board
*	0x87		16 bit SCSI Card
*	0x8c		SMPTE 259M Video
*	0x8d		Babblefish Compression
*
#endif /* GIOBUS */
*****************************************************************************

#if defined(EV_EPC)
*****************************************************************************
*
* VECTOR lines with bustype=EPC
*	This includes the VECTOR lines for Ethernet and Serial ports on
*	Challenge/Onyx systems.
*
* In Challenge/Onyx systems, the EPC controls simple low-throughput
* devices such as the ethernet and the serial ports. bustype=EPC is used
* to specify devices attached to the EPC.
*
* Devices on EPC are specified using the VECTOR lines. VECTOR lines for
* EPC is similar to that used for VME devices.
*
* VECTOR lines for EPC Ethernet/EPC serial port interface.
*
* Each VECTOR line should have
*	bustype=EPC
*	module=epcether for EPC Ethernet and
*	module=epcserial for EPC Serial ports
*	unit=?		the unit number for this device (0,1,..)
*	slot=?		slot no of IO4 board
*	ioa=?		IO Adapter no of EPC
*			slot=0 and ioa=0 maps to Master IO4
*			and default EPC Adapter(1) on Master IO4.
*
*	adapter=??	could be used in place of slot and ioa..It is
*			calculated as (slot * 8)+ ioa.  adapter=0 would
*			map to Master IO4 and default EPC adapter (1) on
*			Master IO4.
*
*	intrcpu=?	cpu to send interrupts to for the device. This
*			option requires the cooperation of the device and
*			may not be implemented for all drivers
*
*	syscallcpu=?	cpu to route syscalls to for the device. This
*			option is silently ignored on MP drivers. This
*			option should be used with caution, as a non-mp
*			driver may expect its interrupts to run on the
*			same cpu as its syscall entry points.
*
*	probe and probsize is not supported for EPC enet and serial devices.
*
*****************************************************************************
#endif /* EV_EPC */

/* There are two kinds of cpp ifdefs in this file.   First, there are
 * 'mr', 'ship', 'kdebug', and 'diskless', which define which kind of
 * kernel we are building.  Second, there are 'IP19', 'IP30', etc.
 * which define which kind of hardware will use the kernel.
 */
#ifdef diskless			/* tell customers what system.dl is */
*
* A "diskless" kernel, built from system.dl is what is run while building
*	the kernel for a diskless machine.  It should be small, excluding
*	everything not needed to build the real kernel.  It is a
*	"mini-root kernel" for diskless machines.
#endif
/* The "mr" or mini-root kernel is the kernel shipped on the tapes.
 *	It should also be small.
 *
 * The "system.ship" file is what is shipped to customers.
 */

*
* The following statements direct lboot as it generates a kernel.
* There are 2 styles of VECTOR line.  The preferred style is defined
* first and in depth in the driver writers guide and the system
* file man page.  Also look within this file for examples.
*
*	VECTOR directives must be before all other lboot directives which
*		refer to modules, such as USE, INCLUDE, and EXCLUDE.
*
*	VECTOR lines must occur in the opposite order that the devices
*		should be probed.  Do not change the order of the VECTOR
*		lines in this file, unless you understand the implications.
*
* VECTOR: bustype module adapter [ipl [vector]] [ctlr] iospace iospace2
*	  iospace3 probe_space exprobe_space
*
*	bustype: bus the device sits on.
*	module:  boot module
*	adapter: identifies which bus of type bustype
*	ipl:	 VME interrupt priority level
*	ctlr:	 identifying number for driver
*	iospace: base address of card
*	iospace2,3:	additional addresses passed to driver edtinit
*	probe_space:	address and size to be read to determine existence
*			of card (not specified)
*	exprobe_space:	extended probe which allows for reading and value
*			checking and writing of values as part of the probe.
*
* The old style VECTOR line is defined as:
*
* VECTOR: module [intr] [vector ipl unit] [base] [probe [probe_size]]
*		[base2] [base3]
*
*	module: boot module
*	intr:	interrupt function (default: module_prefix|"intr")
*	vector: vme interrupt vector
*	ipl:	(vme or local IRQx) interrupt priority level
*		do not specify it unless it is needed
*	base:	base address of card
*	probe:	address read to determine existence of card
*		(no probe address implies existence)
*	probe_size: size of probe (default 4 bytes)
*	base2, base3:	additional addresses passed to driver edtinit
*		routine via edt structure
*
#if defined(VMEBUS)
*==========================================================================
*
*  System with multiple VME busses can reach higher levels of performance
*  when certain boards are spread out among the available busses.  In
*  the past, the method for
*  specifying which VME bus a device was connect to required the use of
*  special VMEPREFIXs which would be prepended to the boards VME bus
*  address.  Now, it is a simpler matter of just determining the VME bus
*  number that the device is on and changing the adapter=0 field in the
*  VECTOR line to the appropriate value.
*
*  On an IP19, the VME bus adapter number specified encodes the IO4 Ebus
*  slot and the adapter position upon the IO4 to which the VME bus is
*  connected.  There are only 4 adapter positions on the IO4 which can
*  be used for VME.  These are positions 2, 3, 5 and 6.  The prom command
*  'hinv -v -b' can be used to determine both the IO4 Ebus slot number
*  and the IO4 adapter position of the VME bus adapter.  The IO4 adapter
*  positions 2, 3, 5 and 6 are translated into VME positions 0, 1, 2 and 3.
*  The VME bus adapter number used in the VECTOR line is then computed as:
*
*            VME adap # = IO4 Ebus Slot * 4 + VME position.
*
*
#endif
*****************************************************************************



/* Do not put extra TABs here, to keep system.ship readable.
 */
#if defined(noprobe)
NOPROBE: 1
#define pr(addr,sz)
#define ex_pr(x)
#else
NOPROBE: 0
#define pr(addr,sz)probe=addr probe_size=sz
#define ex_pr(x)exprobe=x
#endif


*
*
* lboot/system-file version
VERSION: 3



/* kVECTOR should be used for those devices that should not be normally
 *	included in debugging kernels.  Those who want to use the devices
 *	must remove a comment character in the system file.
 * kUSE modules do not go into debugging kernels so as to keep the size
 *	under control. These are mostly those modules which are not in
 *	common use.
 */
#if defined(kdebug)
#define kVECTOR *VECTOR
#define kUSE EXCLUDE
#else
#define kVECTOR VECTOR
#define kUSE USE
#endif

/*	Remove non-global symbols for better disk space usage
 *	in the miniroot, where we have have 5 kernels.  This saves over a
 *	Mbyte in the miniroot.  Leave them in other kernels because
 *	dbx will not work if -x is used.
 */
#if defined(mr)
#define LSTRIP -x
#else
#define LSTRIP
#endif

/*	For the miniroot, force all modules to be linked into the
 *	kernel, whether they are normally loadable or not, since we
 *	do not have /var/sysgen/boot objects in the miniroot to load.
 */
#if defined(mr)
LINKMODULES:1
#endif

/* mVECTOR should be used for devices drivers which should not be include
 *	in debugging or mini-root kernels.
 */
#if defined(mr) || defined(diskless)
#define mVECTOR *VECTOR
#else
#define mVECTOR kVECTOR
#endif

/* mrVECTOR should be used for devices which should not be put in mini-root
 *	but should go in debugging kernels.
 */
#if defined(mr) || defined(diskless)
#define mrVECTOR *VECTOR
#else
#define mrVECTOR VECTOR
#endif

/* sVECTOR should be used for devices which are unlikely
 *	to be used in a single, small-slot VME (6U) machine, but should
 *	appear in all other kernels.
 * skVECTOR is like sVECTOR, but excludes it from debgging kernels
 */
#if defined(IP20) || defined(IP22) || defined(IP26) || defined(IP28) || defined(IP32) || defined(IPMHSIM)
#define sVECTOR *VECTOR
#define skVECTOR *VECTOR
#else
#define sVECTOR VECTOR
#define skVECTOR kVECTOR
#endif

/* smVECTOR should be used for devices which should not be put in mini-root
 *	or debugging kernels and which are unlikely to be used in small
 *	machines.
 */
#if defined(IP20) || defined(IP22) || defined(IP26) || defined(IP28) || defined(IP32) || defined(IPMHSIM) || defined(SABLE)
#define smVECTOR *VECTOR
#else
#define smVECTOR mVECTOR
#endif

/* mrUSE should be used for modules which should not be put in mini-root
 *	kernels but should go in debugging kernels.
 * mrkUSE modules do not go in either the miniroot or debugging kernels
 *	as determined by the kUSE rule.
 */
#if defined(mr)
#define mrUSE EXCLUDE
#define mrkUSE EXCLUDE
#else
#define mrUSE USE
#define mrkUSE kUSE
#endif

/* CC sync register used by power fortran. */
#if EVEREST && !LARGE_CPU_COUNT
mrUSE: ccsync
#endif /* EVEREST */

#ifdef VMEBUS
#ifdef EVEREST
#if !defined(mr)
USE: usrdma
#endif
#endif /* EVEREST */

#ifdef ULI
/* Sample config line for vme user level interrupt support.
 * VECTOR: bustype=VME module=vmeuli ipl=<ipl> adapter=<adap> vector=<vec>
 * 
 * <ipl> is the level at which the vme device will interrupt.
 * <adap> is the adaptor number that the device is attached to.
 * The optional <vec> argument is used to reserve a hardcoded vector
 * value. If the device has a programmable vector number, this value
 * may be omitted, and a vector may be assigned dynamically by the system.
 * see uli(3) for mode info
 */
kVECTOR: bustype=VME module=vmeuli ipl=6 adapter=0
#endif

*
* "6-port" (really 8-port) serial controller
kVECTOR: bustype=VME module=cdsio ipl=5 ctlr=0 adapter=0 iospace=(A24S,0xF00000,0x10000) probe_space=(A24S,0xF0FFFF,1)
skVECTOR: bustype=VME module=cdsio ipl=5 ctlr=1 adapter=0 iospace=(A24S,0xF10000,0x10000) probe_space=(A24S,0xF1FFFF,1)
skVECTOR: bustype=VME module=cdsio ipl=5 ctlr=2 adapter=0 iospace=(A24S,0xF20000,0x10000) probe_space=(A24S,0xF2FFFF,1)
skVECTOR: bustype=VME module=cdsio ipl=5 ctlr=3 adapter=0 iospace=(A24S,0xF30000,0x10000) probe_space=(A24S,0xF3FFFF,1)
#endif /* VMEBUS */

*
*
* Network Interfaces
*
*	Primary interface is determined by network script via "primary"
*	flag for "ifconfig" regardless of the order in lboot drv list.
*

#if EVEREST && !SABLE
VECTOR: bustype=LOCAL module=if_ee
#endif

#if (SN && !defined(SABLE)) || defined(IP30)
USE: if_ef
USE: if_eg
#endif
#if (SN && !defined(SABLE)) || defined(IP30) || defined(IP32)
*
* RNS PCI FDDI board
*
VECTOR: module=if_rns probe_path="/hw/.id/pci/11122200"
#endif

#if EVEREST && !SABLE
*
*Vector lines for EPC Ethernet and Serial ports on Challenge/Onyx systems.
*
VECTOR: bustype=EPC module=epcether  unit=0 slot=0 ioa=0
VECTOR: bustype=EPC module=epcserial unit=0 slot=0 ioa=0
VECTOR: bustype=EPC module=epcserial unit=1 slot=9
VECTOR: bustype=EPC module=epcserial unit=2 slot=7
*
*Modify following lines with to add additional Ethernet/serial adapters.
*
*VECTOR: bustype=EPC module=epcether  unit=1 slot=? ioa=1
*VECTOR: bustype=EPC module=epcether  unit=2 slot=? ioa=1
*VECTOR: bustype=EPC module=epcether  unit=3 slot=? ioa=1
*VECTOR: bustype=EPC module=epcserial unit=3 slot=? ioa=1
*
*
#endif

#ifdef VMEBUS

#if !defined(SN)
*
* EFAST vertor line setup.
#define FXP(v,u,a,p) bustype=VME module=if_fxp ipl=4 adapter=v ctlr=u iospace=(A32S,a,0x40000) probe_space=(A32S,p,2)
smVECTOR: FXP(0,3,0x19800000,0x19801000)
smVECTOR: FXP(0,2,0x19840000,0x19841000)
VECTOR:   FXP(0,1,0x19880000,0x19881000)
VECTOR:   FXP(0,0,0x198c0000,0x198c1000)
#undef FXP
#endif /* !SN */

#if !defined(SN)
*
* FDDIXPress FDDI
#define IPG(u,a,p) bustype=VME ipl=4 adapter=0 ctlr=u iospace=(A16S,a,512) exprobe_space=(r,A16S,p,2,0xfdd1,0xffff)
smVECTOR: module=if_ipg IPG(3,0xb400,0xb402)
smVECTOR: module=if_ipg IPG(2,0xb200,0xb202)
sVECTOR: module=if_ipg IPG(1,0xae00,0xae02)
VECTOR: module=if_ipg IPG(0,0xac00,0xac02)
#undef IPG
#endif /* !SN */
#endif /* VMEBUS  */

*
* Madge Tokenring driver
#if 0
*	EISA version on Indigo2
#endif
*	PCI version on Octane, O2 and Origin
#if 0
#if defined(IP22) || defined(IP26) || defined(IP28)
* VECTOR: bustype=EISA module=if_mtr ctlr=1 iospace=(EISAIO,0x1000,0x1000) exprobe_space=(r,EISAIO, 0x1c80,4,0x02008734,0xffffffff)
* VECTOR: bustype=EISA module=if_mtr ctlr=2 iospace=(EISAIO,0x2000,0x1000) exprobe_space=(r,EISAIO, 0x2c80,4,0x02008734,0xffffffff)
* VECTOR: bustype=EISA module=if_mtr ctlr=3 iospace=(EISAIO,0x3000,0x1000) exprobe_space=(r,EISAIO, 0x3c80,4,0x02008734,0xffffffff)
* VECTOR: bustype=EISA module=if_mtr ctlr=4 iospace=(EISAIO,0x4000,0x1000) exprobe_space=(r,EISAIO, 0x4c80,4,0x02008734,0xffffffff)
#endif	/* IP22 || IP26 || IP28 */
#endif
#if defined(IP30) || defined(IP32) || defined(SN0)
VECTOR: module=if_ptr probe_path="/hw/.id/pci/10B6000[2,4]"
#endif /* IP30 || IP32 || SN0 */

*
* XPI FDDI board
*
#if defined(IP20)
VECTOR: module=if_xpi vector=0x0 ctlr=1 base=GIO_SLOT1 ex_pr((r,GIO_SLOT1,4,1,0xff))
VECTOR: module=if_xpi vector=0x0 ctlr=0 base=GIO_SLOT0 ex_pr((r,GIO_SLOT0,4,1,0xff))
#endif /* IP20 */
#if defined(IP22) || defined(IP26) || defined(IP28)
VECTOR: module=if_xpi vector=0x0 ctlr=2 base=GIO_SLOTGFX ex_pr((r,GIO_SLOTGFX,4,1,0xff))
VECTOR: module=if_xpi vector=0x0 ctlr=0 base=GIO_SLOT0 ex_pr((r,GIO_SLOT0,4,1,0xff))
#endif /* IP22 || IP26 || IP28 */
#if defined(IP22)
VECTOR: module=if_xpi vector=0x0 ctlr=1 base=GIO_SLOT1 ex_pr((r,GIO_SLOT1,4,1,0xff))
#endif /* IP22 */

#ifdef EVEREST
VECTOR: bustype=DANG module=if_xpi adapter=* exprobe_space=(r,DANG,0,4,0x0a,0xff)

*
* E-Plex 8-port Ethernet board
*
VECTOR: bustype=DANG module=if_ep adapter=* exprobe_space=(r,DANG,0,4,0x0e,0xff)

#endif /* EVEREST */

#if IP22 && !defined(_MIPS3_ADDRSPACE)
*
* GIO slot Ethernet cards in INDY/HPC3 machines
*
VECTOR: module=if_eg2 vector=0x0 ctlr=1 base=HPC_1_ID_ADDR ex_pr(((rn,HPC_SYS_ID,4,0x01,0x01),(rn,HPC_HOLLY_1_LIO,1,0x01,0xff)))
VECTOR: module=if_eg2 vector=0x0 ctlr=2 base=HPC_2_ID_ADDR ex_pr(((rn,HPC_SYS_ID,4,0x01,0x01),(rn,HPC_HOLLY_2_LIO,1,0x01,0xff)))
*
* GFE GIO Fast Ethernet 100BaseTX
*
VECTOR: module=if_gfe vector=0x0 ctlr=0 base=0xBF400000 ex_pr((r,0xBF400000,4,0xb8,0xff))
VECTOR: module=if_gfe vector=0x0 ctlr=1 base=0xBF600000 ex_pr((r,0xBF600000,4,0xb8,0xff))

#endif /* IP22 */

#if defined(IP19) || defined(IP21) || defined(IP25)
* VME Fast Ethernet (if_vfe) 100BT card
*VECTOR: bustype=VME module=if_vfe ipl=4 adapter=0 ctlr=3 iospace=(A16NP,0x9000,0x1000) iospace2=(A32NP,0x19800000,0x100000) probe_space=(A16NP,0x9000,4)
*VECTOR: bustype=VME module=if_vfe ipl=4 adapter=0 ctlr=2 iospace=(A16NP,0x8000,0x1000) iospace2=(A32NP,0x19700000,0x100000) probe_space=(A16NP,0x8000,4)
VECTOR: bustype=VME module=if_vfe ipl=4 adapter=0 ctlr=1 iospace=(A16NP,0x7000,0x1000) iospace2=(A32NP,0x19600000,0x100000) probe_space=(A16NP,0x7000,4)
VECTOR: bustype=VME module=if_vfe ipl=4 adapter=0 ctlr=0 iospace=(A16NP,0x6000,0x1000) iospace2=(A32NP,0x19500000,0x100000) probe_space=(A16NP,0x6000,4)

#endif /* IP19/IP21/IP25 */

#if defined(IP20) || defined(IP22) || defined(IP26) || defined(IP28)
*
* Integral Ethernet interface
*
VECTOR: module=if_ec2
#endif /* IP20 || IP22 || IP26 || IP28 */

#if defined(IP32) || defined(IPMHSIM)
*
* Motherboard Ethernet interface on Moosehead
*
VECTOR: module=if_me
*
* PCI slot Ethernet cards on Moosehead
*
VECTOR: module=if_ecf probe_path="/hw/.id/pci/104C0500"
#endif /* IP32 || IPMHSIM */

#if defined(IP20)
*
* Parallel Port
*
VECTOR: module=hpcplp
#endif

#if defined(IP22) || defined(IP26) || defined(IP28)
*
* Parallel Port
*
VECTOR: module=hpc3plp
#endif

#if defined(IP32) || defined(IPMHSIM)
*
* Parallel Port
*
VECTOR: module=ecplp
#endif /* IP32 || IPMHSIM */

#if defined(IP27) || defined (IP30) && !defined(SABLE) 
*
* parallel port
*
VECTOR: module=ecpplp
#endif

#if defined(EVEREST) && !defined(SABLE)
*
* Parallel Port - we want this in miniroot kernels so that customers
*		  can print their on-line release notes.
*
VECTOR: module=epcplp

*
* External interrupts
*
#if !defined(mr)
VECTOR: module=epcei
#endif

*
* System Controller Driver
*
VECTOR: module=sysctlr

*
*
* Flash prom driver
*
VECTOR: module=flash
#endif	/* EVEREST && !SABLE */

#if defined(IP30)
*
* Flash prom driver for Octane systems.
*
USE: sflash
#endif	/* IP30 */

/*
 * We cannot probe for this adapter since its absence will not cause a
 * bus error on all machines.
 * Only one edt table is generated regardless of the number of adapters.
 * One call handles all of them.  Those present are probed and counted
 * by scsiunit_init(), which is called from the machine specific
 * startup code.
 *
 */
*
* SCSI host adapter driver
*
#if defined(EVEREST)
#if defined(SABLE)
EXCLUDE: wd93, wd95
INCLUDE: pci
VECTOR: bustype=GIO module=pci vector=0x0 unit=0 base=0x9200000080000000
#else
USE: wd95
EXCLUDE: wd93
VECTOR: module=wd95 unit=0 base=0
VECTOR: module=scip unit=0 base=0
*VECTOR: module=fcadp unit=0 base=0
#ifdef GIO2PCI
INCLUDE: pci
VECTOR: module=ql
VECTOR: bustype=GIO module=pci vector=0x0 unit=0
#endif
#endif /* SABLE */

#elif defined(IP22)
VECTOR: module=wd95 vector=0x0 ctlr=0 base=0xBFB00000 ex_pr(((rn,HPC_SYS_ID,4,0x01,0x01),(r,HPC3_NOT_HPC1,4,0,0)))

#ifdef GIO2PCI
/*
 *  Only 1 vector line is needed.  pci_startup (PCI Infrastructure) will go look
 *  at both config slots.
 */
VECTOR: module=ql
INCLUDE: pci
#if defined(_MIPS3_ADDRSPACE)
VECTOR: bustype=GIO module=pci vector=0x0 unit=0 base=0x900000001F400000
#else
VECTOR: bustype=GIO module=pci vector=0x0 unit=0 base=0xBF400000
#endif
#endif /* GIO2PCI */

#ifdef ADAPTEC_PCI_SCSI
VECTOR: module=adp78 unit=0
USE: adphim
#endif /* ADAPTEC_PCI_SCSI */

#elif defined(IP27) || defined (IP33)
#if defined(SABLE)
EXCLUDE: wd93, wd95, ql
#else /* Normal IP27, IP33 */
EXCLUDE: wd93 wd95
#endif /* !SABLE */

#elif defined(IP32) && !defined(IP32SIM)
VECTOR: module=adp78 unit=0
USE: adphim
#ifdef ADP_STATS
USE: scsi_stats
#endif
#ifdef VDM
USE: vdm
#endif
EXCLUDE: wd93, wd95

#else
EXCLUDE: wd95
#endif /* EVEREST elif IP30 elif IP22 elif IP27 elif IP32 elif IP33*/

#if defined(IP32)
VECTOR: module=qlfc probe_path="/hw/.id/pci/10772200"
#endif

#if defined(IP30) || defined(SN)
#if defined(mr) || defined(kdebug)
VECTOR: module=qlfc
#else
VECTOR: module=qlfc probe_path="/hw/.id/pci/10772[12]00"
#endif

VECTOR: module=fcadp
VECTOR: module=ql

* Q-logic SCSI controller custom configuration                 
* Note:  All variables must be given in decimal.
*								
* These DEVICE_ADMIN directives are used to custom configure 	
* q-logic scsi (not fibre channel) controllers.
*								
* These directives take the form:
* DEVICE_ADMIN: hw_graph_path variable_name=variable_value	
*                                                              
* The following Q-logic driver variables can be set with the   
* DEVICE_ADMIN	directive. NOTE, some variables can be applied to all
* targets, or to only a particular target, while others apply to 
* only to the controller. In such cases, the hw_graph_path supplied
* must be that of a target and of a controller respectively.
*
* e.g. controller path
*    /hw/node/xtalk/9/pci/0/scsi_ctlr/0
*    or 
*    /hw/module/1/slot/io5/mscsi/pci/3/scsi_ctlr/0
*
* e.g. target path
*    /hw/node/xtalk/9/pci/0/scsi_ctlr/0/target/3
*    or 
*    /hw/module/1/slot/io5/mscsi/pci/3/scsi_ctlr/0/target/3
*
*  applicable to controller	applicable to target
*  -------------------------	---------------------
*  ql_hostid                    ql_disconnect_allowed
*  ql_selection_timeout         ql_ctq_enable
*  ql_disconnect_allowed        ql_sync_enable
*  ql_ctq_enable                ql_wide_enable
*  ql_sync_enable          	ql_sync_period
*  ql_wide_enable          	ql_force_sync_negotiation
*  ql_sync_period          			
*  ql_sync_offset          		   
*			   
*			   
* 
* ql_disconnect_allowed: default value=1                       
*     by default disconnects are enabled.                      
*     set ql_disconnect_allowed = 0 to disable disconnects     
*     for the controller                                       
*                                                              
* ql_ctq_enable: default value=1                               
*     by default command tag queuing is enabled.               
*     set ql_ctq_enable=0 to disable command tag queuing for   
*     the controller                                           
*                                                              
* ql_sync_enable: default value=1                              
*     by default command synchronous operation is enabled      
*     set ql_sync_enable=0 to disable synchronous operation   
*     for the controller                                       
*                                                             
* ql_sync_period: default value=12                            
*     the following are valid ql_sync_period values            
*                                                              
*      value   period                                          
*       12      50ns  - ULTRA SCSI                             
*       25      100ns - FAST                                   
*       50      200ns - SLOW                                   
*	100     400ns
*                                                              
* ql_sync_offset: default value=8                              
*     valid values for the synchronous offset or 0 -> 12       
*     8 has been chosen for optimal performance               
*                                                              
* ql_wide_enable: default value=1                              
*     reset ql_wide_enable to zero to disable wide(16bit) operation      
*     for the controller                                       
*
* ql_force_sync_negotiation: default value=0
*     some SCSI-1 devices don't set bit 4 byte 7 (sync capable) and
*     consequently the QL driver will not attempt sync
*     negotiation. This variable may be used to force sync negotiation
*     in such cases.
*
#if defined(SN0)
*     note that on Origin 200 machines the default value is zero for
*     /hw/module/1/slot/n1/node/xtalk/8/pci/1/scsi_ctlr/0 and cannot
*     be set to one.
#endif
*                                                              
* ql_hostid: default value=0                                   
*     For maximum throughput, set the host adapter id to 7.    
*     For maximum fairness, set it to 0.                       
*     SCSI devices that have bus id numbers lower than the     
*     host adapter, and have two other devices with higher    
*     numbers on the bus, may not get the SCSI bus for        
*     extended periods of time when the two higher numbered    
*     devices are busy.                                        
*                                                              
*     For example, if the host adapter id number is 5, and     
*     there are devices at 6 and 4, devices numbered 3 and     
*     lower may not get the SCSI bus when * they need it.      
*                                                              
*     If there is a device with the same address as the host   
*     adapter, nothing on that SCSI bus will work.             
*
* ql_selection_timeout: default value=250                      
*
* Allowed values for selection timeout are                     
*   1 sec  - 1000                                              
*   750 mS - 750                                               
*   500 mS - 500                                               
*   250 mS - 250                                               
*   100 uS - 100                                               
*   75 uS  - 75                                               
*   50 uS  - 50                                                
*   25 uS  - 25                                                

#endif /* IP30 || SN */

#if defined(EVEREST) || defined(IP30) || defined(SN)
EXCLUDE: wd93
#else /* EVEREST && IP30 */
#if (!(defined(IP32) || defined(IPMHSIM)))
#if !defined(_MIPS3_ADDRSPACE)
VECTOR: module=wd93 unit=0 base=0xBFB00000
#endif
#if defined(_MIPS3_ADDRSPACE)
VECTOR: module=wd93 unit=0 base=0x900000001FB00000
#endif /* _ABI64 */
#endif /* !(IP32 || IPMHSIM) */
#endif /* EVEREST || IP30 */

*
* SCSI modules
*    These cannot be probed for so must always be manually included.
*	dksc	- Hard Disk and CD-ROM
*	tpsc	- Tape
*	smfd	- Floppy
*	ds	- Generic SCSI support (devscsi)
*
#if defined(SABLE) || defined(IPMHSIM) || defined(IP32SIM)
USE: sabledsk(0)
VECTOR: module=sabledsk
#else
USE: cdl, scsi, dksc, tpsc, tpscutil, ds, scsiha
#endif	/* !SABLE */
/* smfd is loadable, and suported on all machines, so always include it if
	not miniroot */
#if !defined(mr)
USE: smfd
#endif

#if defined(br)
/* RAM "disk" */
USE: ram
#endif

#if !defined(diskless)
*
* XLV Logical volume pseudo-device driver core
*
USE: xlv
*
* XLV Logical volume plexing support
*
USE: xlv_plex
*
* FAILOVER Dual path HA failover support
*
USE: failover
#endif

#if defined(CKPT)
USE: cpr
#else
USE: cprstubs
#endif

#if defined(IP32)
USE: kitchenstubs
#endif

#if CELL
#if EVEREST && !MULTIKERNEL
USE: partition
USE: xpc
#endif
USE: cell
#endif

*
* File systems
*      efs       - Local Disk filesystem
*      xfs       - XFS Local filesystem
*      grio	 - guaranteed rate I/O for xfs
*      xfsrt	 - grio support in xfs
*      dmi	 - data management interfaces
*      xfsdmapi  - XFS specific data management interfaces
*      umfs      - User Mode Filesystem
*      nfs,snfs  - Network File System
*      nfs3      - Network File System version 3 client
*      proc      - Debug (/proc) pseudo-filesystem, see proc(4)
*      uds       - Unix Domain Socket, see Unix(7F)
*      fifofs    - Streams-based pipes and fifos
*      pipefs    - Old style, uni-directional pipes, see pipe(2)
*      specfs    - Character and block device interface
*      fd        - File descriptor (/dev/fd) pseudo-filesystem, see fd(4)
*      namefs    - Mountable streams, see fattach(3C)
*      cfs	 - Nexus Cell File System
*      cxfs	 - Cellular XFS V1 (uses CFS)
*
* The /dev/fd filesystem must be marked USE to allow for the execution
* of set-user-ID/set-group-ID interpreter scripts (see exec(2)).
*
INCLUDE: specfs, pipefs, proc, fifofs, hwgfs
mrUSE: fd, namefs
USE: efs, uds
#if defined(ship) || defined(kdebug) || defined(diskless) || defined(br)
USE: nfs, snfs, lockd, nfs3, svckudp
#else
EXCLUDE: nfs, snfs, lockd, nfs3, svckudp
#endif

*
* onc3 modules
*
#if defined(ship) || defined(kdebug) || defined(diskless) || defined(br)
USE: autofs, cachefs, lofs
#else
EXCLUDE: autofs, cachefs, lofs
#endif

#if !defined(diskless)
*
* Disk quota subsystem (see quotaon(1M) command)
*
mrkUSE: quotas
kUSE: xfsquotas
#else
EXCLUDE: quotas, xfsquotas
#endif

*
* CXFS-V1 subsystems require both CFS and XFS
* They should appear before XFS and CFS for proper linking
*
#if CELL && !defined(diskless)
USE: cxfs
#else
EXCLUDE: cxfs
#endif
#if CELL_ARRAY && !defined(diskless)
USE: cxfsarr
#endif

*
* XFS related subsystems
*
#if defined(diskless)
USE: xfs, grio, dmi, xfsdmapi, xfsrt, umfs
#else
#ifndef SABLE		/* grio pulls in dksc which sable kernels do not use */
mrUSE: dmi xfsdmapi umfs
#if !defined(PERF_BUILD)
mrUSE: grio
mrUSE: xfsrt
#endif
#endif
*
* NOTE: xfs USE line must come *after* its 'dependents' (eg. xfsrt,dmi) 
* or those dependents may not get linked in.
*
USE: xfs    
#endif

*
* Note cfs USE line is the last of the file systems because this will
* cause to the be first in vfssw and so non-golden cells will have a
* chance (in dcvfs_rootinit) to do a remote mountroot.  
*
#if CELL
USE: cfs
#else
EXCLUDE: cfs
#endif


*
* Hardware graph subsystem
*
USE: graph

#if EVEREST || SN || IP30
#if defined(ship) || defined(kdebug)
*
* Frame Scheduler 
*
kUSE: frs
#endif
#endif

#if EVEREST
#if defined(ship) || defined(kdebug)
*
* FRU Analyzer
*
USE: fru
*
#endif
#endif

*
* libnsl (TLI) & libsocket helper modules
*
#if !defined(sesmgr_enabled)
mrkUSE: sockmod, timod, tirdwr,
#endif
*
* TPI loopback device drivers
*
#if !defined(sesmgr_enabled)
mrkUSE: ticlts, ticots, ticotsord
#endif
*
* TPI Streams device drivers for sockets networking
*
#if !defined(sesmgr_enabled)
mrkUSE: tpisocket, tpitcp, tpiudp, tpirawip, tpiicmp
#endif
*
* DLPI: Data Link Provider Interface
*
USE: xtimer, snif
USE: llc2
*
* SVR4 tty compatibility modules
*
mrUSE: ldterm, ptem
*
* Streams based pipe support
*
mrUSE: pipemod
mrUSE: connld
*
* Streams event logger (see strerr(1M))
*
USE: log
*
* Streams administrative device
*
USE: sad
*
* Internationalization Support (see kbdset(1))
*
* alp - Algorithm Pool
* kbd - Keyboard mapping and string translation
*
mrUSE: kbd, alp
*
* IP Filter (see ipfilterd(1M))
*
mrUSE: ipfilter
*
* IP Multicast routing (see mrouted(1M))
*
mrUSE: ip_mroute
*
* Serial Line IP (see slip(1M))
*
mrkUSE: if_sl
*
* Point to Point Protocol (see ppp(1M))
*
mrkUSE: if_ppp
*
* swIPe Protocol
*
kUSE: if_sw
*
* network load sharing pseudo-device driver
*
USE: if_ls
USE: if_lsp

#if !defined(diskless)
*
* Filesystem Control (see fsr(1M))
*
mrUSE: fsctl
#else
EXCLUDE: fsctl
#endif

*
* Inode Monitor (see famd(1M))
*
mrUSE: imon

****************************************************************
*  The following modules implement security features that are
*  part of Irix.  The audit trail and access control lists are
*  not installed  be default.  Capability must always be present.

*
*  Extended attribute support
*
USE: xfs_attr_fetch
USE: eag

*
*  Security Audit Trail
*
#if !defined(PERF_BUILD)
#if !defined(SN0) || !defined(CELL_IRIX)
* TEMP   - disable on SN0 cells.
mrUSE: sat
#endif
#endif

*
* Capability (Privilege) Sets
*
USE: capability

*
* Access Control Lists (ACLs)
*
#if !defined(PERF_BUILD)
USE: acl
USE: acl_hwg
USE: acl_xfs
mrUSE: acl_nfs3
#endif

****************************************************************
*  The following modules are installed with the Trix B1/CMW
*  add-on package.

*
* Mandatory Access Control
*
#if defined(ship) || defined(mac_enabled)
mrUSE: mac
mrUSE: cap_mac_access
mrUSE: mac_nfs3
mrUSE: mac_xfs
mrUSE: mac_ipc
mrUSE: mac_specfs
mrUSE: mac_autofs
mrUSE: mac_proc
mrUSE: mac_pipe
mrUSE: mac_fifo
mrUSE: mac_fd
mrUSE: mac_efs
mrUSE: mac_hwg
#endif

*
* Network Session Manager
*
#if defined(ship) || defined(sesmgr_enabled)
mrUSE: sesmgr
mrUSE: ip_sec
#endif
****************************************************************

*
* Kernel Asyncio for Informix
*
mrkUSE: kaio

*
* Post Wait driver for Oracle
*
mrkUSE: postwait

*
* kernel listio (Oracle Performance)
*
mrkUSE: klistio

*
* ShareII Resource Management System from Softway
*
kUSE: shareII

*
* Stubs
*
USE: dnstubs, gfxstubs, prfstubs, quotasstubs, idbgstubs, nfsstubs
USE: pipefsstubs, vidstubs, ng1stubs, gr2stubs, frsstubs, griostubs
USE: efsstubs, xfsstubs, xfsquotasstubs, xlvstubs, tpisocketstubs, bpqueuestubs
USE: dmistubs, xfsdmapistubs, umfsstubs
USE: macstubs, aclstubs
USE: satstubs, sesmgrstubs
USE: xlvplexstubs
USE: failoverstubs
USE: cachefsstubs, nlmstubs, lockdstubs, mgrasstubs, crimestubs
USE: xfsrtstubs, frustubs, cachefsidbgstubs, kaiostubs, devicestubs, mgvstubs
USE: dfsstubs, postwaitstubs, klistiostubs, uncstubs
USE: shareIIstubs
USE: cxfsstubs 
USE: swipestubs
USE: atmstubs
USE: lofsstubs, autofsstubs

#if CELL
USE: cxfsarrstubs
#endif

#if SN
*
* SN specific stubs
*
USE: partitionstubs
USE: xpcstubs
USE: if_clstubs
USE: numaidbgstubs
#endif

*
* Spin locks - both kernel and user level
* Kernel spinlocks used only on MultiProcessor systems
*	nolocks           - used on non-MP systems
*	hardlocks         - Default spinlock module
*	dhardlocks        - Spinlock module with debug code
*	hardlocks_statistics - Spinlock module to be used with ksync_statistics module
*		to gather extended statistics on lock usage
*		(REQUIRES ksync_statistics be loaded)
*
#if defined(MP)

#if defined(kdebug) && defined(DEBUG_LOCKS)
INCLUDE: dhardlocks
#else	/* !kdebug */
INCLUDE: hardlocks
#endif	/* kdebug */
#else	/* NOT an MP machine */
INCLUDE: nolocks
#endif

#if EVEREST || SN
* Tie a VME level to a processor by adding a line of the form
* "IPL: <level> <cpuid>".
* Interrupts from VME levels that are not specifically bound
* to a processor, interrupt from VME levels that are bound to
* non-existant or disabled processors, and all non-VME interrupts
* are assigned CPUs at boot time, using a "spray" heuristic.
* Example: In order to send all VME level 3 interrupts to CPU1, use:
* IPL: 3 1
#endif

#if EVEREST || SN || IP30
* Declare a CPU that is not suitable for "sprayed" interrupts
* (usually, because they will be used for real-time activities) using
* the NOINTR directive.
* Example: to declare that cpu 3 should not accept sprayed
* interrupts, use: "NOINTR: 3". You may NOT restrict CPU 0 from receiving
* interrupts.  You can specify multiple cpus on the NOINTR line.
#endif

#if EVEREST || SN
* You CAN tie a VME interrupt to a processor that accepts no sprayed
* interrupts using the IPL directive, above.
#endif

#if EVEREST || SN || IP30
* One can also use the NOINTR device administration directive to 
* disable interrupts on a particular CPU.  For example, on Origin:
* DEVICE_ADMIN: /hw/module/1/slot/n3/node/cpu/a NOINTR=1
*
* One can use the INTR_TARGET device administration directive to
* direct interrupts from a device to a particular cpu in the system. 
* For example, on Origin:
* DEVICE_ADMIN: /hw/module/1/slot/n3/node/xtalk/8/pci/1 INTR_TARGET=/hw/cpunum/2
* DEVICE_ADMIN: /hw/module/1/slot/n3/node/xtalk/8/pci/1 INTR_TARGET=/hw/module/1/slot/n4/node/cpu/b
#endif

#if EVEREST || SN 
* One can use the INTR_SWLEVEL device administration directive to 
* specify the thread priority level at which the ithread for 
* handling the device interrupts is supposed to run.
* For example, on Origin:
* DEVICE_ADMIN: /hw/module/1/slot/n3/node/xtalk/8/pci/1 INTR_SWLEVEL=231
#endif

*
*
* Required kernel modules
*
*   kernel   - machine specific
*   os	     - system calls, vm, etc..
*   disp     - Process scheduler
*   numa     - Numa Memory Management
*   kmem     - kernel memory allocation 
*	or  kmem_debug     - memory allocation with debugging
*				kmem_debug is only available if eoe.sw.kdebug
*				has been installed.  It's usage is described
*				under the kmem_do_poison tunable in mtune/kernel
*   ksync    - kernel synchronization onjects (mutex_lock, sv_wait, psema...)
*	or  ksync_metered  - debug version of kernel synchronization objects 
*	or  ksync_named    - named kernel synchronization objects
*	or  ksync_statistics  - kernel synchronization objects - collects locking statistics
*		(You should use hardlocks_statistics if you use ksync_statistics)
*   mem      - /dev/mem, /dev/null, /dev/mmem, /dev/kmem
*   zero     - /dev/zero
*   ipc      - support for sem, shm, and msg
*   sem      - System V semaphores (see semop(2))
*   msg      - Interprocess messages (see msgop(2))
*   klog     - Kernel message logger (see klog(7))
*   usema    - User semaphores (see usema(7))
*   usync    - usync module
*   psema    - posix named semaphore module
*   sharena  - nanothreads
*
KERNEL: kernel
INCLUDE: numa, os, disp, mem, zero, sharena
#if defined(kdebug) && defined(DEBUG_SEMAMETER)
INCLUDE: ksync_metered
#else
INCLUDE: ksync
#endif
INCLUDE: kmem
USE: ipc, msg, sem
USE: psema, usync
USE: klog
USE: usema


*
* General I/O modules
*
*   io     - VME interrupt handler
*   gentty - Generic tty device (/dev/tty)
*   ptc    - Pseudo terminals
*   sduart - Serial port driver
*   cn     - Virtual console driver
*
INCLUDE: io, gentty, ptc, sduart, cn, stream

#if EVEREST
INCLUDE: cserialio
INCLUDE: ev_kbdms
#endif

#if IP27 || IP30 || IP33
*
* include standard serialio upper modules
*
#ifndef SABLE
INCLUDE: cserialio
USE: userialio
#endif
#endif

#if defined(IP32)
*
* Optional, lightweight serial I/O modules
*	cserialio - simple raw non-STREAMS char device access
*	tserialio - +/- 1ms accurate timestamped serialio
*
EXCLUDE: cserialio
INCLUDE: mace
#endif
USE: tserialio

#if IP27
INCLUDE: sio_i2c i2c elsc
#endif

#if IP27
*
*     Psitech RAD1 driver
*
USE: rad1pci
#endif


*
* Keyboard/mouse driver
*
#if defined(IP22) || defined(IP26) || defined(IP28)
INCLUDE: pckm
#elif defined(IP30) || defined(IP27) || defined (IP33)
#if !defined(SABLE)
INCLUDE: ioc3_pckm
#endif
#elif defined(IP32) || defined(IP32SIM)
INCLUDE: mhpckm
#endif	/* IP22 ... */

#if defined(VMEBUS) || defined(EISABUS)
*
* User mode device driver support
*
#if !defined(mr)
USE: usrbus
#endif
#endif

*
* Bus Registrations
*
#if defined(PCIBUS)
*
* PCI devices
*
#if defined(IP30) || defined(SN) && !defined (SABLE)
INCLUDE: ioc3
#if defined(SN0)
INCLUDE: ioc3ei
#endif
#endif

VECTOR: module=pciba

*
* PCI infrastructure
*
#if !defined(SN) && !defined(IP30) && !defined(IP32)
INCLUDE: pci
#endif
INCLUDE: pciio

#if defined(IP32)
INCLUDE: pcimh
USE: usrpci
#else
INCLUDE: usrpci
#endif	/* IP32 */
#endif	/* PCIBUS */

#if defined(NEWGIOBUS)
*
* GIO infrastructure
*
INCLUDE: gioio
#endif

*
* VMEbus service provider
*
#if SN
USE: xiovme vmeio universe usrvme ude
#else
USE: vmestubs
#endif /* SN */

#if defined(XTALKBUS)

*
* XTALK devices
*
#if !defined (SABLE)
INCLUDE: menet
INCLUDE: io6
INCLUDE: mio
INCLUDE: kitchen_sync
#endif /* SABLE */

#if defined(PCIBUS) && defined(XTALKBUS)
INCLUDE: pcibr
INCLUDE: pciiox
#endif

#if defined(NEWGIOBUS)
INCLUDE: giobr
#endif

VECTOR: module=xioba

#if defined(IP27) || defined(IP30)
*
* Tensor Processing Unit support.
*
EXCLUDE: tpu
EXCLUDE: tpuidbg
EXCLUDE: tpusim
#endif

*
* XTALK infrastructure
*

#if defined(IP30)
INCLUDE: heart
#endif

INCLUDE: xbmon
INCLUDE: xbow
INCLUDE: xswitch
INCLUDE: xtalk
#endif

#if SN0
*
* Hub special space interface driver: Specific to SN0 only. 
*
USE: hubspc
USE: sn0drv
USE: fru
*
* Partition and cross partition communication subsystems. 
* 
EXCLUDE: partition
EXCLUDE: xpc
EXCLUDE: cl
EXCLUDE: if_cl
#endif

*
* Number-in-a-can kernel interface
*
#if defined(IP27) || defined(IP30) || defined (IP33)
INCLUDE: nic
#endif

*
* Device specifications
* 
* The ROOTDEV specification can be customized with the format:
*   /dev/dsk/dks?d?s?
*
#if defined(mr) || (defined(SABLE) && !defined(IP30))
/*
 * In the miniroot, the real swap area starts at 57k blocks or
 * 63k block (depending on machine type) the root filesystem 
 * in the swap partition.  This number must
 * match the number in the size argument to the mkfs command
 * in .../buildtools/sa/Makefile (>= variable MRSIZE) and
 * irix/cmd/initpkg/bcheckrc-mr.sh (xfs_growfs statement)
 * irix/cmd/initpkg/brc-mr.sh (swaplo statement).
 *
 * Miniroot defaults:
 *	all	- If "root" is set, things work as for IP17, otherwise it
 *		  defaults to scsi drive 1.  But "root" is not in nvram so
 *		  it is less likely to be set.  If drive 1 is not a system
 *		  drive and root is not set, then "OSLoadPartition" is
 *		  checked as a potential root device.
 *
 */
#if defined(IP20) || defined(IP22) || defined(IP26)
SWAPDEV: /dev/swap 57000 0
#else
SWAPDEV: /dev/swap 63000 0
#endif /* defined(IP20) || defined(IP22) || defined(IP26) */

ROOTDEV: /dev/root
DUMPDEV: /dev/swap
#else
/*
 * The remaining definitions are for use by the following kernel types:
 * 	kdebug, ship, diskless
 */
ROOTDEV: /dev/root
/*
 * Diskless has a different default swap and dump device
 */
#if defined(diskless)
SWAPDEV: /swap/_swap 0 0
DUMPDEV: /swap/_swap
#else
SWAPDEV: /dev/swap 0 0
DUMPDEV: /dev/swap
#endif
#endif

#if defined(IP19) || defined(IP25)
#if defined(_MIPS3_ADDRSPACE)
#if defined(MAPPED_KERNEL)
#define	DBGLOADADDR	-T c000000000180000
#define	NRMLOADADDR	-T c000000000004000
#else /* !MAPPED_KERNEL */
#define	DBGLOADADDR	-T a800000000180000
#define	NRMLOADADDR	-T a800000000004000
#endif /* !MAPPED_KERNEL */
#else
#define	DBGLOADADDR	-T 80100000
#define	NRMLOADADDR	-T 80004000
#endif
#if defined(kdebug)
#define	LOADADDR	DBGLOADADDR
#else
#define	LOADADDR	NRMLOADADDR
#endif
#endif /* IP19 || IP25 */

#if defined(SN0) || defined(SN0S) 
#if defined(_COMPILER_VERSION) && (_COMPILER_VERSION>700)
#if defined(kdebug) || defined(mr)
#if defined(SN0XXL)
#define DBGLOADADDR   -rdata_shared -elspec "../master.d/sn0xxl_elspec.dbg"
#else
#define DBGLOADADDR	-rdata_shared -elspec "../master.d/sn0_elspec.dbg"
#endif
#define NRMLOADADDR	-rdata_shared -elspec "../master.d/sn0_elspec"
#else
#if defined(SN0XXL)
#define DBGLOADADDR   -rdata_shared -elspec "/var/sysgen/master.d/sn0xxl_elspec.dbg"
#else
#define DBGLOADADDR	-rdata_shared -elspec "/var/sysgen/master.d/sn0_elspec.dbg"
#endif
#define NRMLOADADDR	-rdata_shared -elspec "/var/sysgen/master.d/sn0_elspec"
#endif
#else	/* ragnarok */
#if defined(SN0XXL)
#define DBGLOADADDR   -T c000000000360000 -D c000000001c00000 -rdata_shared
#else
#define DBGLOADADDR	-T c000000000300000 -D c000000001c00000 -rdata_shared
#endif
#define NRMLOADADDR	-T c000000000019000 -D c000000001800000
#endif	/* ragnarok */

#if defined(kdebug)
#define LOADADDR        DBGLOADADDR
#else
#define LOADADDR        NRMLOADADDR
#endif

#endif /* SN0 */

#if defined(IP20)
# define DBGLOADADDR	-T 88062000
# if defined(kdebug)
#  define LOADADDR	DBGLOADADDR
# else
#  define LOADADDR	-T 88002000
# endif
#endif

#if defined(IP21)
#if defined(LARGE_CPU_COUNT_EVEREST)
#define	DBGLOADADDR	-T a800000000200000
#else
#define	DBGLOADADDR	-T a800000000100000
#endif
#define	NRMLOADADDR	-T a800000000006000
#if defined(kdebug)
#define	LOADADDR	DBGLOADADDR
#else
#define	LOADADDR	NRMLOADADDR
#endif
#endif

#if defined(IP22)
#if defined(_MIPS3_ADDRSPACE)
#define DBGLOADADDR	-T a800000008078000
#define NRMLOADADDR	-T a800000008002000
#else
#if REMOTEDEBUG
#define DBGLOADADDR	-T 88089000
#else
#define DBGLOADADDR	-T 88070000
#endif
#define NRMLOADADDR	-T 88002000
#endif
# if defined(kdebug)
#  define LOADADDR	DBGLOADADDR
# else
#  define LOADADDR	NRMLOADADDR
# endif
#endif

#if defined(IP26)
#if REMOTEDEBUG
#define DBGLOADADDR	-T a8000000080a0000
#else
#define DBGLOADADDR	-T a800000008070000
#endif
#define NRMLOADADDR	-T a800000008002000
# if defined(kdebug)
#  define LOADADDR	DBGLOADADDR
# else
#  define LOADADDR	NRMLOADADDR
# endif
#endif

#if defined(IP28)
#if REMOTEDEBUG
#define DBGLOADADDR	-T a80000002009c000
#else
#define DBGLOADADDR	-T a800000020080000
#endif
#define NRMLOADADDR	-T a800000020003000
# if defined(kdebug)
#  define LOADADDR	DBGLOADADDR
# else
#  define LOADADDR	NRMLOADADDR
# endif
#endif

#if defined(IP30)
#if REMOTEDEBUG
#define DBGLOADADDR	-T a80000002009c000
#else
#define DBGLOADADDR	-T a800000020080000
#endif	/* REMOTEDEBUG */
#define NRMLOADADDR	-T a800000020004000
# if defined(kdebug)
#  define LOADADDR	DBGLOADADDR
# else
#  define LOADADDR	NRMLOADADDR
# endif
#endif


#if defined(IP32)
#if defined(_MIPS3_ADDRSPACE)
#define DBGLOADADDR	-T a800000000078000
#define NRMLOADADDR	-T a800000000002000
#else
#define DBGLOADADDR	-T 80069000
#define NRMLOADADDR	-T 80002000
#endif
# if defined(kdebug)
#  if defined(MHSIM)
#   define LOADADDR	NRMLOADADDR
#  else
#   define LOADADDR	DBGLOADADDR
#  endif
# else
#  define LOADADDR	NRMLOADADDR
# endif
#endif

#if defined(IPMHSIM)
#if defined(_MIPS3_ADDRSPACE)
#define DBGLOADADDR	-T a800000000060000
#define NRMLOADADDR	-T a800000000002000
#else
#define DBGLOADADDR	-T 80054000
#define NRMLOADADDR	-T 80002000
#endif
# if defined(kdebug)
#	define LOADADDR	DBGLOADADDR
# else
#	define LOADADDR	NRMLOADADDR
# endif
#endif

#if defined(IP33)
/*
 * #define DBGLOADADDR	-T a800000000300000 -D a800000001c00000 -rdata_shared
 * #define NRMLOADADDR	-T a800000000019000 -D a800000001800000
 */
#define DBGLOADADDR	-T a800000000300000
#define NRMLOADADDR	-T a800000000019000

#if defined(kdebug)
#define LOADADDR        DBGLOADADDR
#else
#define LOADADDR        NRMLOADADDR
#endif

#endif /* SN0 */

/* miniroot option */
#if defined(mr) || defined(SABLE) || defined(IPMHSIM)
#define MINICCOPT	-DMINIROOT
#else
#define MINICCOPT
#endif

/* semaphore metering -- on by default except for sable kernels */
#if !defined(SABLE) && !defined(NOSEMAMETER)
#define XSEMAMETER	-DDEFAULTSEMAMETER=1
#else
#define XSEMAMETER	-DDEFAULTSEMAMETER=0
#endif

/* Debugging options */
#define DEBCCOPT	XSEMAMETER

* Kernel debugging tools (see profiler(1M) and idbg(1M))
*
#if defined(kdebug)
USE: idbg, disp_idbg, mloadidbg, bsdidbg, stridbg, asidbg, procidbg, vmidbg
USE: xfsidbg, xlvidbg
USE: pgrpidbg, sessionidbg
USE: spec_idbg
#if !defined(PERF_BUILD)
USE: grioidbg
#endif
USE: nfsidbg
#ifndef SABLE
USE: dmiidbg, umfsidbg
#endif
#if SN0
USE: klidbg, numa_idbg
INCLUDE: vme_idbg
#endif
#if CELL
USE: dp_idbg, cfsidbg, cxfsidbg
#endif
mrUSE: graphidbg, cachefsidbg
#if SN || IP30 || IP32
USE: qlidbg
USE: fcidbg
USE: qlfc_idbg
#endif
#if IP32
USE: adpidbg
#endif
#else
* for most users, only the first line below needs to be changed
* from EXCLUDE to INCLUDE when configuring the kernel debugger.
EXCLUDE: idbg, disp_idbg, mloadidbg, bsdidbg, stridbg, graphidbg, asidbg, procidbg, vmidbg, xfsidbg 
EXCLUDE: xlvidbg
EXCLUDE: pgrpidbg, sessionidbg
#if SN0
EXCLUDE: numa_idbg
EXCLUDE: klidbg
EXCLUDE: vme_idbg
#endif
EXCLUDE: dmiidbg, umfsidbg, grioidbg, spec_idbg
EXCLUDE: dp_idbg, cachefsidbg
EXCLUDE: nfsidbg
#if SN || IP30 || IP32
EXCLUDE: qlidbg
EXCLUDE: fcidbg
EXCLUDE: qlfc_idbg
#endif
#if IP32
EXCLUDE: adpidbg
#endif
#endif
mrUSE: prf

*
* Compilation and load flags
#if !defined(kdebug)
*	To load a kernel that can be co-resident with symmon
*	(for breakpoint debugging) replace LDOPTS
*	with the following.  You must also install eoe.sw.kdebug
*	and eoe.sw.perf, and change (at least) the first idbg line
*	above from EXCLUDE to INCLUDE
*
*LDOPTS: DLDOPTS DBGLOADADDR LSTRIP
*
#endif
LDOPTS: DLDOPTS LOADADDR LSTRIP -wall

CCOPTS: DCCOPTS MINICCOPT DEBCCOPT CPUINSTDIRINC
*
#if defined(ship)
#define TOLROT /var/sysgen/root
CC: TOOLROOT=TOLROT /var/sysgen/root/usr/bin/cc
LD: TOOLROOT=TOLROT /var/sysgen/root/usr/bin/ld
#endif
#if defined(diskless)
#define TOLROT $DL_ROOT/var/sysgen/root
CC: TOOLROOT=TOLROT $DL_ROOT/var/sysgen/root/usr/bin/cc
LD: TOOLROOT=TOLROT $DL_ROOT/var/sysgen/root/usr/bin/ld
#endif

#if COMPILATION_MODEL == N32
TUNE-TAG:32
#else
TUNE-TAG:COMPILATION_MODEL
#endif

#if defined(mr)
TUNE-TAG:MINIROOT
#else
TUNE-TAG:NOT_MINIROOT
#endif

#if defined(IP27) || defined(IP25) || defined(IP19) || defined(IP30) || defined(IP32) || defined (IP33)
TUNE-TAG:NEED_LPAGES
#else
TUNE-TAG:NOT_NEED_LPAGES
#endif
