/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
 * the full copyright text.
 */
/*
 * HISTORY
 * $Log: tkn4int_cstub.c,v $
 * Revision 65.2  1999/02/04 19:19:40  mek
 * Provide C style stub for IRIX kernel integration.
 *
 * Revision 65.1  1997/10/20 19:20:28  jdoak
 * *** empty log message ***
 *
 * Revision 1.1.11.1  1996/10/02  17:47:10  damon
 * 	Newest DFS from Transarc
 * 	[1996/10/01  18:37:38  damon]
 *
 * Revision 1.1.6.1  1994/06/09  14:08:03  annie
 * 	fixed copyright in src/file
 * 	[1994/06/09  13:22:58  annie]
 * 
 * Revision 1.1.4.3  1993/01/21  19:36:18  zeliff
 * 	Embedding copyright notices
 * 	[1993/01/19  19:50:01  zeliff]
 * 
 * Revision 1.1.4.2  1992/09/25  18:14:03  jaffe
 * 	Transarc delta: kazar-ot4474-sys-v-locking-async-grant 1.2
 * 	  Selected comments:
 * 	    start work on async grant
 * 	    finish work on async grant
 * 	    idl changes for async grant
 * 	[1992/09/23  19:10:52  jaffe]
 * 
 * Revision 1.1.2.2  1992/05/20  19:53:03  mason
 * 	Transarc delta: cfe-ot2605-tsr-i-f-changes 1.5
 * 	  Files modified:
 * 	    cm: cm_scache.h
 * 	    config: common_data.acf, common_data.idl, common_def.h
 * 	    fshost: fshs_errs.et
 * 	    fsint: afs4int.acf, afs4int.idl, tkn4int.acf, tkn4int.idl
 * 	    host: hs_errs.et; px: px_repops.c; rep: rep_main.c, repser.h
 * 	    userInt/fts: volc_tokens.c; xvolume: volume.h
 * 	  Selected comments:
 * 	    This delta should encompass the interface changes associated with token
 * 	    state recovery (over server crashes, network partitions, fileset moves,
 * 	    and other things).
 * 	    This delta now captures the interface changes for real.  It includes RPC interface
 * 	    changes, new error codes, and new status bits.  It also includes incomplete changes
 * 	    to fts to support the new interface.
 * 	    Annotate the new RPC procedure.
 * 	    More TSR interface fallout, mostly to the new model.
 * 	    Fix a merge error.
 * 	    Fixing more merge and syntax errors
 * 	[1992/05/20  11:31:45  mason]
 * 
 * Revision 1.1  1992/01/19  02:51:19  devrcs
 * 	Initial revision
 * 
 * $EndLog$
 */

/* Generated by IDL compiler version OSF DCE T1.2.0-09 */
#ifdef VMS
#pragma nostandard
#endif
#include <dce/idlddefs.h>
#include <tkn4int.h>

static rpc_syntax_id_t IDL_transfer_syntaxes[1] = {
{
{0x8a885d04u, 0x1ceb, 0x11c9, 0x9f, 0xe8, {0x8, 0x0, 0x2b, 0x10, 0x48, 0x60}},
2}};

static rpc_if_rep_t IDL_ifspec = {
  1, /* ifspec rep version */
  9, /* op count */
  4, /* if version */
  {0x4d37f2ddu, 0xed96, 0x0000, 0x02, 0xc0, {0x37, 0xcf, 0x1e, 0x0, 0x0, 0x0}},
  2, /* stub/rt if version */
  {0, NULL}, /* endpoint vector */
  {1, IDL_transfer_syntaxes} /* syntax vector */
};
/* global */ rpc_if_handle_t TKN4Int_v4_0_c_ifspec = (rpc_if_handle_t)&IDL_ifspec;
static idl_ulong_int IDL_offset_vec[] = {
0,
sizeof(afsFid ),
offsetof(afsFid , Cell),
offsetof(afsFid , Volume),
offsetof(afsFid , Vnode),
offsetof(afsFid , Unique),
sizeof(afsConnParams ),
offsetof(afsConnParams , Mask),
offsetof(afsConnParams , Values),
sizeof(dfs_interfaceList ),
offsetof(dfs_interfaceList , dfs_interfaceList_len),
offsetof(dfs_interfaceList , dfs_interfaceList_val),
sizeof(dfs_interfaceDescription ),
offsetof(dfs_interfaceDescription , interface_uuid.time_low),
offsetof(dfs_interfaceDescription , interface_uuid.time_mid),
offsetof(dfs_interfaceDescription , interface_uuid.time_hi_and_version),
offsetof(dfs_interfaceDescription , interface_uuid.clock_seq_hi_and_reserved),
offsetof(dfs_interfaceDescription , interface_uuid.clock_seq_low),
offsetof(dfs_interfaceDescription , interface_uuid.node),
offsetof(dfs_interfaceDescription , vers_major),
offsetof(dfs_interfaceDescription , vers_minor),
offsetof(dfs_interfaceDescription , vers_provider),
offsetof(dfs_interfaceDescription , spare0),
offsetof(dfs_interfaceDescription , spare1),
offsetof(dfs_interfaceDescription , spare2),
offsetof(dfs_interfaceDescription , spare3),
offsetof(dfs_interfaceDescription , spare4),
offsetof(dfs_interfaceDescription , spare5),
offsetof(dfs_interfaceDescription , spare6),
offsetof(dfs_interfaceDescription , spare7),
offsetof(dfs_interfaceDescription , spare8),
offsetof(dfs_interfaceDescription , spare9),
offsetof(dfs_interfaceDescription , spareText),
sizeof(afsDBCacheEntry ),
offsetof(afsDBCacheEntry , addr),
offsetof(afsDBCacheEntry , fid.Cell),
offsetof(afsDBCacheEntry , fid.Volume),
offsetof(afsDBCacheEntry , fid.Vnode),
offsetof(afsDBCacheEntry , fid.Unique),
offsetof(afsDBCacheEntry , length),
offsetof(afsDBCacheEntry , dataVersion),
offsetof(afsDBCacheEntry , lock.waitStates),
offsetof(afsDBCacheEntry , lock.exclLocked),
offsetof(afsDBCacheEntry , lock.readersReading),
offsetof(afsDBCacheEntry , lock.numWaiting),
offsetof(afsDBCacheEntry , tokenBaseID),
offsetof(afsDBCacheEntry , tokenMask),
offsetof(afsDBCacheEntry , tokenExpiration),
offsetof(afsDBCacheEntry , refCount),
offsetof(afsDBCacheEntry , opens),
offsetof(afsDBCacheEntry , writers),
offsetof(afsDBCacheEntry , readers),
offsetof(afsDBCacheEntry , shareds),
offsetof(afsDBCacheEntry , exclusives),
offsetof(afsDBCacheEntry , mvstat),
offsetof(afsDBCacheEntry , states),
sizeof(afsDBLock ),
offsetof(afsDBLock , name),
offsetof(afsDBLock , lock.waitStates),
offsetof(afsDBLock , lock.exclLocked),
offsetof(afsDBLock , lock.readersReading),
offsetof(afsDBLock , lock.numWaiting),
sizeof(afsRevokes ),
offsetof(afsRevokes , afsRevokes_len),
offsetof(afsRevokes , afsRevokes_val),
sizeof(afsRevokeDesc ),
offsetof(afsRevokeDesc , fid.Cell),
offsetof(afsRevokeDesc , fid.Volume),
offsetof(afsRevokeDesc , fid.Vnode),
offsetof(afsRevokeDesc , fid.Unique),
offsetof(afsRevokeDesc , tokenID),
offsetof(afsRevokeDesc , type),
offsetof(afsRevokeDesc , flags),
offsetof(afsRevokeDesc , outFlags),
offsetof(afsRevokeDesc , errorIDs),
offsetof(afsRevokeDesc , columnA),
offsetof(afsRevokeDesc , colAChoice),
offsetof(afsRevokeDesc , columnB),
offsetof(afsRevokeDesc , colBChoice),
offsetof(afsRevokeDesc , recordLock),
(idl_ulong_int)sizeof(afs_recordLock_t),
sizeof(afsRecordLock ),
offsetof(afsRecordLock , l_type),
offsetof(afsRecordLock , l_whence),
offsetof(afsRecordLock , l_start_pos),
offsetof(afsRecordLock , l_end_pos),
offsetof(afsRecordLock , l_pid),
offsetof(afsRecordLock , l_sysid),
offsetof(afsRecordLock , l_fstype),
offsetof(afsRecordLock , l_start_pos_ext),
offsetof(afsRecordLock , l_end_pos_ext),
(idl_ulong_int)sizeof(afs_token_t),
sizeof(afsToken ),
offsetof(afsToken , tokenID),
offsetof(afsToken , expirationTime),
offsetof(afsToken , type),
offsetof(afsToken , beginRange),
offsetof(afsToken , endRange),
offsetof(afsToken , beginRangeExt),
offsetof(afsToken , endRangeExt),
(idl_ulong_int)sizeof(afs_hyper_t),
sizeof(afsHyper ),
offsetof(afsHyper , high),
offsetof(afsHyper , low),
0
};

static IDL_rtn_func_t IDL_rtn_vec[] = {
(IDL_rtn_func_t)NULL,
(IDL_rtn_func_t)afsRecordLock_from_local,
(IDL_rtn_func_t)afsRecordLock_to_local,
(IDL_rtn_func_t)afsRecordLock_free_local,
(IDL_rtn_func_t)afsRecordLock_free_inst,
(IDL_rtn_func_t)afsToken_from_local,
(IDL_rtn_func_t)afsToken_to_local,
(IDL_rtn_func_t)afsToken_free_local,
(IDL_rtn_func_t)afsToken_free_inst,
(IDL_rtn_func_t)afsHyper_from_local,
(IDL_rtn_func_t)afsHyper_to_local,
(IDL_rtn_func_t)afsHyper_free_local,
(IDL_rtn_func_t)afsHyper_free_inst,
(IDL_rtn_func_t)NULL
};

static idl_byte IDL_type_vec[] = {
0xff,0xff,0xff,0xff,
0,
0,
0xff,0xff,
0x00,0x03,
0x00,0x02,
0x00,0x04,
0x00,0x00,
0x4d,0x37,0xf2,0xdd,
0xed,0x96,
0x00,0x00,
0x02,
0xc0,
0x37,0xcf,0x1e,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x04,
0x00,0x00,0x04,0xbc,
0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,
0x00,0x00,0x00,0x09,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x02,
0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,
0x00,0x00,0x00,0x01,
0x00,0x00,0x01,0x18,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0d,
0x00,0x00,0x00,0x08,
0x00,0x00,0x01,0x20,
0x00,0x00,0x00,0x04,
0x00,0x00,0x01,0x60,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x03,
0x00,0x00,0x00,0x01,
0x00,0x00,0x01,0x80,
0x00,0x00,0x00,0x02,
0x00,0x00,0x01,0x80,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x04,
0x00,0x00,0x00,0x01,
0x00,0x00,0x01,0x98,
0x00,0x00,0x00,0x03,
0x00,0x00,0x01,0xa8,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x04,
0x00,0x00,0x00,0x01,
0x00,0x00,0x01,0xd4,
0x00,0x00,0x00,0x02,
0x00,0x00,0x01,0xdc,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x04,
0x00,0x00,0x00,0x01,
0x00,0x00,0x01,0xf4,
0x00,0x00,0x00,0x02,
0x00,0x00,0x01,0xfc,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x03,
0x00,0x00,0x00,0x01,
0x00,0x00,0x02,0x14,
0x00,0x00,0x00,0x02,
0x00,0x00,0x02,0x14,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x04,
0x00,0x00,0x00,0x02,
0x00,0x00,0x02,0x2c,
0x00,0x00,0x00,0x02,
0x00,0x00,0x02,0x34,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x05,
0x00,0x00,0x00,0x03,
0x00,0x00,0x02,0x4c,
0x00,0x00,0x00,0x02,
0x00,0x00,0x02,0x74,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x09,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x0a,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x0c,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x02,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x04,0xa4,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_STRING,
IDL_DT_VARYING_ARRAY,
0,
0x00,0x00,0x02,0x9f,
0x00,0x00,0x02,0x9f,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,
0x00,0x00,0x02,0xbc,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x02,0xd4,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x03,0x14,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,
0x00,0x00,0x03,0x28,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x03,0x3c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x04,0x78,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_LONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x3e,
IDL_DT_NDR_ALIGN_4,
IDL_DT_LONG,
IDL_DT_VARYING_ARRAY,
0|IDL_PROP_DEP_INT,
0x00,0x00,0x03,0xd7,
0x00,0x00,0x03,0xd7,
IDL_DT_EOL,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xff,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_STRING,
1,
0xff,0xff,
0x00,0x00,0x00,0xff,
IDL_DT_BYTE,
0xff,0xff,0xff,
0x00,0x00,0x00,0x38,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x03,0xcb,
0x00,0x00,0x03,0xcb,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_USMALL,
IDL_DT_USMALL,
IDL_DT_USMALL,
IDL_DT_USMALL,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x21,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x04,0xa4,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x04,0xa4,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,0xff,
0x00,0x00,0x04,0xa4,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x04,0xa4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_USMALL,
IDL_DT_USMALL,
IDL_DT_USMALL,
IDL_DT_USMALL,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_SHORT,
IDL_DT_SHORT,
IDL_DT_SHORT,
IDL_DT_SHORT,
IDL_DT_SHORT,
IDL_DT_SHORT,
IDL_DT_USMALL,
IDL_DT_USMALL,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x09,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_VARYING_ARRAY,
0|IDL_PROP_DEP_INT,
0x00,0x00,0x03,0x5f,
0x00,0x00,0x03,0x5f,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0|IDL_PROP_DEP_INT,
0x00,0x00,0x03,0x53,
0x00,0x00,0x03,0x53,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x01,
IDL_DT_NDR_ALIGN_4,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x04,0xa4,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x04,0xa4,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_EOL,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x13,
IDL_DT_ULONG,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x09,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_LENGTH_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x01,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,0xff,
0x00,0x00,0x03,0x80,
0x00,0x00,0x00,0x0c,
IDL_DT_NDR_ALIGN_4,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_USHORT,
IDL_DT_USHORT,
IDL_DT_USMALL,
IDL_DT_USMALL,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x03,0xbf,
0x00,0x00,0x03,0xbf,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_USHORT,
IDL_DT_USHORT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0,
0x00,0x00,0x03,0xb3,
0x00,0x00,0x03,0xb3,
IDL_DT_EOL,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x31,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x05,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_LENGTH_IS,
IDL_DT_LONG,
0xff,0xff,
0x00,0x00,0x00,0x01,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x03,0xf8,
0x00,0x00,0x00,0x41,
IDL_DT_NDR_ALIGN_4,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,0xff,
0x00,0x00,0x04,0xa4,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x04,0xa4,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,0xff,
0x00,0x00,0x04,0xa4,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x04,0xa4,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0x00,0x00,0x04,0xa4,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x04,0x78,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x04,0xa4,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x04,0x78,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x04,0xa4,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x04,0x58,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x50,
0x00,0x00,0x00,0x01,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x04,0x68,
0x00,0x00,0x00,0x51,
IDL_DT_NDR_ALIGN_4,
IDL_DT_SHORT,
IDL_DT_SHORT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x5b,
0x00,0x00,0x00,0x05,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x04,0x88,
0x00,0x00,0x00,0x5c,
IDL_DT_NDR_ALIGN_4,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x04,0xa4,
IDL_DT_ULONG,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x04,0xa4,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x64,
0x00,0x00,0x00,0x09,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x04,0xb4,
0x00,0x00,0x00,0x65,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_EOL,
0x00,0x00,0x00,0x10,
0
};


error_status_t TKN_Probe
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h
)
#else
(h)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[2];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,0,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    0,
    0,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    1,
    280,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t TKN_InitTokenState
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ unsigned32 Flags,
    /* [in] */ unsigned32 hostLifeGuarantee,
    /* [in] */ unsigned32 hostRPCGuarantee,
    /* [in] */ unsigned32 deadServerTimeout,
    /* [in] */ unsigned32 serverRestartEpoch,
    /* [in] */ unsigned32 serverSizesAttrs,
    /* [in] */ unsigned32 spare2,
    /* [in] */ unsigned32 spare3,
    /* [out] */ unsigned32 *spare4,
    /* [out] */ unsigned32 *spare5,
    /* [out] */ unsigned32 *spare6
)
#else
(h, Flags, hostLifeGuarantee, hostRPCGuarantee, deadServerTimeout, serverRestartEpoch, serverSizesAttrs, spare2, spare3, spare4, spare5, spare6)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    unsigned32 Flags;
    unsigned32 hostLifeGuarantee;
    unsigned32 hostRPCGuarantee;
    unsigned32 deadServerTimeout;
    unsigned32 serverRestartEpoch;
    unsigned32 serverSizesAttrs;
    unsigned32 spare2;
    unsigned32 spare3;
    unsigned32 *spare4;
    unsigned32 *spare5;
    unsigned32 *spare6;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[13];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)&Flags;
IDL_param_vec[3] = (rpc_void_p_t)&hostLifeGuarantee;
IDL_param_vec[4] = (rpc_void_p_t)&hostRPCGuarantee;
IDL_param_vec[5] = (rpc_void_p_t)&deadServerTimeout;
IDL_param_vec[6] = (rpc_void_p_t)&serverRestartEpoch;
IDL_param_vec[7] = (rpc_void_p_t)&serverSizesAttrs;
IDL_param_vec[8] = (rpc_void_p_t)&spare2;
IDL_param_vec[9] = (rpc_void_p_t)&spare3;
IDL_param_vec[10] = (rpc_void_p_t)spare4;
IDL_param_vec[11] = (rpc_void_p_t)spare5;
IDL_param_vec[12] = (rpc_void_p_t)spare6;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,1,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    8,
    288,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    4,
    352,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t TKN_TokenRevoke
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in, out] */ afsRevokes *revokeDescp
)
#else
(h, revokeDescp)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsRevokes *revokeDescp;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[3];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)revokeDescp;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,2,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    1,
    384,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    2,
    384,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t TKN_GetCellName
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *Cellp,
    /* [out] */ NameString_t CellNamep
)
#else
(h, Cellp, CellNamep)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    /* Type must appear in user header or IDL */ afs_hyper_t *Cellp;
    NameString_t CellNamep;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[4];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)Cellp;
IDL_param_vec[3] = (rpc_void_p_t)CellNamep;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,3,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    1,
    408,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    3,
    424,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t TKN_GetLock
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ unsigned32 index,
    /* [out] */ afsDBLock *lock
)
#else
(h, index, lock)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    unsigned32 index;
    afsDBLock *lock;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[4];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)&index;
IDL_param_vec[3] = (rpc_void_p_t)lock;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,4,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    1,
    468,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    2,
    476,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t TKN_GetCE
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ unsigned32 index,
    /* [out] */ afsDBCacheEntry *ce
)
#else
(h, index, ce)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    unsigned32 index;
    afsDBCacheEntry *ce;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[4];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)&index;
IDL_param_vec[3] = (rpc_void_p_t)ce;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,5,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    1,
    500,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    2,
    508,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t TKN_GetServerInterfaces
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in, out] */ dfs_interfaceList *serverInterfacesP
)
#else
(h, serverInterfacesP)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    dfs_interfaceList *serverInterfacesP;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[3];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)serverInterfacesP;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,6,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    1,
    532,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    2,
    532,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t TKN_SetParams
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ unsigned32 Flags,
    /* [in, out] */ afsConnParams *paramsP
)
#else
(h, Flags, paramsP)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    unsigned32 Flags;
    afsConnParams *paramsP;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[4];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)&Flags;
IDL_param_vec[3] = (rpc_void_p_t)paramsP;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,7,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    2,
    556,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    2,
    564,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t TKN_AsyncGrant
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsFid *grantedFileIDp,
    /* [in] */ /* Type must appear in user header or IDL */ afs_token_t *grantedTokenP,
    /* [in] */ idl_long_int grantedRequestID
)
#else
(h, grantedFileIDp, grantedTokenP, grantedRequestID)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsFid *grantedFileIDp;
    /* Type must appear in user header or IDL */ afs_token_t *grantedTokenP;
    idl_long_int grantedRequestID;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[5];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)grantedFileIDp;
IDL_param_vec[3] = (rpc_void_p_t)grantedTokenP;
IDL_param_vec[4] = (rpc_void_p_t)&grantedRequestID;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,8,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    3,
    588,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    2,
    628,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}
#ifdef VMS
#pragma standard
#endif
