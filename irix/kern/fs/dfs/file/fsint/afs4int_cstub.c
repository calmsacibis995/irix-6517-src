/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
 * the full copyright text.
 */
/*
 * HISTORY
 * $Log: afs4int_cstub.c,v $
 * Revision 65.2  1999/02/04 19:19:39  mek
 * Provide C style stub for IRIX kernel integration.
 *
 * Revision 65.1  1997/10/20 19:20:27  jdoak
 * *** empty log message ***
 *
 * Revision 1.1.65.1  1996/10/02  17:46:58  damon
 * 	Newest DFS from Transarc
 * 	[1996/10/01  18:37:26  damon]
 *
 * Revision 1.1.60.2  1994/06/09  14:07:49  annie
 * 	fixed copyright in src/file
 * 	[1994/06/09  13:22:47  annie]
 * 
 * Revision 1.1.60.1  1994/02/04  20:18:42  devsrc
 * 	Merged from 1.0.3a to 1.1
 * 	[1994/02/04  15:13:03  devsrc]
 * 
 * Revision 1.1.58.1  1993/12/07  17:24:15  jaffe
 * 	1.0.3a update from Transarc
 * 	[1993/12/03  15:22:34  jaffe]
 * 
 * Revision 1.1.4.4  1993/01/21  19:35:45  zeliff
 * 	Embedding copyright notices
 * 	[1993/01/19  19:49:25  zeliff]
 * 
 * Revision 1.1.4.3  1993/01/13  17:49:13  shl
 * 	Transarc delta: cfe-ot6054-genl-and-i18n-spares 1.1
 * 	  Selected comments:
 * 	    Add spares to several RPC structures, with two goals:
 * 	    - general future usage
 * 	    - allow for at least some internationalization designs
 * 	    The only tricky part of this work is that the on-the-wire representation for
 * 	    directory contents is expanded.
 * 	Transarc delta: tu-ot5968-remove-obsolete-api 1.1
 * 	  Selected comments:
 * 	    Remove the obsolete rpc call, AFS_RenewAllToken and others.
 * 	[1993/01/12  20:57:44  shl]
 * 
 * Revision 1.1.4.2  1992/11/24  17:03:35  bolinger
 * 	Change include file install directory from .../afs to .../dcedfs.
 * 	[1992/11/22  17:59:07  bolinger]
 * 
 * Revision 1.1.2.2  1992/05/20  19:52:41  mason
 * 	Transarc delta: cfe-ot2605-tsr-i-f-changes 1.5
 * 	  Files modified:
 * 	    cm: cm_scache.h
 * 	    config: common_data.acf, common_data.idl, common_def.h
 * 	    fshost: fshs_errs.et
 * 	    fsint: afs4int.acf, afs4int.idl, tkn4int.acf, tkn4int.idl
 * 	    host: hs_errs.et; px: px_repops.c; rep: rep_main.c, repser.h
 * 	    userInt/fts: volc_tokens.c; xvolume: volume.h
 * 	  Selected comments:
 * 	    This delta should encompass the interface changes associated with token
 * 	    state recovery (over server crashes, network partitions, fileset moves,
 * 	    and other things).
 * 	    This delta now captures the interface changes for real.  It includes RPC interface
 * 	    changes, new error codes, and new status bits.  It also includes incomplete changes
 * 	    to fts to support the new interface.
 * 	    Annotate the new RPC procedure.
 * 	    More TSR interface fallout, mostly to the new model.
 * 	    Fix a merge error.
 * 	    Fixing more merge and syntax errors
 * 	[1992/05/20  11:31:04  mason]
 * 
 * Revision 1.1  1992/01/19  02:51:15  devrcs
 * 	Initial revision
 * 
 * $EndLog$
 */

/* Generated by IDL compiler version OSF DCE T1.2.0-09 */
#ifdef VMS
#pragma nostandard
#endif
#include <dce/idlddefs.h>
#include <afs4int.h>

static rpc_syntax_id_t IDL_transfer_syntaxes[1] = {
{
{0x8a885d04u, 0x1ceb, 0x11c9, 0x9f, 0xe8, {0x8, 0x0, 0x2b, 0x10, 0x48, 0x60}},
2}};

static rpc_if_rep_t IDL_ifspec = {
  1, /* ifspec rep version */
  28, /* op count */
  4, /* if version */
  {0x4d37f2ddu, 0xed93, 0x0000, 0x02, 0xc0, {0x37, 0xcf, 0x1e, 0x0, 0x0, 0x0}},
  2, /* stub/rt if version */
  {0, NULL}, /* endpoint vector */
  {1, IDL_transfer_syntaxes} /* syntax vector */
};
/* global */ rpc_if_handle_t AFS4Int_v4_0_c_ifspec = (rpc_if_handle_t)&IDL_ifspec;
static idl_ulong_int IDL_offset_vec[] = {
0,
sizeof(BulkStat ),
offsetof(BulkStat , BulkStat_len),
offsetof(BulkStat , BulkStat_val),
sizeof(bundled_stat ),
offsetof(bundled_stat , fid.Cell),
offsetof(bundled_stat , fid.Volume),
offsetof(bundled_stat , fid.Vnode),
offsetof(bundled_stat , fid.Unique),
offsetof(bundled_stat , stat.interfaceVersion),
offsetof(bundled_stat , stat.fileType),
offsetof(bundled_stat , stat.linkCount),
offsetof(bundled_stat , stat.length),
offsetof(bundled_stat , stat.dataVersion),
offsetof(bundled_stat , stat.author),
offsetof(bundled_stat , stat.owner),
offsetof(bundled_stat , stat.group),
offsetof(bundled_stat , stat.callerAccess),
offsetof(bundled_stat , stat.anonymousAccess),
offsetof(bundled_stat , stat.aclExpirationTime),
offsetof(bundled_stat , stat.mode),
offsetof(bundled_stat , stat.parentVnode),
offsetof(bundled_stat , stat.parentUnique),
offsetof(bundled_stat , stat.modTime.sec),
offsetof(bundled_stat , stat.modTime.usec),
offsetof(bundled_stat , stat.changeTime.sec),
offsetof(bundled_stat , stat.changeTime.usec),
offsetof(bundled_stat , stat.accessTime.sec),
offsetof(bundled_stat , stat.accessTime.usec),
offsetof(bundled_stat , stat.serverModTime.sec),
offsetof(bundled_stat , stat.serverModTime.usec),
offsetof(bundled_stat , stat.typeUUID.time_low),
offsetof(bundled_stat , stat.typeUUID.time_mid),
offsetof(bundled_stat , stat.typeUUID.time_hi_and_version),
offsetof(bundled_stat , stat.typeUUID.clock_seq_hi_and_reserved),
offsetof(bundled_stat , stat.typeUUID.clock_seq_low),
offsetof(bundled_stat , stat.typeUUID.node),
offsetof(bundled_stat , stat.objectUUID.time_low),
offsetof(bundled_stat , stat.objectUUID.time_mid),
offsetof(bundled_stat , stat.objectUUID.time_hi_and_version),
offsetof(bundled_stat , stat.objectUUID.clock_seq_hi_and_reserved),
offsetof(bundled_stat , stat.objectUUID.clock_seq_low),
offsetof(bundled_stat , stat.objectUUID.node),
offsetof(bundled_stat , stat.deviceNumber),
offsetof(bundled_stat , stat.blocksUsed),
offsetof(bundled_stat , stat.clientSpare1),
offsetof(bundled_stat , stat.deviceNumberHighBits),
offsetof(bundled_stat , stat.spare0),
offsetof(bundled_stat , stat.spare1),
offsetof(bundled_stat , stat.spare2),
offsetof(bundled_stat , stat.spare3),
offsetof(bundled_stat , stat.spare4),
offsetof(bundled_stat , stat.spare5),
offsetof(bundled_stat , stat.spare6),
offsetof(bundled_stat , token),
offsetof(bundled_stat , error),
sizeof(afsConnParams ),
offsetof(afsConnParams , Mask),
offsetof(afsConnParams , Values),
sizeof(dfs_interfaceList ),
offsetof(dfs_interfaceList , dfs_interfaceList_len),
offsetof(dfs_interfaceList , dfs_interfaceList_val),
sizeof(dfs_interfaceDescription ),
offsetof(dfs_interfaceDescription , interface_uuid.time_low),
offsetof(dfs_interfaceDescription , interface_uuid.time_mid),
offsetof(dfs_interfaceDescription , interface_uuid.time_hi_and_version),
offsetof(dfs_interfaceDescription , interface_uuid.clock_seq_hi_and_reserved),
offsetof(dfs_interfaceDescription , interface_uuid.clock_seq_low),
offsetof(dfs_interfaceDescription , interface_uuid.node),
offsetof(dfs_interfaceDescription , vers_major),
offsetof(dfs_interfaceDescription , vers_minor),
offsetof(dfs_interfaceDescription , vers_provider),
offsetof(dfs_interfaceDescription , spare0),
offsetof(dfs_interfaceDescription , spare1),
offsetof(dfs_interfaceDescription , spare2),
offsetof(dfs_interfaceDescription , spare3),
offsetof(dfs_interfaceDescription , spare4),
offsetof(dfs_interfaceDescription , spare5),
offsetof(dfs_interfaceDescription , spare6),
offsetof(dfs_interfaceDescription , spare7),
offsetof(dfs_interfaceDescription , spare8),
offsetof(dfs_interfaceDescription , spare9),
offsetof(dfs_interfaceDescription , spareText),
sizeof(afsQuota ),
offsetof(afsQuota , afsQuotaType),
offsetof(afsQuota , afsQuotaOp),
offsetof(afsQuota , afsQuota_len),
offsetof(afsQuota , afsQuota_val),
sizeof(afsBulkFEX ),
offsetof(afsBulkFEX , afsBulkFEX_len),
offsetof(afsBulkFEX , afsBulkFEX_val),
sizeof(afsFidExp ),
offsetof(afsFidExp , fid.Cell),
offsetof(afsFidExp , fid.Volume),
offsetof(afsFidExp , fid.Vnode),
offsetof(afsFidExp , fid.Unique),
offsetof(afsFidExp , keepAliveTime),
sizeof(afsBulkVVs ),
offsetof(afsBulkVVs , afsBulkVVs_len),
offsetof(afsBulkVVs , afsBulkVVs_val),
sizeof(afsBulkVolIDs ),
offsetof(afsBulkVolIDs , afsBulkVolIDs_len),
offsetof(afsBulkVolIDs , afsBulkVolIDs_val),
sizeof(afsStatistics ),
offsetof(afsStatistics , CurrentMsgNumber),
offsetof(afsStatistics , OldestMsgNumber),
offsetof(afsStatistics , CurrentTime),
offsetof(afsStatistics , BootTime),
offsetof(afsStatistics , StartTime),
offsetof(afsStatistics , CurrentConnections),
offsetof(afsStatistics , TotalAfsCalls),
offsetof(afsStatistics , TotalFetchs),
offsetof(afsStatistics , FetchDatas),
offsetof(afsStatistics , FetchedBytes),
offsetof(afsStatistics , HighFetchedBytes),
offsetof(afsStatistics , FetchDataRate),
offsetof(afsStatistics , TotalStores),
offsetof(afsStatistics , StoreDatas),
offsetof(afsStatistics , StoredBytes),
offsetof(afsStatistics , HighStoredBytes),
offsetof(afsStatistics , StoreDataRate),
offsetof(afsStatistics , TotalRPCBytesSent),
offsetof(afsStatistics , HighTotalRPCBytesSent),
offsetof(afsStatistics , TotalRPCBytesReceived),
offsetof(afsStatistics , HighTotalRPCBytesReceived),
offsetof(afsStatistics , TotalRPCPacketsSent),
offsetof(afsStatistics , TotalRPCPacketsReceived),
offsetof(afsStatistics , TotalRPCPacketsLost),
offsetof(afsStatistics , TotalRPCBogusPackets),
offsetof(afsStatistics , SystemCPU),
offsetof(afsStatistics , UserCPU),
offsetof(afsStatistics , NiceCPU),
offsetof(afsStatistics , IdleCPU),
offsetof(afsStatistics , TotalIO),
offsetof(afsStatistics , ActiveVM),
offsetof(afsStatistics , TotalVM),
offsetof(afsStatistics , EtherNetTotalErrors),
offsetof(afsStatistics , EtherNetTotalWrites),
offsetof(afsStatistics , EtherNetTotalInterupts),
offsetof(afsStatistics , EtherNetGoodReads),
offsetof(afsStatistics , EtherNetTotalBytesWritten),
offsetof(afsStatistics , EtherNetTotalBytesRead),
offsetof(afsStatistics , ProcessSize),
offsetof(afsStatistics , WorkStations),
offsetof(afsStatistics , ActiveWorkStations),
offsetof(afsStatistics , Spare1),
offsetof(afsStatistics , Spare2),
offsetof(afsStatistics , Spare3),
offsetof(afsStatistics , Spare4),
offsetof(afsStatistics , Spare5),
offsetof(afsStatistics , Spare6),
offsetof(afsStatistics , Spare7),
offsetof(afsStatistics , Spare8),
offsetof(afsStatistics , Disk1.BlocksAvailable),
offsetof(afsStatistics , Disk1.TotalBlocks),
offsetof(afsStatistics , Disk1.spare1),
offsetof(afsStatistics , Disk1.spare2),
offsetof(afsStatistics , Disk1.spare3),
offsetof(afsStatistics , Disk1.Name),
offsetof(afsStatistics , Disk2.BlocksAvailable),
offsetof(afsStatistics , Disk2.TotalBlocks),
offsetof(afsStatistics , Disk2.spare1),
offsetof(afsStatistics , Disk2.spare2),
offsetof(afsStatistics , Disk2.spare3),
offsetof(afsStatistics , Disk2.Name),
offsetof(afsStatistics , Disk3.BlocksAvailable),
offsetof(afsStatistics , Disk3.TotalBlocks),
offsetof(afsStatistics , Disk3.spare1),
offsetof(afsStatistics , Disk3.spare2),
offsetof(afsStatistics , Disk3.spare3),
offsetof(afsStatistics , Disk3.Name),
offsetof(afsStatistics , Disk4.BlocksAvailable),
offsetof(afsStatistics , Disk4.TotalBlocks),
offsetof(afsStatistics , Disk4.spare1),
offsetof(afsStatistics , Disk4.spare2),
offsetof(afsStatistics , Disk4.spare3),
offsetof(afsStatistics , Disk4.Name),
offsetof(afsStatistics , Disk5.BlocksAvailable),
offsetof(afsStatistics , Disk5.TotalBlocks),
offsetof(afsStatistics , Disk5.spare1),
offsetof(afsStatistics , Disk5.spare2),
offsetof(afsStatistics , Disk5.spare3),
offsetof(afsStatistics , Disk5.Name),
offsetof(afsStatistics , Disk6.BlocksAvailable),
offsetof(afsStatistics , Disk6.TotalBlocks),
offsetof(afsStatistics , Disk6.spare1),
offsetof(afsStatistics , Disk6.spare2),
offsetof(afsStatistics , Disk6.spare3),
offsetof(afsStatistics , Disk6.Name),
offsetof(afsStatistics , Disk7.BlocksAvailable),
offsetof(afsStatistics , Disk7.TotalBlocks),
offsetof(afsStatistics , Disk7.spare1),
offsetof(afsStatistics , Disk7.spare2),
offsetof(afsStatistics , Disk7.spare3),
offsetof(afsStatistics , Disk7.Name),
offsetof(afsStatistics , Disk8.BlocksAvailable),
offsetof(afsStatistics , Disk8.TotalBlocks),
offsetof(afsStatistics , Disk8.spare1),
offsetof(afsStatistics , Disk8.spare2),
offsetof(afsStatistics , Disk8.spare3),
offsetof(afsStatistics , Disk8.Name),
offsetof(afsStatistics , Disk9.BlocksAvailable),
offsetof(afsStatistics , Disk9.TotalBlocks),
offsetof(afsStatistics , Disk9.spare1),
offsetof(afsStatistics , Disk9.spare2),
offsetof(afsStatistics , Disk9.spare3),
offsetof(afsStatistics , Disk9.Name),
offsetof(afsStatistics , Disk10.BlocksAvailable),
offsetof(afsStatistics , Disk10.TotalBlocks),
offsetof(afsStatistics , Disk10.spare1),
offsetof(afsStatistics , Disk10.spare2),
offsetof(afsStatistics , Disk10.spare3),
offsetof(afsStatistics , Disk10.Name),
offsetof(afsStatistics , Disk11.BlocksAvailable),
offsetof(afsStatistics , Disk11.TotalBlocks),
offsetof(afsStatistics , Disk11.spare1),
offsetof(afsStatistics , Disk11.spare2),
offsetof(afsStatistics , Disk11.spare3),
offsetof(afsStatistics , Disk11.Name),
offsetof(afsStatistics , Disk12.BlocksAvailable),
offsetof(afsStatistics , Disk12.TotalBlocks),
offsetof(afsStatistics , Disk12.spare1),
offsetof(afsStatistics , Disk12.spare2),
offsetof(afsStatistics , Disk12.spare3),
offsetof(afsStatistics , Disk12.Name),
offsetof(afsStatistics , Disk13.BlocksAvailable),
offsetof(afsStatistics , Disk13.TotalBlocks),
offsetof(afsStatistics , Disk13.spare1),
offsetof(afsStatistics , Disk13.spare2),
offsetof(afsStatistics , Disk13.spare3),
offsetof(afsStatistics , Disk13.Name),
offsetof(afsStatistics , Disk14.BlocksAvailable),
offsetof(afsStatistics , Disk14.TotalBlocks),
offsetof(afsStatistics , Disk14.spare1),
offsetof(afsStatistics , Disk14.spare2),
offsetof(afsStatistics , Disk14.spare3),
offsetof(afsStatistics , Disk14.Name),
offsetof(afsStatistics , Disk15.BlocksAvailable),
offsetof(afsStatistics , Disk15.TotalBlocks),
offsetof(afsStatistics , Disk15.spare1),
offsetof(afsStatistics , Disk15.spare2),
offsetof(afsStatistics , Disk15.spare3),
offsetof(afsStatistics , Disk15.Name),
offsetof(afsStatistics , Disk16.BlocksAvailable),
offsetof(afsStatistics , Disk16.TotalBlocks),
offsetof(afsStatistics , Disk16.spare1),
offsetof(afsStatistics , Disk16.spare2),
offsetof(afsStatistics , Disk16.spare3),
offsetof(afsStatistics , Disk16.Name),
sizeof(afsReturns ),
offsetof(afsReturns , afsReturns_len),
offsetof(afsReturns , afsReturns_val),
sizeof(afsReturnDesc ),
offsetof(afsReturnDesc , fid.Cell),
offsetof(afsReturnDesc , fid.Volume),
offsetof(afsReturnDesc , fid.Vnode),
offsetof(afsReturnDesc , fid.Unique),
offsetof(afsReturnDesc , tokenID),
offsetof(afsReturnDesc , type),
offsetof(afsReturnDesc , flags),
(idl_ulong_int)sizeof(afs_recordLock_t),
sizeof(afsRecordLock ),
offsetof(afsRecordLock , l_type),
offsetof(afsRecordLock , l_whence),
offsetof(afsRecordLock , l_start_pos),
offsetof(afsRecordLock , l_end_pos),
offsetof(afsRecordLock , l_pid),
offsetof(afsRecordLock , l_sysid),
offsetof(afsRecordLock , l_fstype),
offsetof(afsRecordLock , l_start_pos_ext),
offsetof(afsRecordLock , l_end_pos_ext),
sizeof(afsTaggedPath ),
offsetof(afsTaggedPath , tp_tag),
offsetof(afsTaggedPath , tp_length),
offsetof(afsTaggedPath , tp_chars),
sizeof(afsTaggedName ),
offsetof(afsTaggedName , tn_tag),
offsetof(afsTaggedName , tn_length),
offsetof(afsTaggedName , tn_chars),
sizeof(afsFidTaggedName ),
offsetof(afsFidTaggedName , fid.Cell),
offsetof(afsFidTaggedName , fid.Volume),
offsetof(afsFidTaggedName , fid.Vnode),
offsetof(afsFidTaggedName , fid.Unique),
offsetof(afsFidTaggedName , name.tn_tag),
offsetof(afsFidTaggedName , name.tn_length),
offsetof(afsFidTaggedName , name.tn_chars),
sizeof(afsStoreStatus ),
offsetof(afsStoreStatus , mask),
offsetof(afsStoreStatus , modTime.sec),
offsetof(afsStoreStatus , modTime.usec),
offsetof(afsStoreStatus , accessTime.sec),
offsetof(afsStoreStatus , accessTime.usec),
offsetof(afsStoreStatus , changeTime.sec),
offsetof(afsStoreStatus , changeTime.usec),
offsetof(afsStoreStatus , owner),
offsetof(afsStoreStatus , group),
offsetof(afsStoreStatus , mode),
offsetof(afsStoreStatus , truncLength),
offsetof(afsStoreStatus , length),
offsetof(afsStoreStatus , typeUUID.time_low),
offsetof(afsStoreStatus , typeUUID.time_mid),
offsetof(afsStoreStatus , typeUUID.time_hi_and_version),
offsetof(afsStoreStatus , typeUUID.clock_seq_hi_and_reserved),
offsetof(afsStoreStatus , typeUUID.clock_seq_low),
offsetof(afsStoreStatus , typeUUID.node),
offsetof(afsStoreStatus , deviceType),
offsetof(afsStoreStatus , deviceNumber),
offsetof(afsStoreStatus , cmask),
offsetof(afsStoreStatus , clientSpare1),
offsetof(afsStoreStatus , deviceNumberHighBits),
offsetof(afsStoreStatus , spare1),
offsetof(afsStoreStatus , spare2),
offsetof(afsStoreStatus , spare3),
offsetof(afsStoreStatus , spare4),
offsetof(afsStoreStatus , spare5),
offsetof(afsStoreStatus , spare6),
sizeof(afsACL ),
offsetof(afsACL , afsACL_len),
offsetof(afsACL , afsACL_val),
sizeof(afsVolSync ),
offsetof(afsVolSync , VolID),
offsetof(afsVolSync , VV),
offsetof(afsVolSync , VVAge),
offsetof(afsVolSync , VVPingAge),
offsetof(afsVolSync , vv_spare1),
offsetof(afsVolSync , vv_spare2),
(idl_ulong_int)sizeof(afs_token_t),
sizeof(afsToken ),
offsetof(afsToken , tokenID),
offsetof(afsToken , expirationTime),
offsetof(afsToken , type),
offsetof(afsToken , beginRange),
offsetof(afsToken , endRange),
offsetof(afsToken , beginRangeExt),
offsetof(afsToken , endRangeExt),
sizeof(afsFetchStatus ),
offsetof(afsFetchStatus , interfaceVersion),
offsetof(afsFetchStatus , fileType),
offsetof(afsFetchStatus , linkCount),
offsetof(afsFetchStatus , length),
offsetof(afsFetchStatus , dataVersion),
offsetof(afsFetchStatus , author),
offsetof(afsFetchStatus , owner),
offsetof(afsFetchStatus , group),
offsetof(afsFetchStatus , callerAccess),
offsetof(afsFetchStatus , anonymousAccess),
offsetof(afsFetchStatus , aclExpirationTime),
offsetof(afsFetchStatus , mode),
offsetof(afsFetchStatus , parentVnode),
offsetof(afsFetchStatus , parentUnique),
offsetof(afsFetchStatus , modTime.sec),
offsetof(afsFetchStatus , modTime.usec),
offsetof(afsFetchStatus , changeTime.sec),
offsetof(afsFetchStatus , changeTime.usec),
offsetof(afsFetchStatus , accessTime.sec),
offsetof(afsFetchStatus , accessTime.usec),
offsetof(afsFetchStatus , serverModTime.sec),
offsetof(afsFetchStatus , serverModTime.usec),
offsetof(afsFetchStatus , typeUUID.time_low),
offsetof(afsFetchStatus , typeUUID.time_mid),
offsetof(afsFetchStatus , typeUUID.time_hi_and_version),
offsetof(afsFetchStatus , typeUUID.clock_seq_hi_and_reserved),
offsetof(afsFetchStatus , typeUUID.clock_seq_low),
offsetof(afsFetchStatus , typeUUID.node),
offsetof(afsFetchStatus , objectUUID.time_low),
offsetof(afsFetchStatus , objectUUID.time_mid),
offsetof(afsFetchStatus , objectUUID.time_hi_and_version),
offsetof(afsFetchStatus , objectUUID.clock_seq_hi_and_reserved),
offsetof(afsFetchStatus , objectUUID.clock_seq_low),
offsetof(afsFetchStatus , objectUUID.node),
offsetof(afsFetchStatus , deviceNumber),
offsetof(afsFetchStatus , blocksUsed),
offsetof(afsFetchStatus , clientSpare1),
offsetof(afsFetchStatus , deviceNumberHighBits),
offsetof(afsFetchStatus , spare0),
offsetof(afsFetchStatus , spare1),
offsetof(afsFetchStatus , spare2),
offsetof(afsFetchStatus , spare3),
offsetof(afsFetchStatus , spare4),
offsetof(afsFetchStatus , spare5),
offsetof(afsFetchStatus , spare6),
sizeof(afsFid ),
offsetof(afsFid , Cell),
offsetof(afsFid , Volume),
offsetof(afsFid , Vnode),
offsetof(afsFid , Unique),
(idl_ulong_int)sizeof(afs_hyper_t),
sizeof(afsHyper ),
offsetof(afsHyper , high),
offsetof(afsHyper , low),
sizeof(afsUUID ),
offsetof(afsUUID , time_low),
offsetof(afsUUID , time_mid),
offsetof(afsUUID , time_hi_and_version),
offsetof(afsUUID , clock_seq_hi_and_reserved),
offsetof(afsUUID , clock_seq_low),
offsetof(afsUUID , node),
sizeof(afsNetData ),
offsetof(afsNetData , sockAddr.type),
offsetof(afsNetData , sockAddr.data),
offsetof(afsNetData , principalName),
0
};

static IDL_rtn_func_t IDL_rtn_vec[] = {
(IDL_rtn_func_t)NULL,
(IDL_rtn_func_t)afsRecordLock_from_local,
(IDL_rtn_func_t)afsRecordLock_to_local,
(IDL_rtn_func_t)afsRecordLock_free_local,
(IDL_rtn_func_t)afsRecordLock_free_inst,
(IDL_rtn_func_t)afsToken_from_local,
(IDL_rtn_func_t)afsToken_to_local,
(IDL_rtn_func_t)afsToken_free_local,
(IDL_rtn_func_t)afsToken_free_inst,
(IDL_rtn_func_t)afsHyper_from_local,
(IDL_rtn_func_t)afsHyper_to_local,
(IDL_rtn_func_t)afsHyper_free_local,
(IDL_rtn_func_t)afsHyper_free_inst,
(IDL_rtn_func_t)NULL
};

static idl_byte IDL_type_vec[] = {
0xff,0xff,0xff,0xff,
0,
0,
0xff,0xff,
0x00,0x03,
0x00,0x02,
0x00,0x04,
0x00,0x00,
0x4d,0x37,0xf2,0xdd,
0xed,0x93,
0x00,0x00,
0x02,
0xc0,
0x37,0xcf,0x1e,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x04,
0x00,0x00,0x18,0xe0,
0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,
0x00,0x00,0x00,0x1c,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x08,
0x00,0x00,0x00,0x06,
0x00,0x00,0x02,0xe0,
0x00,0x00,0x00,0x01,
0x00,0x00,0x03,0x20,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x09,
0x00,0x00,0x00,0x03,
0x00,0x00,0x03,0x28,
0x00,0x00,0x00,0x06,
0x00,0x00,0x03,0x50,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0b,
0x00,0x00,0x00,0x05,
0x00,0x00,0x03,0xa8,
0x00,0x00,0x00,0x07,
0x00,0x00,0x03,0xe8,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x09,
0x00,0x00,0x00,0x04,
0x00,0x00,0x04,0x50,
0x00,0x00,0x00,0x05,
0x00,0x00,0x04,0x80,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x08,
0x00,0x00,0x00,0x03,
0x00,0x00,0x04,0xc8,
0x00,0x00,0x00,0x05,
0x00,0x00,0x04,0xf0,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0b,
0x00,0x00,0x00,0x07,
0x00,0x00,0x05,0x38,
0x00,0x00,0x00,0x05,
0x00,0x00,0x05,0x98,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0a,
0x00,0x00,0x00,0x06,
0x00,0x00,0x05,0xe0,
0x00,0x00,0x00,0x04,
0x00,0x00,0x06,0x30,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x08,
0x00,0x00,0x00,0x04,
0x00,0x00,0x06,0x68,
0x00,0x00,0x00,0x04,
0x00,0x00,0x06,0xa0,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0b,
0x00,0x00,0x00,0x05,
0x00,0x00,0x06,0xd8,
0x00,0x00,0x00,0x07,
0x00,0x00,0x07,0x20,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0c,
0x00,0x00,0x00,0x05,
0x00,0x00,0x07,0x88,
0x00,0x00,0x00,0x07,
0x00,0x00,0x07,0xd0,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x10,
0x00,0x00,0x00,0x07,
0x00,0x00,0x08,0x38,
0x00,0x00,0x00,0x0a,
0x00,0x00,0x08,0xa0,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0d,
0x00,0x00,0x00,0x06,
0x00,0x00,0x09,0x38,
0x00,0x00,0x00,0x07,
0x00,0x00,0x09,0x90,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0a,
0x00,0x00,0x00,0x05,
0x00,0x00,0x09,0xf8,
0x00,0x00,0x00,0x05,
0x00,0x00,0x0a,0x40,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0c,
0x00,0x00,0x00,0x05,
0x00,0x00,0x0a,0x88,
0x00,0x00,0x00,0x07,
0x00,0x00,0x0a,0xd0,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0b,
0x00,0x00,0x00,0x05,
0x00,0x00,0x0b,0x38,
0x00,0x00,0x00,0x07,
0x00,0x00,0x0b,0x80,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0c,
0x00,0x00,0x00,0x05,
0x00,0x00,0x0b,0xe8,
0x00,0x00,0x00,0x08,
0x00,0x00,0x0c,0x28,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0b,
0x00,0x00,0x00,0x04,
0x00,0x00,0x0c,0xa0,
0x00,0x00,0x00,0x07,
0x00,0x00,0x0c,0xd8,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0a,
0x00,0x00,0x00,0x04,
0x00,0x00,0x0d,0x40,
0x00,0x00,0x00,0x07,
0x00,0x00,0x0d,0x78,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x04,
0x00,0x00,0x00,0x02,
0x00,0x00,0x0d,0xe0,
0x00,0x00,0x00,0x01,
0x00,0x00,0x0d,0xf8,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x06,
0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
0x00,0x00,0x0e,0x00,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0e,
0x00,0x00,0x00,0x08,
0x00,0x00,0x0e,0x28,
0x00,0x00,0x00,0x06,
0x00,0x00,0x0e,0x98,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x03,
0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,
0x00,0x00,0x00,0x02,
0x00,0x00,0x0e,0xf0,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0a,
0x00,0x00,0x00,0x06,
0x00,0x00,0x0f,0x08,
0x00,0x00,0x00,0x04,
0x00,0x00,0x0f,0x48,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x08,
0x00,0x00,0x00,0x05,
0x00,0x00,0x0f,0x78,
0x00,0x00,0x00,0x02,
0x00,0x00,0x0f,0xa8,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x08,
0x00,0x00,0x00,0x04,
0x00,0x00,0x0f,0xb8,
0x00,0x00,0x00,0x05,
0x00,0x00,0x0f,0xf0,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x03,
0x00,0x00,0x00,0x01,
0x00,0x00,0x10,0x38,
0x00,0x00,0x00,0x02,
0x00,0x00,0x10,0x38,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x04,
0x00,0x00,0x00,0x02,
0x00,0x00,0x10,0x50,
0x00,0x00,0x00,0x02,
0x00,0x00,0x10,0x58,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0d,
0x00,0x00,0x00,0x05,
0x00,0x00,0x10,0x70,
0x00,0x00,0x00,0x09,
0x00,0x00,0x10,0xb0,
0x00,0x00,0x00,0x02,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x38,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,
0x00,0x00,0x11,0x5c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0xf8,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_LONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x0a,
IDL_DT_PASSED_BY_REF,
IDL_DT_PIPE,
0,
0xff,
0x00,0x00,0x12,0x21,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0xf8,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x09,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x24,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0xf8,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x38,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_LONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_PIPE,
0,
0xff,
0x00,0x00,0x12,0x21,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x09,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0a,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x24,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x09,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x38,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x84,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x09,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0a,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,
0x00,0x00,0x12,0xb4,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x38,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x09,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0a,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0xf8,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x84,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x84,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x09,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0a,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0c,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0d,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0e,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0f,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,
0x00,0x00,0x12,0xb4,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,
0x00,0x00,0x12,0xcc,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x38,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x09,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0a,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0xf8,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0c,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,
0x00,0x00,0x12,0xb4,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x09,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,
0x00,0x00,0x12,0xb4,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x38,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x09,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0a,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0xf8,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x84,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x09,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0a,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_PASSED_BY_REF,
IDL_DT_PIPE,
0,
0xff,
0x00,0x00,0x12,0x21,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x09,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0xf8,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0a,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,
0x00,0x00,0x12,0xb4,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x09,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0xf8,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0a,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0xf8,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0xf8,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0xe4,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x09,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0xf4,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,
0x00,0x00,0x12,0xb4,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,
0x00,0x00,0x12,0xb4,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_LONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,
0x00,0x00,0x12,0xb4,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x38,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x09,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x0a,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0c,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0d,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,
0x00,0x00,0x13,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x14,0x80,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x14,0x94,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x09,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x14,0xa8,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x14,0xbc,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x14,0xbc,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x14,0xd4,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,
0x00,0x00,0x14,0xe8,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x74,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x0c,
IDL_DT_PASSED_BY_REF,
IDL_DT_PIPE,
0,
0xff,
0x00,0x00,0x12,0x21,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x14,0xfc,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x09,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0x8c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0a,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0xf8,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x12,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x01,0x8e,
IDL_DT_NDR_ALIGN_2,
IDL_DT_NDR_ALIGN_2,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_USHORT,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x18,0xd3,
0x00,0x00,0x18,0xd3,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_STRING,
IDL_DT_VARYING_ARRAY,
0,
0x00,0x00,0x18,0xb7,
0x00,0x00,0x18,0xb7,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x01,0x87,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_USHORT,
IDL_DT_USHORT,
IDL_DT_USMALL,
IDL_DT_USMALL,
IDL_DT_FIXED_ARRAY,
0,
0x00,0x00,0x18,0xab,
0x00,0x00,0x18,0xab,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x01,0x7e,
IDL_DT_NDR_ALIGN_4,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x18,0x90,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x01,0x50,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x18,0x90,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x18,0x90,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_USHORT,
IDL_DT_USHORT,
IDL_DT_USMALL,
IDL_DT_USMALL,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x18,0x83,
0x00,0x00,0x18,0x83,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_USHORT,
IDL_DT_USHORT,
IDL_DT_USMALL,
IDL_DT_USMALL,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x18,0x77,
0x00,0x00,0x18,0x77,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x01,0x47,
0x00,0x00,0x00,0x05,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x18,0x5c,
0x00,0x00,0x01,0x40,
IDL_DT_NDR_ALIGN_4,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x18,0x90,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_EOL,
IDL_DT_BYTE,
0xff,0xff,
0x00,0x00,0x01,0x3d,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_VARYING_ARRAY,
0,
0x00,0x00,0x18,0x3f,
0x00,0x00,0x18,0x3f,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x01,0x1f,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x18,0x90,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x18,0x90,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_USHORT,
IDL_DT_USHORT,
IDL_DT_USMALL,
IDL_DT_USMALL,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,0xff,
0x00,0x00,0x18,0x33,
0x00,0x00,0x18,0x33,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x01,0x17,
IDL_DT_NDR_ALIGN_4,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,0xff,
0x00,0x00,0x18,0x90,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x18,0x90,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_USHORT,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,0xff,
0x00,0x00,0x18,0x27,
0x00,0x00,0x18,0x27,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x01,0x13,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_USHORT,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,0xff,
0x00,0x00,0x18,0x1b,
0x00,0x00,0x18,0x1b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x01,0x0f,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_USHORT,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,0xff,
0x00,0x00,0x18,0x0f,
0x00,0x00,0x18,0x0f,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x01,0x04,
0x00,0x00,0x00,0x01,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x18,0x00,
0x00,0x00,0x00,0xf9,
IDL_DT_NDR_ALIGN_4,
IDL_DT_LONG,
IDL_DT_VARYING_ARRAY,
0|IDL_PROP_DEP_INT,
0x00,0x00,0x17,0xaf,
0x00,0x00,0x17,0xaf,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x67,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0,
0xff,
0x00,0x00,0x17,0xa3,
0x00,0x00,0x17,0xa3,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x17,0x97,
0x00,0x00,0x17,0x97,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x17,0x8b,
0x00,0x00,0x17,0x8b,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x17,0x7f,
0x00,0x00,0x17,0x7f,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x17,0x73,
0x00,0x00,0x17,0x73,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x17,0x67,
0x00,0x00,0x17,0x67,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x17,0x5b,
0x00,0x00,0x17,0x5b,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x17,0x4f,
0x00,0x00,0x17,0x4f,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x17,0x43,
0x00,0x00,0x17,0x43,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x17,0x37,
0x00,0x00,0x17,0x37,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x17,0x2b,
0x00,0x00,0x17,0x2b,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x17,0x1f,
0x00,0x00,0x17,0x1f,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x17,0x13,
0x00,0x00,0x17,0x13,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x17,0x07,
0x00,0x00,0x17,0x07,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x16,0xfb,
0x00,0x00,0x16,0xfb,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x16,0xef,
0x00,0x00,0x16,0xef,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x64,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_VARYING_ARRAY,
0|IDL_PROP_DEP_INT,
0x00,0x00,0x16,0xcb,
0x00,0x00,0x16,0xcb,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x61,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_VARYING_ARRAY,
0|IDL_PROP_DEP_INT,
0x00,0x00,0x16,0xa7,
0x00,0x00,0x16,0xa7,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x58,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_VARYING_ARRAY,
0|IDL_PROP_DEP_INT,
0x00,0x00,0x16,0x67,
0x00,0x00,0x16,0x67,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x53,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_VARYING_ARRAY,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x16,0x4b,
0x00,0x00,0x16,0x4b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x3b,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_VARYING_ARRAY,
0|IDL_PROP_DEP_INT,
0x00,0x00,0x15,0xdf,
0x00,0x00,0x15,0xdf,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x38,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0|IDL_PROP_DEP_INT,
0x00,0x00,0x15,0xd3,
0x00,0x00,0x15,0xd3,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x01,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_VARYING_ARRAY,
0|IDL_PROP_DEP_INT,
0x00,0x00,0x15,0x0f,
0x00,0x00,0x15,0x0f,
IDL_DT_EOL,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_LENGTH_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x01,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x15,0x30,
0x00,0x00,0x00,0x04,
IDL_DT_NDR_ALIGN_4,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,0xff,
0x00,0x00,0x18,0x90,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x18,0x90,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x18,0x90,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x18,0x90,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_USHORT,
IDL_DT_USHORT,
IDL_DT_USMALL,
IDL_DT_USMALL,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x15,0xc7,
0x00,0x00,0x15,0xc7,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_USHORT,
IDL_DT_USHORT,
IDL_DT_USMALL,
IDL_DT_USMALL,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x15,0xbb,
0x00,0x00,0x15,0xbb,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x11,0xf8,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x05,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x05,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x13,
IDL_DT_ULONG,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x09,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_LENGTH_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x01,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,0xff,
0x00,0x00,0x16,0x00,
0x00,0x00,0x00,0x3e,
IDL_DT_NDR_ALIGN_4,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_USHORT,
IDL_DT_USHORT,
IDL_DT_USMALL,
IDL_DT_USMALL,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x16,0x3f,
0x00,0x00,0x16,0x3f,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_USHORT,
IDL_DT_USHORT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0,
0x00,0x00,0x16,0x33,
0x00,0x00,0x16,0x33,
IDL_DT_EOL,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x31,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x05,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_LENGTH_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_ULONG,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_LENGTH_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x01,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x16,0x88,
0x00,0x00,0x00,0x5b,
IDL_DT_NDR_ALIGN_4,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,0xff,
0x00,0x00,0x18,0x90,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x18,0x90,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_LENGTH_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x01,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x12,0x08,
0xff,0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_LENGTH_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x01,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x18,0x90,
0xff,0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_LENGTH_IS,
IDL_DT_LONG,
0xff,0xff,
0x00,0x00,0x00,0x01,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x17,0xd0,
0x00,0x00,0x00,0xfc,
IDL_DT_NDR_ALIGN_4,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,0xff,
0x00,0x00,0x18,0x90,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x18,0x90,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,0xff,
0x00,0x00,0x18,0x90,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x18,0x90,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x01,0x05,
IDL_DT_NDR_ALIGN_4,
IDL_DT_SHORT,
IDL_DT_SHORT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_EOL,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x04,0x00,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x01,0x00,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x01,0x00,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x05,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x1f,0xfb,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_LENGTH_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x01,
IDL_DT_BYTE,
0xff,0xff,0xff,
0x00,0x00,0x01,0x48,
IDL_DT_NDR_ALIGN_4,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_ULONG,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x18,0x90,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x05,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x05,
IDL_DT_BYTE,
0xff,0xff,0xff,
0x00,0x00,0x01,0x83,
0x00,0x00,0x00,0x09,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x18,0xa0,
0x00,0x00,0x01,0x84,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x05,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xff,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_STRING,
1,
0xff,0xff,
0x00,0x00,0x00,0xff,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0d,
IDL_DT_USMALL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x10,
0
};


error_status_t AFS_SetContext
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ unsigned32 epochTime,
    /* [in] */ afsNetData *callbackAddr,
    /* [in] */ unsigned32 Flags,
    /* [in] */ afsUUID *secObjectID,
    /* [in] */ unsigned32 clientSizesAttrs,
    /* [in] */ unsigned32 parm7
)
#else
(h, epochTime, callbackAddr, Flags, secObjectID, clientSizesAttrs, parm7)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    unsigned32 epochTime;
    afsNetData *callbackAddr;
    unsigned32 Flags;
    afsUUID *secObjectID;
    unsigned32 clientSizesAttrs;
    unsigned32 parm7;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[8];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)&epochTime;
IDL_param_vec[3] = (rpc_void_p_t)callbackAddr;
IDL_param_vec[4] = (rpc_void_p_t)&Flags;
IDL_param_vec[5] = (rpc_void_p_t)secObjectID;
IDL_param_vec[6] = (rpc_void_p_t)&clientSizesAttrs;
IDL_param_vec[7] = (rpc_void_p_t)&parm7;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,0,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    6,
    736,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    1,
    800,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_LookupRoot
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsFid *InFidp,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *minVVp,
    /* [in] */ unsigned32 Flags,
    /* [out] */ afsFid *OutFidp,
    /* [out] */ afsFetchStatus *OutFidStatusp,
    /* [out] */ /* Type must appear in user header or IDL */ afs_token_t *OutTokenp,
    /* [out] */ afsVolSync *Syncp
)
#else
(h, InFidp, minVVp, Flags, OutFidp, OutFidStatusp, OutTokenp, Syncp)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsFid *InFidp;
    /* Type must appear in user header or IDL */ afs_hyper_t *minVVp;
    unsigned32 Flags;
    afsFid *OutFidp;
    afsFetchStatus *OutFidStatusp;
    /* Type must appear in user header or IDL */ afs_token_t *OutTokenp;
    afsVolSync *Syncp;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[9];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)InFidp;
IDL_param_vec[3] = (rpc_void_p_t)minVVp;
IDL_param_vec[4] = (rpc_void_p_t)&Flags;
IDL_param_vec[5] = (rpc_void_p_t)OutFidp;
IDL_param_vec[6] = (rpc_void_p_t)OutFidStatusp;
IDL_param_vec[7] = (rpc_void_p_t)OutTokenp;
IDL_param_vec[8] = (rpc_void_p_t)Syncp;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,1,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    3,
    808,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    6,
    848,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_FetchData
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsFid *Fidp,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *minVVp,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *Position,
    /* [in] */ signed32 Length,
    /* [in] */ unsigned32 Flags,
    /* [out] */ afsFetchStatus *OutStatusp,
    /* [out] */ /* Type must appear in user header or IDL */ afs_token_t *OutTokenp,
    /* [out] */ afsVolSync *Syncp,
    /* [out] */ pipe_t *fetchStream
)
#else
(h, Fidp, minVVp, Position, Length, Flags, OutStatusp, OutTokenp, Syncp, fetchStream)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsFid *Fidp;
    /* Type must appear in user header or IDL */ afs_hyper_t *minVVp;
    /* Type must appear in user header or IDL */ afs_hyper_t *Position;
    signed32 Length;
    unsigned32 Flags;
    afsFetchStatus *OutStatusp;
    /* Type must appear in user header or IDL */ afs_token_t *OutTokenp;
    afsVolSync *Syncp;
    pipe_t *fetchStream;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[11];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)Fidp;
IDL_param_vec[3] = (rpc_void_p_t)minVVp;
IDL_param_vec[4] = (rpc_void_p_t)Position;
IDL_param_vec[5] = (rpc_void_p_t)&Length;
IDL_param_vec[6] = (rpc_void_p_t)&Flags;
IDL_param_vec[7] = (rpc_void_p_t)OutStatusp;
IDL_param_vec[8] = (rpc_void_p_t)OutTokenp;
IDL_param_vec[9] = (rpc_void_p_t)Syncp;
IDL_param_vec[10] = (rpc_void_p_t)fetchStream;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0|rpc_c_call_out_pipe,
 (rpc_if_handle_t)&IDL_ifspec,2,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    5,
    936,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    7,
    1000,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_FetchACL
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsFid *Fidp,
    /* [in] */ unsigned32 aclType,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *minVVp,
    /* [in] */ unsigned32 Flags,
    /* [out] */ afsACL *AccessListp,
    /* [out] */ afsFetchStatus *OutStatusp,
    /* [out] */ afsVolSync *Syncp
)
#else
(h, Fidp, aclType, minVVp, Flags, AccessListp, OutStatusp, Syncp)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsFid *Fidp;
    unsigned32 aclType;
    /* Type must appear in user header or IDL */ afs_hyper_t *minVVp;
    unsigned32 Flags;
    afsACL *AccessListp;
    afsFetchStatus *OutStatusp;
    afsVolSync *Syncp;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[9];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)Fidp;
IDL_param_vec[3] = (rpc_void_p_t)&aclType;
IDL_param_vec[4] = (rpc_void_p_t)minVVp;
IDL_param_vec[5] = (rpc_void_p_t)&Flags;
IDL_param_vec[6] = (rpc_void_p_t)AccessListp;
IDL_param_vec[7] = (rpc_void_p_t)OutStatusp;
IDL_param_vec[8] = (rpc_void_p_t)Syncp;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,3,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    4,
    1104,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    5,
    1152,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_FetchStatus
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsFid *Fidp,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *minVVp,
    /* [in] */ unsigned32 Flags,
    /* [out] */ afsFetchStatus *OutStatusp,
    /* [out] */ /* Type must appear in user header or IDL */ afs_token_t *OutTokenp,
    /* [out] */ afsVolSync *Syncp
)
#else
(h, Fidp, minVVp, Flags, OutStatusp, OutTokenp, Syncp)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsFid *Fidp;
    /* Type must appear in user header or IDL */ afs_hyper_t *minVVp;
    unsigned32 Flags;
    afsFetchStatus *OutStatusp;
    /* Type must appear in user header or IDL */ afs_token_t *OutTokenp;
    afsVolSync *Syncp;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[8];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)Fidp;
IDL_param_vec[3] = (rpc_void_p_t)minVVp;
IDL_param_vec[4] = (rpc_void_p_t)&Flags;
IDL_param_vec[5] = (rpc_void_p_t)OutStatusp;
IDL_param_vec[6] = (rpc_void_p_t)OutTokenp;
IDL_param_vec[7] = (rpc_void_p_t)Syncp;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,4,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    3,
    1224,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    5,
    1264,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_StoreData
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsFid *Fidp,
    /* [in] */ afsStoreStatus *InStatusp,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *Position,
    /* [in] */ signed32 Length,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *minVVp,
    /* [in] */ unsigned32 Flags,
    /* [in] */ pipe_t *storeStream,
    /* [out] */ afsFetchStatus *OutStatusp,
    /* [out] */ afsVolSync *Syncp
)
#else
(h, Fidp, InStatusp, Position, Length, minVVp, Flags, storeStream, OutStatusp, Syncp)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsFid *Fidp;
    afsStoreStatus *InStatusp;
    /* Type must appear in user header or IDL */ afs_hyper_t *Position;
    signed32 Length;
    /* Type must appear in user header or IDL */ afs_hyper_t *minVVp;
    unsigned32 Flags;
    pipe_t *storeStream;
    afsFetchStatus *OutStatusp;
    afsVolSync *Syncp;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[11];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)Fidp;
IDL_param_vec[3] = (rpc_void_p_t)InStatusp;
IDL_param_vec[4] = (rpc_void_p_t)Position;
IDL_param_vec[5] = (rpc_void_p_t)&Length;
IDL_param_vec[6] = (rpc_void_p_t)minVVp;
IDL_param_vec[7] = (rpc_void_p_t)&Flags;
IDL_param_vec[8] = (rpc_void_p_t)storeStream;
IDL_param_vec[9] = (rpc_void_p_t)OutStatusp;
IDL_param_vec[10] = (rpc_void_p_t)Syncp;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0|rpc_c_call_in_pipe,
 (rpc_if_handle_t)&IDL_ifspec,5,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    7,
    1336,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    5,
    1432,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_StoreACL
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsFid *Fidp,
    /* [in] */ afsACL *AccessListp,
    /* [in] */ unsigned32 aclType,
    /* [in] */ afsFid *aclFidp,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *minVVp,
    /* [in] */ unsigned32 Flags,
    /* [out] */ afsFetchStatus *OutStatusp,
    /* [out] */ afsVolSync *Syncp
)
#else
(h, Fidp, AccessListp, aclType, aclFidp, minVVp, Flags, OutStatusp, Syncp)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsFid *Fidp;
    afsACL *AccessListp;
    unsigned32 aclType;
    afsFid *aclFidp;
    /* Type must appear in user header or IDL */ afs_hyper_t *minVVp;
    unsigned32 Flags;
    afsFetchStatus *OutStatusp;
    afsVolSync *Syncp;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[10];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)Fidp;
IDL_param_vec[3] = (rpc_void_p_t)AccessListp;
IDL_param_vec[4] = (rpc_void_p_t)&aclType;
IDL_param_vec[5] = (rpc_void_p_t)aclFidp;
IDL_param_vec[6] = (rpc_void_p_t)minVVp;
IDL_param_vec[7] = (rpc_void_p_t)&Flags;
IDL_param_vec[8] = (rpc_void_p_t)OutStatusp;
IDL_param_vec[9] = (rpc_void_p_t)Syncp;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,6,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    6,
    1504,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    4,
    1584,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_StoreStatus
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsFid *Fidp,
    /* [in] */ afsStoreStatus *InStatusp,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *minVVp,
    /* [in] */ unsigned32 Flags,
    /* [out] */ afsFetchStatus *OutStatusp,
    /* [out] */ afsVolSync *Syncp
)
#else
(h, Fidp, InStatusp, minVVp, Flags, OutStatusp, Syncp)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsFid *Fidp;
    afsStoreStatus *InStatusp;
    /* Type must appear in user header or IDL */ afs_hyper_t *minVVp;
    unsigned32 Flags;
    afsFetchStatus *OutStatusp;
    afsVolSync *Syncp;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[8];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)Fidp;
IDL_param_vec[3] = (rpc_void_p_t)InStatusp;
IDL_param_vec[4] = (rpc_void_p_t)minVVp;
IDL_param_vec[5] = (rpc_void_p_t)&Flags;
IDL_param_vec[6] = (rpc_void_p_t)OutStatusp;
IDL_param_vec[7] = (rpc_void_p_t)Syncp;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,7,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    4,
    1640,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    4,
    1696,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_RemoveFile
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsFid *DirFidp,
    /* [in] */ afsFidTaggedName *Namep,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *returnTokenIDp,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *minVVp,
    /* [in] */ unsigned32 Flags,
    /* [out] */ afsFetchStatus *OutDirStatusp,
    /* [out] */ afsFetchStatus *OutFileStatusp,
    /* [out] */ afsFid *OutFileFidp,
    /* [out] */ afsVolSync *Syncp
)
#else
(h, DirFidp, Namep, returnTokenIDp, minVVp, Flags, OutDirStatusp, OutFileStatusp, OutFileFidp, Syncp)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsFid *DirFidp;
    afsFidTaggedName *Namep;
    /* Type must appear in user header or IDL */ afs_hyper_t *returnTokenIDp;
    /* Type must appear in user header or IDL */ afs_hyper_t *minVVp;
    unsigned32 Flags;
    afsFetchStatus *OutDirStatusp;
    afsFetchStatus *OutFileStatusp;
    afsFid *OutFileFidp;
    afsVolSync *Syncp;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[11];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)DirFidp;
IDL_param_vec[3] = (rpc_void_p_t)Namep;
IDL_param_vec[4] = (rpc_void_p_t)returnTokenIDp;
IDL_param_vec[5] = (rpc_void_p_t)minVVp;
IDL_param_vec[6] = (rpc_void_p_t)&Flags;
IDL_param_vec[7] = (rpc_void_p_t)OutDirStatusp;
IDL_param_vec[8] = (rpc_void_p_t)OutFileStatusp;
IDL_param_vec[9] = (rpc_void_p_t)OutFileFidp;
IDL_param_vec[10] = (rpc_void_p_t)Syncp;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,8,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    5,
    1752,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    7,
    1824,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_CreateFile
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsFid *DirFidp,
    /* [in] */ afsTaggedName *Namep,
    /* [in] */ afsStoreStatus *InStatusp,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *minVVp,
    /* [in] */ unsigned32 Flags,
    /* [out] */ afsFid *OutFidp,
    /* [out] */ afsFetchStatus *OutFidStatusp,
    /* [out] */ afsFetchStatus *OutDirStatusp,
    /* [out] */ /* Type must appear in user header or IDL */ afs_token_t *OutTokenp,
    /* [out] */ afsVolSync *Syncp
)
#else
(h, DirFidp, Namep, InStatusp, minVVp, Flags, OutFidp, OutFidStatusp, OutDirStatusp, OutTokenp, Syncp)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsFid *DirFidp;
    afsTaggedName *Namep;
    afsStoreStatus *InStatusp;
    /* Type must appear in user header or IDL */ afs_hyper_t *minVVp;
    unsigned32 Flags;
    afsFid *OutFidp;
    afsFetchStatus *OutFidStatusp;
    afsFetchStatus *OutDirStatusp;
    /* Type must appear in user header or IDL */ afs_token_t *OutTokenp;
    afsVolSync *Syncp;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[12];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)DirFidp;
IDL_param_vec[3] = (rpc_void_p_t)Namep;
IDL_param_vec[4] = (rpc_void_p_t)InStatusp;
IDL_param_vec[5] = (rpc_void_p_t)minVVp;
IDL_param_vec[6] = (rpc_void_p_t)&Flags;
IDL_param_vec[7] = (rpc_void_p_t)OutFidp;
IDL_param_vec[8] = (rpc_void_p_t)OutFidStatusp;
IDL_param_vec[9] = (rpc_void_p_t)OutDirStatusp;
IDL_param_vec[10] = (rpc_void_p_t)OutTokenp;
IDL_param_vec[11] = (rpc_void_p_t)Syncp;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,9,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    5,
    1928,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    7,
    2000,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_Rename
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsFid *OldDirFidp,
    /* [in] */ afsFidTaggedName *OldNamep,
    /* [in] */ afsFid *NewDirFidp,
    /* [in] */ afsFidTaggedName *NewNamep,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *returnTokenIDp,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *minVVp,
    /* [in] */ unsigned32 Flags,
    /* [out] */ afsFetchStatus *OutOldDirStatusp,
    /* [out] */ afsFetchStatus *OutNewDirStatusp,
    /* [out] */ afsFid *OutOldFileFidp,
    /* [out] */ afsFetchStatus *OutOldFileStatusp,
    /* [out] */ afsFid *OutNewFileFidp,
    /* [out] */ afsFetchStatus *OutNewFileStatusp,
    /* [out] */ afsVolSync *Syncp
)
#else
(h, OldDirFidp, OldNamep, NewDirFidp, NewNamep, returnTokenIDp, minVVp, Flags, OutOldDirStatusp, OutNewDirStatusp, OutOldFileFidp, OutOldFileStatusp, OutNewFileFidp, OutNewFileStatusp, Syncp)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsFid *OldDirFidp;
    afsFidTaggedName *OldNamep;
    afsFid *NewDirFidp;
    afsFidTaggedName *NewNamep;
    /* Type must appear in user header or IDL */ afs_hyper_t *returnTokenIDp;
    /* Type must appear in user header or IDL */ afs_hyper_t *minVVp;
    unsigned32 Flags;
    afsFetchStatus *OutOldDirStatusp;
    afsFetchStatus *OutNewDirStatusp;
    afsFid *OutOldFileFidp;
    afsFetchStatus *OutOldFileStatusp;
    afsFid *OutNewFileFidp;
    afsFetchStatus *OutNewFileStatusp;
    afsVolSync *Syncp;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[16];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)OldDirFidp;
IDL_param_vec[3] = (rpc_void_p_t)OldNamep;
IDL_param_vec[4] = (rpc_void_p_t)NewDirFidp;
IDL_param_vec[5] = (rpc_void_p_t)NewNamep;
IDL_param_vec[6] = (rpc_void_p_t)returnTokenIDp;
IDL_param_vec[7] = (rpc_void_p_t)minVVp;
IDL_param_vec[8] = (rpc_void_p_t)&Flags;
IDL_param_vec[9] = (rpc_void_p_t)OutOldDirStatusp;
IDL_param_vec[10] = (rpc_void_p_t)OutNewDirStatusp;
IDL_param_vec[11] = (rpc_void_p_t)OutOldFileFidp;
IDL_param_vec[12] = (rpc_void_p_t)OutOldFileStatusp;
IDL_param_vec[13] = (rpc_void_p_t)OutNewFileFidp;
IDL_param_vec[14] = (rpc_void_p_t)OutNewFileStatusp;
IDL_param_vec[15] = (rpc_void_p_t)Syncp;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,10,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    7,
    2104,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    10,
    2208,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_Symlink
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsFid *DirFidp,
    /* [in] */ afsTaggedName *Namep,
    /* [in] */ afsTaggedPath *LinkContentsp,
    /* [in] */ afsStoreStatus *InStatusp,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *minVVp,
    /* [in] */ unsigned32 Flags,
    /* [out] */ afsFid *OutFidp,
    /* [out] */ afsFetchStatus *OutFidStatusp,
    /* [out] */ afsFetchStatus *OutDirStatusp,
    /* [out] */ /* Type must appear in user header or IDL */ afs_token_t *OutTokenp,
    /* [out] */ afsVolSync *Syncp
)
#else
(h, DirFidp, Namep, LinkContentsp, InStatusp, minVVp, Flags, OutFidp, OutFidStatusp, OutDirStatusp, OutTokenp, Syncp)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsFid *DirFidp;
    afsTaggedName *Namep;
    afsTaggedPath *LinkContentsp;
    afsStoreStatus *InStatusp;
    /* Type must appear in user header or IDL */ afs_hyper_t *minVVp;
    unsigned32 Flags;
    afsFid *OutFidp;
    afsFetchStatus *OutFidStatusp;
    afsFetchStatus *OutDirStatusp;
    /* Type must appear in user header or IDL */ afs_token_t *OutTokenp;
    afsVolSync *Syncp;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[13];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)DirFidp;
IDL_param_vec[3] = (rpc_void_p_t)Namep;
IDL_param_vec[4] = (rpc_void_p_t)LinkContentsp;
IDL_param_vec[5] = (rpc_void_p_t)InStatusp;
IDL_param_vec[6] = (rpc_void_p_t)minVVp;
IDL_param_vec[7] = (rpc_void_p_t)&Flags;
IDL_param_vec[8] = (rpc_void_p_t)OutFidp;
IDL_param_vec[9] = (rpc_void_p_t)OutFidStatusp;
IDL_param_vec[10] = (rpc_void_p_t)OutDirStatusp;
IDL_param_vec[11] = (rpc_void_p_t)OutTokenp;
IDL_param_vec[12] = (rpc_void_p_t)Syncp;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,11,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    6,
    2360,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    7,
    2448,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_HardLink
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsFid *DirFidp,
    /* [in] */ afsTaggedName *Namep,
    /* [in] */ afsFid *ExistingFidp,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *minVVp,
    /* [in] */ unsigned32 Flags,
    /* [out] */ afsFetchStatus *OutFidStatusp,
    /* [out] */ afsFetchStatus *OutDirStatusp,
    /* [out] */ afsVolSync *Syncp
)
#else
(h, DirFidp, Namep, ExistingFidp, minVVp, Flags, OutFidStatusp, OutDirStatusp, Syncp)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsFid *DirFidp;
    afsTaggedName *Namep;
    afsFid *ExistingFidp;
    /* Type must appear in user header or IDL */ afs_hyper_t *minVVp;
    unsigned32 Flags;
    afsFetchStatus *OutFidStatusp;
    afsFetchStatus *OutDirStatusp;
    afsVolSync *Syncp;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[10];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)DirFidp;
IDL_param_vec[3] = (rpc_void_p_t)Namep;
IDL_param_vec[4] = (rpc_void_p_t)ExistingFidp;
IDL_param_vec[5] = (rpc_void_p_t)minVVp;
IDL_param_vec[6] = (rpc_void_p_t)&Flags;
IDL_param_vec[7] = (rpc_void_p_t)OutFidStatusp;
IDL_param_vec[8] = (rpc_void_p_t)OutDirStatusp;
IDL_param_vec[9] = (rpc_void_p_t)Syncp;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,12,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    5,
    2552,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    5,
    2624,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_MakeDir
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsFid *DirFidp,
    /* [in] */ afsTaggedName *Namep,
    /* [in] */ afsStoreStatus *InStatusp,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *minVVp,
    /* [in] */ unsigned32 Flags,
    /* [out] */ afsFid *OutFidp,
    /* [out] */ afsFetchStatus *OutFidStatusp,
    /* [out] */ afsFetchStatus *OutDirStatusp,
    /* [out] */ /* Type must appear in user header or IDL */ afs_token_t *OutTokenp,
    /* [out] */ afsVolSync *Syncp
)
#else
(h, DirFidp, Namep, InStatusp, minVVp, Flags, OutFidp, OutFidStatusp, OutDirStatusp, OutTokenp, Syncp)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsFid *DirFidp;
    afsTaggedName *Namep;
    afsStoreStatus *InStatusp;
    /* Type must appear in user header or IDL */ afs_hyper_t *minVVp;
    unsigned32 Flags;
    afsFid *OutFidp;
    afsFetchStatus *OutFidStatusp;
    afsFetchStatus *OutDirStatusp;
    /* Type must appear in user header or IDL */ afs_token_t *OutTokenp;
    afsVolSync *Syncp;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[12];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)DirFidp;
IDL_param_vec[3] = (rpc_void_p_t)Namep;
IDL_param_vec[4] = (rpc_void_p_t)InStatusp;
IDL_param_vec[5] = (rpc_void_p_t)minVVp;
IDL_param_vec[6] = (rpc_void_p_t)&Flags;
IDL_param_vec[7] = (rpc_void_p_t)OutFidp;
IDL_param_vec[8] = (rpc_void_p_t)OutFidStatusp;
IDL_param_vec[9] = (rpc_void_p_t)OutDirStatusp;
IDL_param_vec[10] = (rpc_void_p_t)OutTokenp;
IDL_param_vec[11] = (rpc_void_p_t)Syncp;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,13,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    5,
    2696,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    7,
    2768,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_RemoveDir
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsFid *DirFidp,
    /* [in] */ afsFidTaggedName *Namep,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *returnTokenIDp,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *minVVp,
    /* [in] */ unsigned32 Flags,
    /* [out] */ afsFetchStatus *OutDirStatusp,
    /* [out] */ afsFid *OutFidp,
    /* [out] */ afsFetchStatus *OutDelStatusp,
    /* [out] */ afsVolSync *Syncp
)
#else
(h, DirFidp, Namep, returnTokenIDp, minVVp, Flags, OutDirStatusp, OutFidp, OutDelStatusp, Syncp)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsFid *DirFidp;
    afsFidTaggedName *Namep;
    /* Type must appear in user header or IDL */ afs_hyper_t *returnTokenIDp;
    /* Type must appear in user header or IDL */ afs_hyper_t *minVVp;
    unsigned32 Flags;
    afsFetchStatus *OutDirStatusp;
    afsFid *OutFidp;
    afsFetchStatus *OutDelStatusp;
    afsVolSync *Syncp;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[11];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)DirFidp;
IDL_param_vec[3] = (rpc_void_p_t)Namep;
IDL_param_vec[4] = (rpc_void_p_t)returnTokenIDp;
IDL_param_vec[5] = (rpc_void_p_t)minVVp;
IDL_param_vec[6] = (rpc_void_p_t)&Flags;
IDL_param_vec[7] = (rpc_void_p_t)OutDirStatusp;
IDL_param_vec[8] = (rpc_void_p_t)OutFidp;
IDL_param_vec[9] = (rpc_void_p_t)OutDelStatusp;
IDL_param_vec[10] = (rpc_void_p_t)Syncp;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,14,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    5,
    2872,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    7,
    2944,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_Readdir
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsFid *DirFidp,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *Offsetp,
    /* [in] */ unsigned32 Size,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *minVVp,
    /* [in] */ unsigned32 Flags,
    /* [out] */ /* Type must appear in user header or IDL */ afs_hyper_t *NextOffsetp,
    /* [out] */ afsFetchStatus *OutDirStatusp,
    /* [out] */ /* Type must appear in user header or IDL */ afs_token_t *OutTokenp,
    /* [out] */ afsVolSync *Syncp,
    /* [out] */ pipe_t *dirStream
)
#else
(h, DirFidp, Offsetp, Size, minVVp, Flags, NextOffsetp, OutDirStatusp, OutTokenp, Syncp, dirStream)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsFid *DirFidp;
    /* Type must appear in user header or IDL */ afs_hyper_t *Offsetp;
    unsigned32 Size;
    /* Type must appear in user header or IDL */ afs_hyper_t *minVVp;
    unsigned32 Flags;
    /* Type must appear in user header or IDL */ afs_hyper_t *NextOffsetp;
    afsFetchStatus *OutDirStatusp;
    /* Type must appear in user header or IDL */ afs_token_t *OutTokenp;
    afsVolSync *Syncp;
    pipe_t *dirStream;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[12];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)DirFidp;
IDL_param_vec[3] = (rpc_void_p_t)Offsetp;
IDL_param_vec[4] = (rpc_void_p_t)&Size;
IDL_param_vec[5] = (rpc_void_p_t)minVVp;
IDL_param_vec[6] = (rpc_void_p_t)&Flags;
IDL_param_vec[7] = (rpc_void_p_t)NextOffsetp;
IDL_param_vec[8] = (rpc_void_p_t)OutDirStatusp;
IDL_param_vec[9] = (rpc_void_p_t)OutTokenp;
IDL_param_vec[10] = (rpc_void_p_t)Syncp;
IDL_param_vec[11] = (rpc_void_p_t)dirStream;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0|rpc_c_call_out_pipe,
 (rpc_if_handle_t)&IDL_ifspec,15,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    5,
    3048,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    8,
    3112,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_Lookup
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsFid *DirFidp,
    /* [in] */ afsTaggedName *Namep,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *minVVp,
    /* [in] */ unsigned32 Flags,
    /* [out] */ afsFid *OutFidp,
    /* [out] */ afsFetchStatus *OutFidStatusp,
    /* [out] */ afsFetchStatus *OutDirStatusp,
    /* [out] */ /* Type must appear in user header or IDL */ afs_token_t *OutTokenp,
    /* [out] */ afsVolSync *Syncp
)
#else
(h, DirFidp, Namep, minVVp, Flags, OutFidp, OutFidStatusp, OutDirStatusp, OutTokenp, Syncp)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsFid *DirFidp;
    afsTaggedName *Namep;
    /* Type must appear in user header or IDL */ afs_hyper_t *minVVp;
    unsigned32 Flags;
    afsFid *OutFidp;
    afsFetchStatus *OutFidStatusp;
    afsFetchStatus *OutDirStatusp;
    /* Type must appear in user header or IDL */ afs_token_t *OutTokenp;
    afsVolSync *Syncp;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[11];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)DirFidp;
IDL_param_vec[3] = (rpc_void_p_t)Namep;
IDL_param_vec[4] = (rpc_void_p_t)minVVp;
IDL_param_vec[5] = (rpc_void_p_t)&Flags;
IDL_param_vec[6] = (rpc_void_p_t)OutFidp;
IDL_param_vec[7] = (rpc_void_p_t)OutFidStatusp;
IDL_param_vec[8] = (rpc_void_p_t)OutDirStatusp;
IDL_param_vec[9] = (rpc_void_p_t)OutTokenp;
IDL_param_vec[10] = (rpc_void_p_t)Syncp;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,16,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    4,
    3232,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    7,
    3288,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_GetToken
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsFid *Fidp,
    /* [in] */ /* Type must appear in user header or IDL */ afs_token_t *MinTokenp,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *minVVp,
    /* [in] */ unsigned32 Flags,
    /* [out] */ /* Type must appear in user header or IDL */ afs_token_t *OutTokenp,
    /* [out] */ /* Type must appear in user header or IDL */ afs_recordLock_t *OutBlockerp,
    /* [out] */ afsFetchStatus *OutStatusp,
    /* [out] */ afsVolSync *Syncp
)
#else
(h, Fidp, MinTokenp, minVVp, Flags, OutTokenp, OutBlockerp, OutStatusp, Syncp)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsFid *Fidp;
    /* Type must appear in user header or IDL */ afs_token_t *MinTokenp;
    /* Type must appear in user header or IDL */ afs_hyper_t *minVVp;
    unsigned32 Flags;
    /* Type must appear in user header or IDL */ afs_token_t *OutTokenp;
    /* Type must appear in user header or IDL */ afs_recordLock_t *OutBlockerp;
    afsFetchStatus *OutStatusp;
    afsVolSync *Syncp;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[10];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)Fidp;
IDL_param_vec[3] = (rpc_void_p_t)MinTokenp;
IDL_param_vec[4] = (rpc_void_p_t)minVVp;
IDL_param_vec[5] = (rpc_void_p_t)&Flags;
IDL_param_vec[6] = (rpc_void_p_t)OutTokenp;
IDL_param_vec[7] = (rpc_void_p_t)OutBlockerp;
IDL_param_vec[8] = (rpc_void_p_t)OutStatusp;
IDL_param_vec[9] = (rpc_void_p_t)Syncp;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,17,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    4,
    3392,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    7,
    3448,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_ReleaseTokens
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsReturns *Tokens_Arrayp,
    /* [in] */ unsigned32 Flags
)
#else
(h, Tokens_Arrayp, Flags)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsReturns *Tokens_Arrayp;
    unsigned32 Flags;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[4];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)Tokens_Arrayp;
IDL_param_vec[3] = (rpc_void_p_t)&Flags;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,18,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    2,
    3552,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    1,
    3576,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_GetTime
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [out] */ unsigned32 *Secondsp,
    /* [out] */ unsigned32 *USecondsp,
    /* [out] */ unsigned32 *SyncDistance,
    /* [out] */ unsigned32 *SyncDispersion
)
#else
(h, Secondsp, USecondsp, SyncDistance, SyncDispersion)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    unsigned32 *Secondsp;
    unsigned32 *USecondsp;
    unsigned32 *SyncDistance;
    unsigned32 *SyncDispersion;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[6];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)Secondsp;
IDL_param_vec[3] = (rpc_void_p_t)USecondsp;
IDL_param_vec[4] = (rpc_void_p_t)SyncDistance;
IDL_param_vec[5] = (rpc_void_p_t)SyncDispersion;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,19,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    0,
    0,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    5,
    3584,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_MakeMountPoint
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsFid *DirFidp,
    /* [in] */ afsTaggedName *Namep,
    /* [in] */ afsTaggedName *cellNamep,
    /* [in] */ afsFStype Type,
    /* [in] */ afsTaggedName *volumeNamep,
    /* [in] */ afsStoreStatus *InStatusp,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *minVVp,
    /* [in] */ unsigned32 Flags,
    /* [out] */ afsFid *OutFidp,
    /* [out] */ afsFetchStatus *OutFidStatusp,
    /* [out] */ afsFetchStatus *OutDirStatusp,
    /* [out] */ afsVolSync *Syncp
)
#else
(h, DirFidp, Namep, cellNamep, Type, volumeNamep, InStatusp, minVVp, Flags, OutFidp, OutFidStatusp, OutDirStatusp, Syncp)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsFid *DirFidp;
    afsTaggedName *Namep;
    afsTaggedName *cellNamep;
    afsFStype Type;
    afsTaggedName *volumeNamep;
    afsStoreStatus *InStatusp;
    /* Type must appear in user header or IDL */ afs_hyper_t *minVVp;
    unsigned32 Flags;
    afsFid *OutFidp;
    afsFetchStatus *OutFidStatusp;
    afsFetchStatus *OutDirStatusp;
    afsVolSync *Syncp;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[14];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)DirFidp;
IDL_param_vec[3] = (rpc_void_p_t)Namep;
IDL_param_vec[4] = (rpc_void_p_t)cellNamep;
IDL_param_vec[5] = (rpc_void_p_t)&Type;
IDL_param_vec[6] = (rpc_void_p_t)volumeNamep;
IDL_param_vec[7] = (rpc_void_p_t)InStatusp;
IDL_param_vec[8] = (rpc_void_p_t)minVVp;
IDL_param_vec[9] = (rpc_void_p_t)&Flags;
IDL_param_vec[10] = (rpc_void_p_t)OutFidp;
IDL_param_vec[11] = (rpc_void_p_t)OutFidStatusp;
IDL_param_vec[12] = (rpc_void_p_t)OutDirStatusp;
IDL_param_vec[13] = (rpc_void_p_t)Syncp;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,20,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    8,
    3624,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    6,
    3736,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_GetStatistics
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [out] */ afsStatistics *Statisticsp
)
#else
(h, Statisticsp)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsStatistics *Statisticsp;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[3];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)Statisticsp;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,21,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    0,
    0,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    2,
    3824,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_BulkFetchVV
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *cellIdp,
    /* [in] */ afsBulkVolIDs *VolIDsp,
    /* [in] */ unsigned32 NumVols,
    /* [in] */ unsigned32 Flags,
    /* [in] */ unsigned32 spare1,
    /* [in] */ unsigned32 spare2,
    /* [out] */ afsBulkVVs *VolVVsp,
    /* [out] */ unsigned32 *spare4
)
#else
(h, cellIdp, VolIDsp, NumVols, Flags, spare1, spare2, VolVVsp, spare4)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    /* Type must appear in user header or IDL */ afs_hyper_t *cellIdp;
    afsBulkVolIDs *VolIDsp;
    unsigned32 NumVols;
    unsigned32 Flags;
    unsigned32 spare1;
    unsigned32 spare2;
    afsBulkVVs *VolVVsp;
    unsigned32 *spare4;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[10];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)cellIdp;
IDL_param_vec[3] = (rpc_void_p_t)VolIDsp;
IDL_param_vec[4] = (rpc_void_p_t)&NumVols;
IDL_param_vec[5] = (rpc_void_p_t)&Flags;
IDL_param_vec[6] = (rpc_void_p_t)&spare1;
IDL_param_vec[7] = (rpc_void_p_t)&spare2;
IDL_param_vec[8] = (rpc_void_p_t)VolVVsp;
IDL_param_vec[9] = (rpc_void_p_t)spare4;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,22,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    6,
    3848,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    4,
    3912,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_BulkKeepAlive
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsBulkFEX *KAFEXp,
    /* [in] */ unsigned32 numExecFids,
    /* [in] */ unsigned32 Flags,
    /* [in] */ unsigned32 spare1,
    /* [in] */ unsigned32 spare2,
    /* [out] */ unsigned32 *spare4
)
#else
(h, KAFEXp, numExecFids, Flags, spare1, spare2, spare4)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsBulkFEX *KAFEXp;
    unsigned32 numExecFids;
    unsigned32 Flags;
    unsigned32 spare1;
    unsigned32 spare2;
    unsigned32 *spare4;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[8];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)KAFEXp;
IDL_param_vec[3] = (rpc_void_p_t)&numExecFids;
IDL_param_vec[4] = (rpc_void_p_t)&Flags;
IDL_param_vec[5] = (rpc_void_p_t)&spare1;
IDL_param_vec[6] = (rpc_void_p_t)&spare2;
IDL_param_vec[7] = (rpc_void_p_t)spare4;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,23,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    5,
    3960,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    2,
    4008,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_ProcessQuota
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsFid *Fidp,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *minVVp,
    /* [in] */ unsigned32 Flags,
    /* [in, out] */ afsQuota *quotaListp,
    /* [out] */ afsFetchStatus *OutStatusp,
    /* [out] */ afsVolSync *Syncp
)
#else
(h, Fidp, minVVp, Flags, quotaListp, OutStatusp, Syncp)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsFid *Fidp;
    /* Type must appear in user header or IDL */ afs_hyper_t *minVVp;
    unsigned32 Flags;
    afsQuota *quotaListp;
    afsFetchStatus *OutStatusp;
    afsVolSync *Syncp;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[8];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)Fidp;
IDL_param_vec[3] = (rpc_void_p_t)minVVp;
IDL_param_vec[4] = (rpc_void_p_t)&Flags;
IDL_param_vec[5] = (rpc_void_p_t)quotaListp;
IDL_param_vec[6] = (rpc_void_p_t)OutStatusp;
IDL_param_vec[7] = (rpc_void_p_t)Syncp;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,24,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    4,
    4024,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    5,
    4080,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_GetServerInterfaces
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in, out] */ dfs_interfaceList *serverInterfacesP
)
#else
(h, serverInterfacesP)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    dfs_interfaceList *serverInterfacesP;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[3];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)serverInterfacesP;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,25,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    1,
    4152,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    2,
    4152,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_SetParams
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ unsigned32 Flags,
    /* [in, out] */ afsConnParams *paramsP
)
#else
(h, Flags, paramsP)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    unsigned32 Flags;
    afsConnParams *paramsP;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[4];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)&Flags;
IDL_param_vec[3] = (rpc_void_p_t)paramsP;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,26,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    2,
    4176,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    2,
    4184,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t AFS_BulkFetchStatus
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsFid *DirFidp,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *Offsetp,
    /* [in] */ unsigned32 Size,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *minVVp,
    /* [in] */ unsigned32 Flags,
    /* [out] */ BulkStat *bulkstats,
    /* [out] */ /* Type must appear in user header or IDL */ afs_hyper_t *NextOffsetp,
    /* [out] */ afsFetchStatus *OutDirStatusp,
    /* [out] */ /* Type must appear in user header or IDL */ afs_token_t *OutTokenp,
    /* [out] */ afsVolSync *Syncp,
    /* [out] */ pipe_t *dirStream
)
#else
(h, DirFidp, Offsetp, Size, minVVp, Flags, bulkstats, NextOffsetp, OutDirStatusp, OutTokenp, Syncp, dirStream)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsFid *DirFidp;
    /* Type must appear in user header or IDL */ afs_hyper_t *Offsetp;
    unsigned32 Size;
    /* Type must appear in user header or IDL */ afs_hyper_t *minVVp;
    unsigned32 Flags;
    BulkStat *bulkstats;
    /* Type must appear in user header or IDL */ afs_hyper_t *NextOffsetp;
    afsFetchStatus *OutDirStatusp;
    /* Type must appear in user header or IDL */ afs_token_t *OutTokenp;
    afsVolSync *Syncp;
    pipe_t *dirStream;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[13];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)DirFidp;
IDL_param_vec[3] = (rpc_void_p_t)Offsetp;
IDL_param_vec[4] = (rpc_void_p_t)&Size;
IDL_param_vec[5] = (rpc_void_p_t)minVVp;
IDL_param_vec[6] = (rpc_void_p_t)&Flags;
IDL_param_vec[7] = (rpc_void_p_t)bulkstats;
IDL_param_vec[8] = (rpc_void_p_t)NextOffsetp;
IDL_param_vec[9] = (rpc_void_p_t)OutDirStatusp;
IDL_param_vec[10] = (rpc_void_p_t)OutTokenp;
IDL_param_vec[11] = (rpc_void_p_t)Syncp;
IDL_param_vec[12] = (rpc_void_p_t)dirStream;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0|rpc_c_call_out_pipe,
 (rpc_if_handle_t)&IDL_ifspec,27,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    5,
    4208,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    9,
    4272,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}
#ifdef VMS
#pragma standard
#endif
