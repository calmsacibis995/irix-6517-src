/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
 * the full copyright text.
 */
/*
 * HISTORY
 * $Log: rep_proc_cstub.c,v $
 * Revision 65.2  1999/02/04 19:19:40  mek
 * Provide C style stub for IRIX kernel integration.
 *
 * Revision 65.1  1997/10/20 19:20:27  jdoak
 * *** empty log message ***
 *
 * Revision 1.1.9.1  1996/10/02  17:47:07  damon
 * 	Newest DFS from Transarc
 * 	[1996/10/01  18:37:35  damon]
 *
 * Revision 1.1.4.1  1994/06/09  14:08:00  annie
 * 	fixed copyright in src/file
 * 	[1994/06/09  13:22:54  annie]
 * 
 * Revision 1.1.2.2  1993/01/21  19:36:14  zeliff
 * 	Embedding copyright notices
 * 	[1993/01/19  19:49:53  zeliff]
 * 
 * Revision 1.1  1992/01/19  02:51:16  devrcs
 * 	Initial revision
 * 
 * $EndLog$
 */

/* Generated by IDL compiler version OSF DCE T1.2.0-09 */
#ifdef VMS
#pragma nostandard
#endif
#include <dce/idlddefs.h>
#include <rep_proc.h>

static rpc_syntax_id_t IDL_transfer_syntaxes[1] = {
{
{0x8a885d04u, 0x1ceb, 0x11c9, 0x9f, 0xe8, {0x8, 0x0, 0x2b, 0x10, 0x48, 0x60}},
2}};

static rpc_if_rep_t IDL_ifspec = {
  1, /* ifspec rep version */
  10, /* op count */
  4, /* if version */
  {0x4d37f2ddu, 0xed43, 0x0005, 0x02, 0xc0, {0x37, 0xcf, 0x1e, 0x0, 0x0, 0x0}},
  2, /* stub/rt if version */
  {0, NULL}, /* endpoint vector */
  {1, IDL_transfer_syntaxes} /* syntax vector */
};
/* global */ rpc_if_handle_t REP_v4_0_c_ifspec = (rpc_if_handle_t)&IDL_ifspec;
static idl_ulong_int IDL_offset_vec[] = {
0,
sizeof(dfs_interfaceList ),
offsetof(dfs_interfaceList , dfs_interfaceList_len),
offsetof(dfs_interfaceList , dfs_interfaceList_val),
sizeof(dfs_interfaceDescription ),
offsetof(dfs_interfaceDescription , interface_uuid.time_low),
offsetof(dfs_interfaceDescription , interface_uuid.time_mid),
offsetof(dfs_interfaceDescription , interface_uuid.time_hi_and_version),
offsetof(dfs_interfaceDescription , interface_uuid.clock_seq_hi_and_reserved),
offsetof(dfs_interfaceDescription , interface_uuid.clock_seq_low),
offsetof(dfs_interfaceDescription , interface_uuid.node),
offsetof(dfs_interfaceDescription , vers_major),
offsetof(dfs_interfaceDescription , vers_minor),
offsetof(dfs_interfaceDescription , vers_provider),
offsetof(dfs_interfaceDescription , spare0),
offsetof(dfs_interfaceDescription , spare1),
offsetof(dfs_interfaceDescription , spare2),
offsetof(dfs_interfaceDescription , spare3),
offsetof(dfs_interfaceDescription , spare4),
offsetof(dfs_interfaceDescription , spare5),
offsetof(dfs_interfaceDescription , spare6),
offsetof(dfs_interfaceDescription , spare7),
offsetof(dfs_interfaceDescription , spare8),
offsetof(dfs_interfaceDescription , spare9),
offsetof(dfs_interfaceDescription , spareText),
sizeof(repserverStatus ),
offsetof(repserverStatus , Attns.Count),
offsetof(repserverStatus , Attns.OverCount),
offsetof(repserverStatus , Attns.SizeOverCount),
offsetof(repserverStatus , Attns.SizeOverCountSq),
offsetof(repserverStatus , KAs.Count),
offsetof(repserverStatus , KAs.OverCount),
offsetof(repserverStatus , KAs.SizeOverCount),
offsetof(repserverStatus , KAs.SizeOverCountSq),
offsetof(repserverStatus , nextForceKA),
offsetof(repserverStatus , numReplicas),
offsetof(repserverStatus , numHosts),
offsetof(repserverStatus , numAllocVIDs),
offsetof(repserverStatus , numUsedVIDs),
offsetof(repserverStatus , numReusedVIDs),
offsetof(repserverStatus , numWillCalls),
offsetof(repserverStatus , willCallState),
offsetof(repserverStatus , willCallError),
offsetof(repserverStatus , nextWillCallTime),
offsetof(repserverStatus , spare1),
offsetof(repserverStatus , spare2),
offsetof(repserverStatus , spare3),
offsetof(repserverStatus , spare4),
offsetof(repserverStatus , spare5),
offsetof(repserverStatus , spare6),
offsetof(repserverStatus , spare7),
offsetof(repserverStatus , spare8),
offsetof(repserverStatus , spare9),
sizeof(repStatuses ),
offsetof(repStatuses , repStatuses_len),
offsetof(repStatuses , repStatuses_val),
sizeof(repStatus ),
offsetof(repStatus , volId),
offsetof(repStatus , srcVolId),
offsetof(repStatus , curVV),
offsetof(repStatus , srcVV),
offsetof(repStatus , srcAddr.type),
offsetof(repStatus , srcAddr.data),
offsetof(repStatus , CellId),
offsetof(repStatus , WVT_ID),
offsetof(repStatus , spareh1),
offsetof(repStatus , spareh2),
offsetof(repStatus , spareh3),
offsetof(repStatus , tokenLossTime.sec),
offsetof(repStatus , tokenLossTime.usec),
offsetof(repStatus , tokenExpireTime.sec),
offsetof(repStatus , tokenExpireTime.usec),
offsetof(repStatus , lastReplicaPublish.sec),
offsetof(repStatus , lastReplicaPublish.usec),
offsetof(repStatus , vvCurr.sec),
offsetof(repStatus , vvCurr.usec),
offsetof(repStatus , vvPingCurr.sec),
offsetof(repStatus , vvPingCurr.usec),
offsetof(repStatus , whenTried.sec),
offsetof(repStatus , whenTried.usec),
offsetof(repStatus , whenToTryAgain.sec),
offsetof(repStatus , whenToTryAgain.usec),
offsetof(repStatus , lastKASweep.sec),
offsetof(repStatus , lastKASweep.usec),
offsetof(repStatus , sparet1.sec),
offsetof(repStatus , sparet1.usec),
offsetof(repStatus , sparet2.sec),
offsetof(repStatus , sparet2.usec),
offsetof(repStatus , flags),
offsetof(repStatus , volStates),
offsetof(repStatus , curAggr),
offsetof(repStatus , srcAggr),
offsetof(repStatus , numKAs),
offsetof(repStatus , numVolChanged),
offsetof(repStatus , volChangedOldestTimeUsed),
offsetof(repStatus , nextVolChangedTime),
offsetof(repStatus , sparel1),
offsetof(repStatus , sparel2),
offsetof(repStatus , sparel3),
offsetof(repStatus , msgTag),
offsetof(repStatus , msgLength),
offsetof(repStatus , volName),
offsetof(repStatus , RepMsg),
sizeof(fidsInVol ),
offsetof(fidsInVol , fidsInVol_len),
offsetof(fidsInVol , fidsInVol_val),
sizeof(fidInVol ),
offsetof(fidInVol , Vnode),
offsetof(fidInVol , Unique),
sizeof(afsFids ),
offsetof(afsFids , afsFids_len),
offsetof(afsFids , afsFids_val),
sizeof(afsFid ),
offsetof(afsFid , Cell),
offsetof(afsFid , Volume),
offsetof(afsFid , Vnode),
offsetof(afsFid , Unique),
sizeof(afsNetAddrs ),
offsetof(afsNetAddrs , afsNetAddrs_len),
offsetof(afsNetAddrs , afsNetAddrs_val),
sizeof(afsNetAddr ),
offsetof(afsNetAddr , type),
offsetof(afsNetAddr , data),
(idl_ulong_int)sizeof(afs_hyper_t),
sizeof(afsHyper ),
offsetof(afsHyper , high),
offsetof(afsHyper , low),
0
};

static IDL_rtn_func_t IDL_rtn_vec[] = {
(IDL_rtn_func_t)NULL,
(IDL_rtn_func_t)afsHyper_from_local,
(IDL_rtn_func_t)afsHyper_to_local,
(IDL_rtn_func_t)afsHyper_free_local,
(IDL_rtn_func_t)afsHyper_free_inst,
(IDL_rtn_func_t)NULL
};

static idl_byte IDL_type_vec[] = {
0xff,0xff,0xff,0xff,
0,
0,
0xff,0xff,
0x00,0x03,
0x00,0x02,
0x00,0x04,
0x00,0x00,
0x4d,0x37,0xf2,0xdd,
0xed,0x43,
0x00,0x05,
0x02,
0xc0,
0x37,0xcf,0x1e,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x04,
0x00,0x00,0x07,0xf4,
0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,
0x00,0x00,0x00,0x0a,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0a,
0x00,0x00,0x00,0x06,
0x00,0x00,0x01,0x30,
0x00,0x00,0x00,0x05,
0x00,0x00,0x01,0x70,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0c,
0x00,0x00,0x00,0x08,
0x00,0x00,0x01,0xa8,
0x00,0x00,0x00,0x05,
0x00,0x00,0x02,0x00,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0a,
0x00,0x00,0x00,0x06,
0x00,0x00,0x02,0x38,
0x00,0x00,0x00,0x03,
0x00,0x00,0x02,0x70,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x11,
0x00,0x00,0x00,0x08,
0x00,0x00,0x02,0x88,
0x00,0x00,0x00,0x0c,
0x00,0x00,0x02,0xe8,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0c,
0x00,0x00,0x00,0x04,
0x00,0x00,0x03,0x78,
0x00,0x00,0x00,0x07,
0x00,0x00,0x03,0x98,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x08,
0x00,0x00,0x00,0x03,
0x00,0x00,0x03,0xd8,
0x00,0x00,0x00,0x04,
0x00,0x00,0x03,0xf0,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0a,
0x00,0x00,0x00,0x06,
0x00,0x00,0x04,0x18,
0x00,0x00,0x00,0x05,
0x00,0x00,0x04,0x58,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x02,
0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,
0x00,0x00,0x00,0x01,
0x00,0x00,0x04,0x90,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0b,
0x00,0x00,0x00,0x05,
0x00,0x00,0x04,0x98,
0x00,0x00,0x00,0x07,
0x00,0x00,0x04,0xd0,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x03,
0x00,0x00,0x00,0x01,
0x00,0x00,0x05,0x20,
0x00,0x00,0x00,0x02,
0x00,0x00,0x05,0x20,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x38,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x38,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x09,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x38,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x38,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x48,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x09,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x0a,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x5c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x09,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x38,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x38,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x38,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x38,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x09,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x0a,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x38,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x0c,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x70,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x0d,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x0e,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x0f,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x10,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x84,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x09,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x0a,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x0b,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x98,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x38,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x38,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x09,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x38,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x38,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x06,0x6c,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x09,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x0a,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0xcc,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x7b,
0x00,0x00,0x00,0x01,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x07,0xec,
0x00,0x00,0x00,0x75,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_VARYING_ARRAY,
0|IDL_PROP_DEP_INT,
0x00,0x00,0x07,0xab,
0x00,0x00,0x07,0xab,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x6d,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_VARYING_ARRAY,
0|IDL_PROP_DEP_INT,
0x00,0x00,0x07,0x73,
0x00,0x00,0x07,0x73,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x67,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_VARYING_ARRAY,
0|IDL_PROP_DEP_INT,
0x00,0x00,0x07,0x47,
0x00,0x00,0x07,0x47,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x35,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_VARYING_ARRAY,
0|IDL_PROP_DEP_INT,
0x00,0x00,0x06,0x4b,
0x00,0x00,0x06,0x4b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x19,
IDL_DT_NDR_ALIGN_4,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0x00,0x00,0x05,0x38,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0x00,0x00,0x05,0x38,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x01,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_VARYING_ARRAY,
0|IDL_PROP_DEP_INT,
0x00,0x00,0x05,0xdf,
0x00,0x00,0x05,0xdf,
IDL_DT_EOL,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x09,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_LENGTH_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x01,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,0xff,
0x00,0x00,0x06,0x00,
0x00,0x00,0x00,0x04,
IDL_DT_NDR_ALIGN_4,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_USHORT,
IDL_DT_USHORT,
IDL_DT_USMALL,
IDL_DT_USMALL,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x06,0x3f,
0x00,0x00,0x06,0x3f,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_USHORT,
IDL_DT_USHORT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0,
0x00,0x00,0x06,0x33,
0x00,0x00,0x06,0x33,
IDL_DT_EOL,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x31,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x05,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x09,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_LENGTH_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x01,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x06,0x6c,
0x00,0x00,0x00,0x38,
IDL_DT_NDR_ALIGN_4,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x38,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x05,0x38,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x05,0x38,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x05,0x38,
IDL_DT_NDR_ALIGN_2,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_USHORT,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,0xff,
0x00,0x00,0x07,0x3b,
0x00,0x00,0x07,0x3b,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x38,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x05,0x38,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x05,0x38,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x05,0x38,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x05,0x38,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,0xff,
0x00,0x00,0x07,0x2f,
0x00,0x00,0x07,0x2f,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x07,0x23,
0x00,0x00,0x07,0x23,
IDL_DT_EOL,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x01,0x8f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x6f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0d,
IDL_DT_USMALL,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x31,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_LENGTH_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x01,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,0xff,
0x00,0x00,0x07,0x68,
0x00,0x00,0x00,0x6a,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1f,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_LENGTH_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x01,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x07,0x94,
0x00,0x00,0x00,0x70,
IDL_DT_NDR_ALIGN_4,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x38,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x05,0x38,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_EOL,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x1d,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_LENGTH_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x01,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,0xff,
0x00,0x00,0x07,0xcc,
0x00,0x00,0x00,0x78,
IDL_DT_NDR_ALIGN_2,
IDL_DT_USHORT,
IDL_DT_FIXED_ARRAY,
0,
0x00,0x00,0x07,0xdf,
0x00,0x00,0x07,0xdf,
IDL_DT_EOL,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0d,
IDL_DT_USMALL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x7c,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_EOL,
0x00,0x00,0x00,0x10,
0
};


error_status_t REP_CheckReplicationConfig
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *cellIdP,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *volIdP,
    /* [in] */ unsigned32 flags,
    /* [in] */ unsigned32 spare1,
    /* [in] */ unsigned32 spare2,
    /* [in] */ unsigned32 spare3,
    /* [out] */ unsigned32 *spare4,
    /* [out] */ unsigned32 *spare5
)
#else
(h, cellIdP, volIdP, flags, spare1, spare2, spare3, spare4, spare5)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    /* Type must appear in user header or IDL */ afs_hyper_t *cellIdP;
    /* Type must appear in user header or IDL */ afs_hyper_t *volIdP;
    unsigned32 flags;
    unsigned32 spare1;
    unsigned32 spare2;
    unsigned32 spare3;
    unsigned32 *spare4;
    unsigned32 *spare5;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[10];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)cellIdP;
IDL_param_vec[3] = (rpc_void_p_t)volIdP;
IDL_param_vec[4] = (rpc_void_p_t)&flags;
IDL_param_vec[5] = (rpc_void_p_t)&spare1;
IDL_param_vec[6] = (rpc_void_p_t)&spare2;
IDL_param_vec[7] = (rpc_void_p_t)&spare3;
IDL_param_vec[8] = (rpc_void_p_t)spare4;
IDL_param_vec[9] = (rpc_void_p_t)spare5;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,0,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    6,
    304,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    5,
    368,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t REP_AllCheckReplicationConfig
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *cellIdP,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *volIdP,
    /* [in] */ unsigned32 howManyGuys,
    /* [in] */ afsNetAddrs *TheseGuysToo,
    /* [in] */ unsigned32 flags,
    /* [in] */ unsigned32 spare1,
    /* [in] */ unsigned32 spare2,
    /* [in] */ unsigned32 spare3,
    /* [out] */ unsigned32 *spare4,
    /* [out] */ unsigned32 *spare5
)
#else
(h, cellIdP, volIdP, howManyGuys, TheseGuysToo, flags, spare1, spare2, spare3, spare4, spare5)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    /* Type must appear in user header or IDL */ afs_hyper_t *cellIdP;
    /* Type must appear in user header or IDL */ afs_hyper_t *volIdP;
    unsigned32 howManyGuys;
    afsNetAddrs *TheseGuysToo;
    unsigned32 flags;
    unsigned32 spare1;
    unsigned32 spare2;
    unsigned32 spare3;
    unsigned32 *spare4;
    unsigned32 *spare5;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[12];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)cellIdP;
IDL_param_vec[3] = (rpc_void_p_t)volIdP;
IDL_param_vec[4] = (rpc_void_p_t)&howManyGuys;
IDL_param_vec[5] = (rpc_void_p_t)TheseGuysToo;
IDL_param_vec[6] = (rpc_void_p_t)&flags;
IDL_param_vec[7] = (rpc_void_p_t)&spare1;
IDL_param_vec[8] = (rpc_void_p_t)&spare2;
IDL_param_vec[9] = (rpc_void_p_t)&spare3;
IDL_param_vec[10] = (rpc_void_p_t)spare4;
IDL_param_vec[11] = (rpc_void_p_t)spare5;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,1,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    8,
    424,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    5,
    512,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t REP_KeepFilesAlive
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsFids *files,
    /* [in] */ unsigned32 howManyFiles,
    /* [in] */ unsigned32 flags,
    /* [in] */ unsigned32 spare1,
    /* [in] */ unsigned32 spare2,
    /* [in] */ unsigned32 spare3,
    /* [out] */ unsigned32 *spare4,
    /* [out] */ unsigned32 *spare5
)
#else
(h, files, howManyFiles, flags, spare1, spare2, spare3, spare4, spare5)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsFids *files;
    unsigned32 howManyFiles;
    unsigned32 flags;
    unsigned32 spare1;
    unsigned32 spare2;
    unsigned32 spare3;
    unsigned32 *spare4;
    unsigned32 *spare5;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[10];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)files;
IDL_param_vec[3] = (rpc_void_p_t)&howManyFiles;
IDL_param_vec[4] = (rpc_void_p_t)&flags;
IDL_param_vec[5] = (rpc_void_p_t)&spare1;
IDL_param_vec[6] = (rpc_void_p_t)&spare2;
IDL_param_vec[7] = (rpc_void_p_t)&spare3;
IDL_param_vec[8] = (rpc_void_p_t)spare4;
IDL_param_vec[9] = (rpc_void_p_t)spare5;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,2,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    6,
    568,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    3,
    624,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t REP_GetVolChangedFiles
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *cellIdP,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *volIdP,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *initialVV,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *finalVV,
    /* [in] */ unsigned32 cookie,
    /* [in] */ unsigned32 spare1,
    /* [in] */ unsigned32 spare2,
    /* [in] */ unsigned32 spare3,
    /* [out] */ /* Type must appear in user header or IDL */ afs_hyper_t *reallyFinalVV,
    /* [out] */ unsigned32 *nextCookieP,
    /* [out] */ fidsInVol *fidPerVolP,
    /* [out] */ unsigned32 *numFidsInVolP,
    /* [out] */ unsigned32 *flagsP,
    /* [out] */ unsigned32 *spare4,
    /* [out] */ unsigned32 *spare5
)
#else
(h, cellIdP, volIdP, initialVV, finalVV, cookie, spare1, spare2, spare3, reallyFinalVV, nextCookieP, fidPerVolP, numFidsInVolP, flagsP, spare4, spare5)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    /* Type must appear in user header or IDL */ afs_hyper_t *cellIdP;
    /* Type must appear in user header or IDL */ afs_hyper_t *volIdP;
    /* Type must appear in user header or IDL */ afs_hyper_t *initialVV;
    /* Type must appear in user header or IDL */ afs_hyper_t *finalVV;
    unsigned32 cookie;
    unsigned32 spare1;
    unsigned32 spare2;
    unsigned32 spare3;
    /* Type must appear in user header or IDL */ afs_hyper_t *reallyFinalVV;
    unsigned32 *nextCookieP;
    fidsInVol *fidPerVolP;
    unsigned32 *numFidsInVolP;
    unsigned32 *flagsP;
    unsigned32 *spare4;
    unsigned32 *spare5;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[17];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)cellIdP;
IDL_param_vec[3] = (rpc_void_p_t)volIdP;
IDL_param_vec[4] = (rpc_void_p_t)initialVV;
IDL_param_vec[5] = (rpc_void_p_t)finalVV;
IDL_param_vec[6] = (rpc_void_p_t)&cookie;
IDL_param_vec[7] = (rpc_void_p_t)&spare1;
IDL_param_vec[8] = (rpc_void_p_t)&spare2;
IDL_param_vec[9] = (rpc_void_p_t)&spare3;
IDL_param_vec[10] = (rpc_void_p_t)reallyFinalVV;
IDL_param_vec[11] = (rpc_void_p_t)nextCookieP;
IDL_param_vec[12] = (rpc_void_p_t)fidPerVolP;
IDL_param_vec[13] = (rpc_void_p_t)numFidsInVolP;
IDL_param_vec[14] = (rpc_void_p_t)flagsP;
IDL_param_vec[15] = (rpc_void_p_t)spare4;
IDL_param_vec[16] = (rpc_void_p_t)spare5;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,3,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    8,
    648,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    12,
    744,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t REP_GetRepStatus
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ unsigned32 cookie,
    /* [in] */ unsigned32 spare1,
    /* [in] */ unsigned32 spare2,
    /* [in] */ unsigned32 spare3,
    /* [out] */ unsigned32 *nextCookieP,
    /* [out] */ repStatuses *StatusesP,
    /* [out] */ unsigned32 *howManyStatuses,
    /* [out] */ unsigned32 *flagsP,
    /* [out] */ unsigned32 *spare4,
    /* [out] */ unsigned32 *spare5
)
#else
(h, cookie, spare1, spare2, spare3, nextCookieP, StatusesP, howManyStatuses, flagsP, spare4, spare5)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    unsigned32 cookie;
    unsigned32 spare1;
    unsigned32 spare2;
    unsigned32 spare3;
    unsigned32 *nextCookieP;
    repStatuses *StatusesP;
    unsigned32 *howManyStatuses;
    unsigned32 *flagsP;
    unsigned32 *spare4;
    unsigned32 *spare5;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[12];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)&cookie;
IDL_param_vec[3] = (rpc_void_p_t)&spare1;
IDL_param_vec[4] = (rpc_void_p_t)&spare2;
IDL_param_vec[5] = (rpc_void_p_t)&spare3;
IDL_param_vec[6] = (rpc_void_p_t)nextCookieP;
IDL_param_vec[7] = (rpc_void_p_t)StatusesP;
IDL_param_vec[8] = (rpc_void_p_t)howManyStatuses;
IDL_param_vec[9] = (rpc_void_p_t)flagsP;
IDL_param_vec[10] = (rpc_void_p_t)spare4;
IDL_param_vec[11] = (rpc_void_p_t)spare5;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,4,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    4,
    888,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    7,
    920,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t REP_GetRepServerStatus
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ unsigned32 spare1,
    /* [in] */ unsigned32 spare2,
    /* [in] */ unsigned32 spare3,
    /* [out] */ repserverStatus *repserverStat,
    /* [out] */ unsigned32 *spare4,
    /* [out] */ unsigned32 *spare5
)
#else
(h, spare1, spare2, spare3, repserverStat, spare4, spare5)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    unsigned32 spare1;
    unsigned32 spare2;
    unsigned32 spare3;
    repserverStatus *repserverStat;
    unsigned32 *spare4;
    unsigned32 *spare5;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[8];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)&spare1;
IDL_param_vec[3] = (rpc_void_p_t)&spare2;
IDL_param_vec[4] = (rpc_void_p_t)&spare3;
IDL_param_vec[5] = (rpc_void_p_t)repserverStat;
IDL_param_vec[6] = (rpc_void_p_t)spare4;
IDL_param_vec[7] = (rpc_void_p_t)spare5;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,5,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    3,
    984,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    4,
    1008,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t REP_UpdateSelf
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *cellIdP,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *volIdP,
    /* [in] */ unsigned32 flags,
    /* [in] */ unsigned32 spare1,
    /* [in] */ unsigned32 spare2,
    /* [in] */ unsigned32 spare3,
    /* [out] */ unsigned32 *spare4,
    /* [out] */ unsigned32 *spare5
)
#else
(h, cellIdP, volIdP, flags, spare1, spare2, spare3, spare4, spare5)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    /* Type must appear in user header or IDL */ afs_hyper_t *cellIdP;
    /* Type must appear in user header or IDL */ afs_hyper_t *volIdP;
    unsigned32 flags;
    unsigned32 spare1;
    unsigned32 spare2;
    unsigned32 spare3;
    unsigned32 *spare4;
    unsigned32 *spare5;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[10];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)cellIdP;
IDL_param_vec[3] = (rpc_void_p_t)volIdP;
IDL_param_vec[4] = (rpc_void_p_t)&flags;
IDL_param_vec[5] = (rpc_void_p_t)&spare1;
IDL_param_vec[6] = (rpc_void_p_t)&spare2;
IDL_param_vec[7] = (rpc_void_p_t)&spare3;
IDL_param_vec[8] = (rpc_void_p_t)spare4;
IDL_param_vec[9] = (rpc_void_p_t)spare5;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,6,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    6,
    1048,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    5,
    1112,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t REP_Probe
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h
)
#else
(h)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[2];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,7,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    0,
    0,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    1,
    1168,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t REP_GetOneRepStatus
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *cellIdP,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *volIdP,
    /* [in] */ unsigned32 spare1,
    /* [in] */ unsigned32 spare2,
    /* [in] */ unsigned32 spare3,
    /* [out] */ repStatus *StatusP,
    /* [out] */ unsigned32 *flagsP,
    /* [out] */ unsigned32 *spare4,
    /* [out] */ unsigned32 *spare5
)
#else
(h, cellIdP, volIdP, spare1, spare2, spare3, StatusP, flagsP, spare4, spare5)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    /* Type must appear in user header or IDL */ afs_hyper_t *cellIdP;
    /* Type must appear in user header or IDL */ afs_hyper_t *volIdP;
    unsigned32 spare1;
    unsigned32 spare2;
    unsigned32 spare3;
    repStatus *StatusP;
    unsigned32 *flagsP;
    unsigned32 *spare4;
    unsigned32 *spare5;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[11];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)cellIdP;
IDL_param_vec[3] = (rpc_void_p_t)volIdP;
IDL_param_vec[4] = (rpc_void_p_t)&spare1;
IDL_param_vec[5] = (rpc_void_p_t)&spare2;
IDL_param_vec[6] = (rpc_void_p_t)&spare3;
IDL_param_vec[7] = (rpc_void_p_t)StatusP;
IDL_param_vec[8] = (rpc_void_p_t)flagsP;
IDL_param_vec[9] = (rpc_void_p_t)spare4;
IDL_param_vec[10] = (rpc_void_p_t)spare5;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,8,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    5,
    1176,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    7,
    1232,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t REP_GetServerInterfaces
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in, out] */ dfs_interfaceList *serverInterfacesP
)
#else
(h, serverInterfacesP)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    dfs_interfaceList *serverInterfacesP;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[3];
error_status_t IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)serverInterfacesP;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,9,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    1,
    1312,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    2,
    1312,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_ms.IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}
#ifdef VMS
#pragma standard
#endif
