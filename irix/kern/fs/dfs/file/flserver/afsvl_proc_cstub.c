/*
 * @OSF_COPYRIGHT@
 * COPYRIGHT NOTICE
 * Copyright (c) 1990, 1991, 1992, 1993, 1994 Open Software Foundation, Inc.
 * ALL RIGHTS RESERVED (DCE).  See the file named COPYRIGHT.DCE for
 * the full copyright text.
 */
/*
 * HISTORY
 * $Log: afsvl_proc_cstub.c,v $
 * Revision 65.2  1999/02/05 16:54:30  mek
 * Cleanup build warnings for IRIX kernel integration.
 *
 * Revision 65.1  1997/10/20 19:20:06  jdoak
 * *** empty log message ***
 *
 * Revision 1.1.40.1  1996/10/02  17:45:47  damon
 * 	Newest DFS from Transarc
 * 	[1996/10/01  18:36:50  damon]
 *
 * Revision 1.1.35.2  1994/06/09  14:06:49  annie
 * 	fixed copyright in src/file
 * 	[1994/06/09  13:22:06  annie]
 * 
 * Revision 1.1.35.1  1994/02/04  20:17:50  devsrc
 * 	Merged from 1.0.3a to 1.1
 * 	[1994/02/04  15:12:37  devsrc]
 * 
 * Revision 1.1.33.1  1993/12/07  17:23:28  jaffe
 * 	1.0.3a update from Transarc
 * 	[1993/12/03  15:15:25  jaffe]
 * 
 * Revision 1.1.2.5  1993/01/21  19:33:38  zeliff
 * 	Embedding copyright notices
 * 	[1993/01/19  19:47:08  zeliff]
 * 
 * Revision 1.1.2.4  1992/11/24  17:01:26  bolinger
 * 	Change include file install directory from .../afs to .../dcedfs.
 * 	[1992/11/22  17:56:22  bolinger]
 * 
 * Revision 1.1.2.3  1992/11/18  19:43:09  jaffe
 * 	Transarc delta: kazar-ot5247-use-nocode-for-unused-flserver-calls 1.1
 * 	  Selected comments:
 * 	    add [nocode] to afsvl interface calls that aren't used.  reduced kernel size
 * 	    by 30K on the RIOS.
 * 	    add nocode switch
 * 	[1992/11/17  21:35:38  jaffe]
 * 
 * Revision 1.1.2.2  1992/09/15  13:12:17  jaffe
 * 	Transarc delta: vijay-ot4824-multiple-ubik-servers-fail-to-startup 1.3
 * 	  Selected comments:
 * 
 * 	    Problems were detected when multiple ubik servers were started up in a cell.
 * 	    This delta attempts to fix these bugs that prevent multiple ubik servers
 * 	    from running in a cell. Problems fixed are
 * 	    1. a hang in sec_id_parse_name was eliminated by removing unnecessary
 * 	    global locks (pthread_lock_global_np)
 * 	    2. ubik_Call routine cleaned up to handle all error cases. flserver RPC
 * 	    interface had to be changed to return the communication status as a
 * 	    return value instead of as a parameter.
 * 	    3. An error code was not returned if an invalid group is passed to ubik_
 * 	    ServerInit.
 * 	    Any other bugs noticed will be added to this delta. Not ready for release yet,
 * 	    upgrading before further changes are added.
 * 	    comm status as a return value instead of as a parameter
 * 	    After the upgrade, made changes to CM, PX, REP and fixed some typos in
 * 	    flserver and ubik. The changes are mainly to follow the new VL_ RPC
 * 	    signature.
 * 	    cleaned up bad merge.
 * 	[1992/09/14  19:34:58  jaffe]
 * 
 * Revision 1.1  1992/01/19  02:48:44  devrcs
 * 	Initial revision
 * 
 * $EndLog$
 */

/* Generated by IDL compiler version OSF DCE T1.2.0-09 */
#ifdef VMS
#pragma nostandard
#endif
#include <dce/idlddefs.h>
#include <afsvl_proc.h>

static rpc_syntax_id_t IDL_transfer_syntaxes[1] = {
{
{0x8a885d04u, 0x1ceb, 0x11c9, 0x9f, 0xe8, {0x8, 0x0, 0x2b, 0x10, 0x48, 0x60}},
2}};

static rpc_if_rep_t IDL_ifspec = {
  1, /* ifspec rep version */
  13, /* op count */
  4, /* if version */
  {0x4d37f2ddu, 0xed43, 0x0000, 0x02, 0xc0, {0x37, 0xcf, 0x2e, 0x0, 0x0, 0x1}},
  2, /* stub/rt if version */
  {0, NULL}, /* endpoint vector */
  {1, IDL_transfer_syntaxes} /* syntax vector */
};
/* global */ rpc_if_handle_t VL__v4_0_c_ifspec = (rpc_if_handle_t)&IDL_ifspec;
static idl_ulong_int IDL_offset_vec[] = {
0,
sizeof(dfs_interfaceList ),
offsetof(dfs_interfaceList , dfs_interfaceList_len),
offsetof(dfs_interfaceList , dfs_interfaceList_val),
sizeof(dfs_interfaceDescription ),
offsetof(dfs_interfaceDescription , interface_uuid.time_low),
offsetof(dfs_interfaceDescription , interface_uuid.time_mid),
offsetof(dfs_interfaceDescription , interface_uuid.time_hi_and_version),
offsetof(dfs_interfaceDescription , interface_uuid.clock_seq_hi_and_reserved),
offsetof(dfs_interfaceDescription , interface_uuid.clock_seq_low),
offsetof(dfs_interfaceDescription , interface_uuid.node),
offsetof(dfs_interfaceDescription , vers_major),
offsetof(dfs_interfaceDescription , vers_minor),
offsetof(dfs_interfaceDescription , vers_provider),
offsetof(dfs_interfaceDescription , spare0),
offsetof(dfs_interfaceDescription , spare1),
offsetof(dfs_interfaceDescription , spare2),
offsetof(dfs_interfaceDescription , spare3),
offsetof(dfs_interfaceDescription , spare4),
offsetof(dfs_interfaceDescription , spare5),
offsetof(dfs_interfaceDescription , spare6),
offsetof(dfs_interfaceDescription , spare7),
offsetof(dfs_interfaceDescription , spare8),
offsetof(dfs_interfaceDescription , spare9),
offsetof(dfs_interfaceDescription , spareText),
sizeof(compactvldbentry ),
offsetof(compactvldbentry , name),
offsetof(compactvldbentry , volumeType),
offsetof(compactvldbentry , nServers),
offsetof(compactvldbentry , siteCookies),
offsetof(compactvldbentry , sitePartition),
offsetof(compactvldbentry , siteFlags),
offsetof(compactvldbentry , sitemaxReplicaLatency),
offsetof(compactvldbentry , VolIDs),
offsetof(compactvldbentry , VolTypes),
offsetof(compactvldbentry , cloneId),
offsetof(compactvldbentry , flags),
offsetof(compactvldbentry , maxTotalLatency),
offsetof(compactvldbentry , hardMaxTotalLatency),
offsetof(compactvldbentry , minimumPounceDally),
offsetof(compactvldbentry , defaultMaxReplicaLatency),
offsetof(compactvldbentry , reclaimDally),
offsetof(compactvldbentry , WhenLocked),
offsetof(compactvldbentry , spare1),
offsetof(compactvldbentry , spare2),
offsetof(compactvldbentry , spare3),
offsetof(compactvldbentry , spare4),
offsetof(compactvldbentry , LockerName),
offsetof(compactvldbentry , charSpares),
sizeof(siteDesc ),
offsetof(siteDesc , Addr),
offsetof(siteDesc , KerbPrin),
offsetof(siteDesc , Owner.time_low),
offsetof(siteDesc , Owner.time_mid),
offsetof(siteDesc , Owner.time_hi_and_version),
offsetof(siteDesc , Owner.clock_seq_hi_and_reserved),
offsetof(siteDesc , Owner.clock_seq_low),
offsetof(siteDesc , Owner.node),
offsetof(siteDesc , ObjID.time_low),
offsetof(siteDesc , ObjID.time_mid),
offsetof(siteDesc , ObjID.time_hi_and_version),
offsetof(siteDesc , ObjID.clock_seq_hi_and_reserved),
offsetof(siteDesc , ObjID.clock_seq_low),
offsetof(siteDesc , ObjID.node),
offsetof(siteDesc , CreationQuota),
offsetof(siteDesc , CreationUses),
offsetof(siteDesc , DeletedFlag),
offsetof(siteDesc , spare2),
offsetof(siteDesc , spare3),
offsetof(siteDesc , spare4),
offsetof(siteDesc , spare5),
sizeof(vlconf_cell ),
offsetof(vlconf_cell , name),
offsetof(vlconf_cell , CellID),
offsetof(vlconf_cell , numServers),
offsetof(vlconf_cell , hostAddr),
offsetof(vlconf_cell , hostName),
offsetof(vlconf_cell , spare1),
offsetof(vlconf_cell , spare2),
offsetof(vlconf_cell , spare3),
offsetof(vlconf_cell , spare4),
offsetof(vlconf_cell , spare5),
sizeof(hostnam ),
offsetof(hostnam , hstnam),
sizeof(vldbentry ),
offsetof(vldbentry , name),
offsetof(vldbentry , volumeType),
offsetof(vldbentry , nServers),
offsetof(vldbentry , siteAddr),
offsetof(vldbentry , sitePartition),
offsetof(vldbentry , siteFlags),
offsetof(vldbentry , sitemaxReplicaLatency),
offsetof(vldbentry , sitePrincipal),
offsetof(vldbentry , siteOwner),
offsetof(vldbentry , siteObjID),
offsetof(vldbentry , VolIDs),
offsetof(vldbentry , VolTypes),
offsetof(vldbentry , cloneId),
offsetof(vldbentry , flags),
offsetof(vldbentry , maxTotalLatency),
offsetof(vldbentry , hardMaxTotalLatency),
offsetof(vldbentry , minimumPounceDally),
offsetof(vldbentry , defaultMaxReplicaLatency),
offsetof(vldbentry , reclaimDally),
offsetof(vldbentry , WhenLocked),
offsetof(vldbentry , spare1),
offsetof(vldbentry , spare2),
offsetof(vldbentry , spare3),
offsetof(vldbentry , spare4),
offsetof(vldbentry , LockerName),
offsetof(vldbentry , charSpares),
sizeof(afsUUID ),
offsetof(afsUUID , time_low),
offsetof(afsUUID , time_mid),
offsetof(afsUUID , time_hi_and_version),
offsetof(afsUUID , clock_seq_hi_and_reserved),
offsetof(afsUUID , clock_seq_low),
offsetof(afsUUID , node),
sizeof(kerb_princ_name ),
offsetof(kerb_princ_name , text),
sizeof(afsNetAddr ),
offsetof(afsNetAddr , type),
offsetof(afsNetAddr , data),
(idl_ulong_int)sizeof(afs_hyper_t),
sizeof(afsHyper ),
offsetof(afsHyper , high),
offsetof(afsHyper , low),
0
};

static IDL_rtn_func_t IDL_rtn_vec[] = {
(IDL_rtn_func_t)NULL,
(IDL_rtn_func_t)afsHyper_from_local,
(IDL_rtn_func_t)afsHyper_to_local,
(IDL_rtn_func_t)afsHyper_free_local,
(IDL_rtn_func_t)afsHyper_free_inst,
(IDL_rtn_func_t)NULL
};

static idl_byte IDL_type_vec[] = {
0xff,0xff,0xff,0xff,
0,
0,
0xff,0xff,
0x00,0x03,
0x00,0x02,
0x00,0x04,
0x00,0x00,
0x4d,0x37,0xf2,0xdd,
0xed,0x43,
0x00,0x00,
0x02,
0xc0,
0x37,0xcf,0x2e,0x00,0x00,0x01,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x04,
0x00,0x00,0x08,0xd8,
0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,
0x00,0x00,0x00,0x0d,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x05,
0x00,0x00,0x00,0x02,
0x00,0x00,0x01,0x78,
0x00,0x00,0x00,0x03,
0x00,0x00,0x01,0x90,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x04,
0x00,0x00,0x00,0x01,
0x00,0x00,0x01,0xb8,
0x00,0x00,0x00,0x02,
0x00,0x00,0x01,0xcc,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x02,
0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,
0x00,0x00,0x00,0x01,
0x00,0x00,0x01,0xe4,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x03,
0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,
0x00,0x00,0x00,0x02,
0x00,0x00,0x01,0xec,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x08,
0x00,0x00,0x00,0x03,
0x00,0x00,0x02,0x04,
0x00,0x00,0x00,0x05,
0x00,0x00,0x02,0x24,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x07,
0x00,0x00,0x00,0x02,
0x00,0x00,0x02,0x5c,
0x00,0x00,0x00,0x04,
0x00,0x00,0x02,0x78,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x04,
0x00,0x00,0x00,0x01,
0x00,0x00,0x02,0xa0,
0x00,0x00,0x00,0x02,
0x00,0x00,0x02,0xb0,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x05,
0x00,0x00,0x00,0x02,
0x00,0x00,0x02,0xc8,
0x00,0x00,0x00,0x03,
0x00,0x00,0x02,0xe0,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x04,
0x00,0x00,0x00,0x01,
0x00,0x00,0x03,0x08,
0x00,0x00,0x00,0x02,
0x00,0x00,0x03,0x1c,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x08,
0x00,0x00,0x00,0x03,
0x00,0x00,0x03,0x34,
0x00,0x00,0x00,0x05,
0x00,0x00,0x03,0x54,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x07,
0x00,0x00,0x00,0x02,
0x00,0x00,0x03,0x8c,
0x00,0x00,0x00,0x04,
0x00,0x00,0x03,0xa8,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x04,
0x00,0x00,0x00,0x01,
0x00,0x00,0x03,0xd0,
0x00,0x00,0x00,0x02,
0x00,0x00,0x03,0xd8,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x03,
0x00,0x00,0x00,0x01,
0x00,0x00,0x03,0xf0,
0x00,0x00,0x00,0x02,
0x00,0x00,0x03,0xf0,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x04,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x04,0x18,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_STRING,
IDL_DT_VARYING_ARRAY,
0,
0x00,0x00,0x04,0xc3,
0x00,0x00,0x04,0xc3,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x04,0x18,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x04,0xe0,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x04,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x06,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x04,0x18,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_STRING,
IDL_DT_VARYING_ARRAY,
0,
0x00,0x00,0x05,0x17,
0x00,0x00,0x05,0x17,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x04,0x18,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,
0x00,0x00,0x08,0xa4,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,
0x00,0x00,0x05,0x34,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x04,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x84,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_STRING,
IDL_DT_VARYING_ARRAY,
0,
0x00,0x00,0x06,0x0b,
0x00,0x00,0x06,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x84,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x04,0x08,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x06,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x84,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FREE_REP,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_STRING,
IDL_DT_VARYING_ARRAY,
0,
0x00,0x00,0x06,0x27,
0x00,0x00,0x06,0x27,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x05,0x84,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,
0x00,0x00,0x05,0x34,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x06,0x44,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x7b,
0x00,0x00,0x00,0x01,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x08,0xd0,
0x00,0x00,0x00,0x54,
IDL_DT_NDR_ALIGN_4,
IDL_DT_FIXED_ARRAY,
0,
0xff,
0x00,0x00,0x08,0xc3,
0x00,0x00,0x08,0xc3,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0|IDL_PROP_DEP_INT,
0x00,0x00,0x08,0x93,
0x00,0x00,0x08,0x93,
IDL_DT_FIXED_ARRAY,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x08,0x87,
0x00,0x00,0x08,0x87,
IDL_DT_FIXED_ARRAY,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x08,0x7b,
0x00,0x00,0x08,0x7b,
IDL_DT_FIXED_ARRAY,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x08,0x6f,
0x00,0x00,0x08,0x6f,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x08,0x3f,
0x00,0x00,0x08,0x3f,
IDL_DT_FIXED_ARRAY,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x08,0x0b,
0x00,0x00,0x08,0x0b,
IDL_DT_FIXED_ARRAY,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x07,0xf7,
0x00,0x00,0x07,0xf7,
IDL_DT_FIXED_ARRAY,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x07,0xe3,
0x00,0x00,0x07,0xe3,
IDL_DT_FIXED_ARRAY,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x07,0xd7,
0x00,0x00,0x07,0xd7,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x04,0x08,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,0xff,
0x00,0x00,0x07,0xcb,
0x00,0x00,0x07,0xcb,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x07,0xbf,
0x00,0x00,0x07,0xbf,
IDL_DT_EOL,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x6f,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_STRING,
1,
0xff,0xff,
0x00,0x00,0x00,0xff,
IDL_DT_BYTE,
0xff,0xff,0xff,
0x00,0x00,0x00,0x47,
IDL_DT_NDR_ALIGN_4,
IDL_DT_FIXED_ARRAY,
0,
0xff,
0x00,0x00,0x07,0xb3,
0x00,0x00,0x07,0xb3,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x04,0x08,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x07,0x9f,
0x00,0x00,0x07,0x9f,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x07,0x6f,
0x00,0x00,0x07,0x6f,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x6f,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_STRING,
1,
0xff,0xff,
0x00,0x00,0x00,0xff,
IDL_DT_BYTE,
0xff,0xff,0xff,
0x00,0x00,0x00,0x31,
IDL_DT_NDR_ALIGN_4,
IDL_DT_FIXED_ARRAY,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x07,0x5b,
0x00,0x00,0x07,0x5b,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x07,0x4f,
0x00,0x00,0x07,0x4f,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_USHORT,
IDL_DT_USHORT,
IDL_DT_USMALL,
IDL_DT_USMALL,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,0xff,
0x00,0x00,0x07,0x43,
0x00,0x00,0x07,0x43,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_USHORT,
IDL_DT_USHORT,
IDL_DT_USMALL,
IDL_DT_USMALL,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x07,0x37,
0x00,0x00,0x07,0x37,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x19,
IDL_DT_NDR_ALIGN_4,
IDL_DT_FIXED_ARRAY,
0,
0xff,
0x00,0x00,0x07,0x2b,
0x00,0x00,0x07,0x2b,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0|IDL_PROP_DEP_INT,
0x00,0x00,0x07,0x1f,
0x00,0x00,0x07,0x1f,
IDL_DT_FIXED_ARRAY,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x07,0x13,
0x00,0x00,0x07,0x13,
IDL_DT_FIXED_ARRAY,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x07,0x07,
0x00,0x00,0x07,0x07,
IDL_DT_FIXED_ARRAY,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x06,0xfb,
0x00,0x00,0x06,0xfb,
IDL_DT_FIXED_ARRAY,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x06,0xe7,
0x00,0x00,0x06,0xe7,
IDL_DT_FIXED_ARRAY,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x06,0xdb,
0x00,0x00,0x06,0xdb,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x04,0x08,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,0xff,
0x00,0x00,0x06,0xcf,
0x00,0x00,0x06,0xcf,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x06,0xc3,
0x00,0x00,0x06,0xc3,
IDL_DT_EOL,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x6f,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_STRING,
1,
0xff,0xff,
0x00,0x00,0x00,0xff,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x6f,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_STRING,
1,
0xff,0xff,
0x00,0x00,0x00,0xff,
IDL_DT_BYTE,
0xff,0xff,0xff,
0x00,0x00,0x00,0x01,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_VARYING_ARRAY,
0|IDL_PROP_DEP_INT,
0x00,0x00,0x06,0x57,
0x00,0x00,0x06,0x57,
IDL_DT_EOL,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x09,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_LENGTH_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x01,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,0xff,
0x00,0x00,0x06,0x78,
0x00,0x00,0x00,0x04,
IDL_DT_NDR_ALIGN_4,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_USHORT,
IDL_DT_USHORT,
IDL_DT_USMALL,
IDL_DT_USMALL,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x06,0xb7,
0x00,0x00,0x06,0xb7,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_USHORT,
IDL_DT_USHORT,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_FIXED_ARRAY,
0,
0x00,0x00,0x06,0xab,
0x00,0x00,0x06,0xab,
IDL_DT_EOL,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x31,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x05,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x31,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x3f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x07,
IDL_DT_ULONG,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x07,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x04,0x08,
0xff,0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0f,
IDL_DT_ULONG,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0f,
IDL_DT_ULONG,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0f,
IDL_DT_ULONG,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0f,
IDL_DT_ULONG,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x6f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x05,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x05,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x3f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x03,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,0xff,
0x00,0x00,0x08,0xa4,
0xff,0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x3f,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,0xff,
0x00,0x00,0x07,0x80,
0x00,0x00,0x00,0x52,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x07,0x93,
0x00,0x00,0x07,0x93,
IDL_DT_EOL,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x3f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x3f,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,0xff,
0x00,0x00,0x08,0xa4,
0xff,0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x7f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x31,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x3f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x07,
IDL_DT_ULONG,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x07,
IDL_DT_REPRESENT_AS,
0|IDL_PROP_DEP_INT,
0xff,0xff,
0x00,0x00,0x04,0x08,
0xff,0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0f,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,0xff,
0x00,0x00,0x08,0x1c,
0xff,0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0f,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,0xff,
0x00,0x00,0x08,0x1c,
0x00,0x00,0x00,0x6f,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_USHORT,
IDL_DT_USHORT,
IDL_DT_USMALL,
IDL_DT_USMALL,
IDL_DT_FIXED_ARRAY,
0,
0x00,0x00,0x08,0x33,
0x00,0x00,0x08,0x33,
IDL_DT_EOL,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x05,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0f,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,0xff,
0x00,0x00,0x08,0x50,
0x00,0x00,0x00,0x76,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x08,0x63,
0x00,0x00,0x08,0x63,
IDL_DT_EOL,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x3f,
IDL_DT_BYTE,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0f,
IDL_DT_ULONG,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0f,
IDL_DT_ULONG,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0f,
IDL_DT_ULONG,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0f,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,0xff,
0x00,0x00,0x08,0xa4,
0x00,0x00,0x00,0x78,
IDL_DT_NDR_ALIGN_2,
IDL_DT_USHORT,
IDL_DT_FIXED_ARRAY,
0,
0x00,0x00,0x08,0xb7,
0x00,0x00,0x08,0xb7,
IDL_DT_EOL,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0d,
IDL_DT_USMALL,
0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x6f,
IDL_DT_BYTE,
0xff,0xff,0xff,
0x00,0x00,0x00,0x7c,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_ULONG,
IDL_DT_EOL,
0x00,0x00,0x00,0x10,
0
};


error_status_t VL_GetEntryByID
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ /* Type must appear in user header or IDL */ afs_hyper_t *Volid,
    /* [in] */ unsigned32 voltype,
    /* [out] */ vldbentry *entry
)
#else
(h, Volid, voltype, entry)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    /* Type must appear in user header or IDL */ afs_hyper_t *Volid;
    unsigned32 voltype;
    vldbentry *entry;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t *IDL_msp;
idl_byte *IDL_stack_packetp;
rpc_void_p_t IDL_param_vec[5];
error_status_t IDL_function_result;
IDL_msp = (IDL_msp_t) malloc(sizeof(IDL_ms_t));
IDL_stack_packetp = (idl_byte *) malloc(sizeof(idl_byte) * IDL_STACK_PACKET_SIZE);
if ((IDL_msp == NULL) || (IDL_stack_packetp == NULL)) {
    RAISE( rpc_x_no_memory );
}
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, IDL_msp);
IDL_msp->IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_msp->IDL_stack_packet_addr = IDL_stack_packetp;
TRY
IDL_msp->IDL_call_h = 0;
IDL_msp->IDL_elt_p = NULL;
IDL_msp->IDL_offset_vec = IDL_offset_vec;
IDL_msp->IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)Volid;
IDL_param_vec[3] = (rpc_void_p_t)&voltype;
IDL_param_vec[4] = (rpc_void_p_t)entry;
IDL_msp->IDL_param_vec = IDL_param_vec;
IDL_msp->IDL_side = IDL_client_side_k;
IDL_msp->IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,0,(rpc_call_handle_t*)&IDL_msp->IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_msp->IDL_status);
if (IDL_msp->IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    2,
    376,
    IDL_param_vec, IDL_msp);
IDL_msp->IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_msp->IDL_call_h,(rpc_iovector_p_t)&IDL_msp->IDL_iovec,
  IDL_msp->IDL_elt_p,&IDL_msp->IDL_drep,(unsigned32*)&IDL_msp->IDL_status);
if (IDL_msp->IDL_status != error_status_ok)
{
IDL_msp->IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    3,
    400,
    IDL_param_vec, IDL_msp);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(IDL_msp);
rpc_ss_call_end_2(&IDL_msp->IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_msp->IDL_status);
if (IDL_msp->IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_msp->IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_msp->IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_msp->IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_msp->IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, IDL_msp);
free(IDL_msp);
free(IDL_stack_packetp);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t VL_GetEntryByName
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ volumeName volName,
    /* [out] */ vldbentry *entry
)
#else
(h, volName, entry)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    volumeName volName;
    vldbentry *entry;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t *IDL_msp;
idl_byte *IDL_stack_packetp;
rpc_void_p_t IDL_param_vec[4];
error_status_t IDL_function_result;
IDL_msp = (IDL_msp_t) malloc(sizeof(IDL_ms_t));
IDL_stack_packetp = (idl_byte *) malloc(sizeof(idl_byte) * IDL_STACK_PACKET_SIZE);
if ((IDL_msp == NULL) || (IDL_stack_packetp == NULL)) {
    RAISE( rpc_x_no_memory );
}
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, IDL_msp);
IDL_msp->IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_msp->IDL_stack_packet_addr = IDL_stack_packetp;
TRY
IDL_msp->IDL_call_h = 0;
IDL_msp->IDL_elt_p = NULL;
IDL_msp->IDL_offset_vec = IDL_offset_vec;
IDL_msp->IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)volName;
IDL_param_vec[3] = (rpc_void_p_t)entry;
IDL_msp->IDL_param_vec = IDL_param_vec;
IDL_msp->IDL_side = IDL_client_side_k;
IDL_msp->IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,1,(rpc_call_handle_t*)&IDL_msp->IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_msp->IDL_status);
if (IDL_msp->IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    1,
    440,
    IDL_param_vec, IDL_msp);
IDL_msp->IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_msp->IDL_call_h,(rpc_iovector_p_t)&IDL_msp->IDL_iovec,
  IDL_msp->IDL_elt_p,&IDL_msp->IDL_drep,(unsigned32*)&IDL_msp->IDL_status);
if (IDL_msp->IDL_status != error_status_ok)
{
IDL_msp->IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    2,
    460,
    IDL_param_vec, IDL_msp);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(IDL_msp);
rpc_ss_call_end_2(&IDL_msp->IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_msp->IDL_status);
if (IDL_msp->IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_msp->IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_msp->IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_msp->IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_msp->IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, IDL_msp);
free(IDL_msp);
free(IDL_stack_packetp);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t VL_Probe
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h
)
#else
(h)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t *IDL_msp;
idl_byte *IDL_stack_packetp;
rpc_void_p_t IDL_param_vec[2];
error_status_t IDL_function_result;
IDL_msp = (IDL_msp_t) malloc(sizeof(IDL_ms_t));
IDL_stack_packetp = (idl_byte *) malloc(sizeof(idl_byte) * IDL_STACK_PACKET_SIZE);
if ((IDL_msp == NULL) || (IDL_stack_packetp == NULL)) {
    RAISE( rpc_x_no_memory );
}
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, IDL_msp);
IDL_msp->IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_msp->IDL_stack_packet_addr = IDL_stack_packetp;
TRY
IDL_msp->IDL_call_h = 0;
IDL_msp->IDL_elt_p = NULL;
IDL_msp->IDL_offset_vec = IDL_offset_vec;
IDL_msp->IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_msp->IDL_param_vec = IDL_param_vec;
IDL_msp->IDL_side = IDL_client_side_k;
IDL_msp->IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,2,(rpc_call_handle_t*)&IDL_msp->IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_msp->IDL_status);
if (IDL_msp->IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    0,
    0,
    IDL_param_vec, IDL_msp);
IDL_msp->IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_msp->IDL_call_h,(rpc_iovector_p_t)&IDL_msp->IDL_iovec,
  IDL_msp->IDL_elt_p,&IDL_msp->IDL_drep,(unsigned32*)&IDL_msp->IDL_status);
if (IDL_msp->IDL_status != error_status_ok)
{
IDL_msp->IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    1,
    484,
    IDL_param_vec, IDL_msp);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(IDL_msp);
rpc_ss_call_end_2(&IDL_msp->IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_msp->IDL_status);
if (IDL_msp->IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_msp->IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_msp->IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_msp->IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_msp->IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, IDL_msp);
free(IDL_msp);
free(IDL_stack_packetp);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t VL_GetCellInfo
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [out] */ vlconf_cell *MyCell
)
#else
(h, MyCell)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    vlconf_cell *MyCell;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t *IDL_msp;
idl_byte *IDL_stack_packetp;
rpc_void_p_t IDL_param_vec[3];
error_status_t IDL_function_result;
IDL_msp = (IDL_msp_t) malloc(sizeof(IDL_ms_t));
IDL_stack_packetp = (idl_byte *) malloc(sizeof(idl_byte) * IDL_STACK_PACKET_SIZE);
if ((IDL_msp == NULL) || (IDL_stack_packetp == NULL)) {
    RAISE( rpc_x_no_memory );
}
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, IDL_msp);
IDL_msp->IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_msp->IDL_stack_packet_addr = IDL_stack_packetp;
TRY
IDL_msp->IDL_call_h = 0;
IDL_msp->IDL_elt_p = NULL;
IDL_msp->IDL_offset_vec = IDL_offset_vec;
IDL_msp->IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)MyCell;
IDL_msp->IDL_param_vec = IDL_param_vec;
IDL_msp->IDL_side = IDL_client_side_k;
IDL_msp->IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,3,(rpc_call_handle_t*)&IDL_msp->IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_msp->IDL_status);
if (IDL_msp->IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    0,
    0,
    IDL_param_vec, IDL_msp);
IDL_msp->IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_msp->IDL_call_h,(rpc_iovector_p_t)&IDL_msp->IDL_iovec,
  IDL_msp->IDL_elt_p,&IDL_msp->IDL_drep,(unsigned32*)&IDL_msp->IDL_status);
if (IDL_msp->IDL_status != error_status_ok)
{
IDL_msp->IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    2,
    492,
    IDL_param_vec, IDL_msp);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(IDL_msp);
rpc_ss_call_end_2(&IDL_msp->IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_msp->IDL_status);
if (IDL_msp->IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_msp->IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_msp->IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_msp->IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_msp->IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, IDL_msp);
free(IDL_msp);
free(IDL_stack_packetp);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

error_status_t VL_GetSiteInfo
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t h,
    /* [in] */ afsNetAddr *OldAddr,
    /* [out] */ siteDesc *FullSiteInfo
)
#else
(h, OldAddr, FullSiteInfo)
#endif

#ifndef IDL_PROTOTYPES
    handle_t h;
    afsNetAddr *OldAddr;
    siteDesc *FullSiteInfo;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t *IDL_msp;
idl_byte *IDL_stack_packetp;
rpc_void_p_t IDL_param_vec[4];
error_status_t IDL_function_result;
IDL_msp = (IDL_msp_t) malloc(sizeof(IDL_ms_t));
IDL_stack_packetp = (idl_byte *) malloc(sizeof(idl_byte) * IDL_STACK_PACKET_SIZE);
if ((IDL_msp == NULL) || (IDL_stack_packetp == NULL)) {
    RAISE( rpc_x_no_memory );
}
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, IDL_msp);
IDL_msp->IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_msp->IDL_stack_packet_addr = IDL_stack_packetp;
TRY
IDL_msp->IDL_call_h = 0;
IDL_msp->IDL_elt_p = NULL;
IDL_msp->IDL_offset_vec = IDL_offset_vec;
IDL_msp->IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&h;
IDL_param_vec[2] = (rpc_void_p_t)OldAddr;
IDL_param_vec[3] = (rpc_void_p_t)FullSiteInfo;
IDL_msp->IDL_param_vec = IDL_param_vec;
IDL_msp->IDL_side = IDL_client_side_k;
IDL_msp->IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) h, 0,
 (rpc_if_handle_t)&IDL_ifspec,6,(rpc_call_handle_t*)&IDL_msp->IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_msp->IDL_status);
if (IDL_msp->IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    1,
    672,
    IDL_param_vec, IDL_msp);
IDL_msp->IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_msp->IDL_call_h,(rpc_iovector_p_t)&IDL_msp->IDL_iovec,
  IDL_msp->IDL_elt_p,&IDL_msp->IDL_drep,(unsigned32*)&IDL_msp->IDL_status);
if (IDL_msp->IDL_status != error_status_ok)
{
IDL_msp->IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    2,
    688,
    IDL_param_vec, IDL_msp);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(IDL_msp);
rpc_ss_call_end_2(&IDL_msp->IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_msp->IDL_status);
if (IDL_msp->IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_msp->IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_msp->IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_msp->IDL_status!=error_status_ok) ? &IDL_function_result : NULL, (IDL_msp->IDL_status!=error_status_ok) ? &IDL_function_result : NULL, NULL, IDL_msp);
free(IDL_msp);
free(IDL_stack_packetp);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}
#ifdef VMS
#pragma standard
#endif
