/* Generated by IDL compiler version OSF DCE T1.2.0-09 */
#ifdef VMS
#pragma nostandard
#endif
#include <dce/idlddefs.h>
#include <mgmt.h>

static rpc_syntax_id_t IDL_transfer_syntaxes[1] = {
{
{0x8a885d04u, 0x1ceb, 0x11c9, 0x9f, 0xe8, {0x8, 0x0, 0x2b, 0x10, 0x48, 0x60}},
2}};

static rpc_if_rep_t IDL_ifspec = {
  1, /* ifspec rep version */
  6, /* op count */
  1, /* if version */
  {0xafa8bd80u, 0x7d8a, 0x11c9, 0xbe, 0xf4, {0x8, 0x0, 0x2b, 0x10, 0x29, 0x89}},
  2, /* stub/rt if version */
  {0, NULL}, /* endpoint vector */
  {1, IDL_transfer_syntaxes} /* syntax vector */
};
/* global */ rpc_if_handle_t mgmt_v1_0_c_ifspec = (rpc_if_handle_t)&IDL_ifspec;
static idl_ulong_int IDL_offset_vec[] = {
0,
offsetof(rpc_if_id_vector_t , if_id),
offsetof(rpc_if_id_vector_t , count),
offsetof(rpc_if_id_vector_t , if_id),
sizeof(rpc_if_id_t ),
offsetof(rpc_if_id_t , uuid.time_low),
offsetof(rpc_if_id_t , uuid.time_mid),
offsetof(rpc_if_id_t , uuid.time_hi_and_version),
offsetof(rpc_if_id_t , uuid.clock_seq_hi_and_reserved),
offsetof(rpc_if_id_t , uuid.clock_seq_low),
offsetof(rpc_if_id_t , uuid.node),
offsetof(rpc_if_id_t , vers_major),
offsetof(rpc_if_id_t , vers_minor),
0
};

static IDL_rtn_func_t IDL_rtn_vec[] = {
(IDL_rtn_func_t)NULL,
(IDL_rtn_func_t)NULL
};

static idl_byte IDL_type_vec[] = {
0xff,0xff,0xff,0xff,
0,
0,
0xff,0xff,
0x00,0x03,
0x00,0x02,
0x00,0x01,
0x00,0x00,
0xaf,0xa8,0xbd,0x80,
0x7d,0x8a,
0x11,0xc9,
0xbe,
0xf4,
0x08,0x00,0x2b,0x10,0x29,0x89,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x04,
0x00,0x00,0x03,0x68,
0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
0x00,0x00,0x00,0x02,
0x00,0x00,0x00,0x04,
0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,
0x00,0x00,0x00,0x02,
0x00,0x00,0x00,0xd0,
0x00,0x00,0x00,0x02,
0x00,0x00,0x00,0x05,
0x00,0x00,0x00,0x02,
0x00,0x00,0x00,0xe8,
0x00,0x00,0x00,0x03,
0x00,0x00,0x01,0x04,
0x00,0x00,0x00,0x02,
0x00,0x00,0x00,0x03,
0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,
0x00,0x00,0x00,0x02,
0x00,0x00,0x01,0x28,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x03,
0x00,0x00,0x00,0x00,
0xff,0xff,0xff,0xff,
0x00,0x00,0x00,0x01,
0x00,0x00,0x01,0x38,
0x00,0x00,0x00,0x02,
0x00,0x00,0x00,0x06,
0x00,0x00,0x00,0x03,
0x00,0x00,0x01,0x40,
0x00,0x00,0x00,0x02,
0x00,0x00,0x01,0x68,
0x00,0x00,0x00,0x02,
0x00,0x00,0x00,0x09,
0x00,0x00,0x00,0x05,
0x00,0x00,0x01,0x84,
0x00,0x00,0x00,0x04,
0x00,0x00,0x01,0xc8,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_FULL_PTR,
0|IDL_PROP_DEP_INT|IDL_PROP_HAS_PTRS,
0xff,
0x00,0x00,0x01,0xff,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_ALLOCATE,
IDL_DT_CONF_ARRAY,
0|IDL_PROP_DEP_INT,
0x00,0x00,0x02,0x0b,
0x00,0x00,0x02,0x0b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x03,
IDL_DT_PASSED_BY_REF,
IDL_DT_CONF_ARRAY,
0|IDL_PROP_DEP_INT,
0xff,
0x00,0x00,0x02,0x1f,
0x00,0x00,0x02,0x1f,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x00,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_PASSED_BY_REF,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x02,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_ALLOCATE,
IDL_DT_STRING,
IDL_DT_OPEN_ARRAY,
0|IDL_PROP_DEP_CHAR,
0xff,0xff,0xff,
0x00,0x00,0x02,0x33,
0x00,0x00,0x02,0x33,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_PASSED_BY_REF,
IDL_DT_STRING,
IDL_DT_OPEN_ARRAY,
0|IDL_PROP_DEP_CHAR,
0x00,0x00,0x02,0x57,
0x00,0x00,0x02,0x57,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x02,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_ALLOCATE,
IDL_DT_STRING,
IDL_DT_OPEN_ARRAY,
0|IDL_PROP_DEP_CHAR,
0xff,0xff,0xff,
0x00,0x00,0x02,0x7b,
0x00,0x00,0x02,0x7b,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_ALLOCATE,
IDL_DT_OPEN_ARRAY,
0|IDL_PROP_DEP_CHAR,
0x00,0x00,0x02,0x9f,
0x00,0x00,0x02,0x9f,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x05,
IDL_DT_PASSED_BY_REF,
IDL_DT_STRING,
IDL_DT_OPEN_ARRAY,
0|IDL_PROP_DEP_CHAR,
0x00,0x00,0x02,0xc3,
0x00,0x00,0x02,0xc3,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_PASSED_BY_REF,
IDL_DT_ULONG,
IDL_DT_EOL,
0xff,
0x00,0x00,0x00,0x07,
IDL_DT_PASSED_BY_REF,
IDL_DT_OPEN_ARRAY,
0|IDL_PROP_DEP_CHAR,
0xff,
0x00,0x00,0x02,0xe7,
0x00,0x00,0x02,0xe7,
IDL_DT_EOL,
0xff,0xff,0xff,
0x00,0x00,0x00,0x08,
IDL_DT_PASSED_BY_REF,
IDL_DT_ERROR_STATUS,
IDL_DT_EOL,
IDL_DT_CONF_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_HAS_PTRS,
0xff,0xff,0xff,
0x00,0x00,0x03,0x0c,
0xff,0xff,0xff,
1,
IDL_BOUND_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_BOUND_SIZE_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_ULONG,
0xff,0xff,
1,
IDL_BOUND_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_BOUND_SIZE_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x02,
IDL_DT_ULONG,
0xff,0xff,
1,
IDL_BOUND_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_BOUND_SIZE_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_STRING,
1,
0xff,0xff,
0x00,0x00,0x00,0xff,
IDL_DT_CHAR,
0xff,0xff,
1,
IDL_BOUND_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_BOUND_SIZE_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_STRING,
1,
0xff,0xff,
0x00,0x00,0x00,0xff,
IDL_DT_CHAR,
0xff,0xff,
1,
IDL_BOUND_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_BOUND_SIZE_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_STRING,
1,
0xff,0xff,
0x00,0x00,0x00,0xff,
IDL_DT_CHAR,
0xff,0xff,
1,
IDL_BOUND_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_BOUND_SIZE_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_LENGTH_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_CHAR,
0xff,0xff,
1,
IDL_BOUND_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_BOUND_SIZE_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x03,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_STRING,
1,
0xff,0xff,
0x00,0x00,0x00,0xff,
IDL_DT_CHAR,
0xff,0xff,
1,
IDL_BOUND_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_BOUND_SIZE_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x04,
IDL_LIMIT_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_LIMIT_LENGTH_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x06,
IDL_DT_CHAR,
0xff,0xff,0xff,
0x00,0x00,0x00,0x01,
0x00,0x00,0x03,0x23,
IDL_DT_NDR_ALIGN_4,
IDL_DT_ULONG,
IDL_DT_CONF_ARRAY,
0|IDL_PROP_DEP_INT|IDL_PROP_HAS_PTRS,
0x00,0x00,0x03,0x23,
0x00,0x00,0x03,0x23,
IDL_DT_EOL,
0xff,0xff,
1,
IDL_BOUND_FIXED,
0xff,0xff,0xff,
0x00,0x00,0x00,0x00,
IDL_BOUND_SIZE_IS,
IDL_DT_ULONG,
0xff,0xff,
0x00,0x00,0x00,0x01,
IDL_DT_FULL_PTR,
IDL_DT_FIXED_STRUCT,
0|IDL_PROP_DEP_INT|IDL_PROP_MAYBE_WIRE_ALIGNED,
0xff,
0x00,0x00,0x03,0x3c,
0x00,0x00,0x00,0x04,
IDL_DT_NDR_ALIGN_4,
IDL_DT_NDR_ALIGN_4,
IDL_DT_BEGIN_NESTED_STRUCT,
IDL_DT_ULONG,
IDL_DT_USHORT,
IDL_DT_USHORT,
IDL_DT_USMALL,
IDL_DT_USMALL,
IDL_DT_FIXED_ARRAY,
0,
0xff,0xff,
0x00,0x00,0x03,0x5b,
0x00,0x00,0x03,0x5b,
IDL_DT_END_NESTED_STRUCT,
IDL_DT_USHORT,
IDL_DT_USHORT,
IDL_DT_EOL,
0xff,0xff,0xff,
1,
0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x05,
IDL_DT_BYTE,
0xff,0xff,0xff,
0x00,0x00,0x00,0x10,
0
};


static void op0_csr
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t binding_handle,
    /* [out] */ rpc_if_id_vector_p_t *if_id_vector,
    /* [out] */ error_status_t *status
)
#else
(binding_handle, if_id_vector, status)
#endif

#ifndef IDL_PROTOTYPES
    handle_t binding_handle;
    rpc_if_id_vector_p_t *if_id_vector;
    error_status_t *status;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[4];
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[1] = (rpc_void_p_t)&binding_handle;
IDL_param_vec[2] = (rpc_void_p_t)if_id_vector;
IDL_param_vec[3] = (rpc_void_p_t)status;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_ss_init_node_table(&IDL_ms.IDL_node_table,&IDL_ms.IDL_mem_handle);
rpc_ss_mts_client_estab_alloc(&IDL_ms);
rpc_call_start((rpc_binding_handle_t) binding_handle, 0|rpc_c_call_idempotent,
 (rpc_if_handle_t)&IDL_ifspec,0,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    0,
    0,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    2,
    208,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? status : NULL, (IDL_ms.IDL_status!=error_status_ok) ? status : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
}

static void op1_csr
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t binding_handle,
    /* [in, out] */ unsigned32 *count,
    /* [out] */ unsigned32 statistics[],
    /* [out] */ error_status_t *status
)
#else
(binding_handle, count, statistics, status)
#endif

#ifndef IDL_PROTOTYPES
    handle_t binding_handle;
    unsigned32 *count;
    unsigned32 statistics[];
    error_status_t *status;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[5];
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[1] = (rpc_void_p_t)&binding_handle;
IDL_param_vec[2] = (rpc_void_p_t)count;
IDL_param_vec[3] = (rpc_void_p_t)statistics;
IDL_param_vec[4] = (rpc_void_p_t)status;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) binding_handle, 0|rpc_c_call_idempotent,
 (rpc_if_handle_t)&IDL_ifspec,1,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    1,
    232,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    3,
    260,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? status : NULL, (IDL_ms.IDL_status!=error_status_ok) ? status : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
}

static boolean32 op2_csr
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t binding_handle,
    /* [out] */ error_status_t *status
)
#else
(binding_handle, status)
#endif

#ifndef IDL_PROTOTYPES
    handle_t binding_handle;
    error_status_t *status;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[3];
boolean32 IDL_function_result;
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[0] = (rpc_void_p_t)&IDL_function_result;
IDL_param_vec[1] = (rpc_void_p_t)&binding_handle;
IDL_param_vec[2] = (rpc_void_p_t)status;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) binding_handle, 0|rpc_c_call_idempotent,
 (rpc_if_handle_t)&IDL_ifspec,2,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    0,
    0,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    2,
    296,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? status : NULL, (IDL_ms.IDL_status!=error_status_ok) ? status : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
return IDL_function_result;
}

static void op3_csr
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t binding_handle,
    /* [out] */ error_status_t *status
)
#else
(binding_handle, status)
#endif

#ifndef IDL_PROTOTYPES
    handle_t binding_handle;
    error_status_t *status;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[3];
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[1] = (rpc_void_p_t)&binding_handle;
IDL_param_vec[2] = (rpc_void_p_t)status;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) binding_handle, 0,
 (rpc_if_handle_t)&IDL_ifspec,3,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    0,
    0,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    1,
    312,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? status : NULL, (IDL_ms.IDL_status!=error_status_ok) ? status : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
}

static void op4_csr
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t binding_handle,
    /* [in] */ unsigned32 authn_proto,
    /* [in] */ unsigned32 princ_name_size,
    /* [out] */ idl_char princ_name[],
    /* [out] */ error_status_t *status
)
#else
(binding_handle, authn_proto, princ_name_size, princ_name, status)
#endif

#ifndef IDL_PROTOTYPES
    handle_t binding_handle;
    unsigned32 authn_proto;
    unsigned32 princ_name_size;
    idl_char princ_name[];
    error_status_t *status;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[6];
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[1] = (rpc_void_p_t)&binding_handle;
IDL_param_vec[2] = (rpc_void_p_t)&authn_proto;
IDL_param_vec[3] = (rpc_void_p_t)&princ_name_size;
IDL_param_vec[4] = (rpc_void_p_t)princ_name;
IDL_param_vec[5] = (rpc_void_p_t)status;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) binding_handle, 0|rpc_c_call_idempotent,
 (rpc_if_handle_t)&IDL_ifspec,4,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    2,
    320,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    2,
    360,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? status : NULL, (IDL_ms.IDL_status!=error_status_ok) ? status : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
}

static void op5_csr
#ifdef IDL_PROTOTYPES
(
    /* [in] */ handle_t binding_handle,
    /* [in] */ unsigned32 authn_proto,
    /* [in] */ unsigned32 princ_name_size,
    /* [in] */ unsigned32 tkt_size_avail,
    /* [out] */ idl_char princ_name[],
    /* [out] */ unsigned32 *tkt_length,
    /* [out] */ idl_char *data,
    /* [out] */ error_status_t *status
)
#else
(binding_handle, authn_proto, princ_name_size, tkt_size_avail, princ_name, tkt_length, data, status)
#endif

#ifndef IDL_PROTOTYPES
    handle_t binding_handle;
    unsigned32 authn_proto;
    unsigned32 princ_name_size;
    unsigned32 tkt_size_avail;
    idl_char princ_name[];
    unsigned32 *tkt_length;
    idl_char *data;
    error_status_t *status;
#endif
{

rpc_transfer_syntax_t IDL_transfer_syntax;
rpc_iovector_elt_t IDL_outs;
volatile ndr_ulong_int IDL_fault_code=error_status_ok;
volatile ndr_ulong_int IDL_user_fault_id;
volatile RPC_SS_THREADS_CANCEL_STATE_T IDL_async_cancel_state;
IDL_ms_t IDL_ms;
idl_byte IDL_stack_packet[IDL_STACK_PACKET_SIZE];
rpc_void_p_t IDL_param_vec[9];
RPC_SS_INIT_CLIENT
RPC_SS_THREADS_DISABLE_ASYNC(IDL_async_cancel_state);
rpc_ss_init_marsh_state(IDL_type_vec, &IDL_ms);
IDL_ms.IDL_stack_packet_status = IDL_stack_packet_unused_k;
IDL_ms.IDL_stack_packet_addr = IDL_stack_packet;
TRY
IDL_ms.IDL_call_h = 0;
IDL_ms.IDL_elt_p = NULL;
IDL_ms.IDL_offset_vec = IDL_offset_vec;
IDL_ms.IDL_rtn_vec = IDL_rtn_vec;
IDL_param_vec[1] = (rpc_void_p_t)&binding_handle;
IDL_param_vec[2] = (rpc_void_p_t)&authn_proto;
IDL_param_vec[3] = (rpc_void_p_t)&princ_name_size;
IDL_param_vec[4] = (rpc_void_p_t)&tkt_size_avail;
IDL_param_vec[5] = (rpc_void_p_t)princ_name;
IDL_param_vec[6] = (rpc_void_p_t)tkt_length;
IDL_param_vec[7] = (rpc_void_p_t)data;
IDL_param_vec[8] = (rpc_void_p_t)status;
IDL_ms.IDL_param_vec = IDL_param_vec;
IDL_ms.IDL_side = IDL_client_side_k;
IDL_ms.IDL_language = IDL_lang_c_k;
rpc_call_start((rpc_binding_handle_t) binding_handle, 0|rpc_c_call_idempotent,
 (rpc_if_handle_t)&IDL_ifspec,5,(rpc_call_handle_t*)&IDL_ms.IDL_call_h,&IDL_transfer_syntax,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok) goto IDL_closedown;
rpc_ss_ndr_marsh_interp(
    3,
    388,
    IDL_param_vec, &IDL_ms);
IDL_ms.IDL_elt_p = &IDL_outs;
rpc_call_transceive((rpc_call_handle_t)IDL_ms.IDL_call_h,(rpc_iovector_p_t)&IDL_ms.IDL_iovec,
  IDL_ms.IDL_elt_p,&IDL_ms.IDL_drep,(unsigned32*)&IDL_ms.IDL_status);
if (IDL_ms.IDL_status != error_status_ok)
{
IDL_ms.IDL_elt_p = NULL;
goto IDL_closedown;
}
rpc_ss_ndr_unmar_interp(
    4,
    456,
    IDL_param_vec, &IDL_ms);
IDL_closedown: ;
CATCH(rpc_x_ss_pipe_comm_error)
FINALLY
rpc_ss_ndr_clean_up(&IDL_ms);
rpc_ss_call_end_2(&IDL_ms.IDL_call_h,&IDL_fault_code,&IDL_user_fault_id,&IDL_ms.IDL_status);
if (IDL_ms.IDL_mem_handle.memory)
{
 rpc_ss_mem_free(&IDL_ms.IDL_mem_handle);
}
rpc_ss_report_error_2(IDL_fault_code,0,IDL_ms.IDL_status,
 (RPC_SS_THREADS_CANCEL_STATE_T *)&IDL_async_cancel_state, (IDL_ms.IDL_status!=error_status_ok) ? status : NULL, (IDL_ms.IDL_status!=error_status_ok) ? status : NULL, NULL, &IDL_ms);
RPC_SS_THREADS_RESTORE_ASYNC(IDL_async_cancel_state);
ENDTRY
}
/* global */ mgmt_v1_0_epv_t mgmt_v1_0_c_epv = {
 op0_csr,
 op1_csr,
 op2_csr,
 op3_csr,
 op4_csr,
 op5_csr
};
#ifdef VMS
#pragma standard
#endif
