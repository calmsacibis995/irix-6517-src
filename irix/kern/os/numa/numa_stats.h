/*****************************************************************************
 * Copyright 1996, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED
 *
 * UNPUBLISHED -- Rights reserved under the copyright laws of the United
 * States.   Use of a copyright notice is precautionary only and does not
 * imply publication or disclosure.
 *
 * U.S. GOVERNMENT RESTRICTED RIGHTS LEGEND:
 * Use, duplication or disclosure by the Government is subject to restrictions
 * as set forth in FAR 52.227.19(c)(2) or subparagraph (c)(1)(ii) of the Rights
 * in Technical Data and Computer Software clause at DFARS 252.227-7013 and/or
 * in similar or successor clauses in the FAR, or the DOD or NASA FAR
 * Supplement.  Contractor/manufacturer is Silicon Graphics, Inc.,
 * 2011 N. Shoreline Blvd. Mountain View, CA 94039-7311.
 *
 * THE CONTENT OF THIS WORK CONTAINS CONFIDENTIAL AND PROPRIETARY
 * INFORMATION OF SILICON GRAPHICS, INC. ANY DUPLICATION, MODIFICATION,
 * DISTRIBUTION, OR DISCLOSURE IN ANY FORM, IN WHOLE, OR IN PART, IS STRICTLY
 * PROHIBITED WITHOUT THE PRIOR EXPRESS WRITTEN PERMISSION OF SILICON
 * GRAPHICS, INC.
 ****************************************************************************/

#ifndef __NUMA_STATS_H__
#define __NUMA_STATS_H__


typedef struct numa_stats_s {
        /*
         * Instantaneous load on router sampled by
         * the traffic control daemon which controls
         * the local thresholds. Range  [0,100]
         */
        uchar_t traffic_local_router;

        /*
         * Last set migration threshold for this node
         * Range [0,100]
         */
        uchar_t migr_threshold;

        /*
         * Number of interrupts generated by reference counters
         * Includes differential mode (migr request) and absolute mode
         */
        uint refcnt_interrupt_number;

        /*
         * Number of interrupts generated by reference counters
         * with invalid candidate read in intr handler
         */
        uint refcnt_invalid_candidate_intrnumber;

        /*
         * Effective number of loops executed by the intr handler
         */
        uint refcnt_intrhandler_numloops;

        /*
         * Number of absolute interrupts received
         * for pages with migration enabled and not frozen
         */
        uint refcnt_intrfail_absmigrnotfrz;

        /*
         * Number of valid absolute interrupts
         */
        uint refcnt_introk_absolute;

        /*
         * Number of differential interrupts for pages
         * with migration disabled.
         */
        uint refcnt_intrfail_relnotmigr;

        /*
         * Number of valid relative interrupts
         */
        uint refcnt_introk_relative;

        /*
         * Number of effective pagemove operations
         * indexed by migration_vehicle
         * MIGR_VEHICLE_IS_BTE (0)
         * MIGR_VEHICLE_IS_TLBSYNC (1)
         */
        uint migr_pagemove_number[2];

        /*
         * Number of ignored interrupts due to inappropriate state
         */
        uint migr_interrupt_failstate;

        /*
         * Number of ignored interrupts due to disabled auto migration
         */
        uint migr_interrupt_failenabled;

        /*
         * Number of ignored interrupts due to frozen page
         */
        uint migr_interrupt_failfrozen;
        
        /*
         * Number of automatic succesful migrations to this node
         */
        uint migr_auto_number_in;

        /*
         * Number of automatic succesful migrations from this node
         */
        uint migr_auto_number_out;

        /*
         * Number of failed automatic migrations from this node
         */
        uint migr_auto_number_fail;

        /*
         * Number of queued automatic migration requests
         */
        uint migr_auto_number_queued;

        /*
         * Number of queued succesful migrations into this node
         */
        uint migr_queue_number_in;

        /*
         * Number of queued succesful migrations out of this node
         */
        uint migr_queue_number_out;

        /*
         * Number of queued failed migrations
         */
        uint migr_queue_number_fail;

        /*
         * Number of queuing failures due to queue overflow
         */
        uint migr_queue_number_overflow;

        /*
         * Number of queuing failures due to invalid state
         */
        uint migr_queue_number_failstate;

        /*
         * Number of queued pages not migrated because of invalid state
         */
        uint migr_queue_number_failq;        
        
        /*
         * Number of user initiated migrations to this node
         */
        uint migr_user_number_in;

        /*
         * Number of user initiated migrations from this node
         */
        uint migr_user_number_out;

        /*
         * Number of failed user initiated migrations from this node
         */
        uint migr_user_number_fail;
        
        /*
         * Number of enqueued user migrations
         */
        uint migr_user_number_queued;
        
        /*
         * Number of coalescing daemon migrations to this node
         */
        uint migr_coalescingd_number_in;

        /*
         * Number of coalescing daemon migrations from this node
         */
        uint migr_coalescingd_number_out;

        /*
         * Number of failed coalescing daemon migrations from this node
         */
        uint migr_coalescingd_number_fail;

        /*
         * Number of Queue Migr Capacity Triggers
         */
         uint migr_queue_capacity_trigger_count;
        
        /*
         * Number of Queue Migr Time Triggers
         */
         uint migr_queue_time_trigger_count;

        /*
         * Number of Queue Migr Traffic Triggers
         */
         uint migr_queue_traffic_trigger_count;       

        /*
         * Memory lent to other nodes
         */
        uint pagealloc_lent_memory;

        /*
         * Number of times the unpegger has been called
         */
        uint migr_unpegger_calls;

        /*
         * Number of pages unpegged so far
         */
        uint migr_unpegger_npages;

        /*
         * Number of pages unpegged during the last unpegging cycle
         */
        uint migr_unpegger_lastnpages;

        /*
         * Nunmber of frozen pages so far
         */
        uint migr_bouncecontrol_frozen_pages;

        /*
         * Number of bounce control cycles
         */
        uint migr_bouncecontrol_calls;

        /*
         * Number of melt pages so far
         */
        uint migr_bouncecontrol_melt_pages;

        /*
         * Number of melt pages in last cycle
         */
        uint migr_bouncecontrol_last_melt_pages;

        /*
         * Number of dampened pages
         */
        uint migr_bouncecontrol_dampened_pages;
         
	/*
	 * Number of replicated pages in the system.
	 */
	uint repl_pagecount;

	/*
	 * Number of times this node was target of replication.
	 */
	uint repl_page_destination;

	/*
	 * Number of times, a replicated page on this node was reused.
	 */
	uint repl_page_reuse;

	/*
	 * Count of refusal to replicate by the replication controller
	 */
	uint repl_control_refuse;

	/*
	 * Count of failures to allocate a page for creating replication 
	 */
	uint repl_page_notavail;

        /*
         * Memory daemon periodic activations
         */
        uint memoryd_periodic_activations;

        /*
         * Memory daemon total activations
         */
        uint memoryd_total_activations;

        /*
         * Pages frozen due to low memory on destination node
         */
        uint migr_pressure_frozen_pages;

        /*
         * Pages frozen due to migration request to nearby node
         */
        uint migr_distance_frozen_pages;
         
        /*
         * Page frozen due to excessive pfdat references
         */
        uint migr_cost_frozen_pages;

} numa_stats_t;

#ifdef	NUMA_BASE

#define NUMA_STAT_SAMPLE(node, field, value) \
        ((NODEPDA((node)))->numa_stats->field = (value))

#define NUMA_STAT_INCR(node, field) \
       ((NODEPDA((node)))->numa_stats->field++)

#define NUMA_STAT_ADD(node, field, value) \
        ((NODEPDA((node)))->numa_stats->field += (value))


#ifdef DEBUG
#define NUMA_DSTAT_INCR(node, field) \
       ((NODEPDA((node)))->numa_stats->field++)
#else
#define NUMA_DSTAT_INCR(node, field)
#endif

extern void numa_stats_init(cnodeid_t node, caddr_t* nextbyte);

#else

#define NUMA_STAT_SAMPLE(node, field, value) 
#define NUMA_STAT_INCR(node, field) 
#define NUMA_STAT_ADD(node, field, value)
#define NUMA_DSTAT_INCR(node, field)

#endif /* NUMA_BASE */

#endif /* __NUMA_STATS_H__ */
