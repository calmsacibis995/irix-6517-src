'\"! tbl|mmdoc
'\"macro stdmacro
.TH PERF_COUNTERS 5
.SH NAME
r10k_evcntrs, r10k_event_counters, r10k_counters \- Programming the processor event counters
.SH DESCRIPTION
The R10000 and R12000 processors include counters that can be used
to count the frequency of events during the execution of a program.
The information returned by the counters can be helpful in optimizing the
program.  The \f3perfex\f1(1) and \f3ssrun\f1(1) commands provide
convenient interfaces to hardware counter information.
.SH THE COUNTERS 
The R10000 processor supplies two performance counters for counting
certain
hardware events. Each counter can track one event at a time and there are
a choice of sixteen events per counter. There are also two associated
control
registers which are used to specify which event the relevant counter is
counting.
.PP 
The R12000 processor supplies 
two performance counters for counting
hardware events. Each counter can track one event at a time, and you can
choose among 32 events per counter.
.PP
Using performance counters in a machine with both R10000 and R12000
processors is currently undefined.
.PP
Each counter is a 32-bit read / write register and is incremented
by one each time the event specified in its associated control register
occurs. Furthermore, the control registers allow one to indicate that the
events
are only counted in a specific mode. The modes may be user mode or
several
choices of kernel mode, or some combination of kernel and user mode.
.PP
The counters can optionally assert an interrupt upon overflow, which
is defined to be when the most significant bit of one of the counter
registers (bit 31)
becomes set. If such an overflow interrupt is enabled for that event
in the
associated control register, then the interrupt will be presented
to the cpu. Whether the interrupt is asserted or not the counting of
events
will continue after overflow.
.SH THE CONTROL REGISTERS
The format of the control registers is as follows:
.sp 2
.TS
l l c c c c c 
c c c c c c c 
c c c c c c c
c c c c c c c.
31            	8	  4	  3	  2	  1	0
_
|        0	| Event	|   IE	|   U	|   S	|   K	| EXL |
_
.TE
.PP
Bit 4 is the interrupt enable bit, which specifies whether overflows for the 
specified event will generate interrupts or not. Bits 3 through 0 specify 
either the 
mode the event is counted in or the count 
enable bits. These bits will enable counting when they match the 
equivalent KSU settings in the status register of the R10000
or R12000. That is:
.sp 2
.TS
lf4 l.
\f1U bit <----> KSU = 2, EXL = 0, ERL = 0 (user mode) \f3

\f1S bit <----> KSU = 1, EXL = 0, ERL = 0 (supervisor mode, not supported) \f3

\f1K bit <----> KSU = 0, EXL = 0, ERL = 0 (kernel mode) \f3

\f1EXL bit <---> EXL = 1, ERL = 0 (transient kernel mode) \f3
.TE
.PP
ERL is a field in the status register on
coprocessor 0.  It is set when the processor hits an error and is
forced into kernel mode.
.PP
If the KSU bits in the status register are 2,
and the ERL and EXL bits are both off, 
events enabled with the U bit will be counted. In this way, a program 
that intends to use the 
performance counters directly 
must specify the events that are to be counted and
the modes in which they are to be counted.
.SH EVENTS
The following events can be tracked by the performance counters on 
R10000 processors:
.TP
0=cycles
Incremented on each clock cycle.
.TP
1=issued instructions
Incremented each time an instruction is issued to ALU, FPU or load/store
units.
.TP
2=issued loads
Incremented when a load, prefetch, or synchronization instruction is
issued.
.TP
3=issued stores
Incremented when a store instruction is issued.
.TP
4=issued store conditionals
Incremented when a conditional store instruction is issued.
.TP
5=failed store conditionals
Incremented when a store-conditional instruction fails. A
failed store-conditional instruction will, in the normal course of
events, graduate; so this event represents a subset of the
store conditional instructions counted on event 20 (graduated
store conditionals).
.TP
6=Decoded branches
Incremented when a branch is decoded (for revision 2.x processors) or
resolved (for revision 3.x processors).
.TP
7=Quadwords written back from secondary cache
Incremented when data is written back from secondary cache to the system
interface.
.TP
8=correctable secondary cache data array ECC errors
Incremented when single-bit ECC erros are detected on 
data read from secondary cache.
.TP
9=primary instruction cache misses
Incremented when the next instruction is not in primary instruction
cache.
.TP
10=secondary instruction cache misses
Incremented when the next instruction is not in secondary instruction
cache.
.TP
11=instruction misprediction from secondary cache way prediction table
Incremented when the secondary cache way mispredicted an instruction.
.TP
12=external interventions
Incremented when an external intervention is entered into the Miss 
Handling Table (MHT), provided that the intervention is not an
invalidate type.
.TP
13=external invalidations
Incremented when an intervention is entered
into the Miss Handling Table, provided that the intervention is an
invalidate type.
.TP
14=virtual coherency conditions
Incremented on virtual coherency conditions (on revision 2.x R10000 processors)
or on ALU/FPU functional unit completions cycles (on revision 3.x R10000 processors).
This counter is always zero on R12000 processors.
.TP
15=graduated instructions
Incremented when an instruction is graduated.
.TP
16=cycles
Incremented on each clock cycle.
.TP
17=graduated instructions
Incremented when an instruction is graduated.
.TP
18=graduated loads
Incremented on a graduated load, prefetch, or synchronization
instruction.
.TP
19=graduated stores (version 2.x processors)
Incremented on a graduated store instruction.
.TP
19=ALU/FPU forward progress cycles (version 2.x processors)
Incremented at every ALU and floating-point forward progress cycle.
.TP
20=graduated store conditionals
Incremented when a graduated conditional store instruction is issued.
.TP
21=graduated floating-point instructions
Incremented when a graduated floating-point instruction is issued.
.TP
22=quadwords written back from primary data cache
Incremented when data is written back from primary data cache to
secondary cache.
.TP
23=TLB misses
Incremented when a
translation lookaside buffer (TLB) refill exception occurs.
.TP
24=mispredicted braches
Incremented when a branch is mispredicted.
.TP
25=primary (L1) data cache misses.
Incremented when the next data item is not in primary data
cache.
.TP
26=secondary (L2) data cache misses.
Incremented when the next data item is not in secondary data
cache.
.TP
27=data mispredicted from secondary cache way prediction table
Incremented when the secondary cache way mispredicted a data item.
.TP
28=external intervention hits in secondary cache (L2)
Set as follows when an external intervention is
determined to have hit in secondary cache:
.nf
00   Invalid, ho hit detected
01   Clean, shared
10   Clean, exclusive
11   dirty, exclusive
.fi
.TP
29=external invalidation hits in secondary cache (L2)
Set when an external invalidate request is
determined to have hit in the secondary
cache. Its value is equivalent to that
described for event 28.
.TP
30=store/fetch exclusive to clean block in secondary cache (L2)
Incremented on each cycle by the number of entries in the
Miss Handling Table (MHT) waiting for a memory operation to complete.
.TP
31=store/fetch exclusive to shared block in secondary cache (L2)
Incremented when an update request is
issued for a line in the secondary cache. If the line is in the clean
state, the
counter is incremented by one. If the line is in the shared
state, the counter is incremented by two. The conditional counting
mechanism can
be used to select whether one, both, or neither of these events is
chosen.
.PP
Note that the definition of events 6 and 14 on counter 0 differ depending
on the R10000 chip revision.  The chip revision can be determined via the
command \f3hinv\f1(1).
.PP
The following events can be tracked by the performance counters on 
R12000 processors:
.TP
0=cycles
Incremented on each clock cycle.
.TP
1=decoded instructions
Incremented by the total number of instructions decoded on
the previous cycle. Since decoded instructions may later be killed (for
a variety of reasons), this count reflects the overhead due to
incorrectly speculated branches and exception processing. 
.TP
2=decoded loads
Incremented when a load instruction was decoded on the
previous cycle. Prefetch, cache operations,
and synchronization instructions are not included
in the count of decoded loads.
.TP
3=decoded stores
Incremented if a store instruction was decoded on the
previous cycle. Store condtionals are included in this count. 
.TP
4=mishandling table occupancy
Incremented on each cycle by the number of currently
valid entries in the Miss Handling Table (MHT). The MHT has five entries.
Four entries are used for internally generated accesses; the fifth
entry is reserved for externally generated events. All five entries
are included in
this count. See event 8 for a related definition.
.TP
5=failed store conditionals
Incremented when a store-conditional instruction fails. A
failed store-conditional instruction will, in the normal course of
events, graduate; so this event represents a subset of the
store-conditional instructions counted on event 20 (graduated
store-conditionals). 
.TP
6=resolved conditional branches
Incremented both when a branch is determined to have been
mispredicted and when a branch is determined to have been
correctly predicted. When this determination of the 
accuracy of a branch-prediction is known, the branch is 
known as "resolved." This counter
correctly reflects
the case of multiple floating-point conditional branches being resolved in a
single cycle. 
.TP
7=Quadwords written back from secondary cache
Incremented on each cycle that the data for a quadword is
written back from secondary cache to the system interface unit.
.TP
8=correctable secondary cache data array ECC errors
Incremented on the cycle following the correction of a
single-bit error in a quadword read from the secondary cache data array.
.TP
9=primary instruction cache misses
Incremented one cycle after an instruction fetch
request is entered into the Miss Handling Table.
.TP
10=secondary instruction cache misses
Incremented the cycle after a refill request is sent to
the system interface module of the CPU. This is normally just after the
L2 tags are checked and a miss is detected, but it may be delayed if the
system interface module is busy with another request.
.TP
11=instruction misprediction from secondary cache way prediction table
Incremented when the secondary cache control begins
to retry an access because it hit in the unpredicted way, provided
the access that initiated the access was an instruction fetch.
.TP
12=external interventions
Incremented on the cycle after an intervention is entered
into the Miss Handling Table, provided that the intervention is not an
invalidated type.
.TP
13=external invalidations
Incremented on the cycle after an intervention is entered
into the Miss Handling Table, provided that the intervention is an
invalidate type.
.TP
14=ALU/FPU progress cycles
Incremented on the cycle after either ALU1, ALU2, FPU1, or
FPU2 marks an instruction as done.
.TP
15=graduated instructions
Incremented by the number of instructions that were
graduated on the previous cycle. Integer multiply and divide instructions
each count two graduated instructions because they occupy two entries
in the active list.
.TP
16=executed prefetch instructions
Incremented on the cycle after a prefetch instruction
does its tag-check, regardless of whether a data cache line refill is
initiated.
.TP
17=prefetch primary data cache misses
Incremented on the cycle after a prefetch instruction
does its tag-check and a refill of the corresponding data cache line is
initiated.
.TP
18=graduated loads
Incremented by the number of loads that graduated on the
previous cycle. Prefetch instructions are included in this count. Up to
four loads can graduate in one cycle.
.TP
19=graduated stores
Incremented on the cycle after a store graduates. Only
one store can graduate per cycle. Store conditionals are included in
this count. 
.TP
20=graduated store conditions
Incremented on the cycle following the graduation of a
store-conditional instruction. Both failed and sucessful
store-conditional
instructions are included in this count; so sucessful
store-conditionals can be determined as the difference between this
event and event 5 (failed
store-conditionals).
.TP
21=graduated floating-point instructions
Incremented by the number of 
floating-point instructions that
graduated on the previous cycle. There can be 0 to 4 such instructions.
.TP
22=quadwords written back from primary data cache
Incremented on each cycle that a quadword of data is
valid and is written from primary data cache to secondary cache.
.TP
23=TLB misses
Incremented on the cycle after the 
translation lookaside buffer (TLB) miss handler is
invoked.
.TP
24=mispredicted branches
Incremented on the cycle after a branch is \f2restored\f1
because it was mispredicted.
.TP
25=primary data cache misses
Incremented one cycle after a request is entered into the
SCTP logic, provided that the request was initially targeted at the
primary data cache. Such requests fall into three categories: 
.nf
1) Primary data cache misses. 

2) Requests to change the state of 
secondary and primary data cache 
lines from clean to dirty ("update" 
requests) due to stores that hit 
a clean line in the primary data
cache.

3) Requests initiated by cache 
operation instructions. 
.fi
.TP
26=secondary data cache misses
Incremented the cycle after a refill request is sent to 
the system interface module of the CPU. This is normally just after the
L2 tags are checked and a miss is detected, but it can be delayed if the
system interface module is busy with another request. 
.TP
27=data misprediction from secondary cache way prediction table
Incremented when the secondary cache control begins to
retry an access because it hit in the unpredicted way. The counter is
incremented only if
access that initiated the access was not an instruction fetch.
.TP
28=state of external intervention hits in secondary cache
Set on the cycle after an external intervention is
determined to have hit in the secondary cache. 
The value of the event is equal to
the state of the secondary cache line that was hit. 
Setting a performance control register to select this event has a special
effect on the conditional counting behavior. If event 28 or 29 is
selected,
the sense of the "Negated conditional counting" bit is inverted. See
the description of conditional counting for details.
The values are:
.nf
00   Invalid, ho hit detected
01   Clean, shared
10   Clean, exclusive
11   dirty, exclusive
.fi
.TP
29=state of invalidation hits in secondary cache (L2)
Set on the cycle after an external invalidate request is
determined to have hit in 
secondary cache. Its value is equivalent to that
described for event 28.
.TP
30=Miss Handling Table entries accessing memory
Incremented on each cycle by the number of entries in the
Miss Handling Table (MHT) waiting for a memory operation to complete. It is
always less than or equal to the value tracked by counter 4. An entry 
is considered to begin accessing memory when the cache control logic
recognizes that a request must be sent via the SysA/D bus. An
entry is included in this count from that point until the entry
is removed from the
MHT. For example, once the secondary cache tags are checked and an
secondary cache miss is recognized, the entry that originated the request
is included in this
count. It continues to be included until the last word of
the refilled line is written into the secondary cache and the
MHT entry is removed. Unlike
counter 4, the fifth slot of the MHT, which is
reserved for externally generated requests, is not
included in this count.
.TP
31=store/prefetch exclusive to shared block in secondary cache (L2)
Incremented on the cycle after an update request is
issued for a line in the secondary cache. If the line is in the clean
state, the
counter is incremented by one. If the line is in the shared
state, the counter is incremented by two. The conditional counting
mechanism can
be used to select whether one, both, or neither of these events is
chosen.
.PP	
The kernel maintains 64-bit virtual counters for the user program using the 
hardware counters. The view of the counters as being 64-bits is maintained 
through the programming interfaces that 
use them, even though the actual counters are only 32 bits. Similarly, there 
are only two hardware counters per CPU, but the programming interface 
supports the view that there are actually 32 counters. That is, a user 
program can specify that more than one event per hardware counter is to 
be counted, up to sixteen events per counter. The kernel will then multiplex 
the events across clock tick boundaries. So, if a program is tracking more 
than one event per counter, on every clock tick the kernel will check to see 
if it is necessary to switch the events being tracked. If necessary,
it will save the counts for the previous events and set up the counters for 
the next event. Thus, to the program there are 32 64-bit counters available.
.PP
The performance counters are available to the user program primarily 
through the \f3perfex\f1(1) and \f3ssrun\f1(1) commands.
You can also access the counters through the 
\f3/proc\f1(4) interface. A limited and 
more specialized functionality is also provided 
through the \f3syssgi\f1(2) interface, 
but this is not intended to be the general 
interface. 
.PP
Using \f3perfex\f1, you can select the events to be counted on 
hardware counters and the executable program to be run.  The \f3perfex\f1
command prints the values of the hardware counters following the run.
See the \f3perfex\f1(1) man page for more information.
.PP
The \f3ssrun\f1 command is part of the SpeedShop performance analysis
package, and it provides input to the WorkShop \f3cvperf\f1(1) user
interface or, in ASCII format, to the \f3prof\f1(1) command.  See the
various man pages, the \f2SpeedShop User's Guide\f1, and the \f2Developer
Magic: Performance Analyzer User's Guide\f1 for more information.
.PP
Through \f3/proc\f1, \f3ioctl\f1s allow you to start or 
stop using the counters, to read the counts in your own counters, or to 
modify the way the counters are being used. Since this interface specifies 
a process ID
as a parameter, it is possible, in general, for a
process to read or manipulate the counters of another process, as long as the 
process belongs to the same process group or is root. 
.PP
There are also \f3ioctl\f1s that allow the program to specify overflow thresholds 
on a per-event basis and to supply a signal to be sent to the program upon 
overflow. That is, the fact that an interrupt can be generated whenever a 
particular counter overflows can be exploited to allow a program to 
specify a threshold \f2n\f1 for 
an event such that after 
\f2n\f1 occurrences of the event 
an interrupt will be generated. 
In addition, while the kernel is servicing the counter overflow 
interrupt, it can perform some user-specified action, such as
sending a user-specified signal to the program whenever an 
overflow is generated or incrementing a PC bucket for profiling. 
The latter choice is a more specialized functionality and is not part of the 
general \f3/proc\f1 interface. 
.PP
For a process using the counters in user mode, the control block for 
the counters is kept in the u-area. Thus, once the process forks, the 
'\" Is u-area the user area?
child acquires the same state of the counters as the parent,
which implies that the next time the child runs the performance counters will 
be run for the child, tracking the same events as its parent. Therefore, 
the counter values are zeroed for the child upon 
fork so that at a later time the child's counters will accurately depict the 
activity of the child. For this reason, it is possible for the parent to fork 
and then wait for the child to exit. When the child 
exits, if the kernel sees that the parent is waiting for the child it will 
add the child's 64-bit counters to those of the parent,
and the parent will thus have the event trace of the child. Other methods for 
a parent to acquire a child's counters are discussed with the 
\f3PIOCSAVECCNTRS\f1 \f3ioctl\f1.
.sp 2
.SH Operation Modes for the Performance Counters
.PP
There are two basic modes that the counters are used in, user mode and system 
mode. Using them in user mode allows the counters to be shared among any 
number of user programs. In this mode the kernel saves and restores the 
counts and state of the counters across context switch boundaries. 
System mode is defined when a user with root privileges uses the counters 
in kernel mode (user mode and/or EXL mode may also be specified, but 
kernel mode is 
essential). In this mode there are no context switch boundaries and so other 
programs will not be able to use the counters when they are in use in 
system mode.
'\" HERE
.PP
Therefore, when the counters are already in use in user mode, a program 
which attempts to use them in system mode will fail with EBUSY since the two 
modes cannot co-exist (unless certain commands are employed to force 
releasing of the counters in user mode and the acquiring of them in system 
mode- to be discussed later). Likewise, if the counters are in use in system 
mode, any program attempting to use the counters will fail with EBUSY
(root-level or otherwise).
.PP
The approach taken to these two operating modes is that system mode has a 
higher priority. For this reason there is a syssgi command to forcibly 
acquire the counters in system mode. Any current users of the counters on 
any cpu will be forced to release them. And any users of the counters who 
are not currently running will not be able to acquire them when they 
run again. This latter situation holds at all times. That is, there may 
be several programs sharing the counters in user mode. If at any moment 
they happen to all be switched out, the counters are temporarily free. 
At this point it is possible for a super-user to acquire the counters 
in system mode. Then, when the other programs are run again, they won't 
be able to acquire the counters since they are in use in system mode. 
Since this program will then be run at this point without the intended event 
counting, the kernel will arrange it such that this program will not use 
the counters again, unless they are explicitly restarted. This is 
because the values in the counters are no longer representative of 
the program. 
.PP
To re-iterate, a root-level program may receive EBUSY from the kernel if it 
tries to acquire the counters in system mode through /proc and they are 
actively in use at the time of the system call. If they are in use in user 
mode by other programs but those programs are not running at the time 
of the system call, then the counters will be successfully acquired in system 
mode and the other programs will not be able to acquire them again- the 
kernel will not try to start up the counters for those other programs again.
.PP
In order to make this situation visible to the program, a 
.I generation 
number is employed to reflect the current state of the counters. In this case, 
whenever the kernel does turn off the use of the counters for a program 
because the mode of operation has switched from user mode to system mode, 
the 
.I generation 
number for the counters for the user programs will 
be increased. Thus, subsequent reads of the counters will return the 
new 
.Igeneration 
number and should signal the program that the counter 
values are not to be trusted. 
The 
.Igeneration 
number will be discussed in greater detail later. 
.PP
To support using the counters in system mode, each cpu has its own control 
block for the counters, pointed to in its private area. There is also a 
global counter control block which maintains counter state for the entire 
system. When the counters are being used in system mode they 
are not read and stored across context switch boundaries. In fact, unless 
they are explicitly read by a program, the counters are not read by the kernel 
until there is an overflow interrupt. When this occurs the cpu on which the 
interrupt occurs updates its own private virtual counters, no changes 
are made to the global counter control block.
.PP
When the counters are read in system mode via PIOCGETEVCTRS through /proc, 
the per-cpu counters are all added together into the global counters so that 
the global counters represent the sum total of the counted events for the 
entire system. This same coalescing of the per-cpu counters happens when the 
counters are released. Note that it is also possible to read a particular 
cpu's counters via the syssgi HWPERF_GET_CPUCNTRS command.
.sp 2
            \f1/proc Commands for the Performance Counters\f3
.sp
.PP
To support the /proc interface for the counters, there are several data 
structures defined in /usr/include/sys/hwperftypes.h that are used to 
either pass parameters with the calls or to receive data back from 
the kernel. 
.sp 2
.TS
lf4 l.
\f1struct hwperf_ctrlreg { \f3
       \f1 ushort_t     hwp_ev  :11, /* event counted */\f3
                     \f1hwp_ie  :1,  /* overflow intr enable */\f3
                     \f1hwp_mode:4;  /* user/kernel/EXL */\f3
\f1};\f3

\f1typedef union { \f3
        \f1short                 hwperf_spec; \f3
        \f1struct hwperf_ctrlreg hwperf_creg; \f3
\f1} hwperf_ctrl_t; \f3

\f1typedef struct { \f3
        \f1hwperf_ctrl_t hwp_evctrl[HWPERF_EVENTMAX]; \f3
\f1} hwperf_eventctrl_t; \f3
.TE
.PP
Each event is described to the kernel through an hwperf_ctrl_t. Where 
relevant, the \f3ioctl\f1s take the address of an hwperf_eventctrl_t, the 
array of 32 hwperf_ctrl_t's. If the user is not interested in an event, 
then care must be taken to ensure that the corresponding element in 
this array is zero. 
.PP
For a user to gain access to the counters, it must indicate which events are 
of interest and how they are to be counted; whether overflow thresholds are 
to be used to generate overflow interrupts or not, and what those thresholds 
are per event; and what signal the user program would like to receive from 
the kernel upon overflow interrupt. All of this information is conveyed with 
the structure hwperf_profevctrarg_t:
.sp 2
.TS
lf4 l.
\f1typedef struct hwperf_profevctrarg { \f3
     \f1hwperf_eventctrl_t hwp_evctrargs; \f3
     \f1int                hwp_ovflw_freq[HWPERF_EVENTMAX]; \f3
     \f1int                hwp_ovflw_sig; /* SIGUSR1,2 */ \f3
\f1} hwperf_profevctrarg_t; \f3
.TE
.PP
With the above structure as parameter the user program must take care to zero 
the hwp_ovflw_freq elements for which no overflow thresholds are intended. 
The hwp_ovflw_sig field is used to tell the kernel which signal the program 
wants to receive upon overflow interrupt. The acceptable signals are between 
1 and 32 (SIG32). This field should be zero if no signals are wanted.
.PP
The following structure is an array of 32 64-bit virtual counters and 
is used when a program wants to read the virtual counters of a process:
.sp
.TS
lf4 l.
\f1typedef struct { \f3
  \f1   __uint64_t hwp_evctr[HWPERF_EVENTMAX]; \f3
\f1} hwperf_cntr_t; \f3
.TE
.PP
It is also possible to read the counters and all of the prusage information 
of a process in one call. To this end the hwperf_prusage_t is defined:
.sp
.TS
lf4 l.
\f1typedef struct hwperf_prusage { \f3
  \f1   timespec_t pu_tstamp;  /* time stamp */ \f3
  \f1   timespec_t pu_starttime; /* time process was started */ \f3
  \f1   timespec_t pu_utime;   /* user CPU time */ \f3
  \f1   timespec_t pu_stime;   /* system CPU time */ \f3
  \f1   __uint64_t pu_minf;     /* minor (mapping) page faults */ \f3
  \f1   __uint64_t pu_majf;     /* major (disk) page faults */ \f3
  \f1   __uint64_t pu_utlb;     /* user TLB misses */ \f3
  \f1   __uint64_t pu_nswap;    /* swaps (process only) */ \f3
  \f1   __uint64_t pu_gbread;   /* gigabytes ... */ \f3
  \f1   __uint64_t pu_bread;    /* and bytes read */ \f3
  \f1   __uint64_t pu_gbwrit;   /* gigabytes ... */ \f3
  \f1   __uint64_t pu_bwrit;    /* and bytes written */ \f3
  \f1   __uint64_t pu_sigs;     /* signals received */ \f3
  \f1   __uint64_t pu_vctx;     /* voluntary context switches */ \f3
  \f1   __uint64_t pu_ictx;     /* involuntary context switches */ \f3
  \f1   __uint64_t pu_sysc;     /* system calls */ \f3
  \f1   __uint64_t pu_syscr;    /* read() system calls */ \f3
  \f1   __uint64_t pu_syscw;    /* write() system calls */ \f3
  \f1   __uint64_t pu_syscps;   /* poll() or select() system calls */ \f3
  \f1   __uint64_t pu_sysci;    /* ioctl() system calls */ \f3
  \f1   __uint64_t pu_graphfifo;    /* graphics pipeline stalls */ \f3
  \f1   __uint64_t pu_graph_req[8]; /* graphics resource requests */ \f3
  \f1   __uint64_t pu_graph_wait[8];/* graphics resource waits */ \f3
  \f1   __uint64_t pu_size;     /* size of swappable image in pages */ \f3
  \f1   __uint64_t pu_rss;      /* resident set size */ \f3
  \f1   __uint64_t pu_inblock;  /* block input operations */ \f3
  \f1   __uint64_t pu_oublock;  /* block output operations */ \f3
  \f1   __uint64_t pu_vfault;   /* total number of vfaults */ \f3
  \f1   __uint64_t pu_ktlb;     /* kernel TLB misses */ \f3
  \f1   cpu_mon_t pu_cpu_mon;   /* cpu monitoring stats */ \f3
\f1} hwperf_prusage_t; \f3
.TE
.sp 2
.PP
The \f3ioctl\f1s available through /proc are the following:
.sp 2
.TS
lf4 l.
PIOCENEVCTRS \f1  - Start using the counters for a process, either in user\f3
                 \f1mode or system mode. It initializes the counters for the\f3
                 \f1target process and, if the process is running, starts\f3
                 \f1them. Otherwise, the counters will be started the next \f3
                 \f1time the process is run. Fails with EINVAL if events are\f3
                 \f1specified events improperly, or if an input overflow \f3
                 \f1frequency (threshold) is negative. \f3

                 \f1If supervisor or kernel mode is specified for any of \f3
                 \f1the events and the caller does not have root privileges,\f3
                 \f1it will fail with EPERM. EBUSY may be returned for two \f3
                 \f1possible reasons:\f3 
                 \f1(1) the counters are already in use in system mode or, \f3
                 \f1(2) the caller is requesting the counters in system \f3 
                 \f1mode and, at the time of the request, the counters are \f3
                 \f1in use in user mode, on at least one cpu (this command \f3
                 \f1will not forcibly acquire the counters for a root \f3
                 \f1process).\f3

                 \f1Returns a positive generation number if successful. \f3

PIOCGETEVCTRS \f1 - Read the virtual counters of the target process. \f3
                 \f1The address of an hwperf_cntr_t must be supplied in 
                 \f1the call. \f3

                 \f1Returns a positive generation number if successful. \f3

PIOCGETPREVCTRS\f1- Read a process's counters in addition to reading all \f3 
                 \f1the prusage information associated with the process. \f3
                 \f1The address of an hwperf_prusage_t must be supplied  \f3
                 \f1with the call. \f3

                 \f1Returns a positive generation number if successful. \f3

PIOCGETEVCTRL \f1 - Retrieve the control information for the process's \f3
                 \f1counters: which events are being counted and the mode \f3
                 \f1they are being counted in. The kernel will copyout an \f3
                 \f1array of 32 event specifiers, so the user must supply \f3
                 \f1an address of an hwperf_eventctrl_t. \f3

                 \f1Returns a positive generation number if successful. \f3

PIOCSETEVCTRL \f1 - Modify how a program is using the counters, whether it \f3
                 \f1be events and/or their associated mode of operation, or\f3
                 \f1overflow threshold values, or overflow signal. Once the\f3
                 \f1counters have been acquired this is how their operation\f3
                 \f1for a program is modified without releasing the \f3
                 \f1counters. Each time the PIOCSETEVCTRL is made the \f3
                 \f1generation number for the target process's counters will\f3
                 \f1be incremented. The parameter to this call is the \f3
                 \f1address of an hwperf_profevctrarg_t. \f3

                 \f1Returns a positive generation number if successful. \f3

PIOCRELEVCTRS \f1 - Release the performance counters- the target process \f3
                 \f1will not have any events counted after this call. Note \f3
                 \f1that the virtual counters associated with the target \f3 
                 \f1may still be read as long as the process has not exited.\f3
                 \f1No parameters are necessary. \f3

PIOCSAVECCNTRS \f1- Allow a parent process to receive the counter values \f3
                 \f1of one of its children when it exits, without having to \f3
                 \f1wait for the child (when the parent is waiting no \f3
                 \f1explicit call is necessary). When the child exits its\f3
                 \f1counter values will be added to the parent's, whether \f3
                 \f1the parent is using its counters or not. No parameters \f3
                 \f1are necessary other than target pid.  \f3
.TE
.sp
.SH EXAMPLE
An example of how these commands would be used is given here. Suppose that 
we wanted to count instruction cache misses and data cache misses for our own
program. That means that we want to count event 9 for both counters, and these
events would be counted in user mode.
The following code would 
accomplish this. Note that the constants used are defined in
/usr/include/sys/hwperfmacros.h, and evctr_args is an hwperf_profevctrarg_t.
.sp 2
.TS
lf4 l.
\f1pid = getpid();\f3
\f1sprintf(pfile, "/proc/%05d", pid);\f3
\f1fd = open(pfile, O_RDWR);\f3
\f1for (i = 0; i < HWPERF_CNTEVENTMAX; i++) {\f3
    \f1if (i == 9) {\f3
        \f1evctr_args.hwp_evctrargs.hwp_evctrl[i].hwperf_creg.hwp_mode = HWPERF_CNTEN_U;\f3
        \f1evctr_args.hwp_evctrargs.hwp_evctrl[i].hwperf_creg.hwp_ie = 1;\f3
        \f1evctr_args.hwp_evctrargs.hwp_evctrl[i].hwperf_creg.hwp_ev = i;\f3
        \f1evctr_args.hwp_ovflw_freq[i] = 0;\f3
    \f1} else {\f3
        \f1evctr_args.hwp_evctrargs.hwp_evctrl[i].hwperf_spec = 0;\f3
        \f1evctr_args.hwp_ovflw_freq[i] = 0;\f3
    \f1}\f3
\f1}\f3

\f1for (i = HWPERF_CNT1BASE; i < HWPERF_EVENTMAX; i++) {\f3
    \f1if (i == 9) {\f3
        \f1evctr_args.hwp_evctrargs.hwp_evctrl[i].hwperf_creg.hwp_mode = HWPERF_CNTEN_U;\f3
        \f1evctr_args.hwp_evctrargs.hwp_evctrl[i].hwperf_creg.hwp_ie = 1;\f3
        \f1evctr_args.hwp_evctrargs.hwp_evctrl[i].hwperf_creg.hwp_ev = i - HWPERF_CNT1BASE;\f3
        \f1evctr_args.hwp_ovflw_freq[i] = 0;\f3
    \f1} else {\f3
        \f1evctr_args.hwp_evctrargs.hwp_evctrl[i].hwperf_spec = 0;\f3
        \f1evctr_args.hwp_ovflw_freq[i] = 0;\f3
    \f1}\f3
\f1}\f3
\f1evctr_args.hwp_ovflw_sig = 0;\f3
\f1generation1 = ioctl(fd, PIOCENEVCTRS, (void *)&evctr_args);\f3
\f1if (generation1 < 0) {\f3
    \f1perror("failed to acquire counters");\f3
    \f1exit errno;\f3
\f1}\f3


    \f1. . . . . (body of program) . . . . \f3


\f1/* now read the counter values */\f3
\f1if ((generation2 = ioctl(fd, PIOCGETEVCTRS, (void *)&cnts)) < 0) {\f3
    \f1perror("PIOCGETEVCTRS returns error");\f3
    \f1exit(errno);\f3
\f1}\f3

\f1/* generation number should be the same */\f3
\f1if (generation1 != generation2) {\f3
    \f1printf("program lost event counters\n");\f3
    \f1exit 0;\f3
\f1}\f3

\f1/* release the counters */\f3
\f1if ((ioctl(fd, PIOCRELEVCTRS)) < 0) {\f3
    \f1perror("prioctl PIOCRELEVCTRS returns error");\f3
    \f1exit(errno);\f3
\f1}\f3

\f1/* print out the counts */\f3
\f1printf("instruction cache misses: %d/\n", cnts.hwp_evctr[9]);\f3
\f1printf("data cache misses: %d/\n", cnts.hwp_evctr[25]);\f3
\f1exit 0;\f3
.TE
.sp 2
            \f1Syssgi Commands for the Performance Counters\f3
.PP
The syssgi commands that access the event counters are not intended 
for general use. Rather, specialized commands are implemented through this 
interface. Note that all the commands are the first argument to the syssgi 
command SGI_EVENTCTR. The available commands are:
.sp 2
.TS
lf4 l.
HWPERF_PROFENABLE     \f1- Enable sprofil-like profiling using the \f3
                        \f1performance counters rather than the clock. \f3
                        \f1Returns EINVAL on incorrect input, or EBUSY \f3
                        \f1if the counters are already in use in system \f3
                        \f1mode. The second argument to this command is \f3
                        \f1the address of an hwperf_profevctrarg_t, the \f3
                        \f1argument is a profp, the fourth is the profcnt,\f3
                        \f1both referring to input necessary for profiling.\f3

                        \f1Returns a positive generation number if \f3
                        \f1successful.\f3

HWPERF_ENSYSCNTRS     \f1- Forcibly acquire the counters in system mode. \f3

                        \f1ROOT PERMISSIONS ARE REQUIRED FOR THIS COMMAND.\f3

                        \f1Note that the counters must be set up in kernel \f3
                        \f1mode (usr and EXL may be included, but kernel mode\f3
                        \f1is required), EINVAL will be returned otherwise. \f3
                        \f1That is, at least one of the events must be \f3
                        \f1counted in kernel mode. Will fail with EBUSY if \f3
                        \f1the counters are already in use in system mode. \f3
                        \f1Otherwise, the command is guaranteed to return \f3
                        \f1the counters in system mode. Starts up the \f3
                        \f1counters on all the cpus, with all the cpus\f3
                        \f1counting the same events. \f3 

                        \f1Takes as input (third parameter of syssgi call) \f3
                        \f1the address of an hwperf_profevctrarg_t, which \f3
                        \f1is set up just as it is for the PIOCENEVENTCTRS \f3
                        \f1(see example above).

                        \f1Returns a positive generation number if \f3
                        \f1successful.\f3

HWPERF_GET_SYSCNTRS   \f1- Read the global system counters to get the global\f3
                        \f1event counts. All of the per-cpu counters will be\f3
                        \f1aggregated into the global counters and the \f3
                        \f1results will be returned to the caller. Caller \f3
                        \f1must supply in third argument the address of\f3
                        \f1an hwperf_cntr_t.

                        \f1Returns a positive generation number if \f3
                        \f1successful.\f3

HWPERF_GET_CPUCNTRS   \f1- Read a particular cpu's event counters. The third\f3
                        \f1parameter is a cpuid, the fourth is the address \f3
                        \f1of an hwperf_cntr_t.\f3

                        \f1Returns a positive generation number if \f3
                        \f1successful, 0 otherwise (which would indicate \f3
                        \f1an invalid cpuid.) \f3

HWPERF_GET_SYSEVCTRL  \f1- Retrieve the control information for the systems\f3
                        \f1event counters: which events are being counted \f3
                        \f1and the modes they are being counted in. The third\f3
                        \f1parameter must be the address of an \f3
                        \f1hwperf_eventctrl_t. Returns EINVAL if the counters\f3
                        \f1are not in use.\f3

                        \f1Returns a positive generation number if \f3
                        \f1successful.\f3

HWPERF_SET_SYSEVCTRL  \f1- Modify how the system counters are operating, \f3
                        \f1whether it be events being counted and/or their\f3
                        \f1associated mode of operation, or overflow \f3
                        \f1threshold values, or overflow signal. \f3

                        \f1MUST BE ROOT TO ISSUE THIS COMMAND, or else EPERM\f3
                        \f1will be returned.\f3

                        \f1Once the counters have been acquired this is how\f3
                        \f1their operation is modified without releasing \f3
                        \f1them. Each time the system call \f3
                        \f1syssgi(SGI_EVENTCTR, HWPERF_SET_SYSEVCTRL,...)\f3
                        \f1is issued the generation number for the system's\f3
                        \f1counters is incremented. The third parameter to \f3
                        \f1this call is the address of an \f3
                        \f1hwperf_profevctrarg_t. \f3

                        \f1Returns a positive generation number if \f3
                        \f1successful.\f3

HWPERF_RELSYSCNTRS    \f1- Stop using the counters in system mode and to
                        \f1make the counters available again.
                        \f1ROOT PERMISSION REQUIRED. 
			
                        \f1Returns 0 upon success.

.TE
.SH NOTES
The following list, ordered by events traced, details
revision 3 of the R10000 CPU counters that return information
different from the R12000 CPU counters.  If an event is not
listed here, it is the same on both CPU types.
.sp
.TS
ccc
lll
lll
lll
lll
lll
lll
lll.
Event	R10000	R12000
1	Issued instructions	Decoded instructions
2	Issued loads	Decoded loads
3	Issued stores	Decoded stores
4	Issued store conditionals	Decoded store conditionals
16	Cycles	
17	Graduated instructions	Data cache misses
30	Store/fetch exclusive to clean	MHT entries
.TE
.SH FILES
\f3/usr/include/sys/hwperftypes.h
.br
/usr/include/sys/hwperfmacros.h\f1
.SH SEE ALSO
\f3ecadmin\f1(1M), \f3ecstats\f1(1M), \f3perfex\f1(1M), \f3libperfex\f1(3C), 
and \f3libperfex\f1(3F)\f1.
