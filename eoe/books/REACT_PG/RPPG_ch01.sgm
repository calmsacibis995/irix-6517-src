<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="1"><TITLE><XREFTARGET ID="12360">Real-Time Programs<XREFTARGET ID="72608"></TITLE><PARAGRAPH>This chapter surveys the categories of real-time programs, and indicates which types can best be supported by REACT and REACT/Pro. As an experienced programmer of real-time applications, you might want to read the chapter to verify that this book uses terminology that you know; or you might want to proceed directly to <INDEXTARGET ID="RPPG_ch011"><!-- POSTPROCESSDATA: RPPG_ch011|real-time application:types of --><XREF IDREF="34779" TYPE="TITLE">Chapter&nbsp;2, &ldquo;How IRIX and REACT/Pro Support Real&ndash;Time Programs.&rdquo;</XREF></PARAGRAPH>
<SECTION1 LBL="" HELPID = ""><TITLE>Defining Real-Time Programs</TITLE><PARAGRAPH>A real-time program is any program that must maintain a fixed, absolute timing relationship with an external hardware device.<INDEXTARGET ID="RPPG_ch012"><!-- POSTPROCESSDATA: RPPG_ch012|real-time program:defined --></PARAGRAPH>
<PARAGRAPH>Normal-time programs do not require a fixed timing relationship to external devices. A normal-time program is a correct program when it produces the correct output, no matter how long that takes. You can specify performance goals for a normal-time program, such as &ldquo;respond in at most 2 seconds to 90% of all transactions,&rdquo; but if the program does not meet the goals, it is merely slow, not incorrect.</PARAGRAPH>
<PARAGRAPH>A real-time program is one that is incorrect and unusable if it fails to meet its performance requirements, and so falls out of step with the external device.</PARAGRAPH>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE>Examples of Real-Time Applications</TITLE><PARAGRAPH>Some examples of real-time applications include simulators, data collection systems, and process control systems. This section describes each type briefly. Simulators and data collection systems are described in more detail in following sections.</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>A simulator maintains an internal model of the world. It receives control inputs, updates the model to reflect them, and displays the changed model. It must process inputs in real time in order to maintain an accurate simulation, and it must generate output in real time to keep up with the display hardware.<INDEXTARGET ID="RPPG_ch013"><!-- POSTPROCESSDATA: RPPG_ch013|simulator --><INDEXTARGET ID="RPPG_ch014"><!-- POSTPROCESSDATA: RPPG_ch014|real-time application:simulator --></PARAGRAPH>
<PARAGRAPH>Silicon Graphics systems are well suited to programming many kinds of simulators.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A data collection system receives input from reporting devices, for example, telemetry receivers, and stores the data. It may be required to process, reduce, analyze or compress the data before storing it. It must react in real time to avoid losing data.<INDEXTARGET ID="RPPG_ch015"><!-- POSTPROCESSDATA: RPPG_ch015|telemetry --><INDEXTARGET ID="RPPG_ch016"><!-- POSTPROCESSDATA: RPPG_ch016|data collection system --><INDEXTARGET ID="RPPG_ch017"><!-- POSTPROCESSDATA: RPPG_ch017|real-time application:data collection --></PARAGRAPH>
<PARAGRAPH>Silicon Graphics systems are suited to many data collection tasks.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A process control system monitors the state of an industrial process and constantly adjusts it for efficient, safe operation. It must react in real time to avoid waste, damage, or hazardous operating conditions.<INDEXTARGET ID="RPPG_ch018"><!-- POSTPROCESSDATA: RPPG_ch018|process control --><INDEXTARGET ID="RPPG_ch019"><!-- POSTPROCESSDATA: RPPG_ch019|real-time application:process control --></PARAGRAPH>
<PARAGRAPH>Silicon Graphics systems are suited for many process control applications.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE>Simulators</TITLE><PARAGRAPH>All simulators have the same four components,<INDEXTARGET ID="RPPG_ch0110"><!-- POSTPROCESSDATA: RPPG_ch0110|simulator --><INDEXTARGET ID="RPPG_ch0111"><!-- POSTPROCESSDATA: RPPG_ch0111|real-time application:simulator --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>An internal model of the world, or part of it; for example, a model of a vehicle traveling through a model geography, or a model of the physical state of a nuclear power plant.<INDEXTARGET ID="RPPG_ch0112"><!-- POSTPROCESSDATA: RPPG_ch0112|simulator:world model in --></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>External devices to display the state of the model; for example, one or more video displays, audio speakers, or a simulated instrument panel.<INDEXTARGET ID="RPPG_ch0113"><!-- POSTPROCESSDATA: RPPG_ch0113|simulator:state display --></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>External devices to supply control inputs; for example, a steering wheel, a joystick, or simulated knobs and dials.<INDEXTARGET ID="RPPG_ch0114"><!-- POSTPROCESSDATA: RPPG_ch0114|simulator:control inputs to --></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>An operator (or hardware under test) that &ldquo;closes the loop&rdquo; by moving the controls in response to what is shown on the display.<INDEXTARGET ID="RPPG_ch0115"><!-- POSTPROCESSDATA: RPPG_ch0115|operator:of simulator --><INDEXTARGET ID="RPPG_ch0116"><!-- POSTPROCESSDATA: RPPG_ch0116|simulator: operator of --></PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE>Requirements on Simulators</TITLE><PARAGRAPH>The real-time requirements on a simulator vary depending on the nature of these four components. Two key performance requirements on a simulator are <INDEXTARGET ID="RPPG_ch0117"><!-- POSTPROCESSDATA: RPPG_ch0117|real-time application:frame rate --><INDEXTARGET ID="RPPG_ch0118"><!-- POSTPROCESSDATA: RPPG_ch0118|simulator:frame rate of --><GLOSSARYITEM>frame rate</GLOSSARYITEM> and <GLOSSARYITEM>transport delay</GLOSSARYITEM>.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Frame Rate</TITLE><PARAGRAPH>A crucial measure of simulator performance is the rate at which it updates the display. This rate is called the frame rate, whether or not the simulator displays its model on a video screen.<INDEXTARGET ID="RPPG_ch0119"><!-- POSTPROCESSDATA: RPPG_ch0119|frame rate --></PARAGRAPH>
<PARAGRAPH>Frame rate is given in cycles per second (abbreviated Hz). Typical frame rates run from 15 Hz to 60 Hz, although rates higher and lower than these are used in special situations.</PARAGRAPH>
<PARAGRAPH>The inverse of frame rate is <INDEXTARGET ID="RPPG_ch0120"><!-- POSTPROCESSDATA: RPPG_ch0120|frame interval --><GLOSSARYITEM>frame interval</GLOSSARYITEM>. For example, a frame rate of 60 Hz implies a frame interval of 1/60 second, or 16.67 milliseconds. To maintain a frame rate of 60 Hz, a simulator must update its model and prepare a new display in less than 16.67 ms.</PARAGRAPH>
<PARAGRAPH>The REACT/Pro Frame Scheduler (FRS) helps you organize a multiprocess application to achieve a specified frame rate. (See <XREF IDREF="96303" TYPE="TITLE">Chapter&nbsp;4, &ldquo;Using the Frame Scheduler.&rdquo;</XREF>)</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Transport Delay</TITLE><PARAGRAPH>Transport delay is the term for the number of frames that elapses before a control motion is reflected in the display. When the transport delay is too long, the operator perceives the simulation as sluggish or unrealistic. If a visual display lags behind control inputs, a human operator can become physically ill.<INDEXTARGET ID="RPPG_ch0121"><!-- POSTPROCESSDATA: RPPG_ch0121|operator:affected by transport delay --><INDEXTARGET ID="RPPG_ch0122"><!-- POSTPROCESSDATA: RPPG_ch0122|transport delay --></PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Aircraft Simulators</TITLE><PARAGRAPH>Simulators for real or hypothetical aircraft or spacecraft typically require frame rates of 30 Hz to 120 Hz and transport delays of 1 or 2 frames. There can be several analogue control inputs or and possibly many digital control inputs (simulated switches and circuit breakers, for example). There are often multiple video display outputs (one each for the left, forward and right &ldquo;windows&rdquo;), and possibly special hardware to shake or tilt the &ldquo;cockpit.&rdquo; The display in the &ldquo;windows&rdquo; must have a convincing level of detail.<INDEXTARGET ID="RPPG_ch0123"><!-- POSTPROCESSDATA: RPPG_ch0123|aircraft simulator --><INDEXTARGET ID="RPPG_ch0124"><!-- POSTPROCESSDATA: RPPG_ch0124|simulator:aircraft --></PARAGRAPH>
<PARAGRAPH>Silicon Graphics systems with REACT/Pro are well suited to building aircraft simulators.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Ground Vehicle Simulators</TITLE><PARAGRAPH>Simulators for automobiles, tanks, and heavy equipment have been built with Silicon Graphics systems. Frame rates and transport delays are similar to those for aircraft simulators. However, there is a smaller world of simulated &ldquo;geography&rdquo; to maintain in the model. Also, the viewpoint of the display changes more slowly, and through smaller angles, than the viewpoint from an aircraft simulator. These factors can make it somewhat simpler for a ground vehicle simulator to update its display.<INDEXTARGET ID="RPPG_ch0125"><!-- POSTPROCESSDATA: RPPG_ch0125|simulator:ground vehicle --><INDEXTARGET ID="RPPG_ch0126"><!-- POSTPROCESSDATA: RPPG_ch0126|ground vehicle simulator --></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Plant Control Simulators</TITLE><PARAGRAPH>A simulator can be used to train the operators of an industrial plant such as a nuclear or conventional power generation plant. Power-plant simulators have been built using Silicon Graphics systems.<INDEXTARGET ID="RPPG_ch0127"><!-- POSTPROCESSDATA: RPPG_ch0127|power plant simulator --><INDEXTARGET ID="RPPG_ch0128"><!-- POSTPROCESSDATA: RPPG_ch0128|plant control simulator --><INDEXTARGET ID="RPPG_ch0129"><!-- POSTPROCESSDATA: RPPG_ch0129|simulator:plant control --></PARAGRAPH>
<PARAGRAPH>The frame rate of a plant control simulator can be as low as 1 or 2 Hz. However, the number of control inputs (knobs, dials, valves, and so on) can be very large. Special hardware may be required to attach the control inputs and multiplex them onto the VME or PCI bus. Also, the number of display outputs (simulated gauges, charts, warning lights, and so on) can be very large and may also require custom hardware to interface them to the computer.<INDEXTARGET ID="RPPG_ch0130"><!-- POSTPROCESSDATA: RPPG_ch0130|simulator:control inputs to --><INDEXTARGET ID="RPPG_ch0131"><!-- POSTPROCESSDATA: RPPG_ch0131|simulator:frame rate of --><INDEXTARGET ID="RPPG_ch0132"><!-- POSTPROCESSDATA: RPPG_ch0132|frame rate:of plant control simulator --></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Virtual Reality Simulators</TITLE><PARAGRAPH>A virtual reality simulator aims to give its operator a sense of presence in a computer-generated world. (So does a vehicle simulator. One difference is that a vehicle simulator strives for an exact model of the laws of physics, which a virtual reality simulator typically does not need to do.)<INDEXTARGET ID="RPPG_ch0133"><!-- POSTPROCESSDATA: RPPG_ch0133|virtual reality simulator --><INDEXTARGET ID="RPPG_ch0134"><!-- POSTPROCESSDATA: RPPG_ch0134|simulator:virtual reality --></PARAGRAPH>
<PARAGRAPH>Usually the operator can see only the simulated display, and has no other visual referents. Because of this, the frame rate must be high enough to give smooth, nonflickering animation, and any perceptible transport delay can cause nausea and disorientation. However, the virtual world is not required (or expected) to look like the real world, so the simulator may be able to do less work to prepare the display.<INDEXTARGET ID="RPPG_ch0135"><!-- POSTPROCESSDATA: RPPG_ch0135|operator:in virtual reality simulator --><INDEXTARGET ID="RPPG_ch0136"><!-- POSTPROCESSDATA: RPPG_ch0136|frame rate:of virtual reality simulator --></PARAGRAPH>
<PARAGRAPH>Silicon Graphics systems, with their excellent graphic and audio capabilities, are well suited to building virtual reality applications.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Hardware-in-the-Loop Simulators</TITLE><PARAGRAPH>The operator of a simulator need not be a person. In a hardware-in-the-loop (HITL) simulator, the role of operator is played by another computer, such as an aircraft autopilot or the control and guidance computer of a missile. The inputs to the computer under test are the simulator's display output. The output signals of the computer under test are the simulator's control inputs.<INDEXTARGET ID="RPPG_ch0137"><!-- POSTPROCESSDATA: RPPG_ch0137|hardware simulator --><INDEXTARGET ID="RPPG_ch0138"><!-- POSTPROCESSDATA: RPPG_ch0138|simulator:hardware --></PARAGRAPH>
<PARAGRAPH>Depending on the hardware being exercised, the simulator may have to maintain a very high frame rate, up to several thousand hertz. Silicon Graphics systems are excellent choices for HITL simulators.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE>Data Collection Systems</TITLE><PARAGRAPH>A data collection system has the following major parts:<INDEXTARGET ID="RPPG_ch0139"><!-- POSTPROCESSDATA: RPPG_ch0139|real-time application:data collection --><INDEXTARGET ID="RPPG_ch0140"><!-- POSTPROCESSDATA: RPPG_ch0140|data collection system --></PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Sources of data, for example telemetry. Often the source or sources are interfaced to the VME bus, but the PCI bus, serial ports, SCSI devices, and other device types are also used.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>A repository for the data. This can be a raw device such as a tape, or it can be a disk file or even a database system.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Rules for processing. The data collection system might be asked only to buffer the data and copy it to disk. Or it might be expected to compress the data, smooth it, sample it, or filter it for noise.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Optionally, a display. The data collection system may be required to display the status of the system or to display a summary or sample of the data. The display is typically not required to maintain a particular frame rate, however.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<SECTION2 LBL="" HELPID = ""><TITLE>Requirements on Data Collection Systems</TITLE><PARAGRAPH>The first requirement on a data collection system is imposed by the <INDEXTARGET ID="RPPG_ch0141"><!-- POSTPROCESSDATA: RPPG_ch0141|data collection system:peak data rate --><INDEXTARGET ID="RPPG_ch0142"><!-- POSTPROCESSDATA: RPPG_ch0142|overrun in data collection system --><INDEXTARGET ID="RPPG_ch0143"><!-- POSTPROCESSDATA: RPPG_ch0143|peak data rate --><INDEXTARGET ID="RPPG_ch0144"><!-- POSTPROCESSDATA: RPPG_ch0144|data collection system:requirements on --><GLOSSARYITEM>peak data rate</GLOSSARYITEM> of the combined data sources. The system must be able to receive data at this peak rate without an <GLOSSARYITEM>overrun</GLOSSARYITEM>; that is, without losing data because it could not read the data as fast as it arrived.</PARAGRAPH>
<PARAGRAPH>The second requirement is that the system must be able to process and write the data to the repository at the <INDEXTARGET ID="RPPG_ch0145"><!-- POSTPROCESSDATA: RPPG_ch0145|average data rate --><INDEXTARGET ID="RPPG_ch0146"><!-- POSTPROCESSDATA: RPPG_ch0146|data collection system:average data rate --><GLOSSARYITEM>average data rate</GLOSSARYITEM> of the combined sources. Writing can proceed at the average rate as long as there is enough memory to buffer short bursts at the peak rate.</PARAGRAPH>
<PARAGRAPH>You might specify a desired frame rate for updating the display of the data. However, there is usually no real-time requirement on display rate for a data collection system. That is, the system is correct as long as it receives and stores all data, even if the display is updated slowly.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE>Real-Time Programming Languages</TITLE><PARAGRAPH>The majority of real-time programs are written in C, which is the most common language for system programming on UNIX. All of the examples in this book are in C syntax.</PARAGRAPH>
<PARAGRAPH>The second most common real-time language is Ada, which is used for many defense-related projects. Silicon Graphics sells Ada 95, an implementation of the language. Ada&nbsp;95 programs can call any function that is available to a C program, so all the facilities described in this book are available, although the calling syntax may vary slightly. Ada offers additional features that are useful in real-time programming; for example, it includes a partial implementation of POSIX threads, which is used to implement Ada tasking.</PARAGRAPH>
<PARAGRAPH>Some real-time programs are written in FORTRAN. A program in FORTRAN can access any IRIX system function, that is, any facility that is specified in section 2 of the reference pages. For example, all the facilities of the REACT/Pro Frame Scheduler are accessible through the IRIX system function <FUNCTION>schedctl()</FUNCTION>, and hence can be accessed from a FORTRAN program (see <XREF IDREF="95148" TYPE="TITLE">&ldquo;The Frame Scheduler API&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>A FORTRAN program cannot directly call C library functions, so any facility that is documented in volume 3 of the reference pages is not directly available in FORTRAN. Thus the <FUNCTION>mmap()</FUNCTION> function, a system function, is available, but the <FUNCTION>usinit()</FUNCTION> library function, which is basic to SGI semaphores and locks, is not available. However, it is possible to link subroutines in C to FORTRAN programs, so you can write interface subroutines to encapsulate C library functions and make them available to a FORTRAN program.</PARAGRAPH>
</SECTION1>
</CHAPTER>
