<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="8"><TITLE><XREFTARGET ID="75148">Transport Layer Interface</TITLE><PARAGRAPH>This chapter provides detailed information, with various examples, on X/Open's Transport Layer Interface. This chapter describes the more important and common facilities of TLI, but is not meant to be exhaustive.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>Silicon Graphics does not encourage use of the TLI model; its inclusion is for compatibility with interfaces used by other vendors. The sockets interface, with its ease of use and compatibility with industry standardization is the preferred interface.</NOTE>
<PARAGRAPH>Topics covered in this chapter include:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>an introduction to TLI</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>a brief discussion of Network Selection and Name-to-Address Mapping</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>a description of the OSI Reference Model</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>a summary of the basic services available to Transport Interface users</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>an introduction to connection-mode (virtual circuit) communication</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>an introduction to connectionless-mode (datagram) communication</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>how to use <FUNCTION>read()</FUNCTION> and <FUNCTION>write()</FUNCTION></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>advanced topics such as asynchronous event handling and processing of multiple simultaneous connect requests</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the allowable state transitions associated with the Transport Interface</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>necessary guidelines for developing software that can be run without change over any transport protocol developed for TLI</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>a full listing of each programming example given (in fragmentary form) elsewhere in the chapter</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>error message enhancements provided for XTI compatibility</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE>Introduction</TITLE><PARAGRAPH>The Transport Layer Interface is a programming interface to the transport layer of ISO's Open Systems Interconnection Reference Model. It is a subset of the X/Open Transport Interface (XTI), and is implemented within the STREAMS framework. TLI is media- and protocol-independent; it allows applications to run across any transport protocol that supports the interface.<INDEXTARGET ID="8.TLI1"><!-- POSTPROCESSDATA: 8.TLI1|STREAMS --></PARAGRAPH>
<PARAGRAPH>Network Selection and Name-to-Address Mapping facilities have been added to TLI to provide a means of guaranteeing media and protocol independence for transport applications. Network Selection and Name-to-Address Mapping allow network applications to acquire transport-specific information in a transport-independent way.<INDEXTARGET ID="8.TLI2"><!-- POSTPROCESSDATA: 8.TLI2|Network Selection --><INDEXTARGET ID="8.TLI3"><!-- POSTPROCESSDATA: 8.TLI3|Name-to-Address Mappingmapping, name to address --></PARAGRAPH>
<PARAGRAPH>The following discussion assumes that you have a working knowledge of IRIX, C language programming, and data communication concepts. You should also be familiar with ISO-OSI before reading this chapter.<INDEXTARGET ID="8.TLI4"><!-- POSTPROCESSDATA: 8.TLI4|OSI (Open Systems Interconnection)Open Systems Interconnection --></PARAGRAPH>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE>Network Selection and Name-to-Address Mapping</TITLE><PARAGRAPH>If TLI applications are to be media- and protocol-independent, they require an understanding of Network Selection and Name-to-Address Mapping facilities. The Network Selection routines in <FILENAME>libnsl.so</FILENAME> provide a standard interface to the networks available in any environment. Name-to-Address Mapping allows applications to translate transport-specific addresses. The following manual pages give more information on these topics:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><FUNCTION>getnetconfig()</FUNCTION></HANGITEM>
<HANGBODY><PARAGRAPH>describes the <FILENAME>libnsl.so</FILENAME> routines that manipulate the network configuration administrative file, <FILENAME>netconfig</FILENAME>. For more information, see <REFPAGE>getnetconfig(3N)</REFPAGE>.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><FUNCTION>getnetpath()</FUNCTION></HANGITEM>
<HANGBODY><PARAGRAPH>describes the routines that manipulate the NETPATH variable, allowing you to specify which networks in the <FILENAME>netconfig</FILENAME> file to try. For more information, see <REFPAGE>getnetpath(3N)</REFPAGE>.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><FUNCTION>netconfig()</FUNCTION></HANGITEM>
<HANGBODY><PARAGRAPH>describes the network configuration database file. For more information, see <REFPAGE>netconfig(4)</REFPAGE>.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><FUNCTION>netdir()</FUNCTION></HANGITEM>
<HANGBODY><PARAGRAPH>describes the Name-to-Address Mapping library functions. For more information, see <REFPAGE>netdir(3N)</REFPAGE>.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<NOTE><PREFIX>Note</PREFIX><FILENAME>libnsl</FILENAME>, the Network Selection library, should not be confused with <FILENAME>libnls</FILENAME>, the network license server library.</NOTE>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE>OSI Reference Model</TITLE><PARAGRAPH>This section discusses the Reference Model to place the Transport Interface in perspective. The Reference Model partitions networking functions into seven layers, as depicted in <INDEXTARGET ID="8.TLI5"><!-- POSTPROCESSDATA: 8.TLI5|transport interface:reference modelreference model (transport interface) --><XREF IDREF="51208" TYPE="GRAPHIC">Figure&nbsp;8-1</XREF>.</PARAGRAPH>
<!-- RASTERCONVERT: 8.TLI.cgm -->
<PARAGRAPH><FIGURE><GRAPHIC FILE="8.TLI-1.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="8-1"><PREFIX>Figure 8-1 </PREFIX><XREFTARGET ID="51208">OSI Reference Model</CAPTION>
</FIGURE>
</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>Layer 1</HANGITEM>
<HANGBODY><PARAGRAPH>The physical layer is responsible for the transmission of raw data over a communication medium.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>Layer 2</HANGITEM>
<HANGBODY><PARAGRAPH>The data-link layer provides the exchange of data between network layer entities. It detects and corrects any errors that may occur in the physical layer transmission.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>Layer 3</HANGITEM>
<HANGBODY><PARAGRAPH>The network layer manages the operation of the network. In particular, it is responsible for the routing and management of data exchange between transport layer entities within the network.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>Layer 4</HANGITEM>
<HANGBODY><PARAGRAPH>The transport layer provides transparent data transfer services between session layer entities, thereby relieving them of concerns about how to achieve reliable and cost-effective transfer of data.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>Layer 5</HANGITEM>
<HANGBODY><PARAGRAPH>The session layer provides the services needed by presentation layer entities that enable them to organize and synchronize their dialogue and manage their data exchange.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>Layer 6</HANGITEM>
<HANGBODY><PARAGRAPH>The presentation layer manages the representation of information that application layer entities either communicate or reference in their communication.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>Layer 7</HANGITEM>
<HANGBODY><PARAGRAPH>The application layer serves as the window between corresponding application processes that are exchanging information.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>A basic principle of the Reference Model is that each layer provides services needed by the next higher layer in a way that frees the upper layer from concern about how these services are provided. This approach simplifies the design of each particular layer.</PARAGRAPH>
<PARAGRAPH>Industry standards have been defined (or are being defined) at each layer of the Reference Model. Two standards are defined at each layer: one that specifies an interface to the services of the layer (to be used when interacting with other layers) and one that defines the protocol by which services are provided (used by each instance of the current layer, as shown in <XREF IDREF="51208" TYPE="GRAPHIC">Figure&nbsp;8-1</XREF>). A service interface standard at any layer frees users of the service from details of how that layer's protocol is implemented, or even which protocol is used to provide the service.</PARAGRAPH>
<PARAGRAPH>The transport layer is important because it is the lowest layer in the Reference Model that provides the basic service of reliable, end-to-end data transfer needed by applications and higher-layer protocols. In doing so, this layer hides the topology and characteristics of the underlying network from its users. More important, however, the transport layer defines a set of services common to layers of many contemporary protocol suites, including the International Standards Organization (ISO) protocols, the Transmission Control Protocol and Internet Protocol (TCP/IP) of the Internet, and the Systems Network Architecture (SNA).</PARAGRAPH>
<PARAGRAPH>A transport service interface, then, enables applications and higher layer protocols to be implemented without knowledge of the underlying protocol stack. That is a principal goal of the Transport Interface. Also, because an inherent characteristic of the transport layer is that it hides details of the physical medium being used, the Transport Interface offers both protocol and medium independence to networking applications and higher layer protocols.</PARAGRAPH>
<PARAGRAPH>The Transport Interface was modeled after the industry standard ISO Transport Service Definition (ISO 8072). As such, it is intended for those applications and protocols that require transport services. Because the Transport Interface provides reliable data transfer, and because its services are common to several protocol suites, many networking applications will find these services useful.</PARAGRAPH>
<PARAGRAPH>The Transport Interface is implemented as a user library using the STREAMS input/output mechanism. Therefore, many services available to STREAMS applications are also available to users of the Transport Interface. These services will be highlighted throughout this guide. For detailed information about STREAMS, refer to any generic UNIX SVR4 document set.<INDEXTARGET ID="8.TLI6"><!-- POSTPROCESSDATA: 8.TLI6|STREAMS --></PARAGRAPH>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="90505">Overview of the Transport Interface</TITLE><PARAGRAPH>This section presents a high-level overview of the services of the Transport Interface, which supports the transfer of data between two user processes. <XREF IDREF="74790" TYPE="GRAPHIC">Figure&nbsp;8-2</XREF> illustrates the Transport Interface. </PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="Fig8.2.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="8-2"><PREFIX>Figure 8-2 </PREFIX><XREFTARGET ID="74790">Transport Interface</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>The transport provider is the entity that provides the services of the Transport Interface, and the transport user is the entity that requires these services. An example of a transport provider is ISO 8073 (the OSI transport protocol), while a transport user can be a networking application or session layer protocol.</PARAGRAPH>
<PARAGRAPH>The transport user accesses the services of the transport provider by issuing the appropriate service requests. One example is a request to transfer data over a connection. Similarly, the transport provider notifies the user of various events, such as the arrival of data on a connection.</PARAGRAPH>
<PARAGRAPH>The Network Services Library includes a set of functions that support the services of the Transport Interface for user processes.</PARAGRAPH>
<PARAGRAPH>These functions enable a user to make requests to the provider and process incoming events. Programs using the Transport Interface can link the appropriate routines from the Network Services Library by using the <INDEXTARGET ID="8.TLI7"><!-- POSTPROCESSDATA: 8.TLI7|Network Services Library --><CMDLINEOPT>&ndash;lnsl</CMDLINEOPT> command-line option to <COMMAND>cc</COMMAND>.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Modes of Service</TITLE><PARAGRAPH>The Transport Interface provides two modes of service: connection mode and connectionless mode.<INDEXTARGET ID="8.TLI8"><!-- POSTPROCESSDATA: 8.TLI8|modes of service (transport interface) --></PARAGRAPH>
<PARAGRAPH>Connection mode is circuit-oriented and enables the transmission of data over an established connection in a reliable, sequenced manner. It also provides an identification procedure that avoids the overhead of address resolution and transmission during the data transfer phase. This service is attractive for applications that require relatively long-lived, datastream-oriented interactions. Connection-mode service is analogous to BSD's &ldquo;stream sockets&rdquo; (as opposed to datagram sockets), which provide a stream of data instead of isolated data units.</PARAGRAPH>
<PARAGRAPH>Connectionless mode, by contrast, is message-oriented and supports data transfer in self-contained units with no logical relationship required among multiple units. This service requires only a preexisting association between the peer users involved, which determines the characteristics of the data to be transmitted. This mode corresponds to sending datagrams in the sockets paradigm. All the information required to deliver a unit of data (for example, the destination address) is presented to the transport provider, together with the data to be transmitted, in one service access (which need not relate to any other service access). Each unit of data transmitted is entirely self-contained, like datagrams transmitted through BSD datagram sockets. Connectionless-mode service is attractive for applications that:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>involve short-term request/response interactions</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>exhibit a high level of redundancy</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>are dynamically reconfigurable</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>do not require guaranteed, in-sequence delivery of data</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION3 LBL="" HELPID = ""><TITLE>Connection-Mode Service</TITLE><PARAGRAPH>The connection-mode transport service is characterized by four phases: <INDEXTARGET ID="8.TLI9"><!-- POSTPROCESSDATA: 8.TLI9|connection-mode transport servicetransport service:connection mode --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>local management </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>connection establishment </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>data transfer </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>connection release </PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Local Management</TITLE><PARAGRAPH>The local management phase defines local operations between a transport user and a transport provider. For example, a user must establish a channel of communication with the transport provider, as illustrated in <XREF IDREF="34387" TYPE="GRAPHIC">Figure&nbsp;8-3</XREF>. Each channel between a transport user and transport provider is a unique endpoint of communication, and is called the transport endpoint. The <FUNCTION>t_open()</FUNCTION> routine (see <REFPAGE>t_open(3)</REFPAGE>) enables a user to choose a particular transport provider that supplies the connection-mode service, and establishes the transport endpoint.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="Fig8.3.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="8-3"><PREFIX>Figure 8-3 </PREFIX><XREFTARGET ID="34387">Channel between User and Provider</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>Another necessary local function for each user is to establish an identity with the transport provider. Each user is identified by a transport address. More accurately, a transport address is associated with each transport endpoint, and one user process can manage several transport endpoints. In connection-mode service, one user requests a connection to another user by specifying that user's address. The structure of a transport address is defined by the address space of the transport provider. An address can be anything from a simple character string (such as &ldquo;file_server&rdquo;) to an encoded bit pattern that specifies all information needed to route data through a network. Each transport provider defines its own mechanism for identifying users. Addresses can be assigned to each transport endpoint by <FUNCTION>t_bind()</FUNCTION>.</PARAGRAPH>
<PARAGRAPH>In addition to <FUNCTION>t_open()</FUNCTION> and <FUNCTION>t_bind()</FUNCTION>, several routines are available to support local operations. <XREF IDREF="62871" TYPE="TABLE">Table&nbsp;8-1</XREF> summarizes all local management routines of the Transport Interface.</PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="8-1"><PREFIX>Table 8-1 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="62871">Local Management Routines for the Transport Interface</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Routine</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="306"><PARAGRAPH>Description</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_alloc()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="306"><PARAGRAPH>Allocates Transport Interface data structures </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_bind()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="306"><PARAGRAPH>Binds a transport address to a transport endpoint </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_close()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="306"><PARAGRAPH>Closes a transport endpoint </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_error()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="306"><PARAGRAPH>Prints a Transport Interface error message </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_free()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="306"><PARAGRAPH>Frees structures allocated using <FUNCTION>t_alloc() </FUNCTION></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_getinfo()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="306"><PARAGRAPH>Returns a set of parameters associated with a particular transport provider </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_getstate()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="306"><PARAGRAPH>Returns the state of a transport endpoint </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_look()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="306"><PARAGRAPH>Returns the current event on a transport endpoint </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_open()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="306"><PARAGRAPH>Establishes a transport endpoint connected to a chosen transport provider </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_optmgmt()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="306"><PARAGRAPH>Negotiates protocol-specific options with the transport provider </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_sync()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="306"><PARAGRAPH>Synchronizes a transport endpoint with the transport provider </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_unbind()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="306"><PARAGRAPH>Unbinds a transport address from a transport endpoint </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Connection Establishment</TITLE><PARAGRAPH>The connection establishment phase enables two users to create a connection, or virtual circuit, between them, as demonstrated in <XREF IDREF="96312" TYPE="GRAPHIC">Figure&nbsp;8-4</XREF>.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="Fig8.4.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="8-4"><PREFIX>Figure 8-4 </PREFIX><XREFTARGET ID="96312">Transport Connection</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>This phase is illustrated in the following description of a client/server relationship. The client application and the server application are users of their respective transport providers. One user, the server, typically advertises some service to a group of users, and then listens for requests from those users. When a client requires the service, the client attempts to connect itself to the server using the server's advertised transport address. The <FUNCTION>t_connect()</FUNCTION> routine (see <REFPAGE>t_connect(3N)</REFPAGE>) initiates the connect request. One argument to <FUNCTION>t_connect()</FUNCTION>, the transport address, identifies the server the client wishes to access. The server is notified of each incoming request using <FUNCTION>t_listen()</FUNCTION> and can call <FUNCTION>t_accept()</FUNCTION> (see <REFPAGE>t_listen(3N)</REFPAGE> and <REFPAGE>t_accept(3N)</REFPAGE>) to accept the client's request for access to the service. If the request is accepted, the transport connection is established.</PARAGRAPH>
<PARAGRAPH><XREF IDREF="69631" TYPE="TABLE">Table&nbsp;8-2</XREF> summarizes all routines available for establishing a transport connection.</PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="8-2"><PREFIX>Table 8-2 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="69631">Routines for Establishing a Transport Connection</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Routine</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="306"><PARAGRAPH>Description</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_accept</FUNCTION><FUNCTION>()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="306"><PARAGRAPH>Accepts a request for a transport connection </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_connect</FUNCTION><FUNCTION>()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="306"><PARAGRAPH>Establishes a connection with the transport user at a specified destination </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_listen</FUNCTION><FUNCTION>()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="306"><PARAGRAPH>Retrieves an indication of a connect request from another transport user </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_rcvconnect</FUNCTION><FUNCTION>()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="306"><PARAGRAPH>Completes connection establishment if <FUNCTION>t_connect()</FUNCTION> was called in 
asynchronous mode (see <XREF IDREF="80913" TYPE="TITLE">&ldquo;Advanced Topics&rdquo;</XREF>) </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Data Transfer</TITLE><PARAGRAPH>The data transfer phase enables users to transfer data in both directions over an established connection. Two routines, <FUNCTION>t_snd()</FUNCTION> and <FUNCTION>t_rcv()</FUNCTION>, send and receive data over this connection. All data sent by a user is guaranteed to be delivered to the user on the other end of the connection in the order in which it was sent. <XREF IDREF="91307" TYPE="TABLE">Table&nbsp;8-3</XREF> summarizes the connection-mode data transfer routines.</PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="8-3"><PREFIX>Table 8-3 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="91307">Connection-Mode Data Transfer Routines</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Routine</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="252"><PARAGRAPH>Description</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_rcv</FUNCTION><FUNCTION>()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="252"><PARAGRAPH>Retrieves data that has arrived over a transport connection </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_snd</FUNCTION><FUNCTION>()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="252"><PARAGRAPH>Sends data over an established transport connection </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Connection Release</TITLE><PARAGRAPH>The connection release phase allows you to break an established connection. When you decide that a conversation should end, you can request that the provider release the transport connection. Two types of connection release are supported by the Transport Interface. The first is an abortive release, which directs the transport provider to release the connection immediately. Any previously sent data that has not yet reached the other transport user can be discarded by the transport provider. The <FUNCTION>t_snddis()</FUNCTION> routine initiates this abortive disconnect, and <FUNCTION>t_rcvdis()</FUNCTION> processes the incoming indication for an abortive disconnect.</PARAGRAPH>
<PARAGRAPH>All transport providers must support the abortive release procedure. In addition, some transport providers can also support an orderly release facility that enables users to terminate communication gracefully with no data loss. The functions <FUNCTION>t_sndrel()</FUNCTION> and <FUNCTION>t_rcvrel()</FUNCTION> support this capability. <XREF IDREF="30897" TYPE="TABLE">Table&nbsp;8-4</XREF> summarizes the connection release routines.</PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="8-4"><PREFIX>Table 8-4 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="30897">Connection Release Routines</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Routine</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="252"><PARAGRAPH>Description</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_rcvdis</FUNCTION><FUNCTION>()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="252"><PARAGRAPH>Returns an indication of an aborted connection, including a 
reason code and user data</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_rcvrel</FUNCTION><FUNCTION>()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="252"><PARAGRAPH>Returns an indication that the other transport user has 
requested an orderly release of a connection</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_snddis</FUNCTION><FUNCTION>()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="252"><PARAGRAPH>Aborts a connection or rejects a connect request</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_sndrel</FUNCTION><FUNCTION>()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="252"><PARAGRAPH>Requests the orderly release of a connection</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Connectionless-Mode Service</TITLE><PARAGRAPH>The connectionless-mode transport service is characterized by two phases: local management and data transfer. The local management phase defines the same local operations described above for the connection-mode service.<INDEXTARGET ID="8.TLI10"><!-- POSTPROCESSDATA: 8.TLI10|connectionless-mode transport servicetransport service:connectionless-mode --></PARAGRAPH>
<PARAGRAPH>The data transfer phase enables a user to transfer data units (sometimes called datagrams) to the specified peer user. Each data unit must be accompanied by the transport address of the receiver. Two routines, <FUNCTION>t_sndudata()</FUNCTION> and <FUNCTION>t_rcvudata()</FUNCTION>, support this message-based data transfer facility, while another routine, <FUNCTION>t_rcvuderr()</FUNCTION>, allows retrieval of error messages. (For more information, see <REFPAGE>t_sndudata(3N)</REFPAGE>, <REFPAGE>t_rcvudata(3N)</REFPAGE>, and <REFPAGE>t_rcvuderr(3N)</REFPAGE>.) <XREF IDREF="81991" TYPE="TABLE">Table&nbsp;8-5</XREF> summarizes all routines associated with connectionless-mode data transfer.</PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="8-5"><PREFIX>Table 8-5 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="81991">Routines for Connectionless-Mode Data Transfer</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Routine</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="252"><PARAGRAPH>Description</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_rcvudata</FUNCTION><FUNCTION>()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="252"><PARAGRAPH>Retrieves a message sent by another transport user</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_rcvuderr()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="252"><PARAGRAPH>Retrieves error information associated with a previously sent 
message</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><FUNCTION>t_sndudata</FUNCTION><FUNCTION>()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="252"><PARAGRAPH>Sends a message to the specified destination user</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>State Transitions</TITLE><PARAGRAPH>The Transport Interface has two components: </PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>the library routines that provide the transport services to users </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the state transition rules that define the sequence in which the transport routines can be invoked </PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The state transition rules can be found in the state tables under <INDEXTARGET ID="8.TLI11"><!-- POSTPROCESSDATA: 8.TLI11|state transition rules --><XREF IDREF="39217" TYPE="TITLE">&ldquo;State Transitions&rdquo;</XREF>. The state tables define the legal sequence of library calls based on state information and the handling of events. These events include user-generated library calls, as well as provider-generated event indications.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>Any user of the Transport Interface must completely understand all possible state transitions before writing software using the interface.</NOTE>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="15433">Introduction to Connection-Mode Service</TITLE><PARAGRAPH>This section describes the connection-mode service of the Transport Interface. As discussed in the previous section, the connection-mode service can be illustrated using a client/server paradigm. The important concepts of connection-mode service are presented using two programming examples. The examples are related: <XREF IDREF="44605" TYPE="TEXT">Example&nbsp;8-1</XREF> illustrates how a client establishes a connection to a server and then communicates with it, while <XREF IDREF="20590" TYPE="TEXT">Example&nbsp;8-2</XREF> shows the server's side of the interaction. All code-fragment examples discussed in this chapter are presented as complete programs in <XREF IDREF="16101" TYPE="TITLE">&ldquo;Some Examples&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>In the examples, the client establishes a connection with a server process. The server then transfers a file to the client. The client, in turn, receives the data from the server and writes it to its standard output file.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="19084">Local Management</TITLE><PARAGRAPH>Before the client and server can establish a transport connection, each must first establish a local channel (the transport endpoint) to the transport provider using <INDEXTARGET ID="8.TLI12"><!-- POSTPROCESSDATA: 8.TLI12|transport interface:local managementlocal management (transport interface) --><FUNCTION>t_open()</FUNCTION> and establish its identity (or address) using <FUNCTION>t_bind()</FUNCTION>.</PARAGRAPH>
<PARAGRAPH>The set of services supported by the Transport Interface may not be implemented by all transport protocols. Each transport provider has a set of characteristics associated with it that determines the services it offers and the limits associated with those services. This information is returned to the user by <FUNCTION>t_open()</FUNCTION> and consists of the following:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><VARIABLE>addr</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>maximum size of a transport address</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>options</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>maximum bytes of protocol-specific options that can be passed between the transport user and transport provider</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>tsdu</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>maximum message size that can be transmitted</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>etsdu</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>maximum expedited data message size that can be sent over a transport connection</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>connect</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>maximum number of bytes of user data that can be passed between users during connection establishment</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>discon</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>maximum number of bytes of user data that can be passed between users during the abortive release of a connection</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>servtype</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>type of service supported by the transport provider</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>The three service types (<ITALICS>servtype</ITALICS>) defined by the Transport Interface are as follows:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>T_COTS</HANGITEM>
<HANGBODY><PARAGRAPH>The transport provider supports connection-mode service but does not provide the optional orderly release facility.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>T_COTS_ORD</HANGITEM>
<HANGBODY><PARAGRAPH>The transport provider supports connection-mode service with the optional orderly release facility.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>T_CLTS</HANGITEM>
<HANGBODY><PARAGRAPH>The transport provider supports connectionless-mode service. Only one such service can be associated with the transport provider identified by <FUNCTION>t_open()</FUNCTION>.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<NOTE><PREFIX>Note</PREFIX><FUNCTION>t_open()</FUNCTION> returns the default provider characteristics associated with a transport endpoint. However, some characteristics can change after an endpoint has been opened. This occurs if the characteristics are associated with negotiated options (option negotiation is described later in this section). For example, if the support of expedited data transfer is a negotiated option, the value of this characteristic can change.<FUNCTION>&space;t_getinfo()</FUNCTION> can be called to retrieve the current characteristics of a transport endpoint.</NOTE>
<PARAGRAPH>Once a user establishes a transport endpoint with the chosen transport provider, it must establish its identity. As mentioned earlier, <FUNCTION>t_bind()</FUNCTION> does this by binding a transport address to the transport endpoint. In addition, for servers, this routine informs the transport provider that the endpoint will be used to listen for incoming connect indications, also called connect requests.</PARAGRAPH>
<PARAGRAPH>An optional facility, <FUNCTION>t_optmgmt()</FUNCTION> (see <REFPAGE>t_optmgmt(3N)</REFPAGE>), is also available during the local management phase. It enables a user to negotiate the values of protocol options with the transport provider. Each transport protocol is expected to define its own set of negotiable protocol options, which can include such information as Quality-of-Service parameters. Because of the protocol-specific nature of options, only applications written for a particular protocol environment are expected to use this facility.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>The Client</TITLE><PARAGRAPH>The local management requirements of the example client and server are used to discuss details of these facilities following each example. The following are the definitions needed by the client program, followed by its necessary local management steps:</PARAGRAPH>

<!-- WARNING: (47) Example captions should come at end of Example - detected on page 201 -->
<!-- WARNINGLOCATION: PAGE = "201" SRC = "8.TLI.mif" TAGTYPE = "PARA" TAG = "ExampleTitle" TAGCOUNT = "1" UID = "840" TEXT = "The local management requ"-->
<EXAMPLE><CAPTION LBL="8-1"><PREFIX>Example 8-1 </PREFIX><XREFTARGET ID="44605">The Connection-Mode Client Definitions and Local Management</CAPTION></EXAMPLE>
<CODE>
#include &lt;stdio.h>
#include &lt;tiuser.h>
#include &lt;fcntl.h>

#define SRV_ADDR  1     /* server's well-known address */

void main() 
{
&space;   int fd;
&space;   int nbytes;
&space;   int flags = 0;
&space;   char buf[1024];
&space;   struct t_call *sndcall;
&space;   extern int t_errno;
if ((fd = t_open("/dev/ticotsord", O_RDWR, NULL)) &lt; 0) {
&space;       t_error("t_open failed");
&space;       exit(1);
&space;   } 

&space;   if (t_bind(fd, NULL, NULL) &lt; 0) {
&space;       t_error("t_bind failed");
&space;       exit(2);
&space;   }
</CODE>
<PARAGRAPH>The first argument to<FUNCTION>&space;t_open()</FUNCTION> is the pathname of a filesystem node that identifies the transport protocol that supplies the transport service. In this example, <FILENAME>/dev/ticotsord</FILENAME> is a STREAMS clone device node that identifies a generic, connection-based transport protocol (see <REFPAGE>clone(7)</REFPAGE>). The <ITALICS>clone</ITALICS> device finds an available minor device of the transport provider for the user. It is opened for both reading and writing, as specified by the <VARIABLE>O_RDWR</VARIABLE> flag passed as the second argument. The third argument can be used to return the service characteristics of the transport provider to the user. This information is useful when writing protocol-independent software (discussed in <XREF IDREF="17225" TYPE="TITLE">&ldquo;Guidelines for Protocol Independence&rdquo;</XREF>). For simplicity, the client and server in this example ignore this information and assume the transport provider has the following characteristics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The transport address is an integer value that uniquely identifies each user.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The transport provider supports the T_COTS_ORD service type, and the example uses the orderly release facility to release the connection.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>User data cannot be passed between users during either connection establishment or abortive release.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The transport provider does not support protocol-specific options.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Because these characteristics are not needed by the user, NULL is specified in the third argument to <FUNCTION>t_open()</FUNCTION>. If the user were to require a service other than T_COTS_ORD, another transport provider would be opened. An example of the T_CLTS service invocation is presented in <XREF IDREF="60724" TYPE="TITLE">&ldquo;Introduction to Connectionless-Mode Service&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>The return value of <FUNCTION>t_open()</FUNCTION> is an identifier for the transport endpoint that is used by all subsequent Transport Interface function calls. This identifier is actually a file descriptor obtained by opening the transport protocol file (see <REFPAGE>open(2)</REFPAGE>). The significance of this fact is highlighted in <XREF IDREF="77708" TYPE="TITLE">&ldquo;A Read/Write Interface&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>After the transport endpoint is created, the client calls <FUNCTION>t_bind()</FUNCTION> to assign an address to the endpoint. The first argument identifies the transport endpoint. The second argument describes the address the user would like to bind to the endpoint, and the third argument is set on return from <FUNCTION>t_bind()</FUNCTION> to specify the address that the provider bound.</PARAGRAPH>
<PARAGRAPH>The address associated with a server's transport endpoint is important, because that is the address used by all clients to access the server. However, the typical client does not care what its own address is, because no other process tries to access it. That is the case in this example, where the second and third arguments to <FUNCTION>t_bind()</FUNCTION> are set to NULL. A NULL second argument directs the transport provider to choose an address for the user. A NULL third argument specifies that the user does not care what address was assigned to the endpoint.</PARAGRAPH>
<PARAGRAPH>If either <FUNCTION>t_open()</FUNCTION> or <FUNCTION>t_bind()</FUNCTION> fails, the program calls <FUNCTION>t_error()</FUNCTION> (see <REFPAGE>t_error(3N)</REFPAGE>) to print an appropriate error message to <VARIABLE>stderr</VARIABLE>. If any Transport Interface routine fails, the global integer <VARIABLE>t_errno</VARIABLE> is assigned a transport error value. A set of error values is defined (in &lt;<FILENAME>tiuser.h</FILENAME>>) for the Transport Interface, and <FUNCTION>t_error()</FUNCTION> prints an error message corresponding to the value in <VARIABLE>t_errno</VARIABLE>. This routine is analogous to <FUNCTION>perror()</FUNCTION>, which prints an error message based on the value of <VARIABLE>errno </VARIABLE>(see <REFPAGE>perror(3)</REFPAGE>). If the error associated with a transport function is a system error, <VARIABLE>t_errno</VARIABLE> is set to TSYSERR, and <VARIABLE>errno</VARIABLE> is set to the appropriate value.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>The Server</TITLE><PARAGRAPH>The server in <XREF IDREF="20590" TYPE="TEXT">Example&nbsp;8-2</XREF> must take similar local management steps before communication can begin. The server must establish a transport endpoint through which it listens for connect indications. The necessary definitions and local management steps are shown in <XREF IDREF="20590" TYPE="TEXT">Example&nbsp;8-2</XREF>.</PARAGRAPH>

<!-- WARNING: (47) Example captions should come at end of Example - detected on page 203 -->
<!-- WARNINGLOCATION: PAGE = "203" SRC = "8.TLI.mif" TAGTYPE = "PARA" TAG = "ExampleTitle" TAGCOUNT = "1" UID = "706" TEXT = "."-->
<EXAMPLE><CAPTION LBL="8-2"><PREFIX>Example 8-2 </PREFIX><XREFTARGET ID="20590">The Connection-Mode Server Definitions and Local Management</CAPTION></EXAMPLE>
<CODE>
#include &lt;tiuser.h>
#include &lt;stropts.h>
#include &lt;fcntl.h>
#include &lt;stdio.h>
#include &lt;signal.h>

#define DISCONNECT -1
#define SRV_ADDR  1   /* server's well-known address */

int conn_fd;             /* connection established here */
extern int t_errno;

void main()
{
&space;   int listen_fd;        /* listening transport endpoint */
&space;   struct t_bind *bind;
&space;   struct t_call *call;

&space;   if ((listen_fd = t_open("/dev/ticotsord", O_RDWR, NULL))
&space;       &lt; 0) {
&space;       t_error("t_open failed for listen_fd");
&space;       exit(1);
&space;   }

&space;   /*
&space;    * By assuming that the address is an integer value,
&space;    * this program may not run over another protocol.
&space;    */

&space;   if ((bind = (struct t_bind *)t_alloc(listen_fd,
&space;       T_BIND, T_ALL))== NULL) {
&space;       t_error("t_alloc of t_bind structure failed");
&space;       exit(2);
&space;   } 

&space;   bind->qlen = 1;
&space;   bind->addr.len = sizeof(int);

&space;   *(int *)bind->addr.buf = SRV_ADDR;

&space;   if (t_bind(listen_fd, bind, bind) &lt; 0)  {
&space;       t_error("t_bind failed for listen_fd");
&space;       exit(3);
&space;   } 

&space;   /* Was the correct address bound? */
&space;   if (*(int *)bind->addr.buf != SRV_ADDR)  {
&space;       fprintf(stderr, "t_bind bound wrong address\n");
&space;       exit(4);
&space;   }
</CODE>
<PARAGRAPH>As with the client, the first step is to call <FUNCTION>t_open()</FUNCTION> to establish a transport endpoint with the desired transport provider. This endpoint, <VARIABLE>listen_fd</VARIABLE>, is used to listen for connect indications. Next, the server must bind its well-known address to the endpoint. This address is used by each client to access the server. The second argument to <FUNCTION>t_bind()</FUNCTION> requests that a particular address be bound to the transport endpoint. This argument points to a <VARIABLE>t_bind</VARIABLE> structure with the following format:</PARAGRAPH>
<CODE>
struct t_bind {
&space;   struct netbuf addr;
&space;   unsigned qlen;
}
</CODE>
<PARAGRAPH><VARIABLE>addr</VARIABLE> describes the address to be bound, and <VARIABLE>qlen</VARIABLE> specifies the maximum outstanding connect indications that can arrive at this endpoint. All Transport Interface structure and constant definitions are found in &lt;<FILENAME>tiuser.h</FILENAME>>.</PARAGRAPH>
<PARAGRAPH>The address is specified using a <VARIABLE>netbuf</VARIABLE> structure that contains the following members:</PARAGRAPH>
<CODE>
struct netbuf {
&space;   unsigned int maxlen;
&space;   unsigned int len;
&space;   char *buf;
}
</CODE>
<PARAGRAPH><VARIABLE>buf</VARIABLE> points to a buffer containing the data, <VARIABLE>len</VARIABLE> specifies the number of bytes of data in the buffer, and <VARIABLE>maxlen</VARIABLE> specifies the maximum number of bytes the buffer can hold (and need only be set when data is returned to the user by a Transport Interface routine). For the <VARIABLE>t_bind</VARIABLE> structure, the data pointed to by <VARIABLE>buf</VARIABLE> identifies a transport address. The structure of addresses is likely to vary between protocol implementations under the Transport Interface; the <VARIABLE>netbuf</VARIABLE> structure is intended to support any address structure.</PARAGRAPH>
<PARAGRAPH>If the value of <VARIABLE>qlen</VARIABLE> is greater than 0, the transport endpoint can be used to listen for connect indications. In such cases, <FUNCTION>t_bind()</FUNCTION> directs the transport provider to begin queueing connect indications destined for the bound address immediately. Furthermore, the value of <VARIABLE>qlen</VARIABLE> specifies the maximum outstanding connect indications the server wishes to process. The server must respond to each connect indication, either accepting or rejecting the request for connection. An outstanding connect indication is one to which the server has not yet responded. Often, a server fully processes a single connect indication and responds to it before receiving the next indication. When this occurs, a value of 1 is appropriate for <VARIABLE>qlen</VARIABLE>. However, some servers may wish to retrieve several connect indications before responding to any of them. In such cases, <VARIABLE>qlen</VARIABLE> specifies the maximum number of outstanding indications the server processes. An example of a server that manages multiple outstanding connect indications is presented in <XREF IDREF="80913" TYPE="TITLE">&ldquo;Advanced Topics&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH><FUNCTION>t_alloc()</FUNCTION> is called to allocate the <VARIABLE>t_bind</VARIABLE> structure needed by <FUNCTION>t_bind()</FUNCTION>. <FUNCTION>t_alloc()</FUNCTION> takes three arguments. The first is a file descriptor that references a transport endpoint. This is used to access the characteristics of the transport provider (see <REFPAGE>t_open(3N)</REFPAGE>). The second argument identifies the appropriate Transport Interface structure to be allocated. The third argument specifies which, if any, <VARIABLE>netbuf</VARIABLE> buffers should be allocated for that structure. T_ALL specifies that all <VARIABLE>netbuf</VARIABLE> buffers associated with the structure should be allocated, and causes the <VARIABLE>addr</VARIABLE> buffer to be allocated in this example. The size of this buffer is determined from the transport provider characteristic that defines the maximum address size. The <VARIABLE>maxlen</VARIABLE> field of this <VARIABLE>netbuf</VARIABLE> structure is set to the size of the buffer allocated by <FUNCTION>t_alloc()</FUNCTION>. The use of <FUNCTION>t_alloc()</FUNCTION> helps ensure the compatibility of user programs with future releases of the Transport Interface.</PARAGRAPH>
<PARAGRAPH>The server in this example processes connect indications one at a time, so <VARIABLE>qlen</VARIABLE> is set to 1. The address information is then assigned to the newly allocated <VARIABLE>t_bind</VARIABLE> structure. This <VARIABLE>t_bind</VARIABLE> structure is passed to <FUNCTION>t_bind()</FUNCTION> as both the second and third arguments; as the second argument, it contains information for <FUNCTION>t_bind()</FUNCTION>, while as the third argument, it returns information to the user.</PARAGRAPH>
<PARAGRAPH>On return, the <VARIABLE>t_bind</VARIABLE> structure contains whatever address was bound to the transport endpoint. If the provider can't bind the requested address (perhaps because it's already bound to another transport endpoint), it returns another appropriate address.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>Each transport provider manages its address space differently. Some transport providers can allow a single transport address to be bound to several transport endpoints, while others can require a unique address per endpoint. The Transport Interface supports either choice. Based on its address management rules, a provider determines if it can bind the requested address. If not, it chooses another valid address from its address space and binds it to the given transport endpoint.</NOTE>
<PARAGRAPH>The server must check the bound address to ensure that it is the one previously advertised to clients. Otherwise, the clients are unable to reach the server.</PARAGRAPH>
<PARAGRAPH>If <FUNCTION>t_bind()</FUNCTION> succeeds, the provider begins queueing connect indications, entering the next phase of communication, connection establishment.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Connection Establishment</TITLE><PARAGRAPH>The connection establishment procedures highlight the distinction between clients and servers. The Transport Interface imposes a different set of procedures in this phase for each type of transport user. The client starts the connection establishment procedure by requesting a connection to a particular server using <INDEXTARGET ID="8.TLI13"><!-- POSTPROCESSDATA: 8.TLI13|connection establishment:transport interfacetransport interface:connection establishment --><FUNCTION>t_connect()</FUNCTION>. The server is then notified of the client's request by calling <FUNCTION>t_listen()</FUNCTION>. The server can either accept or reject the client's request. It calls <FUNCTION>t_accept()</FUNCTION> to establish the connection, or calls <FUNCTION>t_snddis() </FUNCTION>to reject the request. The client is notified of the server's decision when <FUNCTION>t_connect()</FUNCTION> completes. For more information, see <REFPAGE>t_connect(3N)</REFPAGE>, <REFPAGE>t_listen(3N)</REFPAGE>, <REFPAGE>t_accept(3N)</REFPAGE>, and <REFPAGE>t_snddis(3N)</REFPAGE>.</PARAGRAPH>
<PARAGRAPH>The Transport Interface supports two facilities during connection establishment that are not necessarily supported by all transport providers:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The ability to transfer data between the client and server when establishing the connection.</PARAGRAPH>
<PARAGRAPH>The client can send data to the server when it requests a connection. This data is passed to the server by <FUNCTION>t_listen()</FUNCTION>. Similarly, the server can send data to the client when it accepts or rejects the connection. The connect characteristic returned by <FUNCTION>t_open()</FUNCTION> determines how much data, if any, two users can transfer during connect establishment.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The negotiation of protocol options.</PARAGRAPH>
<PARAGRAPH>The client can specify protocol options that it would like the transport provider and/or the other user to support. The Transport Interface supports both local and remote option negotiation. As discussed earlier, option negotiation is inherently a protocol-specific function. If you want protocol-independent software, you should not use this facility (see <XREF IDREF="17225" TYPE="TITLE">&ldquo;Guidelines for Protocol Independence&rdquo;</XREF>).</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION3 LBL="" HELPID = ""><TITLE>The Client</TITLE><PARAGRAPH>Continuing with the client/server example, the steps needed by the client to establish a connection are as follows:</PARAGRAPH>
<CODE>
/* Since it assumes that the address is an integer value,
&space;* this program may not run over another protocol.
&space;*/ 
if ((sndcall = (struct t_call *)t_alloc(fd, T_CALL, T_ADDR)) == NULL) {
&space;   t_error("t_alloc failed");
&space;   exit(3);
}
sndcall->addr.len = sizeof(int);
*(int *)sndcall->addr.buf = SRV_ADDR;

if (t_connect(fd, sndcall, NULL) &lt; 0) {
&space;   t_error("t_connect failed for fd");
&space;   exit(4);
}
</CODE>
<PARAGRAPH>The <FUNCTION>t_connect()</FUNCTION> call establishes the connection with the server. The first argument to <FUNCTION>t_connect()</FUNCTION> identifies the transport endpoint through which the connection is established, and the second argument identifies the destination server. This argument is a pointer to a <VARIABLE>t_call</VARIABLE> structure with the following format:</PARAGRAPH>
<CODE>
struct t_call  {
&space;   struct netbuf addr;
&space;   struct netbuf opt;
&space;   struct netbuf udata;
&space;   int sequence;
}
</CODE>
<PARAGRAPH><VARIABLE>addr</VARIABLE> identifies the address of the server, <VARIABLE>opt</VARIABLE> can be used to specify protocol-specific options that the client would like to associate with the connection, and <VARIABLE>udata</VARIABLE> identifies user data that can be sent with the connect request to the server. The sequence field has no meaning for <FUNCTION>t_connect()</FUNCTION>.</PARAGRAPH>
<PARAGRAPH><FUNCTION>t_alloc()</FUNCTION> is called to allocate the <VARIABLE>t_call</VARIABLE> structure dynamically. Once allocated, the appropriate values are assigned. In this example, no options or user data items are associated with the <FUNCTION>t_connect()</FUNCTION> call, but the server's address must be set. The third argument to <FUNCTION>t_alloc()</FUNCTION> is set to T_ADDR to specify that an appropriate <VARIABLE>netbuf</VARIABLE> buffer should be allocated for the address. The server's address is then assigned to <VARIABLE>buf</VARIABLE>, and <VARIABLE>len</VARIABLE> is set accordingly.</PARAGRAPH>
<PARAGRAPH>The third argument to <FUNCTION>t_connect()</FUNCTION> can be used to return information to the user about the newly established connection, and can be used to retrieve any user data sent by the server in its response to the connect request. It is set to NULL by the client here to indicate that this information is not needed. The connection is established on the successful return of <FUNCTION>t_connect()</FUNCTION>. If the server rejects the connect request, <FUNCTION>t_connect()</FUNCTION> fails and sets <VARIABLE>t_errno</VARIABLE> to TLOOK.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Event Handling<INDEXTARGET ID="8.TLI14"><!-- POSTPROCESSDATA: 8.TLI14|event handling --></TITLE><PARAGRAPH>The TLOOK error has special significance in the Transport Interface. TLOOK notifies the user if a Transport Interface routine is interrupted by an unexpected asynchronous transport event on the given transport endpoint. As such, TLOOK does not report an error with a Transport Interface routine, but the normal processing of that routine is not performed because of the pending event. The events defined by the Transport Interface are listed as follows: </PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>T_LISTEN</HANGITEM>
<HANGBODY><PARAGRAPH>A request for a connection, called a connect indication, has arrived at the transport endpoint.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>T_CONNECT</HANGITEM>
<HANGBODY><PARAGRAPH>The confirmation of a previously sent connect request, called a connect confirmation, has arrived at the transport endpoint. The confirmation is generated when a server accepts a connect request.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>T_DATA</HANGITEM>
<HANGBODY><PARAGRAPH>User data has arrived at the transport endpoint.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>T_EXDATA</HANGITEM>
<HANGBODY><PARAGRAPH>Expedited user data has arrived at the transport endpoint. Expedited data is discussed later in this section.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>T_DISCONNECT</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;A notification that the connection was aborted or that the server rejected a connect request, called a disconnect indication, has arrived at the transport endpoint.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>T_ERROR</HANGITEM>
<HANGBODY><PARAGRAPH>A notification that a fatal error has occurred.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>T_UDERR</HANGITEM>
<HANGBODY><PARAGRAPH>A notification of an error in a previously sent datagram, called a unitdata error indication, has arrived at the transport endpoint (see <XREF IDREF="60724" TYPE="TITLE">&ldquo;Introduction to Connectionless-Mode Service&rdquo;</XREF>).</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>T_ORDREL</HANGITEM>
<HANGBODY><PARAGRAPH>A request for the orderly release of a connection, called an orderly release indication, has arrived at the transport endpoint.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>It is possible in some states to receive one of several asynchronous events, as described in the state tables of <XREF IDREF="39217" TYPE="TITLE">&ldquo;State Transitions&rdquo;</XREF>. The <FUNCTION>t_look()</FUNCTION> routine enables a user to determine what event has occurred if a TLOOK error is returned. The user can then process that event accordingly. In the example, if a connect request is rejected, the event passed to the client is a disconnect indication. The client exits if its request is rejected.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>The Server</TITLE><PARAGRAPH>Returning to the example, when the client calls <FUNCTION>t_connect()</FUNCTION>, a connect indication is generated on the server's listening transport endpoint. The steps required by the server to process the event are discussed below. For each client, the server accepts the connect request and spawns a server process to manage the connection as follows:</PARAGRAPH>
<CODE>
if ((call = (struct t_call *)t_alloc(listen_fd, T_CALL,
&space;                                    T_ALL)) == NULL) {
&space;   t_error("t_alloc of t_call structure failed");
&space;   exit(5);
} 
while (1) {
&space;   if (t_listen(listen_fd, call) &lt; 0) {
&space;       t_error("t_listen failed for listen_fd");
&space;       exit(6);
&space;   } 
&space;   if ((conn_fd = accept_call(listen_fd, call))
&space;       != DISCONNECT)
&space;       run_server(listen_fd);
}
</CODE>
<PARAGRAPH>The server loops forever, processing each connect indication. First, the server calls <FUNCTION>t_listen()</FUNCTION> to retrieve the next connect indication. When one arrives, the server calls <FUNCTION>accept_call()</FUNCTION> to accept the connect request. <FUNCTION>accept_call()</FUNCTION> accepts the connection on an alternate transport endpoint (as discussed below) and returns the value of that endpoint. <VARIABLE>conn_fd</VARIABLE> is a global variable that identifies the transport endpoint where the connection is established. Because the connection is accepted on an alternate endpoint, the server can continue listening for connect indications on the endpoint that was bound for listening. If the call is accepted without error, <FUNCTION>run_server()</FUNCTION> spawns a process to manage the connection.</PARAGRAPH>
<PARAGRAPH>The server allocates a <VARIABLE>t_call</VARIABLE> structure to be used by <FUNCTION>t_listen()</FUNCTION>. The third argument to <FUNCTION>t_alloc()</FUNCTION>, T_ALL, specifies that all necessary buffers should be allocated for retrieving the caller's address, options, and user data. As mentioned earlier, the transport provider in this example does not support the transfer of user data during connection establishment, and also does not support any protocol options. Therefore, <FUNCTION>t_alloc()</FUNCTION> does not allocate buffers for the user data and options. It must, however, allocate a buffer large enough to store the address of the caller. <FUNCTION>t_alloc()</FUNCTION> determines the buffer size from the <VARIABLE>addr</VARIABLE> characteristic returned by <FUNCTION>t_open()</FUNCTION>. The <VARIABLE>maxlen</VARIABLE> field of each <VARIABLE>netbuf</VARIABLE> structure is set to the size of the buffer allocated by <FUNCTION>t_alloc()</FUNCTION> (<VARIABLE>maxlen</VARIABLE> is 0 for the user data and options buffers).</PARAGRAPH>
<PARAGRAPH>Using the <VARIABLE>t_call</VARIABLE> structure, the server calls <FUNCTION>t_listen()</FUNCTION> to retrieve the next connect indication. If one is currently available, it is returned to the server immediately. Otherwise, <FUNCTION>t_listen()</FUNCTION> blocks until a connect indication arrives.</PARAGRAPH>
<PARAGRAPH>The Transport Interface supports an asynchronous mode for these routines, which prevents a process from blocking. This feature is discussed in <XREF IDREF="80913" TYPE="TITLE">&ldquo;Advanced Topics&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>When a connect indication arrives, the server calls <FUNCTION>accept_call()</FUNCTION> to accept the client's request, as follows:</PARAGRAPH>
<CODE>
int accept_call(listen_fd, call)
int listen_fd;
struct t_call *call;
{
&space;   int resfd;

&space;   if ((resfd = t_open("/dev/ticotsord", O_RDWR, NULL))
&space;       &lt; 0) {
&space;       t_error("t_open for responding fd failed");
&space;       exit(7);
&space;   }

&space;   if (t_bind(resfd, NULL, NULL) &lt; 0) {
&space;       t_error("t_bind for responding fd failed");
&space;       exit(8);
&space;   } 
&space;   if (t_accept(listen_fd, resfd, call) &lt; 0) {
&space;       if (t_errno == TLOOK) {  /* must be a disconnect */
&space;           if (t_rcvdis(listen_fd, NULL) &lt; 0) {
&space;               t_error("t_rcvdis failed for listen_fd");
&space;               exit(9);
&space;           }
&space;           if (t_close(resfd) &lt; 0) {
&space;               t_error("t_close failed for responding fd");
&space;               exit(10);
&space;           } 			/* go back up and listen for other calls */
&space;           return(DISCONNECT);
&space;       }
&space;       t_error("t_accept failed");
&space;       exit(11);
&space;   }
&space;   return(resfd);
}
</CODE>
<PARAGRAPH><FUNCTION>accept_call()</FUNCTION> takes two arguments:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><VARIABLE>listen_fd</VARIABLE> identifies the transport endpoint where the connect indication arrived </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><VARIABLE>call </VARIABLE>is a pointer to a <VARIABLE>t_call</VARIABLE> structure that contains all information associated with the connect indication.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The server first establishes another transport endpoint by opening the <COMMAND>clone</COMMAND> device node of the transport provider and binding an address. As with the client, a NULL value is passed to <FUNCTION>t_bind()</FUNCTION> to specify that the user does not care what address is bound by the provider. The newly established transport endpoint, <VARIABLE>resfd</VARIABLE>, is used to accept the client's connect request.</PARAGRAPH>
<PARAGRAPH>The first two arguments of <FUNCTION>t_accept()</FUNCTION> specify the listening transport endpoint and the endpoint where the connection is accepted, respectively. A connection can be accepted on the listening endpoint, but this prevents other clients from accessing the server for the duration of the connection.</PARAGRAPH>
<PARAGRAPH>The third argument of <FUNCTION>t_accept()</FUNCTION> points to the <VARIABLE>t_call</VARIABLE> structure associated with the connect indication. This structure should contain the address of the calling user and the sequence number returned by <FUNCTION>t_listen()</FUNCTION>. The sequence number is significant if the server manages multiple outstanding connect indications. <XREF IDREF="80913" TYPE="TITLE">&ldquo;Advanced Topics&rdquo;</XREF> presents an example of this situation. Also, the <VARIABLE>t_call</VARIABLE> structure should identify protocol options the user has requested and user data that can be passed to the client. Because the transport provider in this example does not support protocol options or the transfer of user data during connection establishment, the <VARIABLE>t_call</VARIABLE> structure returned by <FUNCTION>t_listen()</FUNCTION> can be passed without change to <FUNCTION>t_accept()</FUNCTION>.</PARAGRAPH>
<PARAGRAPH>For simplicity in the example, the server exits if either the <FUNCTION>t_open()</FUNCTION> or <FUNCTION>t_bind()</FUNCTION> call fails. <FUNCTION>exit()</FUNCTION> closes the transport endpoint associated with <VARIABLE>listen_fd</VARIABLE>, causing the transport provider to pass a disconnect indication to the client that requested the connection. This disconnect indication notifies the client that the connection was not established; <FUNCTION>t_connect()</FUNCTION> fails, setting <VARIABLE>t_errno</VARIABLE> to TLOOK.</PARAGRAPH>
<PARAGRAPH><FUNCTION>t_accept()</FUNCTION> can fail if an asynchronous event has occurred on the listening transport endpoint before the connection is accepted, and <VARIABLE>t_errno</VARIABLE> is set to TLOOK. The state transition table in <XREF IDREF="39217" TYPE="TITLE">&ldquo;State Transitions&rdquo;</XREF> shows that the only event that can occur in this state with only one outstanding connect indication is a disconnect indication. This event can occur if the client decides to undo the connect request it had previously sent. If a disconnect indication arrives, the server must retrieve the disconnect indication using <FUNCTION>t_rcvdis()</FUNCTION>. This routine takes a pointer to a <VARIABLE>t_discon</VARIABLE> structure as an argument, which is used to retrieve information associated with a disconnect indication. In this example, however, the server does not care to retrieve this information, so it sets the argument to NULL. After receiving the disconnect indication, <FUNCTION>accept_call()</FUNCTION> closes the responding transport endpoint and returns DISCONNECT, which informs the server that the connection was disconnected by the client. The server then listens for further connect indications.</PARAGRAPH>
<PARAGRAPH><XREF IDREF="76183" TYPE="GRAPHIC">Figure&nbsp;8-5</XREF> illustrates how the server establishes connections. </PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="Fig8.5.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="8-5"><PREFIX>Figure 8-5 </PREFIX><XREFTARGET ID="76183">Listening and Responding Transport Endpoints</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>The transport connection is established on the newly created responding endpoint, and the listening endpoint is freed to retrieve further connect indications.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Data Transfer<INDEXTARGET ID="8.TLI15"><!-- POSTPROCESSDATA: 8.TLI15|data transfer --></TITLE><PARAGRAPH>Once the connection is established, both the client and server can begin transferring data over the connection using <FUNCTION>t_snd()</FUNCTION> and <FUNCTION>t_rcv()</FUNCTION>. The Transport Interface does not differentiate the client from the server from this point on. Either user can send and receive data or release the connection. The Transport Interface guarantees reliable, sequenced delivery of data over an existing connection.</PARAGRAPH>
<PARAGRAPH>Two classes of data can be transferred over a transport connection: normal data and expedited data.</PARAGRAPH>
<PARAGRAPH>Expedited data is typically associated with urgent information. The exact semantics of expedited data are subject to the interpretations of the transport provider. Furthermore, not all transport protocols support the notion of an expedited data class (see <REFPAGE>t_open(3N)</REFPAGE>).</PARAGRAPH>
<PARAGRAPH>All transport protocols support the transfer of data in byte stream mode, where <VARIABLE>byte stream</VARIABLE> implies no concept of message boundaries on data that's transferred over a connection. However, some transport protocols support the preservation of message boundaries over a transport connection. This service is supported by the Transport Interface, but protocol-independent software must not rely on its existence.</PARAGRAPH>
<PARAGRAPH>The message interface for data transfer is supported by a special flag of <FUNCTION>t_snd()</FUNCTION> and <FUNCTION>t_rcv()</FUNCTION> called T_MORE. The messages, called Transport Service Data Units (TSDU), can be transferred between two transport users as distinct units. The maximum TSDU size is a characteristic of the underlying transport protocol. This information is available to the user from <INDEXTARGET ID="8.TLI16"><!-- POSTPROCESSDATA: 8.TLI16|TSDU (Transport Service Data Units)transport service data units (TDSU) --><FUNCTION>t_open()</FUNCTION> and <FUNCTION>t_getinfo()</FUNCTION>. Because the maximum size can be large (possibly unlimited), the Transport Interface allows a user to transmit a message in multiple units.</PARAGRAPH>
<PARAGRAPH>To send a message in multiple units over a transport connection, the user must set the T_MORE flag on every <FUNCTION>t_snd()</FUNCTION> call except the last. This flag specifies that the user will send more data associated with the message in a subsequent call to <FUNCTION>t_snd()</FUNCTION>. The last message unit should be transmitted with T_MORE turned off to specify that this is the end of the TSDU.</PARAGRAPH>
<PARAGRAPH>Similarly, a TSDU can be passed in multiple units to the receiving user. Again, if <FUNCTION>t_rcv()</FUNCTION> returns with the T_MORE flag set, the user should continue calling <FUNCTION>t_rcv()</FUNCTION> to retrieve the remainder of the message. The last unit in the message is identified by a call to <FUNCTION>t_rcv()</FUNCTION> that does not set T_MORE.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>The T_MORE flag implies nothing about how the data can be packaged below the Transport Interface or how the data can be delivered to the receiver. Each transport protocol, and each implementation of that protocol, can package and deliver the data differently.</NOTE>
<PARAGRAPH>For example, if a user sends a complete message in a single call to <FUNCTION>t_snd()</FUNCTION>, there is no guarantee that the transport provider will deliver the data in a single unit to the remote transport user. Similarly, a message transmitted in two message units can be delivered in a single unit to the remote transport user. The message boundaries can only be preserved by noting the value of the T_MORE flag on <FUNCTION>t_snd()</FUNCTION> and <FUNCTION>t_rcv()</FUNCTION>. This guarantees that the receiving user sees a message with the same contents and message boundaries as that sent by the sender.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>The Client</TITLE><PARAGRAPH>Continuing with the client/server example, the server transfers a log file to the client over the transport connection. The client receives this data and writes it to its standard output file. A byte stream interface is used by the client and server, where message boundaries (that is, the T_MORE flag) are ignored. The client receives data using the following instructions:</PARAGRAPH>
<CODE>
while ((nbytes = t_rcv(fd, buf, 1024, &amp;flags)) != -1) {
&space;   if (fwrite(buf, 1, nbytes, stdout) &lt; 0) {
&space;       fprintf(stderr, "fwrite failed\n");
&space;       exit(5);
&space;   }
}
</CODE>
<PARAGRAPH>The client continuously calls <FUNCTION>t_rcv()</FUNCTION> to process incoming data. If no data is currently available, <FUNCTION>t_rcv()</FUNCTION> blocks until data arrives. <FUNCTION>t_rcv()</FUNCTION> retrieves the available data up to 1024 bytes, which is the size of the client's input buffer, and returns the number of bytes received. The client then writes this data to standard output and continues. The data transfer phase completes when <FUNCTION>t_rcv()</FUNCTION> fails. <FUNCTION>t_rcv()</FUNCTION> fails if an orderly release or disconnect indication arrives, as discussed later in this section. If the <FUNCTION>fwrite()</FUNCTION> call (see <REFPAGE>fwrite(3S)</REFPAGE>) fails for any reason, the client exits, closing the transport endpoint. If the transport endpoint is closed (either by <FUNCTION>exit()</FUNCTION> or <FUNCTION>t_close()</FUNCTION>) during the data transfer phase, the connection is aborted and the other user receives a disconnect indication.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>The Server</TITLE><PARAGRAPH>Looking now at the other side of the connection, the server manages its data transfer by spawning a child process to send the data to the client. The parent process then loops back to listen for further connect indications.</PARAGRAPH>
<PARAGRAPH>&space;<FUNCTION>run_server()</FUNCTION> is called by the server to spawn this child process as shown in <XREF IDREF="84303" TYPE="TEXT">Example&nbsp;8-3</XREF>.</PARAGRAPH>

<!-- WARNING: (47) Example captions should come at end of Example - detected on page 215 -->
<!-- WARNINGLOCATION: PAGE = "215" SRC = "8.TLI.mif" TAGTYPE = "PARA" TAG = "ExampleTitle" TAGCOUNT = "1" UID = "716" TEXT = "."-->
<EXAMPLE><CAPTION LBL="8-3"><PREFIX>Example 8-3 </PREFIX><XREFTARGET ID="84303">Sending Data to a Client</CAPTION></EXAMPLE>
<CODE>
void connrelease()
{
&space;   /* conn_fd is global because needed here */
&space;   if (t_look(conn_fd) == T_DISCONNECT) {
&space;       fprintf(stderr, "connection aborted\n");
&space;       exit(12);
&space;   }     /* else orderly release indication - normal exit */
&space;   exit(0);
&space;}

int run_server(listen_fd)
int listen_fd;
{
&space;   int nbytes;
&space;   FILE *logfp;           /* file pointer to log file */
&space;   char buf[1024];

&space;   switch (fork()) {

&space;   case -1:
&space;       perror("fork failed");
&space;       exit(20);

&space;   default:   /* parent */ 

&space;       /* close conn_fd and then go up and listen again */ 
&space;       if (t_close(conn_fd) &lt; 0) {
&space;           t_error("t_close failed for conn_fd");
&space;           exit(21);
&space;       } 
&space;       return;

&space;   case 0:     /* child */ 

&space;       /* close listen_fd and do service */ 
&space;       if (t_close(listen_fd) &lt; 0) {
&space;           t_error("t_close failed for listen_fd");
&space;           exit(22);
&space;       } 
&space;       if ((logfp = fopen("logfile", "r")) == NULL) {
&space;           perror("cannot open logfile");
&space;           exit(23);
&space;       }
&space;       signal(SIGPOLL, connrelease);
&space;       if (ioctl(conn_fd, I_SETSIG, S_INPUT) &lt; 0) {
&space;           perror("ioctl I_SETSIG failed");
&space;           exit(24);
&space;       }
        /* was disconnect there? */
&space;       if (t_look(conn_fd) != 0) {
&space;           fprintf(stderr, "t_look: unexpected event\n");
&space;           exit(25);
&space;       } 
&space;       while ((nbytes = fread(buf, 1, 1024, logfp)) > 0) 
&space;           if (t_snd(conn_fd, buf, nbytes, 0) &lt; 0) {
&space;               t_error("t_snd failed");
&space;               exit(26);
&space;           }
</CODE>
<PARAGRAPH>After the <FUNCTION>fork()</FUNCTION>, the parent process returns to the main processing loop and listens for further connect indications. Meanwhile, the child process manages the newly established transport connection. If the <FUNCTION>fork()</FUNCTION> call fails, <FUNCTION>exit()</FUNCTION> closes the transport endpoint associated with <VARIABLE>listen_fd</VARIABLE>, sending a disconnect indication to the client, and the client's <FUNCTION>t_connect()</FUNCTION> call fails.</PARAGRAPH>
<PARAGRAPH>The server process reads 1024 bytes of the log file at a time and sends that data to the client using <FUNCTION>t_snd()</FUNCTION>. <VARIABLE>buf</VARIABLE> points to the start of the data buffer, and <VARIABLE>nbytes</VARIABLE> specifies the number of bytes to be transmitted. The fourth argument can contain one of the two optional flags as follows:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>T_EXPEDITED specifies that the data is expedited.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>T_MORE defines message boundaries when transmitting messages over a connection.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Neither flag is set by the server in this example.</PARAGRAPH>
<PARAGRAPH>If the user floods the transport provider with data, the provider can exert back pressure to provide flow control. In such cases, <FUNCTION>t_snd()</FUNCTION> blocks until the flow control is relieved, and then resumes its operation. <FUNCTION>t_snd()</FUNCTION> does not complete until <VARIABLE>nbyte</VARIABLE> bytes have been passed to the transport provider.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>t_snd()</FUNCTION> routine does not look for a disconnect indication (showing that the connection was broken) before passing data to the provider. Also, because the data traffic flows in one direction, the user never looks for incoming events. If the connection is aborted, the user should be notified since data can be lost. The user can invoke <FUNCTION>t_look()</FUNCTION>, which checks for incoming events before each <FUNCTION>t_snd()</FUNCTION> call. A more efficient solution is presented in <XREF IDREF="84303" TYPE="TEXT">Example&nbsp;8-3</XREF>. The STREAMS I_SETSIG <FUNCTION>ioctl()</FUNCTION> enables a user to request a signal when a given event occurs (see <REFPAGE>streamio(5)</REFPAGE> and <REFPAGE>signal(2)</REFPAGE>). S_INPUT causes a signal to be sent to the user if any input arrives on the Stream referenced by <VARIABLE>conn_fd</VARIABLE>. If a disconnect indication arrives, the signal catching routine (<FUNCTION>connrelease()</FUNCTION>) prints an error message and then exits.</PARAGRAPH>
<PARAGRAPH>If the data traffic flowed in both directions in this example, the user would not have to monitor the connection for disconnects. If the client alternated <FUNCTION>t_snd()</FUNCTION> and <FUNCTION>t_rcv()</FUNCTION> calls, it could rely on <FUNCTION>t_rcv()</FUNCTION> to recognize an incoming disconnect indication.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Connection Release<INDEXTARGET ID="8.TLI17"><!-- POSTPROCESSDATA: 8.TLI17|connection release --></TITLE><PARAGRAPH>At any point during data transfer, either user can release the transport connection and end the conversation. As mentioned earlier, two forms of connection release are supported by the Transport Interface:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Abortive release breaks a connection immediately and can result in the loss of any data that has not yet reached the destination user.</PARAGRAPH>
<PARAGRAPH>Either user can call <FUNCTION>t_snddis()</FUNCTION> to generate an abortive release. Also, the transport provider can abort a connection if a problem occurs below the Transport Interface. <FUNCTION>t_snddis()</FUNCTION> enables a user to send data to the receiver when aborting a connection. Although the abortive release is supported by all transport providers, the ability to send data when aborting a connection is not.</PARAGRAPH>
<PARAGRAPH>When a user receives notification of the aborted connection, <FUNCTION>t_rcvdis()</FUNCTION> must be called to retrieve the disconnect indication. This call returns a reason code that identifies why the connection was aborted, and returns any user data that accompanied the disconnect indication (if the abortive release was initiated by the other user). This reason code is specific to the underlying transport protocol and should not be interpreted by protocol-independent software.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Orderly release gracefully terminates a connection and guarantees that no data is lost.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>All transport providers must support the abortive release procedure, but orderly release is an optional facility that is not supported by all transport protocols.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>The Server</TITLE><PARAGRAPH>The client/server example in this section assumes that the transport provider supports the orderly release of a connection. When all the data has been transferred by the server, the connection can be released as follows:</PARAGRAPH>
<CODE>
&space;       if (t_sndrel(conn_fd) &lt; 0) {
&space;           t_error("t_sndrel failed");
&space;           exit(27);
&space;       } 
&space;       pause();
&space;   /* until orderly release indication arrives */
&space;   }
</CODE>
<PARAGRAPH>The orderly release procedure consists of two steps by each user. The first user to complete data transfer can initiate a release using <FUNCTION>t_sndrel()</FUNCTION>, as illustrated in the example. This routine informs the client that no more data will be sent by the server. When the client receives this indication, it can continue sending data back to the server if desired. When all data has been transferred, however, the client must also call <FUNCTION>t_sndrel()</FUNCTION> to indicate that it is ready to release the connection. The connection is released only after both users have requested an orderly release and received the corresponding indication from the other user.</PARAGRAPH>
<PARAGRAPH>In this example, data is transferred in one direction from the server to the client, so the server does not expect to receive data from the client after it has initiated the release procedure. Thus, the server simply calls <FUNCTION>pause()</FUNCTION> (see <REFPAGE>pause(2)</REFPAGE>)after initiating the release. Eventually, the client responds with its orderly release request, which generates a signal that is caught by <FUNCTION>connrelease()</FUNCTION>. Remember that the server earlier issued an I_SETSIG <FUNCTION>ioctl()</FUNCTION> call to generate a signal on any incoming event. Since the only possible Transport Interface events that can occur in this situation are a disconnect indication or an orderly release indication, <FUNCTION>connrelease()</FUNCTION> terminates normally when the orderly release indication arrives. The <FUNCTION>exit()</FUNCTION> call in <FUNCTION>connrelease()</FUNCTION> closes the transport endpoint, freeing the bound address for another user. If a user process wants to close a transport endpoint without exiting, it can call <FUNCTION>t_close()</FUNCTION>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>The Client</TITLE><PARAGRAPH>The client's view of connection release is similar to that of the server. As mentioned earlier, the client continues to process incoming data until <FUNCTION>t_rcv()</FUNCTION> fails. If the server releases the connection (using either <FUNCTION>t_snddis()</FUNCTION> or <FUNCTION>t_sndrel()</FUNCTION>), <FUNCTION>t_rcv()</FUNCTION> fails and sets <VARIABLE>t_errno</VARIABLE> to TLOOK. The client then processes the connection release as follows:</PARAGRAPH>
<CODE>
&space;   if ((t_errno == TLOOK)  &amp;&amp;  (t_look(fd) == T_ORDREL)) {
&space;       if (t_rcvrel(fd) &lt; 0) {
&space;           t_error("t_rcvrel failed");
&space;           exit(6);
&space;       }
&space;       if (t_sndrel(fd) &lt; 0) {
&space;           t_error("t_sndrel failed");
&space;           exit(7);
&space;       }
&space;       exit(0);
&space;   }
&space;   t_error("t_rcv failed");
&space;   exit(8);
</CODE>
<PARAGRAPH>When an event occurs on the client's transport endpoint, the client checks whether the expected orderly release indication has arrived. If so, it proceeds with the release procedures by calling <FUNCTION>t_rcvrel()</FUNCTION> to process the indication and <FUNCTION>t_sndrel()</FUNCTION> to inform the server that it is also ready to release the connection. At this point the client exits, closing its transport endpoint.</PARAGRAPH>
<PARAGRAPH>Because not all transport providers support the orderly release facility just described, users may have to use the abortive release facility provided by <FUNCTION>t_snddis()</FUNCTION> and <FUNCTION>t_rcvdis()</FUNCTION>. However, steps must be taken by each user to prevent data loss. For example, a special byte pattern can be inserted in the datastream to indicate the end of a conversation. There are many possible routines for preventing data loss. Each application and high-level protocol must choose an appropriate routine given the target protocol environment and requirements.</PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="60724">Introduction to Connectionless-Mode Service</TITLE><PARAGRAPH>This section describes the connectionless-mode service of the Transport Interface. Connectionless-mode service is appropriate for short-term request/response interactions, such as transaction-processing applications. Data is transferred in self-contained units with no logical relationship required among multiple units.<INDEXTARGET ID="8.TLI18"><!-- POSTPROCESSDATA: 8.TLI18|connectionless-mode service (transport interface)transport interface:connectionless-mode service --></PARAGRAPH>
<PARAGRAPH>The connectionless-mode service is described using a transaction server as an example. This server waits for incoming transaction queries, and processes and responds to each query.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Local Management</TITLE><PARAGRAPH>Just as with connection-mode service, the transport users must do appropriate local management steps before transferring data. A user must choose the appropriate connectionless service provider using <FUNCTION>t_open()</FUNCTION> and establish its identity using <FUNCTION>t_bind()</FUNCTION>. See the <REFPAGE>t_open(3N)</REFPAGE> man page or the other <XREF IDREF="19084" TYPE="TITLE">&ldquo;Local Management&rdquo;</XREF> section of this chapter (under <XREF IDREF="15433" TYPE="TITLE">&ldquo;Introduction to Connection-Mode Service&rdquo;</XREF>) for information about what <FUNCTION>t_open()</FUNCTION> returns.</PARAGRAPH>
<PARAGRAPH><FUNCTION>t_optmgmt()</FUNCTION> can be used to negotiate protocol options associated with the transfer of each data unit. As with the connection-mode service, each transport provider specifies the options, if any, that it supports. Option negotiation is therefore a protocol-specific activity.</PARAGRAPH>
<PARAGRAPH>The definitions and local management calls needed by the transaction server are shown in <XREF IDREF="13643" TYPE="TEXT">Example&nbsp;8-4</XREF>:</PARAGRAPH>

<!-- WARNING: (47) Example captions should come at end of Example - detected on page 221 -->
<!-- WARNINGLOCATION: PAGE = "221" SRC = "8.TLI.mif" TAGTYPE = "PARA" TAG = "ExampleTitle" TAGCOUNT = "1" UID = "868" TEXT = ":"-->
<EXAMPLE><CAPTION LBL="8-4"><PREFIX>Example 8-4 </PREFIX><XREFTARGET ID="13643">The Transaction Server Definitions and Local Management</CAPTION></EXAMPLE>
<CODE>
#include &lt;stdio.h>
#include &lt;fcntl.h> 
#include &lt;tiuser.h> 

#define SRV_ADDR  2     /* server's well-known address */

void main()
{
&space;   int fd;
&space;   int flags;

&space;   struct t_bind *bind;
&space;   struct t_unitdata *ud;
&space;   struct t_uderr *uderr;

&space;   extern int t_errno;

&space;   if ((fd = t_open("/dev/ticlts", O_RDWR, NULL)) &lt; 0) {
&space;       t_error("unable to open /dev/provider");
&space;       exit(1);
&space;   }

&space;   if ((bind = (struct t_bind *)t_alloc(fd, T_BIND,
&space;               T_ADDR)) == NULL)   {
&space;       t_error("t_alloc of t_bind structure failed");
&space;       exit(2);
&space;   } 

&space;   bind->addr.len = sizeof(int);
&space;   *(int *)bind->addr.buf = SRV_ADDR;
&space;   bind->qlen = 0;

&space;   if (t_bind(fd, bind, bind) &lt; 0)  {
&space;       t_error("t_bind failed");
&space;       exit(3);
&space;   } 

&space;   /*
&space;    * is the bound address correct?
&space;    */ 

&space;   if (*(int *)bind->addr.buf != SRV_ADDR)
&space;   {
&space;       fprintf(stderr, "t_bind bound wrong address\n");
&space;       exit(4);
&space;   }
</CODE>
<PARAGRAPH>The local management steps should look familiar by now. The server establishes a transport endpoint with the desired transport provider using <FUNCTION>t_open()</FUNCTION>. Each provider has an associated service type, so the user can choose a particular service by opening the appropriate transport provider file. This connectionless-mode server ignores the characteristics of the provider returned by <FUNCTION>t_open()</FUNCTION> in the same way as the users in the connection-mode example, by setting the third argument to NULL. For simplicity, the transaction server assumes the transport provider has the following characteristics: </PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The transport address is an integer value that uniquely identifies each user.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The transport provider supports the T_CLTS service type (connectionless transport service, or datagram).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The transport provider does not support any protocol-specific options.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The connectionless server also binds a transport address to the endpoint so that potential clients can identify and access the server. A <VARIABLE>t_bind</VARIABLE> structure is allocated using <FUNCTION>t_alloc()</FUNCTION>, and the <VARIABLE>buf</VARIABLE> and <VARIABLE>len</VARIABLE> fields of the address are set accordingly.</PARAGRAPH>
<PARAGRAPH>One important difference between the connection-mode server and this connectionless-mode server is that the <VARIABLE>qlen</VARIABLE> field of the <VARIABLE>t_bind</VARIABLE> structure has no meaning for connectionless-mode service, since all users are capable of receiving datagrams once they have bound an address. The Transport Interface defines an inherent client/server relationship between two users while establishing a transport connection in the connection-mode service. However, no such relationship exists in the connectionless-mode service. It is the context of this example, not the Transport Interface, that defines one user as a server and another as a client.</PARAGRAPH>
<PARAGRAPH>Because the address of the server is known by all potential clients, the server checks the bound address returned by <FUNCTION>t_bind()</FUNCTION> to ensure it is correct.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Data Transfer</TITLE><PARAGRAPH>Once a user has bound an address to the transport endpoint, datagrams can be sent or received over that endpoint. Each outgoing message is accompanied by the address of the destination user. In addition, the Transport Interface enables a user to specify protocol options that should be associated with the transfer of the data unit (for example, transit delay). As discussed earlier, each transport provider defines the set of options, if any, that can accompany a datagram. When the datagram is passed to the destination user, the associated protocol options can be returned as well.</PARAGRAPH>
<PARAGRAPH>The sequence of calls in <XREF IDREF="43905" TYPE="TEXT">Example&nbsp;8-5</XREF> illustrates the data transfer phase of the connectionless-mode server:</PARAGRAPH>

<!-- WARNING: (47) Example captions should come at end of Example - detected on page 223 -->
<!-- WARNINGLOCATION: PAGE = "223" SRC = "8.TLI.mif" TAGTYPE = "PARA" TAG = "ExampleTitle" TAGCOUNT = "1" UID = "931" TEXT = " illustrates the data tra"-->
<EXAMPLE><CAPTION LBL="8-5"><PREFIX>Example 8-5 </PREFIX><XREFTARGET ID="43905">The Data Transfer Phase of a Connectionless-Mode Server</CAPTION></EXAMPLE>
<CODE>
if ((ud = (struct t_unitdata *)t_alloc(fd, T_UNITDATA,
&space;                                      T_ALL)) == NULL)  {
&space;       t_error("t_alloc of t_unitdata structure failed");
&space;       exit(5);
} 

if ((uderr = (struct t_uderr *)t_alloc(fd, T_UDERROR,
&space;                                      T_ALL)) == NULL)  {
&space;       t_error("t_alloc of t_uderr structure failed");
&space;       exit(6);
} 

&space;   while (1)  {
&space;       if (t_rcvudata(fd, ud, &amp;flags) &lt; 0)  {
&space;           if (t_errno == TLOOK)  {
&space;               /* Error on previously sent datagram */
&space;               if (t_rcvuderr(fd, uderr) &lt; 0)  {
&space;                   exit(7);
&space;               }
&space;               fprintf(stderr, "bad datagram, \
&space;                error = %d\n", uderr->error);
&space;               continue;
&space;           }
&space;           t_error("t_rcvudata failed");
&space;           exit(8);
&space;       } 

&space;       /*
&space;        * Query() processes the request and places the
&space;        * response in ud->udata.buf, setting ud->udata.len
&space;        */ 

&space;       query(ud);

&space;       if (t_sndudata(fd, ud &lt; 0)  {
&space;           t_error("t_sndudata failed");
&space;           exit(9);
&space;       }
&space;   }
}
query()
{
&space;   /* Merely a stub for simplicity */ 
}
</CODE>
<PARAGRAPH>The server must first allocate a <VARIABLE>t_unitdata</VARIABLE> structure for storing datagrams, which has the following format:</PARAGRAPH>
<CODE>
struct t_unitdata {
&space;   struct netbuf addr;
&space;   struct netbuf opt;
&space;   struct netbuf udata;
}
</CODE>
<PARAGRAPH><VARIABLE>addr</VARIABLE> holds the source address of incoming datagrams and the destination address of outgoing datagrams, <VARIABLE>opt</VARIABLE> identifies any protocol options associated with the transfer of the datagram, and <VARIABLE>udata</VARIABLE> holds the data itself. The <VARIABLE>addr</VARIABLE>, <VARIABLE>opt</VARIABLE>, and <VARIABLE>udata</VARIABLE> fields must all be allocated with buffers large enough to hold any possible incoming values. As described in the previous section, the T_ALL argument to <FUNCTION>t_alloc()</FUNCTION> ensures this and sets the <VARIABLE>maxlen</VARIABLE> field of each <VARIABLE>netbuf</VARIABLE> structure accordingly. Because the provider does not support protocol options in this example, no options buffers are allocated, and <VARIABLE>maxlen</VARIABLE> is set to zero in the <VARIABLE>netbuf</VARIABLE> structure for options. The server also allocates a <VARIABLE>t_uderr</VARIABLE> structure for processing any datagram errors, as discussed later in this section.</PARAGRAPH>
<PARAGRAPH>The transaction server loops forever, receiving queries, processing the queries, and responding to the clients. It first calls <FUNCTION>t_rcvudata()</FUNCTION> to receive the next query. <FUNCTION>t_rcvudata()</FUNCTION> retrieves the next available incoming datagram. If none is currently available, <FUNCTION>t_rcvudata()</FUNCTION> blocks, waiting for a datagram to arrive. The second argument of <FUNCTION>t_rcvudata()</FUNCTION> identifies the <VARIABLE>t_unitdata</VARIABLE> structure in which the datagram should be stored.</PARAGRAPH>
<PARAGRAPH>The third argument, <VARIABLE>flags</VARIABLE>, must point to an integer variable and can be set to T_MORE on return from <FUNCTION>t_rcvudata()</FUNCTION> to specify that the user's <VARIABLE>udata</VARIABLE> buffer was not large enough to store the full datagram. In this case, subsequent calls to <FUNCTION>t_rcvudata()</FUNCTION> retrieve the remainder of the datagram. Because <FUNCTION>t_alloc()</FUNCTION> allocates a <VARIABLE>udata</VARIABLE> buffer large enough to store the maximum datagram size, the transaction server does not have to check the value of <VARIABLE>flags</VARIABLE>.</PARAGRAPH>
<PARAGRAPH>If a datagram is received successfully, the transaction server calls the <FUNCTION>query()</FUNCTION> routine to process the request. This routine stores the response in the structure pointed to by <VARIABLE>ud</VARIABLE>, and sets <VARIABLE>ud&ndash;>udata.len</VARIABLE> to the number of bytes in the response. The source address returned by <FUNCTION>t_rcvudata()</FUNCTION> in <VARIABLE>ud&ndash;>addr</VARIABLE> is used as the destination address by <FUNCTION>t_sndudata()</FUNCTION>.</PARAGRAPH>
<PARAGRAPH>When the response is ready, <FUNCTION>t_sndudata()</FUNCTION> is called to return the response to the client. The Transport Interface prevents a user from flooding the transport provider with datagrams using the same flow control mechanism described for the connection-mode service. In such cases, <FUNCTION>t_sndudata()</FUNCTION> blocks until the flow control is relieved, and then resumes its operation.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Datagram Errors</TITLE><PARAGRAPH>If the transport provider cannot process a datagram that was passed to it by <FUNCTION>t_sndudata()</FUNCTION>, it returns a unit data error event, T_UDERR, to the user. This event includes the destination address and options associated with the datagram, plus a protocol-specific error value that describes what could be wrong with the datagram. The reason a datagram could not be processed is protocol-specific. One reason can be that the transport provider could not interpret the destination address or options. Each transport protocol is expected to specify all reasons why it is unable to process a datagram.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>The unit data error indication is not necessarily intended to indicate success or failure in delivering the datagram to the specified destination. The transport protocol decides how the indication is used. Remember, the connectionless service does not guarantee reliable delivery of data.</NOTE>
<PARAGRAPH>The transaction server is notified of this error event when it attempts to receive another datagram. In this case, <FUNCTION>t_rcvudata()</FUNCTION> fails, setting <VARIABLE>t_errno</VARIABLE> to TLOOK. If TLOOK is set, the only possible event is T_UDERR, so the server calls <FUNCTION>t_rcvuderr()</FUNCTION> to retrieve the event. The second argument to <FUNCTION>t_rcvuderr()</FUNCTION> is the <VARIABLE>t_uderr</VARIABLE> structure that was allocated earlier. This structure is filled in by <FUNCTION>t_rcvuderr()</FUNCTION> and has the following format:</PARAGRAPH>
<CODE>
struct t_uderr  {
&space;   struct netbuf addr;
&space;   struct netbuf opt;
&space;   long error;
&space;}
</CODE>
<PARAGRAPH><VARIABLE>addr</VARIABLE> and <VARIABLE>opt</VARIABLE> identify the destination address and protocol options as specified in the bad datagram, and <VARIABLE>error</VARIABLE> is a protocol-specific error code that specifies why the provider could not process the datagram. The transaction server prints the error code and then continues by entering the processing loop again.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="77708">A Read/Write Interface</TITLE><PARAGRAPH>A user may wish to establish a transport connection and then <FUNCTION>exec()</FUNCTION> (see <REFPAGE>exec(2)</REFPAGE>) an existing user program such as <COMMAND>cat</COMMAND> to process the data as it arrives over the connection. However, existing programs use <FUNCTION>read()</FUNCTION> and <FUNCTION>write()</FUNCTION> for their input/output needs. The Transport Interface does not directly support a read/write interface to a transport provider, but one is available with IRIX. This interface enables a user to issue <FUNCTION>read()</FUNCTION> and <FUNCTION>write()</FUNCTION> calls over a transport connection that is in the data transfer phase. This section describes the read/write interface to the connection-mode service of the Transport Interface. This interface is not available with the connectionless-mode service.</PARAGRAPH>
<PARAGRAPH>The read/write interface is presented using the client example of <XREF IDREF="15433" TYPE="TITLE">&ldquo;Introduction to Connection-Mode Service&rdquo;</XREF> with some minor modifications. The clients are identical until the data transfer phase is reached. At that point, this client uses the read/write interface and <COMMAND>cat</COMMAND> to process incoming data. <FUNCTION>cat()</FUNCTION> can be run without change over the transport connection. Only the differences between this client and that of the example in <XREF IDREF="15433" TYPE="TITLE">&ldquo;Introduction to Connection-Mode Service&rdquo;</XREF> are shown below:</PARAGRAPH>
<CODE>
#include &lt;stropts.h>
&space;   ...
&space;   /*
&space;    * Same local management and connection
&space;    * establishment steps.
&space;    */
&space;   ...
&space;   if (ioctl(fd, I_PUSH, "tirdwr") &lt; 0) {
&space;       perror("I_PUSH of tirdwr failed");
&space;       exit(5);
&space;   }

&space;   close(0);
&space;   dup(fd);
&space;   execl("/usr/bin/cat", "/usr/bin/cat", 0);
&space;   perror("execl of /usr/bin/cat failed");
&space;   exit(6);
&space;}
</CODE>
<PARAGRAPH>The client invokes the read/write interface by pushing the <ITALICS>tirdwr</ITALICS> (see <REFPAGE>tirdwr(7)</REFPAGE>) module onto the Stream associated with the transport endpoint where the connection was established (see I_PUSH in <REFPAGE>streamio(5)</REFPAGE>). This module converts the Transport Interface above the transport provider into a pure read/write interface. With the module in place, the client calls <FUNCTION>close()</FUNCTION> and <FUNCTION>dup()</FUNCTION> (see <REFPAGE>close(2)</REFPAGE> and <REFPAGE>dup(2)</REFPAGE>) to establish the transport endpoint as its standard input file, and uses <FILENAME>/usr/bin/cat</FILENAME> to process the input. Because the transport endpoint identifier is a file descriptor, the facility for <FUNCTION>dup()</FUNCTION>ing the endpoint is available to users.</PARAGRAPH>
<PARAGRAPH>Because the Transport Interface uses STREAMS, the facilities of this character input/output mechanism can be used to provide enhanced user services. By pushing the <ITALICS>tirdwr</ITALICS> module above the transport provider, the user's interface is effectively changed. The semantics of <FUNCTION>read()</FUNCTION> and <FUNCTION>write()</FUNCTION> must be followed, and message boundaries are not preserved.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>The <ITALICS>tirdwr</ITALICS> module can only be pushed onto a Stream when the transport endpoint is in the data transfer phase. Once the module is pushed, the user cannot call any Transport Interface routines. If a Transport Interface routine is invoked, <ITALICS>tirdwr</ITALICS> generates a fatal protocol error, EPROTO, on that Stream, rendering it unusable. Furthermore, if the user pops the <ITALICS>tirdwr</ITALICS> module off the Stream (see I_POP in <REFPAGE>streamio(5)</REFPAGE>), the transport connection is aborted. </NOTE>
<PARAGRAPH>The exact semantics of <FUNCTION>write()</FUNCTION>, <FUNCTION>read()</FUNCTION>, and <FUNCTION>close()</FUNCTION> using <ITALICS>tirdwr</ITALICS> are described below. To summarize, <ITALICS>tirdwr</ITALICS> enables a user to send and receive data over a transport connection using <FUNCTION>read()</FUNCTION> and <FUNCTION>write()</FUNCTION>. This module translates all Transport Interface indications into the appropriate actions. The connection can be released with the <FUNCTION>close()</FUNCTION> system call.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>write()</TITLE><PARAGRAPH>The user can transmit data over the transport connection using <FUNCTION>write()</FUNCTION>. The <ITALICS>tirdwr</ITALICS> module passes data through to the transport provider. However, if a user attempts to send a zero-length data packet, which the STREAMS mechanism allows, <ITALICS>tirdwr</ITALICS> discards the message. If the transport connection is aborted (for example, because the other user aborts the connection using <FUNCTION>t_snddis()</FUNCTION>), a STREAMS hangup condition is generated on that Stream, and further <FUNCTION>write()</FUNCTION> calls fail and set <VARIABLE>errno</VARIABLE> to ENXIO. The user can still retrieve any available data after a hangup.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>read()</TITLE><PARAGRAPH><FUNCTION>read()</FUNCTION> can be used to retrieve data that has arrived over the transport connection. The <ITALICS>tirdwr</ITALICS> module passes data through to the user from the transport provider. However, any other event or indication passed to the user from the provider is processed by <ITALICS>tirdwr</ITALICS> as follows: </PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><FUNCTION>read()</FUNCTION> cannot process expedited data because it cannot distinguish expedited data from normal data for the user. If an expedited data indication is received, <ITALICS>tirdwr</ITALICS> generates a fatal protocol error, EPROTO, on that Stream. This error causes further system calls to fail. You should therefore not communicate with a process that is sending expedited data.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>If an abortive disconnect indication is received, <ITALICS>tirdwr</ITALICS> discards it and generates a hangup condition on that Stream. Subsequent <FUNCTION>read()</FUNCTION> calls retrieve any remaining data, and then <FUNCTION>read()</FUNCTION> returns 0 for all further calls (indicating end-of-file).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>If an orderly release indication is received, <ITALICS>tirdwr</ITALICS> discards the indication and delivers a zero-length message to the user. As described in <REFPAGE>read(2)</REFPAGE>, this notifies the user of end-of-file by returning 0.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>If any other Transport Interface indication is received, <ITALICS>tirdwr</ITALICS> generates a fatal protocol error, EPROTO, on that Stream. This causes further system calls to fail. If a user pushes <ITALICS>tirdwr</ITALICS> onto a Stream after the connection has been established, no indication is generated.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>close()</TITLE><PARAGRAPH>With <ITALICS>tirdwr</ITALICS> on a Stream, the user can send and receive data over a transport connection for the duration of that connection. Either user can terminate the connection by closing the file descriptor associated with the transport endpoint or by popping the <ITALICS>tirdwr</ITALICS> module off the Stream. In either case, <ITALICS>tirdwr</ITALICS> takes the following actions: </PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>If an orderly release indication was previously received by <ITALICS>tirdwr</ITALICS>, an orderly release request is passed to the transport provider to complete the orderly release of the connection. The user who initiated the orderly release procedure receives the expected indication when data transfer completes.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>If a disconnect indication was previously received by <ITALICS>tirdwr</ITALICS>, no special action is taken.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>If neither an orderly release indication nor a disconnect indication was previously received by <ITALICS>tirdwr</ITALICS>, a disconnect request is passed to the transport provider to abort the connection.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>If an error previously occurred on the Stream and a disconnect indication has not been received by <ITALICS>tirdwr</ITALICS>, a disconnect request is passed to the transport provider.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>A process cannot initiate an orderly release after <ITALICS>tirdwr</ITALICS> is pushed onto a Stream, but <ITALICS>tirdwr</ITALICS> handles an orderly release properly if it is initiated by the user on the other side of a transport connection. If the client described in this section is communicating with the server program in <XREF IDREF="15433" TYPE="TITLE">&ldquo;Introduction to Connection-Mode Service,&rdquo;</XREF> that server terminates the transfer of data with an orderly release request. The server then waits for the corresponding indication from the client. At that point, the client exits and the transport endpoint is closed. When the file descriptor is closed, as explained in the first bulleted item above, <ITALICS>tirdwr</ITALICS> initiates the orderly release request from the client's side of the connection. This generates the indication that the server is expecting, and the connection is released properly.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="80913">Advanced Topics</TITLE><PARAGRAPH>This section presents the following important concepts of the Transport Interface that have not been covered in the previous section: </PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>An optional nonblocking (asynchronous) mode for some library calls </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>An advanced programming example that defines a server supporting multiple outstanding connect indications and operating in an event-driven manner </PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE>Asynchronous Execution Mode</TITLE><PARAGRAPH>Many Transport Interface library routines can block waiting for an incoming event or the relaxation of flow control. However, some time-critical applications should not block for any reason. Similarly, an application may wish to do local processing while waiting for some asynchronous transport interface event.</PARAGRAPH>
<PARAGRAPH>Support for asynchronous processing of Transport Interface events is available to applications using a combination of the STREAMS asynchronous features and the nonblocking mode of the Transport Interface library routines. Earlier examples in this chapter have illustrated the use of the <INDEXTARGET ID="8.TLI19"><!-- POSTPROCESSDATA: 8.TLI19|asynchronous processing --><INDEXTARGET ID="8.TLI20"><!-- POSTPROCESSDATA: 8.TLI20|STREAMS --><FUNCTION>poll()</FUNCTION> system call and the I_SETSIG <FUNCTION>ioctl()</FUNCTION> command for processing events asynchronously.</PARAGRAPH>
<PARAGRAPH>In addition, any Transport Interface routine that can block while waiting for some event can be run in a special nonblocking mode. For example, <FUNCTION>t_listen()</FUNCTION> normally blocks waiting for a connect indication. However, a server can periodically poll a transport endpoint for existing connect indications by calling <FUNCTION>t_listen()</FUNCTION> in the nonblocking (or asynchronous) mode. The asynchronous mode is enabled by setting O_NDELAY or O_NONBLOCK on the file descriptor. These can be set as a flag on <FUNCTION>t_open()</FUNCTION> or by calling <FUNCTION>fcntl()</FUNCTION> (see <REFPAGE>fcntl(2)</REFPAGE>) before calling the Transport Interface routine. <FUNCTION>fcntl()</FUNCTION> can be used to enable or disable this mode at any time. All programming examples in this chapter use the default synchronous processing mode.</PARAGRAPH>
<PARAGRAPH>O_NDELAY or O_NONBLOCK affect each Transport Interface routine differently. To determine the exact semantics of O_NDELAY or O_NONBLOCK for a particular routine, see the relevant manual pages.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Advanced Programming Example</TITLE><PARAGRAPH>The example in <XREF IDREF="95847" TYPE="TEXT">Example&nbsp;8-6</XREF> demonstrates two important concepts. The first is a server's ability to manage multiple outstanding connect indications. The second is an illustration of the ability to write event-driven software using the Transport Interface and the system call interface.</PARAGRAPH>
<PARAGRAPH>The server example in <XREF IDREF="95847" TYPE="TEXT">Example&nbsp;8-6</XREF> is capable of supporting only one outstanding connect indication, but the Transport Interface supports the ability to manage multiple outstanding connect indications. One reason a server might wish to receive several simultaneous connect indications is to impose a priority scheme on each client. A server can retrieve several connect indications, and then accept them in an order based on a priority associated with each client. A second reason for handling several outstanding connect indications is that the single-threaded scheme has some limitations. Depending on the implementation of the transport provider, it is possible that while the server is processing the current connect indication, other clients will find it busy. If, however, multiple connect indications can be processed simultaneously, the server will be found to be busy only if the maximum allowed number of clients attempt to call the server simultaneously.</PARAGRAPH>
<PARAGRAPH>The server example in <XREF IDREF="95847" TYPE="TEXT">Example&nbsp;8-6</XREF> is <ITALICS>event-driven: th</ITALICS>e process polls a transport endpoint for incoming Transport Interface events, and then takes the appropriate actions for the current event. The example demonstrates the ability to poll multiple transport endpoints for incoming events.</PARAGRAPH>
<PARAGRAPH>The definitions and local management functions needed by the example in <XREF IDREF="95847" TYPE="TEXT">Example&nbsp;8-6</XREF> are similar to those of the server example in <XREF IDREF="13643" TYPE="TEXT">Example&nbsp;8-4</XREF>.</PARAGRAPH>

<!-- WARNING: (47) Example captions should come at end of Example - detected on page 231 -->
<!-- WARNINGLOCATION: PAGE = "231" SRC = "8.TLI.mif" TAGTYPE = "PARA" TAG = "ExampleTitle" TAGCOUNT = "1" UID = "1136" TEXT = "."-->
<EXAMPLE><CAPTION LBL="8-6"><PREFIX>Example 8-6 </PREFIX><XREFTARGET ID="95847">An Advanced Server</CAPTION></EXAMPLE>
<CODE>
#include &lt;tiuser.h>
#include &lt;fcntl.h>
#include &lt;stdio.h>
#include &lt;poll.h>
#include &lt;stropts.h>
#include &lt;signal.h>

#define NUM_FDS        1
#define MAX_CONN_IND   4
#define SRV_ADDR       1    /* server's well-known address */

int conn_fd;                /* server connection here */
extern int t_errno;

/* holds connect indications */
struct t_call  *calls[NUM_FDS][MAX_CONN_IND];

void main()
{
&space;   struct pollfd pollfds[NUM_FDS];
&space;   struct t_bind *bind;
&space;   int i;

&space;   /*
&space;    * Only opening and binding one transport endpoint,
&space;    * but more could be supported
&space;    */
&space;   if ((pollfds[0].fd = t_open("/dev/ticotsord", O_RDWR,
&space;                               NULL)) &lt; 0) {
&space;       t_error("t_open failed");
&space;       exit(1);
&space;   } 

&space;   if ((bind = (struct t_bind *)t_alloc(pollfds[0].fd,
&space;         T_BIND, T_ALL)) == NULL) {
&space;       t_error("t_alloc of t_bind structure failed");
&space;       exit(2);
&space;   }
&space;   bind->qlen = MAX_CONN_IND;
&space;   bind->addr.len = sizeof(int);
&space;   *(int *)bind->addr.buf = SRV_ADDR;

&space;   if (t_bind(pollfds[0].fd, bind, bind) &lt; 0)  {
&space;       t_error("t_bind failed");
&space;       exit(3);
&space;   }

&space;   /* Was the correct address bound? */ 
&space;   if (*(int *)bind->addr.buf != SRV_ADDR)  {
&space;       fprintf(stderr, "t_bind bound wrong address\n");
&space;       exit(4);
&space;   }
</CODE>
<PARAGRAPH>The file descriptor returned by <FUNCTION>t_open()</FUNCTION> is stored in a <VARIABLE>pollfd</VARIABLE> structure (see <REFPAGE>poll(2)</REFPAGE>) that polls the transport endpoint for incoming data. Notice that only one transport endpoint is established in this example. However, the remainder of the example is written to manage multiple transport endpoints. Several endpoints could be supported with minor changes to the above code.</PARAGRAPH>
<PARAGRAPH>An important aspect of this server is that it sets <VARIABLE>qlen</VARIABLE> to a value greater than 1 for <FUNCTION>t_bind()</FUNCTION>. This specifies that the server is willing to handle multiple outstanding connect indications. Remember that the earlier examples single-threaded the connect indications and responses. The server accepted the current connect indication before retrieving additional connect indications. This example, however, can retrieve up to MAX_CONN_IND connect indications at one time before responding to any of them. The transport provider can negotiate the value of <VARIABLE>qlen</VARIABLE> downward if it cannot support MAX_CONN_IND outstanding connect indications.</PARAGRAPH>
<PARAGRAPH>Once the server has bound its address and is ready to process incoming connect requests, it performs the following:</PARAGRAPH>
<CODE>
&space;   pollfds[0].events = POLLIN;
&space;   while (1) {
&space;       if (poll(pollfds, NUM_FDS, -1) &lt; 0)  {
&space;           perror("poll failed");
&space;           exit(5);
&space;       }
&space;       for (i = 0; i &lt; NUM_FDS; i++)  {

&space;           switch (pollfds[i].revents)  {

&space;           default:
&space;               perror("poll returned error event");
&space;               exit(6);

&space;           case 0:
&space;               continue;

&space;           case POLLIN:
&space;               do_event(i, pollfds[i].fd);
&space;               service_conn_ind(i, pollfds[i].fd);
&space;           }
&space;       }
&space;   }
}
</CODE>
<PARAGRAPH>The<VARIABLE>&space;events</VARIABLE> field of the <VARIABLE>pollfd</VARIABLE> structure is set to POLLIN, which notifies the server of any incoming Transport Interface events. The server then enters an infinite loop, in which it <FUNCTION>poll()</FUNCTION>s the transport endpoint(s) for events, and then processes those events as they occur.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>poll()</FUNCTION> call blocks indefinitely, waiting for an incoming event. On return, each entry (corresponding to each transport endpoint) is checked for an existing event. If <VARIABLE>revents</VARIABLE> is set to 0, no event has occurred on that endpoint. In this case, the server continues to the next transport endpoint. If <VARIABLE>revents</VARIABLE> is set to POLLIN, an event does exist on the endpoint. In this case, <FUNCTION>do_event()</FUNCTION> is called to process the event. If <VARIABLE>revents</VARIABLE> contains any other value, an error must have occurred on the transport endpoint, and the server exits.</PARAGRAPH>
<PARAGRAPH>For each iteration of the loop, if any event is found on the transport endpoint, <FUNCTION>service_conn_ind()</FUNCTION> is called to process any outstanding connect indications. However, if another connect indication is pending, <FUNCTION>service_conn_ind()</FUNCTION> saves the current connect indication and responds to it later. This routine is explained shortly. If an incoming event is discovered, the routine in <XREF IDREF="43267" TYPE="TEXT">Example&nbsp;8-7</XREF> is called to process it.</PARAGRAPH>

<!-- WARNING: (47) Example captions should come at end of Example - detected on page 233 -->
<!-- WARNINGLOCATION: PAGE = "233" SRC = "8.TLI.mif" TAGTYPE = "PARA" TAG = "ExampleTitle" TAGCOUNT = "1" UID = "1235" TEXT = " is called to process it."-->
<EXAMPLE><CAPTION LBL="8-7"><PREFIX>Example 8-7 </PREFIX><XREFTARGET ID="43267">Processing an Incoming Event</CAPTION></EXAMPLE>
<CODE>
do_event(slot, fd)
{
&space;   struct t_discon *discon;
&space;   int i;

&space;   switch (t_look(fd))  {

&space;   default:
&space;       fprintf(stderr,"t_look: unexpected event\n");
&space;       exit(7);

&space;   case T_ERROR:
&space;       fprintf(stderr,"t_look returned T_ERROR event\n");
&space;       exit(8);

&space;   case -1:
&space;       t_error("t_look failed");
&space;       exit(9);

&space;   case 0:
&space;       /* since POLLIN returned, this should not happen */
&space;       fprintf(stderr, "t_look returned no event\n");
&space;       exit(10);

&space;   case T_LISTEN:
&space;        /* find free element in calls array */

&space;       for (i = 0; i &lt; MAX_CONN_IND; i++)  {
&space;           if (calls[slot][i] == NULL)
&space;               break;
&space;       } 

&space;       if ((calls[slot][i] = (struct t_call *)t_alloc(fd,
               T_CALL, T_ALL)) == NULL)   {
&space;           t_error("t_alloc of t_call structure failed");
&space;           exit(11);
&space;       } 

&space;       if (t_listen(fd, calls[slot][i]) &lt; 0)  {
&space;           t_error("t_listen failed");
&space;           exit(12);
&space;       }
&space;       break;
&space;   case T_DISCONNECT:
&space;       discon = (struct t_discon *)t_alloc(fd,T_DIS,T_ALL);
&space;       if (t_rcvdis(fd, discon) &lt; 0)  {
&space;           t_error("t_rcvdis failed");
&space;           exit(13);
&space;       }
&space;         /* find call ind in array and delete it  */

&space;       for (i = 0; i &lt; MAX_CONN_IND; i++)  {
&space;           if (discon->sequence==calls[slot][i]->sequence) {
&space;               t_free((char*)calls[slot][i], T_CALL);
&space;               calls[slot][i] = NULL;
&space;           }
&space;       }
&space;       t_free(discon, T_DIS);
&space;       break;
&space;   }
}
</CODE>
<PARAGRAPH>This routine takes a number, <VARIABLE>slot</VARIABLE>, and a file descriptor, <VARIABLE>fd</VARIABLE>, as arguments. <VARIABLE>slot</VARIABLE> is used as an index into the global array <VARIABLE>calls</VARIABLE>. This array contains an entry for each polled transport endpoint, where each entry consists of an array of <VARIABLE>t_call</VARIABLE> structures that hold incoming connect indications for that transport endpoint. The value of <VARIABLE>slot</VARIABLE> is used to identify the transport endpoint.</PARAGRAPH>
<PARAGRAPH><FUNCTION>do_event()</FUNCTION> calls <FUNCTION>t_look()</FUNCTION> to determine the Transport Interface event that has occurred on the transport endpoint specified by <VARIABLE>fd</VARIABLE>. If a connect indication (T_LISTEN event) or disconnect indication (T_DISCONNECT event) has arrived, the event is processed. Otherwise, the server prints an appropriate error message and exits.</PARAGRAPH>
<PARAGRAPH>For connect indications, <FUNCTION>do_event()</FUNCTION> scans the array of outstanding connect indications looking for the first free entry. A <VARIABLE>t_call</VARIABLE> structure is then allocated for that entry, and the connect indication is retrieved using <FUNCTION>t_listen()</FUNCTION>. There must always be at least one free entry in the connect indication array, because the array is large enough to hold the maximum number of outstanding connect indications as negotiated by <FUNCTION>t_bind()</FUNCTION>. The processing of the connect indication is deferred until later.</PARAGRAPH>
<PARAGRAPH>If a disconnect indication arrives, it must correspond to a previously received connect indication. This occurs if a client attempts to undo a previous connect request. In this case, <FUNCTION>do_event()</FUNCTION> allocates a <VARIABLE>t_discon</VARIABLE> structure to retrieve the relevant disconnect information. This structure has the following members:</PARAGRAPH>
<CODE>
struct t_discon  {
&space;   struct netbuf udata;
&space;   int reason;
&space;   int sequence;
&space;}
</CODE>
<PARAGRAPH><VARIABLE>udata</VARIABLE> identifies any user data that might have been sent with the disconnect indication, <VARIABLE>reason</VARIABLE> contains a protocol-specific disconnect reason code, and <VARIABLE>sequence</VARIABLE> identifies the outstanding connect indication that matches this disconnect indication.</PARAGRAPH>
<PARAGRAPH>Next, <FUNCTION>t_rcvdis()</FUNCTION> is called to retrieve the disconnect indication. The array of connect indications for <VARIABLE>slot</VARIABLE> is then scanned for one that contains a sequence number that matches the <VARIABLE>sequence</VARIABLE> number in the disconnect indication. When the connect indication is found, it is freed and the corresponding entry is set to NULL.</PARAGRAPH>
<PARAGRAPH>As mentioned earlier, if any event is found on a transport endpoint, <FUNCTION>service_conn_ind()</FUNCTION> is called to process all currently outstanding connect indications associated with that endpoint as follows:</PARAGRAPH>
<CODE>
service_conn_ind(slot, fd)
{
&space;   int i;

&space;   for (i = 0; i &lt; MAX_CONN_IND; i++) {
&space;       if (calls[slot][i] == NULL)
&space;           continue;
&space;       if ((conn_fd = t_open("/dev/ticotsord", O_RDWR,
&space;                             NULL)) &lt; 0) {
&space;           t_error("open failed");
&space;           exit(14);
&space;       }
&space;       if (t_bind(conn_fd, NULL, NULL) &lt; 0) {
&space;           t_error("t_bind failed");
&space;           exit(15);
&space;       } 
&space;       if (t_accept(fd, conn_fd, calls[slot][i]) &lt; 0) {
&space;           if (t_errno == TLOOK) {
&space;               t_close(conn_fd);
&space;               return;
&space;           }
&space;           t_error("t_accept failed");
&space;           exit(16);
&space;       }
&space;       t_free((char*)calls[slot][i], T_CALL);
&space;       calls[slot][i] = NULL;

&space;       run_server(fd);
&space;   }
}
</CODE>
<PARAGRAPH>For the given slot (the transport endpoint), the array of outstanding connect indications is scanned. For each indication, the server opens a responding transport endpoint, binds an address to the endpoint, and then accepts the connection on that endpoint. If another event (connect indication or disconnect indication) arrives before the current indication is accepted, <FUNCTION>t_accept()</FUNCTION> fails and sets <VARIABLE>t_errno</VARIABLE> to TLOOK.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>The user cannot accept an outstanding connect indication if any pending connect indication events or disconnect indication events exist on that transport endpoint.</NOTE>
<PARAGRAPH>If this error occurs, the responding transport endpoint is closed and <FUNCTION>service_conn_ind()</FUNCTION> returns immediately (saving the current connect indication for later processing). This causes the server's main processing loop to be entered, and the new event is discovered by the next call to <FUNCTION>poll()</FUNCTION>. In this way, multiple connect indications can be queued by the user.</PARAGRAPH>
<PARAGRAPH>Eventually, all events are processed, and <FUNCTION>service_conn_ind()</FUNCTION> is able to accept each connect indication in turn. Once the connection is established, the <FUNCTION>run_server()</FUNCTION> routine used by the server in <XREF IDREF="15433" TYPE="TITLE">&ldquo;Introduction to Connection-Mode Service&rdquo;</XREF> is called to manage the data transfer.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="39217">State Transitions</TITLE><PARAGRAPH>These tables describe all state transitions associated with the Transport Interface. First, however, the states and events are described.<INDEXTARGET ID="8.TLI21"><!-- POSTPROCESSDATA: 8.TLI21|transport interface:state transition tablesstate transition tables (transport interface) --></PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Transport Interface States</TITLE><PARAGRAPH><XREF IDREF="90152" TYPE="TABLE">Table&nbsp;8-6</XREF> defines the states used to describe the Transport Interface state transitions.</PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-6"><PREFIX>Table 8-6 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="90152">States Describing Transport Interface State Transitions</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="81"><PARAGRAPH>State</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="110"><PARAGRAPH>Description</PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="158"><PARAGRAPH>Service Type</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>T_UNINIT</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="110"><PARAGRAPH>Uninitialized&mdash;initial and 
final state of interface </PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="158"><PARAGRAPH>T_COTS, T_COTS_ORD, T_CLTS </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>T_UNBND</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="110"><PARAGRAPH>Initialized but not bound </PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="158"><PARAGRAPH>T_COTS, T_COTS_ORD, T_CLTS </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>T_IDLE</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="110"><PARAGRAPH>No connection established </PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="158"><PARAGRAPH>T_COTS, T_COTS_ORD, T_CLTS </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>T_OUTCON</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="110"><PARAGRAPH>Outgoing connection 
pending for client </PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="158"><PARAGRAPH>T_COTS, T_COTS_ORD </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>T_INCON</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="110"><PARAGRAPH>Incoming connection 
pending for server </PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="158"><PARAGRAPH>T_COTS, T_COTS_ORD </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>T_DATAXFER </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="110"><PARAGRAPH>Data transfer</PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="158"><PARAGRAPH>T_COTS, T_COTS_ORD </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>T_OUTREL </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="110"><PARAGRAPH>Outgoing orderly release 
(waiting for orderly 
release indication) </PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="158"><PARAGRAPH>T_COTS_ORD </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>T_INREL</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="110"><PARAGRAPH>Incoming orderly release 
(waiting to send orderly 
release request) </PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="158"><PARAGRAPH>T_COTS_ORD </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Outgoing Events</TITLE><PARAGRAPH>The outgoing events described in <XREF IDREF="46456" TYPE="TABLE">Table&nbsp;8-7</XREF> correspond to the return of the specified transport routines, where these routines send a request or response to the transport provider.</PARAGRAPH>
<PARAGRAPH>In the table, some events (such as <ITALICS>accept</ITALICS>n) are distinguished by the context in which they occur. The context is based on the values of the following variables:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><VARIABLE>ocnt </VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>count of outstanding connect indications</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>fd</VARIABLE> </HANGITEM>
<HANGBODY><PARAGRAPH>file descriptor of the current transport endpoint</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>resfd </VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>file descriptor of the transport endpoint where a connection is accepted</PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-7"><PREFIX>Table 8-7 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="46456">Outgoing Events</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="50"><PARAGRAPH>Event</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="194"><PARAGRAPH>Description</PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="140"><PARAGRAPH>Service Type</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>open</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="194"><PARAGRAPH>Successful return of <FUNCTION>t_open()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="140"><PARAGRAPH>T_COTS, T_COTS_ORD, T_CLTS </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>bind</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="194"><PARAGRAPH>Successful return of <FUNCTION>t_bind()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="140"><PARAGRAPH>T_COTS, T_COTS_ORD, T_CLTS </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>optmgmt</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="194"><PARAGRAPH>Successful return of <FUNCTION>t_optmgmt()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="140"><PARAGRAPH>T_COTS, T_COTS_ORD, T_CLTS </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>unbind</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="194"><PARAGRAPH>Successful return of <FUNCTION>t_unbind()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="140"><PARAGRAPH>T_COTS, T_COTS_ORD, T_CLTS </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>close</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="194"><PARAGRAPH>Successful return of <FUNCTION>t_close()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="140"><PARAGRAPH>T_COTS, T_COTS_ORD, T_CLTS </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>sndudata</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="194"><PARAGRAPH>Successful return of <FUNCTION>t_sndudata()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="140"><PARAGRAPH>T_CLTS</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>connect1</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="194"><PARAGRAPH>Successful return of <FUNCTION>t_connect()</FUNCTION> in 
synchronous mode</PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="140"><PARAGRAPH>T_COTS, T_COTS_ORD</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>connect2</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="194"><PARAGRAPH>TNODATA error on <FUNCTION>t_connect()</FUNCTION> in 
asynchronous mode, or TLOOK error due to a 
disconnect indication arriving on the transport 
endpoint</PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="140"><PARAGRAPH>T_COTS, T_COTS_ORD</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>accept1</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="194"><PARAGRAPH>Successful return of <FUNCTION>t_accept()</FUNCTION> with ocnt == 1, 
fd == resfd</PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="140"><PARAGRAPH>T_COTS, T_COTS_ORD</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>accept2</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="194"><PARAGRAPH>Successful return of <FUNCTION>t_accept()</FUNCTION> with ocnt == 1, 
fd != resfd</PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="140"><PARAGRAPH>T_COTS, T_COTS_ORD</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>accept3</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="194"><PARAGRAPH>Successful return of <FUNCTION>t_accept()</FUNCTION> with ocnt > 1 </PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="140"><PARAGRAPH>T_COTS, T_COTS_ORD</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>snd</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="194"><PARAGRAPH>Successful return of <FUNCTION>t_snd()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="140"><PARAGRAPH>T_COTS, T_COTS_ORD</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>snddis1</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="194"><PARAGRAPH>Successful return of <FUNCTION>t_snddis()</FUNCTION> with &lbreak;ocnt &lt;= 1</PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="140"><PARAGRAPH>T_COTS, T_COTS_ORD</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>snddis2</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="194"><PARAGRAPH>Successful return of <FUNCTION>t_snddis()</FUNCTION> with ocnt > 1 </PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="140"><PARAGRAPH>T_COTS, T_COTS_ORD</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>sndrel</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="194"><PARAGRAPH>Successful return of <FUNCTION>t_sndrel()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="140"><PARAGRAPH>T_COTS_ORD</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Incoming Events</TITLE><PARAGRAPH>The incoming events correspond to the successful return of the specified routines, where these routines retrieve data or event information from the transport provider. The only incoming event not associated directly with the return of a routine is <ITALICS>pass_conn</ITALICS>, which occurs when a user transfers a connection to another transport endpoint. This event occurs on the endpoint that is being passed the connection, despite the fact that no Transport Interface routine is issued on that endpoint. <ITALICS>pass_conn</ITALICS> is included in the state tables to describe the behavior when a user accepts a connection on another transport endpoint.</PARAGRAPH>
<PARAGRAPH>In <XREF IDREF="94318" TYPE="TABLE">Table&nbsp;8-8</XREF>, the <ITALICS>rcvdis</ITALICS> events are distinguished by the context in which they occur. The context is based on the value of <VARIABLE>ocnt</VARIABLE>, which is the count of outstanding connect indications on the transport endpoint.</PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-8"><PREFIX>Table 8-8 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="94318">Incoming Events</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="54"><PARAGRAPH>Event</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="198"><PARAGRAPH>Description</PARAGRAPH>
</CELL>
<CELL LEFT="265" WIDTH="135"><PARAGRAPH>Service Type</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>rcvudata</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="198"><PARAGRAPH>Successful return of <FUNCTION>t_rcvudata()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="265" WIDTH="135"><PARAGRAPH>T_CLTS</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>rcvuderr</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="198"><PARAGRAPH>Successful return of <FUNCTION>t_rcvuderr()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="265" WIDTH="135"><PARAGRAPH>T_CLTS</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>rcvconnect</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="198"><PARAGRAPH>Successful return of <FUNCTION>t_rcvconnect()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="265" WIDTH="135"><PARAGRAPH>T_COTS, T_COTS_ORD </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>listen</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="198"><PARAGRAPH>Successful return of <FUNCTION>t_listen()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="265" WIDTH="135"><PARAGRAPH>T_COTS, T_COTS_ORD </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>rcv</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="198"><PARAGRAPH>Successful return of <FUNCTION>t_rcv()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="265" WIDTH="135"><PARAGRAPH>T_COTS, T_COTS_ORD </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>rcvdis1</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="198"><PARAGRAPH>Successful return of <FUNCTION>t_rcvdis()</FUNCTION> with ocnt &lt;= 0 </PARAGRAPH>
</CELL>
<CELL LEFT="265" WIDTH="135"><PARAGRAPH>T_COTS, T_COTS_ORD </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>rcvdis2</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="198"><PARAGRAPH>Successful return of <FUNCTION>t_rcvdis()</FUNCTION> with ocnt == 1 </PARAGRAPH>
</CELL>
<CELL LEFT="265" WIDTH="135"><PARAGRAPH>T_COTS, T_COTS_ORD </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>rcvdis3</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="198"><PARAGRAPH>Successful return of <FUNCTION>t_rcvdis()</FUNCTION> with ocnt > 1 </PARAGRAPH>
</CELL>
<CELL LEFT="265" WIDTH="135"><PARAGRAPH>T_COTS, T_COTS_ORD </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>rcvrel</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="198"><PARAGRAPH>Successful return of <FUNCTION>t_rcvrel()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="265" WIDTH="135"><PARAGRAPH>T_COTS_ORD</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>pass_conn</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="198"><PARAGRAPH>Receive a passed connection</PARAGRAPH>
</CELL>
<CELL LEFT="265" WIDTH="135"><PARAGRAPH>T_COTS, T_COTS_ORD </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Transport User Actions</TITLE><PARAGRAPH>In the state tables that follow, some state transitions are accompanied by a list of actions the transport user must take. These actions are represented by the notation [<VARIABLE>x</VARIABLE>], where <VARIABLE>x</VARIABLE> is a mnemonic for the specific action:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>[0]</HANGITEM>
<HANGBODY><PARAGRAPH>Set the count of outstanding connect indications to zero.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>[+]</HANGITEM>
<HANGBODY><PARAGRAPH>Increment the count of outstanding connect indications.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>[-]</HANGITEM>
<HANGBODY><PARAGRAPH>Decrement the count of outstanding connect indications.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>[&ndash;>]</HANGITEM>
<HANGBODY><PARAGRAPH>Pass a connection to another transport endpoint as indicated in <FUNCTION>t_accept()</FUNCTION>.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>State Tables</TITLE><PARAGRAPH><XREF IDREF="77417" TYPE="TABLE">Table&nbsp;8-9</XREF>, <XREF IDREF="75673" TYPE="TABLE">Table&nbsp;8-10</XREF>, and <XREF IDREF="36086" TYPE="TABLE">Table&nbsp;8-11</XREF> describe the Transport Interface state transitions. Given a current state and an event, the transition to the next state is shown, as well as any actions that must be taken by the transport user (indicated by [<VARIABLE>x</VARIABLE>]). The state is that of the transport provider as seen by the transport user.</PARAGRAPH>
<PARAGRAPH>To see what the next state will be in a given situation, find the table cell at the intersection of the column headed by the current state and the row labeled with the current incoming or outgoing event. An empty cell represents a state/event combination that is invalid. Along with the next state, each cell can indicate one or more actions from among those listed in the previous section. The transport user must take the specific actions in the order specified in the state table.</PARAGRAPH>
<PARAGRAPH>The following should be understood when studying the state tables:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The <FUNCTION>t_close()</FUNCTION> routine is referenced in the state tables (see <VARIABLE>close </VARIABLE>event in <XREF IDREF="77417" TYPE="TABLE">Table&nbsp;8-9</XREF>) but can be called from any state to close a transport endpoint. If <FUNCTION>t_close()</FUNCTION> is called when a transport address is bound to an endpoint, the address is unbound. Also, if <FUNCTION>t_close()</FUNCTION> is called when the transport connection is still active, the connection is aborted.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>If a transport user issues a routine out of sequence, the transport provider recognizes this and the routine fails, setting <VARIABLE>t_errno</VARIABLE> to TOUTSTATE. The state does not change.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>If any other transport error occurs, the state does not change unless explicitly stated on the manual page for that routine. The exception to this is a TLOOK or TNODATA error on <FUNCTION>t_connect()</FUNCTION>, as described in <XREF IDREF="46456" TYPE="TABLE">Table&nbsp;8-7</XREF> under &ldquo;connect2.&rdquo; The state tables assume correct use of the Transport Interface.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The support routines <FUNCTION>t_getinfo()</FUNCTION>, <FUNCTION>t_getstate()</FUNCTION>, <FUNCTION>t_alloc()</FUNCTION>, <FUNCTION>t_free()</FUNCTION>, <FUNCTION>t_sync()</FUNCTION>, <FUNCTION>t_look()</FUNCTION>, and <FUNCTION>t_error()</FUNCTION> are excluded from the state tables because they do not affect the state.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Here are the state-transition tables: one for common local management steps; one for data transfer in connectionless mode; and one for connection establishment, connection release, and data transfer in connection mode. </PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="8-9"><PREFIX>Table 8-9 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="77417">Common Local Management State Table</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="83"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="83"><PARAGRAPH>T_UNINIT</PARAGRAPH>
</CELL>
<CELL LEFT="180" WIDTH="83"><PARAGRAPH>T_UNBND</PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="83"><PARAGRAPH>T_IDLE</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH>open</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="83"><PARAGRAPH>T_UNBND</PARAGRAPH>
</CELL>
<CELL LEFT="180" WIDTH="83"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="83"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH>bind</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="83"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="180" WIDTH="83"><PARAGRAPH>T_IDLE[0]</PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="83"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH>optmgmt</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="83"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="180" WIDTH="83"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="83"><PARAGRAPH>T_IDLE</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH>unbind</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="83"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="180" WIDTH="83"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="83"><PARAGRAPH>T_UNBND </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH>close</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="83"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="180" WIDTH="83"><PARAGRAPH>T_UNINIT</PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="83"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<TABLE COLUMNS="2"><CAPTION LBL="8-10"><PREFIX>Table 8-10 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="75673">Connectionless-Mode State Table</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="166"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>T_IDLE</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>sndudata</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>T_IDLE</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>rcvudata</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>T_IDLE</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>rcvuderr</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>T_IDLE</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<TABLE COLUMNS="7"><CAPTION LBL="8-11"><PREFIX>Table 8-11 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="36086">Connection-Mode State Table</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="50"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="67"><PARAGRAPH>T_IDLE</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="67"><PARAGRAPH>T_OUTCON</PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="86"><PARAGRAPH>T_INCON</PARAGRAPH>
</CELL>
<CELL LEFT="300" WIDTH="67"><PARAGRAPH>T_DATAXFER</PARAGRAPH>
</CELL>
<CELL LEFT="375" WIDTH="52"><PARAGRAPH>T_OUTREL</PARAGRAPH>
</CELL>
<CELL LEFT="435" WIDTH="44"><PARAGRAPH>T_INREL</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>connect1</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="67"><PARAGRAPH>T_DATAXFER</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="86"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="300" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="375" WIDTH="52"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="435" WIDTH="44"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>connect2</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="67"><PARAGRAPH>T_OUTCON</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="86"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="300" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="375" WIDTH="52"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="435" WIDTH="44"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>rcvconnet</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="67"><PARAGRAPH>T_DATAXFR</PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="86"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="300" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="375" WIDTH="52"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="435" WIDTH="44"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>listen</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="67"><PARAGRAPH>T_INCON [+]</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="86"><PARAGRAPH>T_INCON [+] </PARAGRAPH>
</CELL>
<CELL LEFT="300" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="375" WIDTH="52"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="435" WIDTH="44"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>accept1</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="86"><PARAGRAPH>T_DATAXFER [-]</PARAGRAPH>
</CELL>
<CELL LEFT="300" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="375" WIDTH="52"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="435" WIDTH="44"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>accept2</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="86"><PARAGRAPH>T_IDLE [-] [&ndash;>]</PARAGRAPH>
</CELL>
<CELL LEFT="300" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="375" WIDTH="52"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="435" WIDTH="44"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>accept3</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="86"><PARAGRAPH>T_INCON [-] [&ndash;>]</PARAGRAPH>
</CELL>
<CELL LEFT="300" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="375" WIDTH="52"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="435" WIDTH="44"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>snd</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="86"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="300" WIDTH="67"><PARAGRAPH>T_DATAXFR </PARAGRAPH>
</CELL>
<CELL LEFT="375" WIDTH="52"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="435" WIDTH="44"><PARAGRAPH>T_INRL</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>rcv</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="86"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="300" WIDTH="67"><PARAGRAPH>T_DATAXFR </PARAGRAPH>
</CELL>
<CELL LEFT="375" WIDTH="52"><PARAGRAPH>T_OUTRL </PARAGRAPH>
</CELL>
<CELL LEFT="435" WIDTH="44"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>snddis1</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="67"><PARAGRAPH>T_IDLE</PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="86"><PARAGRAPH>T_IDLE [-]</PARAGRAPH>
</CELL>
<CELL LEFT="300" WIDTH="67"><PARAGRAPH>T_IDLE</PARAGRAPH>
</CELL>
<CELL LEFT="375" WIDTH="52"><PARAGRAPH>T_IDLE</PARAGRAPH>
</CELL>
<CELL LEFT="435" WIDTH="44"><PARAGRAPH>T_IDLE</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>snddis2</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="86"><PARAGRAPH>T_INCON [-]</PARAGRAPH>
</CELL>
<CELL LEFT="300" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="375" WIDTH="52"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="435" WIDTH="44"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>rcvdis1</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="67"><PARAGRAPH>T_IDLE</PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="86"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="300" WIDTH="67"><PARAGRAPH>T_IDLE</PARAGRAPH>
</CELL>
<CELL LEFT="375" WIDTH="52"><PARAGRAPH>T_IDLE</PARAGRAPH>
</CELL>
<CELL LEFT="435" WIDTH="44"><PARAGRAPH>T_IDLE</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>rcvdis2</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="86"><PARAGRAPH>T_IDLE [-]</PARAGRAPH>
</CELL>
<CELL LEFT="300" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="375" WIDTH="52"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="435" WIDTH="44"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>rcvdis3</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="86"><PARAGRAPH>T_INCON [-]</PARAGRAPH>
</CELL>
<CELL LEFT="300" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="375" WIDTH="52"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="435" WIDTH="44"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>sndrel</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="86"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="300" WIDTH="67"><PARAGRAPH>T_OUTREL </PARAGRAPH>
</CELL>
<CELL LEFT="375" WIDTH="52"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="435" WIDTH="44"><PARAGRAPH>T_IDLE</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>rcvrel</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="86"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="300" WIDTH="67"><PARAGRAPH>T_INREL</PARAGRAPH>
</CELL>
<CELL LEFT="375" WIDTH="52"><PARAGRAPH>T_IDLE</PARAGRAPH>
</CELL>
<CELL LEFT="435" WIDTH="44"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>pass_conn</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="67"><PARAGRAPH>T_DATAXFER</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="86"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="300" WIDTH="67"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="375" WIDTH="52"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="435" WIDTH="44"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="17225">Guidelines for Protocol Independence</TITLE><PARAGRAPH>By defining a set of services common to many transport protocols, the Transport Interface provides many opportunities for protocol independence. However, there exist some transport protocols that do not support all of the services supported by the Transport Interface. If software must be run in a variety of protocol environments, only the common services should be accessed.<INDEXTARGET ID="8.TLI22"><!-- POSTPROCESSDATA: 8.TLI22|protocol independence --></PARAGRAPH>
<PARAGRAPH>The following guidelines highlight services that may not be common to all transport protocols:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>In the connection-mode service, the concept of a transport service data unit (TSDU) may not be supported by all transport providers. The user should make no assumptions about the preservation of logical data boundaries across a connection. If messages must be transferred over a connection, a protocol should be implemented above the Transport Interface to support message boundaries.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Protocol- and implementation-specific service limits are returned by the <FUNCTION>t_open()</FUNCTION> and <FUNCTION>t_getinfo()</FUNCTION> routines. These limits are useful when allocating buffers to store protocol-specific transport addresses and options. It is the responsibility of the user to access these limits and then adhere to the limits throughout the communication process.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>User data should not be transmitted with connect requests or disconnect requests (see <REFPAGE>t_connect(3N)</REFPAGE> and <REFPAGE>t_snddis(3N)</REFPAGE>). Not all transport protocols support this capability.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The buffers in the <VARIABLE>t_call</VARIABLE> structure used for <FUNCTION>t_listen()</FUNCTION> must be large enough to hold any information passed by the client during connection establishment. The server should use the T_ALL argument to <FUNCTION>t_alloc()</FUNCTION>, which determines the maximum buffer sizes needed to store the address, options, and user data for the current transport provider.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The user program should not look at or change options that are associated with any Transport Interface routine. These options are specific to the underlying transport protocol. The user should not pass options with <FUNCTION>t_connect()</FUNCTION> or <FUNCTION>t_sndudata()</FUNCTION>. In such cases, the transport provider uses default values. Also, a server should use the options returned by <FUNCTION>t_listen()</FUNCTION> when accepting a connection.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Protocol-specific addressing issues should be hidden from the user program. A client should not specify any protocol address on <FUNCTION>t_bind()</FUNCTION>, but instead should allow the transport provider to assign an appropriate address to the transport endpoint. Similarly, a server should retrieve its address for <FUNCTION>t_bind()</FUNCTION> in such a way that it does not require knowledge of the transport provider's address space. Such addresses should not be hard-coded into a program. A name server procedure could be useful in this situation, but the details for providing this service are outside the scope of the Transport Interface. The reason codes associated with <FUNCTION>t_rcvdis()</FUNCTION> are protocol-dependent. The user should not interpret this information if protocol independence is important.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The error codes associated with <FUNCTION>t_rcvuderr()</FUNCTION> are protocol-dependent. The user should not interpret this information if protocol independence is a concern.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The names of devices should not be hard-coded into programs, because the device node identifies a particular transport provider and is not protocol independent.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The optional orderly release facility of the connection-mode service (provided by <FUNCTION>t_sndrel()</FUNCTION> and <FUNCTION>t_rcvrel()</FUNCTION>) should not be used by programs targeted for multiple protocol environments. This facility is not supported by all connection-based transport protocols.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="16101">Some Examples</TITLE><PARAGRAPH>This section contains examples of complete client and server programs mentioned earlier in the chapter.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Connection-Mode Client</TITLE><PARAGRAPH>The code in <XREF IDREF="52703" TYPE="TEXT">Example&nbsp;8-8</XREF> represents the connection-mode client program described in <XREF IDREF="15433" TYPE="TITLE">&ldquo;Introduction to Connection-Mode Service.&rdquo;</XREF></PARAGRAPH>
<PARAGRAPH>This client establishes a transport connection with a server, and then receives data from the server and writes that data to the client's standard output. The connection is released using the orderly release facility of the Transport Interface. This client communicates with each of the connection-mode servers presented in the guide.</PARAGRAPH>

<!-- WARNING: (47) Example captions should come at end of Example - detected on page 245 -->
<!-- WARNINGLOCATION: PAGE = "245" SRC = "8.TLI.mif" TAGTYPE = "PARA" TAG = "ExampleTitle" TAGCOUNT = "1" UID = "846" TEXT = "This client establishes a"-->
<EXAMPLE><CAPTION LBL="8-8"><PREFIX>Example 8-8 </PREFIX><XREFTARGET ID="52703">A Connection-Mode Client</CAPTION></EXAMPLE>
<CODE>
#include &lt;stdio.h>
#include &lt;tiuser.h>
#include &lt;fcntl.h>

#define SRV_ADDR 1   /* server's well-known address */ 

void main()
{
&space;   int fd;
&space;   int nbytes;
&space;   int flags = 0;
&space;   char buf[1024];
&space;   struct t_call *sndcall;
&space;   extern int t_errno;

&space;   if ((fd = t_open("/dev/ticotsord", O_RDWR, NULL)) &lt; 0) {
&space;       t_error("t_open failed");
&space;       exit(1);
&space;   }

&space;   if (t_bind(fd, NULL, NULL) &lt; 0) {
&space;       t_error("t_bind failed");
&space;       exit(2);
&space;   }

&space;   /* By assuming that the address is an integer value,
&space;    * this program may not run over another protocol. */

&space;   if ((sndcall = (struct t_call *)t_alloc(fd, T_CALL,
&space;       T_ADDR)) == NULL) {
&space;       t_error("t_alloc failed");
&space;       exit(3);
&space;   }
&space;   sndcall->addr.len = sizeof(int);
&space;   *(int *)sndcall->addr.buf = SRV_ADDR;

&space;   if (t_connect(fd, sndcall, NULL) &lt; 0) {
&space;       t_error("t_connect failed for fd");
&space;       exit(4);
&space;   } 
&space;   while ((nbytes = t_rcv(fd, buf, 1024, &amp;flags)) != -1){
&space;       if (fwrite(buf, 1, nbytes, stdout) &lt; 0){
&space;           fprintf(stderr, "fwrite failed\n");
&space;           exit(5);
&space;       }
&space;   } 
&space;   if ((t_errno == TLOOK)  &amp;&amp;  (t_look(fd) == T_ORDREL)) {
&space;       if (t_rcvrel(fd) &lt; 0) {
&space;           t_error("t_rcvrel failed");
&space;           exit(6);
&space;       }
&space;       if (t_sndrel(fd) &lt; 0) {
&space;           t_error("t_sndrel failed");
&space;           exit(7);
&space;       }
&space;       exit(0);
&space;   }
&space;   t_error("t_rcv failed");
&space;   exit(8);
&space;}
</CODE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Connection-Mode Server</TITLE><PARAGRAPH>The code in <XREF IDREF="81535" TYPE="TEXT">Example&nbsp;8-9</XREF> represents the connection-mode server program described in <XREF IDREF="15433" TYPE="TITLE">&ldquo;Introduction to Connection-Mode Service.&rdquo;</XREF> This server establishes a transport connection with a client, and then transfers a log file to the client on the other side of the connection. The connection is released using the orderly release facility of the Transport Interface. The connection-mode client presented earlier communicates with this server.</PARAGRAPH>

<!-- WARNING: (47) Example captions should come at end of Example - detected on page 246 -->
<!-- WARNINGLOCATION: PAGE = "246" SRC = "8.TLI.mif" TAGTYPE = "PARA" TAG = "ExampleTitle" TAGCOUNT = "1" UID = "1425" TEXT = " This server establishes "-->
<EXAMPLE><CAPTION LBL="8-9"><PREFIX>Example 8-9 </PREFIX><XREFTARGET ID="81535">A Connection-Mode Server</CAPTION></EXAMPLE>
<CODE>
#include &lt;tiuser.h>
#include &lt;stropts.h>
#include &lt;fcntl.h>
#include &lt;stdio.h>
#include &lt;signal.h>

#define DISCONNECT -1
#define SRV_ADDR  1  /* server's well-known address */

int conn_fd;         /* connection established here */
extern int t_errno;

void main()
{
&space;   int listen_fd;   /* listening transport endpoint */
&space;   struct t_bind *bind;
&space;   struct t_call *call;
&space;   if ((listen_fd = t_open("/dev/ticotsord", O_RDWR, NULL))
&space;       &lt; 0) {
&space;       t_error("t_open failed for listen_fd");
&space;       exit(1);
&space;   }
&space;   /*
&space;    * By assuming that the address is an integer value,
&space;    * this program may not run over another protocol.
&space;    */
&space;   if ((bind = (struct t_bind *)t_alloc(listen_fd, T_BIND,
&space;       T_ALL)) == NULL) {
&space;       t_error("t_alloc of t_bind structure failed");
&space;       exit(2);
&space;   }
&space;   bind->qlen = 1;
&space;   bind->addr.len = sizeof(int);
&space;   *(int *)bind->addr.buf = SRV_ADDR;

&space;   if (t_bind(listen_fd, bind, bind) &lt; 0) {
&space;       t_error("t_bind failed for listen_fd");
&space;       exit(3);
&space;   }

&space;   /* Was the correct address bound? */
&space;   if (*(int *)bind->addr.buf != SRV_ADDR) {
&space;       fprintf(stderr, "t_bind bound wrong address\n");
&space;       exit(4);
&space;   }
&space;   if ((call = (struct t_call *)t_alloc(listen_fd, T_CALL,
&space;                                        T_ALL)) == NULL) {
&space;       t_error("t_alloc of t_call structure failed");
&space;       exit(5);
&space;   }
&space;   while (1) {
&space;       if (t_listen(listen_fd, call) &lt; 0) {
&space;           t_error("t_listen failed for listen_fd");
&space;           exit(6);
&space;       }
&space;       if ((conn_fd = accept_call(listen_fd, call))
&space;           != DISCONNECT)
&space;           run_server(listen_fd);
&space;   }
}
&space;
int accept_call(listen_fd, call)
int listen_fd; struct t_call *call;
{
&space;   int resfd;

&space;   if ((resfd = t_open("/dev/ticotsord", O_RDWR, NULL))
&space;       &lt; 0) {
&space;       t_error("t_open for responding fd failed");
&space;       exit(7);
&space;   }
&space;   if (t_bind(resfd, NULL, NULL) &lt; 0) {
&space;       t_error("t_bind for responding fd failed");
&space;       exit(8);
&space;   }
&space;   if (t_accept(listen_fd, resfd, call) &lt; 0) {
&space;       if (t_errno == TLOOK) {  /* must be a disconnect */
&space;           if (t_rcvdis(listen_fd, NULL) &lt; 0) {
&space;               t_error("t_rcvdis failed for listen_fd");
&space;               exit(9);
&space;           }
&space;           if (t_close(resfd) &lt; 0) {
&space;               t_error("t_close failed for responding fd");
&space;               exit(10);
&space;           }
&space;           /* go back up and listen for other calls */
&space;           return(DISCONNECT);
&space;       }
&space;       t_error("t_accept failed");
&space;       exit(11);
&space;   }
&space;   return(resfd);
}

void connrelease()
&space;{
&space;   /* conn_fd is global because needed here */
&space;   if (t_look(conn_fd) == T_DISCONNECT) {
&space;       fprintf(stderr, "connection aborted\n");
&space;       exit(12);
&space;   }
&space;   /* else orderly release indication - normal exit */
&space;   exit(0);
&space;}

int run_server(listen_fd)
int listen_fd;
{
&space;   int nbytes;
&space;   FILE *logfp;        /* file pointer to log file */
&space;   char buf[1024];

&space;   switch (fork()) {

&space;   case -1:
&space;       perror("fork failed");
&space;       exit(20);

&space;   default:    /* parent */
&space;       /* close conn_fd and then go up and listen again */
&space;       if (t_close(conn_fd) &lt; 0) {
&space;           t_error("t_close failed for conn_fd");
&space;           exit(21);
&space;       }
&space;       return;

&space;   case 0:     /* child */
&space;       /* close listen_fd and do service */
&space;       if (t_close(listen_fd) &lt; 0) {
&space;           t_error("t_close failed for listen_fd");
&space;           exit(22);
&space;       }

&space;       if ((logfp = fopen("logfile", "r")) == NULL) {
&space;           perror("cannot open logfile");
&space;           exit(23);
&space;       }

&space;       signal(SIGPOLL, connrelease);
&space;       if (ioctl(conn_fd, I_SETSIG, S_INPUT) &lt; 0) {
&space;           perror("ioctl I_SETSIG failed");
&space;           exit(24);
&space;       }
&space;       if (t_look(conn_fd) != 0) {
&space;           /* disconnect wasn't there */
&space;           fprintf(stderr, "t_look: unexpected event\n");
&space;           exit(25);
&space;       }

&space;       while ((nbytes = fread(buf, 1, 1024, logfp)) > 0)
&space;           if (t_snd(conn_fd, buf, nbytes, 0) &lt; 0) {
&space;               t_error("t_snd failed");
&space;               exit(26);
&space;           }

&space;       if (t_sndrel(conn_fd) &lt; 0) {
&space;           t_error("t_sndrel failed");
&space;           exit(27);
&space;       }
&space;       pause(); /*until orderly release indication arrives*/
&space;   }
&space;}
</CODE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Connectionless-Mode Transaction Server</TITLE><PARAGRAPH>The code in <XREF IDREF="87873" TYPE="TEXT">Example&nbsp;8-10</XREF> represents the connectionless-mode transaction server program described in <XREF IDREF="60724" TYPE="TITLE">&ldquo;Introduction to Connectionless-Mode Service.&rdquo;</XREF></PARAGRAPH>
<PARAGRAPH>This server waits for incoming datagram queries, and then processes each query and sends a response.</PARAGRAPH>

<!-- WARNING: (47) Example captions should come at end of Example - detected on page 250 -->
<!-- WARNINGLOCATION: PAGE = "250" SRC = "8.TLI.mif" TAGTYPE = "PARA" TAG = "ExampleTitle" TAGCOUNT = "1" UID = "1518" TEXT = "This server waits for inc"-->
<EXAMPLE><CAPTION LBL="8-10"><PREFIX>Example 8-10 </PREFIX><XREFTARGET ID="87873">A Connectionless-Mode Transaction Server</CAPTION></EXAMPLE>
<CODE>
#include &lt;stdio.h>
#include &lt;fcntl.h>
#include &lt;tiuser.h>

#define SRV_ADDR  2   /* server's well-known address */

void main()
{
&space;   int fd;
&space;   int flags;
&space;   struct t_bind *bind;
&space;   struct t_unitdata *ud;
&space;   struct t_uderr *uderr;
&space;   extern int t_errno;

&space;   if ((fd = t_open("/dev/ticlts", O_RDWR, NULL)) &lt; 0) {
&space;       t_error("unable to open /dev/provider");
&space;       exit(1);
&space;   } 

&space;   if ((bind = (struct t_bind *)t_alloc(fd, T_BIND,
&space;                                        T_ADDR)) == NULL) {
&space;       t_error("t_alloc of t_bind structure failed");
&space;       exit(2);
&space;   }
&space;   bind->addr.len = sizeof(int);
&space;   *(int *)bind->addr.buf = SRV_ADDR;
&space;   bind->qlen = 0;

&space;   if (t_bind(fd, bind, bind) &lt; 0) {
&space;       t_error("t_bind failed");
&space;       exit(3);
&space;   } 

&space;   /* is the bound address correct? */
&space;   if (*(int *)bind->addr.buf != SRV_ADDR) {
&space;       fprintf(stderr, "t_bind bound wrong address\n");
&space;       exit(4);
&space;   }

&space;   if ((ud = (struct t_unitdata *)t_alloc(fd, T_UNITDATA,
&space;       T_ALL)) == NULL) {
&space;       t_error("t_alloc of t_unitdata structure failed");
&space;       exit(5);
&space;   }
&space;   if ((uderr = (struct t_uderr *)t_alloc(fd, T_UDERROR,
&space;                                          T_ALL)) == NULL) {
&space;       t_error("t_alloc of t_uderr structure failed");
&space;       exit(6);
&space;   } 

&space;   while (1) 
&space;       {
&space;       if (t_rcvudata(fd, ud, &amp;flags) &lt; 0) {
&space;           if (t_errno == TLOOK) {
&space;               /* Error on previously sent datagram */ 
&space;               if (t_rcvuderr(fd, uderr) &lt; 0) {
&space;                   t_error("t_rcvuderr failed");
&space;                   exit(7);
&space;               }
&space;               fprintf(stderr, "bad datagram, \
&space;                 error = %d\n", uderr->error);
&space;               continue;
&space;           } 
&space;           t_error("t_rcvudata failed");
&space;           exit(8);
&space;       } 

&space;       /* 
&space;        * Query() processes the request and places the 
&space;        * response in ud->udata.buf, setting ud->udata.len 
&space;        */ 
&space;       query(ud);

&space;       if (t_sndudata(fd, ud &lt; 0) {
&space;           t_error("t_sndudata failed");
&space;           exit(9);
&space;       }
&space;   }
}

query()
{
&space;   /* Merely a stub for simplicity */
}
</CODE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Read/Write Client</TITLE><PARAGRAPH>The code in <XREF IDREF="57028" TYPE="TEXT">Example&nbsp;8-11</XREF> represents the connection-mode read/write client program described in <XREF IDREF="77708" TYPE="TITLE">&ldquo;A Read/Write Interface.&rdquo;</XREF> This client establishes a transport connection with a server, and then uses <COMMAND>cat </COMMAND>to retrieve the data sent by the server and write that data to the client's standard output. This client communicates with each of the connection-mode servers presented in the guide.</PARAGRAPH>

<!-- WARNING: (47) Example captions should come at end of Example - detected on page 252 -->
<!-- WARNINGLOCATION: PAGE = "252" SRC = "8.TLI.mif" TAGTYPE = "PARA" TAG = "ExampleTitle" TAGCOUNT = "1" UID = "1594" TEXT = "to retrieve the data sent"-->
<EXAMPLE><CAPTION LBL="8-11"><PREFIX>Example 8-11 </PREFIX><XREFTARGET ID="57028">A Connection-Mode Read/Write Client</CAPTION></EXAMPLE>
<CODE>
#include &lt;stdio.h>
#include &lt;tiuser.h>
#include &lt;fcntl.h>
#include &lt;stropts.h>

#define SRV_ADDR  1   /* server's well-known address */

void main()
{
&space;   int fd;
&space;   int nbytes;
&space;   int flags = 0;
&space;   char buf[1024];
&space;   struct t_call *sndcall;
&space;   extern int t_errno;

&space;   if ((fd = t_open("/dev/ticotsord", O_RDWR, NULL)) &lt; 0) {
&space;       t_error("t_open failed");
&space;       exit(1);
&space;   } 

&space;   if (t_bind(fd, NULL, NULL) &lt; 0) {
&space;       t_error("t_bind failed");
&space;       exit(2);
&space;   } 

&space;    /* By assuming that the address is an integer value,
&space;     * this program may not run over another protocol. */ 

&space;   if ((sndcall = (struct t_call *)t_alloc(fd, T_CALL,
&space;       T_ADDR)) == NULL) {
&space;       t_error("t_alloc failed");
&space;       exit(3);
&space;   } 

&space;   sndcall->addr.len = sizeof(int);
&space;   *(int *)sndcall->addr.buf = SRV_ADDR;

&space;   if (t_connect(fd, sndcall, NULL) &lt; 0) 
{
&space;       t_error("t_connect failed for fd");
&space;       exit(4);
&space;   }
&space;   if (ioctl(fd, I_PUSH, "tirdwr") &lt; 0) {
&space;       perror("I_PUSH of tirdwr failed");
&space;       exit(5);
&space;   } 

&space;   close(0);
&space;   dup(fd);

&space;   execl("/usr/bin/cat", "/usr/bin/cat", 0);
&space;   perror("execl of /usr/bin/cat failed");
&space;   exit(6);
}
</CODE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Event-Driven Server</TITLE><PARAGRAPH>The code in <XREF IDREF="43036" TYPE="TEXT">Example&nbsp;8-12</XREF> represents the connection-mode server program described in <XREF IDREF="80913" TYPE="TITLE">&ldquo;Advanced Topics.&rdquo;</XREF> This server manages multiple connect indications in an event-driven manner. Either connection-mode client presented earlier communicates with this server.</PARAGRAPH>

<!-- WARNING: (47) Example captions should come at end of Example - detected on page 254 -->
<!-- WARNINGLOCATION: PAGE = "254" SRC = "8.TLI.mif" TAGTYPE = "PARA" TAG = "ExampleTitle" TAGCOUNT = "1" UID = "1672" TEXT = " This server manages mult"-->
<EXAMPLE><CAPTION LBL="8-12"><PREFIX>Example 8-12 </PREFIX><XREFTARGET ID="43036">A Connection-Mode Server</CAPTION></EXAMPLE>
<CODE>
#include &lt;tiuser.h>
#include &lt;fcntl.h>
#include &lt;stdio.h>
#include &lt;poll.h>
#include &lt;stropts.h>
#include &lt;signal.h>

#define NUM_FDS         1
#define MAX_CONN_IND    4
#define SRV_ADDR        1 /* server's well-known address */

int conn_fd;        /* server connection here */
extern int t_errno;

/* holds connect indications */
struct t_call *calls[NUM_FDS][MAX_CONN_IND];

void main()
{
&space;   struct pollfd pollfds[NUM_FDS];
&space;   struct t_bind *bind;
&space;   int i;

&space;   / * Only opening and binding one transport endpoint,
&space;     * but more could be supported  */

&space;   if ((pollfds[0].fd = t_open("/dev/ticotsord", O_RDWR,
&space;       NULL)) &lt; 0) {
&space;       t_error("t_open failed");
&space;       exit(1);
&space;   }

&space;   if ((bind = (struct t_bind *)t_alloc(pollfds[0].fd,
&space;       T_BIND, T_ALL)) == NULL) {
&space;       t_error("t_alloc of t_bind structure failed");
&space;       exit(2);
&space;   }
&space;   bind->qlen = MAX_CONN_IND;
&space;   bind->addr.len = sizeof(int);
&space;   *(int *)bind->addr.buf = SRV_ADDR;

&space;   if (t_bind(pollfds[0].fd, bind, bind) &lt; 0) {
&space;       t_error("t_bind failed");
&space;       exit(3);
&space;   }

&space;   /* Was the correct address bound? */
&space;   if (*(int *)bind->addr.buf != SRV_ADDR) {
&space;       fprintf(stderr, "t_bind bound wrong address\n");
&space;       exit(4);
&space;   } 

&space;   pollfds[0].events = POLLIN;

&space;   while (1) {
&space;       if (poll(pollfds, NUM_FDS, -1) &lt; 0) {
&space;           perror("poll failed");
&space;           exit(5);
&space;       }

&space;       for (i = 0; i &lt; NUM_FDS; i++) {

&space;           switch (pollfds[i].revents) {

&space;           default:
&space;               perror("poll returned error event");
&space;               exit(6);

&space;           case 0:
&space;               continue;

&space;           case POLLIN:
&space;               do_event(i, pollfds[i].fd);
&space;               service_conn_ind(i, pollfds[i].fd);
&space;           }
&space;       }
&space;   } 
} 
do_event(slot, fd) 
{
&space;   struct t_discon *discon;
&space;   int i;

&space;   switch (t_look(fd)) {

&space;   default: 
&space;       fprintf(stderr,"t_look: unexpected event\n");
&space;       exit(7);

&space;   case T_ERROR:
&space;       fprintf(stderr,"t_look returned T_ERROR event\n");
&space;       exit(8);

&space;   case -1:
&space;       t_error("t_look failed");
&space;       exit(9);

&space;   case 0:
&space;       /* since POLLIN returned, this should not happen */
&space;       fprintf(stderr,"t_look returned no event\n");
&space;       exit(10);
&space;       case T_LISTEN:
&space;       /* find free element in calls array */

&space;       for (i = 0; i &lt; MAX_CONN_IND; i++) {
&space;           if (calls[slot][i] == NULL)
&space;               break;
&space;       }
&space;       if ((calls[slot][i] = (struct t_call *)t_alloc(fd,
&space;           T_CALL, T_ALL)) == NULL)  {
&space;           t_error("t_alloc of t_call structure failed");
&space;           exit(11);
&space;       }
&space;       if (t_listen(fd, calls[slot][i]) &lt; 0) {
&space;           t_error("t_listen failed");
&space;           exit(12);
&space;       }
&space;       break;

&space;   case T_DISCONNECT:
&space;       discon = (struct t_discon *)t_alloc(fd,T_DIS,T_ALL);

&space;       if (t_rcvdis(fd, discon) &lt; 0) {
&space;           t_error("t_rcvdis failed");
&space;           exit(13);
&space;       }
&space;        /* find call ind in array and delete it  */

&space;       for (i = 0; i &lt; MAX_CONN_IND; i++) {
&space;           if (discon->sequence==calls[slot][i]->sequence) {
&space;               t_free((char*)calls[slot][i], T_CALL);
&space;               calls[slot][i] = NULL;
&space;           }
&space;       } 
&space;       t_free((char*)discon, T_DIS);
&space;       break;
&space;   }
&space;} 
service_conn_ind(slot, fd) 
{
&space;   int i;
&space;   for (i = 0; i &lt; MAX_CONN_IND; i++) {
&space;       if (calls[slot][i] == NULL) 
&space;           continue;
&space;       if ((conn_fd = t_open("/dev/ticotsord", O_RDWR,
&space;                             NULL)) &lt; 0){
&space;           t_error("open failed");
&space;           exit(14);
&space;       }

&space;       if (t_bind(conn_fd, NULL, NULL) &lt; 0)  {
&space;           t_error("t_bind failed");
&space;           exit(15);
&space;       }
&space;       if (t_accept(fd, conn_fd, calls[slot][i]) &lt; 0) {
&space;           if (t_errno == TLOOK) {
&space;               t_close(conn_fd);
&space;               return;
&space;           }
&space;           t_error("t_accept failed");
&space;           exit(16);
&space;       }
&space;       t_free((char*)calls[slot][i], T_CALL);
&space;       calls[slot][i] = NULL;

&space;       run_server(fd);
&space;   }
&space;} 

void connrelease() 
{
&space;   /* conn_fd is global because needed here */
&space;   if (t_look(conn_fd) == T_DISCONNECT) {
&space;       fprintf(stderr, "connection aborted\n");
&space;       exit(12);
&space;   } 

&space;   /* else orderly release indication - normal exit */
&space;   exit(0);
} 

int run_server(listen_fd) 
int listen_fd;
{
&space;   int nbytes;
&space;   FILE *logfp;        /* file pointer to log file */ 
&space;   char buf[1024];

&space;   switch (fork()) 
{

&space;   case -1: 
&space;       perror("fork failed");
&space;       exit(20);

&space;   default:     /* parent */

&space;       /* close conn_fd and then go up and listen again */
&space;       if (t_close(conn_fd) &lt; 0) {
&space;           t_error("t_close failed for conn_fd");
&space;           exit(21);
&space;       }
&space;       return;

&space;   case 0:     /* child */

&space;       /* close listen_fd and do service */
&space;       if (t_close(listen_fd) &lt; 0) {
&space;           t_error("t_close failed for listen_fd");
&space;           exit(22);
&space;       }
&space;       if ((logfp = fopen("logfile", "r")) == NULL) {
&space;           perror("cannot open logfile");
&space;           exit(23);
&space;       }

&space;       signal(SIGPOLL, connrelease);
&space;       if (ioctl(conn_fd, I_SETSIG, S_INPUT) &lt; 0) {
&space;           perror("ioctl I_SETSIG failed");
&space;           exit(24);
&space;       }
&space;       /* disconnect already there? */
&space;       if (t_look(conn_fd) != 0) {
&space;           fprintf(stderr, "t_look: unexpected event\n");
&space;           exit(25);
&space;       }

&space;       while ((nbytes = fread(buf, 1, 1024, logfp)) > 0)
&space;           if (t_snd(conn_fd, buf, nbytes, 0) &lt; 0){
&space;               t_error("t_snd failed");
&space;               exit(26);
&space;           }

&space;       if (t_sndrel(conn_fd) &lt; 0) {
&space;           t_error("t_sndrel failed");
&space;           exit(27);
&space;       }
&space;       pause();
&space;   /* until orderly release indication arrives */
&space;   }
&space;}
</CODE>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="34328">Error Messages</TITLE><PARAGRAPH>The following errors have been added to TLI for X/Open Transport Interface (XTI) compatibility.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>&space;XTI has changed the names specified by <VARIABLE>struct_type</VARIABLE> by appending _STR to the end. For example, to allocate a <VARIABLE>t_bind</VARIABLE> structure, the argument <VARIABLE>struct_type</VARIABLE> is T_BIND_STR instead of T_BIND. The old names will continue to be supported. <FUNCTION>t_free()</FUNCTION> supports the new names for the <VARIABLE>struct_type</VARIABLE> argument. </NOTE>
<PARAGRAPH>Upon failure, <FUNCTION>t_accept()</FUNCTION> sets t_errno to TBADADDR if the specified protocol address was in an incorrect format or contained illegal information.</PARAGRAPH>
<PARAGRAPH>Upon failure, <FUNCTION>t_alloc()</FUNCTION> sets t_errno to TNOSTRUCTYPE if the <VARIABLE>struct_type</VARIABLE> parameter is invalid.</PARAGRAPH>
<PARAGRAPH>Upon failure, <FUNCTION>t_bind()</FUNCTION> sets t_errno to TADDRBUSY if the requested address is in use and the transport provider can't allocate an new address.</PARAGRAPH>
<PARAGRAPH><FUNCTION>t_look()</FUNCTION> includes two new events, and an existing event was removed. The T_ERROR event was removed because it can be handled by setting t_errno to TSYSERR. The new events, T_GODATA and T_GOEXDATA, are returned to indicate that flow-control restrictions on normal data flow (T_GODATA) or expedited data flow (T_GOEXDATA) have been lifted and data may be sent again.</PARAGRAPH>
<PARAGRAPH>Upon failure, <FUNCTION>t_open()</FUNCTION> sets <VARIABLE>t_errno</VARIABLE> to:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>TBADFLAG</HANGITEM>
<HANGBODY><PARAGRAPH>if <VARIABLE>oflag</VARIABLE> is invalid.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>TBADNAME</HANGITEM>
<HANGBODY><PARAGRAPH>if <VARIABLE>name</VARIABLE> is not a valid transport provider.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>Upon failure, <FUNCTION>t_rcv()</FUNCTION>, <FUNCTION>t_rcvconnect()</FUNCTION>, <FUNCTION>t_rcvdis()</FUNCTION>, <FUNCTION>t_rcvrel()</FUNCTION>, and <FUNCTION>t_rcvudata()</FUNCTION> set <VARIABLE>t_errno</VARIABLE> to TOUTSTATE if the function was issued in the wrong sequence on this transport endpoint.</PARAGRAPH>
<PARAGRAPH>Upon failure, <FUNCTION>t_snd()</FUNCTION> sets <VARIABLE>t_errno</VARIABLE> to:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>TBADFLAG </HANGITEM>
<HANGBODY><PARAGRAPH>if <VARIABLE>oflag</VARIABLE> is invalid.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>TLOOK </HANGITEM>
<HANGBODY><PARAGRAPH>if an asynchronous event has occurred on this transport endpoint and requires immediate attention.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>TOUTSTATE </HANGITEM>
<HANGBODY><PARAGRAPH>if the function was issued in the wrong sequence on this transport endpoint.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>Upon failure, <FUNCTION>t_sndrel()</FUNCTION> and <FUNCTION>t_sndudata()</FUNCTION> set t_errno to:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>&space;TLOOK </HANGITEM>
<HANGBODY><PARAGRAPH>if an asynchronous event has occurred on this transport endpoint and requires immediate attention.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>&space;TOUTSTATE </HANGITEM>
<HANGBODY><PARAGRAPH>if the function was issued in the wrong sequence on this transport endpoint.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION1>
</CHAPTER>
