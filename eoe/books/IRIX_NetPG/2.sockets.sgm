<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="2"><TITLE><XREFTARGET ID="60843">Sockets-based Communication</TITLE><PARAGRAPH>This chapter describes the BSD sockets-based Inter-Process Communication (IPC) facilities available with the IRIX operating system.</PARAGRAPH>
<PARAGRAPH>Topics in this chapter include:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>the basic sockets communication model and IPC-related system calls</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>network library routines used to construct distributed applications</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the client/server model that is used to develop applications, including examples of the two major types of servers</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>advanced topics for sophisticated users, such as UDP/IP broadcasting and multicasting</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="38273">Sockets Basics</TITLE><PARAGRAPH>A <ITALICS>socket</ITALICS> is the basic building block for program-to-program communication. A socket is an endpoint of communication to which a name can be bound. Each socket in use has a <ITALICS>type</ITALICS> and one or more associated processes. Sockets are typed according to their communication properties.</PARAGRAPH>
<PARAGRAPH>Four socket types are available:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><ITALICS>Stream sockets</ITALICS> provide a bidirectional, reliable, sequenced, and unduplicated flow of message data.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><ITALICS>Datagram sockets</ITALICS> support bidirectional data flow, but do not guarantee that the message data is sequenced, reliable, or unduplicated.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><ITALICS>ST</ITALICS> sockets provides a reliable, sequenced, and unduplicated flow of message data and requires data transfers to be scheduled in advance.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><ITALICS>Raw sockets</ITALICS> give you access to the underlying communication protocols that support socket abstractions.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>(All four socket types are described in <XREF IDREF="32263" TYPE="TITLE">&ldquo;Socket Types&rdquo;</XREF>.)</PARAGRAPH>
<PARAGRAPH>The processes associated with a socket communicate through the socket. Sockets are presumed to communicate with sockets of the same type; however, nothing prevents communication between sockets of different types should the underlying communication protocols support it.</PARAGRAPH>
<PARAGRAPH>Sockets exist within <ITALICS>communication domains</ITALICS>. A domain dictates various properties of the socket. One such property is the scheme used to name sockets. For example, in the UNIX communication domain, sockets are named with UNIX pathnames; a socket, for example, may be named <FILENAME>/dev/foo</FILENAME>.</PARAGRAPH>
<PARAGRAPH>Normally, sockets exchange data within the same domain. It may be possible to cross domain boundaries, but only if some translation process is performed.</PARAGRAPH>
<PARAGRAPH>The sockets facility supports three communication domains:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The <ITALICS>UNIX domain</ITALICS> is used only for on-system communication.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The <ITALICS>Internet domain</ITALICS> is used by processes that communicate using the Internet standard communication protocols IP/TCP/UDP.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The <ITALICS>Raw domain</ITALICS> provides access to the link-level protocols of network interfaces (unique to IRIX).</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The underlying communication facilities provided by each domain significantly influence the interface to the sockets facilities available to users, providing protocol-specific socket properties that may be set or changed by the user. For example, a socket operating in the UNIX domain can see a subset of the error conditions that are possible when operating in the Internet domain.</PARAGRAPH>
<PARAGRAPH>In general, there is one protocol for each socket type within each domain. The code that implements a protocol keeps track of the names that are bound to sockets, sets up connections, and transfers data between sockets, perhaps sending the data across a network. It is possible for several protocols, differing only in low-level details, to implement the same style of communication within a particular domain. Although it is possible to select which protocol should be used, for nearly all uses it is sufficient to request the default protocol.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="32263">Socket Types</TITLE><PARAGRAPH>This section describes the three socket types: stream sockets, datagram sockets, and raw sockets.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Stream Sockets</TITLE><PARAGRAPH>A <ITALICS>stream</ITALICS> socket provides a bidirectional, reliable, sequenced, and unduplicated flow of data without record boundaries. Aside from the bidirectionality of data flow and some additional signaling facilities, a pair of connected stream sockets provides an interface similar to that of a pipe. (In the UNIX domain, in fact, the semantics are identical.)</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>Stream sockets should not be confused with STREAMS, the modularized driver interface on which TLI is built.</NOTE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Datagram Sockets</TITLE><PARAGRAPH>A <ITALICS>datagram</ITALICS> socket supports the bidirectional flow of messages that are not necessarily sequenced, reliable, or unduplicated. That is, a process receiving messages on a datagram socket can find messages duplicated or in a different order. The data in any single message, however, is in the correct order, with no duplications, deletions, or changes.</PARAGRAPH>
<PARAGRAPH>An important characteristic of a datagram socket is that record boundaries in the data are preserved. Datagram sockets closely model facilities found in many packet-switched networks. However, datagram sockets provide additional facilities, including routing and fragmentation.</PARAGRAPH>
<PARAGRAPH>Routing is used to forward messages from one local network to another nearby or distant network. Dividing one large network into several smaller ones can improve network performance in each smaller network, improve security, and facilitate administration and troubleshooting.</PARAGRAPH>
<PARAGRAPH>Fragmentation divides large messages into pieces small enough to fit on the local medium. It allows application programs to use a single message size independent of the packet size limitations of the underlying networks.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>ST Sockets</TITLE><PARAGRAPH>An <INDEXTARGET ID="2.sockets1"><!-- POSTPROCESSDATA: 2.sockets1|socket:ST --><ITALICS>ST</ITALICS> socket provides a reliable, sequenced, and unduplicated flow of data. The ST protocol provides the receiving host or device more control over the flow of data by requiring data transfers to be scheduled in advance and does not allow data to be sent until the resources to support the transfer have been allocated and reserved on the receiving host or device.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Raw Sockets</TITLE><PARAGRAPH>A <ITALICS>raw</ITALICS> socket provides access to the underlying communication protocols that support socket abstractions. Raw sockets are normally datagram-oriented, though their exact characteristics depend on the interface provided by the protocol.</PARAGRAPH>
<PARAGRAPH>Raw sockets are not intended for the general user. They are provided for programmers interested in developing new communication protocols or for gaining access to some of the more esoteric facilities of an existing protocol.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="20443">Creating Sockets</TITLE><PARAGRAPH>To create a socket, use the <FUNCTION>socket()</FUNCTION> system call (see <REFPAGE>socket(2)</REFPAGE>):</PARAGRAPH>
<CODE>
#include &lt;sys/types.h>
#include &lt;sys/socket.h>
s = socket(domain, type, protocol);
</CODE>
<PARAGRAPH>This call creates a socket in the specified <VARIABLE>domain</VARIABLE>, of the specified <VARIABLE>type</VARIABLE>, using the specified <VARIABLE>protocol</VARIABLE>, and returns a descriptor (a small integer) that can be used in later system calls operating on sockets.</PARAGRAPH>
<PARAGRAPH>If <VARIABLE>protocol</VARIABLE> is not specified (a 0 value is given), a default protocol is used. The system selects from the protocols that make up the communication domain and that can be used to support the requested socket type.</PARAGRAPH>
<PARAGRAPH>The domain is specified as one of the manifest constants defined in the file &lt;<FILENAME>sys/socket.h</FILENAME>>:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>AF_UNIX</HANGITEM>
<HANGBODY><PARAGRAPH>UNIX domain</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>AF_INET</HANGITEM>
<HANGBODY><PARAGRAPH>Internet domain</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>AF_RAW</HANGITEM>
<HANGBODY><PARAGRAPH>Raw domain</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<NOTE><PREFIX>Note</PREFIX>AF indicates the <ITALICS>address family</ITALICS> (or format) to use in interpreting names. </NOTE>
<PARAGRAPH>The socket types are also defined in &lt;<FILENAME>sys/socket.h</FILENAME>>, as SOCK_STREAM, SOCK_DGRAM, or SOCK_RAW.</PARAGRAPH>
<PARAGRAPH>For example, to create a stream socket in the Internet domain, you could use this call:</PARAGRAPH>
<CODE>
s = socket(AF_INET, SOCK_STREAM, 0);
</CODE>
<PARAGRAPH>This creates a stream socket in which underlying communication support is provided by the default protocol, TCP.</PARAGRAPH>
<PARAGRAPH>The default protocol should be correct for most situations. However, you can specify other protocols; see <XREF IDREF="75950" TYPE="TITLE">&ldquo;Selecting Protocols&rdquo;</XREF> for details.</PARAGRAPH>
<PARAGRAPH>To create a datagram socket for same&ndash;machine use, the call might be:</PARAGRAPH>
<EXAMPLE>
s = socket(AF_UNIX, SOCK_DGRAM, 0);
</EXAMPLE>
<PARAGRAPH>To create an ST socket in the Internet domain, you could use this call:</PARAGRAPH>
<CODE>
s = socket(AF_INET, SEQPACKET, 0);
</CODE>
<PARAGRAPH>This creates an ST socket in which underlying communication support is provided by IP protocol.</PARAGRAPH>
<PARAGRAPH>To create a <ITALICS>drain</ITALICS> socket, which receives all packets that have a network&ndash;layer type-code or encapsulation not implemented by the kernel, use this call:</PARAGRAPH>
<CODE>
#include &lt;net/raw.h>
s = socket(AF_RAW, SOCK_RAW, RAWPROTO_DRAIN);
</CODE>
<PARAGRAPH>For details about raw domain sockets, see the manual pages for <REFPAGE>raw(7F)</REFPAGE>, <REFPAGE>snoop(7P)</REFPAGE>, and <REFPAGE>drain(7P)</REFPAGE>.</PARAGRAPH>
<PARAGRAPH>A <FUNCTION>socket()</FUNCTION> call can fail for several reasons, each of which sets the <VARIABLE>errno</VARIABLE> variable appropriately. Aside from the rare occurrence of lack of memory (ENOBUFS), a socket request can fail in response to a request for an unknown protocol (EPROTONOSUPPORT) or a request for a type of socket for which there is no supporting protocol (EPROTOTYPE).</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Binding Local Names to a Socket</TITLE><PARAGRAPH>A socket is created without a name. Until a name is bound to the socket, processes have no way to reference it, and, consequently, no messages can be received on it.</PARAGRAPH>
<PARAGRAPH>Communicating processes are bound by an association. An <ITALICS>association</ITALICS> is a temporary or permanent specification of a pair of communicating sockets.</PARAGRAPH>
<PARAGRAPH>In the Internet domain, an association is composed of local and foreign addresses, and local and foreign ports. The structure of Internet domain addresses is defined in the file &lt;<FILENAME>netinet/in.h</FILENAME>>.</PARAGRAPH>
<PARAGRAPH>Internet addresses specify a host address (a 32-bit number) and a delivery slot, or port, on that machine. These ports are managed by the system routines that implement a particular protocol. Unlike UNIX domain socket names, Internet domain socket names are not entered into the filesystem and, therefore, do not have to be unlinked after the socket is closed.</PARAGRAPH>
<PARAGRAPH>When a message is exchanged between machines, it is first sent to the protocol routine on the destination machine. This routine interprets the address to determine to which socket the message should be delivered. Several different protocols may be active on the same machine, but, in general, they will not communicate with one another. As a result, different protocols are allowed to use the same port numbers. Thus, an Internet address is a triple address, including a protocol, the port, and the machine address.</PARAGRAPH>
<PARAGRAPH>An Internet association is identified by the tuple &lt;<VARIABLE>protocol, local address, local port, remote address, remote port</VARIABLE>>. Duplicate tuples are not allowed. An association may be transient when using datagram sockets; the association actually exists during a <FUNCTION>send()</FUNCTION> operation.</PARAGRAPH>
<PARAGRAPH>In the UNIX domain, an association is composed of local and foreign pathnames (a <ITALICS>foreign pathname</ITALICS> is a pathname created by a foreign process, not a pathname on a foreign system). UNIX domain sockets need not always be bound to a name, but when they are bound, there may never be duplicate &lt;<VARIABLE>protocol, local pathname, foreign pathname</VARIABLE>> tuples.</PARAGRAPH>
<PARAGRAPH>The pathnames may not refer to files already existing on the system. Like pathnames for normal files, they may be either absolute (for example, <FILENAME>/dev/imaginary</FILENAME>) or relative (for example, <FILENAME>socket</FILENAME>). Because these names are used to allow processes to rendezvous, relative pathnames can pose difficulties and should be used with care.</PARAGRAPH>
<PARAGRAPH>When a name is bound into the name space, a file (inode) is allocated in the filesystem. If the inode is not deallocated, the name will continue to exist even after the bound socket is closed. This situation can cause subsequent runs of a program to find a name unavailable and can cause directories to fill up with these objects. You can remove names by calling <FUNCTION>unlink()</FUNCTION> (see <REFPAGE>unlink(2)</REFPAGE>) or by using the <COMMAND>rm</COMMAND> command.</PARAGRAPH>
<PARAGRAPH>Names in the UNIX domain are used only for rendezvous; they are not used for message delivery once a connection is established. Therefore, in contrast to the Internet domain, unbound sockets are not, and need not be, automatically given addresses when they are connected.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>bind()</FUNCTION> system call (see <REFPAGE>bind(2)</REFPAGE>) allows a process to specify half of an association, &lt;<VARIABLE>local address, local port</VARIABLE>> (or &lt;<VARIABLE>local pathname</VARIABLE>>), while the <FUNCTION>connect()</FUNCTION> and <FUNCTION>accept()</FUNCTION> system calls are used to complete a stream socket's association.</PARAGRAPH>
<PARAGRAPH>The form of the <FUNCTION>bind()</FUNCTION> system call is:</PARAGRAPH>
<EXAMPLE>
bind(s, name, namelen);
</EXAMPLE>
<PARAGRAPH>The bound name is a variable-length byte string that is interpreted by the supporting protocol(s). The interpretation of the bound name may vary from communication domain to communication domain (this is one of the properties that make up the domain).</PARAGRAPH>
<PARAGRAPH>In the UNIX domain, names contain a pathname and a family, which is always AF_UNIX. The following code fragment binds the name <FILENAME>/tmp/foo</FILENAME> to a UNIX domain socket:</PARAGRAPH>
<CODE>
#include &lt;sys/un.h>
&space;...
struct sockaddr_un addr;
&space;...
strcpy(addr.sun_path, "/tmp/foo");
addr.sun_family = AF_UNIX;
bind(s, (struct sockaddr *)&amp;addr, strlen(addr.sun_path) +
&space;    sizeof(addr.sun_family));
</CODE>
<PARAGRAPH>Note that in determining the size of a UNIX domain address, null bytes are not counted, which is why <FUNCTION>strlen()</FUNCTION> is used.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>In the current implementation of UNIX domain IPC under IRIX, the filename referred to in <VARIABLE>addr.sun_path</VARIABLE> is created as a socket in the system's file space. The caller must, therefore, have write permission in the directory where <VARIABLE>addr.sun_path</VARIABLE> is to reside, and this file should be deleted by the caller when it is no longer needed using the <FUNCTION>unlink()</FUNCTION> system call (see <REFPAGE>unlink(2)</REFPAGE>). Future versions of IRIX may not create this file.&space;</NOTE>
<PARAGRAPH>In the Internet domain, binding names to sockets can be fairly complex. Fortunately, it usually isn't necessary to specifically bind an address and port number to a socket, because the <FUNCTION>connect()</FUNCTION> and <FUNCTION>send()</FUNCTION> calls automatically bind an appropriate address if they are used with an unbound socket. To bind an Internet address, use the <FUNCTION>bind()</FUNCTION> system call like this:</PARAGRAPH>
<CODE>
#include &lt;sys/types.h>
#include &lt;netinet/in.h>
&space;...
struct sockaddr_in sin;
&space;...
bind(s, (struct sockaddr *)&amp;sin, sizeof(sin));
</CODE>
<NOTE><PREFIX>Note</PREFIX>Selecting what to place in the address <VARIABLE>sin</VARIABLE> requires some discussion. See <XREF IDREF="93055" TYPE="TITLE">&ldquo;Network Library Routines&rdquo;</XREF> for information about formulating Internet addresses and the library routines used in name resolution.</NOTE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="30328">Establishing Socket Connections</TITLE><PARAGRAPH>Stream socket connections are usually established asymmetrically, with one process a client and the other a server. When it offers its advertised services, the server binds a socket to a well-known address associated with the service and then passively listens on its socket. It is then possible for an unrelated process to rendezvous with the server.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>For details about datagram sockets, see <XREF IDREF="77749" TYPE="TITLE">&ldquo;Connectionless Sockets&rdquo;</XREF>.</NOTE>
<PARAGRAPH>The client requests services from the server by initiating a connection to the server's socket. On the client side, the <FUNCTION>connect()</FUNCTION> call is used to initiate a connection. Using the UNIX domain, this might appear as:</PARAGRAPH>
<CODE>
struct sockaddr_un server;
&space;...
connect(s, (struct sockaddr *)&amp;server,
&space;   strlen(server.sun_path) +
&space;   sizeof(server.sun_family));
</CODE>
<PARAGRAPH>Using the Internet domain, this might appear as:</PARAGRAPH>
<CODE>
struct sockaddr_in server;
&space;...
connect(s, (struct sockaddr *)&amp;server, sizeof(server));
</CODE>
<PARAGRAPH>In the preceding examples, <VARIABLE>server</VARIABLE> contains either the UNIX pathname or the Internet address and port number of the server to contact. If the client process's socket is unbound at the time of the <FUNCTION>connect()</FUNCTION> call, the system will automatically select and bind a name to the socket if necessary. This is the way local addresses are usually bound to a socket.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>connect()</FUNCTION> call returns an error if the connection attempt was unsuccessful (any name automatically bound by the system, however, remains). Otherwise, the socket is associated with the server, and data transfer can begin.</PARAGRAPH>
<PARAGRAPH>When a connection attempt fails, an error is returned and the global variable <VARIABLE>errno</VARIABLE> is set to indicate the error. <XREF IDREF="75346" TYPE="TABLE">Table&nbsp;2-1</XREF> lists some of the more common <VARIABLE>errno</VARIABLE> values.</PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="2-1"><PREFIX>Table 2-1 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="75346">Common <VARIABLE>errno</VARIABLE> values</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="129"><PARAGRAPH>Value</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="257"><PARAGRAPH>Explanation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="129"><PARAGRAPH>ETIMEDOUT</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="257"><PARAGRAPH>This error indicates that after failing to establish a connection for 
a period of time, the system stopped trying. It usually occurs 
because the destination host is down or because problems in the 
network resulted in lost transmissions. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="129"><PARAGRAPH>ECONNREFUSED</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="257"><PARAGRAPH>This error indicates that the host has refused service. It usually 
occurs because a server process is not present at the requested 
port on the host. It may also indicate an explicit refusal due to 
access control.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="129"><PARAGRAPH>EHOSTDOWN, ENETDOWN </PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="257"><PARAGRAPH>These errors describe status information delivered to the client 
host by the underlying communication services.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="129"><PARAGRAPH>EHOSTUNREACH,</PARAGRAPH>
<PARAGRAPH>ENETUNREACH</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="257"><PARAGRAPH>These errors can occur either because the network or host is 
unknown (no route to the network or host is present) or because 
of status information returned by intermediate gateways or 
switching nodes. Many times the status returned is not 
sufficient to determine if a network or host is down, in which 
case the system indicates that the entire network is unreachable.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>To receive a client's connection, the server must perform two steps after binding its socket: it indicates that it is ready to listen for incoming connection requests, and then it accepts the connection.<INDEXTARGET ID="2.sockets2"><!-- POSTPROCESSDATA: 2.sockets2|listen --></PARAGRAPH>
<PARAGRAPH>To indicate that a socket is ready to listen for incoming connection requests, use the <FUNCTION>listen()</FUNCTION> call (see <REFPAGE>listen(2)</REFPAGE>):</PARAGRAPH>
<EXAMPLE>
listen(s, 5);
</EXAMPLE>
<PARAGRAPH>The second parameter of the <FUNCTION>listen()</FUNCTION> call specifies the maximum number of outstanding connections that can be queued awaiting acceptance by the server process; this number is limited by the system and is a value that is intended to catch flagrant abuses of system resources. If a connection is requested while the queue is full, the connection is not refused, but the individual messages that make up the request are ignored. This gives a busy server time to make room in its pending connection queue while the client retries the connection request. If the connection returns with the ECONNREFUSED error, the client will be unable to determine whether the server is up.</PARAGRAPH>
<PARAGRAPH>It is still possible to get the ETIMEDOUT error back, though this is unlikely. The backlog figure supplied with the <FUNCTION>listen()</FUNCTION> call is limited to a very large value, (currently 1000). Applications should limit the backlog parameter to a value consistent with a server's usage.</PARAGRAPH>
<PARAGRAPH>With a socket marked as listening, a server can accept a connection by using the <INDEXTARGET ID="2.sockets3"><!-- POSTPROCESSDATA: 2.sockets3|accept --><FUNCTION>accept()</FUNCTION> system call (see <REFPAGE>accept(2)</REFPAGE>):</PARAGRAPH>
<CODE>
struct sockaddr_in from;
int fromlen = sizeof (from);
newsock = accept(s, (struct sockaddr *)&amp;from, &amp;fromlen);
</CODE>
<NOTE><PREFIX>Note</PREFIX>For the UNIX domain, <VARIABLE>from</VARIABLE> would be declared as a <VARIABLE>struct&nbsp;sockaddr_un</VARIABLE>, but the rest of this example would remain the same. The examples that follow describe only Internet-domain routines. </NOTE>
<PARAGRAPH>A new descriptor is returned on receipt of a connection (along with a new socket). To identify the client, a server can supply a buffer for the client socket's name. The server initializes the value-result parameter <VARIABLE>fromlen</VARIABLE> to indicate how much space is associated with <VARIABLE>from</VARIABLE>. The parameter is then modified on return to reflect the true size of the name. If the client's name is not of interest, the second parameter can be a null pointer.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>accept()</FUNCTION> call normally blocks. That is, <FUNCTION>accept()</FUNCTION> will not return until a connection is available or the system call is interrupted by a signal to the program. Furthermore, a program cannot indicate it will accept connections from only a specific individual or individuals. It is up to the program to consider whom the connection is from and close down the connection if it does not wish to speak to the remote program. If the server program wants to accept connections on more than one socket, or wants to avoid blocking on the accept call, there are alternatives; see <XREF IDREF="93855" TYPE="TITLE">&ldquo;The Client/Server Model&rdquo;</XREF> for details.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="21853">Transferring Data</TITLE><PARAGRAPH>IRIX has several system calls for reading and writing information. The simplest calls are <INDEXTARGET ID="2.sockets4"><!-- POSTPROCESSDATA: 2.sockets4|sockets:I/Odata, transfertransfer, dataread(2)recv(2)write(2)send(2) --><FUNCTION>read()</FUNCTION> and <FUNCTION>write()</FUNCTION> (see <REFPAGE>read(2)</REFPAGE> and <REFPAGE>write(2)</REFPAGE>). They take as arguments a descriptor, a pointer to a buffer containing the data, and the size of the data:</PARAGRAPH>
<CODE>
char buf [100];
&space;...
write(s, buf, sizeof (buf));
read(s, buf, sizeof (buf));
</CODE>
<PARAGRAPH>The descriptor may indicate a file or a connected socket. &ldquo;Connected&rdquo; can mean either a connected stream socket or a datagram socket for which a <FUNCTION>connect()</FUNCTION> call has provided a default destination. The <FUNCTION>write()</FUNCTION> call requires a connected socket, since no destination is specified in the parameters of the system call. The <FUNCTION>read()</FUNCTION> call can be used for either a connected or an unconnected socket. These calls are, therefore, quite flexible and may be used to write applications that do not require assumptions about the source of their input or the destination of their output.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>readv()</FUNCTION> and <FUNCTION>writev()</FUNCTION> calls (see <REFPAGE>read(3)</REFPAGE> and <REFPAGE>write(3)</REFPAGE>) (for read and write <ITALICS>vector</ITALICS>) are variations of the <FUNCTION>read()</FUNCTION> and <FUNCTION>write()</FUNCTION> calls, which allow the source and destination of the input and output to use several separate buffers, while retaining the flexibility to handle both files and sockets.</PARAGRAPH>
<PARAGRAPH>Sometimes it's necessary to send high-priority data over a connection that may have unread low-priority data at the other end. For example, a user interface process may be interpreting commands and sending them on to another process through a stream connection. The user interface may have filled the stream with as-yet-unprocessed requests when the user types a command to cancel all outstanding requests. Rather than have the high-priority data wait to be processed after the low-priority data, it is possible to send it as <ITALICS>out-of-band</ITALICS> (OOB) data. OOB data is specific to stream sockets and is discussed in <XREF IDREF="44096" TYPE="TITLE">&ldquo;Out-of-Band Data&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>send()</FUNCTION> and <FUNCTION>recv()</FUNCTION> calls (see <REFPAGE>send(2)</REFPAGE> and <REFPAGE>recv(2)</REFPAGE>) are similar to <FUNCTION>read()</FUNCTION> and <FUNCTION>write()</FUNCTION>, but they allow options, including sending and receiving OOB information:</PARAGRAPH>
<CODE>
send(s, buf, sizeof (buf), flags);
recv(s, buf, sizeof (buf), flags);
</CODE>
<PARAGRAPH>These calls are used only with connected sockets; specifying a descriptor for a file will result in an error.</PARAGRAPH>
<PARAGRAPH>While <FUNCTION>send()</FUNCTION> and <FUNCTION>recv()</FUNCTION> are virtually identical to <FUNCTION>write()</FUNCTION> and <FUNCTION>read()</FUNCTION>, the addition of the <VARIABLE>flags</VARIABLE> argument is important. The flags are defined in &lt;<FILENAME>sys/socket.h</FILENAME>> and can have nonzero values if one or more of the following are required:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>MSG_PEEK</HANGITEM>
<HANGBODY><PARAGRAPH>look at data without reading</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>MSG_OOB</HANGITEM>
<HANGBODY><PARAGRAPH>send/receive out-of-band data</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>MSG_DONTROUTE</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;send data without routing packets</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>To preview data, specify MSG_PEEK with a <FUNCTION>recv()</FUNCTION> call. The <FUNCTION>recv()</FUNCTION> call allows a process to read data without removing the data from the stream. That is, the next <FUNCTION>read()</FUNCTION> or <FUNCTION>recv()</FUNCTION> call applied to the socket will return the data previously previewed.</PARAGRAPH>
<PARAGRAPH>One use of this facility is to read ahead in a stream to determine the size of the next item to be read. The option to have data sent in outgoing packets without routing is used only by the routing table management process.</PARAGRAPH>
<PARAGRAPH>To send datagrams, one must be allowed to specify the destination. The call <FUNCTION>sendto()</FUNCTION> (see <REFPAGE>sendto(2)</REFPAGE>) takes a destination address as an argument and is therefore used for sending datagrams. The call <FUNCTION>recvfrom()</FUNCTION> (see <REFPAGE>recvfrom(2)</REFPAGE>) is often used to read datagrams, since this call returns the address of the sender, if it is available, along with the data. If the identity of the sender does not matter, one may use <FUNCTION>read()</FUNCTION> or <FUNCTION>recv()</FUNCTION>.</PARAGRAPH>
<PARAGRAPH>Finally, there is a pair of calls that allow you to send and receive messages from multiple buffers (the sender must specify the address of the recipient). These are <FUNCTION>sendmsg()</FUNCTION> and <FUNCTION>recvmsg()</FUNCTION> (see <REFPAGE>sendmsg(2)</REFPAGE> and <REFPAGE>recvmsg(2)</REFPAGE>). These calls are actually quite general and have other uses, including, in the UNIX domain, the transmission of a file descriptor from one process to another.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Discarding Sockets</TITLE><PARAGRAPH>A socket is discarded by closing the descriptor; use the <FUNCTION>close()</FUNCTION> system call (see <REFPAGE>close(2)</REFPAGE>):</PARAGRAPH>
<EXAMPLE>
close(s);
</EXAMPLE>
<PARAGRAPH>If data is associated with a socket that promises reliable delivery (for example, a stream socket) when a close takes place, the system will continue trying to transfer the data. However, after a period of time, undelivered data is discarded. Should you have no use for any pending data, perform a <FUNCTION>shutdown()</FUNCTION> on the socket prior to closing it:</PARAGRAPH>
<EXAMPLE>
shutdown(s, how);
</EXAMPLE>
<PARAGRAPH>The value <VARIABLE>how</VARIABLE> is 0 if you do not want to read data, 1 if no more data will be sent, or 2 if no data is to be sent or received.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="40932">Scheduled Transfers Sockets</TITLE><PARAGRAPH>Nearly all SGI socket system calls such as <INDEXTARGET ID="2.sockets5"><!-- POSTPROCESSDATA: 2.sockets5|socket:Scheduled Transfers --><FUNCTION>accept</FUNCTION>(), <FUNCTION>bind</FUNCTION>(), <FUNCTION>connect</FUNCTION>(), and so on, support ST sockets. ST sockets must be connected before they can send or receive data. Therefore, the <FUNCTION>sendto</FUNCTION>() and <FUNCTION>recfrom</FUNCTION>() calls are <BOLD>not</BOLD> supported for ST sockets.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="77749">Connectionless Sockets</TITLE><PARAGRAPH>The sockets described so far follow a connection-oriented model. However, connectionless interactions, typical of the datagram facilities found in contemporary packet-switched networks, are also supported. A datagram socket provides a symmetric interface to data exchange. While processes are still likely to be client and server, there is no requirement for connection establishment. Instead, each message includes the destination address.<INDEXTARGET ID="2.sockets6"><!-- POSTPROCESSDATA: 2.sockets6|recvfrom(2)sendto(2)connectionless:socketsockets:connectionless --></PARAGRAPH>
<PARAGRAPH>Datagram sockets are created as described in <XREF IDREF="20443" TYPE="TITLE">&ldquo;Creating Sockets&rdquo;</XREF>. If a particular local address is needed, the <FUNCTION>bind()</FUNCTION> operation must precede the first data transmission. Otherwise, the system will set the local address and/or port when data is first sent.</PARAGRAPH>
<PARAGRAPH>To send data, use the <FUNCTION>sendto()</FUNCTION> system call:</PARAGRAPH>
<CODE>
sendto(s, buf, buflen, flags, (struct sockaddr *)&amp;to,
&space;      sizeof(to));
</CODE>
<PARAGRAPH>The <VARIABLE>s</VARIABLE>, <VARIABLE>buf</VARIABLE>, <VARIABLE>buflen</VARIABLE>, and <VARIABLE>flags</VARIABLE> parameters are used as described for the <FUNCTION>send()</FUNCTION> call (see <XREF IDREF="21853" TYPE="TITLE">&ldquo;Transferring Data&rdquo;</XREF>). The <VARIABLE>to</VARIABLE> value indicates the destination address. On an unreliable datagram interface, errors probably will not be reported to the sender. When information is present locally to recognize a message that cannot be delivered (for instance when a network is unreachable), the call will return &ndash;1 and the global variable <VARIABLE>errno</VARIABLE> will contain an error number.</PARAGRAPH>
<PARAGRAPH>To receive messages on an unconnected datagram socket, use the <FUNCTION>recvfrom()</FUNCTION> call:</PARAGRAPH>
<CODE>
recvfrom(s, buf, buflen, flags, (struct sockaddr *)&amp;from,
&space;        &amp;fromlen);
</CODE>
<PARAGRAPH>Once again, the value-result parameter, <VARIABLE>fromlen</VARIABLE>, initially contains the size of the <VARIABLE>from</VARIABLE> buffer and is modified on return to indicate the actual size of the address from which the datagram was received. If you don't care who the sender is, use 0 for the <VARIABLE>&amp;from</VARIABLE> and <VARIABLE>&amp;fromlen</VARIABLE> parameters.</PARAGRAPH>
<PARAGRAPH>In addition to <FUNCTION>sendto()</FUNCTION> and <FUNCTION>recvfrom()</FUNCTION>, datagram sockets can use the <FUNCTION>connect()</FUNCTION> call to associate a socket with a specific destination address. In this case, any data sent on the socket will automatically be addressed to the connected peer, and only data received from that peer will be delivered to the user.</PARAGRAPH>
<PARAGRAPH>Only one connected address is permitted for each socket at a time; a second <FUNCTION>connect()</FUNCTION> will change the destination address, and a <FUNCTION>connect()</FUNCTION> to a &ldquo;null&rdquo; address (family AF_UNSPEC) will cause a disconnection.</PARAGRAPH>
<PARAGRAPH>Connection requests on datagram sockets return immediately, because the request simply results in the system recording the peer's address. Connection requests on a stream socket, however, do not return immediately; the request initiates the establishment of an end&ndash;to&ndash;end connection. (The <FUNCTION>accept()</FUNCTION> and <FUNCTION>listen()</FUNCTION> calls are not used with datagram sockets.)</PARAGRAPH>
<PARAGRAPH>While a datagram socket is connected, errors from recent <FUNCTION>send()</FUNCTION> calls can be returned asynchronously. These errors can be reported on subsequent operations on the socket or by using a special socket option, SO_ERROR, with <FUNCTION>getsockopt()</FUNCTION> that can be used to interrogate the error status. A <FUNCTION>select()</FUNCTION> for reading or writing will return true when an error indication has been received. The next operation will return the error, and the error status is cleared. For additional details about datagram sockets, see <XREF IDREF="27505" TYPE="TITLE">&ldquo;Advanced Topics&rdquo;</XREF>.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>I/O Multiplexing</TITLE><PARAGRAPH>You can multiplex I/O requests among multiple sockets and/or files by using the &lbreak;<INDEXTARGET ID="2.sockets7"><!-- POSTPROCESSDATA: 2.sockets7|multiplexing:inputmultiplexing:outputI/O multiplexingselect(2)FD_SETSIZEFD_SETFD_ISSETFD_CLRFD_ZERO --><FUNCTION>select()</FUNCTION> call:</PARAGRAPH>
<CODE>
#include &lt;sys/time.h>
#include &lt;sys/types.h>
&space;...
fd_set readmask, writemask, exceptmask;
struct timeval timeout;
&space;...
select(nfds, &amp;readmask, &amp;writemask, &amp;exceptmask, &amp;timeout);
</CODE>
<PARAGRAPH>The <FUNCTION>select()</FUNCTION> call takes three sets of pointers as arguments:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>one for the set of file descriptors on which the caller wants to read data</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>one for the set of file descriptors on which data is to be written</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>one for which exceptional conditions are pending (out-of-band data is the only exceptional condition currently implemented)</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>If you are not interested in certain conditions (that is, read, write, or exceptions), the corresponding argument to the <FUNCTION>select()</FUNCTION> call should be a null pointer.</PARAGRAPH>
<PARAGRAPH>Each set is a structure containing an array of long integer bit masks. The size of the array is set by the definition FD_SETSIZE. The array must be long enough to hold one bit for each FD_SETSIZE file descriptor.</PARAGRAPH>
<PARAGRAPH>The set should be zeroed before use. To clear the set mask, use this macro:</PARAGRAPH>
<EXAMPLE>
FD_ZERO(&amp;mask)
</EXAMPLE>
<PARAGRAPH>To add and remove the file descriptor <VARIABLE>fd</VARIABLE> in the set mask, use these macros:</PARAGRAPH>
<CODE>
FD_SET(fd, &amp;mask)
FD_CLR(fd, &amp;mask)
</CODE>
<PARAGRAPH>The parameter <VARIABLE>nfds</VARIABLE> in the <FUNCTION>select()</FUNCTION> call specifies the range of file descriptors (one plus the value of the largest descriptor) to be examined in a set.</PARAGRAPH>
<PARAGRAPH>You can specify a timeout value if the selection will not last more than a predetermined period of time. If the fields in <VARIABLE>timeout</VARIABLE> are set to 0, the selection takes the form of a poll, returning immediately. If <VARIABLE>timeout</VARIABLE> is a null pointer, the selection will block indefinitely. To be more specific, a return takes place only when a descriptor is selectable or when a signal is received by the caller, interrupting the system call.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>select()</FUNCTION> call normally returns the number of file descriptors selected. If the <FUNCTION>select()</FUNCTION> call returns because the timeout expires, the value 0 is returned. If the <FUNCTION>select()</FUNCTION> call terminates because of an error or interruption, &ndash;1 is returned with the error number in <VARIABLE>errno</VARIABLE>, and with the file descriptor masks unchanged.</PARAGRAPH>
<PARAGRAPH>For a successful return, the three sets will indicate which file descriptors are ready to be read from, written to, or have exceptional conditions pending. The status of a file descriptor in a select mask can be tested with this macro:</PARAGRAPH>
<EXAMPLE>
FD_ISSET(fd, &amp;mask)
</EXAMPLE>
<PARAGRAPH>This macro returns a nonzero value if <VARIABLE>fd</VARIABLE> is a member of the set <VARIABLE>mask</VARIABLE>, and 0 if it is not.</PARAGRAPH>
<PARAGRAPH>To check for read readiness on a socket to be used with an <FUNCTION>accept()</FUNCTION> call, use <FUNCTION>select()</FUNCTION> followed by the FD_ISSET(<VARIABLE>fd</VARIABLE>, <VARIABLE>&amp;mask</VARIABLE>) macro. If FD_ISSET returns a nonzero value, indicating permission to read, then a connection is pending on the socket.</PARAGRAPH>
<PARAGRAPH>For example, to read data from two sockets, <VARIABLE>s1</VARIABLE> and <VARIABLE>s2</VARIABLE>, as the data becomes available and with a one-second timeout, this code might be used:</PARAGRAPH>
<CODE>
#include &lt;sys/time.h>
#include &lt;sys/types.h>
&space;...
fd_set read_template; struct timeval wait;
&space;...
for (;;) {
&space;   wait.tv_sec = 1;        /* one second */
&space;   wait.tv_usec = 0;
&space;   FD_ZERO(&amp;read_template);
&space;   FD_SET(s1, &amp;read_template);
&space;   FD_SET(s2, &amp;read_template);
&space;   nb = select(FD_SETSIZE, &amp;read_template, (fd_set *) 0,
&space;               (fd_set *) 0, &amp;wait);
&space;   if (nb &lt;= 0) {
&space;       /*
&space;        *  An error occurred during the select, or
&space;        *  the select timed out.
&space;        */
&space;   }
&space;   if (FD_ISSET(s1, &amp;read_template)) {
&space;       /* Socket #1 is ready to be read from. */
&space;   }
&space;   if (FD_ISSET(s2, &amp;read_template)) {
&space;       /* Socket #2 is ready to be read from. */
&space;   }
}
</CODE>
<NOTE><PREFIX>Note</PREFIX>In 4.2BSD, the arguments to<FUNCTION>&space;select()</FUNCTION> were pointers to integers instead of pointers to <VARIABLE>fd_set</VARIABLE>s. This type of call will still work, as long as the largest file descriptor is numerically less than the number of bits in an integer (that is, 32). However, the methods illustrated above should be used in all current programs.</NOTE>
<PARAGRAPH>The <FUNCTION>select()</FUNCTION> call provides a synchronous multiplexing scheme. Asynchronous notification of output completion, input availability, and exceptional conditions are possible through the use of the SIGIO and SIGURG signals.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="93055">Network Library Routines</TITLE><PARAGRAPH>When you use the IPC facilities in a distributed environment, programs need to locate and construct network addresses. This section discusses the library routines you can use to manipulate Internet network addresses.<INDEXTARGET ID="2.sockets8"><!-- POSTPROCESSDATA: 2.sockets8|network:library routinesroutines, library --></PARAGRAPH>
<PARAGRAPH>Locating a service on a remote host requires many levels of mapping before client and server can communicate. A service is assigned a name, such as <VARIABLE>login server</VARIABLE>, that humans can easily understand. This name, and the name of the peer host, must then be translated into network addresses. Finally, the address is used to locate a physical location and route to the service.</PARAGRAPH>
<PARAGRAPH>The specifics of these mappings can vary among network architectures. For instance, it is desirable that a network not require a host to have a name indicating its physical location to a client host. Instead, underlying services in the network can discover the actual location of the host at the time the client host wants to communicate.</PARAGRAPH>
<PARAGRAPH>This ability to have hosts named in a location&ndash;independent manner can induce overhead in connection establishment, as a discovery process must take place, but it allows a host to be physically mobile. The host does not have to notify its clients of its current location.</PARAGRAPH>
<PARAGRAPH>Standard routines are provided for these mappings:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>host names to network addresses</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>network names to network numbers</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>protocol names to protocol numbers</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>service names to port numbers</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Routines also indicate the appropriate protocol to use to communicate with the server process. The file &lt;<FILENAME>netdb.h</FILENAME>> must be included when using any of these routines.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Host Names</TITLE><PARAGRAPH>The <INDEXTARGET ID="2.sockets9"><!-- POSTPROCESSDATA: 2.sockets9|host, namenames, hostgethostbyaddr(3)gethostbyname(3) --><VARIABLE>hostent</VARIABLE> data structure provides Internet host Name-to-Address Mapping:</PARAGRAPH>
<CODE>
struct    hostent {
&space;   char  *h_name;       /* official name of host */
&space;   char  **h_aliases;   /* alias list */
&space;   int   h_addrtype;    /* host address type (eg AF_INET) */
&space;   int   h_length;      /* length of address */
&space;   char  **h_addr_list; /* list of addresses, */
&space;                        /* null-terminated */
};
/* first address, in network byte order, for backward
&space;* compatibility: */
#define h_addr    h_addr_list[0]
</CODE>
<PARAGRAPH>The routine <FUNCTION>gethostbyname()</FUNCTION> takes an Internet host name and returns a <VARIABLE>hostent</VARIABLE> structure, while the routine <FUNCTION>gethostbyaddr()</FUNCTION> maps Internet host addresses into a <VARIABLE>hostent</VARIABLE> structure (see <REFPAGE>gethostbyname(3N)</REFPAGE> and <REFPAGE>gethostbyaddr(3N)</REFPAGE>).</PARAGRAPH>
<PARAGRAPH>These routines return the official name of the host and its public aliases, along with the address type (family) and a null-terminated list of variable-length addresses. The list of addresses is required because a host may have many addresses and the same name. The <VARIABLE>h_addr</VARIABLE> definition is provided for backward compatibility and is defined as the first address in the list of addresses in the <VARIABLE>hostent</VARIABLE> structure.</PARAGRAPH>
<PARAGRAPH>The database for these calls is provided either by the <FILENAME>/etc/hosts</FILENAME> file&mdash;see <REFPAGE>hosts(4)</REFPAGE>&mdash;or by using the Internet domain name server, <COMMAND>named</COMMAND> (see <REFPAGE>named(1M)</REFPAGE>). The database can also come from the NIS, if you have the NFS option. Because of the differences in these databases and their access protocols, the information returned can differ. When using the host table or NIS versions of <FUNCTION>gethostbyname()</FUNCTION>, the call returns only one address but includes all listed aliases. When using the name server version, the calls can return alternate addresses, but they will not provide any aliases other than the one given as the argument.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Network Names</TITLE><PARAGRAPH>The <INDEXTARGET ID="2.sockets10"><!-- POSTPROCESSDATA: 2.sockets10|network:namesnames, networkgetnetbyname(3)getnetbynumber(3) --><VARIABLE>netent</VARIABLE> data structure defines the Network-Name-to-Network-Number Mapping used with the <FUNCTION>getnetbyname()</FUNCTION>, <FUNCTION>getnetbynumber()</FUNCTION>, and <FUNCTION>getnetent()</FUNCTION> routines (see <REFPAGE>getnetbyname(3N)</REFPAGE>, <REFPAGE>getnetbynumber(3N)</REFPAGE>, and <REFPAGE>getnetent(3N)</REFPAGE>):</PARAGRAPH>
<CODE>
/*
&space;* Assumption here is that a network number
&space;* fits in 32 bits.
&space;*/
struct netent {
&space;   char  *n_name;     /* official name of net */
&space;   char  **n_aliases; /* alias list */
&space;   int   n_addrtype;  /* net address type */
&space;   int   n_net;       /* network number, host byte order */
};
</CODE>
<PARAGRAPH>These routines are the network counterparts to the host routines described in the preceding section. The routines extract their information from <FILENAME>/etc/networks</FILENAME> or from the NIS if the NFS option is installed.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Protocol Names</TITLE><PARAGRAPH>The <INDEXTARGET ID="2.sockets11"><!-- POSTPROCESSDATA: 2.sockets11|protocol namesnames, protocolgetprotobyname(3)getprotobynumber(3) --><VARIABLE>protoent</VARIABLE> data structure defines the protocol Name-to-Number Mapping used with the routines<FUNCTION>&space;getprotobyname()</FUNCTION>, <FUNCTION>getprotobynumber()</FUNCTION>, and <FUNCTION>getprotoent()</FUNCTION> (see <REFPAGE>getprotobyname(3N)</REFPAGE>, <REFPAGE>getprotobynumber(3N)</REFPAGE>, and <REFPAGE>getprotoent(3N)</REFPAGE>):</PARAGRAPH>
<CODE>
struct   protoent {
&space;   char  *p_name;      /* official protocol name */
&space;   char  **p_aliases;  /* alias list */
&space;   int   p_proto;      /* protocol number */
};
</CODE>
<PARAGRAPH>The routines extract their information from <FILENAME>/etc/protocols</FILENAME> or from the NIS if the NFS option is installed.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Service Names</TITLE><PARAGRAPH>A service is expected to reside at a specific port and employ a particular communication protocol. This view is consistent with the Internet domain but is inconsistent with other network architectures. Furthermore, a service can reside on multiple ports. If it does, the higher-level library routines will have to be bypassed or extended. Services available are obtained from the file <INDEXTARGET ID="2.sockets12"><!-- POSTPROCESSDATA: 2.sockets12|names, serviceservice namesgetservbyname(3)getservbynumber(3) --><FILENAME>/etc/services</FILENAME> or from the NIS if the NFS option is installed.</PARAGRAPH>
<PARAGRAPH>The <VARIABLE>servent</VARIABLE> structure defines the service Name-to-Port-Number Mapping:</PARAGRAPH>
<CODE>
struct   servent {
&space;   char  *s_name;     /* official service name */
&space;   char  **s_aliases; /* alias list */
&space;   int   s_port;      /* port #, network byte order */
&space;   char  *s_proto;    /* protocol to use */
};
</CODE>
<PARAGRAPH>The routine <FUNCTION>getservbyname()</FUNCTION> (see <REFPAGE>getservbyname(3N)</REFPAGE>) maps service names to a <VARIABLE>servent</VARIABLE> structure by specifying a service name and, optionally, a qualifying protocol.</PARAGRAPH>
<PARAGRAPH>The following returns the service specification for a TELNET server using any protocol:</PARAGRAPH>
<EXAMPLE>
sp = getservbyname("telnet", (char *) 0);
</EXAMPLE>
<PARAGRAPH>This returns only the TELNET server that uses the TCP protocol:</PARAGRAPH>
<EXAMPLE>
sp = getservbyname("telnet", "tcp");
</EXAMPLE>
<PARAGRAPH>The routines <FUNCTION>getservbyport()</FUNCTION> and <FUNCTION>getservent()</FUNCTION> also provide service mappings (see <REFPAGE>getservbyport(3N)</REFPAGE> and <REFPAGE>getservent(3N)</REFPAGE>). The <FUNCTION>getservbyport()</FUNCTION> routine has an interface similar to that provided by getservbyname&mdash;you specify an optional protocol name to qualify lookups.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="17020">Network Dependencies</TITLE><PARAGRAPH>With the support routines already described, an Internet application program rarely has to deal directly with addresses. This allows services to operate as much as possible in a network-independent fashion. However, purging all network dependencies is difficult. As long as the user must supply network addresses when naming services and sockets, some network dependency is required in a program. For example, the normal code included in client programs, such as the remote login program, takes the form shown in <XREF IDREF="94771" TYPE="TEXT">Example&nbsp;2-1</XREF>:</PARAGRAPH>

<!-- WARNING: (47) Example captions should come at end of Example - detected on page 27 -->
<!-- WARNINGLOCATION: PAGE = "27" SRC = "2.sockets.mif" TAGTYPE = "PARA" TAG = "ExampleTitle" TAGCOUNT = "1" UID = "660" TEXT = ":"-->
<EXAMPLE><CAPTION LBL="2-1"><PREFIX>Example 2-1 </PREFIX><XREFTARGET ID="94771">A Remote-Login Client</CAPTION></EXAMPLE>
<CODE>
#include &lt;sys/types.h>
#include &lt;sys/socket.h>
#include &lt;netinet/in.h>
#include &lt;stdio.h>
#include &lt;netdb.h>

main(argc, argv)
&space;   int argc;
&space;   char *argv[];
{
&space;   struct sockaddr_in server;
&space;   struct servent *sp;
&space;   struct hostent *hp;
&space;   int s;
&space;   ...
&space;   sp = getservbyname("login", "tcp");
&space;   if (sp == NULL) {
&space;       fprintf(stderr,
&space;               "rlogin: tcp/login: unknown service\n");
&space;       exit(1);
&space;   }
&space;   hp = gethostbyname(argv[1]);
&space;   if (hp == NULL) {
&space;       fprintf(stderr,
&space;               "rlogin: %s: unknown host\n", argv[1]);
&space;       exit(2);
&space;   }
&space;   bzero((char *)&amp;server, sizeof (server));
&space;   bcopy(hp->h_addr, (char *)&amp;server.sin_addr,
&space;         hp->h_length);
&space;   server.sin_family = hp->h_addrtype;
&space;   server.sin_port = sp->s_port;
&space;   s = socket(hp->h_addrtype, SOCK_STREAM, 0);
&space;   if (s &lt; 0) {
&space;       perror("rlogin: socket");
&space;       exit(3);
&space;   }
&space;   ...
&space;   /* Connect does the bind() for us */
&space;   if (connect(s, (struct sockaddr *)&amp;server,
&space;       sizeof (server)) &lt; 0) {
&space;       perror("rlogin: connect");
&space;       exit(4);
&space;   }
}
</CODE>
<NOTE><PREFIX>Note</PREFIX>To make the remote login program independent of the Internet protocols and addressing scheme, the program would have to have a layer of routines that masked the network-dependent aspects from the mainstream login code. For the current facilities available in the system, this does not appear worthwhile.</NOTE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Byte Ordering</TITLE><PARAGRAPH>In addition to the address-related database routines, several other routines are available to simplify manipulation of names and addresses. <INDEXTARGET ID="2.sockets13"><!-- POSTPROCESSDATA: 2.sockets13|address, manipulationhtonl(3)htons(3)ntohl(3)ntohs(3)byte orderinglittle endianbig endian --><XREF IDREF="21604" TYPE="TABLE">Table&nbsp;2-2</XREF> summarizes the routines that manipulate variable-length byte strings and handle byte swapping of network addresses and values. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="2-2"><PREFIX>Table 2-2 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="21604">C Run-time Routines</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="99"><PARAGRAPH>Call</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="279"><PARAGRAPH>Synopsis </PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>bcmp(s1, s2, n) </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="279"><PARAGRAPH>Compare byte strings; 0 if same, not 0 otherwise. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>bcopy(s1, s2, n) </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="279"><PARAGRAPH>Copy <VARIABLE>n</VARIABLE> bytes from <VARIABLE>s1</VARIABLE> to <VARIABLE>s2.</VARIABLE></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>bzero(base, n) </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="279"><PARAGRAPH>Zero-fill <VARIABLE>n </VARIABLE>bytes starting at base.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>htonl(val) </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="279"><PARAGRAPH>(<ITALICS>host-to-network-long</ITALICS>) Convert 32-bit quantity from host to network 
byte order.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>htons(val) </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="279"><PARAGRAPH>(<ITALICS>host-to-network-short</ITALICS>) Convert 16-bit quantity from host to network 
byte order.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>ntohl(val) </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="279"><PARAGRAPH>(<ITALICS>network-to-host-long</ITALICS>) Convert 32-bit quantity from network to host 
byte order.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>ntohs(val) </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="279"><PARAGRAPH>(<ITALICS>network-to-host-short</ITALICS>) Convert 16-bit quantity from network to host 
byte order.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The format of the socket address is specified, in part, by standards within the Internet domain. The specification includes the order of the bytes in the address (called the network byte order). Addresses supplied to system calls must be in network byte order; values returned by the system also have this ordering. Because machines differ in the internal representation of integers, examining an address as returned by <FUNCTION>getsockname()</FUNCTION> or <FUNCTION>getservbyname()</FUNCTION> (see <REFPAGE>getsockname(2)</REFPAGE> or <REFPAGE>getservbyname(3N)</REFPAGE>) may result in a misinterpretation. To use the number, it is necessary to call the routine <FUNCTION>ntohs()</FUNCTION>&space;to convert the number from the network representation to the host's representation. For example:</PARAGRAPH>
<EXAMPLE>
printf("port number %d\n", ntohs(sp->s_port));
</EXAMPLE>
<PARAGRAPH>On machines that have &ldquo;big-endian&rdquo; byte ordering, such as the IRIS, the <COMMAND>ntohs</COMMAND> is a null operation. On machines with &ldquo;little-endian&rdquo; ordering, such as the VAX&trade;, this results in a swapping of bytes. Another routine exists to convert a short integer from the host format to the network format, called <FUNCTION>htons()</FUNCTION>; the <FUNCTION>ntohl()</FUNCTION> and <FUNCTION>htonl()</FUNCTION> routines exist for long integers. Any protocol that transfers integer data between machines with different byte orders should use these routines. The library routines that return network addresses and ports provide them in network order so that they can simply be copied into the structures provided to the system.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="93855">The Client/Server Model</TITLE><PARAGRAPH>The most commonly used paradigm in constructing distributed applications is the client/server model. In this scheme, client applications request services from a server process. This implies an asymmetry in establishing communication between the client and server. (See <INDEXTARGET ID="2.sockets14"><!-- POSTPROCESSDATA: 2.sockets14|client/server modelserver/client model --><XREF IDREF="30328" TYPE="TITLE">&ldquo;Establishing Socket Connections&rdquo;</XREF> for details.) This section examines the interactions between client and server, and considers some of the problems in developing client and server applications.</PARAGRAPH>
<PARAGRAPH>The client and server require a well-known set of conventions before service can be rendered (and accepted). This set of conventions constitutes a protocol that must be implemented at both ends of a connection. The protocol can be symmetric or asymmetric. In a symmetric protocol, either side can play the master or slave role. In an asymmetric protocol, one side is always the master, and the other is the slave. An example of a symmetric protocol is TELNET, which is used in Internet for remote terminal emulation. An example of an asymmetric protocol is the Internet File Transfer Protocol (FTP). Regardless of whether the protocol is symmetric or asymmetric, when it accesses a service there is a &ldquo;server process&rdquo; and a &ldquo;client process.&rdquo;</PARAGRAPH>
<PARAGRAPH>A server process normally listens at a well-known address for service requests. That is, the server process remains dormant until a connection is requested by a client's connection to the server's address. At such a time the server process &ldquo;wakes up&rdquo; and services the client, performing actions the client requests.</PARAGRAPH>
<PARAGRAPH>Alternative schemes that use a server to provide a service can eliminate a flock of server processes clogging the system while remaining dormant most of the time. For Internet servers in BSD-based systems, this scheme has been implemented via <COMMAND>inetd</COMMAND>,&space;the so-called &ldquo;Internet super-server.&rdquo; The <COMMAND>inetd</COMMAND> daemon listens at a variety of ports, determined at startup by reading a configuration file. When a connection is requested to a port on which <COMMAND>inetd</COMMAND> is listening, <COMMAND>inetd</COMMAND> executes the appropriate server program to handle the client. With this method, clients are unaware that an intermediary such as <COMMAND>inetd</COMMAND> has played any part in the connection. The <COMMAND>inetd</COMMAND> daemon is described in more detail in <XREF IDREF="27505" TYPE="TITLE">&ldquo;Advanced Topics&rdquo;</XREF>.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="26711">Connection-based Servers</TITLE><PARAGRAPH>Most servers are accessed at well-known Internet addresses. The remote login server's main loop takes the form shown in this sample code:</PARAGRAPH>
<CODE>
main(int argc, char **argv)
{
&space;   int f;
&space;   struct sockaddr_in from;
&space;   struct servent *sp;
&space;   
&space;   sp = getservbyname("login", "tcp");
&space;   if (sp == NULL) {
&space;       fprintf(stderr,
&space;           "rlogind: tcp/login: unknown service\n");
&space;       exit(1);
&space;   }
&space;   ...
#ifndef DEBUG
&space;   /* Disassociate server from controlling terminal */
&space;   ...
#endif
&space;   /* Restricted port -- see "Address Binding" */
&space;   from.sin_port = sp->s_port;
&space;   ...
&space;   f = socket(AF_INET, SOCK_STREAM, 0);
&space;   ...
&space;   if (bind(f, (struct sockaddr *) &amp;from,
&space;            sizeof (from)) &lt; 0) {
&space;       syslog(LOG_ERR, "rlogind: bind: %m");
&space;       exit(1);
&space;   }
&space;   ...
&space;   listen(f, 5);
&space;   for (;;) {
&space;       int g, len = sizeof (from);
&space;       g = accept(f, (struct sockaddr *)&amp;from, &amp;len);
&space;       if (g &lt; 0) {
&space;           if (errno != EINTR) {
&space;               syslog(LOG_ERR, "rlogind: accept: %m");
&space;           }
&space;           continue;
&space;       }
&space;       if (fork() == 0) {            /* child */
&space;           close(f);
&space;           doit(g, &amp;from);
&space;       }
&space;       close(g);                /* parent */
&space;   }
}
</CODE>
<PARAGRAPH>The first step taken by the server is to look up its service definition:</PARAGRAPH>
<CODE>
sp = getservbyname("login", "tcp");
if (sp == NULL) {
&space;   fprintf(stderr, "rlogind: tcp/login: unknown service\n");
&space;   exit(1);
}
</CODE>
<PARAGRAPH>The result of the <FUNCTION>getservbyname()</FUNCTION> call is used in later portions of the code to define the well-known Internet port where the server listens for service requests (indicated by a connection).<INDEXTARGET ID="2.sockets15"><!-- POSTPROCESSDATA: 2.sockets15|ioctls:TIOCNOTTY --></PARAGRAPH>
<PARAGRAPH>The second step taken by the server is to disassociate from the controlling terminal of its invoker:</PARAGRAPH>
<EXAMPLE>
_daemonize(0, -1, -1, -1);
</EXAMPLE>
<PARAGRAPH>The <FUNCTION>_daemonize()</FUNCTION> function does the common work needed to put a program into the background or to make a program into a daemon. This generally includes <FUNCTION>fork()</FUNCTION>ing a new process, closing most files, and releasing the controlling terminal. See the <REFPAGE>daemonize(3)</REFPAGE> manual page for details.</PARAGRAPH>
<PARAGRAPH>The server is protected from receiving signals delivered to the process group of the controlling terminal. Note, however, that once a server has disassociated itself, it can no longer send reports of errors to a terminal and must log errors via <FUNCTION>syslog()</FUNCTION>.</PARAGRAPH>
<PARAGRAPH>Once a server has established a pristine environment, it creates a socket and begins accepting service requests. The <FUNCTION>bind()</FUNCTION> call is required to ensure that the server listens at its expected location. Note that the remote login server listens at a restricted port number and must therefore be run with a user ID of <ITALICS>root</ITALICS>. This concept of a &ldquo;restricted port number&rdquo; is specific to BSD-based systems; see <XREF IDREF="81270" TYPE="TITLE">&ldquo;Address Binding&rdquo;</XREF> for more information.</PARAGRAPH>
<PARAGRAPH>The main body of the loop is shown in this example:</PARAGRAPH>
<CODE>
for (;;) {
&space;   int g, len = sizeof (from);
&space;   g = accept(f, (struct sockaddr *)&amp;from, &amp;len);
&space;   if (g &lt; 0) {
&space;       if (errno != EINTR) {
&space;           syslog(LOG_ERR, "rlogind: accept: %m");
&space;       }
&space;       continue;
&space;   }
&space;   if (fork() == 0) {    /* Child */
&space;       close(f);
&space;       doit(g, &amp;from);
&space;   }
&space;   close(g);             /* Parent */
}
</CODE>
<PARAGRAPH>An <FUNCTION>accept()</FUNCTION> call blocks the server until a client requests service. This call could return a failure status if interrupted by a signal such as SIGCHLD. Therefore, the return value from <FUNCTION>accept()</FUNCTION> is checked to ensure that a connection has actually been established, and an error report is logged via <FUNCTION>syslog()</FUNCTION> if an error has occurred.</PARAGRAPH>
<PARAGRAPH>With a connection established, the server then <FUNCTION>fork()</FUNCTION>s a child process and invokes the main body of the remote login protocol processing. Note that the socket used by the parent for queuing connection requests is closed in the child, while the socket created as a result of <FUNCTION>accept()</FUNCTION> is closed in the parent. The address of the client is also handed to the <FUNCTION>doit()</FUNCTION> routine, because the routine requires it in authenticating clients.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Connection-based Clients</TITLE><PARAGRAPH>The client side of the remote login service was described in <XREF IDREF="17020" TYPE="TITLE">&ldquo;Network Dependencies&rdquo;</XREF>. The separate, asymmetric roles of the client and server show clearly in the code. The server is a passive entity, listening for client connections, while the client process is an active entity, initiating a connection when invoked.</PARAGRAPH>
<PARAGRAPH>Consider the steps taken by the client remote login process. As in the server process, the first step is to locate the service definition for a remote login:</PARAGRAPH>
<CODE>
sp = getservbyname("login", "tcp");
if (sp == NULL) {
&space;   fprintf(stderr, "rlogin: tcp/login: unknown service\n");
&space;   exit(1);
}
</CODE>
<PARAGRAPH>Then the <FUNCTION>gethostbyname()</FUNCTION> call looks up the destination host:</PARAGRAPH>
<CODE>
hp = gethostbyname(argv[1]);
if (hp == NULL) {
&space;   fprintf(stderr, "rlogin: %s: unknown host\n", argv[1]);
&space;   exit(2);
}
</CODE>
<PARAGRAPH>Next, a connection is established to the server at the requested host and the remote login protocol is started. The address buffer is cleared and is then filled in with the Internet address of the remote host and the port number of the login process on the remote host:</PARAGRAPH>
<CODE>
bzero((char *)&amp;server, sizeof (server));
bcopy(hp->h_addr, (char *) &amp;server.sin_addr, hp->h_length);
server.sin_family = hp->h_addrtype;
server.sin_port = sp->s_port;
</CODE>
<PARAGRAPH>A socket is created and a connection is initiated:</PARAGRAPH>
<CODE>
s = socket(hp->h_addrtype, SOCK_STREAM, 0);
if (s &lt; 0) {
&space;   perror("rlogin: socket");
&space;   exit(3);
}
&space;   ...
if (connect(s, (struct sockaddr *)&amp;server,
&space;           sizeof (server)) &lt; 0) {
&space;   perror("rlogin: connect");
&space;   exit(4);
}
</CODE>
<PARAGRAPH>Note that <FUNCTION>connect()</FUNCTION> implicitly performs a <FUNCTION>bind()</FUNCTION> call in this case, since <VARIABLE>s</VARIABLE>&space;is unbound.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Connectionless Servers</TITLE><PARAGRAPH>While connection-based services are the norm, some services are based on the use of datagram sockets. The <COMMAND>rwho </COMMAND>service is an example. It provides users with status information for hosts connected to a local area network. This service is predicated on the ability to broadcast information to all hosts connected to a particular network.</PARAGRAPH>
<PARAGRAPH>A user on any machine running the<COMMAND>&space;rwho </COMMAND>server can find out the current status of a machine with the <COMMAND>ruptime</COMMAND> program (see <REFPAGE>ruptime(1C)</REFPAGE>). For example, <COMMAND>ruptime</COMMAND> might generate this output:</PARAGRAPH>
<CODE>
dali      up    2+06:28,    9 users, load 1.04, 1.20, 1.65
breton    down  0:24
manray    up    3+06:18,    0 users, load 0.03, 0.03, 0.05
magritte  up    1+00:43,    2 users, load 0.22, 0.09, 0.07
</CODE>
<PARAGRAPH>Status information for each host is periodically broadcast by <COMMAND>rwho</COMMAND> server processes on each machine. The same server process also receives the status information and uses it to update a database. This database is then interpreted to generate the status information for each host. Servers operate autonomously, coupled only by the local network and its broadcast capabilities.</PARAGRAPH>
<PARAGRAPH>The use of broadcast for such a task is inefficient, as all hosts must process each message, whether or not they are using an <COMMAND>rwho</COMMAND> server. Unless such a service is sufficiently universal and frequently used, the expense of periodic broadcasts outweighs the simplicity. However, on a very small network (for example, one dedicated to a computation engine and several display engines) broadcast works well because all services are universal.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>Multicasting reduces the load on host machines and is an alternative to broadcasting. Setting up multicast sockets is described in <XREF IDREF="88856" TYPE="TITLE">&ldquo;IP Multicasting&rdquo;</XREF>.</NOTE>
<PARAGRAPH>The <INDEXTARGET ID="2.sockets16"><!-- POSTPROCESSDATA: 2.sockets16|rwho server --><COMMAND>rwho</COMMAND> server, in a simplified form, is shown in this code sample:</PARAGRAPH>
<CODE>
main()
{
&space;   ...
&space;   sp = getservbyname("who", "udp");
&space;   from.sin_addr.s_addr = htonl(INADDR_ANY);
&space;   from.sin_port = sp->s_port;
&space;   ...
&space;   s = socket(AF_INET, SOCK_DGRAM, 0);
&space;   ...
&space;   on = 1;
&space;   if (setsockopt(s, SOL_SOCKET, SO_BROADCAST,
&space;                  &amp;on, sizeof(on)) &lt; 0) {
&space;       syslog(LOG_ERR, "setsockopt SO_BROADCAST: %m");
&space;       exit(1);
&space;   }
&space;   bind(s, (struct sockaddr *)&amp;from, sizeof (from));
&space;   ...
&space;   signal(SIGALRM, onalrm);
&space;   onalrm();
&space;   for (;;) {
&space;       struct whod wd;
&space;       int cc, whod, len = sizeof (from);
&space;       
&space;       cc = recvfrom(s, (char *)&amp;wd, sizeof (struct whod),
&space;                     0, (struct sockaddr *)&amp;from, &amp;len);
&space;       if (cc &lt;= 0) {
&space;           if (cc &lt; 0 &amp;&amp; errno != EINTR) {
&space;               syslog(LOG_ERR, "rwhod: recv: %m");
&space;           }
&space;           continue;
&space;       }
&space;       if (from.sin_port != sp->s_port) {
&space;           syslog(LOG_ERR, "rwhod: %d: bad from port",
&space;                  ntohs(from.sin_port));
&space;           continue;
&space;       }
&space;       ...
&space;       if (!verify(wd.wd_hostname)) {
&space;           syslog(LOG_ERR,
&space;                  "rwhod: malformed host name from %x",
&space;                  ntohl(from.sin_addr.s_addr));
&space;           continue;
&space;       }
&space;       (void) sprintf(path, "%s/whod.%s", RWHODIR,
&space;                      wd.wd_hostname);
&space;       whod = open(path, O_WRONLY|O_CREAT|O_TRUNC, 0666);
&space;       ...
&space;       /*undo header byte swapping before writing to file*/
&space;       wd.wd_sendtime = ntohl(wd.wd_sendtime);
&space;       ...
&space;       (void) time(&amp;wd.wd_recvtime);
&space;       (void) write(whod, (char *)&amp;wd, cc);
&space;       (void) close(whod);
&space;   }
}
</CODE>
<PARAGRAPH>The server performs two separate tasks. The first task is to receive status information broadcast by other hosts on the network. This job is carried out in the main loop of the program. Packets received at the <COMMAND>rwho</COMMAND> port are interrogated to make sure they were sent by another <COMMAND>rwho</COMMAND> server process. They are then time-stamped with their arrival time and used to update a file indicating the status of the host. When a host has not been heard from for an extended period of time, the database interpretation routines assume the host is down and indicate such on the status reports. This algorithm is prone to error, because an <COMMAND>rwho</COMMAND> server can be down while a host is actually up.</PARAGRAPH>
<PARAGRAPH>The second task performed by the server is to supply host status information. This task involves periodically acquiring system status information, packaging it in a message, and broadcasting it on the local network for other <COMMAND>rwho</COMMAND> servers to hear. The supply function is triggered by a timer and runs off a signal.</PARAGRAPH>
<PARAGRAPH>Deciding where to transmit the resultant packet is somewhat problematical. Status information must be broadcast on the local network. For networks that do not support broadcast, another scheme must be used. One possibility is to enumerate the known neighbors (based on the status messages received from other <COMMAND>rwho</COMMAND> servers). This method requires some bootstrapping information, because a server will have no idea what machines are its neighbors until it receives status messages from them. Therefore, if all machines on a network are freshly booted, no machine will have any known neighbors and thus will never receive, or send, any status information. This problem also occurs in the routing table management process in propagating routing status information.</PARAGRAPH>
<PARAGRAPH>The standard solution is to inform one or more servers of known neighbors and request that the servers always communicate with these neighbors. If each server has at least one neighbor supplied to it, status information can then propagate through a neighbor to hosts that are not directly neighbors.</PARAGRAPH>
<PARAGRAPH>If the server is able to support networks that provide a broadcast capability, as well as those that do not, networks with an arbitrary topology can share status information. However, network loops can cause problems. That is, if a host is connected to multiple networks, it will receive status information from itself. This situation can lead to an endless, wasteful exchange of information.</PARAGRAPH>
<PARAGRAPH>Software operating in a distributed environment should not have any site&ndash;dependent information compiled into it. To achieve this, each host must have a separate copy of the server, making server maintenance difficult. The BSD model attempts to isolate host-specific information from applications by providing system calls that return the necessary information. An example of such a call is <FUNCTION>gethostname()</FUNCTION> (see <REFPAGE>gethostname(2)</REFPAGE>), which returns the host's &ldquo;official&rdquo; name. In addition, an <COMMAND>ioctl</COMMAND> call can find the collection of networks to which a host is directly connected. Furthermore, a local network broadcasting mechanism has been implemented at the sockets level.</PARAGRAPH>
<PARAGRAPH>Combining these features lets a process broadcast on any directly connected local network that supports the notion of broadcasting in a site-independent manner. The system decides how to propagate status information in the case of <COMMAND>rwho, </COMMAND>or more generally in broadcasting. Such status information is broadcast to connected networks at the sockets level, where the connected networks have been obtained via the appropriate <COMMAND>ioctl</COMMAND> calls. The specifics of this kind of broadcasting are discussed in the next section, &ldquo;Advanced Topics.&rdquo; </PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="27505">Advanced Topics</TITLE><PARAGRAPH>For most users of the sockets interface, the mechanisms already described will suffice in constructing distributed applications. However, you might need to use some of the more advanced features described in this section.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="44096">Out-of-Band Data</TITLE><PARAGRAPH>Stream sockets can accommodate &ldquo;out-of-band&rdquo; data. Out-of-band data is transmitted on a logically independent transmission channel associated with each pair of connected stream sockets. Out-of-band data is delivered to the user independently of normal data. For stream sockets, the out-of-band data facilities must support the reliable delivery of at least one out-of-band message at a time. This message can contain at least one byte of data, and at least one message can be pending delivery to the user at any one time.</PARAGRAPH>
<PARAGRAPH>For communication protocols that support only in-band signaling (that is, the urgent data is delivered in sequence with the normal data), the system extracts the data from the normal data stream and stores it separately. You can choose between receiving urgent data in sequence and receiving it out of sequence, without having to buffer all the intervening data.</PARAGRAPH>
<PARAGRAPH>It is possible to &ldquo;peek&rdquo; (via MSG_PEEK) at out-of-band data. If the socket has a process group, SIGURG is generated when the protocol is notified of its existence. A process can set the process group or process ID to be informed by SIGURG via the appropriate <COMMAND>fcntl</COMMAND> call as described for SIGIO (see <XREF IDREF="90745" TYPE="TITLE">&ldquo;Interrupt-driven Sockets I/O&rdquo;</XREF>). If multiple sockets can have out-of-band data awaiting delivery, a <COMMAND>select</COMMAND> call for exceptional conditions can be used to determine which sockets have such data pending. Neither the signal nor the <COMMAND>select</COMMAND> indicates the actual arrival of the out-of-band data, only notification of pending data.</PARAGRAPH>
<PARAGRAPH>In addition to the information passed, a logical mark is placed in the data stream to indicate the point at which the out-of-band data was sent. The remote login and remote shell applications use this facility to propagate signals between client and server processes. When a signal flushes pending output from the remote process(es), all data up to the mark in the data stream is discarded.</PARAGRAPH>
<PARAGRAPH>To send an out-of-band message, the MSG_OOB flag is supplied to a <INDEXTARGET ID="2.sockets17"><!-- POSTPROCESSDATA: 2.sockets17|ioctls:SIOCATMARK --><FUNCTION>send()</FUNCTION> or <FUNCTION>sendto()</FUNCTION> call. To receive out-of-band data, MSG_OOB should be indicated when performing a <FUNCTION>recvfrom()</FUNCTION> or <FUNCTION>recv()</FUNCTION> call. To find out if the read pointer is currently pointing at the mark in the data stream, use the SIOCATMARK <COMMAND>ioctl</COMMAND>:</PARAGRAPH>
<CODE>
int yes;
ioctl(s, SIOCATMARK, &amp;yes);
</CODE>
<PARAGRAPH>If the value <ITALICS>yes</ITALICS> is a 1 on return, the next <COMMAND>read</COMMAND> will return data after the mark. Otherwise (assuming out-of-band data has arrived), the next <COMMAND>read</COMMAND> will provide data sent by the client prior to transmission of the out-of-band signal. <XREF IDREF="45593" TYPE="TEXT">Example&nbsp;2-2</XREF> shows the routine used in the remote login process to flush output on receipt of an interrupt or quit signal. It reads the normal data up to the mark (to discard it) and then reads the out-of-band byte.</PARAGRAPH>

<!-- WARNING: (47) Example captions should come at end of Example - detected on page 40 -->
<!-- WARNINGLOCATION: PAGE = "40" SRC = "2.sockets.mif" TAGTYPE = "PARA" TAG = "ExampleTitle" TAGCOUNT = "1" UID = "3601" TEXT = " shows the routine used i"-->
<EXAMPLE><CAPTION LBL="2-2"><PREFIX>Example 2-2 </PREFIX><XREFTARGET ID="45593">Flushing Terminal I/O on Receipt of Out-of-Band Data</CAPTION></EXAMPLE>
<CODE>
#include &lt;stdio.h>
#include &lt;termios.h>        /* POSIX-style */
#include &lt;sys/ioctl.h>
#include &lt;sys/socket.h>

oob()
{
&space;   int  mark;
&space;   char waste[BUFSIZ];
&space;   /* Flush local terminal output */
&space;   tcflush(1, TCOFLUSH);
&space;   for (;;) {
&space;       if (ioctl(rem, SIOCATMARK, &amp;mark) &lt; 0) {
&space;           perror("ioctl");
&space;           break;
&space;       }
&space;       if (mark)
&space;           break;
&space;       (void) read(rem, waste, sizeof (waste));
&space;   }
&space;   if (recv(rem, &amp;mark, 1, MSG_OOB) &lt; 0) {
&space;       perror("recv");
&space;       ...
&space;   }
&space;   ...
}
</CODE>
<PARAGRAPH>A process can also read the out-of-band data without first reading up to the mark. Reading the out-of-band data in this way is more difficult when the underlying protocol delivers the urgent data in-band with the normal data and only sends notification of its presence ahead of time (for example, the TCP protocol used to implement streams in the Internet domain). With such protocols, the out-of-band byte may not yet have arrived when a <COMMAND>recv</COMMAND> is done with the MSG_OOB flag. In that case, the call will return an error of EWOULDBLOCK. Worse, there may be so much in-band data in the input buffer that normal flow control prevents the sender from sending the urgent data until the buffer is cleared. The process must then read enough of the queued data for the urgent data to be delivered.</PARAGRAPH>
<PARAGRAPH>Certain programs that use multiple bytes of urgent data and must handle multiple urgent signals&mdash;for example, <COMMAND>telnet </COMMAND>(see <REFPAGE>telnet(1C)</REFPAGE>)&mdash;need to retain the position of urgent data within the stream. This treatment is available as a sockets-level option, SO_OOBINLINE; see <REFPAGE>setsockopt(2)</REFPAGE> for usage. With this option, the position of urgent data (the &ldquo;mark&rdquo;) is retained, but the urgent data immediately follows the mark within the normal data stream returned without the MSG_OOB flag. Reception of multiple urgent indications causes the mark to move, but no out-of-band data is lost.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Nonblocking Sockets</TITLE><PARAGRAPH>Programs that cannot wait for a socket operation to be completed should use nonblocking sockets. I/O requests on nonblocking sockets return with an error if the request cannot be satisfied immediately.<INDEXTARGET ID="2.sockets18"><!-- POSTPROCESSDATA: 2.sockets18|non-blocking socketssockets:non-blockingfcntls:FNDELAY --></PARAGRAPH>
<PARAGRAPH>Once a socket has been created with the <FUNCTION>socket()</FUNCTION> call, it can be marked as nonblocking by <FUNCTION>fcntl()</FUNCTION> as follows:</PARAGRAPH>
<CODE>
#include &lt;fcntl.h>
&space;...
int s;
&space;...
s = socket(AF_INET, SOCK_STREAM, 0);
&space;...
if (fcntl(s, F_SETFL, FNDELAY) &lt; 0)  {
&space;   perror("fcntl F_SETFL, FNDELAY");
&space;   exit(1);
}
...
</CODE>
<PARAGRAPH>When performing nonblocking I/O on sockets, check for the error EAGAIN (stored in the global variable <VARIABLE>errno</VARIABLE>). This error occurs when an operation would normally block, but the socket it was performed on is nonblocking. In particular, <FUNCTION>accept()</FUNCTION>, <FUNCTION>connect()</FUNCTION>, <FUNCTION>send()</FUNCTION>, <FUNCTION>recv()</FUNCTION>, <FUNCTION>read()</FUNCTION>, and <FUNCTION>write()</FUNCTION> can all return EAGAIN, and processes should be prepared to deal with this return code.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>In previous releases of IRIX, the error EWOULDBLOCK was sometimes returned instead of EAGAIN. In the current release of IRIX, EWOULDBLOCK is defined as EAGAIN for source compatibility.</NOTE>
<PARAGRAPH>If an operation such as a <FUNCTION>send()</FUNCTION> cannot be completed, but partial writes are sensible (for example, when using a stream socket), data that can be sent immediately is processed, and the return value indicates the amount that was actually sent.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="90745">Interrupt-driven Sockets I/O</TITLE><PARAGRAPH>The SIGIO signal allows a process to be notified when a socket (or more generally, a file descriptor) has data waiting to be read. Use of the SIGIO facility requires three steps:<INDEXTARGET ID="2.sockets19"><!-- POSTPROCESSDATA: 2.sockets19|interrupt-driven socket I/Osockets:interrupt-driven I/Osignals:SIGIOsignals:SIGURGfcntls:F_SETOWNfcntls:FASYNC --></PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>The process must use a <COMMAND>signal</COMMAND> call to set up a SIGIO signal handler.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The process must set the process ID or process group ID (see <XREF IDREF="52816" TYPE="TITLE">&ldquo;Signals and Process Groups&rdquo;</XREF>) to receive notification of pending input either to its own process ID or to the group ID of its process group (the default process group of a socket is group zero). To do this, the process uses an <COMMAND>fcntl</COMMAND> call.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The process uses another <COMMAND>fcntl</COMMAND> call to enable asynchronous notification of pending I/O requests. <XREF IDREF="17072" TYPE="TEXT">Example&nbsp;2-3</XREF> shows sample code that enables a process to receive information on pending I/O requests as they occur for a socket <VARIABLE>s</VARIABLE>. With the addition of a handler for SIGURG, this code can be used to prepare for receipt of SIGURG signals.</PARAGRAPH>

<!-- WARNING: (47) Example captions should come at end of Example - detected on page 43 -->
<!-- WARNINGLOCATION: PAGE = "43" SRC = "2.sockets.mif" TAGTYPE = "PARA" TAG = "ExampleTitle" TAGCOUNT = "1" UID = "960" TEXT = ". With the addition of a "-->
<EXAMPLE><CAPTION LBL="2-3"><PREFIX>Example 2-3 </PREFIX><XREFTARGET ID="17072">Asynchronous Notification of I/O Requests</CAPTION></EXAMPLE>
<CODE>
#include &lt;signal.h>
#include &lt;fcntl.h>

...
int    io_handler();
...
main()
{
&space;   signal(SIGIO, io_handler);
&space;   
&space;   /*Set the process receiving SIGIO/SIGURG signals to us*/
&space;   
&space;   if (fcntl(s, F_SETOWN, getpid()) &lt; 0) {
&space;       perror("fcntl F_SETOWN");
&space;       exit(1);
&space;   }
&space;   
&space;   /* Allow receipt of asynchronous I/O signals */
&space;   if (fcntl(s, F_SETFL, FASYNC) &lt; 0) {
&space;       perror("fcntl F_SETFL, FASYNC");
&space;       exit(1);
&space;   }
}
io_handler()
{
...
}
</CODE>
</LIST>
</ORDEREDLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="52816">Signals and Process Groups</TITLE><PARAGRAPH>Due to the existence of the SIGURG and SIGIO signals, each socket has an associated process number. This value is initialized to zero, but it can be redefined at a later time with the F_SETOWN <INDEXTARGET ID="2.sockets20"><!-- POSTPROCESSDATA: 2.sockets20|signal handlingprocess groupsgroups:signal process --><COMMAND>fcntl</COMMAND>, as was done in the previous code for SIGIO. To set the socket's process ID for signals, positive arguments should be given to the <COMMAND>fcntl </COMMAND>call. To set the socket's process group for signals, negative arguments should be passed to <VARIABLE>fcntl</VARIABLE>. Note that the process number indicates either the associated process ID or the associated process group; it is impossible to specify both at the same time. A similar <VARIABLE>fcntl</VARIABLE>, F_GETOWN, is available for determining the current process number of a socket.</PARAGRAPH>
<PARAGRAPH>Another useful signal you can use when constructing server processes is SIGCHLD, which is delivered to a process when any child processes have changed state. Normally, servers use SIGCHLD to &ldquo;reap&rdquo; child processes that have exited, without explicitly awaiting their termination or periodic polling for exit status. For example, the remote login server loop shown in <INDEXTARGET ID="2.sockets21"><!-- POSTPROCESSDATA: 2.sockets21|signals:SIGCHLD --><XREF IDREF="26711" TYPE="TITLE">&ldquo;Connection-based Servers&rdquo;</XREF> can be augmented, as shown in <XREF IDREF="28810" TYPE="TEXT">Example&nbsp;2-4</XREF>.</PARAGRAPH>

<!-- WARNING: (47) Example captions should come at end of Example - detected on page 44 -->
<!-- WARNINGLOCATION: PAGE = "44" SRC = "2.sockets.mif" TAGTYPE = "PARA" TAG = "ExampleTitle" TAGCOUNT = "1" UID = "994" TEXT = "."-->
<EXAMPLE><CAPTION LBL="2-4"><PREFIX>Example 2-4 </PREFIX><XREFTARGET ID="28810">Using the SIGCHLD Signal</CAPTION></EXAMPLE>
<CODE>
#include &lt;signal.h>

int reaper();
...
main()
{
&space;   ...
&space;   signal(SIGCHLD, reaper);
&space;   listen(f, 5);
&space;   for (;;) {
&space;       int g, len = sizeof (from);

&space;       g = accept(f, (struct sockaddr *)&amp;from, &amp;len,);
&space;       if (g &lt; 0) {
&space;           if (errno != EINTR) {
&space;               syslog(LOG_ERR, "rlogind: accept: %m");
&space;           }
&space;           continue;
&space;       }
&space;       ...
&space;      }
}
#include &lt;sys/wait.h>
reaper()
{
&space;   union wait status;

&space;   while (wait3(&amp;status, WNOHANG, 0) > 0) {
&space;       ;    /* no-op */
&space;   }
}
</CODE>
<PARAGRAPH>If the parent server process fails to reap its children, a large number of &ldquo;zombie&rdquo; processes can be created.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Pseudo-Terminals</TITLE><PARAGRAPH>Many programs will not function properly without a terminal for standard input and output. Since sockets do not provide the semantics of terminals, it is often necessary to have a process communicate over the network through a <INDEXTARGET ID="2.sockets22"><!-- POSTPROCESSDATA: 2.sockets22|pseudo terminals:terminal:pseudopty creation --><ITALICS>pseudo-terminal.</ITALICS> A pseudo-terminal is actually a pair of devices, master and slave, that allows a process to serve as an active agent in communication between processes and users. Data written on the slave side of a pseudo&ndash;terminal is supplied as input to a process reading from the master side, while data written on the master side is processed as terminal input for the slave. In this way, the process manipulating the master side of the pseudo-terminal has control over the information read and written on the slave side, as if it were manipulating the keyboard and reading the screen on a real terminal. The purpose of this abstraction is to preserve terminal semantics over a network connection. The slave side appears as a normal terminal to any process reading from or writing to it.</PARAGRAPH>
<PARAGRAPH>For example, the remote login server uses pseudo-terminals for remote login sessions. A user logging in to a machine across the network gets a shell with a slave pseudo-terminal as standard input, output, and error. The server process then handles the communication between the programs invoked by the remote shell and the user's local client process. When a user sends a character that causes a remote machine to flush terminal output, the pseudo&ndash;terminal generates a control message for the server process. The server then sends an out-of-band message to the client process to signal a flush of data at the real terminal and on the intervening data buffered in the network.</PARAGRAPH>
<PARAGRAPH>Under IRIX, the name of the slave side of a pseudo-terminal has this syntax:</PARAGRAPH>
<EXAMPLE>
/dev/ttyqx
</EXAMPLE>
<PARAGRAPH>In this syntax, <VARIABLE>x </VARIABLE>is a number in the range 0 through 99. The master side of a pseudo-terminal is the generic device <FILENAME>/dev/ptc</FILENAME>.</PARAGRAPH>
<PARAGRAPH>Creating a pair of master and slave pseudo-terminals is straightforward. The master half of a pseudo-terminal is opened first. The slave side of the pseudo-terminal is then opened and is set to the proper terminal modes if necessary. The process then<COMMAND>&space;fork</COMMAND>s. The child closes the master side of the pseudo&ndash;terminal and <COMMAND>exec</COMMAND>s the appropriate program. Meanwhile, the parent closes the slave side of the pseudo-terminal and begins reading and writing from the master side.</PARAGRAPH>
<PARAGRAPH>The sample code in <XREF IDREF="27436" TYPE="TEXT">Example&nbsp;2-5</XREF> illustrates making use of pseudo&ndash;terminals. This code assumes that a connection on a socket s exists, connected to a peer that wants a service of some kind, and that the process has disassociated itself from any previously controlling terminal.</PARAGRAPH>

<!-- WARNING: (47) Example captions should come at end of Example - detected on page 46 -->
<!-- WARNINGLOCATION: PAGE = "46" SRC = "2.sockets.mif" TAGTYPE = "PARA" TAG = "ExampleTitle" TAGCOUNT = "1" UID = "1038" TEXT = "exists, connected to a pe"-->
<EXAMPLE><CAPTION LBL="2-5"><PREFIX>Example 2-5 </PREFIX><XREFTARGET ID="27436">Creating and Using a Pseudo-Terminal on IRIX</CAPTION></EXAMPLE>
<CODE>
#include &lt;sys/sysmacros.h>
#include &lt;fcntl.h>
#include &lt;syslog.h>

int master, slave;
struct stat stb;
char line[sizeof("/dev/ttyqxxx")];
master = open("/dev/ptc", O_RDWR | O_NDELAY);
if (master &lt; 0 || fstat(master, &amp;stb) &lt; 0) {
&space;   syslog(LOG_ERR, "All network ports in use");
&space;   exit(1);
}
sprintf(line, "/dev/ttyq%d", minor(stb.st_rdev));
/* Put in separate process group, disassociate
&space;  controlling terminal. */
setsid();

slave = open(line, O_RDWR);    /* Open slave side */
if (slave &lt; 0) {
&space;   syslog(LOG_ERR, "Cannot open slave pty %s", line);
&space;   exit(1);
}
pid = fork();
if (pid &lt; 0) {
&space;   syslog(LOG_ERR, "fork: %m");
&space;   exit(1);
}
if (pid > 0) {        /* Parent */
&space;   close(slave);
&space;   ...
} else {            /* Child */
&space;   close(master);
&space;   dup2(slave, 0);
&space;   dup2(slave, 1);
&space;   dup2(slave, 2);
&space;   if (slave > 2)
&space;       (void) close(slave);
&space;   ...
}
</CODE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="75950">Selecting Protocols</TITLE><PARAGRAPH>If the third argument to the <INDEXTARGET ID="2.sockets23"><!-- POSTPROCESSDATA: 2.sockets23|protocol:selectselect protocol --><FUNCTION>socket()</FUNCTION> call is 0, <FUNCTION>socket()</FUNCTION> will select a default protocol to use with the returned socket of the type requested. The default protocol is usually correct, and alternate choices are not usually available. However, when using raw sockets to communicate directly with lower-level protocols or hardware interfaces, the protocol argument can be important for setting up de-multiplexing. For example, raw sockets in the Internet family can be used to implement a new protocol above IP, and the socket will receive packets only for the protocol specified.</PARAGRAPH>
<PARAGRAPH>To obtain a particular protocol, determine the protocol number as defined within the communication domain. For the Internet domain, you can use one of the library routines described in <XREF IDREF="93055" TYPE="TITLE">&ldquo;Network Library Routines&rdquo;</XREF>. For example, you can use <FUNCTION>getprotobyname()</FUNCTION>:</PARAGRAPH>
<CODE>
#include &lt;sys/types.h>
#include &lt;sys/socket.h>
#include &lt;netinet/in.h>
#include &lt;netdb.h>
&space;...
pp = getprotobyname("newtcp");
s = socket(AF_INET, SOCK_STREAM, pp->p_proto);
</CODE>
<PARAGRAPH>This call results in a socket <VARIABLE>s</VARIABLE> using a stream-based connection, but with a protocol type of <COMMAND>newtcp </COMMAND>instead of the default <COMMAND>tcp.</COMMAND></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="81270">Address Binding</TITLE><PARAGRAPH>Binding addresses to sockets in the Internet domain can be fairly complex. These associations are composed of local and foreign addresses, and local and foreign ports. Port numbers are allocated out of separate spaces, one for each system and one for each domain on that system.<INDEXTARGET ID="2.sockets24"><!-- POSTPROCESSDATA: 2.sockets24|address:bindingbinding:address --></PARAGRAPH>
<PARAGRAPH>Through the <FUNCTION>bind()</FUNCTION> system call, a process can specify half of an association, the <ITALICS>&lt;local address, local port></ITALICS> part, while the <COMMAND>connect</COMMAND> and <COMMAND>accept</COMMAND> calls are used to complete a socket's association by specifying the <ITALICS>&lt;foreign address, foreign port></ITALICS> part. Since the association is created in two steps, the association uniqueness requirement could be violated unless care is taken.</PARAGRAPH>
<PARAGRAPH>Furthermore, user programs do not always know the proper values to use for the local address and local port, since a host can reside on multiple networks and the set of allocated port numbers is not directly accessible to a user.</PARAGRAPH>
<PARAGRAPH>To simplify local address binding in the Internet domain, a wildcard address is provided. When an address is specified as INADDR_ANY (a manifest constant defined in <FILENAME>&lt;netinet/in.h></FILENAME>), the system interprets the address as &ldquo;any valid address.&rdquo;</PARAGRAPH>
<PARAGRAPH>For example, to bind a specific port number to a socket but leave the local address unspecified, the following code might be used:</PARAGRAPH>
<CODE>
#include &lt;sys/types.h>
#include &lt;netinet/in.h>
&space;...
struct sockaddr_in sin;
&space;...
s = socket(AF_INET, SOCK_STREAM, 0);
sin.sin_family = AF_INET;
sin.sin_addr.s_addr = htonl(INADDR_ANY);
sin.sin_port = htons(MYPORT);
bind(s, (struct sockaddr *) &amp;sin, sizeof (sin));
</CODE>
<PARAGRAPH>Sockets with wildcarded local addresses can receive messages directed to the specified port number and sent to any of the possible addresses assigned to a host. For example, if a host has addresses 128.32.0.4 and 10.0.0.78, and a socket is bound as above, the process will be able to accept connection requests that are addressed to 128.32.0.4 or 10.0.0.78. For a server process to allow only hosts on a given network to connect to it, it would bind whichever of the server's addresses were on the appropriate network.</PARAGRAPH>
<PARAGRAPH>Similarly, a local port can be left unspecified (specified as zero), in which case the system selects an appropriate port number for it. For example, to bind a specific local address to a socket but leave the local port number unspecified, use this code:</PARAGRAPH>
<CODE>
hp = gethostbyname(hostname);
if (hp == NULL) {
&space;  ...
}
bcopy(hp->h_addr, (char *) sin.sin_addr, hp->h_length);
sin.sin_port = htons(0);
bind(s, (struct sockaddr *) &amp;sin, sizeof (sin));
</CODE>
<PARAGRAPH>The system selects the local port number based on two criteria:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>On BSD systems, Internet ports between 512 and 1023 (IPPORT_RESERVED &ndash; 1) are reserved for privileged users; Internet ports above IPPORT_USERRESERVED (5000) are reserved for nonprivileged servers; and Internet ports between IPPORT_RESERVED and IPPORT_USERRESERVED are used by the system for assignment to clients.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The port number may not be bound to another socket.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>To find a free Internet port number in the privileged range, the <FILENAME>rresvport</FILENAME> library routine can be used as follows to return a stream socket with a privileged port number:</PARAGRAPH>
<CODE>
int lport = IPPORT_RESERVED - 1;
int s;
&space;...
s = rresvport(&amp;lport);
if (s &lt; 0) {
&space;   if (errno == EAGAIN)
&space;       fprintf(stderr, "socket: all ports in use");
&space;   else
&space;       perror("rresvport: socket");
&space;   ...
}
</CODE>
<PARAGRAPH>The restriction on allocating ports allows processes executing in a &ldquo;secure&rdquo; environment to perform authentication based on the originating address and port number. For example, the <COMMAND>rlogin</COMMAND> command (see <REFPAGE>rlogin(1C)</REFPAGE>) lets users log in across a network without being asked for a password, under two conditions:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The name of the system the user is logging in from is in the file <FILENAME>/etc/hosts.equiv</FILENAME>&space;on the system being logged in to (or the system name and the user name are in the user's <FILENAME>.rhosts</FILENAME>&space;file in the user's home directory).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The user's <COMMAND>rlogin</COMMAND> process is coming from a privileged port on the machine from which the user is logging in.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The port number and network address of the machine the user is logging in from can be determined either by the <ITALICS>from</ITALICS> result of the <FUNCTION>accept()</FUNCTION> call or from the <FUNCTION>getpeername()</FUNCTION> call.</PARAGRAPH>
<PARAGRAPH>The algorithm used by the system to select port numbers can be unsuitable for an application, because the algorithm creates associations in a two&ndash;step process. For example, FTP specifies that data connections must always originate from the same local port. However, duplicate associations are avoided by connecting to different foreign ports. The system disallows binding the same local address and port number to a socket if a previous data connection's socket still exists. To override the default port selection algorithm, the following option call must be performed before address binding:</PARAGRAPH>
<CODE>
&space;...
int on = 1;
&space;...
setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on));
bind(s, (struct sockaddr *) &amp;sin, sizeof (sin));
</CODE>
<PARAGRAPH>With this call, local addresses that are already in use can be bound. Binding local addresses does not violate the uniqueness requirement, because the system still checks at connect time to make sure that any other sockets with the same local address and port do not have the same foreign address and port. If the association already exists, the error EADDRINUSE is returned.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Socket Options</TITLE><PARAGRAPH>You can use the <INDEXTARGET ID="2.sockets25"><!-- POSTPROCESSDATA: 2.sockets25|sockets:optionsoptions, socketsetsockopt(2)getsockopt(2) --><FUNCTION>setsockopt()</FUNCTION> and <FUNCTION>getsockopt()</FUNCTION> system calls to set and get a number of options on sockets. These options include marking a socket for broadcasting, not routing, lingering on closing, and so on. In addition, you can specify protocol-specific options for IP and TCP, as described in <REFPAGE>ip(7P)</REFPAGE> and <REFPAGE>tcp(7P)</REFPAGE>, and in <XREF IDREF="88856" TYPE="TITLE">&ldquo;IP Multicasting&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>The general form of the <FUNCTION>setsockopt()</FUNCTION> and <FUNCTION>getsockopt()</FUNCTION> calls is:</PARAGRAPH>
<CODE>
setsockopt(s, level, optname, optval, optlen);
getsockopt(s, level, optname, optval, optlen);
</CODE>
<PARAGRAPH>The parameters have these meanings:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><VARIABLE>s</VARIABLE> is the socket on which the option is to be applied.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><VARIABLE>level</VARIABLE> specifies the protocol layer on which the option is to be applied; in most cases, level is the sockets level, indicated by the symbolic constant SOL_SOCKET, defined in &lt;<FILENAME>sys/socket.h</FILENAME>>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><VARIABLE>optname</VARIABLE> specifies the actual option, a symbolic constant that is also defined in &lt;<FILENAME>sys/socket.h</FILENAME>>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><VARIABLE>optval</VARIABLE> points to the value of the option (in most cases, whether the option is to be turned on or off).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><VARIABLE>optlen</VARIABLE> points to the length of the value of the option. For<FUNCTION>&space;getsockopt</FUNCTION>,<VARIABLE>&space;optlen</VARIABLE> is a value-result parameter, initially set to the size of the storage area pointed to by <VARIABLE>optval</VARIABLE> and modified upon return to indicate the actual amount of storage used.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>For example, sometimes it's useful to determine the type (stream or datagram) of an existing socket. Programs under <COMMAND>inetd</COMMAND> (described in <XREF IDREF="22690" TYPE="TITLE">&ldquo;The inetd Daemon&rdquo;</XREF>) may need to perform this task. You can do so via the SO_TYPE socket option and the <FUNCTION>getsockopt</FUNCTION> call, shown in this code:</PARAGRAPH>
<CODE>
#include &lt;sys/types.h>
#include &lt;sys/socket.h>

int type, size;
size = sizeof (int);
if (getsockopt(s, SOL_SOCKET, SO_TYPE,
&space;   (char *) &amp;type, &amp;size) &lt; 0) {
&space;   perror("getsockopt");
&space;   ...
}
</CODE>
<PARAGRAPH>After the <FUNCTION>getsockopt</FUNCTION> call, <VARIABLE>type</VARIABLE> will be set to the value of the socket type, as defined in &lt;<FILENAME>sys/socket.h</FILENAME>>. For example, if the socket were a datagram socket, <VARIABLE>type</VARIABLE> would have the value corresponding to SOCK_DGRAM.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="22690">The inetd Daemon</TITLE><PARAGRAPH>When a single daemon listens for requests for many daemons, instead of having each daemon listen for its own requests, the number of idle daemons is reduced and the implementation of each daemon is simplified.<INDEXTARGET ID="2.sockets26"><!-- POSTPROCESSDATA: 2.sockets26|inetddaemon, Internetinetd:tcpmux --></PARAGRAPH>
<PARAGRAPH>The <COMMAND>inetd</COMMAND> daemon handles three types of service:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>A standard service, which has a well-known port assigned to it and is listed in <FILENAME>/etc/services</FILENAME>&space;or the NIS <ITALICS>services</ITALICS> map&mdash;see <REFPAGE>services(4)</REFPAGE>. It may be a service that implements an official Internet standard or is a BSD UNIX&ndash;specific service.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>An RPC service, which uses the Sun RPC calls as the transport; such services are listed in <FILENAME>/etc/rpc</FILENAME> or the NIS rpc map&mdash;see <REFPAGE>rpc(4)</REFPAGE>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A TCPMUX service, which is nonstandard and does not have a well&ndash;known port assigned to it. TCPMUX services are invoked from <COMMAND>inetd</COMMAND> when a program connects to the <ITALICS>tcpmux</ITALICS> well-known port and specifies the service name. This is useful for adding locally developed servers.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The <COMMAND>inetd</COMMAND> daemon is invoked at boot time. It examines the file <FILENAME>/usr/etc/inetd.conf</FILENAME>&space;to determine the servers it will listen for. Once this information has been read and a pristine environment created, <COMMAND>inetd</COMMAND> proceeds to create one socket for each service it is to listen for, binding the appropriate port number to each socket.</PARAGRAPH>
<PARAGRAPH>The <COMMAND>inetd</COMMAND> daemon performs a <FUNCTION>select()</FUNCTION> on these sockets for <FUNCTION>read()</FUNCTION> availability, waiting for a process to request a connection to the service corresponding to that socket. The <COMMAND>inetd</COMMAND>&space;daemon then performs an <FUNCTION>accept()</FUNCTION> on the socket in question, <FUNCTION>fork()</FUNCTION>s, <FUNCTION>dup()</FUNCTION>s the new socket to file descriptors 0 and 1 (<VARIABLE>stdin</VARIABLE> and <VARIABLE>stdout</VARIABLE>), closes other open file descriptors, and execs the appropriate server.</PARAGRAPH>
<PARAGRAPH>Servers making use of <COMMAND>inetd</COMMAND> are considerably simplified, because <COMMAND>inetd</COMMAND> takes care of most of the IPC work required in establishing a connection. The server invoked by <COMMAND>inetd</COMMAND> expects the socket connected to its client on file descriptors 0 and 1, and can immediately perform any operations such as <FUNCTION>read()</FUNCTION>, <FUNCTION>write()</FUNCTION>, <FUNCTION>send()</FUNCTION>,&space;or <FUNCTION>recv()</FUNCTION>.&space;Servers can use buffered I/O as provided by the stdio conventions, as long as they use <FUNCTION>fflush()</FUNCTION> when appropriate. However, for server programs that handle multiple services or protocols, <COMMAND>inetd</COMMAND> allocates socket descriptors to protocols based on lexicographic order of service and protocol name.</PARAGRAPH>
<PARAGRAPH>For example, the RPC mount daemon, <FILENAME>rpc.mountd</FILENAME>, has two entries in <FILENAME>inetd.conf</FILENAME> for its TCP and UDP ports. When invoked by <COMMAND>inetd</COMMAND>, the TCP socket is on descriptor 0, and UDP is on&nbsp;1.</PARAGRAPH>
<PARAGRAPH>When writing servers under <COMMAND>inetd</COMMAND>,&space;you can use the <FUNCTION>getpeername</FUNCTION> call to return the address of the peer (process) connected on the other end of the socket. For example, to log a client's Internet address in &ldquo;dot notation&rdquo; (for example, 128.32.0.4), you might use the following code:</PARAGRAPH>
<CODE>
struct sockaddr_in name;
int namelen = sizeof (name);
&space;...
if (getpeername(0, (struct sockaddr *)&amp;name, &amp;namelen) &lt; 0) {
&space;   syslog(LOG_ERR, "getpeername: %m");
&space;   exit(1);
} else {
&space;   syslog(LOG_INFO, "Connection from %s",
&space;          inet_ntoa(name.sin_addr));
}
</CODE>
<PARAGRAPH>While the <FUNCTION>getpeername</FUNCTION> call is especially useful when writing programs to run with <COMMAND>inetd</COMMAND>,&space;it can be used by stand-alone servers.</PARAGRAPH>
<PARAGRAPH>Standard TCP services are assigned unique well-known port numbers in the range of 0 to 255. These ports are of a limited number and are typically only assigned to official Internet protocols. The TCPMUX service, as described in RFC-1078, allows you to add locally developed protocols without needing an official TCP port assignment.</PARAGRAPH>
<PARAGRAPH>The protocol used by TCPMUX is simple: a TCP client connects to a foreign host on TCP port 1. It sends the service name followed by a carriage-return/ line-feed <USERINPUT>&lt;Ctrl>-F</USERINPUT>. The server replies with a single character indicating positive (+) or negative (&ndash;) acknowledgment, immediately followed by an optional message of explanation, terminated with a <USERINPUT>&lt;Ctrl>-F</USERINPUT>. If the reply was positive, the selected protocol begins; otherwise, the connection is closed. In the IRIX system, the TCPMUX service is built into <COMMAND>inetd</COMMAND>; that is, <COMMAND>inetd</COMMAND> listens on TCP port 1 for requests for TCPMUX services listed in <FILENAME>inetd.conf</FILENAME>.</PARAGRAPH>
<PARAGRAPH>The following code is an example TCPMUX server and its <FILENAME>inetd.conf</FILENAME> entry:</PARAGRAPH>
<CODE>
#include &lt;sys/types.h>
#include &lt;stdio.h>

main()
{
&space;   time_t t;
&space;   printf("+Go\r\n");
&space;   fflush(stdout);
&space;   time(&amp;t);
&space;   printf("%d = %s", t, ctime(&amp;t));
&space;   fflush(stdout);
}
</CODE>
<PARAGRAPH>More sophisticated servers may want to do additional processing before returning the positive or negative acknowledgment.</PARAGRAPH>
<PARAGRAPH>The <FILENAME>inetd.conf</FILENAME> entry is:</PARAGRAPH>
<EXAMPLE>
tcpmux/current_time stream tcp nowait guest /d/curtime curtime
</EXAMPLE>
<PARAGRAPH>The following portion of the client code handles the TCPMUX handshake:</PARAGRAPH>
<CODE>
char line[BUFSIZ];
FILE *fp;
&space;...
/* Use stdio for reading data from the server */
fp = fdopen(sock, "r");
if (fp == NULL) {
&space;   fprintf(stderr, "Can't create file pointer\n");
&space;   exit(1);
}
/* Send service request */
sprintf(line, "%s\r\n", "current_time");
if (write(sock, line, strlen(line)) &lt; 0) {
&space;   perror("write");
&space;   exit(1);
}

/* Get ACK/NAK response from the server */
if (fgets(line, sizeof(line), fp) == NULL) {
&space;   if (feof(fp)) {
&space;       die();
&space;   } else {
&space;       fprintf(stderr, "Error reading response\n");
&space;       exit(1);
&space;   }
}
/* Delete &lt;CR> */
if ((lp = index(line, '\r')) != NULL) {
&space;   *lp = ' ';
}

switch (line[0]) {
&space;   case '+':
&space;       printf("Got ACK: %s\n", &amp;line[1]);
&space;       break;
&space;   case '-':
&space;       printf("Got NAK: %s\n", &amp;line[1]);
&space;       exit(0);
&space;   default:
&space;       printf("Got unknown response: %s\n", line);
&space;       exit(1);
}
/* Get rest of data from the server */
while ((fgets(line, sizeof(line), fp)) != NULL) {
&space;   fputs(line, stdout);
}
</CODE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="37197">Broadcasting</TITLE><PARAGRAPH>Using a datagram socket, you can send broadcast packets on many networks supported by the system. The network itself must support broadcast; the system provides no simulation of broadcast in software. Broadcast messages can place a high load on a network, since they force every host on the network to service them. Consequently, the ability to send broadcast packets has been limited to sockets explicitly marked to allow broadcasting. Broadcast is typically used for one of two reasons: to find a resource on a local network without prior knowledge of its address or to send information to all accessible neighbors.<INDEXTARGET ID="2.sockets27"><!-- POSTPROCESSDATA: 2.sockets27|IP:broadcasting --></PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>Multicasting is an alternative to broadcasting. See <XREF IDREF="88856" TYPE="TITLE">&ldquo;IP Multicasting&rdquo;</XREF> for information about setting up multicast sockets.</NOTE>
<PARAGRAPH>To send a broadcast message, create a datagram socket:</PARAGRAPH>
<EXAMPLE>
s = socket(AF_INET, SOCK_DGRAM, 0);
</EXAMPLE>
<PARAGRAPH>Mark the socket to allow broadcasting:</PARAGRAPH>
<CODE>
int on = 1;
setsockopt(s, SOL_SOCKET, SO_BROADCAST, &amp;on, sizeof (on));
</CODE>
<PARAGRAPH>Bind a port number to the socket:</PARAGRAPH>
<CODE>
sin.sin_family = AF_INET;
sin.sin_addr.s_addr = htonl(INADDR_ANY);
sin.sin_port = htons(MYPORT);
bind(s, (struct sockaddr *) &amp;sin, sizeof (sin));
</CODE>
<PARAGRAPH>The destination address of the broadcast message depends on the network(s). The Internet domain supports a shorthand notation for broadcast on the local network, the address INADDR_BROADCAST (defined in <FILENAME>&lt;netinet/in.h></FILENAME>).</PARAGRAPH>
<PARAGRAPH>Determining the list of addresses for all reachable neighbors requires knowledge of the networks to which the host is connected. Since this information should be obtained in a host-independent fashion and may be impossible to derive, IRIX provides a method for retrieving this information from the system data structures.</PARAGRAPH>
<PARAGRAPH>The SIOCGIFCONF <INDEXTARGET ID="2.sockets28"><!-- POSTPROCESSDATA: 2.sockets28|ioctls:SIOCGIFCONF --><COMMAND>ioctl</COMMAND> call returns the interface configuration of a host in the form of a single <COMMAND>ifconf</COMMAND> structure. This structure contains a data area that is made up of an array of ifreq structures, one for each network interface to which the host is connected. </PARAGRAPH>
<PARAGRAPH>These structures are defined in <FILENAME>&lt;net/if.h></FILENAME>, as shown in this example:</PARAGRAPH>
<CODE>
struct ifconf {
&space;   ifc_len    /* size of associated buffer */
&space;   union {
&space;       caddr_t  ifcu_buf;
&space;       struct   ifreq *ifcu_req;
&space;   } ifc_ifcu;
};

/* Buffer address */
#define ifc_buf   ifc_ifcu.ifcu_buf

/* Array of structures returned */
#define ifc_req   ifc_ifcu.ifcu_req

#define IFNAMSIZ        16
struct  ifreq {

&space;       /* Interface name, e.g. "en0" */
&space;       char    ifr_name[IFNAMSIZ];             
&space;       union {
&space;               struct  sockaddr ifru_addr;
&space;               struct  sockaddr ifru_dstaddr;
&space;               struct  sockaddr ifru_broadaddr;
&space;               short   ifru_flags;
&space;               int     ifru_metric;
&space;               /* MIPS ABI - unused by BSD */
&space;               char    ifru_data[1];    
&space;               char    ifru_enaddr[6];         /* MIPS ABI */
&space;               char    ifru_oname[IFNAMSIZ];   /* MIPS ABI */
&space;               struct  ifstats ifru_stats;

&space;               /* Trusted IRIX */
&space;               struct {
&space;                       caddr_t ifruv_base;
&space;                       int     ifruv_len;
&space;               }       ifru_vec;
&space;       } ifr_ifru;
};

/* Address */
#define ifr_addr        ifr_ifru.ifru_addr      

/* Other end of p-to-p link */
#define ifr_dstaddr     ifr_ifru.ifru_dstaddr   

/* Broadcast address */
#define ifr_broadaddr   ifr_ifru.ifru_broadaddr 

/* Flags */
#define ifr_flags       ifr_ifru.ifru_flags     

/* Metric */
#define ifr_metric      ifr_ifru.ifru_metric    

/* For use by interface */
#define ifr_data        ifr_ifru.ifru_data      

/* Ethernet address */
#define ifr_enaddr      ifr_ifru.ifru_enaddr    

/* Other interface name */
#define ifr_oname       ifr_ifru.ifru_oname     

/* Statistics */
#define ifr_stats       ifr_ifru.ifru_stats     

/* Trusted IRIX */
#define ifr_base        ifr_ifru.ifru_vec.ifruv_base
#define ifr_len         ifr_ifru.ifru_vec.ifruv_len
</CODE>
<PARAGRAPH>The following call obtains the interface configuration:</PARAGRAPH>
<CODE>
struct ifconf ifc;
char buf[BUFSIZ];

ifc.ifc_len = sizeof (buf);
ifc.ifc_buf = buf;
if (ioctl(s, SIOCGIFCONF, (char *) &amp;ifc) &lt; 0) {
&space;   ...
}
</CODE>
<PARAGRAPH>After this call, <COMMAND>buf</COMMAND> will contain one <COMMAND>ifreq</COMMAND> structure for each network to which the host is connected, and<FILENAME>&space;ifc.ifc_len</FILENAME>&space;will have been modified to reflect the number of bytes used by the <COMMAND>ifreq</COMMAND> structure.</PARAGRAPH>
<PARAGRAPH>Each structure has an associated set of interface flags that tell whether the network corresponding to that interface is up or down, point-to-point or broadcast, and so on. The SIOCGIFFLAGS <INDEXTARGET ID="2.sockets29"><!-- POSTPROCESSDATA: 2.sockets29|ioctls:SIOCGIFFLAGS --><COMMAND>ioctl</COMMAND> retrieves these flags for an interface specified by an <COMMAND>ifreq</COMMAND> structure:</PARAGRAPH>
<CODE>
struct ifreq *ifr;
struct sockaddr dst;

ifr = ifc.ifc_req;
for (n = ifc.ifc_len / sizeof (struct ifreq); --n >= 0;
&space;    ifr++) {
&space;   
&space;   /* Be careful not to use an interface devoted to an
&space;    * address family other than the one intended */
&space;   if (ifr->ifr_addr.sa_family != AF_INET)
&space;       continue;
&space;   if (ioctl(s, SIOCGIFFLAGS, (char *) ifr) &lt; 0) {
&space;       ...
&space;   }
&space;   /*
&space;    * Skip boring cases.
&space;    */
&space;   if ((ifr->ifr_flags &amp; IFF_UP) == 0 ||
&space;       (ifr->ifr_flags &amp; IFF_LOOPBACK) ||
&space;       (ifr->ifr_flags &amp;
&space;        (IFF_BROADCAST | IFF_POINTTOPOINT)) == 0) {
&space;           continue;
&space;   }
</CODE>
<PARAGRAPH>Once you retrieve the flags, retrieve the broadcast address. For broadcast networks, retrieval is done via the SIOCGIFBRDADDR <INDEXTARGET ID="2.sockets30"><!-- POSTPROCESSDATA: 2.sockets30|ioctls:SIOCGIFBRDADDRioctls, SIOCGIFDSTADDR --><COMMAND>ioctl</COMMAND>.&space;For point&ndash;to&ndash;point networks, the address of the destination host is obtained with SIOCGIFDSTADDR:</PARAGRAPH>
<CODE>
if (ifr->ifr_flags &amp; IFF_POINTTOPOINT) {
&space;   if (ioctl(s, SIOCGIFDSTADDR, (char *) ifr) &lt; 0) {
&space;       ...
&space;   }
&space;   bcopy((char *) ifr->ifr_dstaddr, (char *) &amp;dst,
&space;         sizeof (ifr->ifr_dstaddr));
&space;   
} else if (ifr->ifr_flags &amp; IFF_BROADCAST) {
&space;   if (ioctl(s, SIOCGIFBRDADDR, (char *) ifr) &lt; 0) {
&space;       ...
&space;   }
&space;   bcopy((char *) ifr->ifr_broadaddr, (char *) &amp;dst,
&space;         sizeof (ifr->ifr_broadaddr));
}
</CODE>
<PARAGRAPH>After the appropriate <COMMAND>ioctls</COMMAND> get the broadcast or destination address (now in <COMMAND>dst</COMMAND>), use the <FUNCTION>sendto()</FUNCTION> call:</PARAGRAPH>
<CODE>
&space;   sendto(s, buf, buflen, 0, (struct sockaddr *)&amp;dst,
&space;          sizeof (dst));
</CODE>
<PARAGRAPH>In the above loop, one <FUNCTION>sendto()</FUNCTION> occurs for every interface the host is connected to that supports broadcast or point-to-point addressing. For a process to send only broadcast messages on a given network, use code similar to that outlined above, but the loop needs to find the correct destination address.</PARAGRAPH>
<PARAGRAPH>Received broadcast messages contain the sender's address and port, since datagram sockets are bound before a message is allowed to go out.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="88856">IP Multicasting</TITLE><PARAGRAPH>Multicasting is the transmission of an IP datagram to a host group, a set of zero or more hosts identified by a single IP destination address. A multicast datagram is delivered to all members of its destination host group with the same best-efforts reliability as regular unicast IP datagrams; that is, the datagram is not guaranteed to arrive intact at all members of the destination group or in the same order relative to other datagrams.<INDEXTARGET ID="2.sockets31"><!-- POSTPROCESSDATA: 2.sockets31|IP:multicastingmulticasting, IP --></PARAGRAPH>
<PARAGRAPH>The membership of a host group is dynamic; that is, hosts may join and leave groups at any time. There is no restriction on the location or number of members in a host group. A host may be a member of more than one group at a time. A host need not be a member of a group to send datagrams to it.</PARAGRAPH>
<PARAGRAPH>A host group may be permanent or transient. A permanent group has a well-known, administratively assigned IP address. It is the address, not the membership of the group, that is permanent; at any time a permanent group may have any number of members, even zero. Those IP multicast addresses that are not reserved for permanent groups are available for dynamic assignment to transient groups, which exist as long as they have members.</PARAGRAPH>
<PARAGRAPH>In general, a host cannot assume that datagrams sent to any host group address will reach only the intended hosts, or that datagrams received as a member of a transient host group are intended for the recipient. Misdirected delivery must be detected at a level above IP, using higher-level identifiers or authentication tokens. Information transmitted to a host group address should be encrypted or governed by administrative routing controls if the sender is concerned about unwanted listeners.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>This RFC-1112 level-2 implementation of IP multicasting is experimental and subject to change in order to track future BSD UNIX releases. In particular, there may be changes in the way a process overrides the default interface for sending multicast datagrams and for joining multicast groups. This ability to override the default interface is intended mainly for routing daemons; normal applications should not be concerned with specific interfaces. </NOTE>
<PARAGRAPH>IP multicasting is currently supported only on AF_INET sockets of type SOCK_DGRAM and SOCK_RAW, and only on subnetworks for which the interface driver has been modified to support multicasting. The standard Ethernet, FDDI, and SLIP interfaces on the IRIS support multicasting. (Older versions of ENP-10 Ethernet interfaces may require an upgrade; see the <DOCTITLE>IRIX Admin</DOCTITLE> manual set for details.)</PARAGRAPH>
<PARAGRAPH>The next sections describe how to send and receive multicast datagrams.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Sending IP Multicast Datagrams</TITLE><PARAGRAPH>To send a multicast datagram, specify an IP multicast address in the range 224.0.0.0 to 239.255.255.255 as the destination address in a<INDEXTARGET ID="2.sockets32"><!-- POSTPROCESSDATA: 2.sockets32|send IP multicast datagramdatagram:sendIP:multicast datagram, sendtransmit datagram --><FUNCTION>&space;sendto()</FUNCTION> call.</PARAGRAPH>
<PARAGRAPH>The definitions required for the multicast-related socket options are found in <FILENAME>&lt;netinet/in.h></FILENAME>. All IP addresses are passed in network byte order.</PARAGRAPH>
<PARAGRAPH>By default, IP multicast datagrams are sent with a time-to-live (TTL) of 1, which prevents them from being forwarded beyond a single subnetwork. A new socket option allows the TTL for subsequent multicast datagrams to be set to any value from 0 to 255, in order to control the scope of the multicasts:</PARAGRAPH>
<CODE>
u_char ttl;
setsockopt(sock, IPPROTO_IP, IP_MULTICAST_TTL, &amp;ttl,
&space;          sizeof(ttl));
</CODE>
<PARAGRAPH>Multicast datagrams with a TTL of 0 will not be transmitted on any subnetwork but may be delivered locally if the sending host belongs to the destination group and if multicast loopback has not been disabled on the sending socket. Multicast datagrams with a TTL greater than 1 may be delivered to more than one subnetwork if there is at least one multicast router attached to the first-hop subnetwork. To provide meaningful scope control, the multicast routers support the notion of TTL thresholds, which prevent datagrams with less than a certain TTL from traversing certain subnetworks.</PARAGRAPH>
<PARAGRAPH>The thresholds enforce the convention shown in <XREF IDREF="92732" TYPE="TABLE">Table&nbsp;2-3</XREF>.</PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="2-3"><PREFIX>Table 2-3 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="92732">TTL Threshold Convention</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="166"><PARAGRAPH>Scope</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="85"><PARAGRAPH>Initial TTL</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>Restricted to the same host </PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="85"><PARAGRAPH>0</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>Restricted to the same subnetwork </PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="85"><PARAGRAPH>1</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>Restricted to the same site </PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="85"><PARAGRAPH>32</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>Restricted to the same region </PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="85"><PARAGRAPH>64</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>Restricted to the same continent </PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="85"><PARAGRAPH>128</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>Unrestricted </PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="85"><PARAGRAPH>255</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>&ldquo;Sites&rdquo; and &ldquo;regions&rdquo; are not strictly defined, and sites may be further subdivided into smaller administrative units, as a local matter.</PARAGRAPH>
<PARAGRAPH>An application may choose an initial TTL other than one listed in <XREF IDREF="92732" TYPE="TABLE">Table&nbsp;2-3</XREF>. For example, an application might perform an expanding-ring search for a network resource by sending a multicast query, first with a TTL of 0, and then with larger and larger TTLs, until a reply is received, perhaps using the TTL sequence 0, 1, 2, 4, 8, 16, 32.</PARAGRAPH>
<PARAGRAPH>The multicast router <COMMAND>mrouted</COMMAND> (see <REFPAGE>mrouted(1M)</REFPAGE>) refuses to forward any multicast datagram with a destination address between 224.0.0.0 and 224.0.0.255, inclusive, regardless of its TTL. This range of addresses is reserved for the use of routing protocols and other low-level topology discovery or maintenance protocols, such as gateway discovery and group membership reporting.</PARAGRAPH>
<PARAGRAPH>The address 224.0.0.0 is guaranteed not to be assigned to any group, and 224.0.0.1 is assigned to the permanent group of all IP hosts (including gateways). This assignment convention is used to address all multicast hosts on the directly connected network. There is no multicast address (or any other IP address) for all hosts on the total Internet. The addresses of other well-known, permanent groups are published in the &ldquo;Assigned Numbers&rdquo; RFC (<DOCTITLE>Internet Request for Comment 1060</DOCTITLE>).</PARAGRAPH>
<PARAGRAPH>Each multicast transmission is sent from a single network interface, even if the host has more than one multicast-capable interface. (If the host is also serving as a multicast router, a multicast may be <ITALICS>forwarded</ITALICS> to interfaces other than the originating interface, provided that the TTL is greater than 1.) The default interface to be used for multicasting is the primary network interface on the system. A socket option is available to override the default for subsequent transmissions from a given socket:</PARAGRAPH>
<CODE>
struct in_addr addr;
setsockopt(sock, IPPROTO_IP, IP_MULTICAST_IF, &amp;addr,
&space;          sizeof(addr));
</CODE>
<PARAGRAPH>where <ITALICS>addr</ITALICS> is the local IP address of the desired outgoing interface. An address of INADDR_ANY may be used to revert to the default interface. The local IP address of an interface can be obtained via the SIOCGIFCONF <COMMAND>ioctl.</COMMAND> To determine if an interface supports multicasting, fetch the interface flags via the SIOCGIFFLAGS <COMMAND>ioctl</COMMAND> and see if the IFF_MULTICAST flag is set. (Normal applications should not need to use this option; it is intended primarily for multicast routers and other system services specifically concerned with Internet topology.) The SIOCGIFCONF and SIOCGIFFLAGS <COMMAND>ioctl</COMMAND>s are described in <XREF IDREF="37197" TYPE="TITLE">&ldquo;Broadcasting&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>If a multicast datagram is sent to a group to which the sending host itself belongs (on the outgoing interface), a copy of the datagram is, by default, looped back by the IP layer for local delivery. Another socket option gives the sender explicit control over whether or not subsequent datagrams are looped back:</PARAGRAPH>
<CODE>
u_char loop;
setsockopt(sock, IPPROTO_IP, IP_MULTICAST_LOOP, &amp;loop,
&space;          sizeof(loop));
</CODE>
<PARAGRAPH>In this example, <COMMAND>loop</COMMAND> is set to 0 to disable loopback, and set to 1 to enable loopback. This option improves performance for applications that may have no more than one instance on a single host (such as a router daemon) by eliminating the overhead of receiving their own transmissions. In general, <COMMAND>loop </COMMAND>should not be used by applications for which there may be more than one instance on a single host (such as a conferencing program) or for which the sender does not belong to the destination group (such as a time-querying program).</PARAGRAPH>
<PARAGRAPH>A multicast datagram sent with an initial TTL greater than 1 may be delivered to the sending host on a different interface from that on which it was sent if the host belongs to the destination group on that other interface. The loopback control option has no effect on such delivery.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Receiving IP Multicast Datagrams</TITLE><PARAGRAPH>Before a host can receive IP multicast datagrams, it must become a member of one or more IP multicast groups. A process can ask the host to join a multicast group by using this socket option:<INDEXTARGET ID="2.sockets33"><!-- POSTPROCESSDATA: 2.sockets33|receive IP multicast datagramdatagram:receiveIP:multicast datagram, receive --></PARAGRAPH>
<CODE>
struct ip_mreq mreq;
setsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq,
&space;          sizeof(mreq))
</CODE>
<PARAGRAPH><COMMAND>mreq</COMMAND> is defined in this structure:</PARAGRAPH>
<CODE>
struct ip_mreq {
&space;   struct in_addr imr_multiaddr; /*multicast group to join*/
&space;   struct in_addr imr_interface; /*interface to join on*/
}
</CODE>
<PARAGRAPH>Every membership is associated with a single interface, and it is possible to join the same group on more than one interface. <FILENAME>imr_interface</FILENAME> should be INADDR_ANY to choose the default multicast interface or one of the host's local addresses to choose a particular (multicast-capable) interface. Up to IP_MAX_MEMBERSHIPS (currently 20) memberships may be added on a single socket.</PARAGRAPH>
<PARAGRAPH>To drop a membership, use</PARAGRAPH>
<CODE>
struct ip_mreq mreq;
setsockopt(sock, IPPROTO_IP, IP_DROP_MEMBERSHIP, &amp;mreq,
&space;          sizeof(mreq));
</CODE>
<PARAGRAPH>where <ITALICS>mreq</ITALICS> contains the same values as used to add the membership. The memberships associated with a socket are also dropped when the socket is closed or the process holding the socket is killed. However, more than one socket may claim a membership in a particular group, and the host will remain a member of that group until the last claim is dropped.</PARAGRAPH>
<PARAGRAPH>The memberships associated with a socket do not necessarily determine which datagrams are received on that socket. Incoming multicast packets are accepted by the kernel IP layer if any socket has claimed a membership in the destination group of the datagram; however, delivery of a multicast datagram to a particular socket is based on the destination port (or protocol type for raw sockets), just as with unicast datagrams. To receive multicast datagrams sent to a particular port, it is necessary to bind to that local port, leaving the local address unspecified (that is, INADDR_ANY).</PARAGRAPH>
<PARAGRAPH>More than one process may bind to the same SOCK_DGRAM UDP port if the <FUNCTION>bind()</FUNCTION> call is preceded by:</PARAGRAPH>
<CODE>
int on = 1;
setsockopt(sock, SOL_SOCKET, SO_REUSEPORT, &amp;on, sizeof(on));
</CODE>
<PARAGRAPH>In this case, every incoming multicast or broadcast UDP datagram destined to the shared port is delivered to all sockets bound to the port. For backward compatibility reasons, this does not apply to incoming unicast datagrams. Unicast datagrams are never delivered to more than one socket, regardless of how many sockets are bound to the datagram's destination port. SOCK_RAW sockets do not require the SO_REUSEPORT option to share a single IP protocol type.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>A final multicast-related extension is independent of IP: two new <INDEXTARGET ID="2.sockets34"><!-- POSTPROCESSDATA: 2.sockets34|ioctls:SIOCADDMULTIioctls:SIOCDELMULTI --><COMMAND>ioctl</COMMAND>s, SIOCADDMULTI and SIOCDELMULTI, are available to add or delete link-level (for example, Ethernet) multicast addresses accepted by a particular interface. The address to be added or deleted is passed as a <ITALICS>sockaddr</ITALICS> structure of family AF_UNSPEC, within the standard <ITALICS>ifreq</ITALICS> structure.</NOTE>
<PARAGRAPH>These <ITALICS>ioctl</ITALICS>s are used for protocols other than IP and require superuser privileges. A link-level multicast address added via SIOCADDMULTI is not automatically deleted when the socket used to add it goes away; it must be explicitly deleted. It is inadvisable to delete a link-level address that may be in use by IP.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Sample Multicast Program</TITLE><PARAGRAPH>The following program sends or receives multicast packets. If invoked with one argument, it sends a packet containing the current time to an arbitrarily chosen multicast group and UDP port. If invoked with no arguments, it receives and prints these packets. Start it as a sender on just one host and as a receiver on all the other hosts.</PARAGRAPH>
<CODE>
#include &lt;sys/types.h>
#include &lt;sys/socket.h>
#include &lt;netinet/in.h>
#include &lt;arpa/inet.h>
#include &lt;time.h>
#include &lt;stdio.h>

#define EXAMPLE_PORT    6000
#define EXAMPLE_GROUP    "224.0.0.250"

main(argc)
&space;   int argc;
{
&space;   struct sockaddr_in addr;
&space;   int    addrlen, fd, cnt;
&space;   struct ip_mreq mreq;
&space;   char message[50];

&space;   fd = socket(AF_INET, SOCK_DGRAM, 0);
&space;   if (fd &lt; 0) {
&space;       perror("socket");
&space;       exit(1);
&space;   }
&space;   bzero(&amp;addr, sizeof(addr));
&space;   addr.sin_family = AF_INET;
&space;   addr.sin_addr.s_addr = htonl(INADDR_ANY);
&space;   addr.sin_port = htons(EXAMPLE_PORT);
&space;   addrlen = sizeof(addr);
&space;       if (argc > 1) {    /* Send */
&space;       addr.sin_addr.s_addr = inet_addr(EXAMPLE_GROUP);
&space;       while (1) {
&space;           time_t t = time(0);
&space;           sprintf(message, "time is %-24.24s", ctime(&amp;t));
&space;           cnt = sendto(fd, message, sizeof(message), 0,
&space;                        &amp;addr, addrlen);
&space;           if (cnt &lt; 0) {
&space;               perror("sendto");
&space;               exit(1);
&space;           }
&space;           sleep(5);
&space;       }
&space;   } else {        /* Receive */
&space;       if (bind(fd, &amp;addr, sizeof(addr)) &lt; 0) {
&space;           perror("bind");
&space;           exit(1);
&space;       }
&space;       mreq.imr_multiaddr.s_addr = inet_addr(EXAMPLE_GROUP);
&space;       mreq.imr_interface.s_addr = htonl(INADDR_ANY);
&space;       if (setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP,
&space;           &amp;mreq, sizeof(mreq)) &lt; 0) {
&space;           perror("setsockopt mreq");
&space;           exit(1);
&space;       }
&space;       while (1) {
&space;           cnt = recvfrom(fd, message, sizeof(message), 0,
&space;                          &amp;addr, &amp;addrlen);
&space;               if (cnt &lt; 0) {
&space;               perror("recvfrom");
&space;               exit(1);
&space;               } else if (cnt == 0) {
&space;               break;
&space;           }
&space;           printf("%s: message = \"%s\"\n",
&space;                  inet_ntoa(addr.sin_addr), message);
&space;       }
&space;   }
}
</CODE>
</SECTION3>
</SECTION2>
</SECTION1>
</CHAPTER>
