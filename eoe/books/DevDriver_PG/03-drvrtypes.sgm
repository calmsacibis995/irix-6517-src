<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="3"><TITLE><XREFTARGET ID="62332">Device Control Software</TITLE><PARAGRAPH>IRIX provides for two general methods of controlling devices, at the user level and at the kernel level. This chapter describes the architecture of these two software levels and points out the different abilities of each. This is important background material for understanding all types of device control. The chapter covers the following main topics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="88607" TYPE="TITLE">&ldquo;User-Level Device Control&rdquo;</XREF>summarizes five methods of device control for user-initiated processes.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="87778" TYPE="TITLE">&ldquo;Kernel-Level Device Control&rdquo;</XREF> sets the concepts needed to understand kernel-level drivers.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="88607">User-Level Device Control</TITLE><PARAGRAPH>In IRIX terminology, a <INDEXTARGET ID="03-drvrtypes1"><!-- POSTPROCESSDATA: 03-drvrtypes1|driver:user-level --><INDEXTARGET ID="03-drvrtypes2"><!-- POSTPROCESSDATA: 03-drvrtypes2|user-level driver --><INDEXTARGET ID="03-drvrtypes3"><!-- POSTPROCESSDATA: 03-drvrtypes3|user-level process --><INDEXTARGET ID="03-drvrtypes4"><!-- POSTPROCESSDATA: 03-drvrtypes4|driver:types of --><GLOSSARYITEM>user-level</GLOSSARYITEM> process is one that is initiated by a user (possibly the superuser). A user-level process runs in an address space of its own. Except for explicit memory-sharing agreements, a user-level process has no access to the address space of any other process or to the kernel's address space.</PARAGRAPH>
<PARAGRAPH>In particular, a user-level process has no access to physical memory (which includes access to device registers) unless the kernel allows the process to share part of the kernel's address space. (For more on physical memory, see <XREF IDREF="24376" TYPE="TITLE">Chapter&nbsp;1, &ldquo;Physical and Virtual Memory.&rdquo;</XREF>)</PARAGRAPH>
<PARAGRAPH>There are several ways in which a user-level process can control devices, which are summarized in the following topics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="89939" TYPE="TITLE">&ldquo;PCI Mapping Support&rdquo;</XREF> summarizes PIO access to the PCI bus.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="72133" TYPE="TITLE">&ldquo;EISA Mapping Support&rdquo;</XREF> summarizes PIO access to the EISA bus.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="30072" TYPE="TITLE">&ldquo;VME Mapping Support&rdquo;</XREF> summarizes PIO access to the VME bus.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="17051" TYPE="TITLE">&ldquo;User-Level DMA From the VME Bus&rdquo;</XREF> summarizes DMA I/O managed from a user-level process.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="75657" TYPE="TITLE">&ldquo;User-Level Control of SCSI Devices&rdquo;</XREF> summarizes DMA and command access to the SCSI bus.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="25747" TYPE="TITLE">&ldquo;Managing External Interrupts&rdquo;</XREF> summarizes access to the external interrupt ports on Challenge and Onyx systems.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="89939">PCI Mapping Support</TITLE><PARAGRAPH>In systems that support the PCI bus, IRIX contains a kernel-level device driver which supports general-purpose mapping of PCI bus addresses into the address space of a user process (see <XREF IDREF="96208" TYPE="TITLE">&ldquo;Overview of Memory Mapping&rdquo;</XREF>). The kernel-level drivers for specific devices can also provide support for mapping the registers of the devices they control into user process space.</PARAGRAPH>
<PARAGRAPH>You can write a program that maps a portion of the VME bus address space into the program address space. Then you can load and store from device registers directly.</PARAGRAPH>
<PARAGRAPH>For more details of PIO to the PCI bus, see <XREF IDREF="66996" TYPE="TITLE">Chapter&nbsp;4, &ldquo;User-Level Access to Devices.&rdquo;</XREF></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="72133">EISA Mapping Support</TITLE><PARAGRAPH>In the Silicon Graphics Indigo<INDEXTARGET ID="03-drvrtypes5"><!-- POSTPROCESSDATA: 03-drvrtypes5|EISA bus:mapping into user process --><SUPERSCRIPT>2</SUPERSCRIPT> workstation line (including the Indigo<SUPERSCRIPT>2</SUPERSCRIPT> Maximum Impact, Power Indigo<SUPERSCRIPT>2</SUPERSCRIPT>, and Indigo<SUPERSCRIPT>2</SUPERSCRIPT> R10000), IRIX contains a kernel-level device driver that allows a user-level process to map EISA bus addresses into the address space of the user process (see <XREF IDREF="96208" TYPE="TITLE">&ldquo;Overview of Memory Mapping&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>This means that you can write a program that maps a portion of the EISA bus address space into the program address space. Then you can load and store from device registers directly.</PARAGRAPH>
<PARAGRAPH>For more details of PIO to the EISA bus, see <XREF IDREF="66996" TYPE="TITLE">Chapter&nbsp;4, &ldquo;User-Level Access to Devices.&rdquo;</XREF></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="30072">VME Mapping Support</TITLE><PARAGRAPH>In systems that support the VME bus, IRIX contains a kernel-level device driver that supports general-purpose mapping of VME bus addresses into the address space of a user process (see <INDEXTARGET ID="03-drvrtypes6"><!-- POSTPROCESSDATA: 03-drvrtypes6|VME bus:mapping into user process --><XREF IDREF="96208" TYPE="TITLE">&ldquo;Overview of Memory Mapping&rdquo;</XREF>). The kernel-level drivers for specific devices can also provide support for mapping the registers of the devices they control into user process space.</PARAGRAPH>
<PARAGRAPH>You can write a program that maps a portion of the VME bus address space into the program address space. Then you can load and store from device registers directly.</PARAGRAPH>
<PARAGRAPH>For more details of PIO to the VME bus, see <XREF IDREF="66996" TYPE="TITLE">Chapter&nbsp;4, &ldquo;User-Level Access to Devices.&rdquo;</XREF></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="17051">User-Level DMA From the VME Bus</TITLE><PARAGRAPH>The Challenge L, Challenge XL, and Onyx systems and their Power versions contain a DMA engine that manages DMA transfers from VME devices, including VME slave devices that normally cannot do DMA.<INDEXTARGET ID="03-drvrtypes7"><!-- POSTPROCESSDATA: 03-drvrtypes7|VME bus:user-level DMA --></PARAGRAPH>
<PARAGRAPH>The DMA engine in these systems can be programmed directly from code in a user-level process. Software support for this facility is contained in the <VARIABLE>udmalib</VARIABLE> package.</PARAGRAPH>
<PARAGRAPH>For more details of user DMA, see <XREF IDREF="66996" TYPE="TITLE">Chapter&nbsp;4, &ldquo;User-Level Access to Devices&rdquo;</XREF> and the <REFPAGE>udmalib(3)</REFPAGE> reference page.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="75657">User-Level Control of SCSI Devices</TITLE><PARAGRAPH>IRIX contains a special kernel-level device driver whose purpose is to give user-level processes the ability to issue commands and read and write data on the SCSI bus. By using <INDEXTARGET ID="03-drvrtypes8"><!-- POSTPROCESSDATA: 03-drvrtypes8|IRIX functions:<FUNCTION>ioctl()</FUNCTION> --><INDEXTARGET ID="03-drvrtypes9"><!-- POSTPROCESSDATA: 03-drvrtypes9|SCSI bus:user-level access --><FUNCTION>ioctl()</FUNCTION> calls to this driver, a user-level process can interrogate and program devices, and can initiate DMA transfers between buffers in user process memory and devices.</PARAGRAPH>
<PARAGRAPH>The low-level programming used with the <COMMAND>dsreq</COMMAND> device driver is eased by the use of a library of utility functions documented in the <REFPAGE>dslib(3)</REFPAGE> reference page. The source code of the <FILENAME>dslib</FILENAME> library is distributed with IRIX.</PARAGRAPH>
<PARAGRAPH>For more details on user-level SCSI access, see <XREF IDREF="44062" TYPE="TITLE">Chapter&nbsp;5, &ldquo;User-Level Access to SCSI Devices.&rdquo;</XREF></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="25747">Managing External Interrupts</TITLE><PARAGRAPH>The Challenge L, Challenge XL, and Onyx systems and their Power versions have four external-interrupt output jacks and four external-interrupt input jacks on their back panels. Origin2000 systems also support one or more external interrupt inputs and outputs.<INDEXTARGET ID="03-drvrtypes10"><!-- POSTPROCESSDATA: 03-drvrtypes10|external interrupt --></PARAGRAPH>
<PARAGRAPH>In all these systems, the device special file <FILENAME>/dev/ei</FILENAME> represents a device driver that manages access to external interrupt ports.</PARAGRAPH>
<PARAGRAPH>Using <INDEXTARGET ID="03-drvrtypes11"><!-- POSTPROCESSDATA: 03-drvrtypes11|IRIX functions:<FUNCTION>ioctl()</FUNCTION> --><FUNCTION>ioctl()</FUNCTION> calls to this device (see <XREF IDREF="12595" TYPE="TITLE">&ldquo;Overview of Device Control&rdquo;</XREF>), your program can</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>enable and disable the detection of incoming external interrupts</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>set the strobe length of outgoing signals</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>strobe, or set a fixed level, on any of the four output ports</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>In addition, library calls are provided that allow very low-latency detection of an incoming signal.</PARAGRAPH>
<PARAGRAPH>For more information on external interrupt management, see <XREF IDREF="51765" TYPE="TITLE">Chapter&nbsp;6, &ldquo;Control of External Interrupts&rdquo;</XREF> and the <REFPAGE>ei(7)</REFPAGE> reference page.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="87778">Kernel-Level Device Control</TITLE><PARAGRAPH>IRIX supports the conventional UNIX architecture in which a user process uses a kernel service to request a data transfer, and the kernel calls on a device driver to perform the transfer.<INDEXTARGET ID="03-drvrtypes12"><!-- POSTPROCESSDATA: 03-drvrtypes12|driver:types of:kernel-level --><INDEXTARGET ID="03-drvrtypes13"><!-- POSTPROCESSDATA: 03-drvrtypes13|kernel-level driver --></PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="47288">Kinds of Kernel-Level Drivers</TITLE><PARAGRAPH>There are three distinct kinds of kernel-level drivers:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>A <GLOSSARYITEM>character device driver</GLOSSARYITEM> transfers data as a stream of bytes of arbitrary length. A character device driver is invoked when a user process issuing a system function call such as <FUNCTION>read()</FUNCTION> or <FUNCTION>ioctl()</FUNCTION>.<INDEXTARGET ID="03-drvrtypes14"><!-- POSTPROCESSDATA: 03-drvrtypes14|character device --><INDEXTARGET ID="03-drvrtypes15"><!-- POSTPROCESSDATA: 03-drvrtypes15|driver:types of:character --></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A <GLOSSARYITEM>block device driver</GLOSSARYITEM> transfers data in blocks of fixed size. Often a block driver is not called directly to support a user process. User reads and writes are directed to files, and the filesystem code calls the block driver to read or write whole disk blocks. Block drivers are also called for paging operations.<INDEXTARGET ID="03-drvrtypes16"><!-- POSTPROCESSDATA: 03-drvrtypes16|block device --><INDEXTARGET ID="03-drvrtypes17"><!-- POSTPROCESSDATA: 03-drvrtypes17|driver:types of:block --></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A STREAMS driver is not a device driver, but rather can be dynamically installed to operate on the flow of data to and from any character device driver.<INDEXTARGET ID="03-drvrtypes18"><!-- POSTPROCESSDATA: 03-drvrtypes18|driver:types of:STREAMS --></PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Overviews of the operation of STREAMS drivers are found in <XREF IDREF="94967" TYPE="TITLE">Chapter&nbsp;22, &ldquo;STREAMS Drivers.&rdquo;</XREF> The rest of this discussion is on character and block device drivers.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Typical Driver Operations</TITLE><PARAGRAPH>There are five different kinds of operations that a device driver can support:<INDEXTARGET ID="03-drvrtypes19"><!-- POSTPROCESSDATA: 03-drvrtypes19|driver operations --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The open interaction is supported by all drivers; it initializes the connection between a process and a device.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The control operation is supported by character drivers; it allows the user process to modify the connection to the device or to control the device.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A character driver transfers data directly between the device and a buffer in the user process address space.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Memory mapping enables the user process to perform PIO data transfers for itself.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A block driver transfers one or more fixed-size blocks of data between the device and a buffer owned by a filesystem or the memory paging system.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The following topics present a conceptual overview of the relationship between the user process, the kernel, and the kernel-level device driver. The software architecture that supports these interactions is documented in detail in <XREF IDREF="19849" TYPE="TITLE">Part III, &ldquo;Kernel-Level Drivers,&rdquo;</XREF> especially <XREF IDREF="19192" TYPE="TITLE">Chapter&nbsp;7, &ldquo;Structure of a Kernel-Level Driver.&rdquo;</XREF></PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="42814">Overview of Device Open</TITLE><PARAGRAPH>Before a user process can use a kernel-controlled device, the process must open the device as a file. A high-level overview of this process, as it applies to a character device driver, is shown in <INDEXTARGET ID="03-drvrtypes20"><!-- POSTPROCESSDATA: 03-drvrtypes20|IRIX functions:<FUNCTION>open()</FUNCTION> --><INDEXTARGET ID="03-drvrtypes21"><!-- POSTPROCESSDATA: 03-drvrtypes21|driver operations:open --><XREF IDREF="60714" TYPE="GRAPHIC">Figure&nbsp;3-1</XREF>.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="03-device.open.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="3-1"><PREFIX>Figure 3-1 </PREFIX><XREFTARGET ID="60714">Overview of Device Open</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>The steps illustrated in <XREF IDREF="60714" TYPE="GRAPHIC">Figure&nbsp;3-1</XREF> are:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>The user process calls the <FUNCTION>open()</FUNCTION> kernel function, passing the name of a device special file (see <XREF IDREF="91187" TYPE="TITLE">&ldquo;Device Special Files&rdquo;</XREF> and the <REFPAGE>open(2)</REFPAGE> reference page).</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The kernel notes the device major and minor numbers from the inode of the device special file (see <XREF IDREF="87892" TYPE="TITLE">&ldquo;Devices as Files&rdquo;</XREF>). The kernel uses the major device number to select the device driver, and calls the driver's open entry point, passing the minor number and other data.<INDEXTARGET ID="03-drvrtypes22"><!-- POSTPROCESSDATA: 03-drvrtypes22|inode --><INDEXTARGET ID="03-drvrtypes23"><!-- POSTPROCESSDATA: 03-drvrtypes23|major device number:input to open --><INDEXTARGET ID="03-drvrtypes24"><!-- POSTPROCESSDATA: 03-drvrtypes24|minor device number:input to open --></PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The device driver verifies that the device is operable, and prepares whatever is needed to operate it.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The device driver returns a return code to the kernel, which returns either an error code or a file descriptor to the process.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>It is up to the device driver whether the device can be used by only one process at a time, or by more than one process. If the device can support only one user, and is already in use, the driver returns the EBUSY error code.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>open()</FUNCTION> interaction on a block device is similar, except that the operation is initiated from the filesystem code responding to a <FUNCTION>mount()</FUNCTION> request, rather than coming from a user process <FUNCTION>open()</FUNCTION> request (see the <REFPAGE>mount(1)</REFPAGE> reference page).<INDEXTARGET ID="03-drvrtypes25"><!-- POSTPROCESSDATA: 03-drvrtypes25|IRIX commands:<COMMAND>mount</COMMAND> --></PARAGRAPH>
<PARAGRAPH>There is also a <FUNCTION>close()</FUNCTION> interaction so a process can terminate its connection to a device.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="12595">Overview of Device Control</TITLE><PARAGRAPH>After the user process has successfully opened a character device, it can request control operations. <INDEXTARGET ID="03-drvrtypes26"><!-- POSTPROCESSDATA: 03-drvrtypes26|driver operations:ioctl --><XREF IDREF="20032" TYPE="GRAPHIC">Figure&nbsp;3-2</XREF> shows an overview of this operation.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="03-device.control.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="3-2"><PREFIX>Figure 3-2 </PREFIX><XREFTARGET ID="20032">Overview of Device Control</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>The steps illustrated in <XREF IDREF="20032" TYPE="GRAPHIC">Figure&nbsp;3-2</XREF> are:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>The user process calls the <FUNCTION>ioctl()</FUNCTION> kernel function, passing the file descriptor from open and one or more other parameters (see the <REFPAGE>ioctl(2)</REFPAGE> reference page).<INDEXTARGET ID="03-drvrtypes27"><!-- POSTPROCESSDATA: 03-drvrtypes27|IRIX functions:<FUNCTION>ioctl()</FUNCTION> --></PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The kernel uses the major device number to select the device driver, and calls the device driver, passing the minor device number, the request number, and an optional third parameter from <FUNCTION>ioctl()</FUNCTION>.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The device driver interprets the request number and other parameter, notes changes in its own data structures, and possibly issues commands to the device.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The device driver returns an exit code to the kernel, and the kernel (then or later) redispatches the user process.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>Block device drivers are not asked to provide a control interaction. The user process is not allowed to issue <FUNCTION>ioctl()</FUNCTION> for a block device.</PARAGRAPH>
<PARAGRAPH>The interpretation of ioctl request codes and parameters is entirely up to the device driver. For examples of the range of ioctl functions, you might review some reference pages in volume 7, for example, <REFPAGE>termio(7)</REFPAGE>, <REFPAGE>ei(7)</REFPAGE>, and <REFPAGE>arp(7P)</REFPAGE>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Overview of Character Device I/O</TITLE><PARAGRAPH><XREF IDREF="71856" TYPE="GRAPHIC">Figure&nbsp;3-3</XREF> shows a high-level overview of data transfer for a character device driver that uses programmed I/O.<INDEXTARGET ID="03-drvrtypes28"><!-- POSTPROCESSDATA: 03-drvrtypes28|IRIX functions:<FUNCTION>read()</FUNCTION> --><INDEXTARGET ID="03-drvrtypes29"><!-- POSTPROCESSDATA: 03-drvrtypes29|IRIX functions:<FUNCTION>write()</FUNCTION> --><INDEXTARGET ID="03-drvrtypes30"><!-- POSTPROCESSDATA: 03-drvrtypes30|driver operations:read --><INDEXTARGET ID="03-drvrtypes31"><!-- POSTPROCESSDATA: 03-drvrtypes31|driver operations:write --></PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="03-kernel.pio.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="3-3"><PREFIX>Figure 3-3 </PREFIX><XREFTARGET ID="71856">Overview of Programmed Kernel I/O</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>The steps illustrated in <XREF IDREF="71856" TYPE="GRAPHIC">Figure&nbsp;3-3</XREF> are:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>The user process invokes the <FUNCTION>read()</FUNCTION> kernel function for the file descriptor returned by <FUNCTION>open()</FUNCTION> (see the <REFPAGE>read(2)</REFPAGE> and <REFPAGE>write(2)</REFPAGE> reference pages).</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The kernel uses the major device number to select the device driver, and calls the device driver, passing the minor device number and other information.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The device driver directs the device to operate by storing into its registers in physical memory.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The device driver retrieves data from the device registers and uses a kernel function to store the data into the buffer in the address space of the user process.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The device driver returns to the kernel, which (then or later) dispatches the user process.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>The operation of <FUNCTION>write()</FUNCTION> is similar. A kernel-level driver that uses programmed I/O is conceptually simple since it is basically a subroutine of the kernel.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="96208">Overview of Memory Mapping</TITLE><PARAGRAPH>It is possible to allow the user process to perform I/O directly, by mapping the physical addresses of device registers into the address space of the user process. <INDEXTARGET ID="03-drvrtypes32"><!-- POSTPROCESSDATA: 03-drvrtypes32|IRIX functions:<FUNCTION>mmap()</FUNCTION> --><INDEXTARGET ID="03-drvrtypes33"><!-- POSTPROCESSDATA: 03-drvrtypes33|driver operations:mmap --><XREF IDREF="53081" TYPE="GRAPHIC">Figure&nbsp;3-4</XREF> shows a high-level overview of this interaction.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="03-memory.mapping.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="3-4"><PREFIX>Figure 3-4 </PREFIX><XREFTARGET ID="53081">Overview of Memory Mapping</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>The steps illustrated in <XREF IDREF="53081" TYPE="GRAPHIC">Figure&nbsp;3-4</XREF> are:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>The user process calls the <FUNCTION>mmap()</FUNCTION> kernel function, passing the file descriptor from open and various other parameters (see the <REFPAGE>mmap(2)</REFPAGE> reference page).</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The kernel uses the major device number to select the device driver, and calls the device driver, passing the minor device number and certain other parameters from <FUNCTION>mmap()</FUNCTION>.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The device driver validates the request and uses a kernel function to map the necessary range of physical addresses into the address space of the user process.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The device driver returns an exit code to the kernel, and the kernel (then or later) redispatches the user process.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The user process accesses data in device registers by accessing the virtual address returned to it from the <FUNCTION>mmap()</FUNCTION> call.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>Memory mapping can be supported only by a character device driver. (When a user process applies <FUNCTION>mmap()</FUNCTION> to an ordinary disk file, the filesystem maps the file into memory. The filesystem may call a block driver to transfer pages of the file in and out of memory, but to the driver this is no different from any other read or write call.)</PARAGRAPH>
<PARAGRAPH>Memory mapping by a character device driver has the purpose of making device registers directly accessible to the process as memory addresses. A memory-mapping character device driver is very simple; it needs to support only <FUNCTION>open()</FUNCTION>, <FUNCTION>mmap()</FUNCTION>, and <FUNCTION>close()</FUNCTION> interactions. Data throughput can be higher when PIO is performed in the user process, since the overhead of the <FUNCTION>read()</FUNCTION> and <FUNCTION>write()</FUNCTION> system calls is avoided.</PARAGRAPH>
<PARAGRAPH>Silicon Graphics device drivers for the VME and EISA buses support memory mapping. This enables user-level processes to perform PIO to devices on these buses. Character drivers for the PCI bus are allowed to support memory mapping.</PARAGRAPH>
<PARAGRAPH>It is possible to write a kernel-level driver that only maps memory, and controls no device at all. Such drivers are called <INDEXTARGET ID="03-drvrtypes34"><!-- POSTPROCESSDATA: 03-drvrtypes34|pseudo-device driver --><INDEXTARGET ID="03-drvrtypes35"><!-- POSTPROCESSDATA: 03-drvrtypes35|driver:types of:pseudo-device --><GLOSSARYITEM>pseudo-device</GLOSSARYITEM> drivers. For examples of psuedo-device drivers, see the <REFPAGE>prf(7)</REFPAGE> and <REFPAGE>imon(7)</REFPAGE> reference pages. </PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Overview of Block I/O</TITLE><PARAGRAPH>Block devices and block device drivers normally use DMA (see <INDEXTARGET ID="03-drvrtypes36"><!-- POSTPROCESSDATA: 03-drvrtypes36|driver operations:DMA --><INDEXTARGET ID="03-drvrtypes37"><!-- POSTPROCESSDATA: 03-drvrtypes37|Direct Memory Access (DMA) --><INDEXTARGET ID="03-drvrtypes38"><!-- POSTPROCESSDATA: 03-drvrtypes38|IRIX functions:<FUNCTION>write()</FUNCTION> --><INDEXTARGET ID="03-drvrtypes39"><!-- POSTPROCESSDATA: 03-drvrtypes39|IRIX functions:<FUNCTION>read()</FUNCTION> --><XREF IDREF="91137" TYPE="TITLE">&ldquo;Direct Memory Access&rdquo;</XREF>). With DMA, the driver can avoid the time-consuming process of transferring data between memory and device registers. <XREF IDREF="89791" TYPE="GRAPHIC">Figure&nbsp;3-5</XREF> shows a high-level overview of a DMA transfer.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="03-dma.i.o.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="3-5"><PREFIX>Figure 3-5 </PREFIX><XREFTARGET ID="89791">Overview of DMA I/O</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>The steps illustrated in <XREF IDREF="89791" TYPE="GRAPHIC">Figure&nbsp;3-5</XREF> are:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>The user process invokes the <FUNCTION>read()</FUNCTION> kernel function for a normal file descriptor (not necessarily a device special file). The filesystem (not shown) asks for a block of data.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The kernel uses the major device number to select the device driver, and calls the device driver, passing the minor device number and other information.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The device driver uses kernel functions to create a DMA map that describes the buffer in physical memory; then programs the device with target addresses by storing into its registers.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The device driver returns to the kernel after telling it to put to sleep the user process that called the driver.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The device itself stores the data to the physical memory locations that represent the buffer in the user process address space. While this is going on, the kernel may dispatch other processes.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>When the device presents a hardware interrupt, the kernel invokes the device driver. The driver notifies the kernel that the user process can now resume execution. It resumes in the filesystem code, which moves the requested data into the user process buffer.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>DMA is fundamentally asynchronous. There is no necessary timing relation between the operation of the device performing its operation and the operation of the various user processes. A DMA device driver has a more complex structure because it must deal with such issues as</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>making a DMA map and programming a device to store into a buffer in physical memory</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>blocking a user process, and waking it up when the operation is complete</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>handling interrupts from the device</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the possibility that requests from other processes can occur while the device is operating</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the possibility that a device interrupt can occur while the driver is handling a request</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The reward for the extra complexity of DMA is the possibility of much higher performance. The device can store or read data from memory at its maximum rated speed, while other processes can execute in parallel.</PARAGRAPH>
<PARAGRAPH>A DMA driver must be able to cope with the possibility that it can receive several requests from different processes while the device is busy handling one operation. This implies that the driver must implement some method of queuing requests until they can be serviced in turn.</PARAGRAPH>
<PARAGRAPH>The mapping between physical memory and process address space can be complicated. For example, the buffer can span multiple pages, and the pages need not be in contiguous locations in physical memory. If the device does not support <GLOSSARYITEM>scatter/gather</GLOSSARYITEM> operations, the device driver has to program a separate DMA operation for each page or part of a page&mdash;or else has to obtain a contiguous buffer in the kernel address space, do the I/O from that buffer, and copy the data from that buffer to the process buffer. When the device supports scatter/gather, it can be programmed with the starting addresses and lengths of each page in the buffer, and read and write into them in turn before presenting a single interrupt. </PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="17558">Upper and Lower Halves</TITLE><PARAGRAPH>When a device can produce hardware interrupts, its kernel-level device driver has two distinct logical parts, called the &ldquo;upper half&rdquo; and the &ldquo;lower half&rdquo; (although the upper &ldquo;half&rdquo; is usually much more than half the code).<INDEXTARGET ID="03-drvrtypes40"><!-- POSTPROCESSDATA: 03-drvrtypes40|upper half of driver --><INDEXTARGET ID="03-drvrtypes41"><!-- POSTPROCESSDATA: 03-drvrtypes41|driver:lower half --><INDEXTARGET ID="03-drvrtypes42"><!-- POSTPROCESSDATA: 03-drvrtypes42|driver:upper half --></PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Driver Upper Half</TITLE><PARAGRAPH>The upper half of a driver comprises all the parts that are invoked as a result of user process calls: the driver entry points that execute in response to <FUNCTION>open()</FUNCTION>, <FUNCTION>close()</FUNCTION>, <FUNCTION>ioctl()</FUNCTION>, <FUNCTION>mmap()</FUNCTION>, <FUNCTION>read()</FUNCTION> and <FUNCTION>write()</FUNCTION>.</PARAGRAPH>
<PARAGRAPH>These parts of the driver are always called on behalf of a specific process. This is referred to as &ldquo;having user context,&rdquo; which means that the entry point is executed under the identity of a specific process. In effect, the driver code is a subroutine of the user process.</PARAGRAPH>
<PARAGRAPH>Upper half code can request kernel services that can be delayed, or &ldquo;sleep.&rdquo; For example, code in the upper half of a driver can call <INDEXTARGET ID="03-drvrtypes43"><!-- POSTPROCESSDATA: 03-drvrtypes43|IRIX functions:<FUNCTION>kmem_alloc()</FUNCTION> --><FUNCTION>kmem_alloc()</FUNCTION> to request memory in kernel space, and can specify that if memory is not available, the driver can sleep until memory is available. Also, code in the upper half can wait on a semaphore until some event occurs, or can seize a lock knowing that it may have to sleep until the lock is released.</PARAGRAPH>
<PARAGRAPH>In each case, the entire kernel does not &ldquo;sleep.&rdquo; The kernel marks the user process as blocked, and dispatches other processes to run. When the blocking condition is removed&mdash;when memory is available, the semaphore is posted, or the lock is released&mdash;the driver is scheduled for execution and resumes.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Driver Lower Half</TITLE><PARAGRAPH>The lower half of a driver comprises the code that is called to respond to a hardware interrupt. An interrupt can occur at almost any time, including large parts of the time when the kernel is executing other services, including driver upper and lower halves.<INDEXTARGET ID="03-drvrtypes44"><!-- POSTPROCESSDATA: 03-drvrtypes44|interrupt --><INDEXTARGET ID="03-drvrtypes45"><!-- POSTPROCESSDATA: 03-drvrtypes45|driver:lower half --><INDEXTARGET ID="03-drvrtypes46"><!-- POSTPROCESSDATA: 03-drvrtypes46|lower half of driver --></PARAGRAPH>
<PARAGRAPH>The kernel is not in a known state when executing a driver lower half, and there is no process context. In conventional UNIX systems and in previous versions of IRIX, the lack of user context meant that the lower-half code could not use any kernel service that could sleep. Because of this restriction, you will find that the reference pages for driver kernel services always state whether the service can sleep or not&mdash;a service that might sleep could never be called from an interrupt handler.</PARAGRAPH>
<PARAGRAPH>Starting with IRIX       6.4, the IRIX kernel is threaded; that is, all kernel code executes under a thread identity. When it is time to handle an interrupt, a kernel thread calls the driver's interrupt handler code. In general this makes very little difference to the design of a device driver, but it does mean that the driver lower half has an identity that can sleep. In other words, starting with IRIX       6.4, there is no restriction on what kernel services you can call from driver lower-half code.</PARAGRAPH>
<PARAGRAPH>In all systems, an interrupt handler should do as little as possible and do it as quickly as possible. An interrupt handler will typically get the device status; store it where the top-half code expects it; possibly post a semaphore to release a blocked user process; and possibly start the next I/O operation if one is waiting.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Relationship Between Halves</TITLE><PARAGRAPH>Each half has its proper kind of work. In general terms, the upper half performs all validation and preparation, including allocating and deallocating memory and copying data between address spaces. It initiates the first device operation of a series and queues other operations. Then it waits on a semaphore.</PARAGRAPH>
<PARAGRAPH>The lower half verifies the correct completion of an operation. If another operation is queued, it initiates that operation. Then it posts the semaphore to awaken the upper half, and exits.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Layered Drivers</TITLE><PARAGRAPH>IRIX allows for &ldquo;layered&rdquo; device drivers, in which one driver operates the actual hardware and the driver at the higher layer presents the programming interface. This approach is implemented for SCSI devices: actual management of the SCSI bus is delegated to a set of Host Adapter drivers. Drivers for particular kinds of SCSI devices call the Host Adapter driver through an indirect table to execute SCSI commands. SCSI drivers and Host Adapter drivers are discussed in detail in <INDEXTARGET ID="03-drvrtypes47"><!-- POSTPROCESSDATA: 03-drvrtypes47|layered driver --><INDEXTARGET ID="03-drvrtypes48"><!-- POSTPROCESSDATA: 03-drvrtypes48|driver:types of:layered --><XREF IDREF="33977" TYPE="TITLE">Chapter&nbsp;16, &ldquo;SCSI Device Drivers.&rdquo;</XREF></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="37666">Combined Block and Character Drivers</TITLE><PARAGRAPH>A block device driver is called indirectly, from the filesystem, and it is not allowed to support the <INDEXTARGET ID="03-drvrtypes49"><!-- POSTPROCESSDATA: 03-drvrtypes49|block device:combined with character --><INDEXTARGET ID="03-drvrtypes50"><!-- POSTPROCESSDATA: 03-drvrtypes50|character device:combined with block --><FUNCTION>ioctl()</FUNCTION> entry point. In some cases, block devices can also be thought of as character devices. For example, a block device might return a string of diagnostic information, or it might be sensitive to dynamic control settings.</PARAGRAPH>
<PARAGRAPH>It is possible to support <ITALICS>both</ITALICS> block and character access to a device: block access to support filesystem operations, and character access in order to allow a user process (typically one started by a system administrator) to read, write, or control the device directly.</PARAGRAPH>
<PARAGRAPH>For example, the Silicon Graphics disk device drivers support both block and character access to disk devices. This is why you can find every disk device represented as a block device in the <FILENAME>/dev/dsk</FILENAME> directory and again as a character device in <FILENAME>/dev/rdsk</FILENAME> (&ldquo;r&rdquo; for &ldquo;raw,&rdquo; meaning character devices).</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Drivers for Multiprocessors</TITLE><PARAGRAPH>All but a few Silicon Graphics computers have multiple CPUs that execute concurrently. The CPUs share access to the single main memory, including a single copy of the kernel address space. In principle, all CPUs can execute in the kernel code simultaneously. In principle, the upper half of a device driver could be entered simultaneously by as many different processes are there are CPUs in the system (up to 36 in a Challenge or Onyx system).<INDEXTARGET ID="03-drvrtypes51"><!-- POSTPROCESSDATA: 03-drvrtypes51|multiprocessor:drivers for --></PARAGRAPH>
<PARAGRAPH>A device driver written for a uniprocessor system cannot tolerate concurrent execution by multiple CPUs. For example, a uniprocessor driver has scalar variables whose values would be destroyed if two or more processes updated them concurrently.</PARAGRAPH>
<PARAGRAPH>In versions previous to IRIX       6.4, IRIX made special provision to support uniprocessor character drivers in multiprocessors. It forced a uniprocessor driver to use only CPU 0 to execute calls to upper-half code. This ensured that at most one process executed in any upper half at one time. And it forced interrupts for these drivers to execute on CPU 0. These policies had a detrimental effect on driver and system performance, but they allowed the drivers to work.<INDEXTARGET ID="03-drvrtypes52"><!-- POSTPROCESSDATA: 03-drvrtypes52|multiprocessor:uniprocessor drivers use CPU 0 --></PARAGRAPH>
<PARAGRAPH>Beginning with IRIX       6.4, there is no special provision for uniprocessor drivers in multiprocessor systems. You can write a uniprocessor-only driver and use it on a uniprocessor workstation but you cannot use the same driver design on a multiprocessor.</PARAGRAPH>
<PARAGRAPH>It is not difficult to design a kernel-level driver to execute safely in any CPU of a multiprocessor. Each critical data object must be protected by a lock or semaphore, and particular techniques must be used to coordinate between the upper and lower halves. These techniques are discussed in <XREF IDREF="32791" TYPE="TITLE">&ldquo;Designing for Multiprocessor Use&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>When you have made a driver multiprocessor-safe, you compile it with a particular flag value that IRIX recognizes. For example, drivers are sometimes compiled for Origin2000 systems with the <CMDLINEOPT>-DSN</CMDLINEOPT> and <CMDLINEOPT>-DSN0</CMDLINEOPT> flags. Multiprocessor-safe drivers work properly on uniprocessor systems with very little, if any, extra overhead.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="27851">Loadable Drivers</TITLE><PARAGRAPH>Some drivers are needed whenever the system is running, but others are needed only occasionally. IRIX allows you to create a kernel-level device driver or STREAMS driver that is not loaded at boot time, but only later when it is needed.<INDEXTARGET ID="03-drvrtypes53"><!-- POSTPROCESSDATA: 03-drvrtypes53|loadable driver --><INDEXTARGET ID="03-drvrtypes54"><!-- POSTPROCESSDATA: 03-drvrtypes54|driver:types of:loadable --></PARAGRAPH>
<PARAGRAPH>A loadable driver has the same purposes as a nonloadable one, and uses the same interfaces to do its work. A loadable driver can be configured for automatic loading when its device is opened. Alternatively it can be loaded on command using the <INDEXTARGET ID="03-drvrtypes55"><!-- POSTPROCESSDATA: 03-drvrtypes55|IRIX commands:<COMMAND>ml</COMMAND> --><FILENAME>ml</FILENAME> program (see the <REFPAGE>ml(1)</REFPAGE> and <REFPAGE>mload(4)</REFPAGE> reference pages).</PARAGRAPH>
<PARAGRAPH>A loadable driver remains in memory until its device is no longer in use, or until the administrator uses <COMMAND>ml</COMMAND> to unload it. A loadable driver remains in memory indefinitely, and cannot be unloaded, unless it provides a <VARIABLE>pfx</VARIABLE><FUNCTION>unload()</FUNCTION> entry point (see <XREF IDREF="57773" TYPE="TITLE">&ldquo;Entry Point unload()&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>There are some small differences in the way a loadable driver is compiled and configured (see <XREF IDREF="54976" TYPE="TITLE">&ldquo;Configuring a Loadable Driver&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>One operational difference is that a loadable driver is not available in the miniroot, the standalone system administration environment used for emergency maintenance. If a driver might be required in the miniroot, it can be made nonloadable, or it can be configured for &ldquo;autoregistration&rdquo; (see <INDEXTARGET ID="03-drvrtypes56"><!-- POSTPROCESSDATA: 03-drvrtypes56|loadable driver:not in miniroot --><INDEXTARGET ID="03-drvrtypes57"><!-- POSTPROCESSDATA: 03-drvrtypes57|miniroot:no loadable drivers --><XREF IDREF="88940" TYPE="TITLE">&ldquo;Registration&rdquo;</XREF>). </PARAGRAPH>
<PARAGRAPH></PARAGRAPH>
</SECTION2>
</SECTION1>
</CHAPTER>
