<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="18"><TITLE><XREFTARGET ID="27909">EISA Device Drivers</TITLE><PARAGRAPH>The EISA (Extended Industry Standard Architecture) bus is supported by the Silicon Graphics Indigo<INDEXTARGET ID="17-eisa1"><!-- POSTPROCESSDATA: 17-eisa1|driver:types of:EISA bus --><INDEXTARGET ID="17-eisa2"><!-- POSTPROCESSDATA: 17-eisa2|EISA bus --><SUPERSCRIPT>2</SUPERSCRIPT>, POWER Indigo<SUPERSCRIPT>2</SUPERSCRIPT>, and Indigo<SUPERSCRIPT>2</SUPERSCRIPT> Maximum IMPACT systems. This chapter contains the following topics related to support for the EISA bus:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="72073" TYPE="TITLE">&ldquo;The EISA Bus in Silicon Graphics Systems&rdquo;</XREF> gives an overview of the EISA bus features and implementation.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="35170" TYPE="TITLE">&ldquo;Kernel Functions for EISA Support&rdquo;</XREF> discusses the kernel functions that are specifically used by EISA device drivers.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="74912" TYPE="TITLE">&ldquo;Sample EISA Driver Code&rdquo;</XREF> displays a complete character driver for an EISA device.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<NOTE><PREFIX>Note</PREFIX>Often it is most practical to control an EISA device through programmed I/O from a user-level process. For information on PIO, turn to <XREF IDREF="93811" TYPE="TITLE">&ldquo;EISA Programmed I/O&rdquo;</XREF> after reading <XREF IDREF="72073" TYPE="TITLE">&ldquo;The EISA Bus in Silicon Graphics Systems&rdquo;</XREF>. For information on the general architecture of a kernel-level device driver, see <XREF IDREF="19849" TYPE="TITLE">Part III, &ldquo;Kernel-Level Drivers.&rdquo;</XREF></NOTE>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="72073">The EISA Bus in Silicon Graphics Systems</TITLE><PARAGRAPH>The EISA (Extended Industry Standard Architecture) bus is an enhancement of the ISA (Industry Standard Architecture) bus standard originally developed by IBM.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>EISA Bus Overview</TITLE><PARAGRAPH>EISA is backward compatible with ISA, but expands the ISA data bus from 16 bits to 32&nbsp;bits, and provides 23 more address lines and 16 more indicator and control lines. The EISA bus supports the following features:<INDEXTARGET ID="17-eisa3"><!-- POSTPROCESSDATA: 17-eisa3|EISA bus:overview --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>all ISA transfers</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>bus master devices</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>burst-mode DMA transfers</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>32-bit data and address paths</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>peer-to-peer card communication</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>For detailed information on EISA-bus protocols, electrical specifications, and operation, see the standards documents (<XREF IDREF="39610" TYPE="TITLE">&ldquo;Standards Documents&rdquo;</XREF>). <XREF IDREF="54463" TYPE="GRAPHIC">Figure&nbsp;18-1</XREF> shows the high-level design of the EISA attachment in the Indigo<SUPERSCRIPT>2</SUPERSCRIPT> architecture.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="17-overview.eisa.bus.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="18-1"><PREFIX>Figure 18-1 </PREFIX><XREFTARGET ID="54463">High-Level Overview of EISA Bus in Indigo<SUPERSCRIPT>2</SUPERSCRIPT>&space;</CAPTION>
</FIGURE>
</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>EISA Request Arbitration</TITLE><PARAGRAPH>EISA provides server DMA channels arranged into two channel groups (channels 0-3 and channels 5-7) for priority resolution. Silicon Graphics uses the rotating scheme described in the EISA specification. Although the channels rotate in this scheme, channels 5-7 receive more cycles, in general, than channels 0-3.<INDEXTARGET ID="17-eisa4"><!-- POSTPROCESSDATA: 17-eisa4|EISA bus:request arbitration --></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="63814">EISA Interrupts</TITLE><PARAGRAPH>The EISA bus supports 11 edge-triggerable or level-triggerable interrupts. IRQ0&ndash;IRQ2, IRQ8, and IRQ13 are reserved for internal functions and are not available to EISA cards. The remaining 11 interrupt lines (IRQ3&ndash;IRQ7, IRQ9&ndash;IRQ12, IRQ14, IRQ15) can be generated by EISA cards. Multiple cards can use one IRQ level, so long as they use the same triggering method. <INDEXTARGET ID="17-eisa5"><!-- POSTPROCESSDATA: 17-eisa5|EISA bus:interrupts --></PARAGRAPH>
<PARAGRAPH>All EISA-generated interrupts are transmitted to a single interrupt level on the Silicon Graphics CPU (see <XREF IDREF="21241" TYPE="TITLE">&ldquo;Interrupt Priority Scheduling&rdquo;</XREF>).</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>EISA Data Transfers</TITLE><PARAGRAPH>The EISA bus supports 8-bit, 16-bit, and 32-bit data transfers through direct CPU access (PIO) as well as DMA initiated by a bus-master card or the on-board DMA hardware.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>EISA Address Spaces</TITLE><PARAGRAPH>The EISA-bus address space is divided into I/O address space and memory address space. On the EISA bus, accesses to memory and to I/O are distinguished by having different bus cycle protocols. The MIPS architecture has only one type of memory access, so in the Silicon Graphics systems, EISA I/O space and memory space are assigned separate ranges of physical addresses. The EISA Interface Unit (see <INDEXTARGET ID="17-eisa6"><!-- POSTPROCESSDATA: 17-eisa6|EISA bus:address spaces --><XREF IDREF="54463" TYPE="GRAPHIC">Figure&nbsp;18-1</XREF>) decodes the address ranges and causes the Intel 82350 bus control to issue the appropriate bus cycle type, I/O or memory.</PARAGRAPH>
<PARAGRAPH>The I/O address space comprises a sequence of 4&nbsp;KB page, one for each bus slot. The first page, slot 0, corresponds to the registers of the Intel 82350 chip set. The pages for slots 1-4 correspond to the four accessible slots in the Indigo<SUPERSCRIPT>2</SUPERSCRIPT> and Challenge&nbsp;M chassis (see <XREF IDREF="90785" TYPE="TITLE">&ldquo;Available Card Slots&rdquo;</XREF>).</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="49622">EISA Locked Cycles</TITLE><PARAGRAPH>The EISA bus architecture provides a signal, LOCK*, which allows a card (or the processor, in an Intel architecture system) to lock bus access so as to perform one or more atomic updates.<INDEXTARGET ID="17-eisa7"><!-- POSTPROCESSDATA: 17-eisa7|EISA bus:locked cycles --></PARAGRAPH>
<PARAGRAPH>The Silicon Graphics hardware implementation of the EISA bus is bridged onto the GIO bus, which does not support a locked cycle. The general form of locked bus cycles is not supported in the Silicon Graphics implementation of EISA. An EISA card cannot lock the bus nor can software in the IRIX kernel lock the EISA bus.</PARAGRAPH>
<PARAGRAPH>A device driver in the IRIX kernel can perform a software-controlled read-modify-write cycle, as on a VME bus, using the <FUNCTION>pio_*_rmw()</FUNCTION> kernel functions. See (<XREF IDREF="91021" TYPE="TITLE">&ldquo;Using the PIO Map in Functions&rdquo;</XREF>). This function ensures that no other software accesses the EISA bus during the read-modify-write operation.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>EISA Byte Ordering</TITLE><PARAGRAPH>An important implementation detail of the EISA bus is that it uses the Intel convention of &ldquo;little-endian&rdquo; byte ordering, in which the least significant byte of a halfword or word is in the lowest address. The Silicon Graphics CPU uses &ldquo;big-endian&rdquo; ordering, with the most significant byte first. Hence data exchanged with the EISA bus often needs to be reordered before use.<INDEXTARGET ID="17-eisa8"><!-- POSTPROCESSDATA: 17-eisa8|EISA bus:byte order --></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>EISA Product Identifier </TITLE><PARAGRAPH>EISA expansion boards, embedded devices, and system boards have a four-byte product identifier (ID) that can be read from I/O port addresses 0x<INDEXTARGET ID="17-eisa9"><!-- POSTPROCESSDATA: 17-eisa9|EISA bus:product identifier --><VARIABLE>s</VARIABLE>C80 through 0x<VARIABLE>s</VARIABLE>C83 in the card's I/O address space, where <VARIABLE>s</VARIABLE> is the offset of the card slot. For example, the slot 1 product ID can be read as a 4-byte value from I/O port addresses 0x1C80. This value can be tested in an <VARIABLE>exprobe</VARIABLE> parameter of the VECTOR line during system boot (see <XREF IDREF="41502" TYPE="TITLE">&ldquo;Configuring IRIX&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>The first two bytes (0x<VARIABLE>s</VARIABLE>C80 and 0x<VARIABLE>s</VARIABLE>C81) contain a compressed representation of the manufacturer code. The manufacturer code is a three-character code (uppercase ASCII characters in the range of A to Z) chosen by the manufacturer and registered with the standard (see <XREF IDREF="39610" TYPE="TITLE">&ldquo;Standards Documents&rdquo;</XREF>). The manufacturer code &ldquo;ISA&rdquo; is used to indicate a generic ISA adapter.</PARAGRAPH>
<PARAGRAPH><XREF IDREF="22243" TYPE="GRAPHIC">Figure&nbsp;18-2</XREF> summarizes the contents of the EISA manufacturer ID value.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="17-eisa.mfid.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="18-2"><PREFIX>Figure 18-2 </PREFIX><XREFTARGET ID="22243">Encoding of the EISA Manufacturer ID</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>The three-character manufacturer code is compressed into three 5-bit values so that it can be incorporated into the two I/O bytes at 0x<VARIABLE>s</VARIABLE>C80 and 0x<VARIABLE>s</VARIABLE>C81. The compression procedure is as follows:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Find the hexadecimal ASCII value for each letter:</PARAGRAPH>
<PARAGRAPH>ASCII for &ldquo;A&rdquo;-&ldquo;Z&rdquo;: &ldquo;A&rdquo; = 0x41, &ldquo;Z&rdquo; = 0x5a</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Subtract 0x40 from each ASCII value:</PARAGRAPH>
<PARAGRAPH>Compressed &ldquo;A&rdquo; = 0x41-0x40 = 0x01 = 0000 0001&lbreak;Compressed &ldquo;Z&rdquo; = 0x5a-0x40 = 0x1A = 0001 1010</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Discard leading 0-bits, retaining the five least significant bits of each letter:</PARAGRAPH>
<PARAGRAPH>Compressed &ldquo;A&rdquo; = 00001. Compressed &ldquo;Z&rdquo; = 11010</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Compressed code = concatenate &ldquo;0&rdquo; and the three 5-bit values:</PARAGRAPH>
<PARAGRAPH>&ldquo;AZA&rdquo; = 0&nbsp;00001&nbsp;11010&nbsp;00001 </PARAGRAPH>
</LIST>
</ORDEREDLIST>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE>EISA Support in Indigo<SUPERSCRIPT>2</SUPERSCRIPT> and Challenge M Series</TITLE><PARAGRAPH>One or more EISA cards can be plugged into an Indigo<SUPERSCRIPT>2</SUPERSCRIPT> series workstation, or into a Challenge M system (which uses the identical chassis). Any EISA-conforming card can be plugged into an available slot. EISA devices can be used as block devices or character devices, but they cannot be used as boot devices.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="90785">Available Card Slots</TITLE><PARAGRAPH>The Indigo2 series has four peripheral card slots that accept graphics adapters, EISA cards, or GIO cards in any combination. Graphics cards are available that use one, two, or three slots, resulting in the following combinations:<INDEXTARGET ID="17-eisa10"><!-- POSTPROCESSDATA: 17-eisa10|EISA bus:card slots --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>With Extreme graphics installed, one slot is available for use by an EISA card.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>With XZ graphics installed, two slots are used by the graphics, and two are available for EISA cards. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The XL graphics uses only one slot, so up to three EISA cards can be accommodated.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The Challenge&nbsp;M system, having no graphics adapter, has four available slots.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>EISA Address Mapping</TITLE><PARAGRAPH>The pages of EISA I/O address space are mapped to physical addresses 0x0001&nbsp;0000 (slot 1) through 0x0004&nbsp;0000 (slot 4). The 112&nbsp;MB of EISA memory address space is mapped to physical addresses between 0x000A&nbsp;0000 and 0x06FF&nbsp;FFFF. Addresses in these ranges can be mapped into the kernel address space for PIO or for DMA (see <INDEXTARGET ID="17-eisa11"><!-- POSTPROCESSDATA: 17-eisa11|memory address:physical --><INDEXTARGET ID="17-eisa12"><!-- POSTPROCESSDATA: 17-eisa12|EISA bus:address mapping --><XREF IDREF="35170" TYPE="TITLE">&ldquo;Kernel Functions for EISA Support&rdquo;</XREF>).</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="21241">Interrupt Priority Scheduling</TITLE><PARAGRAPH>The EISA architecture associates interrupt priority with the IRQ level, from IRQ0 to IRQ15. In Silicon Graphics systems, all EISA interrupts are channeled into one CPU interrupt level. The priority of this CPU interrupt is below that of the clock and at the same level as on-board devices. When multiple EISA interrupts arrive, they are serviced in their EISA-bus priority order. When the CPU receives an EISA-bus interrupt, it responds to each interrupt level in IRQ priority order (lower number first). For each interrupt level, the IRIX kernel calls one or more interrupt service functions that have been established by device drivers (see <INDEXTARGET ID="17-eisa13"><!-- POSTPROCESSDATA: 17-eisa13|EISA bus:interrupts --><XREF IDREF="81827" TYPE="TITLE">&ldquo;Allocating IRQs and Channels&rdquo;</XREF>).</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE>EISA Configuration</TITLE><PARAGRAPH>In order to integrate an EISA device into a Silicon Graphics system you must configure the EISA card itself, and then configure the system to recognize the card.<INDEXTARGET ID="17-eisa14"><!-- POSTPROCESSDATA: 17-eisa14|EISA bus:configuring --></PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="77121">Configuring the Hardware</TITLE><PARAGRAPH>The I/O address space on an EISA card plugged into a card slot responds to the range of bus addresses for that slot. All EISA cards are identified by a manufacturer-specific device ID that the operating system uses to register the existence of each card. ISA cards, in contrast, are jumpered to respond to a specific address range that corresponds to the device's I/O registers.</PARAGRAPH>
<PARAGRAPH>Normally a kernel-level driver accesses registers in the I/O space using a PIO map (see <XREF IDREF="57667" TYPE="TITLE">&ldquo;Mapping PIO Addresses&rdquo;</XREF>). For a card's memory space to be accessible, the card must be configured or jumpered to respond to the appropriate address range. The specified address range must be selected to avoid conflicts with other EISA/ISA devices.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="41502">Configuring IRIX</TITLE><PARAGRAPH>In the PC/DOS hardware and software environment, where the EISA bus is commonly found, device configuration is handled in part by use of a standalone ROM BIOS initialization program that stores device information in the nonvolatile RAM of the PC; and in part by saving device initialization information in configuration files that are read at boot time.</PARAGRAPH>
<PARAGRAPH>Neither of these facilities is available in the same way under IRIX. Each EISA device is configured to IRIX using a VECTOR line in a file stored in the directory <FILENAME>/var/sysgen/system</FILENAME> (see <XREF IDREF="28517" TYPE="TITLE">&ldquo;Kernel Configuration Files&rdquo;</XREF>). <INDEXTARGET ID="17-eisa15"><!-- POSTPROCESSDATA: 17-eisa15|VECTOR statement:EISA kernel driver --></PARAGRAPH>
<PARAGRAPH>The syntax of a VECTOR line is documented in two places:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The <FILENAME>/var/sysgen/system/irix.sm</FILENAME> file itself contains descriptive comments on the syntax and meaning of the statement, as well as numerous examples.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The <REFPAGE>system(4)</REFPAGE> reference page gives a more formal definition of the syntax.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>In a Silicon Graphics system equipped with an EISA bus, the file <FILENAME>/var/sysgen/system/irix.sm</FILENAME> contains a number of VECTOR lines describing the EISA devices supported by distributed code.</PARAGRAPH>
<PARAGRAPH>The important elements in a VECTOR line for EISA are as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><COMMAND>bustype</COMMAND>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Specified as <COMMAND>EISA</COMMAND> for EISA devices. The VECTOR statement can be 
used for other types of buses as well. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><COMMAND>module</COMMAND>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>The base name of a kernel-level device driver for this device, as used 
in the <FILENAME>/var/sysgen/master.d</FILENAME> database (see <XREF IDREF="91260" TYPE="TITLE">&ldquo;Master Configuration 
Database&rdquo;</XREF> and <XREF IDREF="69523" TYPE="TITLE">&ldquo;How Names Are Used in Configuration&rdquo;</XREF>). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><COMMAND>adapter</COMMAND>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>The number of the EISA bus where the device is attached&mdash;always 0, 
or omitted, in current systems. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><COMMAND>ctlr</COMMAND>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>The &ldquo;controller&rdquo; number is simply an integer parameter that is 
passed to the device driver at boot time. It can be used for example 
to specify a slot number. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><COMMAND>iospace</COMMAND>, <COMMAND>iospace2</COMMAND>, 
<COMMAND>iospace3</COMMAND>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Each <COMMAND>iospace</COMMAND> group specifies the address space, the starting address, 
and the size of a segment of address space used by this device. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><COMMAND>probe</COMMAND> or <COMMAND>exprobe</COMMAND>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Specifies a hardware test that can be applied at boot time to find out 
if the device exists. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The following is a typical VECTOR line for an EISA device (it must be a single physical line in the file):</PARAGRAPH>
<CODE>
VECTOR: bustype=EISA module=if_ec3 ctlr=1
iospace=(EISAIO,0x1000,0x1000)
exprobe_space=(r,EISAIO, 0x1c80,4,0x6010d425,0xffffffff)
</CODE>
<SECTION3 LBL="" HELPID = ""><TITLE>Using the iospace Parameters</TITLE><PARAGRAPH>The <COMMAND>iospace</COMMAND>, <COMMAND>iospace2</COMMAND>, and <COMMAND>iospace3</COMMAND> parameters are used to pass ranges of device addresses to the device driver. Each parameter contains the following three items:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>A keyword for the address space, either <COMMAND>EISAIO</COMMAND> or <COMMAND>EISAMEM</COMMAND>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The starting address, which depends on the address space and the card itself, as follows:</PARAGRAPH>
<BULLETLISTIND><BULLETIND><PARAGRAPH>For the I/O space of an EISA card, the starting address of I/O registers is 0x1000 multiplied by the slot number of the card (from 1 to 4), and extends for a length of 0x1000 (4096). For example, the manufacturer ID of the card in slot 2 is at address 0x1C80.</PARAGRAPH>
</BULLETIND>
<BULLETIND><PARAGRAPH>The I/O space of an ISA card is hard-wired or jumpered on the card, and falls in the range 0x0100 to 0x0400.</PARAGRAPH>
</BULLETIND>
<BULLETIND><PARAGRAPH>The EISAMEM space is card-dependent and falls in the range 0x000A&nbsp;0000 through 0x06FF&nbsp;FFFF.</PARAGRAPH>
</BULLETIND>
</BULLETLISTIND>
</BULLET>
<BULLET><PARAGRAPH>The length of this bus address range.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The values in these parameters are passed to the device driver at its <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> entry point, provided that the probe shows the device is active.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using the probe and exprobe Parameters</TITLE><PARAGRAPH>You use the <INDEXTARGET ID="17-eisa16"><!-- POSTPROCESSDATA: 17-eisa16|VECTOR statement:use of probe= --><COMMAND>probe</COMMAND> or <COMMAND>exprobe</COMMAND> parameter to program a test for the existence of the device at boot time. When no test is specified, <FILENAME>lboot</FILENAME> assumes the device exists. Then it is up to the device driver to determine if the device is active and usable. When the device does not respond to a probe (because it is off-line or because it has been removed from the system), the <COMMAND>lboot</COMMAND> command will not invoke the device driver for this device.</PARAGRAPH>
<PARAGRAPH>An example exprobe parameter is as follows:</PARAGRAPH>
<EXAMPLE>
exprobe_space=(r,EISAIO, 0x1c80,4,0x6010d425,0xffffffff)
</EXAMPLE>
<PARAGRAPH>The exprobe parameter lists groups of six subparameters, as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Sequence </PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>One or more of <COMMAND>w</COMMAND> for write, <COMMAND>r</COMMAND> for read, or <COMMAND>rn</COMMAND> for read-negate. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Space </PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH><COMMAND>EISAIO</COMMAND> or <COMMAND>EISAMEM</COMMAND>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Address </PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>The address of the byte, halfword, or word to test. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Length </PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>The number of bytes to test: 1, 2, or 4. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Value </PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>The value to write, or the test value for a read. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Mask </PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>A number to be ANDed with the Value operand before a write or after a 
read. Specify 0xffffffff to nullify the AND operation. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>You can use the <COMMAND>w</COMMAND> operation to prime a device. You can use the <COMMAND>r</COMMAND> operation to test for a specific value, and the <COMMAND>rn</COMMAND> operation to test that a specific value (or a specific bit, after masking) is <ITALICS>not</ITALICS> returned.</PARAGRAPH>
<PARAGRAPH>Typically, a simple <COMMAND>r</COMMAND> operation is used on an EISA card to test for the manufacturer's product identifier.</PARAGRAPH>
<PARAGRAPH>To test the existence of an ISA card, use a <COMMAND>wr</COMMAND> sequence to write a value to a register and read it back unchanged. Or read a value and verify that it does not come back all-binary-1, the value returned by a nonexistent device.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using the module Parameter</TITLE><PARAGRAPH>The device driver specified by the <COMMAND>module</COMMAND> parameter is invoked at its <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> entry point, where it receives <COMMAND>ctlr</COMMAND> and <COMMAND>iospace</COMMAND> information specified in the VECTOR line (see <XREF IDREF="14072" TYPE="TITLE">&ldquo;Entry Point edtinit()&rdquo;</XREF>). The device driver initializes the device at this time.</PARAGRAPH>
<PARAGRAPH>You use the <COMMAND>iospace</COMMAND> parameters to pass in the exact bus addresses that correspond to this device. Up to three address space ranges can be passed to the driver. This does not restrict the device&mdash;it can use other ranges of addresses, but the device driver has to deduce their addresses from other information. The device driver typically uses this data to set up PIO maps (see <XREF IDREF="57667" TYPE="TITLE">&ldquo;Mapping PIO Addresses&rdquo;</XREF>). </PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="35170">Kernel Functions for EISA Support</TITLE><PARAGRAPH>The kernel provides services for mapping the EISA bus into the kernel virtual address space for PIO or DMA, and for transferring data using these maps. Two types of DMA are supported, Bus-master DMA and Slave DMA.<INDEXTARGET ID="17-eisa17"><!-- POSTPROCESSDATA: 17-eisa17|EISA bus:kernel services --></PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="57667">Mapping PIO Addresses</TITLE><PARAGRAPH>A PIO map is a system object that represents the mapping of a location in kernel virtual memory to some range of addresses on a VME or EISA bus. After creating a PIO map, a device driver can use it in the following ways:<INDEXTARGET ID="17-eisa18"><!-- POSTPROCESSDATA: 17-eisa18|Programmed I/O (PIO):EISA bus --><INDEXTARGET ID="17-eisa19"><!-- POSTPROCESSDATA: 17-eisa19|EISA bus:PIO mapping --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Extract a specific kernel virtual address that represents the device. This address can be used to load or store data, or it can be mapped that into user process space.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Copy data between the device and memory without learning the specific kernel addresses involved.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Perform bus read-modify-write cycles to apply Boolean operators to device data.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The functions used with PIO maps are summarized in <XREF IDREF="51830" TYPE="TABLE">Table&nbsp;18-1</XREF>. </PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="18-1"><PREFIX>Table 18-1 </PREFIX><XREFTARGET ID="51830"> <EMPHASIS>(continued)        </EMPHASIS>Functions to Create and Use PIO Maps</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="90"><PARAGRAPH>&lbreak;Function</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="72"><PARAGRAPH>&lbreak;Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="42"><PARAGRAPH>Can 
Sleep</PARAGRAPH>
</CELL>
<CELL LEFT="225" WIDTH="182"><PARAGRAPH>&lbreak;Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>pio_mapalloc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="42"><PARAGRAPH>Y</PARAGRAPH>
</CELL>
<CELL LEFT="225" WIDTH="182"><PARAGRAPH>Allocate a PIO map. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>pio_mapfree(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="42"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="225" WIDTH="182"><PARAGRAPH>Free a PIO map. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>pio_badaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="42"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="225" WIDTH="182"><PARAGRAPH>Check for bus error when reading an 
address. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>pio_wbadaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="42"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="225" WIDTH="182"><PARAGRAPH>Check for bus error when writing to an 
address. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>pio_mapaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="42"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="225" WIDTH="182"><PARAGRAPH>Convert a bus address to a virtual address. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>pio_bcopyin(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="42"><PARAGRAPH>Y</PARAGRAPH>
</CELL>
<CELL LEFT="225" WIDTH="182"><PARAGRAPH>Copy data from a bus address to kernel's 
virtual space. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>pio_bcopyout(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="42"><PARAGRAPH>Y</PARAGRAPH>
</CELL>
<CELL LEFT="225" WIDTH="182"><PARAGRAPH>Copy data from kernel's virtual space to a 
bus address. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>pio_andb_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="42"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="225" WIDTH="182"><PARAGRAPH>Byte read-AND-write cycle. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>pio_andh_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="42"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="225" WIDTH="182"><PARAGRAPH>16-bit read-AND-write cycle. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>pio_andw_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="42"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="225" WIDTH="182"><PARAGRAPH>32-bit read-AND-write cycle. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>pio_orb_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="42"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="225" WIDTH="182"><PARAGRAPH>Byte read-OR-write cycle. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>pio_orh_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="42"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="225" WIDTH="182"><PARAGRAPH>16-bit read-OR-write cycle. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>pio_orw_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="42"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="225" WIDTH="182"><PARAGRAPH>32-bit read-OR-write cycle. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>A kernel-level device driver creates a PIO map by calling <INDEXTARGET ID="17-eisa20"><!-- POSTPROCESSDATA: 17-eisa20|kernel functions:<FUNCTION>pio_mapalloc</FUNCTION>() --><FUNCTION>pio_mapalloc()</FUNCTION>. This function performs memory allocation and so can sleep. PIO maps are typically created in the <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> entry point, where the driver first learns about the device addresses from the contents of the <VARIABLE>edt_t</VARIABLE> structure (see <XREF IDREF="14072" TYPE="TITLE">&ldquo;Entry Point edtinit()&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>The parameters to <FUNCTION>pio_mapalloc()</FUNCTION> describe the range of addresses that can be mapped in terms of</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>the bus type, in this case ADAP_EISA from <FILENAME>sys/edt.h</FILENAME></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the bus number, when more than one bus is supported</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the address space, using constants such as PIOMAP_EISA_IO from <FILENAME>sys/pio.h</FILENAME></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the starting bus address and a length</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>This call also specifies a &ldquo;fixed&rdquo; or &ldquo;unfixed&rdquo; map. This distinction applies only to VME maps. An EISA map is always a fixed map.</PARAGRAPH>
<PARAGRAPH>A call to <FUNCTION>pio_mapfree()</FUNCTION> releases a PIO map. PIO maps created by a loadable driver must be released in the <VARIABLE>pfx</VARIABLE><FUNCTION>unload()</FUNCTION> entry point (see <XREF IDREF="57773" TYPE="TITLE">&ldquo;Entry Point unload()&rdquo;</XREF> and <XREF IDREF="53871" TYPE="TITLE">&ldquo;Unloading&rdquo;</XREF>).</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Testing the PIO Map</TITLE><PARAGRAPH>The PIO map is created from the parameters that are passed. These are not validated by <FUNCTION>pio_mapalloc()</FUNCTION>. If there is any possibility that the mapped device is not installed, not active, or improperly configured, you should test the mapped address.</PARAGRAPH>
<PARAGRAPH>The <INDEXTARGET ID="17-eisa21"><!-- POSTPROCESSDATA: 17-eisa21|kernel functions:<FUNCTION>pio_baddr</FUNCTION>() --><FUNCTION>pio_baddr()</FUNCTION> and <FUNCTION>pio_wbaddr()</FUNCTION> functions test the mapped address to see if it is usable.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using the Mapped Address</TITLE><PARAGRAPH>From a fixed PIO map you can recover a kernel virtual address that corresponds to the first bus address in the map. The <FUNCTION>pio_mapaddr()</FUNCTION> function is used for this.</PARAGRAPH>
<PARAGRAPH>You can use this address to load or store data into device registers. In the <VARIABLE>pfx</VARIABLE><FUNCTION>map()</FUNCTION> entry point (see <XREF IDREF="34808" TYPE="TITLE">&ldquo;Concepts and Use of mmap()&rdquo;</XREF>), you can use this address with the <FUNCTION>v_mapphys()</FUNCTION> function to map the range of device addresses into the address space of a user process.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="91021">Using the PIO Map in Functions</TITLE><PARAGRAPH>You can apply a variety of kernel functions to any PIO map, fixed or unfixed. The <INDEXTARGET ID="17-eisa22"><!-- POSTPROCESSDATA: 17-eisa22|kernel functions:<FUNCTION>pio_bcopyout</FUNCTION>() --><INDEXTARGET ID="17-eisa23"><!-- POSTPROCESSDATA: 17-eisa23|kernel functions:<FUNCTION>pio_bcopyin</FUNCTION>() --><FUNCTION>pio_bcopyin()</FUNCTION> and <FUNCTION>pio_bcopyout()</FUNCTION> functions copy a range of data between memory and a PIO map. There is no performance advantage to using these functions, as compared to loading or storing to the mapped addresses, but their use makes the device driver code simpler and more readable.</PARAGRAPH>
<PARAGRAPH>The series of functions <FUNCTION>pio_andb_rmw()</FUNCTION> and <FUNCTION>pio_orb_rmw()</FUNCTION> perform a read-modify-write cycle. You can use them to set or clear bits in device registers. Read-modify-write cycles on the EISA bus are atomic operations to software only (see <XREF IDREF="49622" TYPE="TITLE">&ldquo;EISA Locked Cycles&rdquo;</XREF>). </PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="81827">Allocating IRQs and Channels</TITLE><PARAGRAPH>Before a kernel-level driver can field EISA interrupts, it must associate a handler with one of the IRQ levels. In order to perform DMA, the driver must allocate one of the DMA channels. The functions used for these purposes are summarized in<INDEXTARGET ID="17-eisa24"><!-- POSTPROCESSDATA: 17-eisa24|EISA bus:allocate IRQ --><XREF IDREF="93347" TYPE="TABLE">Table&nbsp;18-2</XREF>.</PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="18-2"><PREFIX>Table 18-2 </PREFIX><XREFTARGET ID="93347">Functions for IRQ and Channel Allocation</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="99"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="106"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="220" WIDTH="45"><PARAGRAPH>Can Sleep</PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="135"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>eisa_dmachan_alloc() </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="106"><PARAGRAPH>eisa.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="220" WIDTH="45"><PARAGRAPH>N </PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="135"><PARAGRAPH>Allocate DMA channel. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>eisa_ivec_alloc() </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="106"><PARAGRAPH>eisa.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="220" WIDTH="45"><PARAGRAPH>N </PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="135"><PARAGRAPH>Allocate IRQ and set triggering. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>eisa_ivec_set() </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="106"><PARAGRAPH>eisa.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="220" WIDTH="45"><PARAGRAPH>N </PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="135"><PARAGRAPH>Associate handler to IRQ. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<NOTE><PREFIX>Note</PREFIX>There are no reference pages for the functions in <XREF IDREF="93347" TYPE="TABLE">Table&nbsp;18-2</XREF>.</NOTE>
<SECTION3 LBL="" HELPID = ""><TITLE>Allocating and Programming an IRQ</TITLE><PARAGRAPH>The function <INDEXTARGET ID="17-eisa25"><!-- POSTPROCESSDATA: 17-eisa25|kernel functions:<FUNCTION>eisa_ivec_alloc</FUNCTION>() --><FUNCTION>eisa_ivec_alloc()</FUNCTION> allocates an available IRQ number from a set of acceptable numbers. Its prototype is</PARAGRAPH>
<EXAMPLE>
int eisa_ivec_alloc(uint_t adap,ushort_t mask,uchar_t trig);
</EXAMPLE>
<PARAGRAPH>The arguments are as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>adap</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The adapter number, always 0 in current systems. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>mask</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>A 16-bit mask containing a 1-bit for each IRQ level that is acceptable for 
this device. (For available IRQ levels, see <XREF IDREF="63814" TYPE="TITLE">&ldquo;EISA Interrupts&rdquo;</XREF>.) </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>trig </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The triggering method used by the card, either EISA_EDGE_IRQ or 
EISA_LEVEL_IRQ from <FILENAME>sys/eisa.h</FILENAME>. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>ISA cards are usually hard-wired or jumpered to a particular IRQ, so that the <VARIABLE>mask</VARIABLE> argument contains a single bit. Some EISA cards can be programmed dynamically to use a selected IRQ; in that case <VARIABLE>mask</VARIABLE> contains a 1-bit for each IRQ the card can be programmed to use.</PARAGRAPH>
<PARAGRAPH>The function attempts to allocate an IRQ from the <VARIABLE>mask</VARIABLE> set that is not in use by any card. If all acceptable levels are in use, it allocates an IRQ that is already in use with the requested kind of triggering. In either case, it returns the number of the IRQ to be used.</PARAGRAPH>
<PARAGRAPH>In the event that all the IRQs requested are already in use with a conflicting type of triggering, the function returns -1.</PARAGRAPH>
<PARAGRAPH>After allocating an IRQ, the device driver programs the card (using PIO) to interrupt on that line.</PARAGRAPH>
<PARAGRAPH>The function <FUNCTION>eisa_ivec_set()</FUNCTION> associates a function in the device driver with an IRQ number. Its prototype is</PARAGRAPH>
<CODE>
int eisa_ivec_set(uint_t adap, int irq,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void (*e_intr)(long), long e_arg)
</CODE>
<PARAGRAPH>The parameters are as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>adap</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="269"><PARAGRAPH>The adapter number, always 0 in current systems. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>irq</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="269"><PARAGRAPH>The IRQ level to be monitored. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>e_intr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="269"><PARAGRAPH>The address of the interrupt handling function to call. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>e_arg</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="269"><PARAGRAPH>An argument to pass to the function when called. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>When more than one device is allocated the same IRQ, the kernel calls all the interrupt functions associated with that IRQ. This means that an interrupt function must always verify, by testing device registers, that the interrupt was caused by its device.</PARAGRAPH>
<PARAGRAPH>The first call to <FUNCTION>eisa_ivec_set()</FUNCTION> for a given IRQ enables interrupts from that IRQ. Prior to the call, interrupts from that IRQ are ignored.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>If you are working with both the VME and EISA interfaces, it is worth noting that the number and type of arguments of <FUNCTION>eisa_ivec_set()</FUNCTION> differ from those of <FUNCTION>vme_ivec_set()</FUNCTION>.</NOTE>
<NOTE><PREFIX>Note</PREFIX>There is no way to retract the association of an interrupt function with an IRQ. This means that if an EISA driver handles interrupts and is loadable, it must not support the <VARIABLE>pfx</VARIABLE><FUNCTION>unload()</FUNCTION> entry point. An interrupt arriving after the driver had been unloaded would panic the system.</NOTE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="83162">Allocating a DMA Channel</TITLE><PARAGRAPH>The function <INDEXTARGET ID="17-eisa26"><!-- POSTPROCESSDATA: 17-eisa26|kernel functions:<FUNCTION>eisa_dmachan_alloc</FUNCTION>() --><INDEXTARGET ID="17-eisa27"><!-- POSTPROCESSDATA: 17-eisa27|EISA bus:allocate DMA channel --><FUNCTION>eisa_dmachan_alloc()</FUNCTION> allocates one of the seven available DMA channels (channel 4 is reserved by the hardware) from a set of acceptable channels. The function's prototype is</PARAGRAPH>
<EXAMPLE>
int eisa_dmachan_alloc(uint_t adap, uchar_t dma_mask)
</EXAMPLE>
<PARAGRAPH>The arguments are as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>adap</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="267"><PARAGRAPH>The adapter number, always 0 in current systems. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>dma_mask</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="267"><PARAGRAPH>An 8-bit mask containing 1-bits for the DMA channels that 
can be used by this device. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The function allocates the channel in the requested set that is in use by the fewest devices. It is possible for a single channel to be requested by multiple devices. However, if the device can use any of several channels, it is likely that the device will be the only one using the channel whose number is returned. After allocating a channel number, the device driver programs the device to use that channel, if necessary.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="76103">Programming Bus-Master DMA</TITLE><PARAGRAPH>Bus-master DMA is performed by an EISA card that has bus-master logic. The card generates the DMA bus cycles, and provides the target memory address to store or retrieve data.<INDEXTARGET ID="17-eisa28"><!-- POSTPROCESSDATA: 17-eisa28|Direct Memory Access (DMA):EISA bus-master --><INDEXTARGET ID="17-eisa29"><!-- POSTPROCESSDATA: 17-eisa29|EISA bus:DMA to bus master --></PARAGRAPH>
<PARAGRAPH>The device driver sets up Bus-master DMA by programming the card with a target physical address and length of data. Some cards support scatter/gather operations, in which the card is programmed with a list of memory pages and their lengths, and the card transfers a stream of data across all of the pages. However, programming an EISA bus master card is a highly hardware-dependent operation. The cards vary widely in their capabilities and programming methods. </PARAGRAPH>
<PARAGRAPH>The key programming issue for a device driver is locating the target memory buffers in system memory, so as to be able to program the EISA card with correct physical memory addresses.</PARAGRAPH>
<PARAGRAPH>The kernel provides functions for mapping memory for DMA. The functions that operate on EISA DMA maps are summarized in <XREF IDREF="70603" TYPE="TABLE">Table&nbsp;18-3</XREF>.</PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="18-3"><PREFIX>Table 18-3 </PREFIX><XREFTARGET ID="70603">Functions That Operate on DMA Maps</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="83"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="102"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="45"><PARAGRAPH>Can Sleep</PARAGRAPH>
</CELL>
<CELL LEFT="250" WIDTH="158"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH><REFPAGE>dma_map(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="102"><PARAGRAPH>dmamap.h &amp; types.h &amp; 
sema.h </PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="250" WIDTH="158"><PARAGRAPH>Prepare DMA mapping. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH><REFPAGE>dma_mapaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="102"><PARAGRAPH>dmamap.h &amp; types.h &amp; 
sema.h </PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="250" WIDTH="158"><PARAGRAPH>Return the target physical address for 
a given map and address.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH><REFPAGE>dma_mapalloc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="102"><PARAGRAPH>dmamap.h &amp; types.h &amp; 
sema.h </PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="45"><PARAGRAPH>Y</PARAGRAPH>
</CELL>
<CELL LEFT="250" WIDTH="158"><PARAGRAPH>Allocate a DMA map.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH><REFPAGE>dma_mapfree(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="102"><PARAGRAPH>dmamap.h &amp; types.h &amp; 
sema.h </PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="250" WIDTH="158"><PARAGRAPH>Free a DMA map.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>A device driver allocates a DMA map using <INDEXTARGET ID="17-eisa30"><!-- POSTPROCESSDATA: 17-eisa30|kernel functions:<FUNCTION>dma_mapalloc</FUNCTION>() --><FUNCTION>dma_mapalloc()</FUNCTION>. This is typically done in the <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> entry point, provided that the maximum I/O size is known at that time (see <XREF IDREF="14072" TYPE="TITLE">&ldquo;Entry Point edtinit()&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>A DMA map is used prior to a DMA transfer into or out of a buffer in kernel virtual space. The function <INDEXTARGET ID="17-eisa31"><!-- POSTPROCESSDATA: 17-eisa31|kernel functions:<FUNCTION>dma_map</FUNCTION>() --><FUNCTION>dma_map()</FUNCTION> takes a DMA map, a buffer address, and a length. It relates the buffer address to physical addresses for use in DMA, and returns the length mapped. The returned length is typically less than the length of the buffer. This is because, for EISA, the function does not support scatter/gather, so the mapping must stop at the first page boundary.</PARAGRAPH>
<PARAGRAPH>After calling <INDEXTARGET ID="17-eisa32"><!-- POSTPROCESSDATA: 17-eisa32|kernel functions:<FUNCTION>dma_mapaddr</FUNCTION>() --><FUNCTION>dma_map()</FUNCTION>, the device driver calls <FUNCTION>dma_mapaddr()</FUNCTION> to get the physical address corresponding to the current map. This is the address that is programmed into the EISA bus master card as a target address for a segment of the transfer up to one page in size.</PARAGRAPH>
<PARAGRAPH>Repeated calls to <FUNCTION>dma_map()</FUNCTION> and <FUNCTION>dma_mapaddr()</FUNCTION> can be used to map successive pages, until the EISA card is loaded with as many transfer segment addresses as it supports.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="50173">Programming Slave DMA</TITLE><PARAGRAPH>In Slave DMA, an EISA card that does not have DMA logic is commanded by the EISA Interface Unit and 82350 chip set (see <INDEXTARGET ID="17-eisa33"><!-- POSTPROCESSDATA: 17-eisa33|Direct Memory Access (DMA):EISA bus slave --><XREF IDREF="54463" TYPE="GRAPHIC">Figure&nbsp;18-1</XREF>) to perform a series of transfers into memory.</PARAGRAPH>
<PARAGRAPH>The kernel supplies a unique set of functions for managing Slave DMA, unrelated to the DMA functions for Bus-master DMA. The functions that operate on EISA DMA maps are summarized in <XREF IDREF="32225" TYPE="TABLE">Table&nbsp;18-4</XREF>. </PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="18-4"><PREFIX>Table 18-4 </PREFIX><XREFTARGET ID="32225"> <EMPHASIS>(continued)        </EMPHASIS>Functions for EISA DMA</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="99"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="84"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="45"><PARAGRAPH>Can Sleep</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="158"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>eisa_dma_disable(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="84"><PARAGRAPH>eisa.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="158"><PARAGRAPH>Disable recognition of hardware 
requests on a DMA channel. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>eisa_dma_enable(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="84"><PARAGRAPH>eisa.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="158"><PARAGRAPH>Enable recognition of hardware 
requests on a DMA channel. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>eisa_dma_free_buf(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="84"><PARAGRAPH>eisa.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="158"><PARAGRAPH>Free a previously allocated DMA 
buffer descriptor. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>eisa_dma_free_cb(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="84"><PARAGRAPH>eisa.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="158"><PARAGRAPH>Free a previously allocated DMA 
command block. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>eisa_dma_get_buf(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="84"><PARAGRAPH>eisa.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="45"><PARAGRAPH>Y</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="158"><PARAGRAPH>Allocate a DMA buffer descriptor. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>eisa_dma_get_cb(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="84"><PARAGRAPH>eisa.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="45"><PARAGRAPH>Y</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="158"><PARAGRAPH>Allocate a DMA command block. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>eisa_dma_prog(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="84"><PARAGRAPH>eisa.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="45"><PARAGRAPH>Y</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="158"><PARAGRAPH>Program a DMA operation for a 
subsequent software request. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>eisa_dma_stop(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="84"><PARAGRAPH>eisa.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="158"><PARAGRAPH>Stop software-initiated DMA 
operation and release channel. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>eisa_dma_swstart(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="84"><PARAGRAPH>eisa.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="45"><PARAGRAPH>Y</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="158"><PARAGRAPH>Initiate a DMA operation via software 
request. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The EISA attachment hardware has many options for performing Slave DMA, and most of these options are reflected in the contents of the <VARIABLE>eisa_dma_cb</VARIABLE> and <VARIABLE>eisa_dma_buf</VARIABLE> data structures (see the <REFPAGE>eisa_dma_buf(D4)</REFPAGE> and <REFPAGE>eisa_dma_cb(D4)</REFPAGE> reference pages, in addition to the reference pages listed in <XREF IDREF="32225" TYPE="TABLE">Table&nbsp;18-4</XREF>). By setting appropriate values declared in <FILENAME>sys/eisa.h</FILENAME> into these structures, you can program most varieties of Slave DMA. </PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="74912">Sample EISA Driver Code</TITLE><PARAGRAPH>This section shows initialization code, and a complete EISA driver.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Initialization Sketch</TITLE><PARAGRAPH>The code in <INDEXTARGET ID="17-eisa34"><!-- POSTPROCESSDATA: 17-eisa34|EISA bus:example driver --><INDEXTARGET ID="17-eisa35"><!-- POSTPROCESSDATA: 17-eisa35|driver:examples:EISA --><INDEXTARGET ID="17-eisa36"><!-- POSTPROCESSDATA: 17-eisa36|example driver --><XREF IDREF="51830" TYPE="TABLE">Table&nbsp;18-1</XREF> represents an outline of the <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> entry point for a hypothetical EISA device, showing the allocation of a PIO map, an IRQ, and a DMA channel. The driver supports as many as four identical devices. It keeps information about them in an array of structures, <VARIABLE>einfo</VARIABLE>. Each entry to <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> initializes one element of this array, as indexed by the <COMMAND>ctlr</COMMAND> value from the VECTOR statement.</PARAGRAPH>
<PARAGRAPH>An important point to note in the example below is that most of the arguments to <INDEXTARGET ID="17-eisa37"><!-- POSTPROCESSDATA: 17-eisa37|kernel functions:<FUNCTION>pio_map_alloc</FUNCTION>() --><FUNCTION>pio_map_alloc()</FUNCTION> can simply be passed as the values from the <VARIABLE>edt_t</VARIABLE> received by the entry point.</PARAGRAPH>
<CODE><CAPTION LBL="18-1"><PREFIX>Example 18-1 </PREFIX>Sketch of EISA Initialization</CAPTION>#include &lt;sys/types.h>
#include &lt;sys/edt.h>
#include &lt;sys/pio.h>
#include &lt;sys/eisa.h>
#include &lt;sys/cmn_err.h>
#define MAX_DEVICE 4
/* Array of info structures about each device. A device
** that does not initialize OK ought to be marked, but
** no such logic is shown.
*/
struct edrv_info {
&nbsp;&nbsp;&nbsp;caddr_t e_addr[NBASE];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* pio mapped addr per space */
&nbsp;&nbsp;&nbsp;int     e_dmachan;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* dma chan in use */
} einfo[MAX_DEVICE];
&nbsp;
#define CARD_ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0163b30a&nbsp;&nbsp;&nbsp;/* mfr. ID */
#define IRQ_MASK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0018&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* acceptable IRQs */
#define DMACHAN_MASK&nbsp;&nbsp;&nbsp;&nbsp;0x7a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* acceptable chans */
edrv_edtinit(edt_t *e)
{
&nbsp;&nbsp;&nbsp;int iospace;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* index over iospace array */
&nbsp;&nbsp;&nbsp;int eirq;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* allocated IRQ # */
&nbsp;&nbsp;&nbsp;int edma_chan;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* allocated chan # */
&nbsp;&nbsp;&nbsp;struct edrv_info *einf; /* -> einfo[n] */
&nbsp;&nbsp;&nbsp;piomap_t *pmap;
&nbsp;
&nbsp;&nbsp;&nbsp;if (e->e_ctlr &lt; MAX_DEVICE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;einf = &amp;einfo[e->e_ctlr];
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;{ /* unknown device, nowhere to put info */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err(CE_WARN,"devno too large:%d",e->e_ctlr);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}
/* for each nonempty iospace parameter,
** set up a PIO map and save the kv address.
*/
&nbsp;&nbsp;&nbsp;for (iospace = 0; iospace &lt; NBASE; iospace++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!e->e_space[iospace].ios_iopaddr)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;einf->e_addr[iospace] = 0; /* note no addr */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pmap = pio_mapalloc( /* make a PIO map */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e->e_bus_type,&nbsp;&nbsp;&nbsp;/* pass bus type given */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e->e_adap, /* pass adapter # given */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;e->e_space[iospace], /* given iospace too */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PIOMAP_FIXED, /* always fixed for EISA */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"edrv");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;einf->e_addr[iospace] = pio_mapaddr(pmap,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e->e_space[iospace].ios_iopaddr);
&nbsp;&nbsp;&nbsp;}
/* Set up an edge-triggered IRQ for this device.
** Associate it with our interrupt entry point.
** There is no need to remember the assigned IRQ.
*/
&nbsp;&nbsp;&nbsp;eirq = eisa_ivec_alloc(e->e_adap,IRQ_MASK,EISA_EDGE_IRQ);
&nbsp;&nbsp;&nbsp;if (eirq &lt; 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err(CE_WARN,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"edrv: ctlr %d could not allocate IRQ\n&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e->e_ctlr);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* should mark einfo unusable */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;eisa_ivec_set(e->e_adap, eirq, edrv_intr, e->e_ctlr);
/* Allocate a DMA Channel for this device and note
** the number in the device info array.
*/
&nbsp;&nbsp;&nbsp;edma_chan = eisa_dmachan_alloc(e->e_adap,DMACHAN_MASK);
&nbsp;&nbsp;&nbsp;if (edma_chan &lt; 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err(CE_WARN,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"edrv: ctlr %d could not allocate DMA Chan\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e->e_ctlr);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* should mark einfo unusable */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;einf->e_dmachan = edma_chan;
}
</CODE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Complete EISA Character Driver </TITLE><PARAGRAPH>The code in this section displays a complete character device driver for an EISA card, the Roland RAP-10 synthesizer. This inexpensive synthesizer card can be installed in an Indigo<SUPERSCRIPT>2</SUPERSCRIPT> and driven by a program through this device driver.</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="28938" TYPE="TEXT">Example&nbsp;18-6</XREF> displays the code of the driver itself.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="13783" TYPE="TEXT">Example&nbsp;18-2</XREF> displays the descriptive file to be placed in <FILENAME>/var/sysgen/master.d</FILENAME> to describe the driver.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="52971" TYPE="TEXT">Example&nbsp;18-3</XREF> displays the configuration file to be placed in <FILENAME>/var/sysgen/system</FILENAME> to enable loading the driver.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="75115" TYPE="TEXT">Example&nbsp;18-4</XREF> displays a shell script to install the driver.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="32876" TYPE="TEXT">Example&nbsp;18-5</XREF> contains a test program to operate the synthesizer. </PARAGRAPH>
<CODE><CAPTION LBL="18-2"><PREFIX>Example 18-2 </PREFIX><XREFTARGET ID="13783">Master File /var/sysgen/rap for RAP-10 Driver</CAPTION>*
* rap  - Roland RAP-10 Musical Board 
*
* $Revision: 1.6 $
*
*FLAG   PREFIX  SOFT    #DEV    DEPENDENCIES
c   rap     61      - 
&nbsp;
$$$
</CODE>
</BULLET>
</BULLETLIST>
<PARAGRAPH>&nbsp;</PARAGRAPH>
<CODE><CAPTION LBL="18-3"><PREFIX>Example 18-3 </PREFIX><XREFTARGET ID="52971">Configuration File /var/sysgen/rap.sm for RAP-10 Driver</CAPTION>VECTOR: bustype=EISA module=rap ctlr=0 adapter=0 iospace=(EISAIO,0x330,16) probe_space=(EISAIO,0x330,1)
</CODE>
<PARAGRAPH>&nbsp;</PARAGRAPH>
<CODE><CAPTION LBL="18-4"><PREFIX>Example 18-4 </PREFIX><XREFTARGET ID="75115">Installation Script for RAP-10 Driver</CAPTION>#!/bin/csh
&nbsp;
if [ &grave;whoami&grave;!= &ldquo;root&rdquo; ]
then
&space; echo &ldquo;You must be root to run this script.\n&rdquo;
&space; exit 1
fi
&nbsp;
echo &ldquo;cp rap.o /var/sysgen/boot/rap.o\n&rdquo;
cp rap.o /var/sysgen/boot/rap.o
&nbsp;
echo &ldquo;cp rap.master /var/sysgen/master.d/rap\n&rdquo;
cp rap.master /var/sysgen/master.d/rap
&nbsp;
echo &ldquo;cp rap.sm /var/sysgen/system/rap.sm&rdquo;
cp rap.sm /var/sysgen/system/rap.sm
&nbsp;
echo &ldquo;mknod /dev/rap c 62 0\n&rdquo;
mknod /dev/rap c 62 0
&nbsp;
echo &ldquo;Make a new kernel anytime by typing: autoconfig -f -v\n&rdquo;

</CODE>
<PARAGRAPH>&nbsp;</PARAGRAPH>
<CODE><CAPTION LBL="18-5"><PREFIX>Example 18-5 </PREFIX><XREFTARGET ID="32876">Program to Test RAP-10 Driver</CAPTION>#include&nbsp;&lt;stdio.h>
#include&nbsp;&lt;fcntl.h>
#include&nbsp;&lt;string.h>
#include&nbsp;&lt;errno.h>
#include&nbsp;&lt;sys/types.h>
#include&nbsp;&lt;signal.h>
#include&nbsp;&ldquo;rap.h&rdquo;&nbsp;&nbsp;&nbsp;
&nbsp;
/*&nbsp;&nbsp;
&nbsp;*&nbsp;&nbsp;record.c
&nbsp;*
&nbsp;*&nbsp;&nbsp;This&nbsp;program&nbsp;plays&nbsp;song&nbsp;from&nbsp;a&nbsp;previuosly&nbsp;recorded&nbsp;file
&nbsp;*&nbsp;&nbsp;using&nbsp;RAP-10&nbsp;board.&nbsp;
&nbsp;*
&nbsp;*/
&nbsp;
#define&nbsp;&nbsp;&nbsp;&nbsp;BUF_SIZE&nbsp;&nbsp;&nbsp;&nbsp;4096
#define&nbsp;&nbsp;&nbsp;&nbsp;FILE_HDR&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;RAP-10&nbsp;WAVE&nbsp;FILE&rdquo;
#define&nbsp;&nbsp;&nbsp;&nbsp;RAP_FILE&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;/dev/rap&rdquo;
#define&nbsp;&nbsp;&nbsp;&nbsp;MAX_BUF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;
#define&nbsp;&nbsp;&nbsp;&nbsp;FOREVER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(;;)
&nbsp;
uchar_t&nbsp;&nbsp;&nbsp;&nbsp;buf[BUF_SIZE];
uchar_t&nbsp;&nbsp;&nbsp;&nbsp;*fname;
void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endProg(&nbsp;int&nbsp;);
&nbsp;
main&nbsp;(int&nbsp;argc,&nbsp;char&nbsp;**argv)
{
&nbsp;&nbsp;&nbsp;&nbsp;register&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;fd,&nbsp;rapfd,&nbsp;bytes;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;argc&nbsp;&lt;=&nbsp;1&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;(&ldquo;play:&nbsp;Usage:&nbsp;play&nbsp;&lt;file_name>\n&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(0);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;fname&nbsp;=&nbsp;argv[1];
&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;(&ldquo;play:&nbsp;opening&nbsp;file&nbsp;%s\n&rdquo;,&nbsp;fname);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;fd&nbsp;=&nbsp;open&nbsp;(fname,&nbsp;O_RDONLY);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;fd&nbsp;==&nbsp;-1&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;(&ldquo;play:&nbsp;Cannot&nbsp;create&nbsp;file,&nbsp;errno&nbsp;=&nbsp;%d\n&rdquo;,&nbsp;errno);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close(rapfd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(0);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;(&ldquo;play:&nbsp;Checking&nbsp;RAP-10&nbsp;File&nbsp;ID\n&rdquo;);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;read(fd,&nbsp;buf,&nbsp;strlen(FILE_HDR))&nbsp;&lt;=&nbsp;0&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;(&ldquo;play:&nbsp;Could&nbsp;not&nbsp;read&nbsp;the&nbsp;file&nbsp;ID,&nbsp;errno&nbsp;=&nbsp;%d\n&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errno);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close(fd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(0);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;strcmp(buf,&nbsp;FILE_HDR)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;(&ldquo;play:&nbsp;File&nbsp;is&nbsp;not&nbsp;a&nbsp;RAP&nbsp;file\n&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close(fd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(0);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;(&ldquo;play:&nbsp;opening&nbsp;RAP&nbsp;card\n&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;rapfd&nbsp;=&nbsp;open&nbsp;(RAP_FILE,&nbsp;O_WRONLY);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;rapfd&nbsp;&lt;=&nbsp;0&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;(&ldquo;play:&nbsp;Cannot&nbsp;open&nbsp;RAP&nbsp;card,&nbsp;errno&nbsp;=&nbsp;%d\n&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errno);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(0);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;(&ldquo;play:&nbsp;Playing&nbsp;..please&nbsp;wait\n&rdquo;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;ignore&nbsp;Interrupt&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;sigset&nbsp;(SIGINT,&nbsp;SIG_IGN&nbsp;);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;FOREVER&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bytes&nbsp;=&nbsp;read(fd,&nbsp;buf,&nbsp;BUF_SIZE);&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;bytes&nbsp;&lt;&nbsp;0&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;(&ldquo;play:&nbsp;error&nbsp;reading&nbsp;data,&nbsp;errno&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errno);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close(fd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close(rapfd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;bytes&nbsp;==&nbsp;0&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bytes&nbsp;=&nbsp;write(rapfd,&nbsp;buf,&nbsp;BUF_SIZE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;bytes&nbsp;&lt;=&nbsp;0&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;(&ldquo;play:&nbsp;Cannot&nbsp;read&nbsp;from&nbsp;RAP,&nbsp;errno&nbsp;=&nbsp;%d\n&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errno);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close&nbsp;(rapfd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close&nbsp;(fd);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;(&ldquo;play:&nbsp;waiting&nbsp;for&nbsp;Play&nbsp;to&nbsp;End\n&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ioctl&nbsp;(rapfd,&nbsp;RAPIOCTL_END_PLAY)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf&nbsp;(&ldquo;play:&nbsp;Ioctl&nbsp;error&nbsp;%d&rdquo;,&nbsp;errno&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;printf&nbsp;(&ldquo;play:&nbsp;Song&nbsp;succesfully&nbsp;played\n&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;close(rapfd);
&nbsp;&nbsp;&nbsp;&nbsp;close&nbsp;(fd);
}
</CODE>
<PARAGRAPH>&nbsp;</PARAGRAPH>
<CODE><CAPTION LBL="18-6"><PREFIX>Example 18-6 </PREFIX><XREFTARGET ID="28938">Complete EISA Character Driver for RAP-10</CAPTION>/*****************************************************************************
&nbsp;*
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Roland&nbsp;RAP-10&nbsp;Music&nbsp;Card&nbsp;Device&nbsp;Driver&nbsp;for&nbsp;Eisa&nbsp;Bus
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;---------------------------------------------------
&nbsp;*
&nbsp;*&nbsp;&nbsp;&nbsp;INTRODUCTION:&nbsp;
&nbsp;*&nbsp;&nbsp;&nbsp;-------------
&nbsp;*&nbsp;&nbsp;&nbsp;This&nbsp;file&nbsp;contains&nbsp;the&nbsp;device&nbsp;driver&nbsp;for&nbsp;Roland&nbsp;RAP-10
&nbsp;*&nbsp;&nbsp;&nbsp;Music&nbsp;Card.&nbsp;Currently&nbsp;it&nbsp;contains&nbsp;necessary&nbsp;routines&nbsp;to&nbsp;Record&nbsp;and
&nbsp;*&nbsp;&nbsp;&nbsp;Playback&nbsp;a&nbsp;&nbsp;Wave&nbsp;file.&nbsp;The&nbsp;MIDI&nbsp;Implementation&nbsp;is&nbsp;to&nbsp;be&nbsp;defined&nbsp;and
&nbsp;*&nbsp;&nbsp;&nbsp;implemented&nbsp;at&nbsp;later&nbsp;time.
&nbsp;*
&nbsp;*&nbsp;&nbsp;&nbsp;DESIGN&nbsp;OVERVIEW:
&nbsp;*&nbsp;&nbsp;&nbsp;----------------
&nbsp;*&nbsp;&nbsp;&nbsp;We&nbsp;will&nbsp;use&nbsp;DMA&nbsp;for&nbsp;wave&nbsp;data&nbsp;movements.&nbsp;At&nbsp;any&nbsp;given&nbsp;time,&nbsp;the&nbsp;card
&nbsp;*&nbsp;&nbsp;&nbsp;can&nbsp;be&nbsp;either&nbsp;playing&nbsp;or&nbsp;recording&nbsp;and&nbsp;both&nbsp;operations&nbsp;are&nbsp;not&nbsp;allowed.
&nbsp;*&nbsp;&nbsp;&nbsp;Also&nbsp;no&nbsp;more&nbsp;than&nbsp;one&nbsp;process&nbsp;at&nbsp;a&nbsp;time&nbsp;can&nbsp;access&nbsp;the&nbsp;card.
&nbsp;*
&nbsp;*&nbsp;&nbsp;&nbsp;Circular&nbsp;Buffers:
&nbsp;*&nbsp;&nbsp;&nbsp;-----------------
&nbsp;*&nbsp;&nbsp;&nbsp;Since&nbsp;DMA&nbsp;operation&nbsp;is&nbsp;performed&nbsp;independently&nbsp;of&nbsp;the&nbsp;processor,
&nbsp;*&nbsp;&nbsp;&nbsp;we&nbsp;will&nbsp;buffer&nbsp;the&nbsp;user's&nbsp;data&nbsp;and&nbsp;release&nbsp;the&nbsp;user's&nbsp;process&nbsp;to
&nbsp;*&nbsp;&nbsp;&nbsp;do&nbsp;other&nbsp;things&nbsp;(i.e.&nbsp;preparing&nbsp;more&nbsp;data).&nbsp;Internally&nbsp;we&nbsp;use&nbsp;a
&nbsp;*&nbsp;&nbsp;&nbsp;circular&nbsp;queue&nbsp;(rwQue)&nbsp;to&nbsp;store&nbsp;the&nbsp;data&nbsp;to&nbsp;be&nbsp;played&nbsp;or&nbsp;recorded.
&nbsp;*&nbsp;&nbsp;&nbsp;Each&nbsp;entry&nbsp;in&nbsp;this&nbsp;queue&nbsp;is&nbsp;of&nbsp;the&nbsp;type&nbsp;rwBuf_t&nbsp;where&nbsp;the&nbsp;data&nbsp;will
&nbsp;*&nbsp;&nbsp;&nbsp;be&nbsp;stored.&nbsp;&nbsp;Each&nbsp;entry&nbsp;can&nbsp;store&nbsp;up&nbsp;to&nbsp;RW_BUF_SIZE&nbsp;bytes&nbsp;of&nbsp;data.
&nbsp;*&nbsp;&nbsp;&nbsp;At&nbsp;the&nbsp;init&nbsp;time,&nbsp;we&nbsp;try&nbsp;to&nbsp;allocate&nbsp;two&nbsp;DMA&nbsp;channels&nbsp;for&nbsp;the&nbsp;card:
&nbsp;*&nbsp;&nbsp;&nbsp;Channel&nbsp;5&nbsp;and&nbsp;6.&nbsp;If&nbsp;we&nbsp;can&nbsp;only&nbsp;allocate&nbsp;Channel&nbsp;5,&nbsp;we&nbsp;will&nbsp;use&nbsp;the
&nbsp;*&nbsp;&nbsp;&nbsp;card&nbsp;in&nbsp;Mono&nbsp;mode,&nbsp;otherwise,&nbsp;we&nbsp;will&nbsp;use&nbsp;it&nbsp;as&nbsp;Stereo.&nbsp;DMA&nbsp;has&nbsp;two
&nbsp;*&nbsp;&nbsp;&nbsp;buffers&nbsp;of&nbsp;its&nbsp;own:&nbsp;dmaRigh[]&nbsp;and&nbsp;dmaLeft[]&nbsp;for&nbsp;each&nbsp;Channel.&nbsp;For
&nbsp;*&nbsp;&nbsp;&nbsp;Stereo&nbsp;play,&nbsp;the&nbsp;data&nbsp;user&nbsp;provides&nbsp;us&nbsp;is&nbsp;of&nbsp;the&nbsp;format:
&nbsp;*
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Left&nbsp;Byte>&lt;Right&nbsp;Byte>&lt;Left&nbsp;Byte>&lt;Right&nbsp;Byte>.....
&nbsp;*
&nbsp;*&nbsp;&nbsp;&nbsp;So&nbsp;for&nbsp;playing,&nbsp;we&nbsp;have&nbsp;to&nbsp;move&nbsp;all&nbsp;Left_Bytes&nbsp;to&nbsp;dmaLeft&nbsp;buffer
&nbsp;*&nbsp;&nbsp;&nbsp;and&nbsp;all&nbsp;Right_Bytes&nbsp;to&nbsp;the&nbsp;dmaRight&nbsp;buffer&nbsp;(in&nbsp;Stereo&nbsp;mode&nbsp;only).
&nbsp;*&nbsp;&nbsp;&nbsp;In&nbsp;mono&nbsp;mode,&nbsp;we&nbsp;will&nbsp;use&nbsp;dmaLeft[]&nbsp;buffer&nbsp;and&nbsp;all&nbsp;the&nbsp;user's&nbsp;data
&nbsp;*&nbsp;&nbsp;&nbsp;are&nbsp;moved&nbsp;to&nbsp;dmaLeft[].
&nbsp;*
&nbsp;*&nbsp;&nbsp;&nbsp;The&nbsp;basic&nbsp;operation&nbsp;of&nbsp;the&nbsp;Card&nbsp;are&nbsp;as&nbsp;follow:
&nbsp;*
&nbsp;*&nbsp;&nbsp;&nbsp;Playing:
&nbsp;*&nbsp;&nbsp;&nbsp;--------
&nbsp;*&nbsp;&nbsp;&nbsp;For&nbsp;playing&nbsp;wave&nbsp;data,&nbsp;the&nbsp;user&nbsp;must&nbsp;first&nbsp;open&nbsp;the&nbsp;card&nbsp;through
&nbsp;*&nbsp;&nbsp;&nbsp;open()&nbsp;system&nbsp;call.The&nbsp;call&nbsp;comes&nbsp;to&nbsp;us&nbsp;as&nbsp;rapopen().&nbsp;This
&nbsp;*&nbsp;&nbsp;&nbsp;routine&nbsp;resets&nbsp;all&nbsp;global&nbsp;values,&nbsp;states&nbsp;and&nbsp;counters,&nbsp;prepares
&nbsp;*&nbsp;&nbsp;&nbsp;necessary&nbsp;DMA&nbsp;structures&nbsp;for&nbsp;each&nbsp;channel,&nbsp;disables&nbsp;RAP-10
&nbsp;*&nbsp;&nbsp;&nbsp;interrupts&nbsp;and&nbsp;establishes&nbsp;this&nbsp;process&nbsp;as&nbsp;the&nbsp;owner&nbsp;of&nbsp;the&nbsp;card.
&nbsp;*
&nbsp;*&nbsp;&nbsp;&nbsp;The&nbsp;user&nbsp;provides&nbsp;us&nbsp;with&nbsp;the&nbsp;wave&nbsp;data&nbsp;by&nbsp;issuing&nbsp;write()
&nbsp;*&nbsp;&nbsp;&nbsp;system&nbsp;calls.&nbsp;This&nbsp;call&nbsp;comes&nbsp;to&nbsp;us&nbsp;as&nbsp;rapwrite().&nbsp;We&nbsp;will
&nbsp;*&nbsp;&nbsp;&nbsp;move&nbsp;the&nbsp;data&nbsp;from&nbsp;user's&nbsp;address&nbsp;space&nbsp;into&nbsp;an&nbsp;empty&nbsp;rwQue[]
&nbsp;*&nbsp;&nbsp;&nbsp;entry&nbsp;and&nbsp;will&nbsp;retrun&nbsp;so&nbsp;that&nbsp;the&nbsp;user&nbsp;can&nbsp;issue&nbsp;another&nbsp;call.
&nbsp;*&nbsp;&nbsp;&nbsp;If&nbsp;there&nbsp;is&nbsp;no&nbsp;DMA&nbsp;going,&nbsp;we&nbsp;will&nbsp;start&nbsp;one&nbsp;and&nbsp;the&nbsp;data&nbsp;will
&nbsp;*&nbsp;&nbsp;&nbsp;start&nbsp;to&nbsp;be&nbsp;moved&nbsp;to&nbsp;the&nbsp;Card&nbsp;to&nbsp;be&nbsp;played.
&nbsp;*&nbsp;&nbsp;&nbsp;The&nbsp;user&nbsp;can&nbsp;issue&nbsp;as&nbsp;many&nbsp;write()&nbsp;as&nbsp;necessary.&nbsp;The&nbsp;playing
&nbsp;*&nbsp;&nbsp;&nbsp;operation&nbsp;will&nbsp;be&nbsp;done&nbsp;by&nbsp;either&nbsp;closing&nbsp;the&nbsp;card&nbsp;or&nbsp;issuing
&nbsp;*&nbsp;&nbsp;&nbsp;an&nbsp;Ioctl&nbsp;call.&nbsp;Issuing&nbsp;Ioctl,&nbsp;will&nbsp;leave&nbsp;this&nbsp;process&nbsp;as&nbsp;owner
&nbsp;*&nbsp;&nbsp;&nbsp;still&nbsp;while&nbsp;closing&nbsp;the&nbsp;card&nbsp;will&nbsp;release&nbsp;the&nbsp;card.
&nbsp;*
&nbsp;*&nbsp;&nbsp;&nbsp;Recording:
&nbsp;*&nbsp;&nbsp;&nbsp;----------
&nbsp;*&nbsp;&nbsp;&nbsp;Assuming&nbsp;that&nbsp;the&nbsp;user&nbsp;has&nbsp;opened&nbsp;the&nbsp;card&nbsp;and&nbsp;is&nbsp;the&nbsp;current
&nbsp;*&nbsp;&nbsp;&nbsp;owner,&nbsp;user&nbsp;will&nbsp;issue&nbsp;read()&nbsp;system&nbsp;call.&nbsp;The&nbsp;call&nbsp;comes&nbsp;to
&nbsp;*&nbsp;&nbsp;&nbsp;us&nbsp;as&nbsp;rapread().&nbsp;If&nbsp;no&nbsp;DMA&nbsp;Record&nbsp;is&nbsp;going&nbsp;on,&nbsp;we&nbsp;will&nbsp;start
&nbsp;*&nbsp;&nbsp;&nbsp;one.&nbsp;We&nbsp;will&nbsp;move&nbsp;data&nbsp;from&nbsp;rwQue[]&nbsp;entries&nbsp;(as&nbsp;they&nbsp;are&nbsp;filled)
&nbsp;*&nbsp;&nbsp;&nbsp;to&nbsp;user's&nbsp;address&nbsp;space.&nbsp;The&nbsp;recording&nbsp;is&nbsp;done&nbsp;either&nbsp;by&nbsp;a
&nbsp;*&nbsp;&nbsp;&nbsp;close()&nbsp;or&nbsp;ioctl()&nbsp;call.
&nbsp;*
&nbsp;*&nbsp;&nbsp;&nbsp;DMA&nbsp;Starting:
&nbsp;*&nbsp;&nbsp;&nbsp;-------------
&nbsp;*&nbsp;&nbsp;&nbsp;For&nbsp;Playing,&nbsp;we&nbsp;will&nbsp;start&nbsp;DMA&nbsp;when&nbsp;we&nbsp;have&nbsp;a&nbsp;full&nbsp;circular&nbsp;buffer.
&nbsp;*&nbsp;&nbsp;&nbsp;This&nbsp;is&nbsp;done&nbsp;so&nbsp;that&nbsp;we&nbsp;have&nbsp;enough&nbsp;data&nbsp;available&nbsp;for&nbsp;a&nbsp;fast&nbsp;DMA
&nbsp;*&nbsp;&nbsp;&nbsp;operation&nbsp;to&nbsp;be&nbsp;busy&nbsp;with.&nbsp;For&nbsp;recording,&nbsp;we&nbsp;will&nbsp;start&nbsp;DMA
&nbsp;*&nbsp;&nbsp;&nbsp;immediatly.
&nbsp;*
&nbsp;*&nbsp;&nbsp;&nbsp;Interrupts:
&nbsp;*&nbsp;&nbsp;&nbsp;-----------
&nbsp;*&nbsp;&nbsp;&nbsp;For&nbsp;each&nbsp;DMA&nbsp;transfer,&nbsp;we&nbsp;will&nbsp;receive&nbsp;two&nbsp;interrupts:&nbsp;One&nbsp;when&nbsp;1st
&nbsp;*&nbsp;&nbsp;&nbsp;half&nbsp;the&nbsp;buffer&nbsp;is&nbsp;transfered,&nbsp;one&nbsp;when&nbsp;2nd&nbsp;half&nbsp;of&nbsp;the&nbsp;buffer&nbsp;is
&nbsp;*&nbsp;&nbsp;&nbsp;transfered.&nbsp;&nbsp;We&nbsp;must&nbsp;fill&nbsp;the&nbsp;half&nbsp;that&nbsp;has&nbsp;just&nbsp;been&nbsp;transfered&nbsp;with
&nbsp;*&nbsp;&nbsp;&nbsp;fresh&nbsp;data.&nbsp;&nbsp;Note&nbsp;that&nbsp;in&nbsp;Stereo&nbsp;mode,&nbsp;there&nbsp;are&nbsp;two&nbsp;DMA&nbsp;operation
&nbsp;*&nbsp;&nbsp;&nbsp;going.&nbsp;So&nbsp;when&nbsp;we&nbsp;receive&nbsp;Interrupt&nbsp;for&nbsp;one&nbsp;DMA,&nbsp;we&nbsp;must&nbsp;wait&nbsp;for&nbsp;the
&nbsp;*&nbsp;&nbsp;&nbsp;exact&nbsp;interrupt&nbsp;from&nbsp;the&nbsp;other&nbsp;DMA&nbsp;and&nbsp;service&nbsp;both&nbsp;DMA's&nbsp;half&nbsp;buffers.
&nbsp;*
&nbsp;*&nbsp;&nbsp;&nbsp;Card&nbsp;Address&nbsp;and&nbsp;IRQ
&nbsp;*&nbsp;&nbsp;&nbsp;--------------------
&nbsp;*&nbsp;&nbsp;&nbsp;We&nbsp;will&nbsp;use&nbsp;the&nbsp;default&nbsp;bus&nbsp;address&nbsp;of&nbsp;0x330&nbsp;and&nbsp;IRQ&nbsp;5.&nbsp;Change&nbsp;in
&nbsp;*&nbsp;&nbsp;&nbsp;bus&nbsp;address&nbsp;should&nbsp;also&nbsp;be&nbsp;reflected&nbsp;in&nbsp;/var/sysgen/system/rap.sm
&nbsp;*&nbsp;&nbsp;&nbsp;file.&nbsp;&nbsp;Changes&nbsp;in&nbsp;IRQ&nbsp;should&nbsp;be&nbsp;reflected&nbsp;in&nbsp;the&nbsp;source&nbsp;code&nbsp;and
&nbsp;*&nbsp;&nbsp;&nbsp;the&nbsp;program&nbsp;must&nbsp;be&nbsp;recomplied.
&nbsp;*
&nbsp;*&nbsp;&nbsp;&nbsp;ISSUES:
&nbsp;*&nbsp;&nbsp;&nbsp;-------
&nbsp;*&nbsp;&nbsp;&nbsp;1.&nbsp;The&nbsp;DMA&nbsp;processing&nbsp;and&nbsp;transfer&nbsp;of&nbsp;data&nbsp;from/to&nbsp;user's&nbsp;buffer
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;are&nbsp;independent&nbsp;of&nbsp;each&nbsp;other.&nbsp;When&nbsp;we&nbsp;are&nbsp;servicing&nbsp;the
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one&nbsp;half&nbsp;of&nbsp;the&nbsp;dma&nbsp;buffer&nbsp;that&nbsp;just&nbsp;been&nbsp;transfered,&nbsp;there&nbsp;is
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;no&nbsp;guarantee&nbsp;that&nbsp;we&nbsp;can&nbsp;fill&nbsp;that&nbsp;half&nbsp;of&nbsp;the&nbsp;buffer&nbsp;BEFORE
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dma&nbsp;is&nbsp;done&nbsp;with&nbsp;the&nbsp;other&nbsp;half.&nbsp;In&nbsp;this&nbsp;case,&nbsp;dma&nbsp;plays&nbsp;the
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fist&nbsp;half&nbsp;of&nbsp;buffer&nbsp;WHILE&nbsp;we&nbsp;are&nbsp;writing&nbsp;into&nbsp;it.
&nbsp;*
&nbsp;*&nbsp;&nbsp;&nbsp;2.&nbsp;Currently&nbsp;eisa_dma_disable()&nbsp;routine&nbsp;does&nbsp;not&nbsp;actually
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;releases&nbsp;the&nbsp;Dma&nbsp;channels.&nbsp;This&nbsp;is&nbsp;the&nbsp;reason&nbsp;why&nbsp;we&nbsp;access
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;Dma&nbsp;channel&nbsp;table&nbsp;(e_ch[])&nbsp;ourselves&nbsp;and&nbsp;release&nbsp;the
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;channel.
&nbsp;*
&nbsp;*&nbsp;&nbsp;&nbsp;3.&nbsp;Somehow&nbsp;because&nbsp;of&nbsp;number&nbsp;2,&nbsp;the&nbsp;Play&nbsp;program&nbsp;cannot&nbsp;be
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stopped&nbsp;with&nbsp;a&nbsp;Ctrl-C.&nbsp;In&nbsp;Play&nbsp;program&nbsp;this&nbsp;signal&nbsp;is
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;explicitly&nbsp;ignored.&nbsp;Trapping&nbsp;a&nbsp;Ctrl-C&nbsp;causes&nbsp;a&nbsp;kernel&nbsp;panic.
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Once&nbsp;we&nbsp;have&nbsp;a&nbsp;workable&nbsp;eisa_dma_disable(),&nbsp;this&nbsp;problem&nbsp;will
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;be&nbsp;resolved.
&nbsp;*
&nbsp;*&nbsp;&nbsp;&nbsp;TECHNICAL&nbsp;REFERENCES:
&nbsp;*&nbsp;&nbsp;&nbsp;---------------------
&nbsp;*&nbsp;&nbsp;&nbsp;Roland&nbsp;RAP-10&nbsp;Technical&nbsp;Reference&nbsp;and&nbsp;Programmer's&nbsp;Guide,&nbsp;Ver.&nbsp;1.1
&nbsp;*&nbsp;&nbsp;&nbsp;IRIX&nbsp;Device&nbsp;Driver&nbsp;Programming&nbsp;Guide
&nbsp;*&nbsp;&nbsp;&nbsp;IRIX&nbsp;Device&nbsp;Driver&nbsp;Reference&nbsp;Pages.
&nbsp;*&nbsp;&nbsp;&nbsp;Intel&nbsp;82357&nbsp;Preliminary&nbsp;Reference,&nbsp;Section:&nbsp;3.7.8&nbsp;Mode&nbsp;Register&nbsp;(pp:&nbsp;223)
&nbsp;*
&nbsp;******************************************************************************
&nbsp;***&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;***
&nbsp;***&nbsp;&nbsp;&nbsp;Copyright&nbsp;1994,&nbsp;Silicon&nbsp;Graphics&nbsp;Inc.,&nbsp;Mountain&nbsp;View,&nbsp;CA.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;***
&nbsp;***&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;***
&nbsp;******************************************************************************
&nbsp;*/
#include&nbsp;&ldquo;sys/types.h&rdquo;
#include&nbsp;&ldquo;sys/file.h&rdquo;
#include&nbsp;&ldquo;sys/errno.h&rdquo;
#include&nbsp;&ldquo;sys/open.h&rdquo;
#include&nbsp;&ldquo;sys/conf.h&rdquo;
#include&nbsp;&ldquo;sys/cmn_err.h&rdquo;
#include&nbsp;&ldquo;sys/debug.h&rdquo;
#include&nbsp;&ldquo;sys/param.h&rdquo;
#include&nbsp;&ldquo;sys/edt.h&rdquo;
#include&nbsp;&ldquo;sys/pio.h&rdquo;
#include&nbsp;&ldquo;sys/uio.h&rdquo;
#include&nbsp;&ldquo;sys/proc.h&rdquo;
#include&nbsp;&ldquo;sys/user.h&rdquo;
#include&nbsp;&ldquo;sys/eisa.h&rdquo;
#include&nbsp;&ldquo;sys/sema.h&rdquo;
#include&nbsp;&ldquo;sys/buf.h&rdquo;
#include&nbsp;&ldquo;sys/cred.h&rdquo;
#include&nbsp;&ldquo;sys/kmem.h&rdquo;
#include&nbsp;&ldquo;sys/ddi.h&rdquo;
#include&nbsp;&ldquo;./rap.h&rdquo;
/*
&nbsp;*&nbsp;&nbsp;Macros&nbsp;to&nbsp;Read/Write&nbsp;8&nbsp;and&nbsp;16-bit&nbsp;values&nbsp;from&nbsp;an&nbsp;address
&nbsp;*/
#define&nbsp;OUTB(addr,&nbsp;b)&nbsp;&nbsp;(&nbsp;*(volatile&nbsp;uchar_t&nbsp;*)(addr)&nbsp;=&nbsp;(b)&nbsp;)
#define&nbsp;INPB(addr)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;*(volatile&nbsp;uchar_t&nbsp;*)(addr)&nbsp;)
#define&nbsp;OUTW(addr,&nbsp;w)&nbsp;&nbsp;(&nbsp;*(volatile&nbsp;ushort_t&nbsp;*)(addr)&nbsp;=&nbsp;(w)&nbsp;)
#define&nbsp;INPW(addr)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;*(volatile&nbsp;ushort_t&nbsp;*)(addr)&nbsp;)
/*
&nbsp;*&nbsp;&nbsp;Raising&nbsp;and&nbsp;lowering&nbsp;CPU&nbsp;interrupt
&nbsp;*/
#define&nbsp;LOCK()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spl5()
#define&nbsp;UNLOCK(s)&nbsp;&nbsp;splx(s)
#define&nbsp;FROM_INTR&nbsp;&nbsp;1
#define&nbsp;FROM_USR&nbsp;&nbsp;&nbsp;0
#define&nbsp;User_pid&nbsp;&nbsp;&nbsp;u.u_procp->p_pid
/*
&nbsp;*&nbsp;&nbsp;&nbsp;IRQ&nbsp;and&nbsp;DMA&nbsp;channels&nbsp;we&nbsp;need.
&nbsp;*
&nbsp;*/
#define&nbsp;IRQ_MASK&nbsp;&nbsp;&nbsp;&nbsp;0x0020
#define&nbsp;DMAC_CH5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;DMA&nbsp;Channel&nbsp;5&nbsp;&nbsp;&nbsp;*/
#define&nbsp;DMAC_CH6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;DMA&nbsp;Channel&nbsp;6&nbsp;&nbsp;&nbsp;*/
/*=======================================*
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MIDI&nbsp;and&nbsp;RAP&nbsp;Registers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;*=======================================*
&nbsp;*
&nbsp;*&nbsp;&nbsp;The&nbsp;following&nbsp;is&nbsp;a&nbsp;description&nbsp;of&nbsp;RAP-10&nbsp;registers.&nbsp;The&nbsp;same
&nbsp;*&nbsp;&nbsp;names&nbsp;used&nbsp;throughout&nbsp;this&nbsp;program.&nbsp;Some&nbsp;of&nbsp;these&nbsp;registers&nbsp;are
&nbsp;*&nbsp;&nbsp;8-bit&nbsp;and&nbsp;some&nbsp;are&nbsp;16-bit&nbsp;long.
&nbsp;*
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mdrd:&nbsp;&nbsp;&nbsp;&nbsp;MIDI&nbsp;Receive&nbsp;Data
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mdtd:&nbsp;&nbsp;&nbsp;&nbsp;MIDI&nbsp;Transmit&nbsp;Data
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mdst:&nbsp;&nbsp;&nbsp;&nbsp;MIDI&nbsp;Status
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mdcm:&nbsp;&nbsp;&nbsp;&nbsp;MIDI&nbsp;Command
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pwmd:&nbsp;&nbsp;&nbsp;&nbsp;Pulse&nbsp;Width&nbsp;Modulation&nbsp;Data
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timm:&nbsp;&nbsp;&nbsp;&nbsp;Timer&nbsp;MSB&nbsp;data
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpcm:&nbsp;&nbsp;&nbsp;&nbsp;GPCC&nbsp;Command
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dtci:&nbsp;&nbsp;&nbsp;&nbsp;DMA&nbsp;Transfer&nbsp;Count&nbsp;Buffer&nbsp;Interrupt&nbsp;Status
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adcm:&nbsp;&nbsp;&nbsp;&nbsp;GPCC&nbsp;Analog&nbsp;to&nbsp;Digital&nbsp;Command
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dacm:&nbsp;&nbsp;&nbsp;&nbsp;D/A&nbsp;Command&nbsp;and&nbsp;DMA&nbsp;Transfer&nbsp;Configuration
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpis:&nbsp;&nbsp;&nbsp;&nbsp;GPCC&nbsp;Interrupt&nbsp;Status
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpdi:&nbsp;&nbsp;&nbsp;&nbsp;GPCC&nbsp;DMA/Interrupt&nbsp;Enable
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpst:&nbsp;&nbsp;&nbsp;&nbsp;GPCC&nbsp;Status
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dad0:&nbsp;&nbsp;&nbsp;&nbsp;Digital&nbsp;to&nbsp;Analog&nbsp;Data&nbsp;Channel&nbsp;0
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addt:&nbsp;&nbsp;&nbsp;&nbsp;A/D&nbsp;Data&nbsp;Transfer
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dad1:&nbsp;&nbsp;&nbsp;&nbsp;Digital&nbsp;to&nbsp;Analog&nbsp;Data&nbsp;Channel&nbsp;1
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timd:&nbsp;&nbsp;&nbsp;&nbsp;Timer&nbsp;Data
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmp0:&nbsp;&nbsp;&nbsp;&nbsp;Compare&nbsp;Register&nbsp;Channel&nbsp;0
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dtcd:&nbsp;&nbsp;&nbsp;&nbsp;DMA&nbsp;Transfer&nbsp;Count&nbsp;Data
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmp1:&nbsp;&nbsp;&nbsp;&nbsp;Compare&nbsp;Register&nbsp;Channel&nbsp;1
&nbsp;*
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;These&nbsp;defines&nbsp;indicate&nbsp;the&nbsp;offsets&nbsp;of&nbsp;the&nbsp;above&nbsp;registers
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;the&nbsp;Drive's&nbsp;base&nbsp;address:
&nbsp;*/
#define&nbsp;MDRD&nbsp;&nbsp;&nbsp;&nbsp;0x0
#define&nbsp;MDTD&nbsp;&nbsp;&nbsp;&nbsp;0x0
#define&nbsp;MDST&nbsp;&nbsp;&nbsp;&nbsp;0x1
#define&nbsp;MDCM&nbsp;&nbsp;&nbsp;&nbsp;0x1
#define&nbsp;PWMD&nbsp;&nbsp;&nbsp;&nbsp;0x2
#define&nbsp;TIMM&nbsp;&nbsp;&nbsp;&nbsp;0x3
#define&nbsp;GPCM&nbsp;&nbsp;&nbsp;&nbsp;0x3
#define&nbsp;DTCI&nbsp;&nbsp;&nbsp;&nbsp;0x4
#define&nbsp;ADCM&nbsp;&nbsp;&nbsp;&nbsp;0x4
#define&nbsp;DACM&nbsp;&nbsp;&nbsp;&nbsp;0x5
#define&nbsp;GPIS&nbsp;&nbsp;&nbsp;&nbsp;0x6
#define&nbsp;GPDI&nbsp;&nbsp;&nbsp;&nbsp;0x6
#define&nbsp;GPST&nbsp;&nbsp;&nbsp;&nbsp;0x8
#define&nbsp;DAD0&nbsp;&nbsp;&nbsp;&nbsp;0x8
#define&nbsp;ADDT&nbsp;&nbsp;&nbsp;&nbsp;0xa
#define&nbsp;DAD1&nbsp;&nbsp;&nbsp;&nbsp;0xa
#define&nbsp;TIMD&nbsp;&nbsp;&nbsp;&nbsp;0xc
#define&nbsp;CMP0&nbsp;&nbsp;&nbsp;&nbsp;0xc
#define&nbsp;DTCD&nbsp;&nbsp;&nbsp;&nbsp;0xe
#define&nbsp;CMP1&nbsp;&nbsp;&nbsp;&nbsp;0xe
&nbsp;
typedef&nbsp;struct&nbsp;rapReg&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;mdrd;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;mdtd;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;mdst;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;mdcm;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;pwmd;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;timm;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;gpcm;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;dtci;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;adcm;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;dacm;
&nbsp;&nbsp;&nbsp;&nbsp;ushort_t&nbsp;gpis;
&nbsp;&nbsp;&nbsp;&nbsp;ushort_t&nbsp;gpdi;
&nbsp;&nbsp;&nbsp;&nbsp;ushort_t&nbsp;gpst;
&nbsp;&nbsp;&nbsp;&nbsp;ushort_t&nbsp;dad0;
&nbsp;&nbsp;&nbsp;&nbsp;ushort_t&nbsp;addt;
&nbsp;&nbsp;&nbsp;&nbsp;ushort_t&nbsp;dad1;
&nbsp;&nbsp;&nbsp;&nbsp;ushort_t&nbsp;timd;
&nbsp;&nbsp;&nbsp;&nbsp;ushort_t&nbsp;cmp0;
&nbsp;&nbsp;&nbsp;&nbsp;ushort_t&nbsp;dtcd;
&nbsp;&nbsp;&nbsp;&nbsp;ushort_t&nbsp;cmp1;
}&nbsp;rapReg_t;
/*==========================================================*
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dtct&nbsp;&nbsp;(DMA&nbsp;Transfer&nbsp;Count)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;*==========================================================*/
#define&nbsp;DTCD_DRQ0&nbsp;&nbsp;0x00FF&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;DRQ&nbsp;0&nbsp;bits&nbsp;(0-7)&nbsp;&nbsp;*/
#define&nbsp;DTCD_DRQ1&nbsp;&nbsp;0xFF00&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;DRQ&nbsp;1&nbsp;bits&nbsp;(8-15)&nbsp;*/
/*==========================================================*
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpst&nbsp;&nbsp;(GPCC&nbsp;Status)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;*==========================================================*/
#define&nbsp;GPST_PWM2&nbsp;0x0800&nbsp;&nbsp;/*&nbsp;PWM2&nbsp;Busy&nbsp;(0=Write&nbsp;Enable,&nbsp;1=Busy)&nbsp;*/
#define&nbsp;GPST_PWM1&nbsp;0x0400&nbsp;&nbsp;/*&nbsp;PWM1&nbsp;Busy&nbsp;(0=Write&nbsp;Enable,&nbsp;1=Busy)&nbsp;*/
#define&nbsp;GPST_PWM0&nbsp;0x0200&nbsp;&nbsp;/*&nbsp;PWM0&nbsp;Busy&nbsp;(0=Write&nbsp;Enable,&nbsp;1=Busy)&nbsp;*/
#define&nbsp;GPST_EPB&nbsp;&nbsp;0x0100&nbsp;&nbsp;/*&nbsp;EP&nbsp;Convertor&nbsp;Busy&nbsp;(0=Write&nbsp;Enable,&nbsp;1=Busy)&nbsp;*/
#define&nbsp;GPST_GP1&nbsp;&nbsp;0x0080&nbsp;&nbsp;/*&nbsp;GP-chip,&nbsp;Ch&nbsp;1&nbsp;Acess&nbsp;(1&nbsp;=&nbsp;Access)&nbsp;&nbsp;&nbsp;*/
#define&nbsp;GPST_GP0&nbsp;&nbsp;0x0040&nbsp;&nbsp;/*&nbsp;GP-chip,&nbsp;Ch&nbsp;0&nbsp;Acess&nbsp;(1&nbsp;=&nbsp;Access)&nbsp;&nbsp;&nbsp;*/
#define&nbsp;GPST_MTE&nbsp;&nbsp;0x0020&nbsp;&nbsp;/*&nbsp;MIDI&nbsp;Tx&nbsp;Enable&nbsp;(0=Tx_Fifo&nbsp;buff&nbsp;full)&nbsp;*/
#define&nbsp;GPST_ORE&nbsp;&nbsp;0x0010&nbsp;&nbsp;/*&nbsp;MIDI&nbsp;Overrun&nbsp;Error&nbsp;(1&nbsp;=&nbsp;error)&nbsp;*/
#define&nbsp;GPST_FE&nbsp;&nbsp;&nbsp;0x0008&nbsp;&nbsp;/*&nbsp;MIDI&nbsp;Framing&nbsp;Error&nbsp;(1&nbsp;=&nbsp;error)&nbsp;*/
#define&nbsp;GPST_ADE&nbsp;&nbsp;0x0004&nbsp;&nbsp;/*&nbsp;A/D&nbsp;Error&nbsp;(1&nbsp;=&nbsp;error)&nbsp;*/
#define&nbsp;GPST_DE1&nbsp;&nbsp;0x0002&nbsp;&nbsp;/*&nbsp;D/A&nbsp;Ch&nbsp;1&nbsp;Write&nbsp;Error&nbsp;(1&nbsp;=&nbsp;error)&nbsp;*/
#define&nbsp;GPST_DE0&nbsp;&nbsp;0x0001&nbsp;&nbsp;/*&nbsp;D/A&nbsp;Ch&nbsp;0&nbsp;Write&nbsp;Error&nbsp;(1&nbsp;=&nbsp;error)&nbsp;*/
/*==========================================================*
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpdi&nbsp;&nbsp;(GPCC&nbsp;DMA/Interrupt&nbsp;Enable&nbsp;(pp:&nbsp;4-18)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;*==========================================================*/
#define&nbsp;GPDI_ITC&nbsp;&nbsp;0x8000&nbsp;&nbsp;/*&nbsp;DMA&nbsp;Transfer&nbsp;Cnt&nbsp;Match&nbsp;(0=Disable)&nbsp;*/
#define&nbsp;GPDI_DC2&nbsp;&nbsp;0x4000&nbsp;&nbsp;/*&nbsp;DMA&nbsp;Chann.&nbsp;Assignment,&nbsp;bit2&nbsp;(pp:4-18)&nbsp;*/
#define&nbsp;GPDI_DC1&nbsp;&nbsp;0x2000&nbsp;&nbsp;/*&nbsp;DMA&nbsp;Chann.&nbsp;Assignment,&nbsp;bit1&nbsp;(pp:4-18)&nbsp;*/
#define&nbsp;GPDI_DC0&nbsp;&nbsp;0x1000&nbsp;&nbsp;/*&nbsp;DMA&nbsp;Chann.&nbsp;Assignment,&nbsp;bit0&nbsp;(pp:4-18)&nbsp;*/
#define&nbsp;GPDI_DT1&nbsp;&nbsp;0x0800&nbsp;&nbsp;/*&nbsp;DMA&nbsp;Trans.&nbsp;Mode,&nbsp;bit:1&nbsp;(pp:&nbsp;4-18)&nbsp;*/
#define&nbsp;GPDI_DT0&nbsp;&nbsp;0x0400&nbsp;&nbsp;/*&nbsp;DMA&nbsp;Trans.&nbsp;Mode,&nbsp;bit:0&nbsp;(pp:&nbsp;4-18)&nbsp;*/
#define&nbsp;GPDI_OVF&nbsp;&nbsp;0x0200&nbsp;&nbsp;/*&nbsp;Free&nbsp;Run.Cntr&nbsp;(FCR)&nbsp;Ov.Flow&nbsp;(0=Disable)*/
#define&nbsp;GPDI_TC1&nbsp;&nbsp;0x0100&nbsp;&nbsp;/*&nbsp;Timer&nbsp;1&nbsp;Compare&nbsp;Match&nbsp;(0=Disable)&nbsp;*/
#define&nbsp;GPDI_TC0&nbsp;&nbsp;0x0080&nbsp;&nbsp;/*&nbsp;Timer&nbsp;0&nbsp;Compare&nbsp;Match&nbsp;(0=Disable)&nbsp;*/
#define&nbsp;GPDI_RXD&nbsp;&nbsp;0x0040&nbsp;&nbsp;/*&nbsp;MIDI&nbsp;Data&nbsp;Read&nbsp;Request&nbsp;(0=Disable)&nbsp;*/
#define&nbsp;GPDI_TXD&nbsp;&nbsp;0x0020&nbsp;&nbsp;/*&nbsp;MIDI&nbsp;Tx_fifo&nbsp;Buf&nbsp;Empty&nbsp;(0=Disable)&nbsp;*/
#define&nbsp;GPDI_ADD&nbsp;&nbsp;0x0010&nbsp;&nbsp;/*&nbsp;A/D&nbsp;Data&nbsp;Ready&nbsp;(0=Disable)&nbsp;&nbsp;*/
#define&nbsp;GPDI_DN1&nbsp;&nbsp;0x0008&nbsp;&nbsp;/*&nbsp;D/A&nbsp;Ch1&nbsp;Note&nbsp;ON&nbsp;Ready&nbsp;(0=Disable)&nbsp;*/
#define&nbsp;GPDI_DN0&nbsp;&nbsp;0x0004&nbsp;&nbsp;/*&nbsp;D/A&nbsp;Ch0&nbsp;Note&nbsp;ON&nbsp;Ready&nbsp;(0=Disable)&nbsp;*/
#define&nbsp;GPDI_DQ1&nbsp;&nbsp;0x0002&nbsp;&nbsp;/*&nbsp;D/A&nbsp;Ch1&nbsp;Data&nbsp;Request&nbsp;&nbsp;(0=Disable)&nbsp;*/
#define&nbsp;GPDI_DQ0&nbsp;&nbsp;0x0001&nbsp;&nbsp;/*&nbsp;D/A&nbsp;Ch0&nbsp;Data&nbsp;Request&nbsp;&nbsp;(0=Disable)&nbsp;*/
/*==========================================================*
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpis&nbsp;&nbsp;(GPCC&nbsp;Interrupt&nbsp;Status&nbsp;..&nbsp;pp:&nbsp;4-16)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;*==========================================================*/
#define&nbsp;GPIS_ITC&nbsp;&nbsp;0x8000&nbsp;&nbsp;/*&nbsp;&nbsp;DMA&nbsp;Transfer&nbsp;Count&nbsp;Match&nbsp;&nbsp;&nbsp;*/
#define&nbsp;GPIS_JSD&nbsp;&nbsp;0x0400&nbsp;&nbsp;/*&nbsp;&nbsp;Joystick&nbsp;Data&nbsp;Ready&nbsp;*/
#define&nbsp;GPIS_OVF&nbsp;&nbsp;0x0200&nbsp;&nbsp;/*&nbsp;&nbsp;Free&nbsp;Running&nbsp;Countr&nbsp;Overflow&nbsp;*/
#define&nbsp;GPIS_TC1&nbsp;&nbsp;0x0100&nbsp;&nbsp;/*&nbsp;&nbsp;Timer1&nbsp;Compare&nbsp;Match&nbsp;*/
#define&nbsp;GPIS_TC0&nbsp;&nbsp;0x0080&nbsp;&nbsp;/*&nbsp;&nbsp;Timer0&nbsp;Compare&nbsp;Match&nbsp;*/
#define&nbsp;GPIS_RXD&nbsp;&nbsp;0x0040&nbsp;&nbsp;/*&nbsp;&nbsp;MIDI&nbsp;Data&nbsp;Read&nbsp;Request&nbsp;*/
#define&nbsp;GPIS_TXD&nbsp;&nbsp;0x0020&nbsp;&nbsp;/*&nbsp;&nbsp;MIDI&nbsp;Tx_fifo&nbsp;Buf.&nbsp;Empty&nbsp;*/
#define&nbsp;GPIS_ADD&nbsp;&nbsp;0x0010&nbsp;&nbsp;/*&nbsp;&nbsp;A/D&nbsp;Data&nbsp;Ready&nbsp;*/
#define&nbsp;GPIS_DN1&nbsp;&nbsp;0x0008&nbsp;&nbsp;/*&nbsp;&nbsp;D/A&nbsp;Ch1&nbsp;Note&nbsp;ON&nbsp;Ready&nbsp;*/
#define&nbsp;GPIS_DN0&nbsp;&nbsp;0x0004&nbsp;&nbsp;/*&nbsp;&nbsp;D/A&nbsp;Ch0&nbsp;Note&nbsp;ON&nbsp;Ready&nbsp;*/
#define&nbsp;GPIS_DQ1&nbsp;&nbsp;0x0002&nbsp;&nbsp;/*&nbsp;&nbsp;D/A&nbsp;Ch1&nbsp;Data&nbsp;Request&nbsp;*/
#define&nbsp;GPIS_DQ0&nbsp;&nbsp;0x0001&nbsp;&nbsp;/*&nbsp;&nbsp;D/A&nbsp;Ch0&nbsp;Data&nbsp;Request&nbsp;*/
/*===================================================================*
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dacm&nbsp;(Digital&nbsp;To&nbsp;Analogue&nbsp;Cmd&nbsp;and&nbsp;DMA&nbsp;Transfer&nbsp;Config)&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;*===================================================================*/
#define&nbsp;DACM_SCC&nbsp;&nbsp;&nbsp;0x80&nbsp;&nbsp;/*&nbsp;DMA&nbsp;Size&nbsp;Cmp.&nbsp;Cnt&nbsp;(0=in&nbsp;Sample,&nbsp;1=in&nbsp;Bytes)*/
#define&nbsp;DACM_TS2&nbsp;&nbsp;&nbsp;0x40&nbsp;&nbsp;/*&nbsp;DMA&nbsp;Trnsfr&nbsp;Size,&nbsp;bit&nbsp;2&nbsp;(pp:&nbsp;4-14)&nbsp;*/
#define&nbsp;DACM_TS1&nbsp;&nbsp;&nbsp;0x20&nbsp;&nbsp;/*&nbsp;DMA&nbsp;Trnsfr&nbsp;Size,&nbsp;bit&nbsp;1&nbsp;(pp:&nbsp;4-14)&nbsp;*/
#define&nbsp;DACM_TS0&nbsp;&nbsp;&nbsp;0x10&nbsp;&nbsp;/*&nbsp;DMA&nbsp;Trnsfr&nbsp;Size,&nbsp;bit&nbsp;0&nbsp;(pp:&nbsp;4-14)&nbsp;*/
#define&nbsp;DACM_DL1&nbsp;&nbsp;&nbsp;0x08&nbsp;&nbsp;/*&nbsp;Ch1&nbsp;DA&nbsp;Data&nbsp;Len&nbsp;(0=8&nbsp;bit,&nbsp;1=17&nbsp;bit)&nbsp;*/
#define&nbsp;DACM_DL0&nbsp;&nbsp;&nbsp;0x04&nbsp;&nbsp;/*&nbsp;Ch0&nbsp;DA&nbsp;Data&nbsp;Len&nbsp;(0=8&nbsp;bit,&nbsp;1=17&nbsp;bit)&nbsp;*/
#define&nbsp;DACM_DS1&nbsp;&nbsp;&nbsp;0x02&nbsp;&nbsp;/*&nbsp;Ch1&nbsp;DA&nbsp;Convrsion&nbsp;(0=Stop,&nbsp;1=Start)&nbsp;*/
#define&nbsp;DACM_DS0&nbsp;&nbsp;&nbsp;0x01&nbsp;&nbsp;/*&nbsp;Ch0&nbsp;DA&nbsp;Convrsion&nbsp;(0=Stop,&nbsp;1=Start)&nbsp;*/
/*=====================================================*
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adcm&nbsp;(&nbsp;&nbsp;GPCC&nbsp;AD&nbsp;Command&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;*=====================================================*/
#define&nbsp;&nbsp;ADCM_MON&nbsp;&nbsp;&nbsp;&nbsp;0x40&nbsp;&nbsp;/*&nbsp;Monitor&nbsp;MIC&nbsp;(0=Monitor&nbsp;Off)&nbsp;*/
#define&nbsp;&nbsp;ADCM_GIN&nbsp;&nbsp;&nbsp;&nbsp;0x20&nbsp;&nbsp;/*&nbsp;Gain&nbsp;Input&nbsp;(0=Line,&nbsp;1=Mic)&nbsp;*/
#define&nbsp;&nbsp;ADCM_AF1&nbsp;&nbsp;&nbsp;&nbsp;0x10&nbsp;&nbsp;/*&nbsp;Analog&nbsp;Freq&nbsp;Selection&nbsp;bit&nbsp;1&nbsp;(pp:&nbsp;4-13)&nbsp;*/
#define&nbsp;&nbsp;ADCM_AF0&nbsp;&nbsp;&nbsp;&nbsp;0x08&nbsp;&nbsp;/*&nbsp;Analog&nbsp;Freq&nbsp;Selection&nbsp;bit&nbsp;0&nbsp;(pp:&nbsp;4-13)&nbsp;*/
#define&nbsp;&nbsp;ADCM_ADL&nbsp;&nbsp;&nbsp;&nbsp;0x04&nbsp;&nbsp;/*&nbsp;Analog&nbsp;Data&nbsp;Length&nbsp;(0=8,&nbsp;1=16)&nbsp;*/
#define&nbsp;&nbsp;ADCM_ADM&nbsp;&nbsp;&nbsp;&nbsp;0x02&nbsp;&nbsp;/*&nbsp;Analog&nbsp;Data&nbsp;Conv.&nbsp;Mode&nbsp;(0=Mono,1=Stereo)&nbsp;*/
#define&nbsp;&nbsp;ADCM_ADS&nbsp;&nbsp;&nbsp;&nbsp;0x01&nbsp;&nbsp;/*&nbsp;Analog&nbsp;Data&nbsp;Conv.&nbsp;Start(0=Stop,1=Start)&nbsp;*/
/*=====================================================*
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dtci&nbsp;(&nbsp;DMA&nbsp;Trans.Count&nbsp;Buf&nbsp;Intr.&nbsp;Stat&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;*=====================================================*/
#define&nbsp;DTCI_BF1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x08&nbsp;&nbsp;/*&nbsp;DMA&nbsp;DRQ1&nbsp;buff&nbsp;full&nbsp;(1&nbsp;=&nbsp;full)&nbsp;*/
#define&nbsp;DTCI_BH1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x04&nbsp;&nbsp;/*&nbsp;DMA&nbsp;DRQ1&nbsp;buff&nbsp;half&nbsp;(1&nbsp;=&nbsp;full)&nbsp;*/
#define&nbsp;DTCI_BF0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x02&nbsp;&nbsp;/*&nbsp;DMA&nbsp;DRQ0&nbsp;buff&nbsp;full&nbsp;(1&nbsp;=&nbsp;full)&nbsp;*/
#define&nbsp;DTCI_BH0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x01&nbsp;&nbsp;/*&nbsp;DMA&nbsp;DRQ0&nbsp;buff&nbsp;half&nbsp;(1&nbsp;=&nbsp;full)&nbsp;*/
/*========================================*
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpcm&nbsp;&nbsp;(&nbsp;GPCC&nbsp;Command&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;*========================================*/
#define&nbsp;GPCM_RST&nbsp;&nbsp;&nbsp;0x80&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;Reset&nbsp;bit&nbsp;*/
#define&nbsp;GPCM_PWM2&nbsp;&nbsp;0x10&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;Select&nbsp;PWM&nbsp;channel&nbsp;2&nbsp;*/
#define&nbsp;GPCM_PWM1&nbsp;&nbsp;0x08&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;Select&nbsp;PWM&nbsp;channel&nbsp;1&nbsp;*/
#define&nbsp;GPCM_PWM0&nbsp;&nbsp;0x04&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;Select&nbsp;PWM&nbsp;channel&nbsp;0&nbsp;*/
#define&nbsp;GPCM_FRCM&nbsp;&nbsp;0x02&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;Free&nbsp;Run.&nbsp;Counter&nbsp;(1=Start)&nbsp;*/
#define&nbsp;GPCM_MTT&nbsp;&nbsp;&nbsp;0x01&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;MIDI&nbsp;Timed&nbsp;Trans&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;(&nbsp;1&nbsp;=&nbsp;Timer&nbsp;INT&nbsp;enabled&nbsp;)&nbsp;&nbsp;&nbsp;*/
/*======================================*
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timm&nbsp;&nbsp;(Timer&nbsp;MSB&nbsp;data)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;*======================================*/
#define&nbsp;TIMM_FRC&nbsp;&nbsp;&nbsp;0x04&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;Free&nbsp;Running&nbsp;Counter&nbsp;Bit&nbsp;16&nbsp;*/
#define&nbsp;TIMM_CR1&nbsp;&nbsp;&nbsp;0x02&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;Compare&nbsp;Reg&nbsp;1&nbsp;Bit&nbsp;16&nbsp;*/
#define&nbsp;TIMM_CR0&nbsp;&nbsp;&nbsp;0x01&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;Compare&nbsp;Reg&nbsp;0&nbsp;Bit&nbsp;16&nbsp;*/
/*===================================*
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mdcm&nbsp;(MIDI&nbsp;Command)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;*===================================*/
#define&nbsp;MDCM_UART&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x3f&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;UART&nbsp;mode&nbsp;*/
#define&nbsp;MDCM_MPU&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xff&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;MPU&nbsp;Reset&nbsp;*/
#define&nbsp;MDCM_VERSION&nbsp;&nbsp;&nbsp;0xac&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;Version&nbsp;&nbsp;*/
#define&nbsp;MDCM_REVISION&nbsp;&nbsp;0xad&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;Revision&nbsp;*/
/*===================================*
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mdst&nbsp;(MIDI&nbsp;Status)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;*===================================*/
#define&nbsp;&nbsp;MDST_DSR&nbsp;&nbsp;0x80&nbsp;/*&nbsp;&nbsp;DSR&nbsp;=&nbsp;0&nbsp;if&nbsp;ready&nbsp;*/
#define&nbsp;&nbsp;MDST_DDR&nbsp;&nbsp;0x40&nbsp;/*&nbsp;&nbsp;DDR&nbsp;=&nbsp;0&nbsp;if&nbsp;ready&nbsp;*/
/*====================================*
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RAP&nbsp;Card&nbsp;Info&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;*====================================*
&nbsp;*
&nbsp;*&nbsp;&nbsp;&nbsp;These&nbsp;are&nbsp;the&nbsp;information&nbsp;regarding&nbsp;the&nbsp;RAP&nbsp;Card.
&nbsp;*&nbsp;&nbsp;&nbsp;The&nbsp;info&nbsp;being&nbsp;tracked&nbsp;are:
&nbsp;*
&nbsp;*&nbsp;&nbsp;ci_state:&nbsp;&nbsp;&nbsp;Our&nbsp;state&nbsp;(Installed,&nbsp;Opened,&nbsp;Playing,&nbsp;Recording)
&nbsp;*&nbsp;&nbsp;ci_pid:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PID&nbsp;of&nbsp;process&nbsp;opened&nbsp;us.
&nbsp;*&nbsp;&nbsp;ci_addr[]:&nbsp;&nbsp;EISA&nbsp;&nbsp;Addresses
&nbsp;*&nbsp;&nbsp;ci_irq:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EISA&nbsp;Interrupt&nbsp;number&nbsp;we&nbsp;use
&nbsp;*&nbsp;&nbsp;ci_ctl:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Controller&nbsp;number&nbsp;we&nbsp;save&nbsp;from&nbsp;edt&nbsp;struct
&nbsp;*&nbsp;&nbsp;ci_adap:&nbsp;&nbsp;&nbsp;&nbsp;Adaptor&nbsp;number&nbsp;we&nbsp;save&nbsp;from&nbsp;edt&nbsp;struct.
&nbsp;*&nbsp;&nbsp;ci_dmaCh6:&nbsp;&nbsp;DMA&nbsp;Channel&nbsp;6
&nbsp;*&nbsp;&nbsp;ci_dmaCh5:&nbsp;&nbsp;DMA&nbsp;Channel&nbsp;5
&nbsp;*&nbsp;&nbsp;ci_dmaBuf6:&nbsp;EISA&nbsp;DMA&nbsp;Buffer&nbsp;struct&nbsp;for&nbsp;Channel&nbsp;6
&nbsp;*&nbsp;&nbsp;ci_dmaBuf5:&nbsp;EISA&nbsp;DMA&nbsp;Buffer&nbsp;struct&nbsp;for&nbsp;Channel&nbsp;5
&nbsp;*&nbsp;&nbsp;ci_dmaCb6:&nbsp;&nbsp;EISA&nbsp;DMA&nbsp;Control&nbsp;Block&nbsp;for&nbsp;Channel&nbsp;6
&nbsp;*&nbsp;&nbsp;ci_dmaCb5:&nbsp;&nbsp;EISA&nbsp;DMA&nbsp;Control&nbsp;Block&nbsp;for&nbsp;Channel&nbsp;5
&nbsp;*&nbsp;&nbsp;di_state:&nbsp;&nbsp;&nbsp;DMA&nbsp;buffers&nbsp;state&nbsp;(Idle,&nbsp;Progress)
&nbsp;*&nbsp;&nbsp;di_idx:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Current&nbsp;rwQue[]&nbsp;entry&nbsp;being&nbsp;used.
&nbsp;*&nbsp;&nbsp;di_ptr:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Address&nbsp;in&nbsp;rwQue&nbsp;buffer
&nbsp;*&nbsp;&nbsp;di_which:&nbsp;&nbsp;&nbsp;Which&nbsp;half&nbsp;of&nbsp;DMA&nbsp;buffer&nbsp;(0=1st&nbsp;half,&nbsp;1=2nd&nbsp;Half)
&nbsp;*&nbsp;&nbsp;di_bh:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Total&nbsp;DMA&nbsp;Buffer&nbsp;Half&nbsp;(BH)&nbsp;Interrupt&nbsp;received.
&nbsp;*&nbsp;&nbsp;di_bf:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Total&nbsp;DMA&nbsp;Buffer&nbsp;Full&nbsp;(BF)&nbsp;Interrupt&nbsp;received.
&nbsp;*&nbsp;&nbsp;ri_state:&nbsp;&nbsp;&nbsp;State&nbsp;of&nbsp;Circular&nbsp;buffer&nbsp;(Wanted_Empty,&nbsp;etc.)
&nbsp;*&nbsp;&nbsp;ri_free:&nbsp;&nbsp;&nbsp;&nbsp;Total&nbsp;Free&nbsp;entries&nbsp;in&nbsp;rwQue[]
&nbsp;*&nbsp;&nbsp;ri_full:&nbsp;&nbsp;&nbsp;&nbsp;Total&nbsp;Full&nbsp;entries&nbsp;in&nbsp;rwQue[]
&nbsp;*&nbsp;&nbsp;ri_idx:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Current&nbsp;rwBuf&nbsp;for&nbsp;Read/Write
&nbsp;*&nbsp;&nbsp;ri_tout;&nbsp;&nbsp;&nbsp;&nbsp;=1&nbsp;if&nbsp;Timed&nbsp;out&nbsp;on&nbsp;read/write
&nbsp;*&nbsp;&nbsp;ri_note;&nbsp;&nbsp;&nbsp;&nbsp;number&nbsp;of&nbsp;Note_On&nbsp;received
&nbsp;*&nbsp;&nbsp;ri_ptr:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pointer&nbsp;in&nbsp;current&nbsp;rwBuf
&nbsp;*/
typedef&nbsp;&nbsp;struct&nbsp;eisa_dma_buf&nbsp;&nbsp;&nbsp;dmaBuf_t;
typedef&nbsp;&nbsp;struct&nbsp;eisa_dma_cb&nbsp;&nbsp;&nbsp;&nbsp;dmaCb_t;
typedef&nbsp;struct&nbsp;cardInfo_s&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;Card&nbsp;Installation&nbsp;Info&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;ushort_t&nbsp;&nbsp;&nbsp;ci_state;
&nbsp;&nbsp;&nbsp;&nbsp;pid_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci_pid;
&nbsp;&nbsp;&nbsp;&nbsp;caddr_t&nbsp;&nbsp;&nbsp;&nbsp;ci_addr[NBASE];
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;ci_irq;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;ci_ctl;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;ci_adap;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;ci_dmaCh6;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;ci_dmaCh5;
&nbsp;&nbsp;&nbsp;&nbsp;dmaBuf_t&nbsp;&nbsp;&nbsp;*ci_dmaBuf6;
&nbsp;&nbsp;&nbsp;&nbsp;dmaBuf_t&nbsp;&nbsp;&nbsp;*ci_dmaBuf5;
&nbsp;&nbsp;&nbsp;&nbsp;dmaCb_t&nbsp;&nbsp;&nbsp;&nbsp;*ci_dmaCb6;
&nbsp;&nbsp;&nbsp;&nbsp;dmaCb_t&nbsp;&nbsp;&nbsp;&nbsp;*ci_dmaCb5;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;DMA&nbsp;Buffer&nbsp;Information&nbsp;data&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;di_state;
&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;di_idx;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;di_which;
&nbsp;&nbsp;&nbsp;&nbsp;caddr_t&nbsp;&nbsp;&nbsp;di_ptr;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;di_bh;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;di_bf;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;Circular&nbsp;buffer&nbsp;Information&nbsp;data&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;ri_state;
&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ri_free;
&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ri_full;
&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ri_idx;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;ri_tout;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;ri_note;
&nbsp;&nbsp;&nbsp;&nbsp;caddr_t&nbsp;&nbsp;&nbsp;ri_ptr;
}&nbsp;cardInfo_t;
/*&nbsp;&nbsp;&nbsp;ci_state&nbsp;&nbsp;values&nbsp;&nbsp;&nbsp;*/
#define&nbsp;&nbsp;CARD_INSTALLED&nbsp;&nbsp;&nbsp;&nbsp;0x0001
#define&nbsp;&nbsp;CARD_STEREO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0002
#define&nbsp;&nbsp;CARD_OPENED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0004
#define&nbsp;&nbsp;CARD_PLAYING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0010
#define&nbsp;&nbsp;CARD_RECORDING&nbsp;&nbsp;&nbsp;&nbsp;0x0020
/*&nbsp;&nbsp;&nbsp;di_state&nbsp;values&nbsp;&nbsp;&nbsp;&nbsp;*/
#define&nbsp;&nbsp;DI_DMA_IDLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00
#define&nbsp;&nbsp;DI_DMA_PLAYING&nbsp;&nbsp;&nbsp;&nbsp;0x01
#define&nbsp;&nbsp;DI_DMA_RECORDING&nbsp;&nbsp;0x02
#define&nbsp;&nbsp;DI_DMA_END_PLAY&nbsp;&nbsp;&nbsp;0x04
#define&nbsp;&nbsp;DI_DMA_END_RECORD&nbsp;0x08
/*&nbsp;&nbsp;&nbsp;ri_state&nbsp;values&nbsp;&nbsp;&nbsp;*/
#define&nbsp;RI_WANTED_EMPTY&nbsp;&nbsp;&nbsp;&nbsp;0x01
/*====================================*
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read/Write&nbsp;Circular&nbsp;Buffers&nbsp;&nbsp;&nbsp;*
&nbsp;*====================================*
&nbsp;*&nbsp;&nbsp;This&nbsp;is&nbsp;the&nbsp;description&nbsp;of&nbsp;our&nbsp;circular&nbsp;buffers&nbsp;used
&nbsp;*&nbsp;&nbsp;to&nbsp;store&nbsp;D/A&nbsp;and&nbsp;A/D&nbsp;values.&nbsp;D/A&nbsp;values&nbsp;are&nbsp;stored&nbsp;from
&nbsp;*&nbsp;&nbsp;user's&nbsp;buffer&nbsp;and&nbsp;then&nbsp;moved&nbsp;to&nbsp;DMA&nbsp;buffers.&nbsp;A/D&nbsp;data&nbsp;is
&nbsp;*&nbsp;&nbsp;moved&nbsp;from&nbsp;DMA&nbsp;buffers&nbsp;to&nbsp;these&nbsp;buffers&nbsp;and&nbsp;then&nbsp;moved
&nbsp;*&nbsp;&nbsp;to&nbsp;user's&nbsp;buffer.&nbsp;The&nbsp;fields&nbsp;are&nbsp;as&nbsp;follow:
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;rw_state:&nbsp;&nbsp;&nbsp;&nbsp;buffer&nbsp;state&nbsp;(Empty,&nbsp;Busy,&nbsp;Full)
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;rw_idx:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Index&nbsp;of&nbsp;this&nbsp;buffer&nbsp;in&nbsp;rwQue[];
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;rw_count:&nbsp;&nbsp;&nbsp;&nbsp;Total&nbsp;bytes&nbsp;in&nbsp;the&nbsp;buffer
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;rw_buf[]:&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;buffer&nbsp;itself.
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RW_MIN_FULL:&nbsp;&nbsp;We&nbsp;will&nbsp;start&nbsp;a&nbsp;D/A&nbsp;DMA&nbsp;when&nbsp;we&nbsp;have&nbsp;this&nbsp;many
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;full&nbsp;buffer&nbsp;on&nbsp;hand.&nbsp;This&nbsp;is&nbsp;done&nbsp;so&nbsp;that&nbsp;we&nbsp;can
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;provide&nbsp;enough&nbsp;full&nbsp;buffers&nbsp;for&nbsp;DMA&nbsp;to&nbsp;process.
&nbsp;*/
#define&nbsp;&nbsp;RW_BUF_SIZE&nbsp;&nbsp;&nbsp;&nbsp;8192
#define&nbsp;&nbsp;RW_BUF_COUNT&nbsp;&nbsp;&nbsp;20
#define&nbsp;&nbsp;RW_MIN_FULL&nbsp;&nbsp;&nbsp;&nbsp;1
#define&nbsp;&nbsp;RW_TIMEOUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1600
typedef&nbsp;struct&nbsp;rwBuf_s&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw_state;
&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw_idx;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw_count;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw_buf[RW_BUF_SIZE];
}&nbsp;rwBuf_t;
/*&nbsp;&nbsp;&nbsp;rw_state&nbsp;&nbsp;values&nbsp;&nbsp;&nbsp;*/
#define&nbsp;RW_EMPTY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00&nbsp;&nbsp;/*&nbsp;&nbsp;used&nbsp;as&nbsp;parameter&nbsp;only&nbsp;&nbsp;*/
#define&nbsp;RW_FULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x01
#define&nbsp;RW_WANTED_FULL&nbsp;&nbsp;0x02
#define&nbsp;RW_WANTED_EMPTY&nbsp;0x04
/*==================================*
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Global&nbsp;values&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;*==================================*/
#define&nbsp;&nbsp;&nbsp;DMA_BUF_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8192
#define&nbsp;&nbsp;&nbsp;DMA_HALF_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4096
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapdevflag&nbsp;=&nbsp;0;
static&nbsp;cardInfo_t&nbsp;&nbsp;&nbsp;&nbsp;cardInfo;
static&nbsp;caddr_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaRight;
static&nbsp;caddr_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaLeft;
static&nbsp;paddr_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaRightPhys;
static&nbsp;paddr_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaLeftPhys;
static&nbsp;rwBuf_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rwQue[RW_BUF_COUNT];
static&nbsp;caddr_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eisa_addr;
/*
&nbsp;*&nbsp;&nbsp;Eisam&nbsp;Dma&nbsp;Channel&nbsp;semaphores..shoule&nbsp;be&nbsp;removed&nbsp;when
&nbsp;*&nbsp;&nbsp;proper&nbsp;way&nbsp;of&nbsp;releasing&nbsp;channels&nbsp;found
&nbsp;*/
extern&nbsp;struct&nbsp;eisa_ch_state&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;sema_t&nbsp;chan_sem;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;inuse&nbsp;semaphore&nbsp;for&nbsp;each&nbsp;channel&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;sema_t&nbsp;dma_sem;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;dma&nbsp;completion&nbsp;semaphore&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;eisa_dma_buf&nbsp;*cur_buf;&nbsp;&nbsp;&nbsp;/*&nbsp;current&nbsp;eisa_dma_buf&nbsp;being&nbsp;dma'ed&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;eisa_dma_cb&nbsp;*cur_cb;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;ptr&nbsp;to&nbsp;current&nbsp;command&nbsp;block&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;count;
}&nbsp;e_ch[];
/*=========================================*
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Driver&nbsp;Entry&nbsp;routines&nbsp;Data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;*=========================================*/
int&nbsp;&nbsp;&nbsp;&nbsp;rapopen&nbsp;&nbsp;(&nbsp;dev_t&nbsp;*,&nbsp;int,&nbsp;int,&nbsp;cred_t&nbsp;&nbsp;*&nbsp;);
int&nbsp;&nbsp;&nbsp;&nbsp;rapread&nbsp;(&nbsp;dev_t,&nbsp;uio_t&nbsp;*,&nbsp;cred_t&nbsp;*&nbsp;);
int&nbsp;&nbsp;&nbsp;&nbsp;rapwrite&nbsp;(&nbsp;dev_t,&nbsp;uio_t&nbsp;*,&nbsp;cred_t&nbsp;*&nbsp;);
int&nbsp;&nbsp;&nbsp;&nbsp;rapclose&nbsp;(&nbsp;dev_t,&nbsp;int,&nbsp;int,&nbsp;cred_t&nbsp;&nbsp;*&nbsp;);
void&nbsp;&nbsp;&nbsp;rapedtinit&nbsp;(&nbsp;struct&nbsp;edt&nbsp;&nbsp;*&nbsp;);
void&nbsp;&nbsp;&nbsp;rapintr&nbsp;(&nbsp;int&nbsp;);
int&nbsp;&nbsp;&nbsp;&nbsp;rapioctl&nbsp;(dev_t,&nbsp;int,&nbsp;void&nbsp;*,&nbsp;int,&nbsp;cred_t&nbsp;*,&nbsp;int&nbsp;*);
/*=======================================*
&nbsp;*&nbsp;&nbsp;Misc&nbsp;and&nbsp;Internal&nbsp;routines&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;*=======================================*/
static&nbsp;void&nbsp;&nbsp;&nbsp;rapDisInt&nbsp;(cardInfo_t&nbsp;&nbsp;*);
static&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;rapGetDma(&nbsp;dmaBuf_t&nbsp;&nbsp;**,&nbsp;&nbsp;dmaCb_t&nbsp;**,&nbsp;int&nbsp;);
static&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;rapClose(uchar_t);
static&nbsp;short&nbsp;&nbsp;rapGetNextEmpty&nbsp;(short,&nbsp;uchar_t);
static&nbsp;short&nbsp;&nbsp;rapGetNextFull&nbsp;(short,&nbsp;uchar_t);
static&nbsp;void&nbsp;&nbsp;&nbsp;rapPrepEisa(&nbsp;dmaBuf_t&nbsp;*,&nbsp;dmaCb_t&nbsp;*,&nbsp;uchar_t,&nbsp;paddr_t);
static&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;rapStart(uchar_t);
static&nbsp;void&nbsp;&nbsp;&nbsp;rapStop(uchar_t);
static&nbsp;void&nbsp;&nbsp;&nbsp;rapStartDA();
static&nbsp;void&nbsp;&nbsp;&nbsp;rapStartAD();
static&nbsp;void&nbsp;&nbsp;&nbsp;rapBufToDma(&nbsp;int&nbsp;);
static&nbsp;void&nbsp;&nbsp;&nbsp;rapDmaToBuf(&nbsp;int&nbsp;);
static&nbsp;void&nbsp;&nbsp;&nbsp;rapMarkBuf(rwBuf_t&nbsp;*,&nbsp;cardInfo_t&nbsp;*,&nbsp;uchar_t);
static&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;rapKernMem(uchar_t);
static&nbsp;void&nbsp;&nbsp;&nbsp;rapSetAutoInit(cardInfo_t&nbsp;*,&nbsp;uchar_t);
static&nbsp;void&nbsp;&nbsp;&nbsp;rapTimeOut(&nbsp;void&nbsp;*);
static&nbsp;void&nbsp;&nbsp;&nbsp;rapNoteOn(cardInfo_t&nbsp;*,&nbsp;ushort_t&nbsp;);
static&nbsp;void&nbsp;&nbsp;&nbsp;rapNoteOff(cardInfo_t&nbsp;*);
static&nbsp;void&nbsp;&nbsp;&nbsp;rapZeroDma(cardInfo_t&nbsp;*,&nbsp;int);
static&nbsp;void&nbsp;&nbsp;&nbsp;rapReleaseDma&nbsp;(cardInfo_t&nbsp;*);
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;e&nbsp;d&nbsp;t&nbsp;i&nbsp;n&nbsp;i&nbsp;t
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapedtint
&nbsp;*&nbsp;&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;Initializes&nbsp;the&nbsp;driver.&nbsp;Called&nbsp;once&nbsp;for&nbsp;each&nbsp;controller.
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;Called&nbsp;only&nbsp;once.
&nbsp;*&nbsp;&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;None.
&nbsp;*************************************************************************/
void
rapedtinit&nbsp;(&nbsp;struct&nbsp;edt&nbsp;*e&nbsp;)
{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctl,&nbsp;iospace,&nbsp;dmac,&nbsp;eirq;
&nbsp;&nbsp;&nbsp;&nbsp;cardInfo_t&nbsp;&nbsp;&nbsp;*ci;
&nbsp;&nbsp;&nbsp;&nbsp;piomap_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pmap;
&nbsp;&nbsp;&nbsp;&nbsp;iospace_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eisa_io;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;ci&nbsp;=&nbsp;&amp;cardInfo;
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapedtinit:&nbsp;Installing&nbsp;RAP&nbsp;board.&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;bzero&nbsp;((void&nbsp;*)ci,&nbsp;sizeof(cardInfo_t)&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;dmaRight&nbsp;=&nbsp;dmaLeft&nbsp;=&nbsp;(caddr_t)NULL;
&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_ctl&nbsp;=&nbsp;e->e_ctlr;
&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_adap&nbsp;=&nbsp;e->e_adap;
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;Get&nbsp;the&nbsp;base&nbsp;address&nbsp;of&nbsp;Eisa&nbsp;bus&nbsp;(for&nbsp;rapSetAutoInit)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;bzero&nbsp;(&amp;eisa_io,&nbsp;sizeof(iospace_t));
&nbsp;&nbsp;&nbsp;&nbsp;eisa_io.ios_iopaddr&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;eisa_io.ios_size&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;1000;
&nbsp;&nbsp;&nbsp;&nbsp;pmap&nbsp;=&nbsp;pio_mapalloc&nbsp;(e->e_bus_type,&nbsp;0,&nbsp;&amp;eisa_io,&nbsp;PIOMAP_FIXED,&nbsp;&ldquo;eisa&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;pmap&nbsp;==&nbsp;(piomap_t&nbsp;*)NULL&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_WARN,&nbsp;&ldquo;rapedtinit:&nbsp;Cannot&nbsp;get&nbsp;Eisa&nbsp;bus&nbsp;address&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;eisa_addr&nbsp;=&nbsp;pio_mapaddr&nbsp;(pmap,&nbsp;eisa_io.ios_iopaddr);
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapedtinit:&nbsp;Eisa&nbsp;base&nbsp;address&nbsp;=&nbsp;%x&rdquo;,&nbsp;eisa_addr);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;/*===================================================*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;map&nbsp;EISA&nbsp;IO/Memory&nbsp;addresses&nbsp;for&nbsp;RAP-10&nbsp;card&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*===================================================*/
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;iospace&nbsp;=&nbsp;0;&nbsp;iospace&nbsp;&lt;&nbsp;NBASE;&nbsp;iospace++&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;any&nbsp;address&nbsp;to&nbsp;map&nbsp;?&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!e->e_space[iospace].ios_iopaddr&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pmap&nbsp;=&nbsp;pio_mapalloc&nbsp;(&nbsp;e->e_bus_type,&nbsp;e->e_adap,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;e->e_space[iospace],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PIOMAP_FIXED,&nbsp;&ldquo;rap10&rdquo;&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_addr[iospace]&nbsp;=&nbsp;pio_mapaddr&nbsp;(&nbsp;pmap,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e->e_space[iospace].ios_iopaddr&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;is&nbsp;Card&nbsp;still&nbsp;there&nbsp;&nbsp;?&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;badaddr(ci->ci_addr[0],&nbsp;1)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_WARN,&nbsp;&ldquo;rapedtinit:&nbsp;RAP&nbsp;board&nbsp;not&nbsp;installed.&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapedtinit:&nbsp;First&nbsp;Load..allocating&nbsp;IRQ&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;eirq&nbsp;=&nbsp;eisa_ivec_alloc(&nbsp;e->e_adap,&nbsp;IRQ_MASK,&nbsp;EISA_EDGE_IRQ&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;eirq&nbsp;&lt;&nbsp;0&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_WARN,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapedtinit:&nbsp;Could&nbsp;not&nbsp;allocate&nbsp;IRQ&nbsp;for&nbsp;RAP&nbsp;card.&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;&nbsp;set&nbsp;Interrupt&nbsp;handler&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapedtinit:&nbsp;Setting&nbsp;Interrupt&nbsp;Handler&nbsp;for&nbsp;IRQ&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eirq);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;eisa_ivec_set(e->e_adap,&nbsp;eirq,&nbsp;rapintr,&nbsp;e->e_ctlr)&nbsp;==&nbsp;-1&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapedtinit:&nbsp;Could&nbsp;not&nbsp;set&nbsp;Interrupt&nbsp;handler&nbsp;for&nbsp;Irq&nbsp;%d&rdquo;,&nbsp;eirq);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_state&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_irq&nbsp;=&nbsp;eirq;
&nbsp;&nbsp;&nbsp;&nbsp;/*======================================*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;DMA&nbsp;Channels&nbsp;Allocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*======================================*/
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;DMA&nbsp;channel&nbsp;5&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;dmac&nbsp;=&nbsp;eisa_dmachan_alloc&nbsp;(&nbsp;e->e_adap,&nbsp;DMAC_CH5&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;dmac&nbsp;&lt;&nbsp;0&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_WARN,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapedtinit:&nbsp;Could&nbsp;not&nbsp;allocate&nbsp;DMA&nbsp;Channel&nbsp;5.&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_dmaCh5&nbsp;=&nbsp;dmac;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;DMA&nbsp;channel&nbsp;6&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;dmac&nbsp;=&nbsp;eisa_dmachan_alloc&nbsp;(&nbsp;e->e_adap,&nbsp;DMAC_CH6&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;dmac&nbsp;&lt;&nbsp;0&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_WARN,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapedtinit:&nbsp;Could&nbsp;not&nbsp;allocate&nbsp;DMA&nbsp;Chann&nbsp;6.&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_WARN,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapedtinit:&nbsp;RAP&nbsp;is&nbsp;initialized&nbsp;as&nbsp;Mono.&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_dmaCh6&nbsp;=&nbsp;dmac;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_state&nbsp;|=&nbsp;CARD_STEREO;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*==============================*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMA&nbsp;Buffer&nbsp;allocation&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*==============================*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;rapKernMem&nbsp;(1)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_WARN,&nbsp;&ldquo;rapedtinit:&nbsp;Did&nbsp;not&nbsp;install&nbsp;RAP-10.&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_state&nbsp;|=&nbsp;CARD_INSTALLED;
#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapedtinit:&nbsp;RAP&nbsp;installed,&nbsp;Addr:&nbsp;%x,&nbsp;Irq:&nbsp;%d.&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_addr[0],&nbsp;ci->ci_irq&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapedtinit:&nbsp;Init&nbsp;as&nbsp;%s,&nbsp;Dma&nbsp;1&nbsp;=&nbsp;%d,&nbsp;Dma&nbsp;0&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ci->ci_state&nbsp;&amp;&nbsp;CARD_STEREO&nbsp;?&nbsp;&ldquo;Stereo&rdquo;:&rdquo;Mono&rdquo;),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_dmaCh5,&nbsp;ci->ci_dmaCh6);
#endif
&nbsp;&nbsp;&nbsp;&nbsp;return;
}&nbsp;&nbsp;/***&nbsp;&nbsp;&nbsp;End&nbsp;rapedtinit&nbsp;&nbsp;&nbsp;&nbsp;***/
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;o&nbsp;p&nbsp;e&nbsp;n
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapopen
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;Opens&nbsp;the&nbsp;RAP&nbsp;board&nbsp;and&nbsp;initializes&nbsp;necessary&nbsp;data
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;0&nbsp;=&nbsp;Success,&nbsp;or&nbsp;appropriate&nbsp;error&nbsp;number.
&nbsp;*************************************************************************/
int
rapopen&nbsp;(&nbsp;dev_t&nbsp;&nbsp;*dev,&nbsp;int&nbsp;oflag,&nbsp;int&nbsp;otyp,&nbsp;cred_t&nbsp;&nbsp;*cred)
{
&nbsp;&nbsp;&nbsp;&nbsp;register&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;cardInfo_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*ci;
&nbsp;&nbsp;&nbsp;&nbsp;rwBuf_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*rw;
&nbsp;&nbsp;&nbsp;&nbsp;dmaBuf_t&nbsp;&nbsp;&nbsp;&nbsp;*dmaB;
&nbsp;&nbsp;&nbsp;&nbsp;dmaCb_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*dmaC;
&nbsp;&nbsp;&nbsp;&nbsp;ci&nbsp;=&nbsp;&amp;cardInfo;
#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapopen:&nbsp;Opening,&nbsp;Addr&nbsp;=&nbsp;%x,&nbsp;ci_state&nbsp;=&nbsp;%x&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_addr[0],&nbsp;ci->ci_state&nbsp;);
#endif
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;No&nbsp;card&nbsp;is&nbsp;installed&nbsp;or&nbsp;card&nbsp;is&nbsp;already&nbsp;opened
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!(ci->ci_state&nbsp;&amp;&nbsp;CARD_INSTALLED)&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(ENODEV);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->ci_state&nbsp;&amp;&nbsp;CARD_OPENED&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(EBUSY);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;Allocate&nbsp;DMA&nbsp;Buf&nbsp;and&nbsp;Cb&nbsp;for&nbsp;Channel&nbsp;5&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->ci_dmaBuf5&nbsp;==&nbsp;(dmaBuf_t&nbsp;*)NULL&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;rapGetDma(&amp;dmaB,&nbsp;&amp;dmaC,&nbsp;ci->ci_dmaCh5)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_WARN,&rdquo;rapopen:&nbsp;Could&nbsp;not&nbsp;allocate&nbsp;DMA&nbsp;Buf&nbsp;5.&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(ENOMEM);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_dmaBuf5&nbsp;=&nbsp;dmaB;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_dmaCb5&nbsp;&nbsp;=&nbsp;dmaC;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;if&nbsp;in&nbsp;stereo,&nbsp;do&nbsp;the&nbsp;same&nbsp;for&nbsp;Channel&nbsp;6&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->ci_state&nbsp;&amp;&nbsp;CARD_STEREO&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;rapGetDma(&amp;dmaB,&nbsp;&amp;dmaC,&nbsp;ci->ci_dmaCh6)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_WARN,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapopen:&nbsp;Could&nbsp;not&nbsp;allocate&nbsp;DMA&nbsp;Buf&nbsp;6.&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(ENOMEM);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_dmaBuf6&nbsp;=&nbsp;dmaB;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_dmaCb6&nbsp;&nbsp;=&nbsp;dmaC;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;Initialize&nbsp;Card&nbsp;Info&nbsp;structure&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_idx&nbsp;&nbsp;&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;ci->di_idx&nbsp;&nbsp;&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_state&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;ci->di_state&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;ci->di_ptr&nbsp;&nbsp;&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_ptr&nbsp;&nbsp;&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_free&nbsp;&nbsp;=&nbsp;RW_BUF_COUNT;
&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_full&nbsp;&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_state&nbsp;&amp;=&nbsp;~(CARD_PLAYING&nbsp;|&nbsp;CARD_RECORDING&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_state&nbsp;|=&nbsp;CARD_OPENED;
&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_pid&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;User_pid;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;Initialize&nbsp;Circular&nbsp;Buffers&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;RW_BUF_COUNT;&nbsp;i++&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw&nbsp;=&nbsp;&amp;rwQue[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_count&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_state&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_idx&nbsp;&nbsp;&nbsp;=&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bzero&nbsp;(rw->rw_buf,&nbsp;RW_BUF_SIZE);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;rapDisInt(ci);
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapopen:&nbsp;Opened&nbsp;succesfully&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;return(0);
}&nbsp;&nbsp;/***&nbsp;&nbsp;End&nbsp;rapopen&nbsp;&nbsp;***/
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;w&nbsp;r&nbsp;i&nbsp;t&nbsp;e
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapwrite
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;&nbsp;Write&nbsp;entry&nbsp;routine.&nbsp;This&nbsp;routine&nbsp;will&nbsp;transfer&nbsp;user's
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;to&nbsp;current&nbsp;or&nbsp;an&nbsp;empty&nbsp;entry&nbsp;in&nbsp;rwQue[]&nbsp;and&nbsp;starts
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMA&nbsp;if&nbsp;none&nbsp;is&nbsp;going.
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;=&nbsp;Success,&nbsp;or&nbsp;errno
&nbsp;*************************************************************************/
int
rapwrite&nbsp;(dev_t&nbsp;&nbsp;dev,&nbsp;uio_t&nbsp;&nbsp;*uio,&nbsp;cred_t&nbsp;&nbsp;*cred)
{
&nbsp;&nbsp;&nbsp;&nbsp;cardInfo_t&nbsp;&nbsp;&nbsp;&nbsp;*ci;
&nbsp;&nbsp;&nbsp;&nbsp;rwBuf_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*rw;
&nbsp;&nbsp;&nbsp;&nbsp;toid_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_id;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avail,&nbsp;size,&nbsp;totBytes,&nbsp;err,&nbsp;s;
&nbsp;&nbsp;&nbsp;&nbsp;ci&nbsp;=&nbsp;&amp;cardInfo;
&nbsp;&nbsp;&nbsp;&nbsp;/*=========================*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;Error&nbsp;Checking&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*=========================*/
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;no&nbsp;card&nbsp;is&nbsp;installed&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!(ci->ci_state&nbsp;&amp;&nbsp;CARD_INSTALLED)&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(ENODEV);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;card&nbsp;is&nbsp;not&nbsp;opened&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!(ci->ci_state&nbsp;&amp;&nbsp;CARD_OPENED)&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(EACCES);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;we&nbsp;are&nbsp;not&nbsp;the&nbsp;owner&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->ci_pid&nbsp;!=&nbsp;User_pid&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(EACCES);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;is&nbsp;busy&nbsp;recording&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->ci_state&nbsp;&amp;&nbsp;CARD_RECORDING&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(EACCES);
&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_state&nbsp;|=&nbsp;CARD_PLAYING;
&nbsp;&nbsp;&nbsp;&nbsp;rw&nbsp;=&nbsp;&amp;rwQue[ci->ri_idx];
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapwrite:&nbsp;%d&nbsp;bytes,&nbsp;buf&nbsp;=&nbsp;%d,&nbsp;rw_count&nbsp;=&nbsp;%d,&nbsp;free&nbsp;=&nbsp;%d,&nbsp;full&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uio->uio_resid,&nbsp;ci->ri_idx,&nbsp;rw->rw_count,&nbsp;ci->ri_free,&nbsp;ci->ri_full);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;if&nbsp;it&nbsp;is&nbsp;full,&nbsp;wait&nbsp;till&nbsp;it&nbsp;is&nbsp;Empty&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;LOCK();
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;rw->rw_state&nbsp;&amp;&nbsp;RW_FULL&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_ptr&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_tout&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_id&nbsp;=&nbsp;itimeout&nbsp;(rapTimeOut,&nbsp;rw,&nbsp;RW_TIMEOUT,&nbsp;plbase,&nbsp;0,&nbsp;0,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(&nbsp;(rw->rw_state&nbsp;&amp;&nbsp;RW_FULL)&nbsp;&amp;&amp;&nbsp;!ci->ri_tout&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapwrite:&nbsp;waiting&nbsp;for&nbsp;buf&nbsp;%d&nbsp;to&nbsp;be&nbsp;Empty&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_idx&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_state&nbsp;|=&nbsp;RW_WANTED_EMPTY;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;sleep&nbsp;(rw,&nbsp;PUSER&nbsp;|&nbsp;PCATCH)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;untimeout(to_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapwrite:&nbsp;Interrupted&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_state&nbsp;&amp;=&nbsp;~RW_WANTED_EMPTY;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(EINTR);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;while&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;untimeout(to_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;we&nbsp;timed&nbsp;out&nbsp;..couldn't&nbsp;get&nbsp;the&nbsp;buffer&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->ri_tout&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapwrite:&nbsp;Timed&nbsp;out&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_state&nbsp;&amp;=&nbsp;~RW_WANTED_EMPTY;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(EIO);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;&nbsp;if&nbsp;(rw->rw_state&nbsp;&amp;&nbsp;RW_FULL&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;adjuest&nbsp;the&nbsp;read/write&nbsp;address&nbsp;if&nbsp;necessary&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->ri_ptr&nbsp;==&nbsp;NULL&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_ptr&nbsp;=&nbsp;rw->rw_buf;
&nbsp;&nbsp;&nbsp;&nbsp;totBytes&nbsp;=&nbsp;uio->uio_resid;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(&nbsp;totBytes&nbsp;>&nbsp;0&nbsp;)&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avail&nbsp;=&nbsp;RW_BUF_SIZE&nbsp;-&nbsp;rw->rw_count;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;if&nbsp;this&nbsp;buffer&nbsp;is&nbsp;full,&nbsp;get&nbsp;next&nbsp;buffer&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;avail&nbsp;&lt;=&nbsp;0&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapwrite:&nbsp;Buffer&nbsp;%d&nbsp;is&nbsp;Full&nbsp;now,&nbsp;rw_count&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_idx,&nbsp;rw->rw_count);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;LOCK();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapMarkBuf(rw,&nbsp;ci,&nbsp;RW_FULL);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;wake&nbsp;anyone&nbsp;wanted&nbsp;this&nbsp;buffer&nbsp;full&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;rw->rw_state&nbsp;&amp;&nbsp;RW_WANTED_FULL&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&rdquo;rapwrite:&nbsp;Buffer&nbsp;%d&nbsp;is&nbsp;Wanted_Full&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_idx&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_state&nbsp;&amp;=&nbsp;~RW_WANTED_FULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wakeup(rw);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;start&nbsp;DMA&nbsp;if&nbsp;none&nbsp;is&nbsp;going&nbsp;and&nbsp;we&nbsp;filled&nbsp;the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;entire&nbsp;buffers.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;(ci->di_state&nbsp;==&nbsp;DI_DMA_IDLE)&nbsp;&amp;&amp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rw->rw_idx&nbsp;>=&nbsp;RW_MIN_FULL&nbsp;)&nbsp;&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&rdquo;rapwrite:&nbsp;Starting&nbsp;Play&nbsp;Dma&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err&nbsp;=&nbsp;rapStart(DI_DMA_PLAYING);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;err&nbsp;)&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_WARN,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapwrite:&nbsp;Could&nbsp;not&nbsp;start&nbsp;playing&nbsp;error&nbsp;%d&rdquo;,err&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(err);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;&nbsp;get&nbsp;next&nbsp;empty&nbsp;buffer&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_idx&nbsp;=&nbsp;rapGetNextEmpty(ci->ri_idx,&nbsp;FROM_USR);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw&nbsp;=&nbsp;&amp;rwQue[ci->ri_idx];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_ptr&nbsp;=&nbsp;rw->rw_buf;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;start&nbsp;filling&nbsp;this&nbsp;buffer&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size&nbsp;=&nbsp;(totBytes&nbsp;>&nbsp;avail&nbsp;?&nbsp;avail:&nbsp;totBytes);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err&nbsp;=&nbsp;uiomove&nbsp;(ci->ri_ptr,&nbsp;size,&nbsp;UIO_WRITE,&nbsp;uio);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;err&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapwrite:&nbsp;uiomov&nbsp;error&nbsp;%d&rdquo;,&nbsp;err);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(err);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_count&nbsp;+=&nbsp;size;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_ptr&nbsp;&nbsp;&nbsp;+=&nbsp;size;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totBytes&nbsp;=&nbsp;uio->uio_resid;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapwrite:&nbsp;Wrote&nbsp;&nbsp;%d&nbsp;to&nbsp;Buffer&nbsp;%d,&nbsp;Left&nbsp;=&nbsp;%d,&nbsp;rw_count&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size,&nbsp;rw->rw_idx,&nbsp;totBytes,&nbsp;rw->rw_count&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(0);
}&nbsp;/***&nbsp;end&nbsp;rapwrite&nbsp;***/
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;r&nbsp;e&nbsp;a&nbsp;d
&nbsp;*************************************************************************
&nbsp;*
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapread
&nbsp;*
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;Reads&nbsp;data&nbsp;from&nbsp;rwQue[]&nbsp;into&nbsp;user's&nbsp;buffer.
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;routine&nbsp;waits&nbsp;for&nbsp;current&nbsp;DMA&nbsp;operation&nbsp;to&nbsp;end
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;then&nbsp;starts&nbsp;a&nbsp;A/D&nbsp;Dma&nbsp;(recording).&nbsp;If&nbsp;A/D&nbsp;is&nbsp;already
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;going&nbsp;then&nbsp;it&nbsp;simply&nbsp;moves&nbsp;data&nbsp;from&nbsp;current&nbsp;Full&nbsp;buffer
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;into&nbsp;user's&nbsp;buffer.&nbsp;If&nbsp;buffer&nbsp;is&nbsp;not&nbsp;full,&nbsp;it&nbsp;waits&nbsp;for
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it&nbsp;to&nbsp;get&nbsp;full.
&nbsp;*
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;0&nbsp;=&nbsp;Success,&nbsp;or&nbsp;errno.
&nbsp;*
&nbsp;*************************************************************************/
int
rapread&nbsp;(dev_t&nbsp;&nbsp;dev,&nbsp;uio_t&nbsp;*uio,&nbsp;cred_t&nbsp;*cred)
{
&nbsp;&nbsp;&nbsp;&nbsp;cardInfo_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*ci;
&nbsp;&nbsp;&nbsp;&nbsp;rwBuf_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*rw;
&nbsp;&nbsp;&nbsp;&nbsp;toid_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_id;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avail,&nbsp;size,&nbsp;totBytes,&nbsp;err,&nbsp;s;
&nbsp;&nbsp;&nbsp;&nbsp;ci&nbsp;=&nbsp;&amp;cardInfo;
&nbsp;&nbsp;&nbsp;&nbsp;/*===============================*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error&nbsp;Checking&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*===============================*/
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;card&nbsp;is&nbsp;not&nbsp;installed&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!(ci->ci_state&nbsp;&amp;&nbsp;CARD_INSTALLED)&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(ENODEV);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;card&nbsp;is&nbsp;not&nbsp;opened&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!(ci->ci_state&nbsp;&amp;&nbsp;CARD_OPENED)&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(EACCES);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;we&nbsp;do&nbsp;not&nbsp;own&nbsp;the&nbsp;card&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->ci_pid&nbsp;!=&nbsp;User_pid&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(EACCES);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;card&nbsp;is&nbsp;in&nbsp;middle&nbsp;of&nbsp;a&nbsp;Play&nbsp;operation&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->ci_state&nbsp;&amp;&nbsp;CARD_PLAYING&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(EIO);
&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_state&nbsp;|=&nbsp;CARD_RECORDING;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;start&nbsp;a&nbsp;A/D&nbsp;Dma&nbsp;if&nbsp;none&nbsp;is&nbsp;going&nbsp;on&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->di_state&nbsp;==&nbsp;DI_DMA_IDLE&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapread:&nbsp;Idle&nbsp;DMA.&nbsp;Starting&nbsp;one&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;rapStart(DI_DMA_RECORDING)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapread:&nbsp;Could&nbsp;not&nbsp;start&nbsp;A/D&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_state&nbsp;&amp;=&nbsp;~CARD_RECORDING;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(EIO);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;get&nbsp;the&nbsp;buffer&nbsp;we&nbsp;should&nbsp;be&nbsp;using&nbsp;and
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;wait&nbsp;for&nbsp;it&nbsp;to&nbsp;become&nbsp;Full
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;rw&nbsp;=&nbsp;&amp;rwQue[ci->ri_idx];
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapread:&nbsp;%d&nbsp;bytes,&nbsp;buf&nbsp;=&nbsp;%d,&nbsp;rw_count&nbsp;=&nbsp;%d,&nbsp;free&nbsp;=&nbsp;%d,&nbsp;full&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uio->uio_resid,&nbsp;ci->ri_idx,&nbsp;rw->rw_count,&nbsp;ci->ri_free,&nbsp;ci->ri_full);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;LOCK();
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!(rw->rw_state&nbsp;&amp;&nbsp;RW_FULL)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_ptr&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_tout&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_id&nbsp;=&nbsp;itimeout&nbsp;(rapTimeOut,&nbsp;rw,&nbsp;RW_TIMEOUT,&nbsp;plbase,&nbsp;0,&nbsp;0,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(&nbsp;!(rw->rw_state&nbsp;&amp;&nbsp;RW_FULL)&nbsp;&amp;&amp;&nbsp;!ci->ri_tout&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapread:&nbsp;wating&nbsp;for&nbsp;buf&nbsp;%d&nbsp;to&nbsp;become&nbsp;Full&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_idx&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_state&nbsp;|=&nbsp;RW_WANTED_FULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;sleep&nbsp;(rw,&nbsp;PUSER&nbsp;|&nbsp;PCATCH)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;untimeout&nbsp;(to_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapread:&nbsp;Interrupted&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_state&nbsp;&amp;=&nbsp;~RW_WANTED_FULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(EINTR);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;&nbsp;while&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;untimeout&nbsp;(to_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->ri_tout&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapread:&nbsp;Timed&nbsp;out&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_state&nbsp;&amp;=&nbsp;~RW_WANTED_FULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(EIO);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;/*&nbsp;&nbsp;if&nbsp;!rw->rw_state&nbsp;&amp;&nbsp;RW_FULL&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;adjust&nbsp;read/write&nbsp;pointer&nbsp;if&nbsp;necessary&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->ri_ptr&nbsp;==&nbsp;NULL&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_ptr&nbsp;=&nbsp;rw->rw_buf;
&nbsp;&nbsp;&nbsp;&nbsp;/*===================================*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Actual&nbsp;Read&nbsp;(Data&nbsp;movement)&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*===================================*/
&nbsp;&nbsp;&nbsp;&nbsp;totBytes&nbsp;=&nbsp;uio->uio_resid;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(&nbsp;totBytes&nbsp;>&nbsp;0&nbsp;)&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;avail&nbsp;=&nbsp;rw->rw_count;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;if&nbsp;this&nbsp;buffer&nbsp;is&nbsp;Empty,&nbsp;get&nbsp;next&nbsp;Full&nbsp;buffer&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;avail&nbsp;&lt;=&nbsp;0&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapread:&nbsp;Buffer&nbsp;%d&nbsp;is&nbsp;Empty&nbsp;now,&nbsp;rw_count&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_idx,&nbsp;rw->rw_count&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;LOCK();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapMarkBuf(rw,&nbsp;ci,&nbsp;RW_EMPTY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;wake&nbsp;anyone&nbsp;wanted&nbsp;this&nbsp;buffer&nbsp;Empty&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;rw->rw_state&nbsp;&amp;&nbsp;RW_WANTED_EMPTY&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&rdquo;rapread:&nbsp;Buffer&nbsp;%d&nbsp;is&nbsp;Wanted_Empty&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_idx&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_state&nbsp;&amp;=&nbsp;~RW_WANTED_FULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wakeup(rw);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;&nbsp;get&nbsp;next&nbsp;Full&nbsp;buffer&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_idx&nbsp;=&nbsp;rapGetNextFull(ci->ri_idx,&nbsp;FROM_USR);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw&nbsp;=&nbsp;&amp;rwQue[ci->ri_idx];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_ptr&nbsp;=&nbsp;rw->rw_buf;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;start&nbsp;filling&nbsp;this&nbsp;buffer&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size&nbsp;=&nbsp;(totBytes&nbsp;>&nbsp;avail&nbsp;?&nbsp;avail:&nbsp;totBytes);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err&nbsp;=&nbsp;uiomove&nbsp;(ci->ri_ptr,&nbsp;size,&nbsp;UIO_READ,&nbsp;uio);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;err&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_PANIC,&nbsp;&ldquo;rapread:&nbsp;uiomov&nbsp;error&nbsp;%d&rdquo;,&nbsp;err);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(err);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_count&nbsp;-=&nbsp;size;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_ptr&nbsp;&nbsp;&nbsp;+=&nbsp;size;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totBytes&nbsp;=&nbsp;uio->uio_resid;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapread:&nbsp;Read&nbsp;%d,&nbsp;Buffer&nbsp;%d,&nbsp;Left&nbsp;=&nbsp;%d,&nbsp;rw_count&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size,&nbsp;rw->rw_idx,&nbsp;totBytes,&nbsp;rw->rw_count&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(0);
}&nbsp;&nbsp;/***&nbsp;&nbsp;&nbsp;End&nbsp;rapread&nbsp;&nbsp;&nbsp;&nbsp;***/
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;c&nbsp;l&nbsp;o&nbsp;s&nbsp;e
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapclose
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;&nbsp;closes&nbsp;connection&nbsp;to&nbsp;the&nbsp;card&nbsp;and&nbsp;makes&nbsp;it&nbsp;available
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;next&nbsp;process&nbsp;to&nbsp;open&nbsp;it.
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;=&nbsp;Success,&nbsp;or&nbsp;errno
&nbsp;*************************************************************************/
int
rapclose&nbsp;(dev_t&nbsp;dev,&nbsp;int&nbsp;flag,&nbsp;int&nbsp;otyp,&nbsp;cred_t&nbsp;*cred)
{
&nbsp;&nbsp;&nbsp;&nbsp;cardInfo_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*ci;
&nbsp;&nbsp;&nbsp;&nbsp;ci&nbsp;=&nbsp;&amp;cardInfo;
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapclose:&nbsp;ci_state&nbsp;=&nbsp;%x,&nbsp;di_state&nbsp;=&nbsp;%x,&nbsp;full&nbsp;=&nbsp;%d,&nbsp;empty&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_state,&nbsp;ci->di_state,&nbsp;ci->ri_full,&nbsp;ci->ri_free&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;/*=========================*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;Error&nbsp;Checking&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*=========================*/
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;card&nbsp;is&nbsp;not&nbsp;installed&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!(ci->ci_state&nbsp;&amp;&nbsp;CARD_INSTALLED)&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(ENODEV);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;card&nbsp;is&nbsp;not&nbsp;opened&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!(ci->ci_state&nbsp;&amp;&nbsp;CARD_OPENED)&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(EACCES);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;we&nbsp;do&nbsp;not&nbsp;own&nbsp;the&nbsp;card&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->ci_pid&nbsp;!=&nbsp;User_pid&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(EACCES);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(&nbsp;rapClose(1)&nbsp;);
}
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;i&nbsp;n&nbsp;t&nbsp;r
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapintr
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;&nbsp;Interrupt&nbsp;handling&nbsp;routine
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;&nbsp;None.
&nbsp;*************************************************************************/
void
rapintr&nbsp;(&nbsp;int&nbsp;ctl&nbsp;)
{
&nbsp;&nbsp;&nbsp;&nbsp;ushort_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpis;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dtci;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stereo;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totreq;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playing;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moveData;
&nbsp;&nbsp;&nbsp;&nbsp;cardInfo_t&nbsp;&nbsp;*ci;
&nbsp;&nbsp;&nbsp;&nbsp;caddr_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addr;
&nbsp;&nbsp;&nbsp;&nbsp;ci&nbsp;=&nbsp;&amp;cardInfo;
&nbsp;&nbsp;&nbsp;&nbsp;addr&nbsp;=&nbsp;ci->ci_addr[0];
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;moveData:&nbsp;&nbsp;0&nbsp;=&nbsp;we&nbsp;should&nbsp;move&nbsp;data&nbsp;between&nbsp;Buf/DMA&nbsp;&nbsp;to&nbsp;DMA/Buf.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;totreq:&nbsp;&nbsp;&nbsp;&nbsp;In&nbsp;stereo,&nbsp;we&nbsp;have&nbsp;to&nbsp;wait&nbsp;for&nbsp;2&nbsp;BF&nbsp;or&nbsp;BH&nbsp;interrupt
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;but&nbsp;in&nbsp;Mono&nbsp;we&nbsp;have&nbsp;to&nbsp;wait&nbsp;for&nbsp;only&nbsp;one.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;playing:&nbsp;&nbsp;&nbsp;1&nbsp;=&nbsp;Playing,&nbsp;0=&nbsp;Recording.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;moveData&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;totreq&nbsp;=&nbsp;(ci->ci_state&nbsp;&amp;&nbsp;CARD_STEREO?&nbsp;2:1);&nbsp;/*&nbsp;No.&nbsp;of&nbsp;Ints.&nbsp;we&nbsp;need&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;playing&nbsp;=&nbsp;ci->ci_state&nbsp;&amp;&nbsp;CARD_PLAYING;
&nbsp;&nbsp;&nbsp;&nbsp;gpis&nbsp;=&nbsp;INPW(addr+GPIS);
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;First,&nbsp;check&nbsp;for&nbsp;stray&nbsp;interrupts&nbsp;and&nbsp;ignore&nbsp;them
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!(ci->ci_state&nbsp;&amp;&nbsp;(CARD_PLAYING&nbsp;|&nbsp;CARD_RECORDING))&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapintr:&nbsp;Stray&nbsp;interupt,&nbsp;gpis&nbsp;=&nbsp;%x,&nbsp;ci_state&nbsp;=&nbsp;%x&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_state&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapintr:&nbsp;New&nbsp;..Gpis&nbsp;=&nbsp;%x&rdquo;,&nbsp;gpis&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;/**********************************
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMA&nbsp;Buffers&nbsp;Half/Full&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**********************************/
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(&nbsp;gpis&nbsp;&amp;&nbsp;GPIS_ITC&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;see&nbsp;which&nbsp;buffer&nbsp;is&nbsp;half/full&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dtci&nbsp;=&nbsp;INPB(addr+DTCI);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapintr:&nbsp;Dma&nbsp;buffer&nbsp;status..Gpis&nbsp;=&nbsp;%x,&nbsp;Dtci&nbsp;=&nbsp;%x&rdquo;,&nbsp;gpis,&nbsp;dtci);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;dtci&nbsp;&amp;&nbsp;DTCI_BF0&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->di_bf++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;dtci&nbsp;&amp;&nbsp;DTCI_BF1&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->di_bf++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(dtci&nbsp;&amp;&nbsp;DTCI_BH0&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->di_bh++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(dtci&nbsp;&amp;&nbsp;DTCI_BH1&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->di_bh++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapintr:&nbsp;di_bf&nbsp;=&nbsp;%d,&nbsp;di_bh&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->di_bf,&nbsp;ci->di_bh&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;1st&nbsp;half&nbsp;of&nbsp;dma&nbsp;needs&nbsp;service&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->di_bh&nbsp;==&nbsp;totreq&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapintr:&nbsp;DMA&nbsp;First_Half&nbsp;needs&nbsp;service&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->di_bh&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->di_which&nbsp;=&nbsp;0;&nbsp;&nbsp;/*&nbsp;1st&nbsp;half&nbsp;of&nbsp;DMA&nbsp;buffer&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moveData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;2nd&nbsp;half&nbsp;of&nbsp;dma&nbsp;needs&nbsp;service&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(&nbsp;ci->di_bf&nbsp;==&nbsp;totreq&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapintr:&nbsp;DMA&nbsp;Second_Half&nbsp;needs&nbsp;service&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->di_bf&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->di_which&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;2nd&nbsp;half&nbsp;of&nbsp;DMA&nbsp;buffer&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moveData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;Move&nbsp;data&nbsp;if&nbsp;needed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;moveData&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;move&nbsp;data&nbsp;for&nbsp;Play&nbsp;if&nbsp;only&nbsp;data&nbsp;available&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;playing&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;No&nbsp;more&nbsp;data..end&nbsp;of&nbsp;play&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->ri_full&nbsp;&lt;=&nbsp;0&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ci->di_state&nbsp;&amp;&nbsp;DI_DMA_END_PLAY&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&rdquo;rapintr:&nbsp;End&nbsp;of&nbsp;Play&nbsp;Reached&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->ri_state&nbsp;&amp;&nbsp;RI_WANTED_EMPTY&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapintr:&nbsp;Cir.Buff&nbsp;is&nbsp;Wanted&nbsp;Empty&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_state&nbsp;&amp;=&nbsp;~RI_WANTED_EMPTY;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wakeup&nbsp;(ci);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;rapStop(DI_DMA_PLAYING);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapintr:&nbsp;Playing&nbsp;but&nbsp;no&nbsp;Full&nbsp;buffers&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;Data&nbsp;is&nbsp;available&nbsp;to&nbsp;play&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapintr:&nbsp;Playing..which&nbsp;=&nbsp;%d,&nbsp;idx&nbsp;=&nbsp;%d,&nbsp;full&nbsp;=&nbsp;%d,&nbsp;Empty&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->di_which,&nbsp;ci->di_idx,&nbsp;ci->ri_full,&nbsp;ci->ri_free);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapBufToDma(DMA_HALF_SIZE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;if&nbsp;playing&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;recording&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapintr:&nbsp;Recording..which&nbsp;=&nbsp;%d,&nbsp;full&nbsp;=&nbsp;%d,&nbsp;Empty&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->di_which,&nbsp;ci->ri_full,&nbsp;ci->ri_free);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapDmaToBuf(DMA_HALF_SIZE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;/*&nbsp;&nbsp;if&nbsp;move&nbsp;data&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;/*&nbsp;&nbsp;&nbsp;no&nbsp;need&nbsp;to&nbsp;move&nbsp;data&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapintr:&nbsp;Waiting&nbsp;for&nbsp;next&nbsp;interrupt,&nbsp;bf&nbsp;=&nbsp;%d,&nbsp;bh&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->di_bf,&nbsp;ci->di_bh);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpis&nbsp;=&nbsp;INPW(addr+GPIS);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapintr:&nbsp;next&nbsp;Gpis&nbsp;=&nbsp;%x&rdquo;,&nbsp;gpis);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;while&nbsp;(&nbsp;gpis&nbsp;&amp;&nbsp;..&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapintr:&nbsp;finished&nbsp;...&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
}&nbsp;&nbsp;/***&nbsp;End&nbsp;rapintr&nbsp;&nbsp;&nbsp;***/
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;i&nbsp;o&nbsp;c&nbsp;t&nbsp;l
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapioctl
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;&nbsp;handles&nbsp;IOCTL&nbsp;calls&nbsp;for&nbsp;RAP-10.
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;=&nbsp;Success,&nbsp;or&nbsp;errno
&nbsp;*************************************************************************/
int
rapioctl&nbsp;(dev_t&nbsp;dev,&nbsp;int&nbsp;cmd,&nbsp;void&nbsp;*arg,&nbsp;int&nbsp;mode,&nbsp;cred_t&nbsp;*cred,&nbsp;int&nbsp;*ret)
{
&nbsp;&nbsp;&nbsp;&nbsp;cardInfo_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*ci;
&nbsp;&nbsp;&nbsp;&nbsp;ci&nbsp;=&nbsp;&amp;cardInfo;
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapioctl:&nbsp;Cmd&nbsp;=&nbsp;%d,&nbsp;full&nbsp;=&nbsp;%d,&nbsp;Empty&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmd,&nbsp;ci->ri_full,&nbsp;ci->ri_free&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;No&nbsp;card&nbsp;is&nbsp;installed&nbsp;or&nbsp;card&nbsp;is&nbsp;already&nbsp;opened
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!(ci->ci_state&nbsp;&amp;&nbsp;CARD_INSTALLED)&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(ENODEV);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!(ci->ci_state&nbsp;&amp;&nbsp;CARD_OPENED)&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(EACCES);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->ci_pid&nbsp;!=&nbsp;User_pid&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(EACCES);
&nbsp;&nbsp;&nbsp;&nbsp;*ret&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(&nbsp;cmd&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;RAPIOCTL_END_PLAY:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*=======================*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;End&nbsp;PLAY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*=======================*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!(ci->ci_state&nbsp;&amp;&nbsp;CARD_PLAYING)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapioctl:&nbsp;End_PLay&nbsp;command&nbsp;in&nbsp;wrong&nbsp;state&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(EACCES);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(rapClose&nbsp;(0)&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;RAPIOCTL_END_RECORD:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*=======================*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;End&nbsp;RECORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*=======================*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!(ci->ci_state&nbsp;&amp;&nbsp;CARD_RECORDING)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapioctl:&nbsp;End_Recrd&nbsp;command&nbsp;in&nbsp;wrong&nbsp;state&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(EACCES);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(rapClose&nbsp;(0)&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;switch&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(0);
}&nbsp;/**&nbsp;End&nbsp;rapioctl&nbsp;&nbsp;**/
/****************************************************************************
&nbsp;******&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;n&nbsp;t&nbsp;e&nbsp;r&nbsp;n&nbsp;a&nbsp;l&nbsp;&nbsp;&nbsp;R&nbsp;o&nbsp;u&nbsp;t&nbsp;i&nbsp;n&nbsp;e&nbsp;s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*******
&nbsp;****************************************************************************/
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;C&nbsp;l&nbsp;o&nbsp;s&nbsp;e
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapClose
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;&nbsp;Routine&nbsp;to&nbsp;actually&nbsp;ends&nbsp;current&nbsp;operation&nbsp;and&nbsp;releases
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;card.&nbsp;It&nbsp;is&nbsp;written&nbsp;as&nbsp;a&nbsp;separate&nbsp;routine&nbsp;here&nbsp;so
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it&nbsp;can&nbsp;be&nbsp;shared&nbsp;by&nbsp;rapclose()&nbsp;and&nbsp;rapioctl()&nbsp;routines.
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;One&nbsp;frees&nbsp;up&nbsp;the&nbsp;card,&nbsp;one&nbsp;does&nbsp;not.&nbsp;Also&nbsp;if&nbsp;we&nbsp;are&nbsp;called
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;ioctl,&nbsp;we&nbsp;will&nbsp;wait&nbsp;till&nbsp;all&nbsp;buffers&nbsp;are&nbsp;played&nbsp;(if
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;Playback&nbsp;mode).
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;=&nbsp;Success,&nbsp;or&nbsp;errno
&nbsp;*************************************************************************/
int
rapClose(&nbsp;uchar_t&nbsp;relCard&nbsp;)
{
&nbsp;&nbsp;&nbsp;&nbsp;cardInfo_t&nbsp;&nbsp;*ci;
&nbsp;&nbsp;&nbsp;&nbsp;rwBuf_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*rw;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s,&nbsp;totLeft;
&nbsp;&nbsp;&nbsp;&nbsp;ci&nbsp;=&nbsp;&amp;cardInfo;
&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;LOCK();
&nbsp;&nbsp;&nbsp;&nbsp;rw&nbsp;=&nbsp;&amp;rwQue[ci->ri_idx];
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapClose:&nbsp;relCard&nbsp;=&nbsp;%d,&nbsp;ci_state&nbsp;=&nbsp;%x,&nbsp;di_state&nbsp;=&nbsp;%x&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;relCard,&nbsp;ci->ci_state,&nbsp;ci->di_state&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;if&nbsp;we&nbsp;are&nbsp;not&nbsp;recording&nbsp;and&nbsp;are&nbsp;not&nbsp;playing
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;then&nbsp;simply&nbsp;mark&nbsp;the&nbsp;card&nbsp;as&nbsp;not&nbsp;opened&nbsp;and&nbsp;return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!(ci->ci_state&nbsp;&amp;&nbsp;(CARD_RECORDING&nbsp;|&nbsp;CARD_PLAYING))&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapClose:&nbsp;Idle&nbsp;card&nbsp;..closing&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;relCard&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_state&nbsp;&amp;=&nbsp;~CARD_OPENED;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_pid&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(0);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;Recording&nbsp;?&nbsp;end&nbsp;it.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->ci_state&nbsp;&amp;&nbsp;CARD_RECORDING&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&rdquo;rapClose:&nbsp;Ending&nbsp;Record&nbsp;(A/D)&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapStop(DI_DMA_RECORDING);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;relCard&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_state&nbsp;&amp;=&nbsp;~CARD_OPENED;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_pid&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(0);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;playback&nbsp;and&nbsp;called&nbsp;from&nbsp;close()&nbsp;routine&nbsp;?
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;End&nbsp;the&nbsp;playback
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;relCard&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapClose:&nbsp;Ending&nbsp;Playback&nbsp;(D/A&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapStop(DI_DMA_PLAYING);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_state&nbsp;&amp;=&nbsp;~CARD_OPENED;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_pid&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(0);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;Called&nbsp;from&nbsp;Ioctl.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;Closing&nbsp;in&nbsp;middle&nbsp;of&nbsp;play&nbsp;is&nbsp;different&nbsp;based&nbsp;on&nbsp;we
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;have&nbsp;been&nbsp;called&nbsp;from&nbsp;close()&nbsp;routine&nbsp;or&nbsp;not.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;If&nbsp;called&nbsp;from&nbsp;Ioctl&nbsp;(relCard&nbsp;=&nbsp;0),&nbsp;we&nbsp;will&nbsp;wait&nbsp;till
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;all&nbsp;buffers&nbsp;are&nbsp;played&nbsp;back.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!(rw->rw_state&nbsp;&amp;&nbsp;RW_FULL)&nbsp;&amp;&amp;&nbsp;(rw->rw_count&nbsp;>&nbsp;0)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totLeft&nbsp;=&nbsp;RW_BUF_SIZE&nbsp;-&nbsp;rw->rw_count;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapClose:&nbsp;Current&nbsp;Buf&nbsp;%d&nbsp;has&nbsp;%d&nbsp;data.&nbsp;Filled&nbsp;with&nbsp;%d&nbsp;zeros&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_idx,&nbsp;rw->rw_count,&nbsp;totLeft&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;totLeft&nbsp;>&nbsp;0&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bzero&nbsp;(ci->ri_ptr,&nbsp;totLeft);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_ptr&nbsp;+=&nbsp;totLeft;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapMarkBuf(rw,&nbsp;ci,&nbsp;RW_FULL);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;some&nbsp;buffers&nbsp;to&nbsp;play&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->ri_full&nbsp;>&nbsp;0&nbsp;)&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;Playback&nbsp;has&nbsp;not&nbsp;started&nbsp;yet&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->di_state&nbsp;==&nbsp;DI_DMA_IDLE&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapClose:&nbsp;Starting&nbsp;playback,&nbsp;full&nbsp;=&nbsp;%d,&nbsp;empty&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_full,&nbsp;ci->ri_free);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapStart(DI_DMA_PLAYING);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->di_state&nbsp;&nbsp;=&nbsp;DI_DMA_IDLE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->di_state&nbsp;|=&nbsp;DI_DMA_END_PLAY;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;wait&nbsp;till&nbsp;buffers&nbsp;are&nbsp;all&nbsp;played&nbsp;back&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(&nbsp;ci->ri_full&nbsp;>&nbsp;0&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapClose:&nbsp;waiting&nbsp;for&nbsp;Play&nbsp;to&nbsp;end..full&nbsp;=&nbsp;%d,&nbsp;empty&nbsp;=&nbsp;%d,&nbsp;ri_idx&nbsp;=&nbsp;%d,&nbsp;di_idx&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_full,&nbsp;ci->ri_free,&nbsp;ci->ri_idx,&nbsp;ci->di_idx);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_state&nbsp;|=&nbsp;RI_WANTED_EMPTY;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;sleep&nbsp;(ci,&nbsp;PUSER&nbsp;|&nbsp;PCATCH)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapClose:&nbsp;Interrupted&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapStop(DI_DMA_PLAYING);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_state&nbsp;&amp;=&nbsp;~CARD_OPENED;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_pid&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(EINTR);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapStop(DI_DMA_PLAYING);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapClose:&nbsp;Circular&nbsp;buffer&nbsp;empty..closing&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapStop(DI_DMA_PLAYING);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
&nbsp;&nbsp;&nbsp;&nbsp;return(0);
}&nbsp;&nbsp;/***&nbsp;&nbsp;&nbsp;&nbsp;End&nbsp;rapClose&nbsp;&nbsp;&nbsp;***/
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;S&nbsp;t&nbsp;o&nbsp;p
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapStop
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;&nbsp;Stops&nbsp;D/A&nbsp;and&nbsp;A/D&nbsp;conversion.
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;&nbsp;None.
&nbsp;*************************************************************************/
static&nbsp;void
rapStop(&nbsp;uchar_t&nbsp;what&nbsp;)
{
&nbsp;&nbsp;&nbsp;&nbsp;cardInfo_t&nbsp;&nbsp;*ci;
&nbsp;&nbsp;&nbsp;&nbsp;rwBuf_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*rw;
&nbsp;&nbsp;&nbsp;&nbsp;caddr_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addr;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dacm,&nbsp;adcm;
&nbsp;&nbsp;&nbsp;&nbsp;ushort_t&nbsp;&nbsp;&nbsp;&nbsp;gpdi;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s,&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;LOCK();
&nbsp;&nbsp;&nbsp;&nbsp;ci&nbsp;=&nbsp;&amp;cardInfo;
&nbsp;&nbsp;&nbsp;&nbsp;addr&nbsp;=&nbsp;ci->ci_addr[0];
&nbsp;&nbsp;&nbsp;&nbsp;gpdi&nbsp;=&nbsp;adcm&nbsp;=&nbsp;dacm&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapStop:&nbsp;&nbsp;Stoping&nbsp;%s,&nbsp;full&nbsp;=&nbsp;%d,&nbsp;Empty&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(what&nbsp;==&nbsp;DI_DMA_PLAYING&nbsp;?&nbsp;&ldquo;Playback(D/A)&rdquo;:&rdquo;Record(A/D)&rdquo;),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_full,&nbsp;ci->ri_free);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(&nbsp;what&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;stop&nbsp;D/A&nbsp;Conversion&nbsp;(Playing)&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;DI_DMA_PLAYING:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->di_which&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapZeroDma(ci,&nbsp;DMA_BUF_SIZE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+DACM,&nbsp;dacm);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapNoteOff&nbsp;(ci);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;stop&nbsp;A/D&nbsp;Conversion&nbsp;(recording)&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;DI_DMA_RECORDING:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+ADCM,&nbsp;adcm);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+DACM,&nbsp;dacm);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;OUTW(addr+GPDI,&nbsp;gpdi);
&nbsp;&nbsp;&nbsp;&nbsp;rapReleaseDma(ci);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;Initialize&nbsp;Card&nbsp;Info&nbsp;structure&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_state&nbsp;&amp;=&nbsp;~(CARD_PLAYING&nbsp;|&nbsp;CARD_RECORDING);
&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_idx&nbsp;&nbsp;&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;ci->di_idx&nbsp;&nbsp;&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_state&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;ci->di_state&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;ci->di_ptr&nbsp;&nbsp;&nbsp;=&nbsp;rwQue[0].rw_buf;
&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_ptr&nbsp;&nbsp;&nbsp;=&nbsp;rwQue[0].rw_buf;
&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_free&nbsp;&nbsp;=&nbsp;RW_BUF_COUNT;
&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_full&nbsp;&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;Initialize&nbsp;Circular&nbsp;Buffers&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;RW_BUF_COUNT;&nbsp;i++&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw&nbsp;=&nbsp;&amp;rwQue[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_count&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_state&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_idx&nbsp;&nbsp;&nbsp;=&nbsp;i;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bzero&nbsp;(rw->rw_buf,&nbsp;RW_BUF_SIZE);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;clear&nbsp;out&nbsp;any&nbsp;hanging&nbsp;GPIS&nbsp;and&nbsp;DACM&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;gpdi&nbsp;=&nbsp;INPW(addr+GPIS);
&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
}&nbsp;/**&nbsp;End&nbsp;rapStop&nbsp;&nbsp;**/
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;S&nbsp;t&nbsp;a&nbsp;r&nbsp;t
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapStart
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;&nbsp;Prepares&nbsp;Eisa&nbsp;DMA&nbsp;buffers/Control&nbsp;block&nbsp;for&nbsp;Playing/Recording
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;function&nbsp;is&nbsp;called&nbsp;when&nbsp;DMA&nbsp;is&nbsp;Idle.
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;=&nbsp;Success&nbsp;or&nbsp;Error&nbsp;number.
&nbsp;*************************************************************************/
static&nbsp;int
rapStart&nbsp;(uchar_t&nbsp;&nbsp;what)
{
&nbsp;&nbsp;&nbsp;&nbsp;cardInfo_t&nbsp;&nbsp;*ci;
&nbsp;&nbsp;&nbsp;&nbsp;dmaBuf_t&nbsp;&nbsp;&nbsp;&nbsp;*dmaB;
&nbsp;&nbsp;&nbsp;&nbsp;dmaCb_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*dmaC;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stereo;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err;
&nbsp;&nbsp;&nbsp;&nbsp;ci&nbsp;=&nbsp;&amp;cardInfo;
&nbsp;&nbsp;&nbsp;&nbsp;stereo&nbsp;=&nbsp;(ci->ci_state&nbsp;&amp;&nbsp;CARD_STEREO);
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapStart:&nbsp;Starting&nbsp;%s,&nbsp;full&nbsp;=&nbsp;%d,&nbsp;empty&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(what&nbsp;==&nbsp;DI_DMA_PLAYING&nbsp;?&nbsp;&ldquo;Playback(D/A)&rdquo;:&rdquo;Record(A/D)&rdquo;),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_full,&nbsp;&nbsp;ci->ri_free&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;&nbsp;clear&nbsp;Dma&nbsp;buffers&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;ci->di_which&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;rapZeroDma(ci,&nbsp;DMA_BUF_SIZE);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;check&nbsp;for&nbsp;Dma&nbsp;buffer&nbsp;addresses&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;(ci->ci_dmaBuf5&nbsp;==&nbsp;(dmaBuf_t&nbsp;*)0)&nbsp;||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ci->ci_dmaCb5&nbsp;&nbsp;==&nbsp;(dmaCb_t&nbsp;&nbsp;*)0)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_WARN,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapStart:&nbsp;Chan&nbsp;5&nbsp;dmaBuf/dmaCb&nbsp;is&nbsp;NULL,&nbsp;what&nbsp;=&nbsp;%d&rdquo;,&nbsp;what);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(EIO);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;(ci->ci_dmaBuf6&nbsp;==&nbsp;(dmaBuf_t&nbsp;*)0)&nbsp;||
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ci->ci_dmaCb6&nbsp;&nbsp;==&nbsp;(dmaCb_t&nbsp;&nbsp;*)0)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_WARN,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapStart:&nbsp;Chan&nbsp;6&nbsp;dmaBuf/dmaCb&nbsp;is&nbsp;NULL,&nbsp;what&nbsp;=&nbsp;%d&rdquo;,&nbsp;what);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(EIO);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;Prepare&nbsp;Eisa&nbsp;Buf&nbsp;and&nbsp;Cb&nbsp;for&nbsp;Channel&nbsp;5.&nbsp;If&nbsp;in
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;stereo&nbsp;mode,&nbsp;do&nbsp;the&nbsp;same&nbsp;for&nbsp;Channel&nbsp;6.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;dmaB&nbsp;=&nbsp;ci->ci_dmaBuf5;
&nbsp;&nbsp;&nbsp;&nbsp;dmaC&nbsp;=&nbsp;ci->ci_dmaCb5;
&nbsp;&nbsp;&nbsp;&nbsp;rapPrepEisa&nbsp;(dmaB,&nbsp;dmaC,&nbsp;what,&nbsp;dmaLeftPhys&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;stereo&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaB&nbsp;=&nbsp;ci->ci_dmaBuf6;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaC&nbsp;=&nbsp;ci->ci_dmaCb6;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapPrepEisa&nbsp;(dmaB,&nbsp;dmaC,&nbsp;what,&nbsp;dmaRightPhys&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;Program&nbsp;Eisa&nbsp;DMA&nbsp;Channels
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;err&nbsp;=&nbsp;eisa_dma_prog&nbsp;(ci->ci_adap,&nbsp;ci->ci_dmaCb5,&nbsp;ci->ci_dmaCh5,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EISA_DMA_NOSLEEP);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;err&nbsp;==&nbsp;0&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_WARN,&nbsp;&ldquo;rapStart:&nbsp;DMA&nbsp;Channel&nbsp;%d&nbsp;is&nbsp;busy&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_dmaCh5&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(EBUSY);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;stereo&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err&nbsp;=&nbsp;eisa_dma_prog&nbsp;(ci->ci_adap,&nbsp;ci->ci_dmaCb6,&nbsp;ci->ci_dmaCh6,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EISA_DMA_NOSLEEP);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;err&nbsp;==&nbsp;0&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_WARN,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapStart:&nbsp;DMA&nbsp;Channel&nbsp;%d&nbsp;is&nbsp;busy&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_dmaCh6&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(EBUSY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;enable&nbsp;hardware&nbsp;recognition&nbsp;on&nbsp;Eisa&nbsp;Dma&nbsp;Channels&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;eisa_dma_enable&nbsp;(ci->ci_adap,&nbsp;ci->ci_dmaCb5,&nbsp;ci->ci_dmaCh5,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EISA_DMA_NOSLEEP);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;stereo&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eisa_dma_enable&nbsp;(ci->ci_adap,&nbsp;ci->ci_dmaCb6,&nbsp;ci->ci_dmaCh6,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EISA_DMA_NOSLEEP);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;set&nbsp;Eisa&nbsp;DMA&nbsp;register&nbsp;for&nbsp;Autoinit&nbsp;mode&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;rapSetAutoInit(ci,&nbsp;what);
&nbsp;&nbsp;&nbsp;&nbsp;ci->di_state&nbsp;|=&nbsp;what;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;let's&nbsp;do&nbsp;it&nbsp;!&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;what&nbsp;==&nbsp;DI_DMA_PLAYING&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapStart:&nbsp;Starting&nbsp;DMA&nbsp;for&nbsp;D/A&nbsp;Play&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapStartDA();
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapStart:&nbsp;Starting&nbsp;DMA&nbsp;for&nbsp;A/D&nbsp;Record&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapStartAD();
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return(0);
}&nbsp;/**&nbsp;&nbsp;End&nbsp;rapStart&nbsp;&nbsp;**/
/************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;P&nbsp;r&nbsp;e&nbsp;p&nbsp;E&nbsp;i&nbsp;s&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapPrepEisa
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prepares&nbsp;EISA&nbsp;Buf&nbsp;and&nbsp;Cb&nbsp;structures.
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;None.
&nbsp;*************************************************************************/
static&nbsp;void
rapPrepEisa(&nbsp;dmaBuf_t&nbsp;*dmaB,&nbsp;dmaCb_t&nbsp;*dmaC,&nbsp;uchar_t&nbsp;&nbsp;what,&nbsp;paddr_t&nbsp;addr)
{
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapPrepEisa:&nbsp;Preparing&nbsp;Eisa&nbsp;DMA&nbsp;buffers&nbsp;for&nbsp;%s&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(what&nbsp;==&nbsp;DI_DMA_PLAYING&nbsp;?&nbsp;&ldquo;Playback(D/A)&rdquo;&nbsp;:&nbsp;&ldquo;Record(A/D)&rdquo;&nbsp;)&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;prepare&nbsp;Eisa&nbsp;DMA&nbsp;Buf&nbsp;struct&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;bzero&nbsp;(dmaB,&nbsp;sizeof(dmaBuf_t)&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;dmaB->count&nbsp;=&nbsp;DMA_BUF_SIZE;
&nbsp;&nbsp;&nbsp;&nbsp;dmaB->address&nbsp;=&nbsp;addr;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;prepare&nbsp;Eisa&nbsp;DMA&nbsp;Control&nbsp;Block&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;bzero&nbsp;(dmaC,&nbsp;sizeof(dmaCb_t)&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;dmaC->reqrbufs&nbsp;&nbsp;&nbsp;=&nbsp;dmaB;
&nbsp;&nbsp;&nbsp;&nbsp;dmaC->reqr_path&nbsp;&nbsp;=&nbsp;EISA_DMA_PATH_16;
&nbsp;&nbsp;&nbsp;&nbsp;dmaC->trans_type&nbsp;=&nbsp;EISA_DMA_TRANS_DMND;
&nbsp;&nbsp;&nbsp;&nbsp;dmaC->targ_step&nbsp;&nbsp;=&nbsp;EISA_DMA_STEP_INC;
&nbsp;&nbsp;&nbsp;&nbsp;dmaC->bufprocess&nbsp;=&nbsp;EISA_DMA_BUF_SNGL;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;what&nbsp;==&nbsp;DI_DMA_PLAYING&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaC->cb_cmd&nbsp;=&nbsp;EISA_DMA_CMD_READ;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;mem&nbsp;->&nbsp;rap10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaC->cb_cmd&nbsp;=&nbsp;EISA_DMA_CMD_WRITE;&nbsp;&nbsp;/*&nbsp;&nbsp;rap10&nbsp;->&nbsp;mem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
}&nbsp;/***&nbsp;End&nbsp;rapPrepEisa&nbsp;&nbsp;***/
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;S&nbsp;t&nbsp;a&nbsp;r&nbsp;t&nbsp;D&nbsp;A
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapStartDA
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables&nbsp;appropriate&nbsp;RAP&nbsp;interrupts&nbsp;and&nbsp;starts&nbsp;D/A&nbsp;Dma.
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;None
&nbsp;*************************************************************************/
static&nbsp;void
rapStartDA()
{
&nbsp;&nbsp;&nbsp;&nbsp;cardInfo_t&nbsp;&nbsp;*ci;
&nbsp;&nbsp;&nbsp;&nbsp;caddr_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addr;
&nbsp;&nbsp;&nbsp;&nbsp;ushort_t&nbsp;&nbsp;&nbsp;&nbsp;gpdi,&nbsp;gpis,&nbsp;gpst,&nbsp;dtcd,&nbsp;mask;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpcm,&nbsp;pwmd,&nbsp;adcm,&nbsp;dacm;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stereo;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci&nbsp;=&nbsp;&amp;cardInfo;
&nbsp;&nbsp;&nbsp;&nbsp;addr&nbsp;=&nbsp;ci->ci_addr[0];
&nbsp;&nbsp;&nbsp;&nbsp;stereo&nbsp;=&nbsp;ci->ci_state&nbsp;&amp;&nbsp;CARD_STEREO;
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapStartDA:&nbsp;Starting&nbsp;D/A&nbsp;Dma,&nbsp;full&nbsp;=&nbsp;%d,&nbsp;empty&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_full,&nbsp;ci->ri_free&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;Prepare&nbsp;the&nbsp;board&nbsp;for&nbsp;Record&nbsp;(A/D)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;Here&nbsp;is&nbsp;what&nbsp;we&nbsp;will&nbsp;do&nbsp;(in&nbsp;exact&nbsp;order):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;GPDI:&nbsp;&nbsp;Stereo&nbsp;=&nbsp;0xA800,&nbsp;Mono&nbsp;=&nbsp;0x9800
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;itc&nbsp;=&nbsp;1,&nbsp;dma&nbsp;transfer&nbsp;match&nbsp;count
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;Stereo:&nbsp;&nbsp;&nbsp;Drq1->Dma5,&nbsp;Drq0->Dma6
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;Mono:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Drq1->Dma5
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dt1,&nbsp;Dt0&nbsp;=&nbsp;10,&nbsp;Chan&nbsp;1&nbsp;->Drq1,&nbsp;Chan&nbsp;0&nbsp;->Drq0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;Left&nbsp;Chan->Drq1,&nbsp;Right&nbsp;Chan->Drq0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;DACM:&nbsp;&nbsp;Stereo:&nbsp;BF,&nbsp;Mono:&nbsp;BE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;scc&nbsp;=&nbsp;1,&nbsp;Dma&nbsp;size&nbsp;in&nbsp;byte
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;ts1&nbsp;=&nbsp;ts2&nbsp;=&nbsp;1,&nbsp;transfer&nbsp;size&nbsp;of&nbsp;4096&nbsp;bytes
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dl1&nbsp;=&nbsp;dl0&nbsp;=&nbsp;1;&nbsp;Data&nbsp;length&nbsp;of&nbsp;16&nbsp;bits&nbsp;for&nbsp;both&nbsp;Channels.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;Stereo&nbsp;?&nbsp;ds1&nbsp;=&nbsp;ds0&nbsp;=&nbsp;1&nbsp;&nbsp;Start&nbsp;D/A&nbsp;on&nbsp;both&nbsp;Channels.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mono&nbsp;&nbsp;&nbsp;?&nbsp;ds1&nbsp;=&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Start&nbsp;D/A&nbsp;on&nbsp;Channel&nbsp;1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;GPCM:&nbsp;&nbsp;&nbsp;Select&nbsp;Mike&nbsp;level&nbsp;=&nbsp;0x04
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Aux&nbsp;&nbsp;level&nbsp;=&nbsp;0x08
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;PWMD:&nbsp;&nbsp;&nbsp;0xFF&nbsp;(Max&nbsp;level)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;gpdi&nbsp;=&nbsp;(stereo&nbsp;?&nbsp;0xA800:&nbsp;0x9800);
&nbsp;&nbsp;&nbsp;&nbsp;dacm&nbsp;=&nbsp;(stereo&nbsp;?&nbsp;0xBF:0xBE);
&nbsp;&nbsp;&nbsp;&nbsp;gpcm&nbsp;=&nbsp;0x04;
&nbsp;&nbsp;&nbsp;&nbsp;pwmd&nbsp;=&nbsp;0xFF;
&nbsp;&nbsp;&nbsp;&nbsp;mask&nbsp;=&nbsp;(stereo&nbsp;?&nbsp;(GPIS_DN1|GPIS_DN0):&nbsp;GPIS_DN1);
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapStartDA:&nbsp;gpdi&nbsp;=&nbsp;%x,&nbsp;dacm&nbsp;=&nbsp;%x&rdquo;,&nbsp;gpdi,&nbsp;dacm);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;Set&nbsp;Rap-10&nbsp;card&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+GPCM,&nbsp;gpcm);
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+PWMD,&nbsp;pwmd);
&nbsp;&nbsp;&nbsp;&nbsp;OUTW(addr+GPDI,&nbsp;gpdi);
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+DACM,&nbsp;dacm);
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;Busy-wait&nbsp;for&nbsp;both&nbsp;Note_On&nbsp;interrupts
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;The&nbsp;interrupt&nbsp;version&nbsp;is&nbsp;commenetd&nbsp;out&nbsp;for&nbsp;now.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;gpis&nbsp;=&nbsp;INPW(addr+GPIS);
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapStartDA:&nbsp;Waiting&nbsp;for&nbsp;Note_On,&nbsp;gpis&nbsp;=&nbsp;%x,&nbsp;mask&nbsp;=&nbsp;%x&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpis,&nbsp;mask);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(&nbsp;!(gpis&nbsp;&amp;&nbsp;mask)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpis&nbsp;=&nbsp;INPW(addr+GPIS);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapStartDA:&nbsp;Waiting&nbsp;..new&nbsp;gpis&nbsp;=&nbsp;%x&rdquo;,&nbsp;gpis);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapStartDA:&nbsp;&nbsp;Note_On&nbsp;Interrupt&nbsp;Received,&nbsp;gpis&nbsp;=&nbsp;%x&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;gpis&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;rapNoteOn(ci,&nbsp;gpis);
}&nbsp;&nbsp;/***&nbsp;&nbsp;&nbsp;End&nbsp;rapStartDA&nbsp;&nbsp;&nbsp;***/
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;S&nbsp;t&nbsp;a&nbsp;r&nbsp;t&nbsp;A&nbsp;D
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapStartAD
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables&nbsp;appropriate&nbsp;RAP&nbsp;interrupts&nbsp;and&nbsp;starts&nbsp;A/D&nbsp;Dma.
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;None
&nbsp;*************************************************************************/
static&nbsp;void
rapStartAD()
{
&nbsp;&nbsp;&nbsp;&nbsp;cardInfo_t&nbsp;&nbsp;*ci;
&nbsp;&nbsp;&nbsp;&nbsp;caddr_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addr;
&nbsp;&nbsp;&nbsp;&nbsp;ushort_t&nbsp;&nbsp;&nbsp;&nbsp;gpdi;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpcm,&nbsp;pwmd,&nbsp;adcm,&nbsp;dacm;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stereo,&nbsp;mic;
&nbsp;&nbsp;&nbsp;&nbsp;ci&nbsp;=&nbsp;&amp;cardInfo;
&nbsp;&nbsp;&nbsp;&nbsp;addr&nbsp;=&nbsp;ci->ci_addr[0];
&nbsp;&nbsp;&nbsp;&nbsp;stereo&nbsp;=&nbsp;ci->ci_state&nbsp;&amp;&nbsp;CARD_STEREO;
#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapStartAD:&nbsp;Starting&nbsp;A/D&nbsp;Dma&nbsp;in&nbsp;%s,&nbsp;full&nbsp;=&nbsp;%d,&nbsp;empty&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stereo&nbsp;?&nbsp;&ldquo;Stereo&rdquo;:&rdquo;Mono&rdquo;),&nbsp;ci->ri_full,&nbsp;ci->ri_free&nbsp;);
#endif
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;Prepare&nbsp;the&nbsp;board&nbsp;for&nbsp;Record&nbsp;(A/D)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;Here&nbsp;is&nbsp;what&nbsp;we&nbsp;will&nbsp;do&nbsp;(in&nbsp;exact&nbsp;order):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;GPDI:&nbsp;&nbsp;Stereo&nbsp;=&nbsp;0xA400,&nbsp;Mono&nbsp;=&nbsp;0x9400
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;itc&nbsp;=&nbsp;1,&nbsp;dma&nbsp;transfer&nbsp;match&nbsp;count
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;Stereo:&nbsp;&nbsp;&nbsp;Drq1->Dma5,&nbsp;Drq0->Dma6
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;Mono:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Drq1->Dma5
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dt1,&nbsp;Dt0&nbsp;=&nbsp;01,&nbsp;Left&nbsp;Chan->Drq1,&nbsp;Right&nbsp;Chan->Drq0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;DACM:&nbsp;&nbsp;0xB0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;scc&nbsp;=&nbsp;1,&nbsp;Dma&nbsp;size&nbsp;in&nbsp;byte
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;ts1&nbsp;=&nbsp;ts2&nbsp;=&nbsp;1,&nbsp;transfer&nbsp;size&nbsp;of&nbsp;4096&nbsp;bytes
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;GPCM:&nbsp;&nbsp;&nbsp;Select&nbsp;Mic&nbsp;level&nbsp;=&nbsp;0x04
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Aux&nbsp;level&nbsp;=&nbsp;0x08
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;PWMD:&nbsp;&nbsp;&nbsp;0xFF&nbsp;(Max&nbsp;level)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;ADCM:&nbsp;&nbsp;Stereo:&nbsp;Mic&nbsp;0x6F,&nbsp;line&nbsp;0x4F,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;Mono:&nbsp;&nbsp;&nbsp;Mic&nbsp;0x6D,&nbsp;line&nbsp;0x4D
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mon&nbsp;=&nbsp;1,&nbsp;Monitor&nbsp;ON
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gin&nbsp;=&nbsp;1,&nbsp;Head&nbsp;Amp&nbsp;Gain&nbsp;to&nbsp;Mic.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Af1,&nbsp;Af0&nbsp;=&nbsp;01,&nbsp;22.05&nbsp;KHz
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adl&nbsp;=&nbsp;1,&nbsp;16&nbsp;bit&nbsp;data&nbsp;length
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stereo,&nbsp;&nbsp;Adm&nbsp;=&nbsp;1,&nbsp;else&nbsp;=&nbsp;0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ads&nbsp;=&nbsp;1,&nbsp;Start&nbsp;A/D
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;gpdi&nbsp;=&nbsp;(stereo&nbsp;?&nbsp;0xA400:&nbsp;0x9400);
&nbsp;&nbsp;&nbsp;&nbsp;gpcm&nbsp;=&nbsp;0x08;
&nbsp;&nbsp;&nbsp;&nbsp;adcm&nbsp;=&nbsp;(stereo&nbsp;?&nbsp;0x6F:0x6D);
&nbsp;&nbsp;&nbsp;&nbsp;dacm&nbsp;=&nbsp;0xB0;
&nbsp;&nbsp;&nbsp;&nbsp;gpcm&nbsp;=&nbsp;0x04;
&nbsp;&nbsp;&nbsp;&nbsp;pwmd&nbsp;=&nbsp;0xFF;
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapStartAD:&nbsp;Rap&nbsp;init&nbsp;as:&nbsp;gpdi&nbsp;=&nbsp;%x,&nbsp;dacm&nbsp;=&nbsp;%x,&nbsp;gpcm&nbsp;=&nbsp;%x,&nbsp;adcm&nbsp;=&nbsp;%x&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;gpdi,&nbsp;dacm,&nbsp;gpcm,&nbsp;adcm);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;OUTW(addr+GPDI,&nbsp;gpdi);
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+DACM,&nbsp;dacm);
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+GPCM,&nbsp;gpcm);
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+PWMD,&nbsp;pwmd);
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+ADCM,&nbsp;adcm);
}&nbsp;&nbsp;/***&nbsp;&nbsp;End&nbsp;rapStartAD&nbsp;&nbsp;***/
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;B&nbsp;u&nbsp;f&nbsp;T&nbsp;o&nbsp;D&nbsp;m&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapBufToDma
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;&nbsp;moves&nbsp;data&nbsp;from&nbsp;current&nbsp;rwQue[]&nbsp;entry&nbsp;to&nbsp;DMA&nbsp;buffers.
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;routine&nbsp;is&nbsp;called&nbsp;by&nbsp;INterrupt&nbsp;handler&nbsp;only&nbsp;except
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;once&nbsp;before&nbsp;we&nbsp;startd&nbsp;D/A&nbsp;(when&nbsp;no&nbsp;DMA&nbsp;is&nbsp;programmed&nbsp;yet)
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;&nbsp;None
&nbsp;*************************************************************************/
static&nbsp;void
rapBufToDma(&nbsp;int&nbsp;&nbsp;bytes)
{
&nbsp;&nbsp;&nbsp;&nbsp;cardInfo_t&nbsp;&nbsp;&nbsp;&nbsp;*ci;
&nbsp;&nbsp;&nbsp;&nbsp;rwBuf_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*rw;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*dmaR;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*dmaL;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stereo;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i,&nbsp;j,&nbsp;s;
&nbsp;&nbsp;&nbsp;&nbsp;ci&nbsp;=&nbsp;&amp;cardInfo;
&nbsp;&nbsp;&nbsp;&nbsp;rw&nbsp;=&nbsp;&amp;rwQue[ci->di_idx];
&nbsp;&nbsp;&nbsp;&nbsp;stereo&nbsp;=&nbsp;ci->ci_state&nbsp;&amp;&nbsp;CARD_STEREO;
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filling&nbsp;1st&nbsp;half&nbsp;or&nbsp;2nd&nbsp;half&nbsp;of&nbsp;the&nbsp;buffers&nbsp;?
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->di_which&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaR&nbsp;=&nbsp;&amp;dmaRight[DMA_HALF_SIZE];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaL&nbsp;=&nbsp;&amp;dmaLeft[DMA_HALF_SIZE];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;bytes&nbsp;==&nbsp;DMA_BUF_SIZE&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bytes&nbsp;=&nbsp;DMA_HALF_SIZE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;filling&nbsp;1st&nbsp;half&nbsp;of&nbsp;dma&nbsp;buffers&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaR&nbsp;=&nbsp;&amp;dmaRight[0];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaL&nbsp;=&nbsp;&amp;dmaLeft[0];
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapBufToDma:&nbsp;Bytes&nbsp;=&nbsp;%d,&nbsp;which&nbsp;=&nbsp;%d,&nbsp;Idx&nbsp;=&nbsp;%d,&nbsp;rw_count&nbsp;=&nbsp;%d,&nbsp;Full&nbsp;=&nbsp;%d,&nbsp;Empty&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;bytes,&nbsp;ci->di_which,&nbsp;ci->di_idx,&nbsp;rw->rw_count,&nbsp;ci->ri_full,
&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_free);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;if&nbsp;buffer&nbsp;is&nbsp;not&nbsp;Full,&nbsp;we&nbsp;zero&nbsp;out&nbsp;dma&nbsp;buffers&nbsp;and
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;return.&nbsp;We&nbsp;cannot&nbsp;wait&nbsp;till&nbsp;it&nbsp;gets&nbsp;Full.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!(rw->rw_state&nbsp;&amp;&nbsp;RW_FULL)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapZeroDma(ci,&nbsp;bytes);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->di_ptr&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapBufToDma:&nbsp;Buf&nbsp;%d&nbsp;is&nbsp;not&nbsp;Full,&nbsp;rw_state&nbsp;=&nbsp;%x&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_idx,&nbsp;rw->rw_state&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;buffer&nbsp;is&nbsp;full&nbsp;of&nbsp;data&nbsp;..readjust&nbsp;the&nbsp;buffer&nbsp;pointer&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->di_ptr&nbsp;==&nbsp;NULL&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->di_ptr&nbsp;=&nbsp;rw->rw_buf;
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;Fill&nbsp;buffers&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;bytes;&nbsp;i++&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;First&nbsp;check&nbsp;if&nbsp;buffer&nbsp;is&nbsp;empty.&nbsp;If&nbsp;it&nbsp;is,&nbsp;mark&nbsp;it
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;as&nbsp;empty,&nbsp;wake&nbsp;anyone&nbsp;up&nbsp;who&nbsp;wants&nbsp;it&nbsp;and&nbsp;get&nbsp;the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;next&nbsp;full&nbsp;buffer.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;rw->rw_count&nbsp;&lt;=&nbsp;0&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapBufToDma:&nbsp;Buf&nbsp;%d&nbsp;is&nbsp;Empty&nbsp;now,&nbsp;rw_count&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_idx,&nbsp;rw->rw_count&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapMarkBuf(rw,&nbsp;ci,&nbsp;RW_EMPTY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->di_ptr&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;rw->rw_state&nbsp;&amp;&nbsp;RW_WANTED_EMPTY&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapBufToDma:&nbsp;Buf&nbsp;%d&nbsp;is&nbsp;Wanted_Empty&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_idx&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_state&nbsp;&amp;=&nbsp;~RW_WANTED_EMPTY;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wakeup(rw);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;rapGetNextFull&nbsp;(ci->di_idx,&nbsp;FROM_INTR);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;j&nbsp;==&nbsp;-1&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapBufToDma:&nbsp;Could&nbsp;not&nbsp;get&nbsp;next&nbsp;Full&nbsp;buffer&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->di_idx&nbsp;=&nbsp;j;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw&nbsp;=&nbsp;&amp;rwQue[ci->di_idx];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->di_ptr&nbsp;=&nbsp;rw->rw_buf;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;buffer&nbsp;still&nbsp;has&nbsp;some&nbsp;data&nbsp;..move&nbsp;them&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;stereo&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaL[i]&nbsp;=&nbsp;*(ci->di_ptr++);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaR[i]&nbsp;=&nbsp;*(ci->di_ptr++);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_count&nbsp;-=&nbsp;2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaL[i]&nbsp;=&nbsp;*(ci->di_ptr++);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_count--;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;for&nbsp;..&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;Flush&nbsp;the&nbsp;cache&nbsp;line&nbsp;so&nbsp;that&nbsp;Dma&nbsp;buffers&nbsp;contain&nbsp;all&nbsp;data&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;dki_dcache_wbinval&nbsp;(dmaL,&nbsp;(unsigned)bytes);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;stereo&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dki_dcache_wbinval&nbsp;(dmaR,&nbsp;(unsigned)bytes);
}&nbsp;&nbsp;/***&nbsp;end&nbsp;rapBufToDma&nbsp;&nbsp;***/
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;D&nbsp;m&nbsp;a&nbsp;T&nbsp;o&nbsp;B&nbsp;u&nbsp;f
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapDmaToBuf
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;&nbsp;Moves&nbsp;data&nbsp;from&nbsp;DMA&nbsp;buffers&nbsp;(Right&nbsp;and&nbsp;Left&nbsp;in&nbsp;stereo)
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;into&nbsp;a&nbsp;rwQue&nbsp;entry.&nbsp;&nbsp;This&nbsp;routine&nbsp;is&nbsp;called&nbsp;only&nbsp;by
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interrupt&nbsp;Handler.
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;&nbsp;None
&nbsp;*************************************************************************/
static&nbsp;void
rapDmaToBuf(&nbsp;int&nbsp;&nbsp;bytes)
{
&nbsp;&nbsp;&nbsp;&nbsp;cardInfo_t&nbsp;&nbsp;&nbsp;&nbsp;*ci;
&nbsp;&nbsp;&nbsp;&nbsp;rwBuf_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*rw;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*dmaR;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*dmaL;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stereo;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;i,&nbsp;j,&nbsp;s,&nbsp;inc;
&nbsp;&nbsp;&nbsp;&nbsp;ci&nbsp;=&nbsp;&amp;cardInfo;
&nbsp;&nbsp;&nbsp;&nbsp;rw&nbsp;=&nbsp;&amp;rwQue[ci->di_idx];
&nbsp;&nbsp;&nbsp;&nbsp;stereo&nbsp;=&nbsp;ci->ci_state&nbsp;&amp;&nbsp;CARD_STEREO;
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filling&nbsp;1st&nbsp;half&nbsp;or&nbsp;2nd&nbsp;half&nbsp;of&nbsp;the&nbsp;buffers&nbsp;?
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->di_which&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaR&nbsp;=&nbsp;&amp;dmaRight[DMA_HALF_SIZE];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaL&nbsp;=&nbsp;&amp;dmaLeft[DMA_HALF_SIZE];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;bytes&nbsp;==&nbsp;DMA_BUF_SIZE&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bytes&nbsp;=&nbsp;DMA_HALF_SIZE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;filling&nbsp;1st&nbsp;half&nbsp;of&nbsp;dma&nbsp;buffers&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaR&nbsp;=&nbsp;&amp;dmaRight[0];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaL&nbsp;=&nbsp;&amp;dmaLeft[0];
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;Invalidate&nbsp;the&nbsp;Cache&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;dki_dcache_inval&nbsp;(dmaL,&nbsp;(unsigned)bytes);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;stereo&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dki_dcache_inval&nbsp;(dmaR,&nbsp;(unsigned)bytes);
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapDmaToBuf:&nbsp;Bytes=&nbsp;%d,&nbsp;Idx&nbsp;=&nbsp;%d,&nbsp;rw_count&nbsp;=&nbsp;%d,&nbsp;Full&nbsp;=&nbsp;%d,&nbsp;Empty=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;bytes,&nbsp;ci->di_idx,&nbsp;rw->rw_count,&nbsp;ci->ri_full,&nbsp;ci->ri_free);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;if&nbsp;buffer&nbsp;is&nbsp;Full&nbsp;..we&nbsp;cannot&nbsp;wait&nbsp;!&nbsp;Ignore&nbsp;new&nbsp;data
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;by&nbsp;simply&nbsp;returning.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;rw->rw_state&nbsp;&amp;&nbsp;RW_FULL&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapDmaToBuf:&nbsp;Buf&nbsp;%d&nbsp;is&nbsp;not&nbsp;Empty&nbsp;..Ignoring&nbsp;data&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_idx&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;buffer&nbsp;is&nbsp;Empty&nbsp;..calculate&nbsp;the&nbsp;end&nbsp;address&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->di_ptr&nbsp;==&nbsp;NULL&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->di_ptr&nbsp;=&nbsp;rw->rw_buf;
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapDmaToBuf:&nbsp;Moving&nbsp;%s&nbsp;of&nbsp;DMA&nbsp;buffers&nbsp;in&nbsp;%s,&nbsp;rw_count&nbsp;=&nbsp;%x&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;(ci->di_which&nbsp;?&nbsp;&ldquo;Second&nbsp;Half&rdquo;&nbsp;:&nbsp;&ldquo;First&nbsp;Half&rdquo;),
&nbsp;&nbsp;&nbsp;&nbsp;(stereo&nbsp;?&nbsp;&ldquo;Stereo&rdquo;:&rdquo;Monoe&rdquo;),&nbsp;rw->rw_count);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fill&nbsp;buffers&nbsp;...in&nbsp;stereo&nbsp;bytes&nbsp;are&nbsp;Left:Right:Left:Right...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;bytes;&nbsp;i++&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;First&nbsp;check&nbsp;if&nbsp;this&nbsp;buffer&nbsp;is&nbsp;Full&nbsp;or&nbsp;not.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;If&nbsp;it&nbsp;is,&nbsp;mark&nbsp;it&nbsp;as&nbsp;Full&nbsp;and&nbsp;wake&nbsp;anyone&nbsp;up&nbsp;who&nbsp;is
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;waiting&nbsp;for&nbsp;it.&nbsp;Then&nbsp;get&nbsp;the&nbsp;next&nbsp;Empty&nbsp;buffer.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;rw->rw_count&nbsp;>=&nbsp;RW_BUF_SIZE&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapDmaToBuf:&nbsp;Buf&nbsp;%d&nbsp;is&nbsp;Full&nbsp;now,&nbsp;rw_count&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_idx,&nbsp;rw->rw_count&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapMarkBuf(rw,&nbsp;ci,&nbsp;RW_FULL);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;rw->rw_state&nbsp;&amp;&nbsp;RW_WANTED_FULL&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapDmaToBuf:&nbsp;Buf&nbsp;%d&nbsp;is&nbsp;Wanted_Full&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_idx&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_state&nbsp;&amp;=&nbsp;~RW_WANTED_FULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wakeup(rw);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;rapGetNextEmpty(ci->di_idx,&nbsp;FROM_INTR);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;j&nbsp;==&nbsp;-1&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapDmaToBuf:&nbsp;Could&nbsp;not&nbsp;get&nbsp;next&nbsp;empty&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->di_idx&nbsp;=&nbsp;j;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw&nbsp;=&nbsp;&amp;rwQue[ci->di_idx];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->di_ptr&nbsp;=&nbsp;rw->rw_buf;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;buffer&nbsp;still&nbsp;has&nbsp;room&nbsp;...move&nbsp;data&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;stereo&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*(ci->di_ptr++)&nbsp;=&nbsp;dmaL[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*(ci->di_ptr++)&nbsp;=&nbsp;dmaR[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+=&nbsp;2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*(ci->di_ptr++)&nbsp;=&nbsp;dmaL[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_count++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;while&nbsp;bytes&nbsp;...&nbsp;*/
}&nbsp;&nbsp;/***&nbsp;end&nbsp;rapDmaToBuf&nbsp;&nbsp;***/
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;G&nbsp;e&nbsp;t&nbsp;N&nbsp;e&nbsp;x&nbsp;t&nbsp;F&nbsp;u&nbsp;l&nbsp;l
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapGetNextFull
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;returns&nbsp;the&nbsp;index&nbsp;of&nbsp;next&nbsp;Full&nbsp;&nbsp;entry&nbsp;in&nbsp;rwQue[],
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;starting&nbsp;from&nbsp;a&nbsp;given&nbsp;index.&nbsp;Sleeps&nbsp;if&nbsp;the&nbsp;entry
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;not&nbsp;Full.
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;index&nbsp;of&nbsp;the&nbsp;empty&nbsp;entry.
&nbsp;*************************************************************************/
static&nbsp;short
rapGetNextFull&nbsp;(short&nbsp;idx,&nbsp;uchar_t&nbsp;fromIntr)
{
&nbsp;&nbsp;&nbsp;&nbsp;cardInfo_t&nbsp;&nbsp;&nbsp;*ci;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s;
&nbsp;&nbsp;&nbsp;&nbsp;toid_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_id;
&nbsp;&nbsp;&nbsp;&nbsp;rwBuf_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*rw;
&nbsp;&nbsp;&nbsp;&nbsp;ci&nbsp;=&nbsp;&amp;cardInfo;
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapGetNextFull:&nbsp;Getting&nbsp;Next&nbsp;Full&nbsp;Buffer..idx&nbsp;=&nbsp;%d,&nbsp;fromIntr:&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;idx,&nbsp;fromIntr&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;go&nbsp;to&nbsp;beginning&nbsp;if&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;queu&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;idx++;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;idx&nbsp;>=&nbsp;RW_BUF_COUNT&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;rw&nbsp;=&nbsp;&amp;rwQue[idx];
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;buffer&nbsp;is&nbsp;not&nbsp;available&nbsp;and&nbsp;we&nbsp;were&nbsp;called&nbsp;from&nbsp;Intrupt
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;handler,&nbsp;simply&nbsp;ignore&nbsp;the&nbsp;request&nbsp;and&nbsp;return&nbsp;error
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;LOCK();
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!(rw->rw_state&nbsp;&amp;&nbsp;RW_FULL)&nbsp;&amp;&amp;&nbsp;(fromIntr)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapGetNextFull:&nbsp;Buffer&nbsp;%d&nbsp;is&nbsp;not&nbsp;Full.&nbsp;..Cannot&nbsp;Wait&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_idx);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(-1);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;wait&nbsp;for&nbsp;the&nbsp;buffer&nbsp;to&nbsp;become&nbsp;Full&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!(rw->rw_state&nbsp;&amp;&nbsp;RW_FULL)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_tout&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_id&nbsp;=&nbsp;itimeout&nbsp;(rapTimeOut,&nbsp;rw,&nbsp;RW_TIMEOUT,&nbsp;plbase,&nbsp;0,&nbsp;0,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(&nbsp;!(rw->rw_state&nbsp;&amp;&nbsp;RW_FULL)&nbsp;&amp;&amp;&nbsp;!ci->ri_tout&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapGetNextFull:&nbsp;&nbsp;Waiting&nbsp;for&nbsp;Buf&nbsp;%d&nbsp;to&nbsp;become&nbsp;Full&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_idx&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_state&nbsp;|=&nbsp;RW_WANTED_FULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;sleep(rw,&nbsp;PUSER&nbsp;|&nbsp;PCATCH)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;untimeout(to_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapGetNextFull:&nbsp;Interrupted&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_state&nbsp;&amp;=&nbsp;~RW_WANTED_FULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(-1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;untimeout&nbsp;(to_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->ri_tout&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;raGetNextFull:&nbsp;Timed&nbsp;out&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_state&nbsp;&amp;=&nbsp;~RW_WANTED_FULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(-1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;/*&nbsp;&nbsp;if&nbsp;!(rw->rw_state&nbsp;&amp;&nbsp;RW_FULL)&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapGetNextFull:&nbsp;next&nbsp;Full&nbsp;Buffer&nbsp;is&nbsp;%d&rdquo;,&nbsp;idx);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;return(idx);
}&nbsp;&nbsp;/***&nbsp;&nbsp;&nbsp;End&nbsp;rapGetNextFull&nbsp;&nbsp;&nbsp;***/
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;G&nbsp;e&nbsp;t&nbsp;N&nbsp;e&nbsp;x&nbsp;t&nbsp;E&nbsp;m&nbsp;p&nbsp;t&nbsp;y
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapGetNextEmpty
&nbsp;*
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;returns&nbsp;the&nbsp;index&nbsp;of&nbsp;next&nbsp;empty&nbsp;entry&nbsp;in&nbsp;rwQue[],
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;starting&nbsp;from&nbsp;a&nbsp;given&nbsp;index.&nbsp;Sleeps&nbsp;if&nbsp;the&nbsp;entry
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;not&nbsp;empty.
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;index&nbsp;of&nbsp;the&nbsp;empty&nbsp;entry.
&nbsp;*************************************************************************/
static&nbsp;short
rapGetNextEmpty&nbsp;(short&nbsp;idx,&nbsp;uchar_t&nbsp;fromIntr)
{
&nbsp;&nbsp;&nbsp;&nbsp;cardInfo_t&nbsp;&nbsp;*ci;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s;
&nbsp;&nbsp;&nbsp;&nbsp;toid_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_id;
&nbsp;&nbsp;&nbsp;&nbsp;rwBuf_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*rw;
&nbsp;&nbsp;&nbsp;&nbsp;ci&nbsp;=&nbsp;&amp;cardInfo;
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapGetNextEmpty:&nbsp;Getting&nbsp;Next&nbsp;Empty&nbsp;Buffer..idx&nbsp;=&nbsp;%d,&nbsp;fromIntr:&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx,&nbsp;fromIntr&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;go&nbsp;to&nbsp;beginning&nbsp;if&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;queu&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;idx++;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;idx&nbsp;>=&nbsp;RW_BUF_COUNT&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;idx&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;rw&nbsp;=&nbsp;&amp;rwQue[idx];
&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;LOCK();
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;buffer&nbsp;is&nbsp;nit&nbsp;available&nbsp;and&nbsp;we&nbsp;were&nbsp;called&nbsp;from&nbsp;Intrupt
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;handler,&nbsp;simply&nbsp;ignore&nbsp;the&nbsp;request&nbsp;and&nbsp;return&nbsp;error
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;(rw->rw_state&nbsp;&amp;&nbsp;RW_FULL)&nbsp;&amp;&amp;&nbsp;(fromIntr)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapGetNextEmpty:&nbsp;Buffer&nbsp;%d&nbsp;is&nbsp;not&nbsp;Empty&nbsp;..Cannot&nbsp;Wait&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_idx);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(-1);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;wait&nbsp;for&nbsp;the&nbsp;buffer&nbsp;to&nbsp;become&nbsp;Empty&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;rw->rw_state&nbsp;&amp;&nbsp;RW_FULL&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_tout&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_id&nbsp;=&nbsp;itimeout&nbsp;(rapTimeOut,&nbsp;rw,&nbsp;RW_TIMEOUT,&nbsp;plbase,&nbsp;0,&nbsp;0,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(&nbsp;(rw->rw_state&nbsp;&amp;&nbsp;&nbsp;RW_FULL)&nbsp;&amp;&amp;&nbsp;!ci->ri_tout&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapGetNextEmpty:&nbsp;Waiting&nbsp;for&nbsp;Buf&nbsp;%d&nbsp;to&nbsp;become&nbsp;Empty&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_idx&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_state&nbsp;|=&nbsp;RW_WANTED_EMPTY;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;sleep(rw,&nbsp;PUSER&nbsp;|&nbsp;PCATCH)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;untimeout(to_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapGetNextEmpty:&nbsp;Interrupted&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_state&nbsp;&amp;=&nbsp;~RW_WANTED_EMPTY;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(-1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;/*&nbsp;&nbsp;while&nbsp;..&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;untimeout&nbsp;(to_id);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->ri_tout&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;raGetNextEmpty:&nbsp;Timed&nbsp;out&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_state&nbsp;&amp;=&nbsp;~RW_WANTED_EMPTY;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(-1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;/*&nbsp;&nbsp;if&nbsp;(rw->rw_state&nbsp;&amp;&nbsp;RW_FULL)&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapGetNextEmpty:&nbsp;next&nbsp;Empty&nbsp;Buffer&nbsp;is&nbsp;%d&rdquo;,&nbsp;idx);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;return(idx);
}&nbsp;&nbsp;/***&nbsp;&nbsp;&nbsp;&nbsp;End&nbsp;rapGetNextEmpty&nbsp;&nbsp;&nbsp;***/
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;D&nbsp;i&nbsp;s&nbsp;I&nbsp;n&nbsp;t
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapDisInt
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disables&nbsp;RAP-10&nbsp;interrupts.
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;None.
&nbsp;*************************************************************************/
static&nbsp;void
rapDisInt(&nbsp;cardInfo_t&nbsp;&nbsp;&nbsp;*ci)
{
&nbsp;&nbsp;&nbsp;&nbsp;caddr_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addr;
&nbsp;&nbsp;&nbsp;&nbsp;ushort_t&nbsp;&nbsp;&nbsp;&nbsp;s;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c;
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapDisInt:&nbsp;full&nbsp;=&nbsp;%d,&nbsp;empty&nbsp;=&nbsp;%d,&nbsp;di_state&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_full,&nbsp;ci->ri_free,&nbsp;ci->di_state&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;addr&nbsp;=&nbsp;ci->ci_addr[0];
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;disable&nbsp;all&nbsp;Interrupts&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;OUTW(addr+GPDI,&nbsp;s);
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+DACM,&nbsp;0x00);
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+ADCM,&nbsp;0x00);
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapDisInt:&nbsp;Rap&nbsp;is&nbsp;set&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
}&nbsp;/***&nbsp;End&nbsp;rapDisInt&nbsp;&nbsp;***/
/**************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;G&nbsp;e&nbsp;t&nbsp;D&nbsp;m&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;**************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapGetDma
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;&nbsp;allocates&nbsp;dma&nbsp;Buf&nbsp;and&nbsp;Cb&nbsp;structures
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;=&nbsp;Success,&nbsp;&nbsp;1&nbsp;=&nbsp;Error
&nbsp;**************************************************************************/
static&nbsp;int
rapGetDma&nbsp;(&nbsp;dmaBuf_t&nbsp;&nbsp;**dmaB,&nbsp;&nbsp;dmaCb_t&nbsp;&nbsp;**dmaC,&nbsp;int&nbsp;ch&nbsp;)
{
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapGetDma:&nbsp;Getting&nbsp;Eisa&nbsp;Dma&nbsp;Buf&nbsp;and&nbsp;Cb&nbsp;for&nbsp;Channel&nbsp;%d&rdquo;,&nbsp;ch);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;*dmaB&nbsp;=&nbsp;eisa_dma_get_buf&nbsp;(EISA_DMA_SLEEP);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;*dmaB&nbsp;==&nbsp;NULL&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(1);
&nbsp;&nbsp;&nbsp;&nbsp;*dmaC&nbsp;=&nbsp;eisa_dma_get_cb&nbsp;(&nbsp;EISA_DMA_SLEEP&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;*dmaC&nbsp;==&nbsp;NULL&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(1);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(0);
}&nbsp;/***&nbsp;&nbsp;End&nbsp;rapGetDma&nbsp;&nbsp;&nbsp;***/
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;M&nbsp;a&nbsp;r&nbsp;k&nbsp;B&nbsp;u&nbsp;f
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapMarkBuf
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;&nbsp;Marks&nbsp;a&nbsp;buffer&nbsp;(Empty,&nbsp;Busy,&nbsp;Full)&nbsp;and&nbsp;increments/decrements
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;appropriate&nbsp;counters.&nbsp;Buffers&nbsp;status&nbsp;changed&nbsp;as:
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Empty&nbsp;->&nbsp;Busy&nbsp;->&nbsp;Full&nbsp;->&nbsp;Empty&nbsp;->&nbsp;Busy&nbsp;..
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;&nbsp;None.
&nbsp;*************************************************************************/
static&nbsp;void
rapMarkBuf&nbsp;(rwBuf_t&nbsp;&nbsp;*rw,&nbsp;cardInfo_t&nbsp;&nbsp;*ci,&nbsp;uchar_t&nbsp;&nbsp;m)
{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;s;
&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;LOCK();
&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(&nbsp;m&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;RW_EMPTY:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_state&nbsp;&amp;=&nbsp;~RW_FULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->ri_full&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_full--;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_free++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_count&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapMarkBuf:&nbsp;Buf&nbsp;%d&nbsp;set&nbsp;EMPTY.&nbsp;Full&nbsp;=&nbsp;%d,&nbsp;Emp&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_idx,&nbsp;ci->ri_full,&nbsp;ci->ri_free&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;RW_FULL:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_state&nbsp;|=&nbsp;RW_FULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_full++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->ri_free&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_free--;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_count&nbsp;=&nbsp;RW_BUF_SIZE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapMarkBuf:&nbsp;Buf&nbsp;%d&nbsp;set&nbsp;FULL.&nbsp;Full&nbsp;=&nbsp;%d,&nbsp;Emp&nbsp;=&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rw->rw_idx,&nbsp;ci->ri_full,&nbsp;ci->ri_free&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
}&nbsp;&nbsp;/***&nbsp;&nbsp;&nbsp;End&nbsp;rapMarkBuf&nbsp;&nbsp;&nbsp;***/
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;K&nbsp;e&nbsp;r&nbsp;n&nbsp;M&nbsp;e&nbsp;m
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapKernMem
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;&nbsp;Allocates/Disallocates&nbsp;Kernel&nbsp;memory&nbsp;for&nbsp;Right&nbsp;and
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Left&nbsp;DMA&nbsp;channels.
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;=&nbsp;Success,&nbsp;&nbsp;1&nbsp;=&nbsp;Failure.
&nbsp;*************************************************************************/
static&nbsp;int
rapKernMem&nbsp;(&nbsp;uchar_t&nbsp;what)
{
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapKernMem:&nbsp;%s&nbsp;Kernel&nbsp;Contigious&nbsp;Memory&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(what&nbsp;==&nbsp;1&nbsp;?&nbsp;&ldquo;Allocating&rdquo;&nbsp;:&nbsp;&ldquo;Deallocating&rdquo;)&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(&nbsp;what&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*=======================================*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocate&nbsp;Right/Left&nbsp;DMA&nbsp;Channels&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*=======================================*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;1:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaRight&nbsp;=&nbsp;kmem_alloc&nbsp;(DMA_BUF_SIZE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KM_NOSLEEP&nbsp;|&nbsp;KM_PHYSCONTIG&nbsp;|&nbsp;KM_CACHEALIGN&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;dmaRight&nbsp;==&nbsp;(caddr_t)NULL&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_WARN,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapKernMem:&nbsp;Cannot&nbsp;allocate&nbsp;DMA&nbsp;memory&nbsp;for&nbsp;R_chann&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaLeft&nbsp;=&nbsp;kmem_alloc&nbsp;(DMA_BUF_SIZE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KM_NOSLEEP&nbsp;|&nbsp;KM_PHYSCONTIG&nbsp;|&nbsp;KM_CACHEALIGN&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;dmaLeft&nbsp;==&nbsp;(caddr_t)NULL&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_WARN,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapKernMem:&nbsp;Cannot&nbsp;allocate&nbsp;DMA&nbsp;memory&nbsp;for&nbsp;L_chann&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kmem_free&nbsp;(dmaRight,&nbsp;DMA_BUF_SIZE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;get&nbsp;the&nbsp;physicall&nbsp;address&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaRightPhys&nbsp;=&nbsp;kvtophys(dmaRight);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaLeftPhys&nbsp;&nbsp;=&nbsp;kvtophys(dmaLeft);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*=======================================*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;Deallocate&nbsp;Right/Left&nbsp;DMA&nbsp;Channels&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*=======================================*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;2:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;dmaRight&nbsp;!=&nbsp;NULL&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kmem_free&nbsp;(dmaRight,&nbsp;DMA_BUF_SIZE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaRight&nbsp;=&nbsp;(caddr_t)NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;dmaLeft&nbsp;!=&nbsp;NULL&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kmem_free&nbsp;(dmaLeft,&nbsp;DMA_BUF_SIZE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaLeft&nbsp;=&nbsp;(caddr_t)NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(0);
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;/*&nbsp;switch&nbsp;*/
}&nbsp;&nbsp;/***&nbsp;&nbsp;&nbsp;End&nbsp;rapKernMem&nbsp;&nbsp;&nbsp;***/
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;T&nbsp;i&nbsp;m&nbsp;e&nbsp;O&nbsp;u&nbsp;t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapTimeOut
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;called&nbsp;when&nbsp;Read/Write&nbsp;waiting&nbsp;for&nbsp;buffers&nbsp;time&nbsp;out.
&nbsp;*&nbsp;&nbsp;Returns:
&nbsp;*************************************************************************/
static&nbsp;void
rapTimeOut(&nbsp;void&nbsp;*addr&nbsp;)
{
&nbsp;&nbsp;&nbsp;&nbsp;cardInfo_t&nbsp;&nbsp;&nbsp;&nbsp;*ci;
&nbsp;&nbsp;&nbsp;&nbsp;ci&nbsp;=&nbsp;&amp;cardInfo;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;indicate&nbsp;a&nbsp;timeout&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;ci->ri_tout&nbsp;=&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;wakeup&nbsp;(addr);
}
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;N&nbsp;o&nbsp;t&nbsp;e&nbsp;O&nbsp;n
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapNoteOn
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;&nbsp;Sends&nbsp;a&nbsp;MIDI&nbsp;Note_On&nbsp;message.
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;code&nbsp;is&nbsp;taken&nbsp;from&nbsp;RAP-10&nbsp;manual.
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;&nbsp;None.
&nbsp;*************************************************************************/
static&nbsp;void
rapNoteOn&nbsp;(&nbsp;cardInfo_t&nbsp;&nbsp;*ci,&nbsp;ushort_t&nbsp;orig_gpis)
{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s,&nbsp;stereo;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c,&nbsp;pan,&nbsp;rank,&nbsp;chksum,&nbsp;sum;
&nbsp;&nbsp;&nbsp;&nbsp;caddr_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addr;
&nbsp;&nbsp;&nbsp;&nbsp;ushort_t&nbsp;&nbsp;&nbsp;&nbsp;gpis;
&nbsp;&nbsp;&nbsp;&nbsp;addr&nbsp;=&nbsp;ci->ci_addr[0];
&nbsp;&nbsp;&nbsp;&nbsp;stereo&nbsp;=&nbsp;ci->ci_state&nbsp;&amp;&nbsp;CARD_STEREO;
&nbsp;&nbsp;&nbsp;&nbsp;pan&nbsp;=&nbsp;0x40;
&nbsp;&nbsp;&nbsp;&nbsp;rank&nbsp;=&nbsp;0x01;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;for&nbsp;22050&nbsp;Hz&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;gpis&nbsp;=&nbsp;orig_gpis;
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Busy&nbsp;wait&nbsp;till&nbsp;Txd&nbsp;Fifo&nbsp;is&nbsp;empty
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;The&nbsp;interrupt&nbsp;version&nbsp;is&nbsp;commenetd&nbsp;out&nbsp;below
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapNoteOn:&nbsp;Waiting&nbsp;for&nbsp;Txd&nbsp;Fifo&nbsp;Empty,&nbsp;gpis&nbsp;=&nbsp;%x&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpis);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(&nbsp;!(gpis&nbsp;&amp;&nbsp;GPIS_TXD)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpis&nbsp;=&nbsp;INPW(addr+GPIS);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapNoteOn:&nbsp;Waiting&nbsp;..new&nbsp;gpis&nbsp;=&nbsp;%x&rdquo;,&nbsp;gpis);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapNoteOn:&nbsp;Issuing&nbsp;a&nbsp;Note_On&nbsp;SysEx&nbsp;Cmd&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;send&nbsp;Note_On&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;0xf0;&nbsp;OUTB(addr+MDTD,&nbsp;c);
&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;0x41;&nbsp;OUTB(addr+MDTD,&nbsp;c);
&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;0x10;&nbsp;OUTB(addr+MDTD,&nbsp;c);
&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;0x56;&nbsp;OUTB(addr+MDTD,&nbsp;c);
&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;0x12;&nbsp;OUTB(addr+MDTD,&nbsp;c);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;stereo&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;0x03;&nbsp;OUTB(addr+MDTD,&nbsp;c);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;0x00;&nbsp;OUTB(addr+MDTD,&nbsp;c);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;0x01;&nbsp;OUTB(addr+MDTD,&nbsp;c);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;=&nbsp;0x03&nbsp;+&nbsp;0x01;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;0x02;&nbsp;OUTB(addr+MDTD,&nbsp;c);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;0x00;&nbsp;OUTB(addr+MDTD,&nbsp;c);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;0x0A+0x01;&nbsp;OUTB(addr+MDTD,&nbsp;c);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;=&nbsp;0x02+0x0A+0x01;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;0x01;&nbsp;OUTB(addr+MDTD,&nbsp;c);
&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;0x7F;&nbsp;OUTB(addr+MDTD,&nbsp;c);
&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;0x7F;&nbsp;OUTB(addr+MDTD,&nbsp;c);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;rank);
&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;+=&nbsp;(0x01+0x7F+0x7F+rank);
&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;0x40;&nbsp;OUTB(addr+MDTD,&nbsp;c);
&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;0x00;&nbsp;OUTB(addr+MDTD,&nbsp;c);
&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;0x40;&nbsp;OUTB(addr+MDTD,&nbsp;c);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;pan);
&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;+=&nbsp;(0x40+0x40+pan);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;calculate&nbsp;the&nbsp;checksum&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;chksum&nbsp;=&nbsp;(0x80&nbsp;-&nbsp;(sum&nbsp;%&nbsp;0x80))&nbsp;&amp;&nbsp;0x7F;
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;chksum);
&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;0xF7;&nbsp;OUTB(addr+MDTD,&nbsp;c);
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapNoteOn:&nbsp;Note_On&nbsp;Issued,&nbsp;chksum&nbsp;=&nbsp;%x&rdquo;,&nbsp;chksum);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
}&nbsp;&nbsp;/*&nbsp;end&nbsp;rapNoteOn&nbsp;&nbsp;*/
&nbsp;
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;N&nbsp;o&nbsp;t&nbsp;e&nbsp;O&nbsp;f&nbsp;f
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapNoteOff
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;&nbsp;Sends&nbsp;a&nbsp;MIDI&nbsp;Note_Off&nbsp;message.
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;code&nbsp;is&nbsp;taken&nbsp;from&nbsp;RAP-10&nbsp;manual.
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;&nbsp;None.
&nbsp;*************************************************************************/
static&nbsp;void
rapNoteOff&nbsp;(&nbsp;cardInfo_t&nbsp;&nbsp;*ci)
{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s,&nbsp;stereo;
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pan,&nbsp;b,&nbsp;rank,&nbsp;sum,&nbsp;chksum;
&nbsp;&nbsp;&nbsp;&nbsp;caddr_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addr;
&nbsp;&nbsp;&nbsp;&nbsp;ushort_t&nbsp;&nbsp;&nbsp;&nbsp;gpis;
&nbsp;&nbsp;&nbsp;&nbsp;addr&nbsp;=&nbsp;ci->ci_addr[0];
&nbsp;&nbsp;&nbsp;&nbsp;stereo&nbsp;=&nbsp;ci->ci_state&nbsp;&amp;&nbsp;CARD_STEREO;
&nbsp;&nbsp;&nbsp;&nbsp;pan&nbsp;=&nbsp;0x40;
&nbsp;&nbsp;&nbsp;&nbsp;rank&nbsp;=&nbsp;0x01;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;for&nbsp;22050&nbsp;Hz&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapNoteOff:&nbsp;Waiting&nbsp;for&nbsp;Txd&nbsp;Empty&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;wait&nbsp;till&nbsp;Txd&nbsp;is&nbsp;Empty&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;gpis&nbsp;=&nbsp;INPW(addr+GPIS);
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(&nbsp;!(gpis&nbsp;&amp;&nbsp;GPIS_TXD)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;us_delay(10);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gpis&nbsp;=&nbsp;INPW(addr+GPIS);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapNoteOff:&nbsp;Waiting&nbsp;..new&nbsp;gpis&nbsp;=&nbsp;%x&rdquo;,&nbsp;gpis);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapNoteOff:&nbsp;Issuing&nbsp;Note_Off&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;send&nbsp;Note_On&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;0xF0);
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;0x41);
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;0x10);
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;0x56);
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;0x12);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;stereo&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;0x03);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;0x00);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;0x01);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;=&nbsp;0x03&nbsp;+&nbsp;0x01;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;0x02);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;0x00);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;0x0A+0x01);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;=&nbsp;0x02&nbsp;+&nbsp;0x0A&nbsp;+&nbsp;0x01;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;0x00);
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;0x7F);
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;0x7F);
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;0x00);
&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;+=&nbsp;0x7F&nbsp;+&nbsp;0x7F;
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;0x40);
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;0x00);
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;0x40);
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;pan);
&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;+=&nbsp;0x40&nbsp;+&nbsp;0x40&nbsp;+&nbsp;pan;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;calculate&nbsp;checksum&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;chksum&nbsp;=&nbsp;(0x80&nbsp;-&nbsp;(sum&nbsp;%&nbsp;0x80))&nbsp;&amp;&nbsp;0x7F;
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;chksum);
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(addr+MDTD,&nbsp;0x7F);
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapNoteOff:&nbsp;Note_On&nbsp;Issued,&nbsp;chksum&nbsp;=&nbsp;%x&rdquo;,&nbsp;chksum);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
}&nbsp;&nbsp;/*&nbsp;&nbsp;end&nbsp;rapNoteOff&nbsp;&nbsp;*/
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;Z&nbsp;e&nbsp;r&nbsp;o&nbsp;D&nbsp;m&nbsp;a
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapZeroDma
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;Zero&nbsp;outs&nbsp;DMA&nbsp;buffers.
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;None.
&nbsp;*************************************************************************/
static&nbsp;void
rapZeroDma&nbsp;(cardInfo_t&nbsp;*ci,&nbsp;int&nbsp;bytes)
{
&nbsp;&nbsp;&nbsp;&nbsp;caddr_t&nbsp;dmaL,&nbsp;dmaR;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stereo,&nbsp;s;
&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;LOCK();
&nbsp;&nbsp;&nbsp;&nbsp;stereo&nbsp;=&nbsp;ci->ci_state&nbsp;&amp;&nbsp;CARD_STEREO;
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Zero&nbsp;out&nbsp;which&nbsp;half&nbsp;?
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->di_which&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaR&nbsp;=&nbsp;&amp;dmaRight[DMA_HALF_SIZE];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaL&nbsp;=&nbsp;&amp;dmaLeft[DMA_HALF_SIZE];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;bytes&nbsp;==&nbsp;DMA_BUF_SIZE&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bytes&nbsp;=&nbsp;DMA_HALF_SIZE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;Zer&nbsp;out&nbsp;1st&nbsp;half&nbsp;of&nbsp;dma&nbsp;buffers&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaR&nbsp;=&nbsp;&amp;dmaRight[0];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmaL&nbsp;=&nbsp;&amp;dmaLeft[0];
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapZeroDma:&nbsp;Zeroing&nbsp;out&nbsp;%s&nbsp;of&nbsp;Dma&nbsp;buffers&nbsp;in&nbsp;%s&nbsp;for&nbsp;%d&nbsp;bytes&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ci->di_which&nbsp;?&nbsp;&ldquo;2nd&nbsp;half&rdquo;:&rdquo;1st&nbsp;half&rdquo;),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stereo&nbsp;?&nbsp;&ldquo;Stereo&rdquo;:&rdquo;Mono&rdquo;),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bytes);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;bzero&nbsp;(dmaL,&nbsp;bytes);
&nbsp;&nbsp;&nbsp;&nbsp;dki_dcache_wbinval&nbsp;(dmaL,&nbsp;(unsigned)bytes);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;stereo&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bzero&nbsp;(dmaR,&nbsp;bytes);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dki_dcache_wbinval&nbsp;(dmaR,&nbsp;(unsigned)bytes);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(s);
}&nbsp;&nbsp;/***&nbsp;&nbsp;end&nbsp;rapZeroDma&nbsp;&nbsp;&nbsp;***/
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;R&nbsp;e&nbsp;l&nbsp;e&nbsp;a&nbsp;s&nbsp;e&nbsp;D&nbsp;m&nbsp;a
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapReleaseDma
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;Releases&nbsp;Dma&nbsp;channel(s).
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Note&nbsp;that&nbsp;we&nbsp;access&nbsp;kernel's&nbsp;Dma&nbsp;structure&nbsp;and&nbsp;later&nbsp;on
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;routine&nbsp;will&nbsp;be&nbsp;provided&nbsp;for&nbsp;us&nbsp;to&nbsp;avoid&nbsp;this.
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;None.
&nbsp;*************************************************************************/
static&nbsp;void
rapReleaseDma&nbsp;(cardInfo_t&nbsp;*ci)
{
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;disable&nbsp;Eisa&nbsp;Dma&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapReleaseDma:&nbsp;Releasing&nbsp;Eisa&nbsp;Dma&nbsp;Chann&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_dmaCh5);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;eisa_dma_disable(0,&nbsp;ci->ci_dmaCh5);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->ci_state&nbsp;&amp;&nbsp;CARD_STEREO&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,&nbsp;&ldquo;rapReleaseDma:&nbsp;Releasing&nbsp;Eisa&nbsp;Dma&nbsp;Chann&nbsp;%d&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ci->ci_dmaCh6);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eisa_dma_disable(0,&nbsp;ci->ci_dmaCh6);
&nbsp;&nbsp;&nbsp;&nbsp;}
}&nbsp;/***&nbsp;&nbsp;end&nbsp;rapReleaseDma&nbsp;&nbsp;&nbsp;&nbsp;***/
/*************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;a&nbsp;p&nbsp;S&nbsp;e&nbsp;t&nbsp;A&nbsp;u&nbsp;t&nbsp;o&nbsp;I&nbsp;n&nbsp;i&nbsp;t
&nbsp;*************************************************************************
&nbsp;*&nbsp;&nbsp;Name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rapSetAutoInit
&nbsp;*&nbsp;&nbsp;Purpose:&nbsp;&nbsp;&nbsp;sets&nbsp;Eisa&nbsp;DMA&nbsp;register&nbsp;for&nbsp;Autoinit.&nbsp;In&nbsp;Autoinit,&nbsp;DMA
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;starts&nbsp;over&nbsp;from&nbsp;the&nbsp;beginning&nbsp;of&nbsp;the&nbsp;buffer&nbsp;again&nbsp;once&nbsp;it
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;has&nbsp;transfered&nbsp;all&nbsp;bytes&nbsp;in&nbsp;the&nbsp;buffer.
&nbsp;*&nbsp;&nbsp;Returns:&nbsp;&nbsp;&nbsp;None.
&nbsp;*************************************************************************/
#define&nbsp;&nbsp;EISA_MODE_REG&nbsp;&nbsp;0xd6
#define&nbsp;&nbsp;EISA_CH5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x01
#define&nbsp;&nbsp;EISA_CH6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x02
#define&nbsp;&nbsp;EISA_WRITE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x04
#define&nbsp;&nbsp;EISA_READ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x08
#define&nbsp;&nbsp;EISA_AUTO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x10
static&nbsp;void
rapSetAutoInit(&nbsp;cardInfo_t&nbsp;&nbsp;*ci,&nbsp;uchar_t&nbsp;what)
{
&nbsp;&nbsp;&nbsp;&nbsp;uchar_t&nbsp;&nbsp;&nbsp;&nbsp;b;
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;DEBUG
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err&nbsp;(CE_NOTE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&ldquo;rapSetAutoInit:&nbsp;setting&nbsp;Autoinit&nbsp;DMA&nbsp;for&nbsp;%s,&nbsp;Eisa&nbsp;Addr&nbsp;=&nbsp;%x&rdquo;,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&nbsp;what&nbsp;==&nbsp;DI_DMA_PLAYING&nbsp;?&nbsp;&ldquo;Playback(D/A)&rdquo;&nbsp;:&nbsp;&ldquo;Record(A/D)&rdquo;&nbsp;),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eisa_addr&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;#endif
&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;what&nbsp;==&nbsp;DI_DMA_PLAYING&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;|=&nbsp;EISA_READ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;Memory&nbsp;->&nbsp;Device&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;|=&nbsp;EISA_WRITE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;Device&nbsp;->&nbsp;Memory&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;Autoinit&nbsp;for&nbsp;Channel&nbsp;5&nbsp;-&nbsp;Demand&nbsp;Mode&nbsp;select&nbsp;is&nbsp;default&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;|=&nbsp;(EISA_AUTO&nbsp;|&nbsp;EISA_CH5);
&nbsp;&nbsp;&nbsp;&nbsp;OUTB(eisa_addr+EISA_MODE_REG,&nbsp;b);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;&nbsp;Autoinit&nbsp;for&nbsp;Channel&nbsp;6&nbsp;(if&nbsp;in&nbsp;stereo&nbsp;mode)&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;ci->ci_state&nbsp;&amp;&nbsp;CARD_STEREO&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;&amp;=&nbsp;~EISA_CH5;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;|=&nbsp;EISA_CH6;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OUTB(eisa_addr+EISA_MODE_REG,&nbsp;b);
&nbsp;&nbsp;&nbsp;&nbsp;}
}&nbsp;&nbsp;/***&nbsp;&nbsp;&nbsp;End&nbsp;rapSetAutoInit&nbsp;&nbsp;&nbsp; ***/

</CODE>
</SECTION2>
</SECTION1>
</CHAPTER>
