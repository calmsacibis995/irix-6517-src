<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<APPENDIX LBL="A"><TITLE><XREFTARGET ID="31703">Silicon Graphics Driver/Kernel API</TITLE><PARAGRAPH>This appendix summarizes the Silicon Graphics Driver/Kernel Authorized Programming Interface in tabular form. The data structures, entry points, and kernel functions are listed alphabetically with with clickable links to discussions in this book and to their reference pages. The tables also show which functions and structures are compatible with SVR4 and which are unique to IRIX.</PARAGRAPH>
<PARAGRAPH>The tables in this appendix are based on the reference pages in volume D. The reference pages in volume D constitute the formal, engineering definition of the Driver/Kernel API. When discussion in this book disagrees with the contents of a reference page, the reference page takes precedence (however, any such disagreement should be reported by using the Feedback menu of the Insight viewer).</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="30453" TYPE="TITLE">&ldquo;Driver Exported Names&rdquo;</XREF> tabulates the names of data and functions that a driver must export.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="79761" TYPE="TITLE">&ldquo;Kernel Data Structures and Declarations&rdquo;</XREF> tabulates the objects used in the interface.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="32594" TYPE="TITLE">&ldquo;Kernel Functions&rdquo;</XREF> tabulates the IRIX kernel services used by drivers.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Each table in this appendix has a column headed &ldquo;Versions.&rdquo; The codes in this column have the following meanings: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>SV </PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="325"><PARAGRAPH>Syntactically and semantically portable from SVR4 UNIX, as documented 
in the <DOCTITLE>UNIX SVR4.2 Device Driver Reference</DOCTITLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>SV* </PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="325"><PARAGRAPH>Syntactically portable from UNIX SVR4, but semantics may differ. Read 
the discussion and reference page carefully when porting. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>5.3 </PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="325"><PARAGRAPH>Portable from IRIX version 5.3. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>5.3* </PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="325"><PARAGRAPH>Portable from IRIX 5.3, but interface has changed in some detail or new 
ability has been added. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>6.2 </PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="325"><PARAGRAPH>Portable from IRIX version 6.2. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="325"><PARAGRAPH>Introduced in IRIX 6.4. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="30453">Driver Exported Names</TITLE><PARAGRAPH>The kernel loader, <INDEXTARGET ID="xA-dkapi1"><!-- POSTPROCESSDATA: xA-dkapi1|entry points:summary tableentry points:AAA --><COMMAND>lboot</COMMAND>, recognizes certain exported names of static data and functional entry points. These exported names are summarized in <XREF IDREF="17664" TYPE="TABLE">Table&nbsp;A-1</XREF>. </PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="A-1"><PREFIX>Table A-1 </PREFIX><XREFTARGET ID="17664"> <EMPHASIS>(continued)        </EMPHASIS>Driver Exported Names</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="81"><PARAGRAPH>Name</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Summary</PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH>Discussed</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>Versions</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>attach() </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Notify driver of device attachment.</PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="54429" TYPE="TEXT">page&nbsp;153</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>close(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Notify driver of final close of minor device. </PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="14026" TYPE="TEXT">page&nbsp;160</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>SV, 5.3 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>detach() </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Notify driver of removed device.</PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="83670" TYPE="TEXT">page&nbsp;156</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>devflag(D1)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Show driver attributes to <COMMAND>lboot</COMMAND>.</PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="67704" TYPE="TEXT">page&nbsp;148</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>SV*, 5.3* </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>edtinit(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Initialize driver from VECTOR information 
(obsolete in 6.2).</PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="14072" TYPE="TEXT">page&nbsp;151</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>halt(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Notify driver of system shutdown.</PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="96840" TYPE="TEXT">page&nbsp;180</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>SV, 5.3 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>info(D1)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Show driver entries to STREAMS interface. </PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="84133" TYPE="TEXT">page&nbsp;750</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>SV, 5.3 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>init(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Initialize driver early in system startup.</PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="25548" TYPE="TEXT">page&nbsp;150</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>SV*, 5.3 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>intr(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Notify driver of device interrupt (obsolete). </PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="41192" TYPE="TEXT">page&nbsp;174</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>SV, 5.3 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>ioctl(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Call driver to implement <FUNCTION>ioctl</FUNCTION>() call.</PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="17370" TYPE="TEXT">page&nbsp;161</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>SV*, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>map(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Call driver to implement <FUNCTION>mmap</FUNCTION>().</PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="20168" TYPE="TEXT">page&nbsp;170</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>mmap(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Call driver to implement <FUNCTION>mmap</FUNCTION>() (SVR4). </PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="11008" TYPE="TEXT">page&nbsp;172</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>SV*, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>open(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Call driver to open a device.</PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="86115" TYPE="TEXT">page&nbsp;157</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>print(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Call block driver to display filesystem error. </PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="94783" TYPE="TEXT">page&nbsp;181</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>put(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Call STREAMS driver to receive message. </PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="22527" TYPE="TEXT">page&nbsp;752</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>read(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Call character driver to read data.</PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="66358" TYPE="TEXT">page&nbsp;162</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>reg() </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Call driver to register for device handling. </PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="36838" TYPE="TEXT">page&nbsp;152</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>size(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Call block driver to get device capacity.</PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="63295" TYPE="TEXT">page&nbsp;181</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>srv(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Call driver to service queued messages.</PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="85058" TYPE="TEXT">page&nbsp;753</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>start(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Initialize driver late in system startup.</PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="97690" TYPE="TEXT">page&nbsp;152</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>strategy(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Call block driver to read or write data. </PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="66319" TYPE="TEXT">page&nbsp;164</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>SV*, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>unload(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Call loadable driver prior to unloading it. </PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="57773" TYPE="TEXT">page&nbsp;179</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>unreg()</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Call driver to unregister as a device handler. </PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="36838" TYPE="TEXT">page&nbsp;152</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>unmap(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Call driver to notify it of unmap() call. </PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="61378" TYPE="TEXT">page&nbsp;173</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>write(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="190"><PARAGRAPH>Call character driver to write data. </PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="52"><PARAGRAPH><XREF IDREF="66358" TYPE="TEXT">page&nbsp;162</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="63"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The following reference pages have overview information on exported names: <REFPAGE>intro(D1)</REFPAGE>, <REFPAGE>intro(D2)</REFPAGE>, and <REFPAGE>prefix(D1)</REFPAGE>.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>The following SVR4 exported names are not used in IRIX drivers: chpoll, _load, and _unload. The latter is replaced by <VARIABLE>pfx</VARIABLE><FUNCTION>load()</FUNCTION> without the leading underscore.</NOTE>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="79761">Kernel Data Structures and Declarations</TITLE><PARAGRAPH>The driver/kernel interface is based on shared use of certain data types and defined constant values. For general information on these interface objects, see the <INDEXTARGET ID="xA-dkapi2"><!-- POSTPROCESSDATA: xA-dkapi2|data types:summary tabledata types:AAA --><REFPAGE>intro(D4)</REFPAGE> and <REFPAGE>intro(D5)</REFPAGE> reference pages.</PARAGRAPH>
<PARAGRAPH>The interface objects used by device drivers are summarized in <XREF IDREF="86140" TYPE="TABLE">Table&nbsp;A-2</XREF>.</PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="A-2"><PREFIX>Table A-2 </PREFIX><XREFTARGET ID="86140"> <EMPHASIS>(continued)        </EMPHASIS>Device Driver Interface Objects</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="90"><PARAGRAPH>Name</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="189"><PARAGRAPH>Summary</PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="51"><PARAGRAPH>Discussed</PARAGRAPH>
</CELL>
<CELL LEFT="350" WIDTH="56"><PARAGRAPH>Versions</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>&space;<REFPAGE>alenlist(d4x)</REFPAGE></PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="189"><PARAGRAPH>Address/length list.</PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="51"><PARAGRAPH><XREF IDREF="65822" TYPE="TEXT">page&nbsp;194</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="350" WIDTH="56"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>buf(D4)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="189"><PARAGRAPH>Block read/write request structure. </PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="51"><PARAGRAPH><XREF IDREF="34384" TYPE="TEXT">page&nbsp;196</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="350" WIDTH="56"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>eisa_dma_cb(D4)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="189"><PARAGRAPH>DMA command block for EISA slave DMA. </PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="51"><PARAGRAPH><XREF IDREF="50173" TYPE="TEXT">page&nbsp;595</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="350" WIDTH="56"><PARAGRAPH>5.3 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>eisa_dma_buf(D4)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="189"><PARAGRAPH>DMA command buffer for EISA slave DMA. </PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="51"><PARAGRAPH><XREF IDREF="50173" TYPE="TEXT">page&nbsp;595</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="350" WIDTH="56"><PARAGRAPH>5.3 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>errnos(D5)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="189"><PARAGRAPH>Error numbers valid for driver use. </PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="51"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="350" WIDTH="56"><PARAGRAPH>SV*, 5.3 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>iovec(D4)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="189"><PARAGRAPH>Describes an I/O buffer segment to the read or 
write entry points. </PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="51"><PARAGRAPH><XREF IDREF="39112" TYPE="TEXT">page&nbsp;195</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="350" WIDTH="56"><PARAGRAPH>SV, 5.3 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>signals(D5)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="189"><PARAGRAPH>Lists signal numbers valid for driver use. </PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="51"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="350" WIDTH="56"><PARAGRAPH>SV*, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>uio(D4)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="189"><PARAGRAPH>Describes an I/O request to the read or write 
entry points. </PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="51"><PARAGRAPH><XREF IDREF="39112" TYPE="TEXT">page&nbsp;195</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="350" WIDTH="56"><PARAGRAPH>SV*, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>&space;<REFPAGE>hwgraph.intro(d4x)</REFPAGE></PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="189"><PARAGRAPH>Hardware graph (hwgraph) vertexes and 
edges. </PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="51"><PARAGRAPH><XREF IDREF="95836" TYPE="TEXT">page&nbsp;192</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="350" WIDTH="56"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<NOTE><PREFIX>Note</PREFIX>The following data structures used in SVR4 drivers are not used in IRIX: <VARIABLE>dma_buf</VARIABLE> and <VARIABLE>dma_cb</VARIABLE>. The <VARIABLE>eisa_dma_buf</VARIABLE> and <VARIABLE>eisa_dma_cb</VARIABLE> structures are similar but are used only in EISA drivers.</NOTE>
<PARAGRAPH>The interface objects used by STREAMS drivers are summarized in <XREF IDREF="39431" TYPE="TABLE">Table&nbsp;A-3</XREF>.</PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="A-3"><PREFIX>Table A-3 </PREFIX><XREFTARGET ID="39431"> <EMPHASIS>(continued)        </EMPHASIS>STREAMS Driver Interface Objects</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="90"><PARAGRAPH>Name</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="189"><PARAGRAPH>Summary</PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="51"><PARAGRAPH>Discussed</PARAGRAPH>
</CELL>
<CELL LEFT="350" WIDTH="56"><PARAGRAPH>Versions</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>copyreq(D4)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="189"><PARAGRAPH>Copy request structure.</PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="51"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="350" WIDTH="56"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>copyresp(D4)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="189"><PARAGRAPH>Copy response structure.</PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="51"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="350" WIDTH="56"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>datab(D4)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="189"><PARAGRAPH>Message data block.</PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="51"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="350" WIDTH="56"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>free_rtn(D4)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="189"><PARAGRAPH>Describes a message-free routine.</PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="51"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="350" WIDTH="56"><PARAGRAPH>SV, 5.3 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>iocblk(D4)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="189"><PARAGRAPH>Describes ioctl() data or response.</PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="51"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="350" WIDTH="56"><PARAGRAPH>SV, 5.3 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>linkblk(D4)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="189"><PARAGRAPH>Describes multiplexed link.</PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="51"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="350" WIDTH="56"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>module_info(D4)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="189"><PARAGRAPH>Describes module attributes.</PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="51"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="350" WIDTH="56"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>msgb(D4)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="189"><PARAGRAPH>Describes all or part of a message.</PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="51"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="350" WIDTH="56"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>qinit(D4)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="189"><PARAGRAPH>Points to handlers and parameters for a queue. </PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="51"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="350" WIDTH="56"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>queue(D4)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="189"><PARAGRAPH>Describes a queue of messages.</PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="51"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="350" WIDTH="56"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>streamtab(D4)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="189"><PARAGRAPH>Points to the queues handled by a driver.</PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="51"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="350" WIDTH="56"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>stroptions(D4)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="189"><PARAGRAPH>Lists stream-head options.</PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="51"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="350" WIDTH="56"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="32594">Kernel Functions</TITLE><PARAGRAPH>The IRIX kernel makes available the functions summarized in <INDEXTARGET ID="xA-dkapi3"><!-- POSTPROCESSDATA: xA-dkapi3|kernel functions:summary tablekernel functions:AAA --><XREF IDREF="96441" TYPE="TABLE">Table&nbsp;A-4</XREF>.</PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="A-4"><PREFIX>Table A-4 </PREFIX><XREFTARGET ID="96441"> <EMPHASIS>(continued)        </EMPHASIS>Kernel Functions</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="153"><PARAGRAPH>Name</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Summary</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH>Text</PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>Versions</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>adjmsg(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Trim bytes from a message. </PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="73571" TYPE="TEXT">page&nbsp;213</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>alenlist_append() (<REFPAGE>alenlist_ops(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Add a specified address and length &lbreak;as an item to an existing alenlist. </PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="47096" TYPE="TEXT">page&nbsp;214</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>alenlist_clear() (<REFPAGE>alenlist_ops(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Empty an alenlist.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="47096" TYPE="TEXT">page&nbsp;214</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>alenlist_create() (<REFPAGE>alenlist_ops(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Create an empty alenlist.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="73571" TYPE="TEXT">page&nbsp;213</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>alenlist_cursor_create() 
(<REFPAGE>alenlist_ops(d3x)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Create an alenlist cursor and associate &lbreak;it with a specified list.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="46391" TYPE="TEXT">page&nbsp;215</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>alenlist_cursor_destroy() 
(<REFPAGE>alenlist_ops(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Release memory of a cursor.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="46391" TYPE="TEXT">page&nbsp;215</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>alenlist_cursor_init() 
(<REFPAGE>alenlist_ops(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Set a cursor to point at a specified list 
item.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="46391" TYPE="TEXT">page&nbsp;215</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>alenlist_cursor_offset() 
(<REFPAGE>alenlist_ops(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Query the effective byte offset of a 
cursor in the buffer described by a list. </PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="46391" TYPE="TEXT">page&nbsp;215</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>alenlist_destroy() (<REFPAGE>alenlist_ops(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Release memory of an alenlist.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="73571" TYPE="TEXT">page&nbsp;213</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>alenlist_get() (<REFPAGE>alenlist_ops(d3x)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Retrieve the next sequential address&lbreak;and length from a list.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="73571" TYPE="TEXT">page&nbsp;213</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>allocb(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate a message block.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>ASSERT(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Debugging macro designed for use &lbreak;in the kernel (compare to <REFPAGE>assert(3X)</REFPAGE>).</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="85359" TYPE="TEXT">page&nbsp;277</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>badaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Test physical address for input.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="54173" TYPE="TEXT">page&nbsp;221</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>badaddr_val(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Test physical address for input and 
return the input value received.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="54173" TYPE="TEXT">page&nbsp;221</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.2</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>bcanput(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Test for flow control in a specified 
priority band. </PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>bcanputnext(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Test for flow control in a specified 
priority band. </PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>bcmp(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Compare data between kernel &lbreak;locations. </PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="98484" TYPE="TEXT">page&nbsp;208</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>bcopy(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Copy data between locations in the 
kernel. </PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="98484" TYPE="TEXT">page&nbsp;208</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>biodone(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Mark a <VARIABLE>buf_t</VARIABLE> as complete and wake &lbreak;any process waiting for it.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="78884" TYPE="TEXT">page&nbsp;245</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>&space;SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>bioerror(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Manipulate error fields within a &lbreak;<VARIABLE>buf_t</VARIABLE>.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="78884" TYPE="TEXT">page&nbsp;245</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>biowait(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Suspend process pending completion of 
block I/O. </PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="78884" TYPE="TEXT">page&nbsp;245</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>bp_mapin(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Map buffer pages into kernel virtual 
address space.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="41107" TYPE="TEXT">page&nbsp;218</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>bp_mapout(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Release mapping of buffer pages.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="41107" TYPE="TEXT">page&nbsp;218</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>bptophys(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get physical address of buffer data.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="40016" TYPE="TEXT">page&nbsp;233</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>brelse(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Return a buffer to the system's free &lbreak;list.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="70392" TYPE="TEXT">page&nbsp;206</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>btod(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Return number of 512-byte &ldquo;sectors&rdquo;&lbreak;in a byte count (round up). </PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="54064" TYPE="TEXT">page&nbsp;211</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>btop(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Return number of I/O pages in a byte 
count (truncate).</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="54064" TYPE="TEXT">page&nbsp;211</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>btopr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Return number of I/O pages in a byte 
count (round up).</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="54064" TYPE="TEXT">page&nbsp;211</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>bufcall(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Call a function when a buffer becomes 
available.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>buf_to_alenlist() (<REFPAGE>alenlist_ops(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Fill an alenlist with entries that &lbreak;describe the buffer controlled by a buf_t 
object. </PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="47096" TYPE="TEXT">page&nbsp;214</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>bzero(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Clear kernel memory for a specified 
size. </PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="22073" TYPE="TEXT">page&nbsp;207</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>canput(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Test for room in a message queue.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>canputnext(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Test for room in a message queue.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>clrbuf(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Erase the contents of a buffer described 
by a buf_t.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="41107" TYPE="TEXT">page&nbsp;218</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>cmn_err(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Display an error message or panic the 
system.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="49566" TYPE="TEXT">page&nbsp;274</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>copyb(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Copy a message block.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>copyin(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Copy data from user address space.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="22073" TYPE="TEXT">page&nbsp;207</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>copymsg(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Copy a message.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>copyout(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Copy data to user address space.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="22073" TYPE="TEXT">page&nbsp;207</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>cpsema(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Conditionally decrement a &lbreak;semaphore's state.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="42679" TYPE="TEXT">page&nbsp;250</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>cvsema(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Conditionally increment a &lbreak;semaphore's state.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="42679" TYPE="TEXT">page&nbsp;250</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>datamsg(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Test whether a message is a data 
message.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>delay(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Delay for a specified number of clock 
ticks.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="56199" TYPE="TEXT">page&nbsp;242</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>device_admin_info_get() 
(<REFPAGE>hwgraph.admin(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Retrieve value set with 
DEVICE_ADMIN statement.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="57823" TYPE="TEXT">page&nbsp;231</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>device_controller_num_get() 
(<REFPAGE>hwgraph.dev(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get controller number from first 
inventory record in a vertex.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="92258" TYPE="TEXT">page&nbsp;230</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>device_controller_num_get() 
(<REFPAGE>hwgraph.dev(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Set controller number field only in &lbreak;first inventory record in a vertex.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="92258" TYPE="TEXT">page&nbsp;230</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>device_driver_admin_info_get() 
(<REFPAGE>hwgraph.admin(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Retrieve value set with 
DRIVER_ADMIN statement.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="57823" TYPE="TEXT">page&nbsp;231</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>device_info_get() (<REFPAGE>hwgraph.dev(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Return device info pointer stored in 
vertex.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="70160" TYPE="TEXT">page&nbsp;222</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>device_info_set() (<REFPAGE>hwgraph.dev(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Store the address of device&lbreak;information in a vertex.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="12806" TYPE="TEXT">page&nbsp;223</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>device_inventory_add() 
(<REFPAGE>hwgraph.inv(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Add hardware inventory data to a 
vertex.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="92258" TYPE="TEXT">page&nbsp;230</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>device_inventory_get_next() 
(<REFPAGE>hwgraph.inv(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Read out inventory data from a &lbreak;vertex.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="92258" TYPE="TEXT">page&nbsp;230</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>disable_sysad_parity()</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Disable memory parity checking on 
SysAD bus.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="23199" TYPE="TEXT">page&nbsp;674</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>dki_dcache_inval(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Invalidate the data cache for a given 
range of virtual addresses.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="65953" TYPE="TEXT">page&nbsp;220</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>dki_dcache_wb(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Write back the data cache for a given 
range of virtual addresses.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="65953" TYPE="TEXT">page&nbsp;220</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>dki_dcache_wbinval(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Write back and invalidate the data &lbreak;cache for a given range of virtual 
addresses.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="65953" TYPE="TEXT">page&nbsp;220</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>dma_map(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Load DMA mapping registers for an 
imminent transfer.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>dma_mapbp(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Load DMA mapping registers for an 
imminent transfer.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>dma_mapaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Return the &ldquo;bus virtual&rdquo; address for a 
given map and address.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>dma_mapalloc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate a DMA map.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>dma_mapfree(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Free a DMA map.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>drv_getparm(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Retrieve kernel state information.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="35201" TYPE="TEXT">page&nbsp;232</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>drv_hztousec(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Convert clock ticks to microseconds.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="56199" TYPE="TEXT">page&nbsp;242</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>drv_priv(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Test for privileged user.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="35201" TYPE="TEXT">page&nbsp;232</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>drv_setparm(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Set kernel state information.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="35201" TYPE="TEXT">page&nbsp;232</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>drv_usectohz(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Convert microseconds to clock ticks.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="56199" TYPE="TEXT">page&nbsp;242</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>drv_usecwait(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Busy-wait for a specified interval.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="56199" TYPE="TEXT">page&nbsp;242</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>dtimeout(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Schedule a function execute on a 
specified processor after a specified 
length of time.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="56199" TYPE="TEXT">page&nbsp;242</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>dupb(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Duplicate a message block.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>dupmsg(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Duplicate a message.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>eisa_dma_disable(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Disable recognition of hardware 
requests on EISA DMA channel.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="50173" TYPE="TEXT">page&nbsp;595</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>eisa_dma_enable(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Enable recognition of hardware &lbreak;requests on EISA DMA channel.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="50173" TYPE="TEXT">page&nbsp;595</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>eisa_dma_free_buf(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Free a previously allocated EISA DMA 
buffer descriptor.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="50173" TYPE="TEXT">page&nbsp;595</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>eisa_dma_free_cb(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Free a previously allocated EISA DMA 
command block.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="50173" TYPE="TEXT">page&nbsp;595</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>eisa_dma_get_buf(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate EISA DMA buffer descriptor.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="50173" TYPE="TEXT">page&nbsp;595</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>eisa_dma_get_cb(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate EISA DMA command block.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="50173" TYPE="TEXT">page&nbsp;595</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>eisa_dma_prog(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Program EISA DMA operation for a 
subsequent software request.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="50173" TYPE="TEXT">page&nbsp;595</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>eisa_dma_stop(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Stop software-initiated EISA DMA 
operation and release channel.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="50173" TYPE="TEXT">page&nbsp;595</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>eisa_dma_swstart(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Initiate EISA DMA operation via 
software request.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="50173" TYPE="TEXT">page&nbsp;595</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>eisa_dmachan_alloc()</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate a DMA channel for EISA &lbreak;slave DMA.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="83162" TYPE="TEXT">page&nbsp;593</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>eisa_ivec_alloc()</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate an IRQ level for EISA.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="81827" TYPE="TEXT">page&nbsp;591</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>eisa_ivec_set()</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Associate a handler with an EISA&lbreak;IRQ.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="81827" TYPE="TEXT">page&nbsp;591</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>enableok(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allow a queue to be serviced.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>enable_sysad_parity()</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Reenable parity checking on SysAD &lbreak;bus.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="23199" TYPE="TEXT">page&nbsp;674</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>esballoc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate a message block using an 
externally-supplied buffer.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>esbbcall(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Call a function when an 
externally-supplied buffer can be 
allocated.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>etoimajor(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Convert external to internal major 
device number.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="14986" TYPE="TEXT">page&nbsp;199</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>fast_itimeout(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Same as itimeout() but takes an &lbreak;interval in &ldquo;fast ticks.&rdquo;</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="56199" TYPE="TEXT">page&nbsp;242</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.2</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>fasthzto(D3)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Returns the value of a <VARIABLE>struct</VARIABLE>&space;<VARIABLE>timeval</VARIABLE> as &lbreak;a count of &ldquo;fast ticks.&rdquo;</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="56199" TYPE="TEXT">page&nbsp;242</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.2</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>flushband(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Flush messages in a specified priority 
band.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>flushbus(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Make sure contents of the write buffer 
are flushed to the system bus.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="65953" TYPE="TEXT">page&nbsp;220</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>flushq(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Flush messages on a queue.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>freeb(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Free a message block.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>freemsg(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Free a message.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>freerbuf(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Free a buf_t with no buffer.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="70392" TYPE="TEXT">page&nbsp;206</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>freesema(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Free the resources associated with a 
semaphore.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="42679" TYPE="TEXT">page&nbsp;250</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>freezestr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Freeze the state of a stream.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>fubyte(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Load a byte from user space.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="22073" TYPE="TEXT">page&nbsp;207</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>fuword(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Load a word from user space.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="22073" TYPE="TEXT">page&nbsp;207</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>geteblk(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get a buf_t with no buffer.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="70392" TYPE="TEXT">page&nbsp;206</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>getemajor(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get external major device number.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="14986" TYPE="TEXT">page&nbsp;199</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>geteminor(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get external minor device number.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="14986" TYPE="TEXT">page&nbsp;199</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>geterror(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>retrieve error number from a buffer 
header.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="78884" TYPE="TEXT">page&nbsp;245</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>getmajor(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get internal major device number 
(obsolete).</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="14986" TYPE="TEXT">page&nbsp;199</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>getminor(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get internal minor device number 
(obsolete).</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="14986" TYPE="TEXT">page&nbsp;199</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>getnextpg(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Return <VARIABLE>pfdat</VARIABLE> structure for next page.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="41107" TYPE="TEXT">page&nbsp;235</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>getq(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get the next message from a queue.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>getrbuf(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate a <VARIABLE>buf_t</VARIABLE> with no buffer.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="70392" TYPE="TEXT">page&nbsp;206</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>hwcpin(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Copy data from device registers to 
kernel memory.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="22073" TYPE="TEXT">page&nbsp;207</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>hwcpout(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Copy data from kernel memory to 
device registers.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="22073" TYPE="TEXT">page&nbsp;207</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>hwgraph_block_device_add() 
(<REFPAGE>hwgraph.dev(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Create block device special file under a 
specified vertex.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="12806" TYPE="TEXT">page&nbsp;223</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>hwgraph_char_device_add() 
(<REFPAGE>hwgraph.dev(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Create a character device special file 
under a specified vertex.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="12806" TYPE="TEXT">page&nbsp;223</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>hwgraph_edge_add() 
(<REFPAGE>hwgraph.edge(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Add a labelled edge between two 
vertexes.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="12806" TYPE="TEXT">page&nbsp;223</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>hwgraph_edge_get() 
(<REFPAGE>hwgraph.edge(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Retrieve the vertex destination of a 
labelled edge (follow edge).</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="12806" TYPE="TEXT">page&nbsp;223</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>hwgraph_edge_remove() 
(<REFPAGE>hwgraph.edge(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Delete a labelled edge between two 
vertexes.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="12806" TYPE="TEXT">page&nbsp;223</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>hwgraph_info_add_LBL() 
(<REFPAGE>hwgraph.lblinfo(d3x)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Attach a labelled attribute to a vertex.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="53606" TYPE="TEXT">page&nbsp;229</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>hwgraph_info_export_LBL() 
(<REFPAGE>hwgraph.lblinfo(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Make an attribute visible to &lbreak;<REFPAGE>attr_get(2)</REFPAGE>.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="53606" TYPE="TEXT">page&nbsp;229</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>hwgraph_info_get_LBL() 
(<REFPAGE>hwgraph.lblinfo(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Retrieve an attribute by name.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="53606" TYPE="TEXT">page&nbsp;229</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>hwgraph_info_remove_LBL() 
(<REFPAGE>hwgraph.lblinfo(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Remove an attribute from a vertex.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="53606" TYPE="TEXT">page&nbsp;229</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>hwgraph_info_replace_LBL() 
(<REFPAGE>hwgraph.lblinfo(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Replace the value of an attribute by 
name.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="53606" TYPE="TEXT">page&nbsp;229</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>hwgraph_info_unexport_LBL() 
(<REFPAGE>hwgraph.lblinfo(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Make an attribute invisible.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="53606" TYPE="TEXT">page&nbsp;229</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>hwgraph_traverse() 
(<REFPAGE>hwgraph.edge(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Follow a path of edges starting from &lbreak;a given vertex.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="12806" TYPE="TEXT">page&nbsp;223</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>hwgraph_vertex_create() 
(<REFPAGE>hwgraph.vertex(d3x)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Create a new, empty vertex, and &lbreak;return its handle.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="12806" TYPE="TEXT">page&nbsp;223</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>hwgraph_vertex_destroy() 
(<REFPAGE>hwgraph.vertex(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Deallocate a vertex.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>hwgraph_vertex_ref() 
(hwgraph.vertex(d3x))</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Increase the reference count of a vertex.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>hwgraph_vertex_unref() 
(<REFPAGE>hwgraph.vertex(d3x)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Decrease the reference count of a vertex.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>initnsema(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Initialize a semaphore to a specified 
count.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="42679" TYPE="TEXT">page&nbsp;250</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>initnsema_mutex(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Initialize a semaphore to a count of 1.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="42679" TYPE="TEXT">page&nbsp;250</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>insq(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Insert a message into a queue.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>ip26_enable_ucmem(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Change memory mode on IP26 
processor.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="17413" TYPE="TEXT">page&nbsp;32</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.2</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>ip26_return_ucmem(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Change memory mode on IP26 
processor.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="17413" TYPE="TEXT">page&nbsp;32</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>is_sysad_parity_enabled()</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Test for parity checking on SysAD bus.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="23199" TYPE="TEXT">page&nbsp;674</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>itimeout(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Schedule a function to be executed &lbreak;after a specified number of clock ticks.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="56199" TYPE="TEXT">page&nbsp;242</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>itoemajor(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Convert internal to external major 
device number.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="14986" TYPE="TEXT">page&nbsp;199</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>kern_calloc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate and clear space from kernel 
memory.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="68494" TYPE="TEXT">page&nbsp;203</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>kern_free(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Free kernel memory space.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="68494" TYPE="TEXT">page&nbsp;203</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>kern_malloc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate kernel virtual memory.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="68494" TYPE="TEXT">page&nbsp;203</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>kmem_alloc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate space from kernel free &lbreak;memory.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="68494" TYPE="TEXT">page&nbsp;203</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>kmem_free(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Free previously allocated kernel 
memory.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="68494" TYPE="TEXT">page&nbsp;203</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>kmem_zalloc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate and clear space from kernel 
free memory.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="68494" TYPE="TEXT">page&nbsp;203</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>kvaddr_to_alenlist() 
(<REFPAGE>alenlist_ops</REFPAGE>(d3x))</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Fill an alenlist with entries that&lbreak;describe a buffer in kernel virtual 
address space.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="47096" TYPE="TEXT">page&nbsp;214</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.2</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>kvtophys(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get physical address of kernel data.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="77908" TYPE="TEXT">page&nbsp;218</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>linkb(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Concatenate two message blocks.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>LOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Acquire a basic lock, waiting if 
necessary.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="59834" TYPE="TEXT">page&nbsp;235</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>LOCK_ALLOC(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate and initialize a basic lock.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="59834" TYPE="TEXT">page&nbsp;235</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>LOCK_DEALLOC(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Deallocate an instance of a basic lock.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="59834" TYPE="TEXT">page&nbsp;235</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>LOCK_INIT(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Initialize a basic lock that was allocated 
statically, or reinitialize an allocated 
lock.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="59834" TYPE="TEXT">page&nbsp;235</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.2</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>LOCK_DESTROY(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Uninitialize a basic lock that was 
allocated statically.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="59834" TYPE="TEXT">page&nbsp;235</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.2</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>makedevice(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Make device number from major and 
minor numbers.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="14986" TYPE="TEXT">page&nbsp;199</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>max(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Return the larger of two integers.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>min(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Return the lesser of two integers.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>msgdsize(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Return number of bytes of data in a 
message.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>msgpullup(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Concatenate bytes in a message.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>MUTEX_ALLOC(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate and initialize a mutex lock.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="29043" TYPE="TEXT">page&nbsp;237</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.2</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>MUTEX_DEALLOC(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Deinitialize and free a dynamically 
allocated mutex lock.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="29043" TYPE="TEXT">page&nbsp;237</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.2</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>MUTEX_DESTROY(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Deinitialize a mutex lock.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="29043" TYPE="TEXT">page&nbsp;237</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.2</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>MUTEX_INIT(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Initialize an existing mutex lock.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="29043" TYPE="TEXT">page&nbsp;237</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.2</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>MUTEX_LOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Claim a mutex lock.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="29043" TYPE="TEXT">page&nbsp;237</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.2</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>MUTEX_MINE(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Test if a mutex lock is owned by this 
process.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="29043" TYPE="TEXT">page&nbsp;237</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.2</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>MUTEX_OWNED(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Query if a mutex lock is available.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="29043" TYPE="TEXT">page&nbsp;237</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.5</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>MUTEX_TRYLOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Conditionally claim a mutex lock.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="29043" TYPE="TEXT">page&nbsp;237</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.2</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>MUTEX_UNLOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Release a mutex lock.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="29043" TYPE="TEXT">page&nbsp;237</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.2</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>ngeteblk(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate a <VARIABLE>buf_t</VARIABLE> and a buffer of &lbreak;specified size.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="70392" TYPE="TEXT">page&nbsp;206</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>noenable(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Prevent a queue from being scheduled.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>OTHERQ(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get a pointer to queue's partner queue.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_dma_dev_get() (<REFPAGE>pciio_get(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get device vertex from DMA map.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_dma_slot_get() (<REFPAGE>pciio_get(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get slot number from DMA map.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>pciio_dmaaddr_drain(D3)</REFPAGE></PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Ensure DMA is complete.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.5</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>pciio_dmalist_drain(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Ensure DMA is complete.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.5</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_dmamap_addr() 
(<REFPAGE>pciio_dma(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Set up DMA mapping for an address.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_dmamap_alloc() 
(<REFPAGE>pciio_dma(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate DMA map object.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_dmamap_done() 
(<REFPAGE>pciio_dma(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Release mapping hardware associated 
with a map object.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_dmamap_drain() 
(<REFPAGE>pciio_dma(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Ensure DMA is complete.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.5</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_dmamap_free() (<REFPAGE>pciio_dma(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Release DMA map object.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_dmamap_list() (<REFPAGE>pciio_dma(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Set up DMA mapping for a list of 
addresses.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_dmatrans_addr() 
(<REFPAGE>pciio_dma(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Set up DMA mapping using fixed 
resources if available.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_dmatrans_list() (<REFPAGE>pciio_dma(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Set up DMA mapping using fixed 
resources if available.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_driver_register() (<REFPAGE>pciio(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Register driver to handle specific 
devices.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_driver_unregister() (<REFPAGE>pciio(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Unregister driver as device handler.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_error_register() (<REFPAGE>pciio_error(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Register error handler for device.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_info_bus_get() (<REFPAGE>pciio_get(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Query PCI bus number for device.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_info_dev_get() (<REFPAGE>pciio_get(d3)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Query connection vertex for device.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_info_device_id_get() 
(<REFPAGE>pciio_get(d3)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Query PCI device ID for device.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_info_func_get() (<REFPAGE>pciio_get(d3)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Query interrupt function for device.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_info_get() (<REFPAGE>pciio_get(d3)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get PCI info object for use in queries.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_info_slot_get() (<REFPAGE>pciio_get(d3)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Query bus slot number for device.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_info_vendor_id_get() 
(<REFPAGE>pciio_get(d3)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Query PCI vendor ID for device.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_intr_alloc() (<REFPAGE>pciio_intr(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate interrupt object.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_intr_connect() (<REFPAGE>pciio_intr(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Enable interrupt and set handler.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_intr_cpu_get() (<REFPAGE>pciio_get(d3)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Query CPU handling interrupt from 
device.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_intr_dev_get() (<REFPAGE>pciio_get(d3)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get device vertex from interrupt object.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_intr_disconnect() 
(<REFPAGE>pciio_intr(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Disable interrupt and unregister 
handler.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_intr_free() (<REFPAGE>pciio_intr(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Release interrupt object.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_iterate() (<REFPAGE>pciio(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Call function for every attached device.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_pio_addr() (<REFPAGE>pciio_pio(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Set up PIO mapping using map object.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_pio_dev_get() (<REFPAGE>pciio_get(d3)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get device vertex from PIO map.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_pio_mapsz_get() (<REFPAGE>pciio_get(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get map size from PIO map object.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_pio_pciaddr_get() 
(<REFPAGE>pciio_get(d3)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get target bus address from PIO map 
object.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_pio_slot_get() (<REFPAGE>pciio_get(d3)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Query bus slot number from PIO map.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_pio_space_get() (<REFPAGE>pciio_get(d3)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Query target bus address space from 
PIO map.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_piomap_addr() (<REFPAGE>pciio_pio(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Set up PIO mapping using map object.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_piomap_alloc() (<REFPAGE>pciio_pio(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate PIO map object.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_piomap_done() (<REFPAGE>pciio_pio(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Release mapping hardware associated 
with a PIO map.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_piomap_free() (<REFPAGE>pciio_pio(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Release a PIO map object.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_piospace_alloc() (<REFPAGE>pciio_pio(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Reserve PCI bus address space for a 
device.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_piospace_free() (<REFPAGE>pciio_pio(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Release PCI bus address space.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_piotrans_addr() (<REFPAGE>pciio_pio(d3)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Set up PIO mapping using fixed 
resources if available.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>pciio_reset() (<REFPAGE>pciio(d3)</REFPAGE>)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Activate reset line of PCI card.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>pcmsg(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Test whether a message is a priority 
control message.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>phalloc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate and initialize a pollhead 
structure.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="54411" TYPE="TEXT">page&nbsp;205</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>phfree(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Free a pollhead structure.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="54411" TYPE="TEXT">page&nbsp;205</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>physiock(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Validate and issue a raw I/O request.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="78884" TYPE="TEXT">page&nbsp;245</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>pio_andb_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Byte read-and-write.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>pio_andh_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>16-bit read-and-write.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>pio_andw_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>32-bit read-and-write.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>pio_badaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Check for bus error when reading an 
address.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>pio_badaddr_val(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Check for bus error when reading an 
address and return the value read.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>pio_bcopyin(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Copy data from a bus address to 
kernel's virtual space.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>pio_bcopyout(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Copy data from kernel's virtual space to 
a bus address.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>pio_mapaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Convert a bus address to a virtual 
address.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>pio_mapalloc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate a PIO map.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>pio_mapfree(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Free a PIO map.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>pio_orb_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Byte read-or-write.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>pio_orh_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>16-bit read-or-write.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>pio_orw_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>32-bit read-or-write.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>pio_wbadaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Check for bus error when writing to an 
address.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>pio_wbadaddr_val(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Check for bus error when writing a 
specified value to an address.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>pollwakeup(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Inform polling processes that an event 
has occurred.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="35890" TYPE="TEXT">page&nbsp;166</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>pptophys(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Convert page pointer to physical 
address.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="41107" TYPE="TEXT">page&nbsp;235</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>proc_ref(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Obtain a reference to a process for 
signaling.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="35201" TYPE="TEXT">page&nbsp;232</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>proc_signal(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Send a signal to a process.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="35201" TYPE="TEXT">page&nbsp;232</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>proc_unref(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Release a reference to a process.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="35201" TYPE="TEXT">page&nbsp;232</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>psema(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Perform a &ldquo;P&rdquo; or wait semaphore 
operation.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="42679" TYPE="TEXT">page&nbsp;250</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>ptob(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Convert size in pages to size in bytes.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="54064" TYPE="TEXT">page&nbsp;211</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>pullupmsg(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Concatenate bytes in a message.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>putbq(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Place a message at the head of a queue.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>putctl(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Send a control message to a queue.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>putctl1(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Send a control message with a one-byte 
parameter to a queue.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>putnext(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Send a message to the next queue.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>putnextctl(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Send a control message to a queue.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>putnextctl1(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Send a control message with a one-byte 
parameter to a queue.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>putq(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Put a message on a queue.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>qenable(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Schedule a queue's service routine to be 
run.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>qprocsoff(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Enable put and service routines.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>qprocson(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Disable put and service routines.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>qreply(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Send a message in the opposite direction 
in a stream.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>qsize(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Find the number of messages on a 
queue.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>RD(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get a pointer to the read queue.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>rmvb(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Remove a message block from a 
message.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>rmvq(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Remove a message from a queue.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>RW_ALLOC(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate and initialize a reader/writer 
lock.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="50612" TYPE="TEXT">page&nbsp;240</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>RW_DEALLOC(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Deallocate a reader/writer lock.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="50612" TYPE="TEXT">page&nbsp;240</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>RW_DESTROY(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Deinitialize an existing reader/writer 
lock.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="50612" TYPE="TEXT">page&nbsp;240</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.2</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>RW_INIT(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Initialize an existing reader/writer &lbreak;lock.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="50612" TYPE="TEXT">page&nbsp;240</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.2</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>RW_RDLOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Acquire a reader/writer lock as reader, 
waiting if necessary.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="50612" TYPE="TEXT">page&nbsp;240</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>RW_TRYRDLOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Try to acquire a reader/writer lock as 
reader, returning a code if it is not free.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="50612" TYPE="TEXT">page&nbsp;240</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>RW_TRYWRLOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Try to acquire a reader/writer lock as 
writer, returning a code if it is not free.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="50612" TYPE="TEXT">page&nbsp;240</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>RW_UNLOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Release a reader/writer lock as reader 
or writer.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="50612" TYPE="TEXT">page&nbsp;240</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>RW_WRLOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Acquire a reader/writer lock as writer, 
waiting if necessary.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="50612" TYPE="TEXT">page&nbsp;240</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>SAMESTR(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Test if next queue is of the same type.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>scsi_abort()</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Transmits a SCSI ABORT command.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="33200" TYPE="TEXT">page&nbsp;508</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>scsi_alloc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Open a connection between a driver and 
a target device.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="33200" TYPE="TEXT">page&nbsp;508</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>scsi_command(D3)</REFPAGE></PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Transmit a SCSI command on the bus 
and return results.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="33200" TYPE="TEXT">page&nbsp;508</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>scsi_free(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Release connection to target device.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="33200" TYPE="TEXT">page&nbsp;508</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>scsi_info(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Issue the SCSI Inquiry command and 
return the results.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="33200" TYPE="TEXT">page&nbsp;508</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>scsi_reset() </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Resets the SCSI adapter or bus.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="33200" TYPE="TEXT">page&nbsp;508</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>setgiovector()</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Register a GIO interrupt handler.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="69895" TYPE="TEXT">page&nbsp;663</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>setgioconfig()</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Prepare a GIO slot for use.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="32510" TYPE="TEXT">page&nbsp;665</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>sgset(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Assign physical addresses to a vector of 
software scatter-gather registers.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="77908" TYPE="TEXT">page&nbsp;234</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>sleep(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Suspend process execution pending 
occurrence of an event.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="60062" TYPE="TEXT">page&nbsp;247</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>SLEEP_ALLOC(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate and initialize a sleep lock.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="72135" TYPE="TEXT">page&nbsp;239</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>SLEEP_DEALLOC(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Deinitialize and deallocate a 
dynamically allocated sleep lock.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="72135" TYPE="TEXT">page&nbsp;239</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>SLEEP_DESTROY(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Deinitialize a sleep lock.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="72135" TYPE="TEXT">page&nbsp;239</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.2</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>SLEEP_INIT(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Initialize an existing sleep lock.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="72135" TYPE="TEXT">page&nbsp;239</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.2</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>SLEEP_LOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Acquire a sleep lock, waiting if 
necessary until the lock is free.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="72135" TYPE="TEXT">page&nbsp;239</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>SLEEP_LOCKAVAIL(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Query whether a sleep lock is &lbreak;available.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="72135" TYPE="TEXT">page&nbsp;239</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>SLEEP_LOCK_SIG(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Acquire a sleep lock, waiting if 
necessary until the lock is free or a signal 
is received.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="72135" TYPE="TEXT">page&nbsp;239</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>SLEEP_TRYLOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Try to acquire a sleep lock, returning a 
code if it is not free.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="72135" TYPE="TEXT">page&nbsp;239</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>SLEEP_UNLOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Release a sleep lock.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="72135" TYPE="TEXT">page&nbsp;239</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>splbase(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Block no interrupts.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="75168" TYPE="TEXT">page&nbsp;241</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>spltimeout(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Block only timeout interrupts.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="75168" TYPE="TEXT">page&nbsp;241</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>spldisk(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Block disk interrupts.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="75168" TYPE="TEXT">page&nbsp;241</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>splstr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Block STREAMS interrupts.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="75168" TYPE="TEXT">page&nbsp;241</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>spltty(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Block disk, VME, serial interrupts.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="75168" TYPE="TEXT">page&nbsp;241</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>splhi(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Block all I/O interrupts.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="75168" TYPE="TEXT">page&nbsp;241</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>spl0(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Same as <FUNCTION>splbase</FUNCTION>().</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="75168" TYPE="TEXT">page&nbsp;241</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>splx(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Restore previous interrupt level.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="75168" TYPE="TEXT">page&nbsp;241</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>strcat(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Append one string to another.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>strcpy(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Copy a string.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>streams_interrupt(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Synchronize interrupt-level function 
with STREAMS mechanism.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>STREAMS_TIMEOUT(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Synchronize timeout with STREAMS 
mechanism.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>strlen(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Return length of a string.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>strlog(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Submit messages to the log driver.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>strncmp(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Compare two strings for a specified 
length.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>strncpy(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Copy a string for a specified length.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>strqget(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get information about a queue or band 
of the queue.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>strqset(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Change information about a queue or 
band of the queue.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>subyte(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Store a byte to user space.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="22073" TYPE="TEXT">page&nbsp;207</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>suword(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Store a word to user space.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="22073" TYPE="TEXT">page&nbsp;207</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>SV_ALLOC(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate and initialize a &lbreak;synchronization variable.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="41132" TYPE="TEXT">page&nbsp;248</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>SV_BROADCAST(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Wake all processes sleeping on a 
synchronization variable.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="41132" TYPE="TEXT">page&nbsp;248</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>SV_DEALLOC(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Deinitialize and deallocate a 
synchronization variable.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="41132" TYPE="TEXT">page&nbsp;248</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>SV_DESTROY(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Deinitialize a synchronization &lbreak;variable.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="41132" TYPE="TEXT">page&nbsp;248</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.2</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>SV_INIT(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Initialize an existing synchronization 
variable.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="41132" TYPE="TEXT">page&nbsp;248</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.2</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>SV_SIGNAL(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Wake one process sleeping on a 
synchronization variable.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="41132" TYPE="TEXT">page&nbsp;248</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>SV_WAIT(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Sleep until a synchronization &lbreak;variable is signalled.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="41132" TYPE="TEXT">page&nbsp;248</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>SV_WAIT_SIG(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Sleep until a synchronization &lbreak;variable is signalled or a signal is 
received.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="41132" TYPE="TEXT">page&nbsp;248</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>timeout(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Schedule a function to be executed &lbreak;after a specified number of clock ticks.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="56199" TYPE="TEXT">page&nbsp;242</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>TRYLOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Try to acquire a basic lock, returning a 
code if the lock is not currently free.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="59834" TYPE="TEXT">page&nbsp;235</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>uiomove(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Copy data using <VARIABLE>uio_t</VARIABLE>.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="75852" TYPE="TEXT">page&nbsp;209</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>uiophysio(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Validate a raw I/O request and pass &lbreak;to a strategy function.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="78884" TYPE="TEXT">page&nbsp;245</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>unbufcall(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Cancel a pending bufcall request.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>undma(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Unlock physical memory in user &lbreak;space.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="78884" TYPE="TEXT">page&nbsp;245</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>unfreezestr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Unfreeze the state of a stream.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>unlinkb(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Remove a message block from the &lbreak;head of a message.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>UNLOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Release a basic lock.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="59834" TYPE="TEXT">page&nbsp;235</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>untimeout(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Cancel a previous itimeout or 
fast_itimeout request.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="56199" TYPE="TEXT">page&nbsp;242</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV*, 5.3*</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>ureadc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Copy a character to space described by 
<VARIABLE>uio_t.</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="75852" TYPE="TEXT">page&nbsp;209</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>userdma(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Lock physical memory in user space.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="78884" TYPE="TEXT">page&nbsp;245</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>userabi()</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get data sizes for the ABI of the user 
process (32- or 64-bit).</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="87735" TYPE="TEXT">page&nbsp;182</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.2</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>uvaddr_to_alenlist() 
(alenlist_ops(d3x))</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Fill an alenlists with entries that 
describe a buffer in a user virtual 
address space.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="47096" TYPE="TEXT">page&nbsp;214</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>6.4 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>uwritec(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Return a character from space &lbreak;described by <VARIABLE>uio_t</VARIABLE>. </PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="75852" TYPE="TEXT">page&nbsp;209</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>v_getaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get the user virtual address &lbreak;associated with a <VARIABLE>vhandl_t</VARIABLE>.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="79722" TYPE="TEXT">page&nbsp;210</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>v_gethandle(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get a unique identifier associated &lbreak;with a <VARIABLE>vhandl_t</VARIABLE>.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="79722" TYPE="TEXT">page&nbsp;210</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>v_getlen(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get the length of user address space 
associated with a <VARIABLE>vhandl_t</VARIABLE>.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="79722" TYPE="TEXT">page&nbsp;210</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>v_mapphys(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Map kernel address space into user 
address space.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="79722" TYPE="TEXT">page&nbsp;210</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>valusema(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Return the value associated with a 
semaphore.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="42679" TYPE="TEXT">page&nbsp;250</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>vme_adapter(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Determine VME adapter that 
corresponds to a given memory 
address.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>vme_ivec_alloc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Allocate a VME bus interrupt vector.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>vme_ivec_free(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Free a VME bus interrupt vector.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>vme_ivec_set(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Register a VME bus interrupt vector.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>vsema(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Perform a &ldquo;V&rdquo; or signal semaphore 
operation.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="42679" TYPE="TEXT">page&nbsp;250</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>wakeup(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Waken a process waiting for an &lbreak;event. </PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="60062" TYPE="TEXT">page&nbsp;247</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>wbadaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Test physical address for output.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="54173" TYPE="TEXT">page&nbsp;221</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>wbadaddr_val(D3) </REFPAGE></PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Test physical address for output of 
specific value. </PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH><XREF IDREF="54173" TYPE="TEXT">page&nbsp;221</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH><REFPAGE>WR(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="158"><PARAGRAPH>Get a pointer to the write queue. </PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="40"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="370" WIDTH="33"><PARAGRAPH>SV, 5.3</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The following SVR4 kernel functions are not implemented in IRIX: bioreset, dma_disable, dma_enable, dma_free_buf, dma_free_cb, dma_get_best_mode, dma_get_buf, dma_get_cb, dma_pageio, dma_prog, dma_swstart, dma_swsetup, drv_gethardware, hat_getkpfnum, hat_getppfnum, inb, inl, inw, kvtoppid, mod_drvattach, mod_drvdetach, outb, outl, outw, physmap, physmap_free, phystoppid, psignal, rdma_filter, repinsb, repinsd, repinsw, repoutsb, repoutsd, repoutsw, rminit, rmsetwant, SLEEP_LOCKOWNED, strncat, vtop.</PARAGRAPH>
</SECTION1>
</APPENDIX>
