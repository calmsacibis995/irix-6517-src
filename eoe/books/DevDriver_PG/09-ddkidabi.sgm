<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="8"><TITLE><XREFTARGET ID="31965">Device Driver/Kernel Interface</TITLE><PARAGRAPH>The programming interface between a device driver and the IRIX kernel is founded on the AT&amp;T System V Release 4 DDI/DKI, and it remains true that a working device driver for an SVR4 system can be ported to IRIX with relatively little difficulty. However, as both Silicon Graphics hardware and the IRIX kernel have evolved into far greater complexity and sophistication, the driver interface has been extended. A driver can now call upon nearly as many IRIX extended kernel functions as it can SVR4-compatible ones.</PARAGRAPH>
<PARAGRAPH>The function prototypes and detailed operation of all kernel functions are documented in the reference pages in volume &ldquo;D.&rdquo; The aim of this chapter is to provide background, context, and an overview of the interface under the following headings:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="77301" TYPE="TITLE">&ldquo;Important Data Types&rdquo;</XREF> describes the data types that are exchanged between the kernel and a driver.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="92643" TYPE="TITLE">&ldquo;Important Header Files&rdquo;</XREF> summarizes the C header files that are frequently included in a driver source file.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="77267" TYPE="TITLE">&ldquo;Kernel Memory Allocation&rdquo;</XREF> discusses allocating kernel memory in general and for objects of specific types.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="20796" TYPE="TITLE">&ldquo;Transferring Data&rdquo;</XREF> discusses the problems of copying data between user and kernel address spaces, and block-copy operations within the kernel.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="74579" TYPE="TITLE">&ldquo;Managing Virtual and Physical Addresses&rdquo;</XREF> discusses functions for testing and translating addresses in different spaces, for using address/length lists, and for setting up DMA transfers.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="50960" TYPE="TITLE">&ldquo;Hardware Graph Management&rdquo;</XREF> discusses the kernel function used to create and modify <FILENAME>hwgraph</FILENAME> vertexes.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="35201" TYPE="TITLE">&ldquo;User Process Administration&rdquo;</XREF> tells how to test the attributes of a calling process and how to send a signal.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="14643" TYPE="TITLE">&ldquo;Waiting and Mutual Exclusion&rdquo;</XREF> details the kinds of locks and semaphores available, and the methods of waiting for events to occur.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="77301">Important Data Types</TITLE><PARAGRAPH>In order to understand the driver/kernel interface, you need first of all to understand the data types with which it deals.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="95836">Hardware Graph Types</TITLE><PARAGRAPH>As discussed under <INDEXTARGET ID="09-ddkidabi1"><!-- POSTPROCESSDATA: 09-ddkidabi1|hwgraph:data types in --><XREF IDREF="45843" TYPE="TITLE">&ldquo;Hardware Graph Features&rdquo;</XREF>, the hwgraph is composed of vertexes connected by labelled edges. The functions for working with the hwgraph are discussed under <XREF IDREF="50960" TYPE="TITLE">&ldquo;Hardware Graph Management&rdquo;</XREF>.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Vertex Handle Type</TITLE><PARAGRAPH>There is no data type associated with the edge as such. The data type of a graph vertex is the <INDEXTARGET ID="09-ddkidabi2"><!-- POSTPROCESSDATA: 09-ddkidabi2|data types:<VARIABLE>vertex_hdl_t</VARIABLE> --><VARIABLE>vertex_hdl_t</VARIABLE>, an opaque, 32-bit number. When you create a vertex, a <VARIABLE>vertex_hdl_t</VARIABLE> is returned. When you store data in a vertex, or get data from one, you pass a <VARIABLE>vertex_hdl_t</VARIABLE> as the argument.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="24530">Vertex Handle and dev_t</TITLE><PARAGRAPH>The device number type, <INDEXTARGET ID="09-ddkidabi3"><!-- POSTPROCESSDATA: 09-ddkidabi3|data types:<VARIABLE>dev_t</VARIABLE>:same as <VARIABLE>vertex_hdl_t</VARIABLE> --><VARIABLE>dev_t</VARIABLE>, is an important type in classical driver design (see <XREF IDREF="52914" TYPE="TITLE">&ldquo;Device Number Types&rdquo;</XREF>). In IRIX 6.4, the <VARIABLE>dev_t</VARIABLE> and the <VARIABLE>vertex_hdl_t</VARIABLE> are identical. That is, when a driver is called to open or operate a device that is represented as a vertex in the hardware graph, the value passed to identify the device is simply the handle to the hwgraph vertex for that device.</PARAGRAPH>
<PARAGRAPH>When a driver is called to open a device that is only represented as a special file in <FILENAME>/dev</FILENAME> (as in IRIX 6.3 and earlier&mdash;there are no such devices supported by IRIX 6.4, but such support is provided for third-party drivers in IRIX 6.5), the identifying value is an <VARIABLE>o_dev_t</VARIABLE>, containing major and minor numbers and identical to the traditional <VARIABLE>dev_t</VARIABLE>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Graph Error Numbers</TITLE><PARAGRAPH>Most hwgraph functions have graph error codes as their explicit result type. The <INDEXTARGET ID="09-ddkidabi4"><!-- POSTPROCESSDATA: 09-ddkidabi4|data types:<VARIABLE>graph_error_t</VARIABLE> --><VARIABLE>graph_error_t</VARIABLE> is an enumeration declared in <FILENAME>sys/graph.h</FILENAME> (included by <FILENAME>sys/hwgraph.h</FILENAME>) having these values: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH>GRAPH_SUCCESS </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="243"><PARAGRAPH>Operation successful. This success value is 0, as is 
conventional in C programming.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH>GRAPH_DUP </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="243"><PARAGRAPH>Data to be added already exists. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH>GRAPH_NOT_FOUND </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="243"><PARAGRAPH>Data requested does not exist. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH>GRAPH_BAD_PARAM </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="243"><PARAGRAPH>Typically a null value where an address is required, or 
other unusable function parameter. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH>GRAPH_HIT_LIMIT </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="243"><PARAGRAPH>Arbitrary limit on, for example, number of edges. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH>GRAPH_CANNOT_ALLOC </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="243"><PARAGRAPH>Unable to allocate memory to expand vertex or other 
data structure, possibly because &ldquo;no sleep&rdquo; specified. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH>GRAPH_ILLEGAL_REQUEST </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="243"><PARAGRAPH>Improper or impossible request. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH>GRAPH_IN_USE </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="243"><PARAGRAPH>Cannot deallocate vertex because there are references 
to it.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>&space;</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Address Types</TITLE><PARAGRAPH>Device drivers deal with addresses in different address spaces. When you store individual addresses, it is a good idea to use a data type specific to the address space. The following types are declared in <INDEXTARGET ID="09-ddkidabi5"><!-- POSTPROCESSDATA: 09-ddkidabi5|data types:<VARIABLE>caddr_t</VARIABLE> --><INDEXTARGET ID="09-ddkidabi6"><!-- POSTPROCESSDATA: 09-ddkidabi6|data types:<VARIABLE>paddr_t</VARIABLE> --><INDEXTARGET ID="09-ddkidabi7"><!-- POSTPROCESSDATA: 09-ddkidabi7|data types:<VARIABLE>iopaddr_t</VARIABLE> --><FILENAME>sys/types.h</FILENAME> to use for pointer variables: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>caddr_t</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Any memory (&ldquo;core&rdquo;) address in user or kernel space. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>daddr_t</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>A disk offset or address (64 bits). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>paddr_t</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>A physical memory address. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>iopaddr_t</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>An address in some I/O bus address space. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>It is a very good idea to always store a pointer in a variable with the correct type. It makes the intentions of the program more understandable, and helps you think about the complexities of address translation.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="65822">Address/Length Lists</TITLE><PARAGRAPH>An <INDEXTARGET ID="09-ddkidabi8"><!-- POSTPROCESSDATA: 09-ddkidabi8|address/length list --><INDEXTARGET ID="09-ddkidabi9"><!-- POSTPROCESSDATA: 09-ddkidabi9|data types:<VARIABLE>alenlist_t</VARIABLE> --><GLOSSARYITEM>address/length list</GLOSSARYITEM>, or alenlist, is a software object you use to store the address and size of each segment of a buffer. An alenlist is a list in which each list item is a pair composed of an address and a related length. All the addresses in the list refer to the same address space, whether that is a user virtual space, the kernel virtual space, physical memory space, or the address space of some I/O bus. An alenlist cursor is a pointer that ranges over the list, selecting one pair after another.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="09-alenlist.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="8-1"><PREFIX>Figure 8-1 </PREFIX><XREFTARGET ID="42770">Address/Length List Concepts</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>The conceptual relationship between an alenlist and a buffer is illustrated in <XREF IDREF="42770" TYPE="GRAPHIC">Figure&nbsp;8-1</XREF>. A buffer area that is a single contiguous segment in virtual memory may consist of scattered page frames in physical memory. The <VARIABLE>alenlist_t</VARIABLE> data type is a pointer to an alenlist.</PARAGRAPH>
<PARAGRAPH>The kernel provides a variety of functions for creating alenlists, for loading them with addresses and lengths, and for translating the addresses (see <XREF IDREF="29580" TYPE="TITLE">&ldquo;Using Address/Length Lists&rdquo;</XREF>). These functions and the <VARIABLE>alenlist_t</VARIABLE> data type are declared in <FILENAME>sys/alenlist.h</FILENAME>.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="39112">Structure uio_t</TITLE><PARAGRAPH>The <INDEXTARGET ID="09-ddkidabi10"><!-- POSTPROCESSDATA: 09-ddkidabi10|data types:<VARIABLE>uio_t</VARIABLE> --><VARIABLE>uio_t</VARIABLE> structure describes data transfer for a character device:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>read()</FUNCTION> and <VARIABLE>pfx</VARIABLE><FUNCTION>write()</FUNCTION> entry points receive a <VARIABLE>uio_t</VARIABLE> that describes the buffer of data.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Within an <VARIABLE>pfx</VARIABLE><FUNCTION>ioctl()</FUNCTION> entry point, you might construct a <VARIABLE>uio_t</VARIABLE> to represent data transfer for control purposes.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>In a hybrid character/block driver, the <FUNCTION>physiock()</FUNCTION> function translates a <VARIABLE>uio_t</VARIABLE> into a <VARIABLE>buf_t</VARIABLE> for use by the <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> entry point.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The fields and values in a <INDEXTARGET ID="09-ddkidabi11"><!-- POSTPROCESSDATA: 09-ddkidabi11|header files:<FILENAME>sys/uio.h</FILENAME> --><VARIABLE>uio_t</VARIABLE> are declared in <FILENAME>sys/uio.h</FILENAME>, which is included by <FILENAME>sys/ddi.h</FILENAME>. For a detailed discussion, see the <REFPAGE>uio(D4)</REFPAGE> reference page. Typically the contents of the <VARIABLE>uio_t</VARIABLE> reflect the buffer areas that were passed to a <FUNCTION>read()</FUNCTION>, <FUNCTION>readv()</FUNCTION>, <FUNCTION>write()</FUNCTION>, or <FUNCTION>writev()</FUNCTION> call (see the <REFPAGE>read(2)</REFPAGE> and <REFPAGE>write(2)</REFPAGE> reference pages).</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Data Location and the iovec_t</TITLE><PARAGRAPH>One <VARIABLE>uio_t</VARIABLE> describes data transfer to or from a single address space, either the address space of a user process or the kernel address space. The address space is indicated by a flag value, either UIO_USERSPACE or UIO_SYSSPACE, in the <VARIABLE>uio_segflg</VARIABLE> field.</PARAGRAPH>
<PARAGRAPH>The total number of bytes remaining to be transferred is given in field <VARIABLE>uio_resid</VARIABLE>. Initially this is the total requested transfer size.</PARAGRAPH>
<PARAGRAPH>Although the transfer is to a single address space, it can be directed to multiple segments of data within the address space. Each segment of data is described by a structure of type <INDEXTARGET ID="09-ddkidabi12"><!-- POSTPROCESSDATA: 09-ddkidabi12|data types:<VARIABLE>iovec_t</VARIABLE> --><VARIABLE>iovec_t</VARIABLE>. An <VARIABLE>iovec_t</VARIABLE> contains the virtual address and length of one segment of memory.</PARAGRAPH>
<PARAGRAPH>The number of segments is given in field <VARIABLE>uio_iovcnt</VARIABLE>. The field <VARIABLE>uio_iov</VARIABLE> points to the first <VARIABLE>iovec_t</VARIABLE> in an array of <VARIABLE>iovec_t</VARIABLE> structures, each describing one segment. of data. The total size in <VARIABLE>uio_resid</VARIABLE> is the sum of the segment sizes.</PARAGRAPH>
<PARAGRAPH>For a simple data transfer, <VARIABLE>uio_iovcnt</VARIABLE> contains 1, and <VARIABLE>uio_iov</VARIABLE> points to a single <VARIABLE>iovec_t</VARIABLE> describing a buffer of 1 or more bytes. For a complicated transfer, the <VARIABLE>uio_t</VARIABLE> might describe a number of scattered segments of data. Such transfers can arise in a network driver where multiple layers of message header data are added to a message at different levels of the software.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Use of the uio_t</TITLE><PARAGRAPH>In the <VARIABLE>pfx</VARIABLE><FUNCTION>read()</FUNCTION> and <VARIABLE>pfx</VARIABLE><FUNCTION>write()</FUNCTION> entry points, you can test <VARIABLE>uio_segflag</VARIABLE> to see if the data is destined for user space or kernel space, and you can save the initial value of <VARIABLE>uio_resid</VARIABLE> as the requested length of the transfer.</PARAGRAPH>
<PARAGRAPH>In a character driver, you fetch or store data using functions that both use and modify the <VARIABLE>uio_t</VARIABLE>. These functions are listed under <XREF IDREF="75852" TYPE="TITLE">&ldquo;Transferring Data Through a uio_t Object&rdquo;</XREF>. When data is not immediately available, you should test for the FNDELAY or FNONBLOCK flags in <VARIABLE>uio_fmode</VARIABLE>, and return when either is set rather than sleeping.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="34384">Structure buf_t</TITLE><PARAGRAPH>The <INDEXTARGET ID="09-ddkidabi13"><!-- POSTPROCESSDATA: 09-ddkidabi13|header files:<FILENAME>sys/param.h</FILENAME> --><INDEXTARGET ID="09-ddkidabi14"><!-- POSTPROCESSDATA: 09-ddkidabi14|data types:<VARIABLE>buf_t</VARIABLE> --><VARIABLE>buf_t</VARIABLE> structure describes a block data transfer. It is designed to represent the transfer (in or out) of a sequence of adjacent, fixed-size blocks from a random-access device to a block of contiguous memory. The size of one device block is NBPSCTR, declared in <FILENAME>sys/param.h</FILENAME>. For a detailed discussion of the <VARIABLE>buf_t</VARIABLE>, see the <REFPAGE>buf(D4)</REFPAGE> reference page.</PARAGRAPH>
<PARAGRAPH>The <VARIABLE>buf_t</VARIABLE> is used internally in IRIX by the paging I/O system to manage queues of physical pages, and by filesystems to manage queues of pages of file data. The paging system and filesystems are the primary clients of the <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> entry point to a block device driver, so it is only natural that a <VARIABLE>buf_t</VARIABLE> pointer is the input argument to <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION>.</PARAGRAPH>
<TIP><PREFIX>Tip</PREFIX>The <COMMAND>idbg</COMMAND> kernel debugging tool has several functions related to displaying the contents of <VARIABLE>buf_t</VARIABLE> objects. See <XREF IDREF="29132" TYPE="TITLE">&ldquo;Commands to Display buf_t Objects&rdquo;</XREF>.</TIP>
<SECTION3 LBL="" HELPID = ""><TITLE>Fields of buf_t</TITLE><PARAGRAPH>The fields of the <VARIABLE>buf_t</VARIABLE> are declared in <FILENAME>sys/buf.h</FILENAME>, which is included by <FILENAME>sys/ddi.h</FILENAME>. This header file also declares the names of many kernel functions that operate on <VARIABLE>buf_t</VARIABLE> objects. (Many of those functions are not supported as part of the DDI/DKI. You should only use kernel functions that have reference pages.)</PARAGRAPH>
<PARAGRAPH>Because <VARIABLE>buf_t</VARIABLE> is used by so many software components, it has many fields that are not relevant to device driver needs, as well as some fields that have multiple uses. The relevant fields are summarized in <XREF IDREF="97245" TYPE="TABLE">Table&nbsp;8-1</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-1"><PREFIX>Table 8-1 </PREFIX><XREFTARGET ID="97245"> <EMPHASIS>(continued)        </EMPHASIS>Accessible Fields of buf_t Objects</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="71"><PARAGRAPH>Field Name</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="54"><PARAGRAPH>Access</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>Purpose and Contents</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="71"><PARAGRAPH><VARIABLE>b_edev</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="54"><PARAGRAPH>read-only</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH><VARIABLE>dev_t</VARIABLE> giving device major and minor numbers.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="71"><PARAGRAPH><VARIABLE>b_flags</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="54"><PARAGRAPH>read-only</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>Operational flags; for a detailed list see <REFPAGE>buf(D4)</REFPAGE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="71"><PARAGRAPH><VARIABLE>b_forw</VARIABLE>, <VARIABLE>b_back</VARIABLE>, 
<VARIABLE>av_forw</VARIABLE>, <VARIABLE>av_back</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="54"><PARAGRAPH>read-write</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>Queuing pointers, available for driver use within the 
<VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>strategy()</FUNCTION> routine. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="71"><PARAGRAPH><VARIABLE>b_un.b_addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="54"><PARAGRAPH>read-only</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>Sometimes the kernel virtual address of the buffer, depending on 
the <VARIABLE>b_flags</VARIABLE> setting BP_ISMAPPED.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="71"><PARAGRAPH><VARIABLE>b_bcount</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="54"><PARAGRAPH>read-only</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>Number of bytes to transfer. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="71"><PARAGRAPH><VARIABLE>b_blkno</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="54"><PARAGRAPH>read-only</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>Starting logical block number on device (for a disk, relative to the 
partition that the device represents).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="71"><PARAGRAPH><VARIABLE>b_iodone</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="54"><PARAGRAPH>read-write</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>Address of a driver internal function to be called on I/O 
completion.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="71"><PARAGRAPH><VARIABLE>b_resid</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="54"><PARAGRAPH>read-write</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>Number of bytes not transferred, set at completion to 0 unless an 
error occurs.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="71"><PARAGRAPH><VARIABLE>b_error</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="54"><PARAGRAPH>read-write</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>Error code, set at completion of I/O.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>No other fields of the <VARIABLE>buf_t</VARIABLE> are designed for use by a driver. In <XREF IDREF="97245" TYPE="TABLE">Table&nbsp;8-1</XREF>, &ldquo;read-only&rdquo; access means that the driver should never change this field in a <VARIABLE>buf_t</VARIABLE> that is owned by the kernel. When the driver is working with a <VARIABLE>buf_t</VARIABLE> that the driver has allocated (see <XREF IDREF="70392" TYPE="TITLE">&ldquo;Allocating buf_t Objects and Buffers&rdquo;</XREF>) the driver can do what it likes.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using the Logical Block Number</TITLE><PARAGRAPH>The logical block number is the number of the 512-byte block in the device. The &ldquo;device&rdquo; is encoded by the minor device number that you can extract from <VARIABLE>b_edev</VARIABLE>. It might be a complete device surface, or it might be a partition within a larger device (for example, the IRIX disk device drivers support different minor device numbers for different disk partitions).</PARAGRAPH>
<PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> routine may have to translate the logical block number based on the driver's information about device partitioning and device geometry (sector size, sectors per track, tracks per cylinder).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="46843">Buffer Location and b_flags</TITLE><PARAGRAPH>The data buffer represented by a <INDEXTARGET ID="09-ddkidabi15"><!-- POSTPROCESSDATA: 09-ddkidabi15|data types:<VARIABLE>buf_t</VARIABLE>:BP_ISMAPPED --><VARIABLE>buf_t</VARIABLE> can be in one of two places, depending on bits in <VARIABLE>b_flags</VARIABLE>.</PARAGRAPH>
<PARAGRAPH>When the macro BP_ISMAPPED(<VARIABLE>buf_t-address</VARIABLE>) returns true, the buffer is in kernel virtual memory and its virtual address is in <VARIABLE>b_un.b_addr</VARIABLE>. </PARAGRAPH>
<PARAGRAPH>When BP_ISMAPPED(<VARIABLE>buf_t-address</VARIABLE>) returns false, the buffer is described by a chain of <VARIABLE>pfdat</VARIABLE> structures (declared in<FILENAME>&space;sys/pfdat.h</FILENAME>, but containing no fields of any use to a device driver). In this case, <VARIABLE>b_un.b_addr</VARIABLE> contains only an offset into the first page frame of the chain. See <XREF IDREF="41107" TYPE="TITLE">&ldquo;Managing Buffer Virtual Addresses&rdquo;</XREF> for a method of mapping an unmapped buffer.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Lock and Semaphore Types</TITLE><PARAGRAPH>The header files <INDEXTARGET ID="09-ddkidabi16"><!-- POSTPROCESSDATA: 09-ddkidabi16|header files:<FILENAME>sys/sema.h</FILENAME> --><INDEXTARGET ID="09-ddkidabi17"><!-- POSTPROCESSDATA: 09-ddkidabi17|data types:<VARIABLE>sv_t</VARIABLE> --><INDEXTARGET ID="09-ddkidabi18"><!-- POSTPROCESSDATA: 09-ddkidabi18|data types:<VARIABLE>mrlock_t</VARIABLE> --><INDEXTARGET ID="09-ddkidabi19"><!-- POSTPROCESSDATA: 09-ddkidabi19|data types:<VARIABLE>sema_t</VARIABLE> --><INDEXTARGET ID="09-ddkidabi20"><!-- POSTPROCESSDATA: 09-ddkidabi20|data types:<VARIABLE>mutex_t</VARIABLE> --><INDEXTARGET ID="09-ddkidabi21"><!-- POSTPROCESSDATA: 09-ddkidabi21|data types:<VARIABLE>lock_t</VARIABLE> --><FILENAME>sys/sema.h</FILENAME> and <FILENAME>sys/types.h</FILENAME> declare the data types of locks of different types, including the following: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>lock_t</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Basic lock, or spin-lock, used with LOCK() and related functions. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>mutex_t</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Sleeping lock, used for mutual exclusion between upper-half instances. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>sema_t</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Semaphore object, used for general locking. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>mrlock_t</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Reader-writer locks, used with RW_RDLOCK() and related functions. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>sv_t</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Synchronization variable, used with SV_WAIT and related functions. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>These lock types should be treated as opaque objects because their contents can change from release to release (and in fact their contents are different in IRIX 6.2 from previous releases).</PARAGRAPH>
<PARAGRAPH>The families of locking and synchronization functions contain functions for allocating, initializing, and freeing each type of lock. See <XREF IDREF="51251" TYPE="TITLE">&ldquo;Waiting and Mutual Exclusion&rdquo;</XREF>.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="52914">Device Number Types</TITLE><PARAGRAPH>In the <INDEXTARGET ID="09-ddkidabi22"><!-- POSTPROCESSDATA: 09-ddkidabi22|<FILENAME>/dev/MAKEDEV</FILENAME>MAKE --><INDEXTARGET ID="09-ddkidabi23"><!-- POSTPROCESSDATA: 09-ddkidabi23|minor device number --><INDEXTARGET ID="09-ddkidabi24"><!-- POSTPROCESSDATA: 09-ddkidabi24|major device number --><INDEXTARGET ID="09-ddkidabi25"><!-- POSTPROCESSDATA: 09-ddkidabi25|data types:<VARIABLE>dev_t</VARIABLE> --><FILENAME>/dev</FILENAME> filesystem (but not in the <FILENAME>/hw</FILENAME> filesystem), two numbers are carried in the inode of a device special file: a <GLOSSARYITEM>major device number</GLOSSARYITEM> of up to 9 bits, and a <GLOSSARYITEM>minor device number</GLOSSARYITEM> of up to 18 bits. The numbers are assigned when the device special file is created, either by the <FILENAME>/dev/MAKEDEV</FILENAME> script or by the system administrator. The contents and meaning of device numbers is discussed under <XREF IDREF="87892" TYPE="TITLE">&ldquo;Devices as Files&rdquo;</XREF>. </PARAGRAPH>
<PARAGRAPH>In traditional UNIX practice, the <VARIABLE>dev_t</VARIABLE> has been an unsigned integer containing the values of the major and minor numbers for the device that is to be used. When a device is represented in IRIX only as a device special file in <FILENAME>/dev</FILENAME>, this is still the case.</PARAGRAPH>
<PARAGRAPH>When a device is represented by a vertex of the hwgraph, visible as a name in the <FILENAME>/hw</FILENAME> filesystem, the major number is always 0 and the minor number is arbitrary. When a device is opened as a special file in <FILENAME>/hw</FILENAME>, the <VARIABLE>dev_t</VARIABLE> received by the driver is composed of major 0 and an arbitrary minor number. In fact, the <VARIABLE>dev_t</VARIABLE> is a <VARIABLE>vertex_hdl_t</VARIABLE>, a handle to the hwgraph vertex that represents the device.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="14986">Historical Use of the Device Numbers</TITLE><PARAGRAPH>Historically, a driver used the major device number to learn which device driver has been called. This was important only when the driver supported multiple interfaces, for example both character and block access to the same hardware.</PARAGRAPH>
<PARAGRAPH>Also historically, the driver used the minor device number to distinguish one hardware unit from another. A typical scheme was to have an array of device-information structures indexed by the minor number. In addition, mode of use options were encoded in the minor number, as described under <XREF IDREF="13802" TYPE="TITLE">&ldquo;Minor Device Number&rdquo;</XREF>. </PARAGRAPH>
<PARAGRAPH>You can still use major and minor numbers the same way, but only when the device is represented by a device special file that is created with the <COMMAND>mknod</COMMAND> command, so that it contains meaningful major and minor numbers. The kernel functions related to <VARIABLE>dev_t</VARIABLE> use are summarized in <XREF IDREF="16594" TYPE="TABLE">Table&nbsp;8-2</XREF>.</PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-2"><PREFIX>Table 8-2 </PREFIX><XREFTARGET ID="16594"> <EMPHASIS>(continued)        </EMPHASIS>Functions to Manipulate Device Numbers</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>etoimajor(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Convert external to internal major device number.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>getemajor(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Get external major device number.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>geteminor(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Get external minor device number.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>getmajor(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Get internal major device number.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>getminor(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Get internal minor device number.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>itoemajor(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Convert internal to external major device number. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>makedevice(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>&space;Make device number from major and minor numbers. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The most important of the functions in <XREF IDREF="16594" TYPE="TABLE">Table&nbsp;8-2</XREF> are</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><INDEXTARGET ID="09-ddkidabi26"><!-- POSTPROCESSDATA: 09-ddkidabi26|kernel functions:<FUNCTION>getemajor()</FUNCTION> --><FUNCTION>getemajor()</FUNCTION>, which extracts the major number from a <VARIABLE>dev_t</VARIABLE> and returns it as a <VARIABLE>major_t</VARIABLE></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><INDEXTARGET ID="09-ddkidabi27"><!-- POSTPROCESSDATA: 09-ddkidabi27|kernel functions:<FUNCTION>geteminor()</FUNCTION> --><FUNCTION>geteminor()</FUNCTION>, which extracts the minor number from a <VARIABLE>dev_t</VARIABLE> and returns it as a <VARIABLE>minor_t</VARIABLE></PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The <INDEXTARGET ID="09-ddkidabi28"><!-- POSTPROCESSDATA: 09-ddkidabi28|kernel functions:<FUNCTION>makedevice()</FUNCTION> --><FUNCTION>makedevice()</FUNCTION> function, which combines a <VARIABLE>major_t</VARIABLE> and a <VARIABLE>minor_t</VARIABLE> to form a traditional <VARIABLE>dev_t</VARIABLE>, is useful only when creating a &ldquo;clone&rdquo; driver (see <XREF IDREF="32390" TYPE="TITLE">&ldquo;Support for CLONE Drivers&rdquo;</XREF>).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Contemporary Device Number Use</TITLE><PARAGRAPH>When the device is represented as a hwgraph vertex, the driver does not receive useful major and minor numbers. Instead, the driver uses the device-unique information that the driver itself has stored in the hwgraph vertex.</PARAGRAPH>
<PARAGRAPH>An historical driver makes only historical use of the <VARIABLE>dev_t</VARIABLE>, using the functions listed in the preceding topic. Such a driver makes no use of the hwgraph, and can only manage devices that are opened as device special files in <FILENAME>/dev</FILENAME>.</PARAGRAPH>
<PARAGRAPH>A contemporary driver creates hwgraph vertexes to represent its devices (see <XREF IDREF="65256" TYPE="TITLE">&ldquo;Extending the hwgraph&rdquo;</XREF>); makes no use of the major and minor device numbers; and uses the <VARIABLE>dev_t</VARIABLE> as a handle to a hwgraph vertex. Such a driver can only manage devices that are opened as device special files in <FILENAME>/hw</FILENAME>, or devices that are opened through symbolic links in <FILENAME>/dev</FILENAME> that refer to <FILENAME>/hw</FILENAME>.</PARAGRAPH>
<PARAGRAPH>It might possibly be necessary to merge the two approaches. This can be done as follows. In each upper-half entry point, apply <FUNCTION>getemajor()</FUNCTION> to the <VARIABLE>dev_t</VARIABLE>. When the result is nonzero, the <VARIABLE>dev_t</VARIABLE> is conventional and <FUNCTION>geteminor()</FUNCTION> will return a useful minor number. Use it to locate the device-specific information.</PARAGRAPH>
<PARAGRAPH>When <FUNCTION>getemajor()</FUNCTION> returns 0, the <VARIABLE>dev_t</VARIABLE> is a vertex handle. Use <FUNCTION>device_info_get()</FUNCTION> to retrieve the address of device-specific information.</PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="92643">Important Header Files</TITLE><PARAGRAPH>The header files that are frequently needed in device driver source modules are summarized in <INDEXTARGET ID="09-ddkidabi29"><!-- POSTPROCESSDATA: 09-ddkidabi29|header files:summary tableheader files:AAA --><XREF IDREF="58662" TYPE="TABLE">Table&nbsp;8-3</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="8-3"><PREFIX>Table 8-3 </PREFIX><XREFTARGET ID="58662"> <EMPHASIS>(continued)        </EMPHASIS>Header Files Often Used in Device Drivers</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="79"><PARAGRAPH>Header File</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>Reason for Including</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/alenlist.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>The address/length list type and related functions. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/buf.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>The <VARIABLE>buf_t</VARIABLE> structure and related constants and functions (included by <FILENAME>sys/ddi.h</FILENAME>). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/cmn_err.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>The <FUNCTION>cmn_err</FUNCTION><FUNCTION>()</FUNCTION> function. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/conf.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>The constants used in the <VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>devflags</FUNCTION> global. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/ddi.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>Many kernel functions declared. Also includes <FILENAME>sys/types.h</FILENAME>, <FILENAME>sys/uio.h</FILENAME>, and 
<FILENAME>sys/buf.h</FILENAME>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/debug.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>Defines the ASSERT macro and others. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/dmamap.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>Data types and kernel functions related to DMA mapping. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/edt.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>Declares the <VARIABLE>edt_t</VARIABLE> type passed to <VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>edtinit</FUNCTION><FUNCTION>()</FUNCTION>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/eisa.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>EISA-bus hardware constants and EISA kernel functions. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/errno.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>Names for all system error codes. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/file.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>Names for file mode flags passed to driver entry points.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/hwgraph.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>Hardware graph objects and related functions.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/immu.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>Types and macros used to manage virtual memory and some kernel functions.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/kmem.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>Constants like KM_SLEEP used with some kernel functions.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/ksynch.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>Functions used for sleep-locks.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/log.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>Types and functions for using the system log.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH>s<FILENAME>ys/major.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>Names for assigned major device numbers.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/mman.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>Constants and flags used with <FUNCTION>mmap</FUNCTION><FUNCTION>()</FUNCTION> and the <VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>mmap</FUNCTION><FUNCTION>()</FUNCTION> entry point.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/param.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>Constants like PZERO used with some kernel functions.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH>s<FILENAME>ys/PCI/pciio.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>PCI bus interface functions and constants.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/pio.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>VME PIO functions.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/poll.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>Types and functions for pollhead allocation and poll callback.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/scsi.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>Types and functions used to call the inner SCSI driver.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/sema.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>Types and functions related to semaphores, mutex locks, and basic locks.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/stream.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>STREAMS standard functions and data types.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/strmp.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>STREAMS multiprocessor functions.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/sysmacros.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>Macros for conversion between bytes and pages, and similar values.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/systm.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>Kernel functions related to system operations.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/types.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>Common data types and types of system objects (included by <FILENAME>sys/ddi.h</FILENAME>).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/uio.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>The <VARIABLE>uio_t</VARIABLE> structure and related functions (included by <FILENAME>sys/ddi.h</FILENAME>).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="79"><PARAGRAPH><FILENAME>sys/vmereg.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="315"><PARAGRAPH>VME bus hardware constants and VME-related functions.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="77267">Kernel Memory Allocation</TITLE><PARAGRAPH>A device or STREAMS driver can allocate memory statically, as global variables in the driver module, and this is a good way to allocate any object that is always needed and has a fixed size.<INDEXTARGET ID="09-ddkidabi30"><!-- POSTPROCESSDATA: 09-ddkidabi30|memory allocation --></PARAGRAPH>
<PARAGRAPH>When the number or size of an object can vary, but can be determined at initialization time, the driver can allocate memory in the <VARIABLE>pfx</VARIABLE><FUNCTION>init()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION>, or <VARIABLE>pfx</VARIABLE><FUNCTION>start()</FUNCTION> entry point.</PARAGRAPH>
<PARAGRAPH>You can allocate memory dynamically in any upper-half entry point. When this is necessary, it should be done in an entry point that is called infrequently, such as <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION>. The reason is that memory allocation is subject to unpredictable delays. As a general rule, you should avoid the need to allocate memory in an interrupt handler.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="68494">General-Purpose Allocation</TITLE><PARAGRAPH>General-purpose allocation uses the <INDEXTARGET ID="09-ddkidabi31"><!-- POSTPROCESSDATA: 09-ddkidabi31|kernel functions:<FUNCTION>kmem_alloc()</FUNCTION> --><FUNCTION>kmem_alloc()</FUNCTION> function and associated functions summarized in <XREF IDREF="95239" TYPE="TABLE">Table&nbsp;8-4</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-4"><PREFIX>Table 8-4 </PREFIX><XREFTARGET ID="95239"> <EMPHASIS>(continued)        </EMPHASIS>Functions for Kernel Virtual Memory</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="81"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="72"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="234"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>kmem_alloc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="72"><PARAGRAPH>kmem.h &amp; 
types.h</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="234"><PARAGRAPH>Allocate space from kernel free memory.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>kmem_free(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="72"><PARAGRAPH>kmem.h &amp; 
types.h</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="234"><PARAGRAPH>Free previously allocated kernel memory.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>kmem_zalloc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="72"><PARAGRAPH>kmem.h &amp; 
types.h</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="234"><PARAGRAPH>Allocate and clear space from kernel free memory.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The most important of these functions is <FUNCTION>kmem_alloc()</FUNCTION>. You use it to allocate blocks of virtual memory at any time. It offers these important options, controlled by a flag argument:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Sleeping or not sleeping when space is not available. You specify not-sleeping when holding a basic lock, but you must be prepared to deal with a return value of NULL.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Physically-contiguous memory. The memory allocated is virtual, and when it spans multiple pages, the pages are not necessarily adjacent in physical memory. You need physically contiguous pages when doing DMA with a device that cannot do scatter/gather. However, contiguous memory is harder to get as the system runs, so it is best to obtain it in an initialization routine.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Cache-aligned memory. By requesting memory that is a multiple of a cache line in size, and aligned on a cache-line boundary, you ensure that DMA operations will affect the fewest cache lines (see <XREF IDREF="40016" TYPE="TITLE">&ldquo;Setting Up a DMA Transfer&rdquo;</XREF>).</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The <INDEXTARGET ID="09-ddkidabi32"><!-- POSTPROCESSDATA: 09-ddkidabi32|kernel functions:<FUNCTION>kmem_zalloc()</FUNCTION> --><FUNCTION>kmem_zalloc()</FUNCTION> function takes the same options, but offers the additional service of zero-filling the allocated memory.</PARAGRAPH>
<PARAGRAPH>In porting an old driver you may find use of allocation calls beginning with &ldquo;kern.&rdquo; Calls to the &ldquo;kern&rdquo; group of functions should be upgraded as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>kern_malloc</FUNCTION>(<VARIABLE>n</VARIABLE>)</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="297"><PARAGRAPH>Change to <FUNCTION>kmem_alloc</FUNCTION>(<VARIABLE>n</VARIABLE>,KM_SLEEP).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>kern_calloc</FUNCTION>(<VARIABLE>n</VARIABLE>,<VARIABLE>s</VARIABLE>)</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="297"><PARAGRAPH>Change to <FUNCTION>kmem_zalloc</FUNCTION>(<VARIABLE>n*s</VARIABLE>,KM_SLEEP)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>kern_free</FUNCTION>(<VARIABLE>p</VARIABLE>)</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="297"><PARAGRAPH>Change to <FUNCTION>kmem_free</FUNCTION>(<VARIABLE>p</VARIABLE>)</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="16279">Allocating Memory in Specific Nodes of a Origin2000 System</TITLE><PARAGRAPH>In the nonuniform memory of a Origin2000 system, there is a time penalty for access to memory that is physically located in a node different from the node where the code is executing. However, <FUNCTION>kmem_alloc()</FUNCTION> attempts to allocate memory in the same node where the caller is executing. The <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> and <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> entry points execute in the node that is closest to the hardware device. If you allocate per-device structures in these entry points using <FUNCTION>kmem_alloc()</FUNCTION>, the structures will normally be in memory on the same node as the device. This provides the best performance for the interrupt handler, which also executes in the closest node to the device.</PARAGRAPH>
<PARAGRAPH>Other upper-half entry points execute in the node used by the process that called the entry point. If you allocate memory in the <FUNCTION>open()</FUNCTION> entry point, for example, that memory will be close to the user process.</PARAGRAPH>
<PARAGRAPH>When it is essential to allocate memory in a specific node and to fail if memory in that node is not available, you can use one of the functions summarized in <XREF IDREF="56354" TYPE="TABLE">Table&nbsp;8-5</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-5"><PREFIX>Table 8-5 </PREFIX><XREFTARGET ID="56354"> <EMPHASIS>(continued)        </EMPHASIS>Functions for Kernel Memory In Specific Nodes</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="99"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="72"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="216"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>kmem_alloc_node() </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="72"><PARAGRAPH>kmem.h &amp; 
types.h </PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="216"><PARAGRAPH>Allocate space from kernel free memory in specific 
node. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>kmem_zalloc_node() </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="72"><PARAGRAPH>kmem.h &amp; 
types.h </PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="216"><PARAGRAPH>Allocate and clear space from kernel free memory in 
specific node. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>These functions are available in all systems. In systems with a uniform memory, they behave the same as the normal kernel allocation functions.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="61136">Allocating Objects of Specific Kinds</TITLE><PARAGRAPH>The kernel provides a number of functions with the purpose of allocating and freeing objects of specific kinds. Many of these are variants of <FUNCTION>kmem_alloc()</FUNCTION> and <FUNCTION>kmem_free()</FUNCTION>, but others use special techniques suited to the type of object.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="54411">Allocating pollhead Objects</TITLE><PARAGRAPH><XREF IDREF="88540" TYPE="TABLE">Table&nbsp;8-6</XREF> summarizes the functions you use to allocate and free the <VARIABLE>pollhead</VARIABLE> structure that is used within the <VARIABLE>pfx</VARIABLE><FUNCTION>poll()</FUNCTION> entry point (see <XREF IDREF="19826" TYPE="TITLE">&ldquo;Entry Point poll()&rdquo;</XREF>). Typically you would call <INDEXTARGET ID="09-ddkidabi33"><!-- POSTPROCESSDATA: 09-ddkidabi33|kernel functions:<FUNCTION>phalloc()</FUNCTION> --><FUNCTION>phalloc()</FUNCTION> while initializing each minor device, and call <INDEXTARGET ID="09-ddkidabi34"><!-- POSTPROCESSDATA: 09-ddkidabi34|kernel functions:<FUNCTION>phfree()</FUNCTION> --><FUNCTION>phfree()</FUNCTION> in the <VARIABLE>pfx</VARIABLE><FUNCTION>unload()</FUNCTION> entry point. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-6"><PREFIX>Table 8-6 </PREFIX><XREFTARGET ID="88540"> <EMPHASIS>(continued)        </EMPHASIS>Functions for Allocating pollhead Structures</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="54"><PARAGRAPH>Function 
Name</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="78"><PARAGRAPH>&lbreak;Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="145" WIDTH="252"><PARAGRAPH>&lbreak;Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><REFPAGE>phalloc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="78"><PARAGRAPH>ddi.h &amp; kmem.h 
&amp; poll.h</PARAGRAPH>
</CELL>
<CELL LEFT="145" WIDTH="252"><PARAGRAPH>Allocate and initialize a pollhead structure.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><REFPAGE>phfree(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="78"><PARAGRAPH>ddi.h &amp; poll.h</PARAGRAPH>
</CELL>
<CELL LEFT="145" WIDTH="252"><PARAGRAPH>Free a pollhead structure.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Allocating Semaphores and Locks</TITLE><PARAGRAPH>There are symmetrical pairs of functions to allocate and free all types of lock and synchronization objects. These functions are summarized together with the other locking functions under <XREF IDREF="14643" TYPE="TITLE">&ldquo;Waiting and Mutual Exclusion&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="70392">Allocating buf_t Objects and Buffers</TITLE><PARAGRAPH>The argument to the <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> entry point is a <VARIABLE>buf_t</VARIABLE> structure that describes a buffer (see <XREF IDREF="66319" TYPE="TITLE">&ldquo;Entry Point strategy()&rdquo;</XREF> and <XREF IDREF="34384" TYPE="TITLE">&ldquo;Structure buf_t&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>Ordinarily, both the <VARIABLE>buf_t</VARIABLE> and the buffer are allocated and initialized by the kernel or the filesystem that calls <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION>. However, some drivers need to create a <VARIABLE>buf_t</VARIABLE> and associated buffer for special uses. The functions summarized in <XREF IDREF="58908" TYPE="TABLE">Table&nbsp;8-7</XREF> are used for this. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-7"><PREFIX>Table 8-7 </PREFIX><XREFTARGET ID="58908"> <EMPHASIS>(continued)        </EMPHASIS>Functions for Allocating buf_t Objects and Buffers</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Function 
Name</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="63"><PARAGRAPH>&lbreak;Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>&lbreak;Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>geteblk(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="63"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>Allocate a <VARIABLE>buf_t</VARIABLE> and a buffer of 1024 bytes. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>ngeteblk(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="63"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>Allocate a <VARIABLE>buf_t</VARIABLE> and a buffer of specified size. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>brelse(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="63"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>Return a buffer header and buffer to the system. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>getrbuf(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="63"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>Allocate a <VARIABLE>buf_t</VARIABLE> with no buffer. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>freerbuf(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="63"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>Free a <VARIABLE>buf_t</VARIABLE> with no buffer. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>To allocate a <VARIABLE>buf_t</VARIABLE> and its associated buffer in kernel virtual memory, use either <INDEXTARGET ID="09-ddkidabi35"><!-- POSTPROCESSDATA: 09-ddkidabi35|kernel functions:<FUNCTION>geteblk()</FUNCTION> --><FUNCTION>geteblk()</FUNCTION> or <FUNCTION>ngeteblk()</FUNCTION>. Free this pair of objects using <INDEXTARGET ID="09-ddkidabi36"><!-- POSTPROCESSDATA: 09-ddkidabi36|kernel functions:<FUNCTION>brelse()</FUNCTION> --><FUNCTION>brelse()</FUNCTION>, or by calling <FUNCTION>biodone()</FUNCTION>.</PARAGRAPH>
<PARAGRAPH>You can allocate a <VARIABLE>buf_t</VARIABLE> to describe an existing buffer&mdash;one in user space, statically allocated in the driver, or allocated with <FUNCTION>kmem_alloc()</FUNCTION>&mdash;using <INDEXTARGET ID="09-ddkidabi37"><!-- POSTPROCESSDATA: 09-ddkidabi37|kernel functions:<FUNCTION>getrbuf()</FUNCTION> --><FUNCTION>getrbuf()</FUNCTION>. Free such a <VARIABLE>buf_t</VARIABLE> using <FUNCTION>freerbuf()</FUNCTION>. </PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="20796">Transferring Data</TITLE><PARAGRAPH>The device driver executes in the kernel virtual address space, but it must transfer data to and from the address space of a user process. The kernel supplies two kinds of functions for this purpose:<INDEXTARGET ID="09-ddkidabi38"><!-- POSTPROCESSDATA: 09-ddkidabi38|address space:data transfer between --><INDEXTARGET ID="09-ddkidabi39"><!-- POSTPROCESSDATA: 09-ddkidabi39|data transfer --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>functions that transfer data between driver variables and the address space of the current process</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>functions that transfer data between driver variables and the buffer described by a <VARIABLE>uio_t</VARIABLE> object</PARAGRAPH>
</BULLET>
</BULLETLIST>
<WARNING><PREFIX>Warning</PREFIX>The use of an invalid address in kernel space with any of these functions causes a kernel panic.<INDEXTARGET ID="09-ddkidabi40"><!-- POSTPROCESSDATA: 09-ddkidabi40|kernel panic:moving data --></WARNING>
<PARAGRAPH>All functions that reference an address in user process space can sleep, because the page of process space might not be resident in memory. As a result, such functions cannot be used while holding a basic lock, and should be avoided in an interrupt handler.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="22073">General Data Transfer</TITLE><PARAGRAPH>The kernel supplies functions for clearing and copying memory within the kernel virtual address space, and between the kernel address space and the address space of the user process that is the current context. These general-purpose functions are summarized in <XREF IDREF="14834" TYPE="TABLE">Table&nbsp;8-8</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-8"><PREFIX>Table 8-8 </PREFIX><XREFTARGET ID="14834"> <EMPHASIS>(continued)        </EMPHASIS>Functions for General Data Transfer</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Function 
Name</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="72"><PARAGRAPH>&lbreak;Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>&lbreak;Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>bcopy(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="72"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Copy data between address locations in the kernel. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>bzero(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="72"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Clear memory for a given number of bytes. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>copyin(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="72"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Copy data from a user buffer to a driver buffer. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>copyout(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="72"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Copy data from a driver buffer to a user buffer. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>fubyte(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="72"><PARAGRAPH>systm.h &amp; 
types.h </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Load a byte from user space. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>fuword(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="72"><PARAGRAPH>systm.h &amp; 
types.h</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Load a word from user space.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>hwcpin(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="72"><PARAGRAPH>systm.h &amp; 
types.h</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Copy data from device registers to kernel memory.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>hwcpout(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="72"><PARAGRAPH>systm.h &amp; 
types.h</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Copy data from kernel memory to device registers.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>subyte(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="72"><PARAGRAPH>systm.h &amp; 
types.h</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Store a byte to user space.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>suword(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="72"><PARAGRAPH>systm.h &amp; 
types.h</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Store a word to user space.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="98484">Block Copy Functions</TITLE><PARAGRAPH>The <INDEXTARGET ID="09-ddkidabi41"><!-- POSTPROCESSDATA: 09-ddkidabi41|kernel functions:<FUNCTION>bzero()</FUNCTION> --><INDEXTARGET ID="09-ddkidabi42"><!-- POSTPROCESSDATA: 09-ddkidabi42|kernel functions:<FUNCTION>bcopy()</FUNCTION> --><FUNCTION>bcopy()</FUNCTION> and <FUNCTION>bzero()</FUNCTION> functions are used to copy and clear data areas within the kernel address space, for example driver buffers or work areas. These are optimized routines that take advantage of available hardware features.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>bcopy()</FUNCTION> function is not appropriate for copying data between a buffer and a device; that is, for copying between virtual memory and the physical memory addresses that represent a range of device registers (or indeed any uncached memory). The reason is that <FUNCTION>bcopy()</FUNCTION> uses doubleword moves and any other special hardware features available, and devices many not be able to accept data in these units. The <FUNCTION>hwcpin()</FUNCTION> and <FUNCTION>hwcpout()</FUNCTION> functions copy data in 16-bit units; use them to transfer bulk data between device space and memory. (Use simple assignment to move single words or bytes.)</PARAGRAPH>
<PARAGRAPH>The <INDEXTARGET ID="09-ddkidabi43"><!-- POSTPROCESSDATA: 09-ddkidabi43|kernel functions:<FUNCTION>copyout()</FUNCTION> --><INDEXTARGET ID="09-ddkidabi44"><!-- POSTPROCESSDATA: 09-ddkidabi44|kernel functions:<FUNCTION>copyin()</FUNCTION> --><FUNCTION>copyin()</FUNCTION> and <FUNCTION>copyout()</FUNCTION> functions take a kernel virtual address, a process virtual address, and a length. They copy the specified number of bytes between the kernel space and the user space. They select the best algorithm for copying, and take advantage of memory alignment and other hardware features.</PARAGRAPH>
<PARAGRAPH>If there is no current context, or if the address in user space is invalid, or if the address plus length is not contained in the user space, the functions return -1. This indicates an error in the request passed to the driver entry point, and the driver normally returns an EFAULT error.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Byte and Word Functions</TITLE><PARAGRAPH>The functions <INDEXTARGET ID="09-ddkidabi45"><!-- POSTPROCESSDATA: 09-ddkidabi45|kernel functions:<FUNCTION>subyte()</FUNCTION> --><INDEXTARGET ID="09-ddkidabi46"><!-- POSTPROCESSDATA: 09-ddkidabi46|kernel functions:<FUNCTION>fubyte()</FUNCTION> --><FUNCTION>fubyte()</FUNCTION>, <FUNCTION>subyte()</FUNCTION>, <FUNCTION>fuword()</FUNCTION>, and <FUNCTION>suword()</FUNCTION> are used to move single items to or from user space. When only a single byte or word is needed, these functions have less overhead than the corresponding <FUNCTION>copyin()</FUNCTION> or <FUNCTION>copyout()</FUNCTION> call. For example you could use <FUNCTION>fuword()</FUNCTION> to pick up a parameter using an address passed to the <VARIABLE>pfx</VARIABLE><FUNCTION>ioctl()</FUNCTION> entry point. When transferring more than a few bytes, a block move is more efficient.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="75852">Transferring Data Through a uio_t Object</TITLE><PARAGRAPH>A <INDEXTARGET ID="09-ddkidabi47"><!-- POSTPROCESSDATA: 09-ddkidabi47|data types:<VARIABLE>uio_t</VARIABLE> --><VARIABLE>uio_t</VARIABLE> object defines a list of one or more segments in the address space of the kernel or a user process (see <XREF IDREF="39112" TYPE="TITLE">&ldquo;Structure uio_t&rdquo;</XREF>). The kernel supplies three functions for transferring data based on a <VARIABLE>uio_t</VARIABLE>, and these are summarized in <XREF IDREF="24875" TYPE="TABLE">Table&nbsp;8-9</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-9"><PREFIX>Table 8-9 </PREFIX><XREFTARGET ID="24875"> <EMPHASIS>(continued)        </EMPHASIS>Functions Moving Data Using uio_t </CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="63"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="243"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>uiomove(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="63"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="243"><PARAGRAPH>Copy data using <VARIABLE>uio_t</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>ureadc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="63"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="243"><PARAGRAPH>Copy a character to space described by <VARIABLE>uio_t.</VARIABLE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>uwritec(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="63"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="243"><PARAGRAPH>Return a character from space described by <VARIABLE>uio_t.</VARIABLE>&space;</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The <INDEXTARGET ID="09-ddkidabi48"><!-- POSTPROCESSDATA: 09-ddkidabi48|kernel functions:<FUNCTION>uiomove()</FUNCTION> --><FUNCTION>uiomove()</FUNCTION> function moves multiple bytes between a buffer in kernel virtual space&mdash;typically, a buffer owned by the driver&mdash;and the space or spaces described by a <VARIABLE>uio_t</VARIABLE>. The function takes a byte count and a direction flag as arguments, and uses the most efficient mechanism for copying.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>ureadc()</FUNCTION> and <FUNCTION>uwritec()</FUNCTION> functions transfer only a single byte. You would use them when transferring data a byte at a time by PIO. When moving more than a few bytes, <FUNCTION>uiomove()</FUNCTION> is faster.</PARAGRAPH>
<PARAGRAPH>All of these functions modify the <VARIABLE>uio_t</VARIABLE> to reflect the transfer of data:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><VARIABLE>uio_resid</VARIABLE> is decremented by the amount moved</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>In the <VARIABLE>iovec_t</VARIABLE> for the current segment, <VARIABLE>iov_base</VARIABLE> is incremented and <VARIABLE>iov_len</VARIABLE> is decremented</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>As segments are used up, <VARIABLE>uio_iov</VARIABLE> is incremented and <VARIABLE>uio_iovcnt</VARIABLE> is decremented</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The result is that the state of the <VARIABLE>uio_t</VARIABLE> always reflects the number of bytes remaining to transfer. When the <VARIABLE>pfx</VARIABLE><FUNCTION>read()</FUNCTION> or <VARIABLE>pfx</VARIABLE><FUNCTION>write()</FUNCTION> entry point returns, the kernel uses the final value of <VARIABLE>ui_resid</VARIABLE> to compute the count returned to the <FUNCTION>read()</FUNCTION> or <FUNCTION>write()</FUNCTION> function call.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="74579">Managing Virtual and Physical Addresses</TITLE><PARAGRAPH>The kernel supplies functions for querying the address of hardware registers and for performing memory mapping. The most helpful of these functions involve the use of address/length lists.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="79722">Managing Mapped Memory</TITLE><PARAGRAPH>The <INDEXTARGET ID="09-ddkidabi49"><!-- POSTPROCESSDATA: 09-ddkidabi49|data types:<VARIABLE>vhandl_t</VARIABLE> --><VARIABLE>pfx</VARIABLE><FUNCTION>map()</FUNCTION> and <VARIABLE>pfx</VARIABLE><FUNCTION>unmap()</FUNCTION> entry points receive a <VARIABLE>vhandl_t</VARIABLE> object that describes the region of user process space to be mapped. The functions summarized in <XREF IDREF="16648" TYPE="TABLE">Table&nbsp;8-10</XREF> are used to manipulate that object. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-10"><PREFIX>Table 8-10 </PREFIX><XREFTARGET ID="16648"> <EMPHASIS>(continued)        </EMPHASIS>Functions to Manipulate a vhandl_t Object</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="81"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="63"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>v_getaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="63"><PARAGRAPH>ddmap.h &amp; 
types.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Get the user virtual address associated with a <VARIABLE>vhandl_t</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>v_gethandle(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="63"><PARAGRAPH>ddmap.h &amp; 
types.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Get a unique identifier associated with a <VARIABLE>vhandl_t</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>v_getlen(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="63"><PARAGRAPH>ddmap.h &amp; 
types.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Get the length of user address space associated with a 
<VARIABLE>vhandl_t</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>v_mapphys(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="63"><PARAGRAPH>ddmap.h &amp; 
types.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Map kernel address space into user address space. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The <INDEXTARGET ID="09-ddkidabi50"><!-- POSTPROCESSDATA: 09-ddkidabi50|kernel functions:<FUNCTION>v_mapphys()</FUNCTION> --><FUNCTION>v_mapphys()</FUNCTION> function actually performs a mapping between a kernel address and a segment described by a <VARIABLE>vhandl_t</VARIABLE> (see <XREF IDREF="20168" TYPE="TITLE">&ldquo;Entry Point map()&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>The <INDEXTARGET ID="09-ddkidabi51"><!-- POSTPROCESSDATA: 09-ddkidabi51|kernel functions:<FUNCTION>v_getaddr()</FUNCTION> --><FUNCTION>v_getaddr()</FUNCTION> function has hardly any use except for logging and debugging. The address in user space is normally undefined and unusable when the <VARIABLE>pfx</VARIABLE><FUNCTION>map()</FUNCTION> entry point is called, and mapped to kernel space when <VARIABLE>pfx</VARIABLE><FUNCTION>unmap()</FUNCTION> is called. The driver has no practical use for this value.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>v_getlen()</FUNCTION> function is useful only in the <VARIABLE>pfx</VARIABLE><FUNCTION>unmap()</FUNCTION> entry point&mdash;the <VARIABLE>pfx</VARIABLE><FUNCTION>map()</FUNCTION> entry point receives a length argument specifying the desired region size.</PARAGRAPH>
<PARAGRAPH>The <INDEXTARGET ID="09-ddkidabi52"><!-- POSTPROCESSDATA: 09-ddkidabi52|kernel functions:<FUNCTION>v_gethandle()</FUNCTION> --><FUNCTION>v_gethandle()</FUNCTION> function returns a number that is unique to this mapping (actually, the address of a page table entry). You use this as a key to identify multiple mappings, so that the <VARIABLE>pfx</VARIABLE><FUNCTION>unmap()</FUNCTION> entry point can properly clean up.</PARAGRAPH>
<CAUTION><PREFIX>Caution</PREFIX>Be careful when mapping device registers to a user process. Memory protection is available only on page boundaries, so configure the addresses of I/O cards so that each device is on a separate page or pages. When multiple devices are on the same page, a user process that maps one device can access all on that page. This can cause system security problems or other problems that are hard to diagnose.</CAUTION>
<NOTE><PREFIX>Note</PREFIX>In previous releases of IRIX, the header file <FILENAME>sys/region.h</FILENAME> contained these functions. As of IRIX 6.5, the header file <FILENAME>sys/region.h</FILENAME> is removed and these same functions are declared in <FILENAME>ksys/ddmap.h</FILENAME>.</NOTE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="54064">Working With Page and Sector Units</TITLE><PARAGRAPH>In a 32-bit kernel, the page size for memory and I/O is 4 KB. In a 64-bit kernel, the memory page size is typically 16&nbsp;KB, but can vary. Also, the size of &ldquo;page&rdquo; used for I/O operations can be different from the size of page used for virtual memory. Because of hardware constraints in Challenge and Onyx systems, a 4&nbsp;KB page is used for I/O operations in these machines.<INDEXTARGET ID="09-ddkidabi53"><!-- POSTPROCESSDATA: 09-ddkidabi53|page size:I/O --><INDEXTARGET ID="09-ddkidabi54"><!-- POSTPROCESSDATA: 09-ddkidabi54|page size:memory --></PARAGRAPH>
<PARAGRAPH>The header files <INDEXTARGET ID="09-ddkidabi55"><!-- POSTPROCESSDATA: 09-ddkidabi55|page size:macros --><INDEXTARGET ID="09-ddkidabi56"><!-- POSTPROCESSDATA: 09-ddkidabi56|sector unit macros --><INDEXTARGET ID="09-ddkidabi57"><!-- POSTPROCESSDATA: 09-ddkidabi57|header files:<FILENAME>sys/sysmacros.h</FILENAME> --><INDEXTARGET ID="09-ddkidabi58"><!-- POSTPROCESSDATA: 09-ddkidabi58|header files:<FILENAME>sys/immu.h</FILENAME> --><FILENAME>sys/immu.h</FILENAME> and <FILENAME>sys/sysmacros.h</FILENAME> contain constants and macros for working with page units. Some of the most useful are listed in <XREF IDREF="71852" TYPE="TABLE">Table&nbsp;8-11</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-11"><PREFIX>Table 8-11 </PREFIX><XREFTARGET ID="71852"> <EMPHASIS>(continued)        </EMPHASIS>Constants and Macros for Page and Sector values</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="99"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="54"><PARAGRAPH>Header File</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>BBSIZE </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="54"><PARAGRAPH><FILENAME>param.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Size of a &ldquo;basic block,&rdquo; the assumed disk sector size (512). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>BTOBB(<VARIABLE>bytes</VARIABLE>) </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="54"><PARAGRAPH><FILENAME>param.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Converts byte count to basic block count, rounding up. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>BTOBBT(<VARIABLE>bytes</VARIABLE>) </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="54"><PARAGRAPH><FILENAME>param.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Converts byte count to basic block count, truncating. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>OFFTOBB(<VARIABLE>bytes</VARIABLE>) </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="54"><PARAGRAPH><FILENAME>param.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Converts <VARIABLE>off_t</VARIABLE> count to basic blocks, rounding. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>OFFTOBBT(<VARIABLE>bytes</VARIABLE>) </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="54"><PARAGRAPH><FILENAME>param.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Converts <VARIABLE>off_t</VARIABLE> count to basic blocks, truncating. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>BBTOOFF(<VARIABLE>bbs</VARIABLE>) </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="54"><PARAGRAPH><FILENAME>param.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Converts count of basic blocks to an <VARIABLE>off_t</VARIABLE> byte count. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>NBPP</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="54"><PARAGRAPH><FILENAME>immu.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Number of bytes in a virtual memory page (defined from 
_PAGESZ; see <XREF IDREF="28510" TYPE="TITLE">&ldquo;Compiler Variables&rdquo;</XREF>). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>IO_NBPP </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="54"><PARAGRAPH><FILENAME>immu.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Number of bytes in an I/O page, can differ from NBPP. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>io_numpages(<VARIABLE>addr</VARIABLE>, <VARIABLE>len</VARIABLE>) </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="54"><PARAGRAPH><FILENAME>sysmacros.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Number of I/O pages that span a given address for a 
length. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>io_ctob(<VARIABLE>x</VARIABLE>) </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="54"><PARAGRAPH><FILENAME>sysmacros.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Return number of bytes in <VARIABLE>x</VARIABLE> I/O pages (rounded up). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>io_ctobt(<VARIABLE>x</VARIABLE>) </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="54"><PARAGRAPH><FILENAME>sysmacros.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Return number of bytes in <VARIABLE>x</VARIABLE> I/O pages (truncated). </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The names listed in <XREF IDREF="71852" TYPE="TABLE">Table&nbsp;8-11</XREF> are defined at compile-time. If you use them, the binary object file is dependent on the compile-time variables for the chosen platform, and may not run on a different platform.</PARAGRAPH>
<PARAGRAPH>The operations summarized in <XREF IDREF="41932" TYPE="TABLE">Table&nbsp;8-12</XREF> are provided as functions. Use of them does not commit your driver to a particular platform. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-12"><PREFIX>Table 8-12 </PREFIX><XREFTARGET ID="41932"> <EMPHASIS>(continued)        </EMPHASIS>Functions to Convert Bytes to Sectors or Pages</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>btop(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Return number of virtual pages in a byte count (truncate). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>btopr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Return number of virtual pages in a byte count (round up). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>ptob(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Convert size in virtual pages to size in bytes. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>When examining an existing driver, be alert for any assumption that a virtual memory page has a particular size, or that an I/O page is the same size as a memory page.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="29580">Using Address/Length Lists</TITLE><PARAGRAPH>The concepts behind alenlists are described under <INDEXTARGET ID="09-ddkidabi59"><!-- POSTPROCESSDATA: 09-ddkidabi59|address/length list --><INDEXTARGET ID="09-ddkidabi60"><!-- POSTPROCESSDATA: 09-ddkidabi60|data types:<VARIABLE>alenlist_t</VARIABLE> --><XREF IDREF="65822" TYPE="TITLE">&ldquo;Address/Length Lists&rdquo;</XREF> and in more detail in the reference page <REFPAGE>alenlist(d4x)</REFPAGE>.</PARAGRAPH>
<PARAGRAPH>You can use alenlists to unify the handling of buffer addresses of all kinds. In general you use an alenlist as follows:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Create the alenlist object, either with an explicit function call or implicitly as part of filling the list.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Fill the list with addresses and lengths to describe a buffer in some address space.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Apply a translation function to translate all the addresses into the address space of an I/O bus.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Use an alenlist cursor to read out the translated address/length pairs, and program them into a device so it can do DMA.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="73571">Creating Alenlists</TITLE><PARAGRAPH>The functions summarized in <XREF IDREF="36531" TYPE="TABLE">Table&nbsp;8-13</XREF> are used to explicitly create and manage alenlists. For details see reference page <REFPAGE>alenlist_ops(d3x)</REFPAGE>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-13"><PREFIX>Table 8-13 </PREFIX><XREFTARGET ID="36531"> <EMPHASIS>(continued)        </EMPHASIS> <EMPHASIS>(continued)        </EMPHASIS>Functions to Explicitly Manage Alenlists</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="81"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="63"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>alenlist_create() </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="63"><PARAGRAPH>alenlist.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Create an empty alenlist. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>alenlist_destroy() </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="63"><PARAGRAPH>alenlist.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Release memory of an alenlist. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>alenlist_clear() </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="63"><PARAGRAPH>alenlist.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Empty an alenlist. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Typically you create an alenlist implicitly, as a side-effect of loading it (see next topic). However you can use <INDEXTARGET ID="09-ddkidabi61"><!-- POSTPROCESSDATA: 09-ddkidabi61|kernel functions:<FUNCTION>alenlist_create()</FUNCTION> --><FUNCTION>alenlist_create()</FUNCTION> to create an alenlist. Then you can be sure that there will never be an unplanned delay for memory allocation while using the list.</PARAGRAPH>
<PARAGRAPH>Whenever the driver is finished with an alenlist, release it using <INDEXTARGET ID="09-ddkidabi62"><!-- POSTPROCESSDATA: 09-ddkidabi62|kernel functions:<FUNCTION>alenlist_destroy()</FUNCTION> --><FUNCTION>alenlist_destroy()</FUNCTION>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="47096">Loading Alenlists</TITLE><PARAGRAPH>The functions summarized in <XREF IDREF="35407" TYPE="TABLE">Table&nbsp;8-14</XREF> are used to populate an alenlist with one or more address/length pairs to describe memory. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-14"><PREFIX>Table 8-14 </PREFIX><XREFTARGET ID="35407"> <EMPHASIS>(continued)        </EMPHASIS> <EMPHASIS>(continued)        </EMPHASIS>Functions to Populate Alenlists</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="90"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>buf_to_alenlist() </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>alenlist.h </PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Fill an alenlist with entries that describe the buffer 
controlled by a <VARIABLE>buf_t</VARIABLE> object. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>kvaddr_to_alenlist() </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>alenlist.h </PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Fill an alenlist with entries that describe a buffer in kernel 
virtual address space. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>uvaddr_to_alenlist() </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>alenlist.h </PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Fill an alenlists with entries that describe a buffer in a user 
virtual address space. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>alenlist_append() </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>alenlist.h </PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Add a specified address and length as an item to an 
existing alenlist. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH> Each of the functions <INDEXTARGET ID="09-ddkidabi63"><!-- POSTPROCESSDATA: 09-ddkidabi63|kernel functions:<FUNCTION>buf_to_alenlist()</FUNCTION> --><INDEXTARGET ID="09-ddkidabi64"><!-- POSTPROCESSDATA: 09-ddkidabi64|kernel functions:<FUNCTION>kvaddr_to_alenlist()</FUNCTION> --><INDEXTARGET ID="09-ddkidabi65"><!-- POSTPROCESSDATA: 09-ddkidabi65|kernel functions:<FUNCTION>uvaddr_to_alenlist()</FUNCTION> --><FUNCTION>buf_to_alenlist()</FUNCTION>, <FUNCTION>kvaddr_to_alenlist()</FUNCTION>, and <FUNCTION>uvaddr_to_alenlist()</FUNCTION> take an alenlist address as their first argument. If this address is NULL, they create a new list and use it. If the input list is too small, any of the functions in <XREF IDREF="35407" TYPE="TABLE">Table&nbsp;8-14</XREF> can allocate a new list with more entries. Either of these allocations may sleep. In order to avoid an unplanned delay, you can create an alenlist in advance, fill it to a planned size with null items, and clear it.</PARAGRAPH>
<PARAGRAPH>The functions <FUNCTION>buf_to_alenlist()</FUNCTION>, <FUNCTION>kvaddr_to_alenlist()</FUNCTION>, and <FUNCTION>uvaddr_to_alenlist()</FUNCTION> add entries to an alenlist to describe the physical address of a buffer. Before using <FUNCTION>uvaddr_to_alenlist()</FUNCTION> you must be sure that the pages of the user buffer are locked into memory (see <XREF IDREF="77908" TYPE="TITLE">&ldquo;Converting Virtual Addresses to Physical&rdquo;</XREF>).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Translating Alenlists</TITLE><PARAGRAPH>The kernel support for the PCI bus includes functions that translate an entire alenlist from physical memory addresses to corresponding addresses in the address space of the target bus. For PCI functions see <XREF IDREF="27119" TYPE="TITLE">&ldquo;Mapping an Address/Length List&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="46391">Using Alenlist Cursors</TITLE><PARAGRAPH>You use a cursor to read out the address/length pairs from an alenlist. The cursor management functions are summarized in <INDEXTARGET ID="09-ddkidabi66"><!-- POSTPROCESSDATA: 09-ddkidabi66|address/length list:cursor use --><XREF IDREF="53918" TYPE="TABLE">Table&nbsp;8-15</XREF> and detailed in reference page <REFPAGE>alenlist_ops(d3x)</REFPAGE>.</PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-15"><PREFIX>Table 8-15 </PREFIX><XREFTARGET ID="53918"> <EMPHASIS>(continued)        </EMPHASIS> <EMPHASIS>(continued)        </EMPHASIS>Functions to Manage Alenlist Cursors</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="117"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="72"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="198"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH>alenlist_cursor_create() </PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="72"><PARAGRAPH>alenlist.h </PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="198"><PARAGRAPH>Create an alenlist cursor and associate it with a 
specified list.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH>alenlist_cursor_init() </PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="72"><PARAGRAPH>alenlist.h </PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="198"><PARAGRAPH>Set a cursor to point at a specified list item.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH>alenlist_cursor_destroy() </PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="72"><PARAGRAPH>alenlist.h </PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="198"><PARAGRAPH>Release memory of a cursor.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Each alenlist includes a built-in cursor. If you know that only one process or thread is using the alenlist, you can use this built-in cursor. When more than one process or thread might use the alenlist, each must create an explicit cursor. A cursor is associated with one alenlist and must always be used with that alenlist.</PARAGRAPH>
<PARAGRAPH>The functions that retrieve data based on a cursor are summarized in <XREF IDREF="97886" TYPE="TABLE">Table&nbsp;8-16</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-16"><PREFIX>Table 8-16 </PREFIX><XREFTARGET ID="97886"> <EMPHASIS>(continued)        </EMPHASIS> <EMPHASIS>(continued)        </EMPHASIS>Functions to Use an Alenlist Based on a Cursor</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="117"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="54"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="216"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH>alenlist_get() </PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="54"><PARAGRAPH>alenlist.h </PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="216"><PARAGRAPH>Retrieve the next sequential address and length from 
a list.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH>alenlist_cursor_offset(D3) </PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="54"><PARAGRAPH>alenlist.h </PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="216"><PARAGRAPH>Query the effective byte offset of a cursor in the buffer 
described by its list.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The <INDEXTARGET ID="09-ddkidabi67"><!-- POSTPROCESSDATA: 09-ddkidabi67|kernel functions:<FUNCTION>alenlist_get()</FUNCTION> --><FUNCTION>alenlist_get()</FUNCTION> function is the key function for extracting data from an alenlist. Each call returns one address and its associated length. However, these address/length pairs are not required to match exactly to the items in the list. You can extract address/length pairs in smaller units. For example, suppose the list contains address/length pairs that describe 4&nbsp;KB pages. You can read out sequential address/length pairs with maximum lengths of 512 bytes, or any other smaller length. The cursor remembers the position in the list to the byte level.</PARAGRAPH>
<PARAGRAPH>You pass to <FUNCTION>alenlist_get() </FUNCTION>a maximum length to return. When that is 0 or large, the function returns exactly the address/length pairs in the list. When the maximum length is smaller than the current address/length pair, the function returns the address and length of the next sequential segment not exceeding the maximum. In addition, when the maximum length is an integral power of two, the function restricts the returned length so that the returned segment does not cross an address boundary of the maximum length.</PARAGRAPH>
<PARAGRAPH>These features allow you to read out units of 512 bytes (for example), never crossing a 512-byte boundary, from a list that contains address/length pairs in other lengths. The <INDEXTARGET ID="09-ddkidabi68"><!-- POSTPROCESSDATA: 09-ddkidabi68|kernel functions:<FUNCTION>alenlist_cursor_offset()</FUNCTION> --><FUNCTION>alenlist_cursor_offset()</FUNCTION> function returns the byte-level offset between the first address in the list and the next address the cursor will return.&space;</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="40016">Setting Up a DMA Transfer</TITLE><PARAGRAPH>A DMA transfer is performed by a programmable I/O device, usually called <INDEXTARGET ID="09-ddkidabi69"><!-- POSTPROCESSDATA: 09-ddkidabi69|Direct Memory Access (DMA):setting up --><GLOSSARYITEM>bus master</GLOSSARYITEM> (see <XREF IDREF="91137" TYPE="TITLE">&ldquo;Direct Memory Access&rdquo;</XREF>). The driver programs the device with the length of data to transfer, and with a starting address. Some devices can be programmed with a list of addresses and lengths; these devices are said to have <GLOSSARYITEM>scatter/gather</GLOSSARYITEM> capability.</PARAGRAPH>
<PARAGRAPH>There are two issues in preparing a DMA transfer:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Calculating the addresses to be programmed into the device registers. These addresses are the <ITALICS>bus</ITALICS> addresses that will properly target the <ITALICS>memory</ITALICS> buffers.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>In a uniprocessor, ensuring cache coherency. A multiprocessor handles cache coherency automatically.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The most effective tool for creation of target addresses is the address/length list (see <XREF IDREF="29580" TYPE="TITLE">&ldquo;Using Address/Length Lists,&rdquo;</XREF> the preceding topic):</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>You collect the addresses and lengths of the parts of the target buffer in an alenlist.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>You apply a single translation function to replace that alenlist with one whose contents are based on bus virtual addresses.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>You use an alenlist cursor to read out addresses and lengths in unit sizes appropriate to the device, and program these into the device using PIO.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>The functions you use to translate the addresses in an alenlist are different for different bus adapters, and are discussed in the following chapters:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The functions to set up DMA from a VME device are covered in <XREF IDREF="13012" TYPE="TITLE">Chapter&nbsp;13, &ldquo;Services for VME Drivers on Origin2000/Onyx2.&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The functions to set up DMA from a SCSI device are covered in <XREF IDREF="33977" TYPE="TITLE">Chapter&nbsp;16, &ldquo;SCSI Device Drivers.&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The functions to set up DMA from a PCI device are covered in <XREF IDREF="46138" TYPE="TITLE">Chapter&nbsp;20, &ldquo;PCI Device Attachment.&rdquo;</XREF></PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION3 LBL="" HELPID = ""><TITLE>DMA Buffer Alignment</TITLE><PARAGRAPH>In some systems, the buffers used for DMA must be aligned on a boundary the size of a <INDEXTARGET ID="09-ddkidabi70"><!-- POSTPROCESSDATA: 09-ddkidabi70|cache:alignment of buffers --><INDEXTARGET ID="09-ddkidabi71"><!-- POSTPROCESSDATA: 09-ddkidabi71|Direct Memory Access (DMA):buffer alignment for --><GLOSSARYITEM>cache line</GLOSSARYITEM> in the current CPU. Although not all system architectures require cache alignment, it does no harm to use cache-aligned buffers in all cases. The size of a cache line varies among CPU models, but if you obtain a DMA buffer using the KMEM_CACHEALIGN flag of <FUNCTION>kmem_alloc()</FUNCTION>, the buffer is properly aligned. The buffer returned by <FUNCTION>geteblk()</FUNCTION> (see <XREF IDREF="70392" TYPE="TITLE">&ldquo;Allocating buf_t Objects and Buffers&rdquo;</XREF>) is cache-aligned.</PARAGRAPH>
<PARAGRAPH>Why is cache alignment necessary? Suppose you have a variable, <VARIABLE>X</VARIABLE>, adjacent to a buffer you are going to use for DMA write. If you invalidate the buffer prior to the DMA write, but then reference the variable <VARIABLE>X</VARIABLE>, the resulting cache miss brings part of the buffer back into the cache. When the DMA write completes, the cache is stale with respect to memory. If, however, you invalidate the cache after the DMA write completes, you destroy the value of the variable <VARIABLE>X</VARIABLE>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Maximum DMA Transfer Size</TITLE><PARAGRAPH>The maximum size for a single DMA transfer can be set by the system tuning variable <INDEXTARGET ID="09-ddkidabi72"><!-- POSTPROCESSDATA: 09-ddkidabi72|IRIX commands:<COMMAND>systune</COMMAND>:max DMA size --><INDEXTARGET ID="09-ddkidabi73"><!-- POSTPROCESSDATA: 09-ddkidabi73|Direct Memory Access (DMA):maximum size --><VARIABLE>maxdmasz</VARIABLE>, using the <COMMAND>systune</COMMAND> command (see the <REFPAGE>systune(1)</REFPAGE> reference page). A single I/O operation larger than this produces the error ENOMEM.</PARAGRAPH>
<PARAGRAPH>The unit of measure for <VARIABLE>maxdmasz</VARIABLE> is the page, which varies with the kernel. Under IRIX 6.2, a 32-bit kernel uses 4&nbsp;KB pages while a 64-bit kernel uses 16&nbsp;KB pages. In both systems, <VARIABLE>maxdmasz</VARIABLE> is shipped with the value 1024 decimal, equivalent to 4&nbsp;MB in a 32-bit kernel and 16&nbsp;MB in a 64-bit kernel.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="77908">Converting Virtual Addresses to Physical</TITLE><PARAGRAPH>There are no legitimate reasons for a device driver to convert a kernel virtual memory address to a physical address in IRIX 6.5. This translation is fraught with complexity and strongly dependent on the hardware of the system. For these and other reasons, the kernel provides a wide variety of address-translation functions that perform the kinds of translations that a driver requires.<INDEXTARGET ID="09-ddkidabi74"><!-- POSTPROCESSDATA: 09-ddkidabi74|address space:physical --></PARAGRAPH>
<PARAGRAPH>In the simpler hardware architectures of past systems, there was a straightforward mapping between the addresses used by software and the addresses used by a bus master for DMA. This is no longer the case. Some of the complexities are sketched under the topic <XREF IDREF="29796" TYPE="TITLE">&ldquo;PIO Addresses and DMA Addresses&rdquo;</XREF>. In the Origin2000 architecture, the address used by a bus master can undergo two or three different translations on its way from the device to memory. There is no way in which a device driver can get the information to prepare the translated address for the device to use.</PARAGRAPH>
<PARAGRAPH>Instead, the driver uses translations based on opaque software objects such as PIO maps, DMA maps, and alenlists. Translations are bus-specific, and the functions for them are presented in the chapters on those buses.</PARAGRAPH>
<PARAGRAPH>You can load an alenlist with physical address/length pairs based on a kernel virtual address using <FUNCTION>buftoalenlist()</FUNCTION> (see <XREF IDREF="47096" TYPE="TITLE">&ldquo;Loading Alenlists&rdquo;</XREF>). Some older drivers might still contain use of the&space;<INDEXTARGET ID="09-ddkidabi75"><!-- POSTPROCESSDATA: 09-ddkidabi75|kernel functions:<FUNCTION>kvtophys()</FUNCTION> --><FUNCTION>kvtophys()</FUNCTION> function, which takes a kernel virtual address and returns the corresponding system bus physical address. This function is still supported (see the <REFPAGE>kvtophys(D3)</REFPAGE> reference page). However, you should be aware that the physical address returned is useless for programming an I/O device.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="41107">Managing Buffer Virtual Addresses</TITLE><PARAGRAPH>Block device drivers operate upon data buffers described by <INDEXTARGET ID="09-ddkidabi76"><!-- POSTPROCESSDATA: 09-ddkidabi76|data types:<VARIABLE>buf_t</VARIABLE>:functions --><VARIABLE>buf_t</VARIABLE> objects (see <XREF IDREF="34384" TYPE="TITLE">&ldquo;Structure buf_t&rdquo;</XREF>). Kernel functions to manipulate buffer page mappings are summarized in <XREF IDREF="94628" TYPE="TABLE">Table&nbsp;8-17</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-17"><PREFIX>Table 8-17 </PREFIX><XREFTARGET ID="94628"> <EMPHASIS>(continued)        </EMPHASIS>Functions to Map Buffer Pages</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="90"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>bp_mapin(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>buf.h </PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Map buffer pages into kernel virtual address space, 
ensuring the pages are in memory and pinned. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>bp_mapout(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>buf.h </PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Release mapping of buffer pages. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>clrbuf(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>buf.h </PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Clear the memory described by a mapped-in <VARIABLE>buf_t</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>buf_to_alenlist(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>alenlist.h </PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Fill an alenlist with entries that describe the buffer 
controlled by a <VARIABLE>buf_t</VARIABLE> object. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>undma(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Unlock physical memory after I/O complete. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>userdma(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Lock physical memory in user space. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>bptophys(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>ddi.h</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Get physical address of buffer data.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>getnextpg(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>buf.h</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Return <VARIABLE>pfdat</VARIABLE> structure for next page.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>pptophys(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>buf.h</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Return the physical address of a page described by a <VARIABLE>pfdat</VARIABLE> 
structure.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>When a <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> routine receives a <VARIABLE>buf_t</VARIABLE> that is not mapped into memory (see <XREF IDREF="46843" TYPE="TITLE">&ldquo;Buffer Location and b_flags&rdquo;</XREF>), it must make sure that the pages of the buffer space are in memory, and it must obtain valid kernel virtual addresses to describe the pages. The simplest way is to apply the <INDEXTARGET ID="09-ddkidabi77"><!-- POSTPROCESSDATA: 09-ddkidabi77|kernel functions:<FUNCTION>bp_mapin()</FUNCTION> --><FUNCTION>bp_mapin()</FUNCTION> function to the <VARIABLE>buf_t</VARIABLE>. This function allocates a contiguous range of page table entries in the kernel address space to describe the buffer, creating a mapping of the buffer pages to a contiguous range of kernel virtual addresses. It sets the virtual address of the first data byte in <VARIABLE>b_un.b_addr</VARIABLE>, and sets the flags so that BP_ISMAPPED<FUNCTION>()</FUNCTION> returns true&mdash;thus converting an unmapped buffer to a mapped case.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>The reference page for the <FUNCTION>userdma()</FUNCTION> function is out of date as shipped in IRIX&nbsp;6.4. The correct prototype for this function, as coded in sys/buf.h, is</NOTE>
<CODE>
int userdma(void *usr_v_addr, size_t num_bytes, int rw, void *MBZ);
</CODE>
<PARAGRAPH>The fourth argument must be a zero. The return value is not the same as stated. The function returns 0 for success and a standard error code for failure.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="65953">Managing Memory for Cache Coherency</TITLE><PARAGRAPH>Some kernel functions used for ensuring cache coherency are summarized in <INDEXTARGET ID="09-ddkidabi78"><!-- POSTPROCESSDATA: 09-ddkidabi78|Direct Memory Access (DMA):cache control --><INDEXTARGET ID="09-ddkidabi79"><!-- POSTPROCESSDATA: 09-ddkidabi79|cache:control functions --><XREF IDREF="22774" TYPE="TABLE">Table&nbsp;8-18</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-18"><PREFIX>Table 8-18 </PREFIX><XREFTARGET ID="22774"> <EMPHASIS>(continued)        </EMPHASIS>Functions Related to Cache Coherency</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="108"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="207"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>dki_dcache_inval(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>systm.h &amp; 
types.h </PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="207"><PARAGRAPH>Invalidate the data cache for a given range of 
virtual addresses. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>dki_dcache_wb(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>systm.h &amp; 
types.h </PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="207"><PARAGRAPH>Write back the data cache for a given range of 
virtual addresses. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>dki_dcache_wbinval(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>systm.h &amp; 
types.h </PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="207"><PARAGRAPH>Write back and invalidate the data cache for a given 
range of virtual addresses. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>flushbus(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>systm.h &amp; 
types.h </PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="207"><PARAGRAPH>Make sure contents of the write buffer are flushed 
to the system bus. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The functions for cache invalidation are essential when doing DMA on a uniprocessor. They cost very little to use in a multiprocessor, so it does no harm to call them in every system. You call them as follows:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Call <INDEXTARGET ID="09-ddkidabi80"><!-- POSTPROCESSDATA: 09-ddkidabi80|kernel functions:<FUNCTION>dki_dcache_inval()</FUNCTION> --><FUNCTION>dki_dcache_inval()</FUNCTION> prior to doing DMA input. This ensures that when you refer to the received data, it will be loaded from real memory.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Call <INDEXTARGET ID="09-ddkidabi81"><!-- POSTPROCESSDATA: 09-ddkidabi81|kernel functions:<FUNCTION>dki_dcache_wb()</FUNCTION> --><FUNCTION>dki_dcache_wb()</FUNCTION> prior to doing DMA output. This ensures that the latest contents of cache memory are in system memory for the device to load.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Call <FUNCTION>dki_dcache_wbinval()</FUNCTION> prior to a device operation that samples memory and then stores new data.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>In the IP28 CPU you must invalidate the cache both before and after a DMA input; see <XREF IDREF="17413" TYPE="TITLE">&ldquo;Uncached Memory Access in the IP26 and IP28&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>The <INDEXTARGET ID="09-ddkidabi82"><!-- POSTPROCESSDATA: 09-ddkidabi82|kernel functions:<FUNCTION>flushbus()</FUNCTION> --><FUNCTION>flushbus()</FUNCTION> function is needed because in some systems the hardware collects output data and writes it to the bus in blocks. When you write a small amount of data to a device through PIO, delay, then write again, the writes could be batched and sent to the device in quick succession. Use <FUNCTION>flushbus()</FUNCTION> after PIO output when it is followed by PIO input from the same device. Use it also between any two PIO outputs when the device is supposed to see a delay between outputs.&space;</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="54173">Testing Device Physical Addresses</TITLE><PARAGRAPH>A family of functions, summarized in <INDEXTARGET ID="09-ddkidabi83"><!-- POSTPROCESSDATA: 09-ddkidabi83|kernel functions:<FUNCTION>badaddr()</FUNCTION> --><XREF IDREF="65285" TYPE="TABLE">Table&nbsp;8-19</XREF>, is used to test a physical address to find out if it represents a usable device register. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-19"><PREFIX>Table 8-19 </PREFIX><XREFTARGET ID="65285"> <EMPHASIS>(continued)        </EMPHASIS>Functions to Test Physical Addresses</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="108"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="201"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>badaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>systm.h </PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="201"><PARAGRAPH>Test physical address for input. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>badaddr_val(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>systm.h </PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="201"><PARAGRAPH>Test physical address for input and return the 
input value received. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>wbadaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>systm.h </PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="201"><PARAGRAPH>Test physical address for output. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>wbadaddr_val(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>systm.h </PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="201"><PARAGRAPH>Test physical address for output of specific value. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_badaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="201"><PARAGRAPH>Test physical address for input through a map. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_badaddr_val(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="201"><PARAGRAPH>Test physical address for input through a map 
and return the input value received. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_wbadaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="201"><PARAGRAPH>Test physical address through a map for output. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_wbadaddr_val(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="201"><PARAGRAPH>Test physical address through a map for output of 
specific value. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The functions return a nonzero value when the address is bad, that is, unusable. These functions are normally used in the <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> entry point to verify the bus address values passed in from a VECTOR statement. They are only usable with VME devices.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="50960">Hardware Graph Management</TITLE><PARAGRAPH>A driver is concerned about the hardware graph in two different contexts:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>When called at an operational entry point such as <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>write()</FUNCTION>, or <VARIABLE>pfx</VARIABLE><FUNCTION>map()</FUNCTION>, the driver gets information about the device from the hwgraph.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>When called to initialize a device at <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> or <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION>, the driver extends the hwgraph with vertexes to represent the device, and stores device and inventory information in the hwgraph.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The hwgraph concepts and terms are covered under <XREF IDREF="45843" TYPE="TITLE">&ldquo;Hardware Graph Features&rdquo;</XREF>. You should also read the <REFPAGE>hwgraph(4)</REFPAGE> and <REFPAGE>hwgraph_intro(d4x)</REFPAGE> reference pages.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="70160">Interrogating the hwgraph</TITLE><PARAGRAPH>When a driver is called at an operational entry point, the first argument is always a <VARIABLE>dev_t</VARIABLE>. This value stands for the specific device on which the driver should work. In older versions of IRIX, the <VARIABLE>dev_t</VARIABLE> was an integer encoding the major and minor device numbers. In current IRIX, the device is opened through a path in <FILENAME>/hw</FILENAME> (or a symbolic link to <FILENAME>/hw</FILENAME>), and the <VARIABLE>dev_t</VARIABLE> is a handle to a vertex of the hwgraph&mdash;usually a vertex created by the device driver. The <VARIABLE>dev_t</VARIABLE> is used as input to the functions summarized in <XREF IDREF="80156" TYPE="TABLE">Table&nbsp;8-20</XREF>.</PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-20"><PREFIX>Table 8-20 </PREFIX><XREFTARGET ID="80156"> <EMPHASIS>(continued)        </EMPHASIS>Functions to Query the Hardware Graph</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="144"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="54"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="189"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH>device_info_get() 
(<REFPAGE>hwgraph.dev(d3x)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="54"><PARAGRAPH>hwgraph.h </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="189"><PARAGRAPH>Return device info pointer stored in vertex. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH>device_inventory_get_next() 
(<REFPAGE>hwgraph.inv(d3x)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="54"><PARAGRAPH>hwgraph.h </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="189"><PARAGRAPH>Retrieve <VARIABLE>inventory_t</VARIABLE> structures that have been 
attached to a vertex. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH>device_controller_num_get() 
(<REFPAGE>hwgraph.inv(d3x)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="54"><PARAGRAPH>hwgraph.h </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="189"><PARAGRAPH>Retrieve the Controller field of the first or only 
<VARIABLE>inventory_t</VARIABLE> structure in a vertex. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH>hwgraph_edge_get() 
(<REFPAGE>hwgraph.edge(d3x)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="54"><PARAGRAPH>hwgraph.h </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="189"><PARAGRAPH>Follow an edge by name to a destination 
vertex. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH>hwgraph_traverse() </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="54"><PARAGRAPH>hwgraph.h </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="189"><PARAGRAPH>Follow a path from a starting vertex to its 
destination. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>When initializing the device, the driver stores the address of a device information structure in the vertex using <INDEXTARGET ID="09-ddkidabi84"><!-- POSTPROCESSDATA: 09-ddkidabi84|kernel functions:<FUNCTION>device_info_get()</FUNCTION> --><FUNCTION>device_info_set()</FUNCTION> (see <XREF IDREF="61268" TYPE="TITLE">&ldquo;Allocating Storage for Device Information&rdquo;</XREF>). This address can be retrieved using <FUNCTION>device_info_get()</FUNCTION>. Typical code at the beginning of any entry point resembles <XREF IDREF="24751" TYPE="TEXT">Example&nbsp;8-1</XREF>.</PARAGRAPH>
<CODE><CAPTION LBL="8-1"><PREFIX>Example 8-1 </PREFIX><XREFTARGET ID="24751">Typical Code to Get Device Info</CAPTION>typedef struct devInfo_s {
... fields of data unique to one device ...
} devInfo_t;
pfx_entry(dev_t dev,...)
&nbsp;&nbsp;&nbsp;devInfo_t *pdi = device_info_get(dev);
&nbsp;&nbsp;&nbsp;if (!pdi) return ENODEV;
&nbsp;&nbsp;&nbsp;MUTEX_LOCK(pdi->devLock); /* get exclusive use */
...
</CODE>
<PARAGRAPH>When the driver creates the vertexes for a device, the driver can attach inventory information. This can be read out later using <INDEXTARGET ID="09-ddkidabi85"><!-- POSTPROCESSDATA: 09-ddkidabi85|kernel functions:<FUNCTION>device_inventory_get_next()</FUNCTION> --><FUNCTION>device_inventory_get_next()</FUNCTION>.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="65256">Extending the hwgraph</TITLE><PARAGRAPH>When a driver is called at the <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> entry point, it receives a vertex handle for the point at which its device is connected to the system&mdash;for example, a vertex that represents a bus slot. When a driver is called at the <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> entry point, it receives an <VARIABLE>edt_t</VARIABLE> from which it can extract a vertex handle that again represents the point at which this device is attached to the system (refer to <XREF IDREF="34212" TYPE="TITLE">&ldquo;VME Device Naming&rdquo;</XREF>, <XREF IDREF="54429" TYPE="TITLE">&ldquo;Entry Point attach()&rdquo;</XREF> and <XREF IDREF="14072" TYPE="TITLE">&ldquo;Entry Point edtinit()&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>At these times, the driver has the responsibility of extending the hwgraph with at least one edge and vertex to provide access to this device. The label of the edge supplies a visible name that a user process can open. The vertex contains the inventory data and the driver's own device information. Often the driver needs to add multiple vertexes and edges. (For an example of how a Silicon Graphics driver extends the hwgraph, see <XREF IDREF="48208" TYPE="TITLE">&ldquo;SCSI Devices in the hwgraph&rdquo;</XREF>.)</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="12806">Construction Functions</TITLE><PARAGRAPH>The basic functions for constructing edges and vertexes are summarized in <XREF IDREF="40449" TYPE="TABLE">Table&nbsp;8-21</XREF>. The most commonly-used are <FUNCTION>hwgraph_char_device_add()</FUNCTION> and <FUNCTION>hwgraph_block_device_add()</FUNCTION>, functions that create leaf vertexes that users can open. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-21"><PREFIX>Table 8-21 </PREFIX><XREFTARGET ID="40449"> <EMPHASIS>(continued)        </EMPHASIS>Functions to Construct Edges and Vertexes</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="144"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="54"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="189"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH>device_info_set() 
(<REFPAGE>hwgraph.dev(d3x)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="54"><PARAGRAPH>hwgraph.h </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="189"><PARAGRAPH>Store the address of device information in a 
vertex. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH>device_inventory_add() 
(<REFPAGE>hwgraph.inv(d3x)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="54"><PARAGRAPH>invent.h </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="189"><PARAGRAPH>Add hardware inventory data to a vertex. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH>hwgraph_char_device_add() 
(<REFPAGE>hwgraph.dev(d3x)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="54"><PARAGRAPH>hwgraph.h </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="189"><PARAGRAPH>Create a character device special file under a 
specified vertex. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH>hwgraph_block_device_add() 
(<REFPAGE>hwgraph.dev(d3x)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="54"><PARAGRAPH>hwgraph.h </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="189"><PARAGRAPH>Create block device special file under a 
specified vertex. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH>hwgraph_vertex_create() 
(<REFPAGE>hwgraph.vertex(d3x)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="54"><PARAGRAPH>hwgraph.h </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="189"><PARAGRAPH>Create a new, empty vertex, and return its 
handle. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH>hwgraph_edge_add() 
(<REFPAGE>hwgraph.edge(d3x)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="54"><PARAGRAPH>hwgraph.h </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="189"><PARAGRAPH>Add a labelled edge between two vertexes. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH>hwgraph_edge_remove() 
(<REFPAGE>hwgraph.edge(d3x)</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="54"><PARAGRAPH>hwgraph.h</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="189"><PARAGRAPH>Remove an edge by name from a vertex. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="89525">Extending the Graph With a Single Vertex</TITLE><PARAGRAPH>Suppose the kernel is probing a PCI bus and finds a <FILENAME>veeble</FILENAME> device plugged into slot 2. The kernel knows that a driver with the prefix <FUNCTION>veeble_</FUNCTION> has registered to handle this type of device. The kernel calls <FUNCTION>veeble_attach()</FUNCTION>, passing the handle of the vertex that represents the point of attachment, which might be <FILENAME>/hw/module/1/io/pci/slot/2</FILENAME>.</PARAGRAPH>
<PARAGRAPH>Suppose that a <FILENAME>veeble</FILENAME> device permits only character-mode access and there are no optional modes of use. In this simple case, the driver needs to add only one vertex, a device special file connected by one edge having a label such as &ldquo;veeble.&rdquo; The result will be that the device can be opened under the pathname <FILENAME>/hw/module/1/io/pci/slot/2/veeble</FILENAME>. Parts of the code in <FUNCTION>veeble_attach()</FUNCTION> would resemble <XREF IDREF="77200" TYPE="TEXT">Example&nbsp;8-2</XREF>.</PARAGRAPH>
<CODE><CAPTION LBL="8-2"><PREFIX>Example 8-2 </PREFIX><XREFTARGET ID="77200">Hypothetical Code for a Single Vertex</CAPTION>int veeble_attach(vertex_hdl_t vh)
{
&nbsp;&nbsp;&nbsp;VeebleDevInfoStruct_t * vdis;
&nbsp;&nbsp;&nbsp;vertex_hdl_t vv;
&nbsp;&nbsp;&nbsp;graph_error_t ret;
&nbsp;&nbsp;&nbsp;/* allocate memory for per-device structure */
&nbsp;&nbsp;&nbsp;vdis = kmem_zalloc(sizeof(*vdis),KM_SLEEP); &space;
&nbsp;&nbsp;&nbsp;if (!vdis) return ENOMEM;
&nbsp;&nbsp;&nbsp;/* create device vertex below connect-point */ 
&nbsp;&nbsp;&nbsp;ret = hwgraph_char_device_add(vh, "veeble", "veeble_", &amp;vv);
&nbsp;&nbsp;&nbsp;if (ret != GRAPH_SUCCESS)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ kmem_free(vdis); return ret; } &space;
&nbsp;&nbsp;&nbsp;/* here initialize contents of vdis->information struct */
&nbsp;&nbsp;&nbsp;/* here initialize the device itself */
&nbsp;&nbsp;&nbsp;/* set info struct in the device vertex */
&nbsp;&nbsp;&nbsp;device_info_set(vv,vdis); 
&nbsp;&nbsp;&nbsp;return 0;
} 
<INDEXTARGET ID="09-ddkidabi86"><!-- POSTPROCESSDATA: 09-ddkidabi86|kernel functions:<FUNCTION>kmem_zalloc()</FUNCTION> --><INDEXTARGET ID="09-ddkidabi87"><!-- POSTPROCESSDATA: 09-ddkidabi87|kernel functions:hwgraph_char_device_add() --><INDEXTARGET ID="09-ddkidabi88"><!-- POSTPROCESSDATA: 09-ddkidabi88|kernel functions:<FUNCTION>kmem_free()</FUNCTION> --><INDEXTARGET ID="09-ddkidabi89"><!-- POSTPROCESSDATA: 09-ddkidabi89|kernel functions:<FUNCTION>device_info_set()</FUNCTION> --></CODE>
<PARAGRAPH>In <XREF IDREF="77200" TYPE="TEXT">Example&nbsp;8-2</XREF>, the important variables are: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH><VARIABLE>vh</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="337"><PARAGRAPH>Handle of the connection-point vertex passed to the function as a parameter. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH><VARIABLE>vdis</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="337"><PARAGRAPH>Pointer to a structure of type &ldquo;VeebleDevInfoStruct&rdquo;&mdash;defined by the writer 
of this device driver to suit the application. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH><VARIABLE>vv</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="337"><PARAGRAPH>Handle of the device vertex created by the function. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The steps performed are:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Allocate memory for a device information structure, and terminate with the standard ENOMEM return code if allocation is not possible.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Create a character device vertex, connected to vertex <VARIABLE>vh</VARIABLE> by an edge labelled &ldquo;veeble,&rdquo; storing the handle of the new vertex in <VARIABLE>vv</VARIABLE>. If this fails, free the info structure memory and return the same error.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Initialize the contents of the information structure: for example, initialize locks and flag values, and create PIO and/or DMA maps.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Initialize the device itself. Possibly set up an interrupt handler and an error handler (these operations are specific to the bus and the device).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Set the address of the initialized device information structure into the device vertex.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>An additional step not shown is the storing of hardware inventory information that can be reported by <INDEXTARGET ID="09-ddkidabi90"><!-- POSTPROCESSDATA: 09-ddkidabi90|kernel functions:<FUNCTION>device_inventory_add()</FUNCTION> --><COMMAND>hinv</COMMAND> using <FUNCTION>device_inventory_add()</FUNCTION>.</PARAGRAPH>
<PARAGRAPH>A point to note is that in a multiprocessor system, a user process could try to open the new &ldquo;veeble&rdquo; vertex as soon as (or even before) <FUNCTION>hwgraph_char_device_add()</FUNCTION> returns. This would result in an entry to the <FUNCTION>veeble_open()</FUNCTION> entry point of the driver, concurrent with the continued execution of the <FUNCTION>veeble_attach()</FUNCTION> entry point. However, note the two statements in <XREF IDREF="24751" TYPE="TEXT">Example&nbsp;8-1</XREF>:</PARAGRAPH>
<CODE>
&nbsp;&nbsp;&nbsp;devInfo_t *pdi = device_info_get(dev);
&nbsp;&nbsp;&nbsp;if (!pdi) return ENODEV;
</CODE>
<PARAGRAPH>At any time before <FUNCTION>veeble_attach()</FUNCTION> executes its call to <FUNCTION>device_info_set()</FUNCTION>, a call to <FUNCTION>veeble_open()</FUNCTION> for this vertex returns ENODEV. Needless to say, all the hwgraph functions are multiprocessor-aware and use locking as necessary to avoid race conditions.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Extending the Graph With Multiple Vertexes</TITLE><PARAGRAPH>In a more complicated case, a <FILENAME>vooble</FILENAME> device permits access as a block device or as a character device. The device should be accessible under names <FILENAME>vooble/char</FILENAME> and <FILENAME>vooble/block</FILENAME>. In this case the driver proceeds as follows:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Create a vertex to be the primary representation of the device using <INDEXTARGET ID="09-ddkidabi91"><!-- POSTPROCESSDATA: 09-ddkidabi91|kernel functions:<FUNCTION>hwgraph_vertex_create()</FUNCTION> --><FUNCTION>hwgraph_vertex_create()</FUNCTION>.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Connect this primary vertex to the point of attachment with an edge named &ldquo;vooble&rdquo; using <INDEXTARGET ID="09-ddkidabi92"><!-- POSTPROCESSDATA: 09-ddkidabi92|kernel functions:<FUNCTION>hwgraph_edge_add()</FUNCTION> --><FUNCTION>hwgraph_edge_add()</FUNCTION>.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Add new vertexes, connected by edges &ldquo;block&rdquo; and &ldquo;char&rdquo; to the primary vertex using <INDEXTARGET ID="09-ddkidabi93"><!-- POSTPROCESSDATA: 09-ddkidabi93|kernel functions:<FUNCTION>hwgraph_char_device_add()</FUNCTION> --><INDEXTARGET ID="09-ddkidabi94"><!-- POSTPROCESSDATA: 09-ddkidabi94|kernel functions:<FUNCTION>hwgraph_block_device_add()</FUNCTION> --><FUNCTION>hwgraph_block_device_add()</FUNCTION> and <FUNCTION>hwgraph_char_device_add()</FUNCTION>. </PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>The subordinate block and character vertexes are device special files that can be opened by user code. Handles to these vertexes will be passed in to other driver entry points. There are a variety of ways to store device information in the three vertexes:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Store a pointer to a single information structure in both leaf vertexes.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Create separate &ldquo;block&rdquo; and &ldquo;char&rdquo; information structures and store one in each leaf vertex. Perhaps create a separate structure of information that is common to both block and character access, and point to it from both block and char structures.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>As you plan this arrangement of data structures, bear in mind that the <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> entry point receives a flag telling it whether the open is for block or character access (see <XREF IDREF="86115" TYPE="TITLE">&ldquo;Entry Point open()&rdquo;</XREF>); and that other entry points are called only for block, or only for character, devices.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Vertexes for Modes of Use</TITLE><PARAGRAPH>Possibly the device has multiple modes of use, as for example a tape device has byte-swapped and non-swapped access, fixed-block and variable-block access, and so on. Traditionally these modes of access were encoded in the device minor number as well as in the device name (see <XREF IDREF="40611" TYPE="TITLE">&ldquo;Creating Conventional Device Names&rdquo;</XREF>). Current practice is to create a separate vertex for each mode of use (see <XREF IDREF="15499" TYPE="TITLE">&ldquo;Multiple Device Names&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>When using the hwgraph, you represent each mode of access as a separate name in the <FILENAME>/hw</FILENAME> filesystem. Suppose that a PCI device of type <FILENAME>flipper</FILENAME> supports two modes of use, &ldquo;flipped&rdquo; and &ldquo;flopped.&rdquo; It is the job of the <FUNCTION>flipper_attach()</FUNCTION> entry point to set up hwgraph vertexes so that one device can be opened under different pathnames such as <FILENAME>/hw/module/1/io/pci/slot/2/flipper/flipped</FILENAME> and <FILENAME>/hw/module/1/io/pci/slot/2/flipper/flopped</FILENAME>. The problem is very similar to creating separate block and character vertexes for one device, with the additional problem that the device information stored in each vertex should reflect the desired mode of use, flipped or flopped. The code might resemble in part that shown in <XREF IDREF="17046" TYPE="TEXT">Example&nbsp;8-3</XREF>. </PARAGRAPH>
<CODE><CAPTION LBL="8-3"><PREFIX>Example 8-3 </PREFIX><XREFTARGET ID="17046">Hypothetical Code for Multiple Vertexes</CAPTION>typedef struct flipperDope_s {
&nbsp;&nbsp;&nbsp;vertex_hdl_t floppedMode; /* vertex for flopped */
&nbsp;&nbsp;&nbsp;...many other fields for management of one flipper dev...
} flipperDope_t;
int flipper_attach(vertex_hdl_t connv)
{
&nbsp;&nbsp;&nbsp;flipperDope_t *pfd = NULL;
&nbsp;&nbsp;&nbsp;vertex_hdl_t masterv = GRAPH_VERTEX_NONE;
&nbsp;&nbsp;&nbsp;vertex_hdl_t flippedv = GRAPH_VERTEX_NONE;
&nbsp;&nbsp;&nbsp;vertex_hdl_t floppedv = GRAPH_VERTEX_NONE;
&nbsp;&nbsp;&nbsp;graph_error_t ret = 0;
&nbsp;&nbsp;&nbsp;if (!pfd = kmem_zalloc(sizeof(*pfd),KM_SLEEP)) &space;
&nbsp;&nbsp;&nbsp;{ ret = ENOMEM; goto done; }
&nbsp;&nbsp;&nbsp;ret = hwgraph_vertex_create(&amp;masterv); &space;
&nbsp;&nbsp;&nbsp;if (ret != GRAPH_SUCCESS) goto done;
&nbsp;&nbsp;&nbsp;ret = hwgraph_edge_add(connv,masterv,"flipper"); &space;
&nbsp;&nbsp;&nbsp;if (ret != GRAPH_SUCCESS) goto done;
&nbsp;&nbsp;&nbsp;ret = hwgraph_char_device_add(masterv, "flipped", "flipper_", &amp;flippedv); &space;
&nbsp;&nbsp;&nbsp;if (ret != GRAPH_SUCCESS) goto done;
&nbsp;&nbsp;&nbsp;ret = hwgraph_char_device_add(masterv, "flopped", "flipper_", &amp;floppedv);
&nbsp;&nbsp;&nbsp;if (ret != GRAPH_SUCCESS) goto done;
&nbsp;&nbsp;&nbsp;pfd->floppedMode = floppedv; /* note which vertex is "flopped" */
...here initialize other fields of pfd->flipperDope...
&nbsp;&nbsp;&nbsp;device_info_set(flippedv,pfd);
&nbsp;&nbsp;&nbsp;device_info_set(floppedv,pfd);
done: /* If any error, undo all partial work */
&nbsp;&nbsp;&nbsp;if (ret)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (floppedv != GRAPH_VERTEX_NONE) hwgraph_vertex_destroy(floppedv);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (flippedv != GRAPH_VERTEX_NONE) hwgraph_vertex_destroy(flippedv);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (masterv != GRAPH_VERTEX_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hwgraph_edge_remove(rootv,"flipper",NULL); &space;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hwgraph_vertex_destroy(masterv);&space;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pfd) kmem_free(pfd); &space;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;return ret;
}
<INDEXTARGET ID="09-ddkidabi95"><!-- POSTPROCESSDATA: 09-ddkidabi95|kernel functions:<FUNCTION>kmem_zalloc()</FUNCTION> --><INDEXTARGET ID="09-ddkidabi96"><!-- POSTPROCESSDATA: 09-ddkidabi96|kernel functions:<FUNCTION>hwgraph_vertex_create()</FUNCTION> --><INDEXTARGET ID="09-ddkidabi97"><!-- POSTPROCESSDATA: 09-ddkidabi97|kernel functions:<FUNCTION>hwgraph_edge_add()</FUNCTION> --><INDEXTARGET ID="09-ddkidabi98"><!-- POSTPROCESSDATA: 09-ddkidabi98|kernel functions:<FUNCTION>hwgraph_char_device_add()</FUNCTION> --><INDEXTARGET ID="09-ddkidabi99"><!-- POSTPROCESSDATA: 09-ddkidabi99|kernel functions:<FUNCTION>hwgraph_edge_remove()</FUNCTION> --><INDEXTARGET ID="09-ddkidabi100"><!-- POSTPROCESSDATA: 09-ddkidabi100|kernel functions:<FUNCTION>hwgraph_vertex_destroy()</FUNCTION> --><INDEXTARGET ID="09-ddkidabi101"><!-- POSTPROCESSDATA: 09-ddkidabi101|kernel functions:<FUNCTION>kmem_free()</FUNCTION> --></CODE>
<PARAGRAPH>After successful completion of <FUNCTION>flipper_attach()</FUNCTION> there are two character special devices with paths <FILENAME>/hw/.../flipper/flipped</FILENAME> and <FILENAME>/hw/.../flipper/flopped</FILENAME>. A pointer to a single device information structure (a <VARIABLE>flipperDope_t</VARIABLE> object) is stored in both vertexes. However, the vertex handle of the <FILENAME>flopped</FILENAME> vertex is saved in the <VARIABLE>floppedMode</VARIABLE> field of the structure. Whenever the device driver is entered, it can retrieve the device information with a statement such as the following:</PARAGRAPH>
<EXAMPLE>
flipperDope_t *pfd = device_info_get(dev);
</EXAMPLE>
<PARAGRAPH>Whenever the driver needs to distinguish between &ldquo;flipped&rdquo; and &ldquo;flopped&rdquo; modes of access, it can do so with code such as the following:</PARAGRAPH>
<CODE>
if (dev == pfd->floppedMode)
{ ...this is flopped-mode...}
else
{ ...this is flipped-mode...}
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Vertexes for User Convenience</TITLE><PARAGRAPH>The driver is allowed to create vertexes and attach them anywhere in the hwgraph. The connection point of a device is often at the end of a long path that is hard for a human to read or type. The driver can use <FUNCTION>hwgraph_vertex_create()</FUNCTION> and <FUNCTION>hwgraph_edge_add()</FUNCTION> to create a shorter, more readable path to any of the leaf vertexes it creates. For example, the hypothetical <VARIABLE>veeble_</VARIABLE> driver of <XREF IDREF="77200" TYPE="TEXT">Example&nbsp;8-2</XREF> might like to make the devices it attaches available via paths like <FILENAME>/hw/veebles/1</FILENAME> and <FILENAME>/hw/veebles/2</FILENAME>.</PARAGRAPH>
<PARAGRAPH>At the time a driver is called to attach a device, the driver has no way to tell how many of these devices exist in the system. Also, recall that the <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> entry point can be called concurrently on multiple CPUs to attach devices in different slots on different buses. The attach code has no basis on which to assign ordinal numbers to devices; that is, no way to know that a particular device is device 1, and another is device 2. These questions cannot be answered until the entire hardware complement has been found and attached.</PARAGRAPH>
<PARAGRAPH>The purpose of the <COMMAND>ioconfig</COMMAND> command is to call drivers one more time, before user processes start but after the hwgraph is complete, so they can create convenience vertexes. This use of <COMMAND>ioconfig</COMMAND> is described under <XREF IDREF="64497" TYPE="TITLE">&ldquo;Device Management File&rdquo;</XREF>. You direct <COMMAND>ioconfig</COMMAND> to assign controller numbers to your devices. After it does so, it opens each device (resulting in the first entry to <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> for that device vertex), and optionally issues an <FUNCTION>ioctl</FUNCTION> against the open device passing a command number you specify. Upon either the first open of a device or in <VARIABLE>pfx</VARIABLE><FUNCTION>ioctl()</FUNCTION>, you can create convenience vertexes that include the assigned controller number of the device to make the names unique.</PARAGRAPH>
<PARAGRAPH>The assigned controller numbers are stable from one boot time to the next, so you can also create symbolic links in <FILENAME>/dev</FILENAME> naming them.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="53606">Attaching Information to Vertexes</TITLE><PARAGRAPH>The driver can attach several kinds of information to any vertex it creates:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Device information defined by the driver itself.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Hardware inventory information to be used by <COMMAND>hinv</COMMAND>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Labelled attribute values.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The driver can also retrieve information that was set in the hwgraph by the administrator.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="29254">Attaching Device Information</TITLE><PARAGRAPH>The use of <FUNCTION>device_info_set()</FUNCTION> is discussed under two other topics: <XREF IDREF="61268" TYPE="TITLE">&ldquo;Allocating Storage for Device Information&rdquo;</XREF> and <XREF IDREF="89525" TYPE="TITLE">&ldquo;Extending the Graph With a Single Vertex&rdquo;</XREF>. Every device needs such an information structure&mdash;if for no other reason than to contain a lock used to ensure that each upper-half entry point has exclusive use of the device.</PARAGRAPH>
<PARAGRAPH>When the driver creates multiple vertexes for a particular device, the driver can store the same address in every vertex (as shown in <XREF IDREF="77200" TYPE="TEXT">Example&nbsp;8-2</XREF> and <XREF IDREF="17046" TYPE="TEXT">Example&nbsp;8-3</XREF>). Yet another design option is to have each vertex contain the address of a small structure containing optional information unique to that view of the device, and a pointer to a single common structure for the device.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="92258">Attaching Inventory Information</TITLE><PARAGRAPH>The <INDEXTARGET ID="09-ddkidabi102"><!-- POSTPROCESSDATA: 09-ddkidabi102|kernel functions:<FUNCTION>device_inventory_add()</FUNCTION> --><FUNCTION>device_inventory_add()</FUNCTION> function stores the fields of one <VARIABLE>inventory_t</VARIABLE> record in a vertex. The driver can store multiple <VARIABLE>inventory_t</VARIABLE> records in a single vertex, but it is customary to store only one. There is no facility to delete an inventory record from a vertex.</PARAGRAPH>
<PARAGRAPH>The <INDEXTARGET ID="09-ddkidabi103"><!-- POSTPROCESSDATA: 09-ddkidabi103|kernel functions:<FUNCTION>hwgraph_inventory_get_next()</FUNCTION> --><FUNCTION>device_inventory_get_next()</FUNCTION> function is used to read out each of the <VARIABLE>inventory_t</VARIABLE> structures in turn. Normally the driver does not have any reason to inspect these. However, the function does not return a copy of the structure; it returns the address of the actual structure in the vertex. The fields of the structure can be modified by the driver.</PARAGRAPH>
<PARAGRAPH>One field of the <INDEXTARGET ID="09-ddkidabi104"><!-- POSTPROCESSDATA: 09-ddkidabi104|kernel functions:<FUNCTION>device_controller_number_get()</FUNCTION> --><VARIABLE>inventory_t</VARIABLE> is particularly important: the controller number is conventionally used to provide ordinal numbering of similar devices. The <FUNCTION>device_controller_number_get()</FUNCTION> function returns the controller number from the first (and usually the only) <VARIABLE>inventory_t</VARIABLE> structure in a vertex. It fails if there is no inventory data in the vertex.</PARAGRAPH>
<PARAGRAPH>When the driver can assign an ordinal numbering to multiple devices, it should record that numbering by setting unique controller numbers in each master vertex for the similar devices. This can be done most easily by calling <INDEXTARGET ID="09-ddkidabi105"><!-- POSTPROCESSDATA: 09-ddkidabi105|kernel functions:<FUNCTION>device_controller_number_set()</FUNCTION> --><FUNCTION>device_controller_number_set()</FUNCTION>. Typically this would be done in an ioctl call from the application that has determined a stable, global numbering of devices (see <XREF IDREF="64497" TYPE="TITLE">&ldquo;Device Management File&rdquo;</XREF>).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="47480">Attaching Attributes</TITLE><PARAGRAPH>A file attribute is an arbitrary block of information associated with a file inode. Attributes were introduced with the XFS filesystem (see the <REFPAGE>attr(1)</REFPAGE> and <REFPAGE>attr_get(2)</REFPAGE> reference pages), but the <FILENAME>/hw</FILENAME> filesystem also supports them. You can store file attributes in hwgraph vertexes, and they can be retrieved by user processes.</PARAGRAPH>
<PARAGRAPH>The functions that a driver uses to manage attributes are summarized in <INDEXTARGET ID="09-ddkidabi106"><!-- POSTPROCESSDATA: 09-ddkidabi106|kernel functions:<FUNCTION>hwgraph_info_add_LBL()</FUNCTION> --><INDEXTARGET ID="09-ddkidabi107"><!-- POSTPROCESSDATA: 09-ddkidabi107|kernel functions:<FUNCTION>hwgraph_info_get_LBL()</FUNCTION> --><INDEXTARGET ID="09-ddkidabi108"><!-- POSTPROCESSDATA: 09-ddkidabi108|kernel functions:<FUNCTION>hwgraph_info_replace_LBL()</FUNCTION> --><INDEXTARGET ID="09-ddkidabi109"><!-- POSTPROCESSDATA: 09-ddkidabi109|kernel functions:<FUNCTION>hwgraph_info_remove_LBL()</FUNCTION> --><INDEXTARGET ID="09-ddkidabi110"><!-- POSTPROCESSDATA: 09-ddkidabi110|kernel functions:<FUNCTION>hwgraph_info_export_LBL()</FUNCTION> --><INDEXTARGET ID="09-ddkidabi111"><!-- POSTPROCESSDATA: 09-ddkidabi111|kernel functions:<FUNCTION>hwgraph_info_unexport_LBL()</FUNCTION> --><XREF IDREF="65918" TYPE="TABLE">Table&nbsp;8-22</XREF> (all are detailed in the reference page <REFPAGE>hwgraph.lblinfo(d3x)</REFPAGE>). </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-22"><PREFIX>Table 8-22 </PREFIX><XREFTARGET ID="65918"> <EMPHASIS>(continued)        </EMPHASIS>Functions to Manage Attributes</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="158"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="54"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="225" WIDTH="174"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="158"><PARAGRAPH>hwgraph_info_add_LBL() </PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="54"><PARAGRAPH>hwgraph.h</PARAGRAPH>
</CELL>
<CELL LEFT="225" WIDTH="174"><PARAGRAPH>Attach a labelled attribute to a vertex. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="158"><PARAGRAPH>hwgraph_info_get_LBL() </PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="54"><PARAGRAPH>hwgraph.h</PARAGRAPH>
</CELL>
<CELL LEFT="225" WIDTH="174"><PARAGRAPH>Retrieve an attribute by name. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="158"><PARAGRAPH>hwgraph_info_replace_LBL() </PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="54"><PARAGRAPH>hwgraph.h</PARAGRAPH>
</CELL>
<CELL LEFT="225" WIDTH="174"><PARAGRAPH>Replace the value of an attribute by name. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="158"><PARAGRAPH>hwgraph_info_remove_LBL() </PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="54"><PARAGRAPH>hwgraph.h</PARAGRAPH>
</CELL>
<CELL LEFT="225" WIDTH="174"><PARAGRAPH>Remove an attribute from a vertex. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="158"><PARAGRAPH>hwgraph_info_export_LBL() </PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="54"><PARAGRAPH>hwgraph.h</PARAGRAPH>
</CELL>
<CELL LEFT="225" WIDTH="174"><PARAGRAPH>Make an attribute visible to user code. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="158"><PARAGRAPH>hwgraph_info_unexport_LBL() </PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="54"><PARAGRAPH>hwgraph.h</PARAGRAPH>
</CELL>
<CELL LEFT="225" WIDTH="174"><PARAGRAPH>Make an attribute invisible. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>An attribute consists of a name (a character string), a pointer-sized integer, and a length. When the length is zero, the attribute is &ldquo;unexported,&rdquo; that is, not visible to the <COMMAND>attr</COMMAND> command nor to the <FUNCTION>attr_get()</FUNCTION> function. All attributes are initially unexported. An unexported attribute can be retrieved by a driver, but not by a user process.</PARAGRAPH>
<PARAGRAPH>The value of an attribute is just a pointer; it can be an integer, a vertex handle, or an address of any kind of information. You can use attributes to hold any kind of information you want to associate with a vertex. (For one example, you could use an attribute to contain mode-bits that determine how a device should be treated.)</PARAGRAPH>
<PARAGRAPH>Attribute storage is not sophisticated. Attribute names are stored sequentially in a string table that is part of the vertex, and looked up in a sequential search. The attribute scheme is meant for convenient storage of a few attributes per vertex, each having a short name.</PARAGRAPH>
<PARAGRAPH>When you export an attribute, you assert that the value of the attribute is a valid address in kernel virtual memory, and the export length is its correct length. The <FUNCTION>attr_get()</FUNCTION> function relies on these points. A user process can retrieve a copy of an attribute by calling <FUNCTION>attr_get()</FUNCTION>. The attribute value is copied from the kernel address space to the user address space. This is a convenient route by which you can export driver internal data to user processes, without the complexity of memory mapping or ioctl calls.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="57823">Retrieving Administrator Attributes</TITLE><PARAGRAPH>The system administrator can use the DEVICE_ADMIN statement to attach a labelled attribute to any device special file in the hwgraph, and can use DRIVER_ADMIN to store a labelled attribute for the driver (see <XREF IDREF="58068" TYPE="TITLE">&ldquo;Storing Device and Driver Attributes&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>These statements are processed at boot time. At this time, the driver might not be loaded, and the device special file might not have been created in the hwgraph. However, the attributes are saved. When a driver creates a hwgraph vertex that is the target of a DEVICE_ADMIN statement, the labelled attributes are attached to the vertex automatically.</PARAGRAPH>
<PARAGRAPH>Your driver can request an administrator attribute for a specific device using <INDEXTARGET ID="09-ddkidabi112"><!-- POSTPROCESSDATA: 09-ddkidabi112|kernel functions:<FUNCTION>device_admin_info_get()</FUNCTION> --><INDEXTARGET ID="09-ddkidabi113"><!-- POSTPROCESSDATA: 09-ddkidabi113|kernel functions:<FUNCTION>hwgraph_info_get_LBL()</FUNCTION> --><FUNCTION>hwgraph_info_get_LBL()</FUNCTION> directly, as described above under <XREF IDREF="47480" TYPE="TITLE">&ldquo;Attaching Attributes&rdquo;</XREF>. Or you can call <FUNCTION>device_admin_info_get()</FUNCTION> (see the reference page <REFPAGE>hwgraph.admin(d3x)</REFPAGE>). The returned value is the address of a read-only copy of the value string.</PARAGRAPH>
<PARAGRAPH>Your driver can request an attribute that was addressed to the driver with DRIVER_ADMIN using <INDEXTARGET ID="09-ddkidabi114"><!-- POSTPROCESSDATA: 09-ddkidabi114|kernel functions:<FUNCTION>device_driver_admin_info_get()</FUNCTION> --><FUNCTION>device_driver_admin_info_get()</FUNCTION>. The returned value is the address of a read-only copy of the value string from the DRIVER_ADMIN statement.</PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="35201">User Process Administration</TITLE><PARAGRAPH>The kernel supplies a small group of functions, summarized in <INDEXTARGET ID="09-ddkidabi115"><!-- POSTPROCESSDATA: 09-ddkidabi115|process --><INDEXTARGET ID="09-ddkidabi116"><!-- POSTPROCESSDATA: 09-ddkidabi116|driver:process context --><XREF IDREF="60651" TYPE="TABLE">Table&nbsp;8-23</XREF>, that help a driver upper-half routine learn about the current user process. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-23"><PREFIX>Table 8-23 </PREFIX><XREFTARGET ID="60651"> <EMPHASIS>(continued)        </EMPHASIS>Functions for User Process Management</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="81"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="63"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>drv_getparm(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="63"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Retrieve kernel state information. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>drv_priv(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="63"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Test for privileged user. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>drv_setparm(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="63"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Set kernel state information. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>proc_ref(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="63"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Obtain a reference to a process for signaling. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>proc_signal(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="63"><PARAGRAPH>ddi.h &amp; 
signal.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Send a signal to a process. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>proc_unref(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="63"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="243"><PARAGRAPH>Release a reference to a process. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<NOTE><PREFIX>Note</PREFIX>When porting an older driver, you may find direct reference to a user structure. That is no longer available. Any reference to a user structure should be eliminated or replaced by one of the functions in <XREF IDREF="60651" TYPE="TABLE">Table&nbsp;8-23</XREF>.</NOTE>
<PARAGRAPH>Use <INDEXTARGET ID="09-ddkidabi117"><!-- POSTPROCESSDATA: 09-ddkidabi117|kernel functions:<FUNCTION>drv_getparm()</FUNCTION> --><FUNCTION>drv_getparm()</FUNCTION> to retrieve certain miscellaneous bits of information including the process ID of the current process. In a character device driver, the current process is the user process that caused entry to the driver, for example by calling the <FUNCTION>open()</FUNCTION>, <FUNCTION>ioctl()</FUNCTION>, or <FUNCTION>read()</FUNCTION> system functions. In a block device driver, the current process has no direct relationship to any particular user; it is usually a daemon process of some kind.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>drv_setparm()</FUNCTION> function is primarily of use to terminal drivers.</PARAGRAPH>
<PARAGRAPH>The <INDEXTARGET ID="09-ddkidabi118"><!-- POSTPROCESSDATA: 09-ddkidabi118|privilege checking --><INDEXTARGET ID="09-ddkidabi119"><!-- POSTPROCESSDATA: 09-ddkidabi119|data types:<VARIABLE>cred_t</VARIABLE> --><INDEXTARGET ID="09-ddkidabi120"><!-- POSTPROCESSDATA: 09-ddkidabi120|kernel functions:<FUNCTION>drv_priv()</FUNCTION> --><FUNCTION>drv_priv()</FUNCTION> function tests a <VARIABLE>cred_t</VARIABLE> object to see if it represents a privileged user. A <VARIABLE>cred_t</VARIABLE> object is passed in to several driver entry points, and the address of the current one can be retrieved <FUNCTION>drv_getparm()</FUNCTION>.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="66916">Sending a Process Signal</TITLE><PARAGRAPH>In traditional UNIX kernels, a device driver identified the current user process by the address of the <INDEXTARGET ID="09-ddkidabi121"><!-- POSTPROCESSDATA: 09-ddkidabi121|data types:<VARIABLE>proc_t </VARIABLE>(not available) --><INDEXTARGET ID="09-ddkidabi122"><!-- POSTPROCESSDATA: 09-ddkidabi122|signal --><VARIABLE>proc_t</VARIABLE> structure that the kernel uses to represent a process. Direct use of the <VARIABLE>proc_t</VARIABLE> is no longer supported by IRIX. The reason is that the contents of the <VARIABLE>proc_t</VARIABLE> change from release to release, and also differ between 64-bit and 32-bit kernels.</PARAGRAPH>
<PARAGRAPH>The most common use of the <VARIABLE>proc_t</VARIABLE> by a driver was to send a signal to the process. This capability is still supported. To do it, take three steps:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Call <INDEXTARGET ID="09-ddkidabi123"><!-- POSTPROCESSDATA: 09-ddkidabi123|process:handle of --><FUNCTION>proc_ref()</FUNCTION> to get a process handle, a number unique to the current process. The returned value must be treated as an arbitrary number (in some releases of IRIX it was the <VARIABLE>proc_t</VARIABLE> address, but this is not the defined behavior of the function).</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Use the process handle as an argument to <INDEXTARGET ID="09-ddkidabi124"><!-- POSTPROCESSDATA: 09-ddkidabi124|process:sending signal to --><FUNCTION>proc_signal()</FUNCTION>, sending the signal to the process.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Release the process handle by calling <FUNCTION>proc_unref()</FUNCTION>.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>The third step is important. In order to keep the process handle valid, IRIX retains information about the process to which it is related. However, that process could terminate (possibly as a result of the signal the driver sends) but until the driver announces that it is done with the handle, the kernel must try to retain process information.</PARAGRAPH>
<PARAGRAPH>It is especially important to release a process handles before unloading a loadable driver (see <XREF IDREF="57773" TYPE="TITLE">&ldquo;Entry Point unload()&rdquo;</XREF>). </PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="14643"><XREFTARGET ID="51251">Waiting and Mutual Exclusion</TITLE><PARAGRAPH>The kernel supplies a rich variety of functions for waiting and for mutual exclusion. In order to use these features well, you must understand the different purposes for which they are designed. In particular, you must clearly understand the distinction between <ITALICS>waiting </ITALICS>and <ITALICS>mutual exclusion </ITALICS>(or locking). </PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="41977">Mutual Exclusion Compared to Waiting</TITLE><PARAGRAPH><INDEXTARGET ID="09-ddkidabi125"><!-- POSTPROCESSDATA: 09-ddkidabi125|mutual exclusion --><ITALICS>Mutual exclusion </ITALICS>allows one entity to have exclusive use of a global resource, temporarily denying use of the resource to other entities. Mutual exclusion normally does not require waiting when software is carefully designed&mdash;the resource is normally free when it is requested. A driver that calls a mutual exclusion function <ITALICS>expects to proceed</ITALICS> without delay&mdash;although there is a chance that the resource is in use, and the driver will have to wait.</PARAGRAPH>
<PARAGRAPH>The kernel offers an array of functions for mutual exclusion, and the choice among them can be critical to performance. The functions are reviewed in the following topics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="59834" TYPE="TITLE">&ldquo;Basic Locks&rdquo;</XREF> covers basic locks, once required by device drivers, and useful in multiprocessors.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="74796" TYPE="TITLE">&ldquo;Long-Term Locks&rdquo;</XREF> covers sleep locks, which can be held for longer periods.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="50612" TYPE="TITLE">&ldquo;Reader/Writer Locks&rdquo;</XREF> covers a class of locks that allow multiple, concurrent, read-only access to resources that are infrequently changed.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="75168" TYPE="TITLE">&ldquo;Priority Level Functions&rdquo;</XREF> discusses the traditional UNIX method of mutual exclusion, now obsolete and dangerous.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH><INDEXTARGET ID="09-ddkidabi126"><!-- POSTPROCESSDATA: 09-ddkidabi126|waiting --><ITALICS>Waiting</ITALICS> allows a driver to coordinate its actions with a specific event or action that occurs asynchronously. A driver can wait for a specified amount of time to pass, wait for an I/O action to complete, and so on. When a driver calls a waiting function, <ITALICS>it expects to wait</ITALICS> for something to happen&mdash;although there is a chance that the expected event has already happened, and the driver will be able to continue at once.</PARAGRAPH>
<PARAGRAPH>The kernel offers several functions that allow you to wait for specific events; and also offers functions for general synchronization. These are covered in the following topics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="56199" TYPE="TITLE">&ldquo;Waiting for Time to Pass&rdquo;</XREF> covers timer-related functions.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="14842" TYPE="TITLE">&ldquo;Waiting for Memory to Become Available&rdquo;</XREF> covers memory allocation waits.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="78884" TYPE="TITLE">&ldquo;Waiting for Block I/O to Complete&rdquo;</XREF> covers waits used in the <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> entry point.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="59737" TYPE="TITLE">&ldquo;Waiting for a General Event&rdquo;</XREF> covers the general-purpose functions that you can adapt to any synchronization problem.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The most general facility, the semaphore, can be used for synchronization and for locking. This topic is covered under <XREF IDREF="42679" TYPE="TITLE">&ldquo;Semaphores&rdquo;</XREF>.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="59834">Basic Locks</TITLE><PARAGRAPH>IRIX supports basic locks using functions compatible with SVR4. These functions are summarized in <INDEXTARGET ID="09-ddkidabi127"><!-- POSTPROCESSDATA: 09-ddkidabi127|mutual exclusion --><XREF IDREF="43930" TYPE="TABLE">Table&nbsp;8-24</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-24"><PREFIX>Table 8-24 </PREFIX><XREFTARGET ID="43930"> <EMPHASIS>(continued)        </EMPHASIS>Functions for Basic Locks</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="99"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="63"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="225"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>LOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="63"><PARAGRAPH>ksynch.h &amp; 
types.h </PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="225"><PARAGRAPH>Acquire a basic lock, waiting if necessary. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>LOCK_ALLOC(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="63"><PARAGRAPH>ksynch.h,kme
m.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="225"><PARAGRAPH>Allocate and initialize a basic lock. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>LOCK_DEALLOC(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="63"><PARAGRAPH>ksynch.h &amp; 
types.h </PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="225"><PARAGRAPH>Deallocate an instance of a basic lock. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>LOCK_INIT(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="63"><PARAGRAPH>ksynch.h &amp; 
types.h </PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="225"><PARAGRAPH>Initialize a basic lock that was allocated statically, or 
reinitialize an allocated lock. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>LOCK_DESTROY(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="63"><PARAGRAPH>ksynch.h &amp; 
types.h </PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="225"><PARAGRAPH>Uninitialize a basic lock that was allocated statically. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>TRYLOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="63"><PARAGRAPH>types.h &amp; 
ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="225"><PARAGRAPH>Try to acquire a basic lock, returning a code if the lock is 
not currently free. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>UNLOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="63"><PARAGRAPH>types.h &amp; 
ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="225"><PARAGRAPH>Release a basic lock. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Basic locks are objects of type <INDEXTARGET ID="09-ddkidabi128"><!-- POSTPROCESSDATA: 09-ddkidabi128|mutual exclusion:basic locks --><INDEXTARGET ID="09-ddkidabi129"><!-- POSTPROCESSDATA: 09-ddkidabi129|data types:<VARIABLE>lock_t</VARIABLE> --><VARIABLE>lock_t</VARIABLE>. Although functions are provided for allocating and freeing them, a basic lock is a very small object. Locks are typically allocated as fields of structures or as global variables.</PARAGRAPH>
<PARAGRAPH>Call LOCK<FUNCTION>()</FUNCTION> to seize a lock and gain possession of the resource for which it stands. Release the lock with UNLOCK<FUNCTION>()</FUNCTION>. These functions are optimized for mutual exclusion in the available hardware, and may be implemented differently in uniprocessors and multiprocessors. However, the programming and binary interface is the same in all systems.</PARAGRAPH>
<PARAGRAPH>Basic locks are implemented as spinning locks in multiprocessors. In releases before IRIX       6.4, the basic lock was the only kind of lock that you could use for mutual exclusion between the upper half of a driver and its interrupt handler (because the interrupt handler could not sleep). Now, interrupt handlers run as threads and can sleep, so you have a choice between basic locks and mutex locks for this purpose.</PARAGRAPH>
<PARAGRAPH>The code in <XREF IDREF="18439" TYPE="TEXT">Example&nbsp;8-4</XREF> illustrates the use of LOCK and UNLOCK in implementing a simple last-in-first-out (LIFO) queueing package. In these functions, the time between locking a queue head and releasing it is only a few microseconds. </PARAGRAPH>
<CODE><CAPTION LBL="8-4"><PREFIX>Example 8-4 </PREFIX><XREFTARGET ID="18439">LIFO Queue Using Basic Locks</CAPTION>typedef struct qitem {
&nbsp;&nbsp;&nbsp;qitem *next; ...other fields...
} qitem_t;
typedef struct lifo {
&nbsp;&nbsp;&nbsp;qitem *latest;
&nbsp;&nbsp;&nbsp;lock_t grab;
} lifo_t;
void putlifo(lifo_t *q, qitem_t *i)
{
&nbsp;&nbsp;&nbsp;int lockpl = LOCK(&amp;q->grab,plhi);
&nbsp;&nbsp;&nbsp;i->next = q->latest;
&nbsp;&nbsp;&nbsp;q->latest = i;
&nbsp;&nbsp;&nbsp;UNLOCK(&amp;q->grab,lockpl);
}
qitem_t *poplifo(lifo_t *q)
{
&nbsp;&nbsp;&nbsp;int lockpl = LOCK(&amp;q->grab,plhi);
&nbsp;&nbsp;&nbsp;qitem_t *ret = q->latest;
&nbsp;&nbsp;&nbsp;q->latest = ret->next;
&nbsp;&nbsp;&nbsp;UNLOCK(&amp;q->grab,lockpl);
&nbsp;&nbsp;&nbsp;return ret;
}
</CODE>
<PARAGRAPH>This is a typical use of basic locks: to ensure that for a brief period, only one thread in the system can update a queue. Basic locks are optimized for such uses. If they are used in situations where they can be held for significant lengths of time (100 microseconds or longer), system performance can suffer, because one or more CPUs can be &ldquo;spinning&rdquo; on the locks and this can delay useful processing.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="74796">Long-Term Locks</TITLE><PARAGRAPH>IRIX provides three types of locks that can suspend the caller when the lock is claimed: mutex locks, sleep locks, and reader-writer locks. Of these, mutex locks are preferred.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="29043">Using Mutex Locks</TITLE><PARAGRAPH>As their name suggests, mutex locks are designed for mutual exclusion. The IRIX implementation of mutex locks is compatible with the <INDEXTARGET ID="09-ddkidabi130"><!-- POSTPROCESSDATA: 09-ddkidabi130|mutual exclusion:mutex locks --><INDEXTARGET ID="09-ddkidabi131"><!-- POSTPROCESSDATA: 09-ddkidabi131|mutex locks --><VARIABLE>kmutex_t</VARIABLE> lock type of SunOS, but optimized for use in Silicon Graphics hardware systems. The mutex functions are summarized in <XREF IDREF="69850" TYPE="TABLE">Table&nbsp;8-25</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-25"><PREFIX>Table 8-25 </PREFIX><XREFTARGET ID="69850"> <EMPHASIS>(continued)        </EMPHASIS>Functions for Mutex Locks</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="113"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="135"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="138"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="113"><PARAGRAPH><REFPAGE>MUTEX_ALLOC(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="135"><PARAGRAPH>types.h &amp; kmem.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="138"><PARAGRAPH>Allocate and initialize a mutex 
lock. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="113"><PARAGRAPH><REFPAGE>MUTEX_INIT(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="135"><PARAGRAPH>types.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="138"><PARAGRAPH>Initialize an existing mutex lock. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="113"><PARAGRAPH><REFPAGE>MUTEX_DESTROY(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="135"><PARAGRAPH>types.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="138"><PARAGRAPH>Deinitialize a mutex lock. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="113"><PARAGRAPH><REFPAGE>MUTEX_DEALLOC(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="135"><PARAGRAPH>types.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="138"><PARAGRAPH>Deinitialize and free a 
dynamically allocated mutex 
lock. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="113"><PARAGRAPH><REFPAGE>MUTEX_LOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="135"><PARAGRAPH>types.h &amp; kmem.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="138"><PARAGRAPH>Claim a mutex lock. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="113"><PARAGRAPH><REFPAGE>MUTEX_TRYLOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="135"><PARAGRAPH>types.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="138"><PARAGRAPH>Conditionally claim a mutex lock. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="113"><PARAGRAPH><REFPAGE>MUTEX_UNLOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="135"><PARAGRAPH>types.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="138"><PARAGRAPH>Release a mutex lock. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="113"><PARAGRAPH><REFPAGE>MUTEX_OWNED(D3) </REFPAGE></PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="135"><PARAGRAPH>types.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="138"><PARAGRAPH>Query if a mutual exclusion lock 
is available. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="113"><PARAGRAPH><REFPAGE>MUTEX_MINE(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="135"><PARAGRAPH>types.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="138"><PARAGRAPH>Test if a mutex lock is owned by 
this process. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Although allocation and deallocation functions are supplied, a <INDEXTARGET ID="09-ddkidabi132"><!-- POSTPROCESSDATA: 09-ddkidabi132|data types:<VARIABLE>mutex_t</VARIABLE> --><VARIABLE>mutex_t</VARIABLE> type is a small object that is normally allocated as a static variable or as a field of a structure. The MUTEX_INIT() operation prepares a statically-allocated <VARIABLE>mutex_t</VARIABLE> for use.</PARAGRAPH>
<PARAGRAPH>Once initialized, a mutex lock is used to gain exclusive use of the resource with which you have associated it. The mutex lock has the following important advantages over a basic lock:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The mutex lock can safely be held over a call to a function that sleeps.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The mutex lock supports inquiry functions such as MUTEX_OWNED or MUTEX_MINE.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>When a debugging kernel is used (see <XREF IDREF="83750" TYPE="TITLE">&ldquo;Including Lock Metering in the Kernel Image&rdquo;</XREF>) a mutex lock can be instrumented to keep statistics of its use.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The mutex lock implementation provides <INDEXTARGET ID="09-ddkidabi133"><!-- POSTPROCESSDATA: 09-ddkidabi133|mutual exclusion:priority inheritance --><INDEXTARGET ID="09-ddkidabi134"><!-- POSTPROCESSDATA: 09-ddkidabi134|priority inheritance --><GLOSSARYITEM>priority inheritance</GLOSSARYITEM>. When a low-priority process (or kernel thread) owns a mutex lock and a high-priority process or thread attempts to seize the lock and is blocked, the process holding the lock is temporarily given the higher priority of the blocked process. This hastens the time when the lock can be released, so that a low-priority process does not needlessly impede a higher-priority process.</PARAGRAPH>
<PARAGRAPH>In order to implement priority inheritance and retain high performance, the mutex lock is subject to the restriction that it must be unlocked by the same process or thread that locked it. It cannot be locked in one process or thread identity and unlocked in another.</PARAGRAPH>
<PARAGRAPH>You can use mutex locks to coordinate the use of global variables between upper-half entry points of a driver, and between the upper-half code and the interrupt handler. You should prefer a mutex lock to a basic lock in any case where the worst-case program path could hold the lock for a time of 100 microseconds or more.</PARAGRAPH>
<PARAGRAPH>Mutex locks become inefficient when there is high contention for the lock (that is, when the probability of having to wait is high), because when a process has to wait for a lock, a thread switch takes place. When there is high contention for a lock, it is usually better to use a basic lock, because waiting threads simply spin; they do not execute a context switch.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="72135">Using Sleep Locks</TITLE><PARAGRAPH>IRIX supports sleep lock functions that are compatible with SVR4. These functions are summarized in <INDEXTARGET ID="09-ddkidabi135"><!-- POSTPROCESSDATA: 09-ddkidabi135|mutual exclusion:sleep locks --><INDEXTARGET ID="09-ddkidabi136"><!-- POSTPROCESSDATA: 09-ddkidabi136|sleep locks --><XREF IDREF="60552" TYPE="TABLE">Table&nbsp;8-26</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-26"><PREFIX>Table 8-26 </PREFIX><XREFTARGET ID="60552"> <EMPHASIS>(continued)        </EMPHASIS>Functions for Sleep Locks</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="117"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="129"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="140"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH><REFPAGE>SLEEP_ALLOC(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="129"><PARAGRAPH>types.h &amp; kmem.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="140"><PARAGRAPH>Allocate and initialize a sleep 
lock. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH><REFPAGE>SLEEP_DEALLOC(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="129"><PARAGRAPH>types.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="140"><PARAGRAPH>Deinitialize and deallocate a 
dynamically allocated sleep lock. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH><REFPAGE>SLEEP_INIT(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="129"><PARAGRAPH>types.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="140"><PARAGRAPH>Initialize an existing sleep lock. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH><REFPAGE>SLEEP_DESTROY(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="129"><PARAGRAPH>types.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="140"><PARAGRAPH>Deinitialize a sleep lock. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH><REFPAGE>SLEEP_LOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="129"><PARAGRAPH>types.h &amp; ksynch.h &amp; param.h </PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="140"><PARAGRAPH>Acquire a sleep lock, waiting if 
necessary until the lock is free. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH><REFPAGE>SLEEP_LOCKAVAIL(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="129"><PARAGRAPH>types.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="140"><PARAGRAPH>Query whether a sleep lock is 
available. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH><REFPAGE>SLEEP_LOCK_SIG(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="129"><PARAGRAPH>types.h &amp; ksynch.h &amp; param.h </PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="140"><PARAGRAPH>Acquire a sleep lock, waiting if 
necessary until the lock is free or a 
signal is received. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH><REFPAGE>SLEEP_TRYLOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="129"><PARAGRAPH>types.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="140"><PARAGRAPH>Try to acquire a sleep lock, 
returning a code if it is not free. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH><REFPAGE>SLEEP_UNLOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="129"><PARAGRAPH>types.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="140"><PARAGRAPH>Release a sleep lock. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Although allocation and deallocation functions are supplied, a <INDEXTARGET ID="09-ddkidabi137"><!-- POSTPROCESSDATA: 09-ddkidabi137|data types:<VARIABLE>sleep_t</VARIABLE> --><VARIABLE>sleep_t </VARIABLE>type is a small object that is normally allocated as a static variable or as a field of a structure. The SLEEP_INIT() operation prepares a statically-allocated <VARIABLE>sleep_t</VARIABLE> for use. (In IRIX 6.2, a <VARIABLE>sleep_t</VARIABLE> is identical to a <VARIABLE>sema_t</VARIABLE>, but this situation could change in a future release.)</PARAGRAPH>
<PARAGRAPH>A sleep lock is similar to a mutex lock in that it is used for mutual exclusion between processes, and can be held across a function call that sleeps. A sleep lock does not have either the advantages or the restrictions of a mutex lock:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>A sleep lock can be seized by one process and released by another.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A sleep lock can be set in an upper-half entry point and released in an interrupt routine.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A sleep lock does not provide priority inheritance. When a low-priority process holds a sleep lock, a higher-priority process can be blocked, causing a <GLOSSARYITEM>priority inversion</GLOSSARYITEM>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A sleep lock does not support the instrumentation or the query functions supported for mutex locks.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="50612">Reader/Writer Locks</TITLE><PARAGRAPH>Reader/writer locks are similar to sleep locks in that they are designed for mutually exclusive control of resources for relatively long periods of time. However, Reader/Writer locks are optimized for the case in which the resource is often used by processes that only interrogate it (readers), but only rarely used by processes that modify it (writers).<INDEXTARGET ID="09-ddkidabi138"><!-- POSTPROCESSDATA: 09-ddkidabi138|mutual exclusion:reader/writer locks --><INDEXTARGET ID="09-ddkidabi139"><!-- POSTPROCESSDATA: 09-ddkidabi139|reader/writer locks --></PARAGRAPH>
<PARAGRAPH>Reader/writer locks compatible with SVR4 are introduced in IRIX 6.2. The functions are summarized in <XREF IDREF="95913" TYPE="TABLE">Table&nbsp;8-27</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-27"><PREFIX>Table 8-27 </PREFIX><XREFTARGET ID="95913"> <EMPHASIS>(continued)        </EMPHASIS>Functions for Reader/Writer Locks</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="108"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="144"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="265" WIDTH="135"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>RW_ALLOC(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="144"><PARAGRAPH>types.h &amp; kmem.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="265" WIDTH="135"><PARAGRAPH>Allocate and initialize a 
reader/writer lock. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>RW_DEALLOC(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="144"><PARAGRAPH>types.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="265" WIDTH="135"><PARAGRAPH>Deallocate a reader/writer lock. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>RW_INIT(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="144"><PARAGRAPH>types.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="265" WIDTH="135"><PARAGRAPH>Initialize an existing 
reader/writer lock. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>RW_DESTROY(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="144"><PARAGRAPH>types.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="265" WIDTH="135"><PARAGRAPH>Deinitialize an existing 
reader/writer lock. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>RW_RDLOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="144"><PARAGRAPH>types.h &amp; ksynch.h &amp; param.h </PARAGRAPH>
</CELL>
<CELL LEFT="265" WIDTH="135"><PARAGRAPH>Acquire a reader/writer lock as 
reader, waiting if necessary. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>RW_TRYRDLOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="144"><PARAGRAPH>types.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="265" WIDTH="135"><PARAGRAPH>Try to acquire a reader/writer 
lock as reader, returning a code if 
it is not free. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>RW_TRYWRLOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="144"><PARAGRAPH>types.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="265" WIDTH="135"><PARAGRAPH>Try to acquire a reader/writer 
lock as writer, returning a code if 
it is not free. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>RW_UNLOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="144"><PARAGRAPH>types.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="265" WIDTH="135"><PARAGRAPH>Release a reader/writer lock as 
reader or writer. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>RW_WRLOCK(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="144"><PARAGRAPH>types.h &amp; ksynch.h &amp; param.h </PARAGRAPH>
</CELL>
<CELL LEFT="265" WIDTH="135"><PARAGRAPH>Acquire a reader/writer lock as 
writer, waiting if necessary. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Although allocation and deallocation functions are supplied, a <INDEXTARGET ID="09-ddkidabi140"><!-- POSTPROCESSDATA: 09-ddkidabi140|data types:<VARIABLE>mrlock_t</VARIABLE> --><VARIABLE>mrlock_t </VARIABLE>type is a small object that is normally allocated as a static variable or as a field of a structure. The RW_INIT() operation prepares a statically-allocated <VARIABLE>mrlock_t</VARIABLE> for use.</PARAGRAPH>
<PARAGRAPH>A process that intends to modify a resource uses RW_WRLOCK to claim it. This process waits until the resource is not in use by any process, then it gains exclusive access. Only one process is allowed to hold a reader/writer lock as a writer. All other processes, readers or writers, wait until the writer releases the lock.</PARAGRAPH>
<PARAGRAPH>A process that intends only to interrogate a resource uses RW_RDLOCK to gain access. If a writer holds the lock, the process waits. When the lock is free, or is held only by other readers, the process continues. More than one reader can hold a reader/writer lock at one time. It is also valid for a reader to &ldquo;double-trip&rdquo; a reader/writer lock; that is, claim it two or more times. The reader must release the lock as many times as it claimed the lock.</PARAGRAPH>
<PARAGRAPH>A reader/writer lock serves the same basic purpose as a sleep lock, but it is more efficient in a multiprocessor when there are frequent, read-only uses of a resource.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="75168">Priority Level Functions</TITLE><PARAGRAPH>In traditional UNIX systems, one set of functions served all purposes of synchronization and locking: the set-priority-level, or <INDEXTARGET ID="09-ddkidabi141"><!-- POSTPROCESSDATA: 09-ddkidabi141|priority level functions --><FUNCTION>spl</FUNCTION>, functions. These functions are still available in IRIX, and are summarized in <XREF IDREF="46716" TYPE="TABLE">Table&nbsp;8-28</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-28"><PREFIX>Table 8-28 </PREFIX><XREFTARGET ID="46716"> <EMPHASIS>(continued)        </EMPHASIS>Functions to Set Interrupt Levels</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="198"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>splbase(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="198"><PARAGRAPH>Block no interrupts. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>splhi(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="198"><PARAGRAPH>Block all I/O interrupts. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>splx(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="198"><PARAGRAPH>Restore previous interrupt level. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Calls to these functions are commonly found in device drivers being ported from uniprocessors. Such drivers rely on the use of <INDEXTARGET ID="09-ddkidabi142"><!-- POSTPROCESSDATA: 09-ddkidabi142|kernel functions:<FUNCTION>splhi()</FUNCTION>:denigrated --><FUNCTION>splhi()</FUNCTION> to guarantee exclusive use of global resources.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>spl</FUNCTION> functions listed in <XREF IDREF="46716" TYPE="TABLE">Table&nbsp;8-28</XREF> are supported by IRIX, but you are strongly advised not to use them. In a multiprocessor, the functions affect only the interrupt handling of the current CPU. Other CPUs in the system continue to handle interrupts, including interrupts initiated by the driver that called <FUNCTION>splhi()</FUNCTION>.</PARAGRAPH>
<PARAGRAPH>A driver should use locks, synchronization variables, and other tools to control access to resources. Such a driver never needs an <FUNCTION>spl</FUNCTION> function. This improves performance in a multiprocessor, does not harm performance in a uniprocessor, and reduces the latency of all interrupts. </PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="56199">Waiting for Time to Pass</TITLE><PARAGRAPH>The kernel offers functions for timed delays, as summarized in <INDEXTARGET ID="09-ddkidabi143"><!-- POSTPROCESSDATA: 09-ddkidabi143|waiting --><XREF IDREF="80726" TYPE="TABLE">Table&nbsp;8-29</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-29"><PREFIX>Table 8-29 </PREFIX><XREFTARGET ID="80726"> <EMPHASIS>(continued)        </EMPHASIS>Functions for Timed Delays</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="90"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="86"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="212"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>delay(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="86"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="212"><PARAGRAPH>Delay for a specified number of clock ticks. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>drv_hztousec(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="86"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="212"><PARAGRAPH>Convert clock ticks to microseconds. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>drv_usectohz(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="86"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="212"><PARAGRAPH>Convert microseconds to clock ticks.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>drv_usecwait(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="86"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="212"><PARAGRAPH>Busy-wait for a specified interval.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>dtimeout(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="86"><PARAGRAPH>ddi.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="212"><PARAGRAPH>Schedule a function execute on a specified processor 
after a specified length of time.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>itimeout(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="86"><PARAGRAPH>ddi.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="212"><PARAGRAPH>Schedule a function to be executed after a specified 
number of clock ticks.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>fast_itimeout()</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="86"><PARAGRAPH>ddi.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="212"><PARAGRAPH>Same as <FUNCTION>itimeout</FUNCTION><FUNCTION>()</FUNCTION> but takes an interval in &ldquo;fast 
ticks.&rdquo;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>fasthzto()</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="86"><PARAGRAPH>types.h &amp; time.h </PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="212"><PARAGRAPH>Returns the value of a <VARIABLE>struct</VARIABLE>&space;<VARIABLE>timeval</VARIABLE> as a count of 
&ldquo;fast ticks.&rdquo;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>timeout(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="86"><PARAGRAPH>ddi.h &amp; ksynch.h </PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="212"><PARAGRAPH>Schedule a function to be executed after a specified 
number of clock ticks.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>untimeout(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="86"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="212"><PARAGRAPH>Cancel a previous itimeout or fast_itimeout request.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>untimeout_func(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="86"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="212"><PARAGRAPH>Cancel a previous itimeout or fast_itimeout request 
by function name.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<SECTION3 LBL="" HELPID = ""><TITLE>Time Units</TITLE><PARAGRAPH>The basic time unit is the &ldquo;tick.&rdquo; Its value can differ between hardware platforms and between versions of IRIX. The <INDEXTARGET ID="09-ddkidabi144"><!-- POSTPROCESSDATA: 09-ddkidabi144|waiting:timed events --><INDEXTARGET ID="09-ddkidabi145"><!-- POSTPROCESSDATA: 09-ddkidabi145|tick --><INDEXTARGET ID="09-ddkidabi146"><!-- POSTPROCESSDATA: 09-ddkidabi146|time unit functions --><INDEXTARGET ID="09-ddkidabi147"><!-- POSTPROCESSDATA: 09-ddkidabi147|waiting:time units --><INDEXTARGET ID="09-ddkidabi148"><!-- POSTPROCESSDATA: 09-ddkidabi148|kernel functions:<FUNCTION>drvhztousec()</FUNCTION> --><FUNCTION>drvhztousec()</FUNCTION> and <INDEXTARGET ID="09-ddkidabi149"><!-- POSTPROCESSDATA: 09-ddkidabi149|kernel functions:<FUNCTION>drvusectohz()</FUNCTION> --><FUNCTION>drvusectohz()</FUNCTION> functions convert between ticks and microseconds in the current system. Use them in order to schedule a delay in a portable manner. (However, the timer function precision is the tick, not the microsecond.)</PARAGRAPH>
<PARAGRAPH>The &ldquo;fast tick&rdquo; is a fraction of a tick. Like the tick, the fast tick's value can differ between systems. Use <INDEXTARGET ID="09-ddkidabi150"><!-- POSTPROCESSDATA: 09-ddkidabi150|kernel functions:<FUNCTION>fasthzto()</FUNCTION> --><FUNCTION>fasthzto()</FUNCTION> to convert from microseconds to fast ticks.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Timer Support</TITLE><PARAGRAPH>Timer support is based on the idea of a &ldquo;callback&rdquo; function. You specify the following to <FUNCTION>dtimeout()</FUNCTION>, <FUNCTION>itimeout()</FUNCTION>, <INDEXTARGET ID="09-ddkidabi151"><!-- POSTPROCESSDATA: 09-ddkidabi151|kernel functions:<FUNCTION>timeout()</FUNCTION> --><FUNCTION>timeout()</FUNCTION> or <FUNCTION>fast_itimeout()</FUNCTION>:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>an interval in clock ticks or fast ticks</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>a function to be called at the expiration of the interval</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>one or more arguments to be passed to the function</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>a priority (interrupt) level at which the function should run</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>After a delay of at least the length requested, the function is called. The function is entered asynchronously. On a uniprocessor, it can interrupt execution of an upper-half routine. On a multiprocessor, it can execute concurrently with an upper-half routine or with an interrupt handler or a different timeout function. (Use locks or mutexes for mutual exclusion.)</PARAGRAPH>
<PARAGRAPH>The difference between <INDEXTARGET ID="09-ddkidabi152"><!-- POSTPROCESSDATA: 09-ddkidabi152|kernel functions:<FUNCTION>itimeout()</FUNCTION> --><FUNCTION>itimeout()</FUNCTION> and <FUNCTION>timeout()</FUNCTION> is that the latter takes no argument values to be passed to the function when it is called. In order to get a repeated series of timer events, start a new timeout from the callback function.</PARAGRAPH>
<PARAGRAPH>The <INDEXTARGET ID="09-ddkidabi153"><!-- POSTPROCESSDATA: 09-ddkidabi153|kernel functions:<FUNCTION>untimeout()</FUNCTION> --><FUNCTION>untimeout()</FUNCTION> and <FUNCTION>untimeout_func()</FUNCTION> functions cancel a pending timeout. In a loadable driver that has an <VARIABLE>pfx</VARIABLE><FUNCTION>unload()</FUNCTION> entry point, cancel any pending timeouts before unloading.</PARAGRAPH>
<PARAGRAPH>The STREAMS_TIMOUT macro supplies similar timeout capability for a STREAMS driver (see <XREF IDREF="34867" TYPE="TITLE">&ldquo;Special Considerations for Multiprocessing&rdquo;</XREF>).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Short-Term Delay Support</TITLE><PARAGRAPH>In rare circumstances, a driver needs to pause briefly between two hardware operations. For example, the Silicon Graphics support for external interrupts in the Challenge and Onyx computers sometimes needs to set a high output level, wait for a brief, precise interval, then set a low output level.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>drv_usecwait()</FUNCTION> function supports this type of very short, precisely-timed delay. It &ldquo;spins&rdquo; for a specified number of microseconds, then returns to the caller. The CPU does nothing else during this period, so clearly a delay of more than a few microseconds can interfere with other work. Furthermore, if interrupts are disabled during the wait, the response to another interrupt is delayed also&mdash;the delay contributes directly to the &ldquo;latency&rdquo; of interrupt handling.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="14842">Waiting for Memory to Become Available</TITLE><PARAGRAPH>Whenever you request memory of any kind, you must allow for the possibility that the memory will not be available. When you allocate memory in bulk (see <INDEXTARGET ID="09-ddkidabi154"><!-- POSTPROCESSDATA: 09-ddkidabi154|waiting:for memory --><XREF IDREF="68494" TYPE="TITLE">&ldquo;General-Purpose Allocation&rdquo;</XREF>) using <FUNCTION>kmem_alloc()</FUNCTION> you have the option of receiving a null response, or of waiting for the memory to be available.</PARAGRAPH>
<PARAGRAPH>When you request memory for specific object types (see <XREF IDREF="61136" TYPE="TITLE">&ldquo;Allocating Objects of Specific Kinds&rdquo;</XREF>) there is usually no choice; the functions sleep until they can acquire an object of the requested type.</PARAGRAPH>
<PARAGRAPH>Within a STREAMS driver you have the ability to schedule a callback function to be entered when memory for a message buffer becomes available (see the <REFPAGE>bufcall(D3)</REFPAGE> reference page).</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="78884">Waiting for Block I/O to Complete</TITLE><PARAGRAPH>The <INDEXTARGET ID="09-ddkidabi155"><!-- POSTPROCESSDATA: 09-ddkidabi155|waiting:for an interrupt --><INDEXTARGET ID="09-ddkidabi156"><!-- POSTPROCESSDATA: 09-ddkidabi156|entry points:strategy:design models --><VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> routine initiates the I/O operation to fill a buffer based on a <VARIABLE>buf_t</VARIABLE> structure. Then it has to wait for the I/O to complete. The functions for managing this synchronization are summarized in <XREF IDREF="67200" TYPE="TABLE">Table&nbsp;8-30</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-30"><PREFIX>Table 8-30 </PREFIX><XREFTARGET ID="67200"> <EMPHASIS>(continued)        </EMPHASIS>Functions for Synchronizing Block I/O</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>biodone(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Release buffer after I/O and wake up waiting process. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>bioerror(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Manipulate error fields in a <VARIABLE>buf_t</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>biowait(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Suspend process pending completion of I/O. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>geterror(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Retrieve error number from a <VARIABLE>buf_t</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>physiock(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Validate a raw I/O request and pass to a strategy function. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>uiophysio(D3) </REFPAGE></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Validate a raw I/O request and pass to a strategy function. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>undma(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Unlock physical memory after I/O complete. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>userdma(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Lock physical memory in user space. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<SECTION3 LBL="" HELPID = ""><TITLE>How the strategy() Entry Point Is Called</TITLE><PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> entry point is called directly from the filesystem or virtual memory management, or it can be called indirectly from a <VARIABLE>pfx</VARIABLE><FUNCTION>read()</FUNCTION> or <VARIABLE>pfx</VARIABLE><FUNCTION>write()</FUNCTION> entry point (see <XREF IDREF="31423" TYPE="TITLE">&ldquo;Calling Entry Point strategy() From Entry Point read() or write()&rdquo;</XREF>).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Strategies of the strategy() Entry Point</TITLE><PARAGRAPH>Typically the <INDEXTARGET ID="09-ddkidabi157"><!-- POSTPROCESSDATA: 09-ddkidabi157|data types:<VARIABLE>buf_t</VARIABLE>:management --><VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> routine must interact with its interrupt handler. The <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> routine can be designed in either of two ways, synchronous or asynchronous.</PARAGRAPH>
<PARAGRAPH>The synchronous <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> routine initiates every I/O operation. Its interrupt handler is responsible only for detecting and signalling the completion of one I/O. The <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> routine proceeds as follows:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Lock the data buffer in memory using <FUNCTION>userdma()</FUNCTION>.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Place the address of the <VARIABLE>buf_t</VARIABLE> where the <VARIABLE>pfx</VARIABLE><FUNCTION>intr()</FUNCTION> entry point can find it.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Program the device (see <XREF IDREF="40016" TYPE="TITLE">&ldquo;Setting Up a DMA Transfer&rdquo;</XREF>) and initiate the I/O activity.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Call <FUNCTION>biowait()</FUNCTION>.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>When the interrupt handler is entered, the handler uses <INDEXTARGET ID="09-ddkidabi158"><!-- POSTPROCESSDATA: 09-ddkidabi158|kernel functions:<FUNCTION>biodone()</FUNCTION> --><INDEXTARGET ID="09-ddkidabi159"><!-- POSTPROCESSDATA: 09-ddkidabi159|kernel functions:<FUNCTION>biowait()</FUNCTION> --><FUNCTION>bioerror()</FUNCTION> if necessary, and <FUNCTION>biodone()</FUNCTION> to signal the completion of the I/O. Then it exits. The strategy code, which is waiting in the call to <FUNCTION>biowait()</FUNCTION>, regains control following the call to <FUNCTION>biodone()</FUNCTION>, and can use <FUNCTION>geterror()</FUNCTION> to check the results.</PARAGRAPH>
<PARAGRAPH>The asynchronous <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> routine only initiates the first I/O operation of a series, and never waits. It proceeds as follows:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Lock the data buffer in memory using <FUNCTION>userdma()</FUNCTION>.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Append the address of the <VARIABLE>buf_t</VARIABLE> to a queue shared with the interrupt handler.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>If the queue was empty, no I/O is in progress. Call a subroutine that programs the device and initiates the I/O.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Return to the caller. The caller (a filesystem or paging system or <FUNCTION>uiophysio()</FUNCTION>) waits using <FUNCTION>biowait()</FUNCTION>.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>When the interrupt occurs, the handler proceeds as follows:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>The first queued <VARIABLE>buf_t</VARIABLE> has completed. Remove it from the queue.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Apply <FUNCTION>bioerror()</FUNCTION> if necessary, and <FUNCTION>biodone()</FUNCTION> to the <VARIABLE>buf_t</VARIABLE>. This releases the caller of the strategy routine from <FUNCTION>biowait()</FUNCTION>.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>If any operations remain in the queue, call a subroutine to program and initiate the next one.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="59737">Waiting for a General Event</TITLE><PARAGRAPH>There are causes for synchronization other than time, block I/O, and memory allocation. For example, there is no defined interface comparable to <INDEXTARGET ID="09-ddkidabi160"><!-- POSTPROCESSDATA: 09-ddkidabi160|waiting:for a general event --><FUNCTION>biowait()</FUNCTION>/<FUNCTION>biodone()</FUNCTION> to mediate between an interrupt handler and the <VARIABLE>pfx</VARIABLE><FUNCTION>read()</FUNCTION> or <VARIABLE>pfx</VARIABLE><FUNCTION>write()</FUNCTION> entry points. You must design a mechanism of your own, using either a synchronization variable or the <FUNCTION>sleep()</FUNCTION>/<FUNCTION>wakeup()</FUNCTION> function pair.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="60062">Using sleep() and wakeup()</TITLE><PARAGRAPH>The <INDEXTARGET ID="09-ddkidabi161"><!-- POSTPROCESSDATA: 09-ddkidabi161|kernel functions:<FUNCTION>wakeup()</FUNCTION> --><INDEXTARGET ID="09-ddkidabi162"><!-- POSTPROCESSDATA: 09-ddkidabi162|kernel functions:<FUNCTION>sleep()</FUNCTION> --><FUNCTION>sleep()</FUNCTION> and <FUNCTION>wakeup()</FUNCTION> function pair are the simplest, oldest, and least efficient of the general synchronization mechanisms. They are summarized in <XREF IDREF="86557" TYPE="TABLE">Table&nbsp;8-31</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-31"><PREFIX>Table 8-31 </PREFIX><XREFTARGET ID="86557"> <EMPHASIS>(continued)        </EMPHASIS>Functions for Synchronization: sleep/wakeup</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="81"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="81"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="180" WIDTH="225"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>sleep(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="81"><PARAGRAPH>ddi.h &amp; param.h </PARAGRAPH>
</CELL>
<CELL LEFT="180" WIDTH="225"><PARAGRAPH>Suspend execution pending an event. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>wakeup(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="81"><PARAGRAPH>ddi.h </PARAGRAPH>
</CELL>
<CELL LEFT="180" WIDTH="225"><PARAGRAPH>Waken a process waiting for an event. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Used carefully, these functions are suitable for simple character device drivers. However, when you are writing new code or converting a driver to multiprocessing you should avoid them and use synchronization variables instead (see <XREF IDREF="41132" TYPE="TITLE">&ldquo;Using Synchronization Variables&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>The basic concept is that the upper-layer routine calls <FUNCTION>sleep</FUNCTION>(<VARIABLE>n</VARIABLE>) in order to wait for an event that is keyed to an arbitrary address <VARIABLE>n</VARIABLE>. Typically <VARIABLE>n</VARIABLE> is a pointer to a data structure related to an I/O operation. The interrupt handler executes <FUNCTION>wakeup</FUNCTION>(<VARIABLE>n</VARIABLE>) to cause the sleeping process to resume execution.</PARAGRAPH>
<PARAGRAPH>The main reason to avoid <FUNCTION>sleep()</FUNCTION> is that, in a multiprocessor system, it is hard to ensure that sleeping always begins before <FUNCTION>wakeup()</FUNCTION> is called. The usual intended sequence of events is as follows:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Upper-half routine initiates a device operation that will lead to an interrupt.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Upper-half routine executes <FUNCTION>sleep</FUNCTION>(<VARIABLE>n</VARIABLE>).</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Interrupt occurs, and handler executes <FUNCTION>wakeup</FUNCTION>(<VARIABLE>n</VARIABLE>).</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>In a multiprocessor-aware driver (one with D_MP in its <VARIABLE>pfx</VARIABLE><FUNCTION>devflag</FUNCTION> constant; see <XREF IDREF="67704" TYPE="TITLE">&ldquo;Driver Flag Constant&rdquo;</XREF>), there is a small chance that the interrupt can occur, calling <FUNCTION>wakeup</FUNCTION>(<VARIABLE>n</VARIABLE>), before the <FUNCTION>sleep</FUNCTION>(<VARIABLE>n</VARIABLE>) call has been completed. Because <FUNCTION>sleep()</FUNCTION> has not been called, the <FUNCTION>wakeup()</FUNCTION> is lost. When the <FUNCTION>sleep()</FUNCTION> call completes, the process sleeps forever. Synchronization variables are designed to handle this case.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="41132">Using Synchronization Variables</TITLE><PARAGRAPH>Synchronization variables, a feature of UNIX SVR4, are supported by IRIX beginning with release 6.2. These functions are summarized in <INDEXTARGET ID="09-ddkidabi163"><!-- POSTPROCESSDATA: 09-ddkidabi163|waiting:synchronization variables --><INDEXTARGET ID="09-ddkidabi164"><!-- POSTPROCESSDATA: 09-ddkidabi164|synchronization variable --><XREF IDREF="58411" TYPE="TABLE">Table&nbsp;8-32</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-32"><PREFIX>Table 8-32 </PREFIX><XREFTARGET ID="58411"> <EMPHASIS>(continued)        </EMPHASIS>Functions for Synchronization: Synchronization Variables</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="96"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="100"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="198"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="96"><PARAGRAPH><REFPAGE>SV_ALLOC(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="100"><PARAGRAPH>types.h &amp; sema.h </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="198"><PARAGRAPH>Allocate and initialize a synchronization 
variable. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="96"><PARAGRAPH><REFPAGE>SV_DEALLOC(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="100"><PARAGRAPH>types.h &amp; sema.h </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="198"><PARAGRAPH>Deinitialize and deallocate a synchronization 
variable. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="96"><PARAGRAPH><REFPAGE>SV_INIT(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="100"><PARAGRAPH>types.h &amp; sema.h </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="198"><PARAGRAPH>Initialize an existing synchronization variable. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="96"><PARAGRAPH><REFPAGE>SV_DESTROY(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="100"><PARAGRAPH>types.h &amp; sema.h </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="198"><PARAGRAPH>Deinitialize a synchronization variable. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="96"><PARAGRAPH><REFPAGE>SV_BROADCAST(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="100"><PARAGRAPH>types.h &amp; sema.h </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="198"><PARAGRAPH>Wake all processes sleeping on a synchronization 
variable. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="96"><PARAGRAPH><REFPAGE>SV_SIGNAL(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="100"><PARAGRAPH>types.h &amp; sema.h </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="198"><PARAGRAPH>Wake one process sleeping on a synchronization 
variable. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="96"><PARAGRAPH><REFPAGE>SV_WAIT(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="100"><PARAGRAPH>types.h &amp; sema.h </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="198"><PARAGRAPH>Sleep until a synchronization variable is 
signalled. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="96"><PARAGRAPH><REFPAGE>SV_WAIT_SIG(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="100"><PARAGRAPH>types.h &amp; sema.h </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="198"><PARAGRAPH>Sleep until a synchronization variable is 
signalled or a signal is received. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>A synchronization variable is a memory object of type <INDEXTARGET ID="09-ddkidabi165"><!-- POSTPROCESSDATA: 09-ddkidabi165|data types:<VARIABLE>sv_t</VARIABLE> --><VARIABLE>sv_t</VARIABLE>, representing the occurrence of an event. You can allocate objects of this type dynamically, or declare them as static variables or as fields of structures.</PARAGRAPH>
<PARAGRAPH>One or more processes may wait for an event using SV_WAIT(). An interrupt handler or timer callback function can signal the occurrence of an event using SV_SIGNAL (to wake up only one waiting process) or SV_BROADCAST (to wake up all of them).</PARAGRAPH>
<PARAGRAPH>SV_WAIT is specifically designed to handle the difficult case that arises when the driver needs to initiate an I/O operation and then sleep, and do these things in such a way that it always begins to sleep before the SV_SIGNAL can possibly be issued. The procedure is done as follows:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>The driver seizes a basic lock (see <XREF IDREF="59834" TYPE="TITLE">&ldquo;Basic Locks&rdquo;</XREF>) or a mutex lock (see <XREF IDREF="29043" TYPE="TITLE">&ldquo;Using Mutex Locks&rdquo;</XREF>) that is also used by the interrupt handler.</PARAGRAPH>
<PARAGRAPH>A LOCK() call returns an integer that is needed later.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The driver initiates an I/O operation that can lead to an interrupt.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The driver calls SV_WAIT, passing the lock it holds and an integer, either the value returned by LOCK() or a zero if the lock is a mutex lock.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>In one indivisible operation, SV_WAIT releases the lock and begins waiting on the synchronization variable.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The interrupt handler or other process is entered, and seizes the lock.</PARAGRAPH>
<PARAGRAPH>This step ensures that, if the interrupt handler or other process is entered preceding the SV_WAIT call, it will not proceed until SV_WAIT has completed.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The interrupt handler or other process does its work and calls SV_SIGNAL to release the waiting driver.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>This process is sketched in <XREF IDREF="60259" TYPE="TEXT">Example&nbsp;8-5</XREF>.</PARAGRAPH>
<CODE><CAPTION LBL="8-5"><PREFIX>Example 8-5 </PREFIX><XREFTARGET ID="60259">Skeleton Code for Use of SV_WAIT</CAPTION>lock_t seize_it;
sv_t wait_on_it;
initiator(...)
{
&nbsp;&nbsp;&nbsp;int lock_cookie;
&nbsp;&nbsp;&nbsp;for( as often as necessary )
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock_cookie = LOCK(&amp;seize_it,PL_ZERO);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[do something that causes a later interrupt]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SV_WAIT(&amp;wait_on_it, 0, &amp;seize_it, lock_cookie);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[interrupt has been handled]
&nbsp;&nbsp;&nbsp;}
}
&nbsp;
void handler(...)
{
&nbsp;&nbsp;&nbsp;int lock_cookie = LOCK(&amp;seize_it,PL_ZERO);
&nbsp;&nbsp;&nbsp;[handle the interrupt]
&nbsp;&nbsp;&nbsp;SV_SIGNAL(&amp;wait_on_it);
&nbsp;&nbsp;&nbsp;UNLOCK(&amp;seize_it);
}
</CODE>
<PARAGRAPH>If it is necessary to use a semaphore as the lock, the header file sys/sema.h declares versions of SV_WAIT that accept a semaphore and a synchronization variable. The combination of a mutual exclusion object and a synchronization variable ensures that even in a multiprocessor, the interrupt handler cannot exit before the driver has entered a predictable wait state.</PARAGRAPH>
<TIP><PREFIX>Tip</PREFIX>When a debugging kernel is used, you can display statistics about the use of a given synchronization variable. See <XREF IDREF="83750" TYPE="TITLE">&ldquo;Including Lock Metering in the Kernel Image&rdquo;</XREF>.</TIP>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="42679">Semaphores</TITLE><PARAGRAPH>The <INDEXTARGET ID="09-ddkidabi166"><!-- POSTPROCESSDATA: 09-ddkidabi166|semaphore --><GLOSSARYITEM>semaphore</GLOSSARYITEM> is a generalized tool that can be used for both mutual exclusion and for waiting. The IRIX kernel support for semaphores is summarized in <XREF IDREF="88458" TYPE="TABLE">Table&nbsp;8-33</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="8-33"><PREFIX>Table 8-33 </PREFIX><XREFTARGET ID="88458"> <EMPHASIS>(continued)        </EMPHASIS>Functions for Semaphores</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="99"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="90"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="203"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>cpsema(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="90"><PARAGRAPH>sema.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="203"><PARAGRAPH>Conditionally perform a &ldquo;P&rdquo; or wait semaphore 
operation. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>cvsema(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="90"><PARAGRAPH>sema.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="203"><PARAGRAPH>Conditionally perform a &ldquo;V&rdquo; or release 
semaphore operation. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>freesema(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="90"><PARAGRAPH>sema.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="203"><PARAGRAPH>Free the resources associated with a semaphore. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>initnsema(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="90"><PARAGRAPH>sema.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="203"><PARAGRAPH>Initialize a semaphore to a given value. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>initnsema_mutex(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="90"><PARAGRAPH>sema.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="203"><PARAGRAPH>Initialize a semaphore to a value of 1. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>psema(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="90"><PARAGRAPH>sema.h &amp; types.h &amp; 
param.h </PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="203"><PARAGRAPH>Perform a &ldquo;P&rdquo; or wait semaphore operation. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>valusema(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="90"><PARAGRAPH>sema.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="203"><PARAGRAPH>Return the value associated with a semaphore. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>vsema(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="90"><PARAGRAPH>sema.h &amp; types.h </PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="203"><PARAGRAPH>Perform a &ldquo;V&rdquo; or signal semaphore operation. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Conceptually, a semaphore contains an integer. The &ldquo;P&rdquo; operation claims the semaphore, decrementing its count by 1 (mnemonic: dePlete). If the count is 0 or less, the process waits until the count is greater than 0 before it decrements the semaphore and returns.</PARAGRAPH>
<PARAGRAPH>The &ldquo;V&rdquo; operation increments the semaphore count (mnemonic: reViVe) and wakens any process that is waiting.</PARAGRAPH>
<TIP><PREFIX>Tip</PREFIX>When a debugging kernel is used, you can display statistics about the use of a given semaphore. See <XREF IDREF="83750" TYPE="TITLE">&ldquo;Including Lock Metering in the Kernel Image&rdquo;</XREF>.</TIP>
<NOTE><PREFIX>Note</PREFIX>In releases before IRIX 6.2, <INDEXTARGET ID="09-ddkidabi167"><!-- POSTPROCESSDATA: 09-ddkidabi167|kernel functions:<FUNCTION>initnsema_mutex() (not supported)</FUNCTION> --><FUNCTION>initnsema_mutex()</FUNCTION> was used to initialize a semaphore in a special way that got the performance of a basic lock in a multiprocessor. Since IRIX&nbsp;6.2, this function is simply a macro that initializes the semaphore to a count of&nbsp;1. </NOTE>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="73500">Using a Semaphore for Mutual Exclusion</TITLE><PARAGRAPH>To use a semaphore for locking, initialize it to 1. (This reflects the idea that a process calling a locking function expects to continue.) When you require exclusive use of the associated resource, call <INDEXTARGET ID="09-ddkidabi168"><!-- POSTPROCESSDATA: 09-ddkidabi168|kernel functions:<FUNCTION>psema()</FUNCTION> --><INDEXTARGET ID="09-ddkidabi169"><!-- POSTPROCESSDATA: 09-ddkidabi169|semaphore:for mutual exclusion --><INDEXTARGET ID="09-ddkidabi170"><!-- POSTPROCESSDATA: 09-ddkidabi170|mutual exclusion:semaphore --><FUNCTION>psema()</FUNCTION>. Typically this finds a semaphore count of 1, reduces it to 0, and returns.</PARAGRAPH>
<PARAGRAPH>When you are finished with the resource, call <INDEXTARGET ID="09-ddkidabi171"><!-- POSTPROCESSDATA: 09-ddkidabi171|kernel functions:<FUNCTION>vsema()</FUNCTION> --><FUNCTION>vsema()</FUNCTION> to increment the semaphore count, and release any process that is blocked in a <FUNCTION>psema()</FUNCTION> call for the same semaphore.</PARAGRAPH>
<PARAGRAPH>For locking, a semaphore is comparable to a sleep lock. In some systems, the performance of semaphore operations may not be as good as the performance of a mutex lock. In other systems, mutex locks may be implemented using semaphores.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using a Semaphore for Waiting</TITLE><PARAGRAPH>To use a semaphore for waiting, initialize it to 0. Then call <INDEXTARGET ID="09-ddkidabi172"><!-- POSTPROCESSDATA: 09-ddkidabi172|semaphore:for waiting --><INDEXTARGET ID="09-ddkidabi173"><!-- POSTPROCESSDATA: 09-ddkidabi173|waiting:semaphore --><FUNCTION>psema()</FUNCTION>. Because the semaphore count is 0, the process waits. When the desired event occurs, typically in the interrupt handler, call <FUNCTION>vsema()</FUNCTION> to release the waiting process.</PARAGRAPH>
<PARAGRAPH>This synchronization method is as reliable as a synchronization variable, but it has slightly different behavior. When a synchronization variable is used correctly (see <XREF IDREF="41132" TYPE="TITLE">&ldquo;Using Synchronization Variables&rdquo;</XREF>), if the interrupt handler is entered before the SV_WAIT call completes, the interrupt handler waits on a LOCK call.</PARAGRAPH>
<PARAGRAPH>When a semaphore is used, if the interrupt handler is entered before the <FUNCTION>psema()</FUNCTION> call completes, the <FUNCTION>vsema()</FUNCTION> operation is done immediately and the interrupt handler continues without waiting. The fact that <FUNCTION>vsema()</FUNCTION> was called is stored as a count within the semaphore, where <FUNCTION>psema()</FUNCTION> will find it. Because the semaphore can contain this state information, the interrupt handler does not have to be synchronized in time using a lock.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>In releases before IRIX 6.2, the <FUNCTION>vpsema()</FUNCTION> function was used in a way similar to synchronization variables are used: to release one semaphore and wait on another in an atomic operation. This function is no longer supported; replace it with synchronization variable. </NOTE>
</SECTION3>
</SECTION2>
</SECTION1>
</CHAPTER>
