<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="14"><TITLE><XREFTARGET ID="90512">VME Device Attachment on Challenge/Onyx</TITLE><PARAGRAPH>This chapter gives a high-level overview of the VME bus, and describes how the VME bus is attached to, and operated by Challenge and Onyx systems.<INDEXTARGET ID="14.1Y-vmehw1"><!-- POSTPROCESSDATA: 14.1Y-vmehw1|VME bus --></PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>For information on hardware device issues on the Origin2000 and Onyx2 platforms, refer to <XREF IDREF="46033" TYPE="TITLE">Chapter&nbsp;12, &ldquo;VME Device Attachment on Origin2000/Onyx2,&rdquo;</XREF> and <XREF IDREF="13012" TYPE="TITLE">Chapter&nbsp;13, &ldquo;Services for VME Drivers on Origin2000/Onyx2.&rdquo;</XREF>.</NOTE>
<PARAGRAPH>This chapter contains useful background information if you plan to control a VME device from a user-level program. It contains important details on VME addressing if you are writing a kernel-level VME device driver.</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="64746" TYPE="TITLE">&ldquo;Overview of the VME Bus&rdquo;</XREF> summarizes the history and features of the VME bus architecture.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="41896" TYPE="TITLE">&ldquo;VME Bus in Challenge and Onyx Systems&rdquo;</XREF> gives an overview of how the VME bus is integrated into Challenge and Onyx computer systems.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="74057" TYPE="TITLE">&ldquo;VME Bus Addresses and System Addresses&rdquo;</XREF> discusses the relationship between addresses on the VME bus and addresses in the physical address space of the system.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="82448" TYPE="TITLE">&ldquo;Configuring VME Devices&rdquo;</XREF> tells how to configure a device so that IRIX can recognize it and initialize its device driver.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="79297" TYPE="TITLE">&ldquo;VME Hardware in Challenge and Onyx Systems&rdquo;</XREF> documents the hardware details of the VME implementation on those systems.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>More information about VME device control appears in these chapters:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="66996" TYPE="TITLE">Chapter&nbsp;4, &ldquo;User-Level Access to Devices,&rdquo;</XREF> covers PIO and DMA access from the user process.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="14611" TYPE="TITLE">Chapter&nbsp;15, &ldquo;Services for VME Drivers on Challenge/Onyx,&rdquo;</XREF>discusses the kernel services used by a kernel-level VME device driver, and contains an example.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="64746">Overview of the VME Bus</TITLE><PARAGRAPH>The VME bus dates to the early 1980s. It was designed as a flexible interconnection between multiple master and slave devices using a variety of address and data precisions, and has become a popular standard bus used in a variety of products. (For ordering information on the standards documents, see <XREF IDREF="39610" TYPE="TITLE">&ldquo;Standards Documents&rdquo;</XREF>.)</PARAGRAPH>
<PARAGRAPH>In Silicon Graphics systems, the VME bus is treated as an I/O device, not as the main system bus.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>VME History</TITLE><PARAGRAPH>The VME bus descends from the VERSAbus, a bus design published by Motorola, Inc., in 1980 to support the needs of the MC68000 line of microprocessors. The bus timing relationships and some signal names still reflect this heritage, although the VME bus is used by devices from many manufacturers today.<INDEXTARGET ID="14.1Y-vmehw2"><!-- POSTPROCESSDATA: 14.1Y-vmehw2|VME bus:history --></PARAGRAPH>
<PARAGRAPH>The original VERSAbus design specified a large form factor for pluggable cards. Because of this, it was not popular with European designers. A bus with a smaller form factor but similar functions and electrical specifications was designed for European use, and promoted by Motorola, Phillips, Thompson, and other companies. This was the VersaModule European, or VME, bus. Beginning with rev B of 1982, the bus quickly became an accepted standard.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>VME Features</TITLE><PARAGRAPH>A VME bus is a set of parallel conductors that interconnect multiple processing devices. The devices can exchange data in units of 8, 16, 32 or 64 bits during a bus cycle.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>VME Address Spaces</TITLE><PARAGRAPH>Each VME device identifies itself with a range of bus addresses. A bus address has either 16, 24, or 32 bits of precision. Each address width forms a separate address space. That is, the same numeric value can refer to one device in the 24-bit address space but a different device in the 32-bit address space. Typically, a device operates in only one address space, but some devices can be configured to respond to addresses in multiple spaces.<INDEXTARGET ID="14.1Y-vmehw3"><!-- POSTPROCESSDATA: 14.1Y-vmehw3|VME bus:bus address spaces --></PARAGRAPH>
<PARAGRAPH>Each VME bus cycle contains the bits of an address. The address is qualified by sets of address-modifier bits that specify the following:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>the address space (A16, A24, or A32)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>whether the operation is single or a block transfer</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>whether the access is to what, in the MC68000 architecture, would be data or code, in a supervisor or user area (Silicon Graphics systems support only supervisor-data and user-data requests)</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Master and Slave Devices</TITLE><PARAGRAPH>Each VME device acts as either a bus master or a bus slave. Typically a bus master is a device with some level of programmability, usually a microprocessor. A disk controller is an example of a master device. A slave device is typically a nonprogrammable device like a memory board.<INDEXTARGET ID="14.1Y-vmehw4"><!-- POSTPROCESSDATA: 14.1Y-vmehw4|VME bus:slave device --><INDEXTARGET ID="14.1Y-vmehw5"><!-- POSTPROCESSDATA: 14.1Y-vmehw5|VME bus:master device --></PARAGRAPH>
<PARAGRAPH>Each data transfer is initiated by a master device. The master</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>asserts ownership of the bus</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>specifies the address modifier bits for the transfer, including the address space, single/block mode, and supervisor/normal mode</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>specifies the address for the transfer</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>specifies the data unit size for the transfer (8, 16, 32 or 64 bits)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>specifies the direction of the transfer with respect to the master</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The VME bus design permits multiple master devices to use the bus, and provides a hardware-based arbitration system so that they can use the bus in alternation.</PARAGRAPH>
<PARAGRAPH>A slave device responds to a master when the master specifies the slave's address. The addressed slave accepts data, or provides data, as directed.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>VME Transactions</TITLE><PARAGRAPH>The VME design allows for four types of data transfer bus cycles:<INDEXTARGET ID="14.1Y-vmehw6"><!-- POSTPROCESSDATA: 14.1Y-vmehw6|VME bus:bus cycles --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>A read cycle returns data from the slave to the master.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A write cycle sends data from the master to the slave.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A read-modify-write cycle takes data from the slave, and on the following bus cycle sends it back to the same address, possibly altered.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A block-transfer transaction sends multiple data units to adjacent addresses in a burst of consecutive bus cycles.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The VME design also allows for interrupts. A device can raise an interrupt on any of seven <INDEXTARGET ID="14.1Y-vmehw7"><!-- POSTPROCESSDATA: 14.1Y-vmehw7|VME bus:interrupt levels --><GLOSSARYITEM>interrupt level</GLOSSARYITEM>s. The interrupt is acknowledged by a bus master. The bus master interrogates the interrupting device in an interrupt-acknowledge bus cycle, and the device returns an interrupt vector number.</PARAGRAPH>
<PARAGRAPH>In Silicon Graphics systems, it is always the Silicon Graphics VME controller that acknowledges interrupts. It passes the interrupt to one of the CPUs in the system.</PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="41896">VME Bus in Challenge and Onyx Systems</TITLE><PARAGRAPH>The VME bus was designed as the system backplane for a workstation, supporting one or more CPU modules along with the memory and I/O modules they used. However, no Silicon Graphics computer uses the VME bus as the system backplane. In all Challenge and Onyx computers, the main system bus that connects CPUs to memory is a proprietary bus design, with higher speed and sometimes wider data units than the VME bus provides. The VME bus is attached to the system as an I/O device.<INDEXTARGET ID="14.1Y-vmehw8"><!-- POSTPROCESSDATA: 14.1Y-vmehw8|VME bus:hardware:overview --><INDEXTARGET ID="14.1Y-vmehw9"><!-- POSTPROCESSDATA: 14.1Y-vmehw9|Silicon Graphics:VME bus hardware --></PARAGRAPH>
<PARAGRAPH>This section provides an overview of the design of the VME bus in any Challenge and Onyx system. It is sufficient background for most users of VME devices. For a more detailed look at the Challenge and Onyx implementation of VME, see <XREF IDREF="79297" TYPE="TITLE">&ldquo;VME Hardware in Challenge and Onyx Systems&rdquo;</XREF>.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>The VME Bus Controller</TITLE><PARAGRAPH>A VME bus controller is attached to the system bus to act as a bridge between the system bus and the VME bus. This arrangement is shown in <XREF IDREF="41389" TYPE="GRAPHIC">Figure&nbsp;14-1</XREF>.</PARAGRAPH>
<PARAGRAPH>On the system bus, the VME bus controller acts as an I/O device. On the VME bus, the bus controller acts as a VME bus master. The VME controller has several tasks. Its most important task is mapping; that is, translating some range of physical addresses in the system address space to a range of VME bus addresses. The VME controller performs a variety of other duties for different kinds of VME access.<INDEXTARGET ID="14.1Y-vmehw10"><!-- POSTPROCESSDATA: 14.1Y-vmehw10|VME bus:hardware:relation to system bus --></PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="13-vme.to.system.bus.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="14-1"><PREFIX>Figure 14-1 </PREFIX><XREFTARGET ID="41389">Relationship of VME Bus to System Bus</CAPTION>
</FIGURE>
</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>VME PIO Operations</TITLE><PARAGRAPH>During programmed I/O (PIO) to the VME bus, software in the CPU loads or stores the contents of CPU registers to a device on the VME bus. The operation of a CPU load from a VME device register is as follows:<INDEXTARGET ID="14.1Y-vmehw11"><!-- POSTPROCESSDATA: 14.1Y-vmehw11|Programmed I/O (PIO):VME bus --><INDEXTARGET ID="14.1Y-vmehw12"><!-- POSTPROCESSDATA: 14.1Y-vmehw12|Programmed I/O (PIO) --><INDEXTARGET ID="14.1Y-vmehw13"><!-- POSTPROCESSDATA: 14.1Y-vmehw13|Programmed I/O (PIO):VME bus --><INDEXTARGET ID="14.1Y-vmehw14"><!-- POSTPROCESSDATA: 14.1Y-vmehw14|VME bus:hardware:PIO cycle --><INDEXTARGET ID="14.1Y-vmehw15"><!-- POSTPROCESSDATA: 14.1Y-vmehw15|VME bus:user-level PIO --></PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>The CPU executes a load from a system physical address.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The system recognizes the physical address as one of its own.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The system translates the physical address into a VME bus address.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Acting as a VME bus master, the system starts a read cycle on the VME bus.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>A slave device on the VME bus responds to the VME address and returns data.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The VME controller initiates a system bus cycle to return the data packet to the CPU, thus completing the load operation.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>A store to a VME device is similar except that it performs a VME bus write, and no data is returned.</PARAGRAPH>
<PARAGRAPH>PIO input requires two system bus cycles&mdash;one to request the data and one to return it&mdash;separated by the cycle time of the VME bus. PIO output takes only one system bus cycle, and the VME bus write cycle run concurrently with the next system bus cycle. As a result, PIO input always takes at least twice as much time as PIO output.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>VME PIO Bandwidth</TITLE><PARAGRAPH>On a Challenge L or Onyx system, the maximum rate of PIO output is approximately 750K writes per second. The maximum rate of PIO input is approximately 250K reads per second. The corresponding data rate depends on the number of bytes transferred on each operation, as summarized in <INDEXTARGET ID="14.1Y-vmehw16"><!-- POSTPROCESSDATA: 14.1Y-vmehw16|VME bus:PIO to:bandwidth --><XREF IDREF="30558" TYPE="TABLE">Table&nbsp;14-1</XREF>.</PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="14-1"><PREFIX>Table 14-1 </PREFIX><XREFTARGET ID="30558">&space;VME Bus PIO Bandwidth</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="119"><PARAGRAPH>Data Unit Size</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="119"><PARAGRAPH>Read</PARAGRAPH>
</CELL>
<CELL LEFT="250" WIDTH="119"><PARAGRAPH>Write</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="119"><PARAGRAPH>D8</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="119"><PARAGRAPH>0.25 MB/second</PARAGRAPH>
</CELL>
<CELL LEFT="250" WIDTH="119"><PARAGRAPH>0.75 MB/second</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="119"><PARAGRAPH>D16</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="119"><PARAGRAPH>0.5 MB/second</PARAGRAPH>
</CELL>
<CELL LEFT="250" WIDTH="119"><PARAGRAPH>1.5 MB/second</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="119"><PARAGRAPH>D32</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="119"><PARAGRAPH>1 MB/second</PARAGRAPH>
</CELL>
<CELL LEFT="250" WIDTH="119"><PARAGRAPH>3 MB/second</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<NOTE><PREFIX>Note</PREFIX>The numbers in <XREF IDREF="30558" TYPE="TABLE">Table&nbsp;14-1</XREF> were obtained by doing continuous reads, or continuous writes, to a device in the Challenge chassis. When reads and writes alternate, add approximately 1&nbsp;microsecond for each change of direction. The use of a repeater to extend to an external card cage would add 200&nbsp;nanoseconds or more to each transfer.</NOTE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>VME DMA Operations</TITLE><PARAGRAPH>A VME device that can act as a bus master can perform DMA into memory. The general sequence of operations in this case is as follows:<INDEXTARGET ID="14.1Y-vmehw17"><!-- POSTPROCESSDATA: 14.1Y-vmehw17|Direct Memory Access (DMA):VME bus --><INDEXTARGET ID="14.1Y-vmehw18"><!-- POSTPROCESSDATA: 14.1Y-vmehw18|VME bus:hardware:DMA cycle --></PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Kernel software uses PIO to program device registers of the VME device, telling it to perform DMA to a certain VME bus address for a specified length of data.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The VME bus master initiates the first read, write, block-read, or block-write cycle on the VME bus.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The VME controller, responding as a slave device on the VME bus, recognizes the VME bus address as one that corresponds to a physical memory address in the system.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>If the bus master is writing, the VME controller accepts the data and initiates a system bus cycle to write the data to system memory.</PARAGRAPH>
<PARAGRAPH>If the bus master is reading, the VME controller uses a system bus cycle to read data from system memory, and returns the data to the bus master.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The bus master device continues to use the VME controller as a slave device until it has completed the DMA transfer.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>During a DMA transaction, the VME bus controller operates independently of any CPU. CPUs in the system execute software concurrently with the data transfer. Since the system bus is faster than the VME bus, the data transfer takes place at the maximum data rate that the VME bus master can sustain.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="99131">Operation of the DMA Engine</TITLE><PARAGRAPH>In the Challenge and Onyx lines, the VME controller contains a &ldquo;DMA Engine&rdquo; that can be programmed to perform DMA-type transfers between memory and a VME device that is a slave, not a bus master.<INDEXTARGET ID="14.1Y-vmehw19"><!-- POSTPROCESSDATA: 14.1Y-vmehw19|VME bus:DMA engine --><INDEXTARGET ID="14.1Y-vmehw20"><!-- POSTPROCESSDATA: 14.1Y-vmehw20|Challenge/Onyx:DMA engine in --><INDEXTARGET ID="14.1Y-vmehw21"><!-- POSTPROCESSDATA: 14.1Y-vmehw21|Direct Memory Access (DMA):DMA engine for VME bus --></PARAGRAPH>
<PARAGRAPH>The general course of operations in a DMA engine transfer is as follows:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>The VME bus controller is programmed to perform a DMA transfer to a certain physical address for a specified amount of data from a specified device address in VME address space.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The VME bus controller, acting as the VME bus master, initiates a block read or block write to the specified device.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>As the slave device responds to successive VME bus cycles, the VME bus controller transfers data to or from memory using the system bus.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>The DMA engine transfers data independently of any CPU, and at the maximum rate the VME bus slave can sustain. In addition, the VME controller collects smaller data units into blocks of the full system bus width, minimizing the number of system bus cycles needed to transfer data. For both these reasons, DMA engine transfers are faster than PIO transfers for all but very short transfer lengths.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>DMA Engine Bandwidth</TITLE><PARAGRAPH>The maximum performance of the DMA engine for D32 transfers is summarized in <XREF IDREF="59336" TYPE="TABLE">Table&nbsp;14-2</XREF>. Performance with D64 Block transfers is somewhat less than twice the rate shown in <XREF IDREF="59336" TYPE="TABLE">Table&nbsp;14-2</XREF>. Transfers for larger sizes are faster because the setup time is amortized over a greater number of bytes.&space;<INDEXTARGET ID="14.1Y-vmehw22"><!-- POSTPROCESSDATA: 14.1Y-vmehw22|VME bus:user-level DMA bandwidth --></PARAGRAPH>
<TABLE COLUMNS="5"><CAPTION LBL="14-2"><PREFIX>Table 14-2 </PREFIX><XREFTARGET ID="59336"> <EMPHASIS>(continued)        </EMPHASIS>VME Bus Bandwidth, DMA Engine, D32 Transfer</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="75"><PARAGRAPH>Transfer Size</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="75"><PARAGRAPH>Read</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="75"><PARAGRAPH>Write</PARAGRAPH>
</CELL>
<CELL LEFT="240" WIDTH="75"><PARAGRAPH>Block Read</PARAGRAPH>
</CELL>
<CELL LEFT="320" WIDTH="75"><PARAGRAPH>Block Write</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="75"><PARAGRAPH>32</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="75"><PARAGRAPH>2.8 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="75"><PARAGRAPH>2.6 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="240" WIDTH="75"><PARAGRAPH>2.7 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="320" WIDTH="75"><PARAGRAPH>2.7 MB/sec</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="75"><PARAGRAPH>64</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="75"><PARAGRAPH>3.8 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="75"><PARAGRAPH>3.8 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="240" WIDTH="75"><PARAGRAPH>4.0 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="320" WIDTH="75"><PARAGRAPH>3.9 MB/sec</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="75"><PARAGRAPH>128</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="75"><PARAGRAPH>5.0 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="75"><PARAGRAPH>5.3 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="240" WIDTH="75"><PARAGRAPH>5.6 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="320" WIDTH="75"><PARAGRAPH>5.8 MB/sec</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="75"><PARAGRAPH>256</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="75"><PARAGRAPH>6.0 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="75"><PARAGRAPH>6.7 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="240" WIDTH="75"><PARAGRAPH>6.4 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="320" WIDTH="75"><PARAGRAPH>7.3 MB/sec</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="75"><PARAGRAPH>512</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="75"><PARAGRAPH>6.4 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="75"><PARAGRAPH>7.7 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="240" WIDTH="75"><PARAGRAPH>7.0 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="320" WIDTH="75"><PARAGRAPH>8.0 MB/sec</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="75"><PARAGRAPH>1024</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="75"><PARAGRAPH>6.8 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="75"><PARAGRAPH>8.0 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="240" WIDTH="75"><PARAGRAPH>7.5 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="320" WIDTH="75"><PARAGRAPH>8.8 MB/sec</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="75"><PARAGRAPH>2048</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="75"><PARAGRAPH>7.0 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="75"><PARAGRAPH>8.4 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="240" WIDTH="75"><PARAGRAPH>7.8 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="320" WIDTH="75"><PARAGRAPH>9.2 MB/sec</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="75"><PARAGRAPH>4096</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="75"><PARAGRAPH>7.1 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="75"><PARAGRAPH>8.7 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="240" WIDTH="75"><PARAGRAPH>7.9 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="320" WIDTH="75"><PARAGRAPH>9.4 MB/sec</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<NOTE><PREFIX>Note</PREFIX>The throughput that can be achieved in VME DMA is very sensitive to several factors:</NOTE>
<BULLETLIST><BULLET><PARAGRAPH>The other activity on the VME bus.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The blocksize (larger is better).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Other overhead in the loop requesting DMA operations.</PARAGRAPH>
<PARAGRAPH>The loop used to generate the figures in <XREF IDREF="59336" TYPE="TABLE">Table&nbsp;14-2</XREF> contained no activity except calls to <FUNCTION>dma_start()</FUNCTION>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the response time of the target VME board to a read or write request, in particular the time from when the VME adapter raises Data Strobe (DS) and the time the slave device raises Data Acknowledge (DTACK).</PARAGRAPH>
<PARAGRAPH>For example, if the slave device takes 500&nbsp;ns to raise DTACK, there will always be fewer than 2&nbsp;M data transfers per second.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="74057">VME Bus Addresses and System Addresses</TITLE><PARAGRAPH>Devices on the VME bus exist in one of the following address spaces:<INDEXTARGET ID="14.1Y-vmehw23"><!-- POSTPROCESSDATA: 14.1Y-vmehw23|VME bus:bus address spaces --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The 16-bit space (A16) contains numbers from 0x0000 to 0xffff.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The 24-bit space (A24) contains numbers from 0x00&nbsp;0000 to 0xff&nbsp;ffff.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The 32-bit space (A32) uses numbers from 0x0000&nbsp;0000 to 0xffff&nbsp;ffff.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The 64-bit space (A64), defined in the revision D specification, uses 64-bit addresses.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The system bus also uses 32-bit or 64-bit numbers to address memory and other I/O devices on the system bus. In order to avoid conflicts between the meanings of address numbers, certain portions of the physical address space are reserved for VME use. The VME address spaces are mapped, that is, translated, into these ranges of physical addresses.</PARAGRAPH>
<PARAGRAPH>The translation is performed by the VME bus controller: It recognizes certain physical addresses on the system bus and translates them into VME bus addresses; and it recognizes certain VME bus addresses and translates them into physical addresses on the system bus.</PARAGRAPH>
<PARAGRAPH>Even with mapping, the entire A32 or A64 address space cannot be mapped into the physical address space. As a result, the system does not provide access to all of the VME address spaces. Only parts of the VME address spaces are available at any time.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>User-Level and Kernel-Level Addressing</TITLE><PARAGRAPH>In a user-level program you can perform PIO and certain types of DMA operations (see <INDEXTARGET ID="14.1Y-vmehw24"><!-- POSTPROCESSDATA: 14.1Y-vmehw24|VME bus:bus address spaces:mapping --><XREF IDREF="66996" TYPE="TITLE">Chapter&nbsp;4, &ldquo;User-Level Access to Devices&rdquo;</XREF>), but you do not program these in terms of the physical addresses mapped to the VME bus. Instead, you call on the services of a kernel-level device driver to map a portion of VME address space into the address space of your process. The requested segment of VME space is mapped dynamically to a segment of your user-level address space&mdash;a segment that can differ from one run of the program to the next.</PARAGRAPH>
<PARAGRAPH>In a kernel-level device driver, you program PIO and DMA operations in terms of specific addresses in kernel space&mdash;memory addresses that are mapped to specified addresses in the VME bus address space. The mapping is either permanent, established by the system hardware, or dynamic, set up temporarily by a kernel function.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>The remainder of this chapter has direct meaning only for kernel-level drivers, which must deal with physical mappings of VME space.</NOTE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>PIO Addressing and DMA Addressing</TITLE><PARAGRAPH>The addressing needs of PIO access and DMA access are different.</PARAGRAPH>
<PARAGRAPH>PIO deals in small amounts of data, typically single bytes or words. PIO is directed to device registers that are identified with specific VME bus addresses. The association between a device register and its bus address is fixed, typically by setting jumpers or switches on the VME card.<INDEXTARGET ID="14.1Y-vmehw25"><!-- POSTPROCESSDATA: 14.1Y-vmehw25|VME bus:PIO to:addresses --><INDEXTARGET ID="14.1Y-vmehw26"><!-- POSTPROCESSDATA: 14.1Y-vmehw26|Programmed I/O (PIO):VME bus --></PARAGRAPH>
<PARAGRAPH>DMA deals with extended segments of kilobytes or megabytes. The addresses used in DMA are not fixed in the device, but are programmed into it just before the data transfer begins. For example, a disk controller device can be programmed to read a certain sector and to write the sector data to a range of 512 consecutive bytes in the VME bus address space. The programming of the disk controller is done by storing numbers into its registers using PIO. While the registers respond only to fixed addresses that are configured into the board, the address to which the disk controller writes its sector data is just a number that is programmed into it each time a transfer is to start.<INDEXTARGET ID="14.1Y-vmehw27"><!-- POSTPROCESSDATA: 14.1Y-vmehw27|Direct Memory Access (DMA):VME bus --></PARAGRAPH>
<PARAGRAPH>The key differences between addresses used by PIO and those used for DMA are:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>PIO addresses are relatively few in number and cover small spans of data, while DMA addresses can span large ranges of data.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>PIO addresses are closely related to the hardware architecture of the device and are configured by hardware or firmware, while DMA addresses are simply parameters programmed into the device before each operation.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>In Challenge and Onyx systems, all VME mappings are dynamic, assigned as needed. Kernel functions are provided to create and release mappings between designated VME addresses and kernel addresses.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="54175">PIO Addressing in Challenge and Onyx Systems</TITLE><PARAGRAPH>The Challenge and Onyx systems and their Power versions support from one to five VME buses. It is impossible to fit adequate segments of five separate A16, A24, and A32 address spaces into fixed mappings in the 40-bit physical address space available in these systems.<INDEXTARGET ID="14.1Y-vmehw28"><!-- POSTPROCESSDATA: 14.1Y-vmehw28|VME bus:PIO to:addressing in Challenge --><INDEXTARGET ID="14.1Y-vmehw29"><!-- POSTPROCESSDATA: 14.1Y-vmehw29|Challenge/Onyx:VME bus address mapping in --></PARAGRAPH>
<PARAGRAPH>The VME controller in Challenge and Onyx systems uses programmable mappings. The IRIX kernel can program the mapping of twelve separate 8&nbsp;MB &ldquo;windows&rdquo; on VME address space on each bus (a total of 96&nbsp;MB of mapped space per bus). The kernel sets up VME mappings by setting the base addresses of these windows as required. A kernel-level VME device driver asks for and uses PIO mappings through the functions documented in &ldquo;Mapping PIO Addresses&rdquo; on page&nbsp;325. Mapping PIO Addresses</PARAGRAPH>
<PARAGRAPH>A PIO map is a system object that represents the mapping from a location in the kernel's virtual address space to some small range of addresses on a VME or EISA bus. After creating a PIO map, a device driver can use it in the following ways:<INDEXTARGET ID="14.1Y-vmehw30"><!-- POSTPROCESSDATA: 14.1Y-vmehw30|Programmed I/O (PIO):address maps for --><INDEXTARGET ID="14.1Y-vmehw31"><!-- POSTPROCESSDATA: 14.1Y-vmehw31|VME bus:PIO to:address maps --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Use the specific kernel virtual address that represents the device, either to load or store data, or to map that address into user process space.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Copy data between the device and memory without learning the specific kernel addresses involved.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Perform bus read-modify-write cycles to apply Boolean operators efficiently to device data.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The kernel virtual address returned by PIO mapping is not a physical memory address and is not a bus address. The kernel virtual address and the VME or EISA bus address need not have any bits in common.</PARAGRAPH>
<PARAGRAPH>The functions used with PIO maps are summarized in <XREF IDREF="50304" TYPE="TABLE">Table&nbsp;14-3</XREF>. </PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="14-3"><PREFIX>Table 14-3 </PREFIX><XREFTARGET ID="50304"> <EMPHASIS>(continued)        </EMPHASIS>Functions to Create and Use PIO Maps</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="108"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="41"><PARAGRAPH>Can 
Sleep</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="166"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_mapalloc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="41"><PARAGRAPH>Y</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="166"><PARAGRAPH>Allocate a PIO map.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_mapfree(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="41"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="166"><PARAGRAPH>Free a PIO map.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_badaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="41"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="166"><PARAGRAPH>Check for bus error when reading an 
address.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_badaddr_val(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="41"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="166"><PARAGRAPH>Check for bus error when reading an 
address and return the value read.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_wbadaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="41"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="166"><PARAGRAPH>Check for bus error when writing to an 
address.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_wbadaddr_val(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="41"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="166"><PARAGRAPH>Check for bus error when writing a 
specified value to an address.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_mapaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="41"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="166"><PARAGRAPH>Convert a bus address to a virtual 
address.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_bcopyin(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="41"><PARAGRAPH>Y</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="166"><PARAGRAPH>Copy data from a bus address to kernel's 
virtual space.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_bcopyout(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="41"><PARAGRAPH>Y</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="166"><PARAGRAPH>Copy data from kernel's virtual space to 
a bus address.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_andb_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="41"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="166"><PARAGRAPH>Byte read-and-write.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_andh_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="41"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="166"><PARAGRAPH>16-bit read-and-write.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_andw_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="41"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="166"><PARAGRAPH>32-bit read-and-write.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_orb_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="41"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="166"><PARAGRAPH>Byte read-or-write.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_orh_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="41"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="166"><PARAGRAPH>16-bit read-or-write.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_orw_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="41"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="166"><PARAGRAPH>32-bit read-or-write.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>A kernel-level device driver creates a PIO map by calling <INDEXTARGET ID="14.1Y-vmehw32"><!-- POSTPROCESSDATA: 14.1Y-vmehw32|kernel functions:<FUNCTION>pio_mapalloc</FUNCTION>() --><FUNCTION>pio_mapalloc()</FUNCTION>. This function performs memory allocation and so can sleep. PIO maps are typically created in the <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> entry point, where the driver first learns about the device addresses from the contents of the <VARIABLE>edt_t</VARIABLE> structure (see <XREF IDREF="14072" TYPE="TITLE">&ldquo;Entry Point edtinit()&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>The parameters to <FUNCTION>pio_mapalloc()</FUNCTION> describe the range of addresses that can be mapped in terms of</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>the bus type, ADAP_VME or ADAP_EISA from <FILENAME>sys/edt.h</FILENAME>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the bus number, when more than one bus is supported</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the address space, using constants such as PIOMAP_A24N or PIOMAP_EISA_IO from <FILENAME>sys/pio.h</FILENAME>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the starting bus address and a length</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>This call also specifies a &ldquo;fixed&rdquo; or &ldquo;unfixed&rdquo; map. The usual type is &ldquo;fixed.&rdquo; For the differences, see <XREF IDREF="15681" TYPE="TITLE">&ldquo;Fixed PIO Maps&rdquo;</XREF> and <XREF IDREF="37244" TYPE="TITLE">&ldquo;Unfixed PIO Maps&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>A call to <FUNCTION>pio_mapfree()</FUNCTION> releases a PIO map. PIO maps created by a loadable driver must be released in the <VARIABLE>pfx</VARIABLE><FUNCTION>unload()</FUNCTION> entry point (see <XREF IDREF="57773" TYPE="TITLE">&ldquo;Entry Point unload()&rdquo;</XREF> and <XREF IDREF="53871" TYPE="TITLE">&ldquo;Unloading&rdquo;</XREF>).</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Testing the PIO Map</TITLE><PARAGRAPH>The PIO map is created from the parameters that are passed. These are not validated by <FUNCTION>pio_mapalloc()</FUNCTION>. If there is any possibility that the mapped device is not installed, not active, or improperly configured, you should test the mapped address.</PARAGRAPH>
<PARAGRAPH>The <INDEXTARGET ID="14.1Y-vmehw33"><!-- POSTPROCESSDATA: 14.1Y-vmehw33|IRIX functions:<FUNCTION>pio_badaddr</FUNCTION>() --><FUNCTION>pio_badaddr()</FUNCTION> and <FUNCTION>pio_badaddr_val()</FUNCTION> functions test the mapped address to see if it is usable for input. Both functions perform the same operation: operating through a PIO map, they test a specified bus address for validity by reading 1, 2, 4, or 8 bytes from it. The <FUNCTION>pio_badaddr_val()</FUNCTION> function returns the value that it reads while making the test. This can simplify coding, as shown in <XREF IDREF="99786" TYPE="TEXT">Example&nbsp;14-1</XREF>.</PARAGRAPH>
<CODE><CAPTION LBL="14-1"><PREFIX>Example 14-1 </PREFIX><XREFTARGET ID="99786">Comparing pio_badaddr() to pio_badaddr_val()</CAPTION>unsigned int gotvalue;
piomap_t *themap;
/* Using only pio_badaddr() */
&nbsp;&nbsp;&nbsp;if (!pio_badaddr(themap,CTLREG,4)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void) pio_bcopyin(themap,CTLREG,&amp;gotvalue,4,4,0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...use "gotvalue"
/* Using pio_badaddr_val() */
&nbsp;&nbsp;&nbsp;if (!pio_badaddr_val(themap,CTLREG,4,&amp;gotvalue))
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...use "gotvalue"
</CODE>
<PARAGRAPH>The <FUNCTION>pio_wbadaddr()</FUNCTION> function tests a mapped device address for writability. The <FUNCTION>pio_wbadaddr_val()</FUNCTION> not only tests the address but takes a specific value to write to that address in the course of testing it.<INDEXTARGET ID="14.1Y-vmehw34"><!-- POSTPROCESSDATA: 14.1Y-vmehw34|kernel functions:<FUNCTION>pio_wbadaddr</FUNCTION>() --></PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using the Mapped Address</TITLE><PARAGRAPH>From a fixed PIO map you can recover a kernel virtual address that corresponds to the first bus address in the map. The <INDEXTARGET ID="14.1Y-vmehw35"><!-- POSTPROCESSDATA: 14.1Y-vmehw35|kernel functions:<FUNCTION>pio_mapaddr</FUNCTION>() --><FUNCTION>pio_mapaddr()</FUNCTION> function is used for this.</PARAGRAPH>
<PARAGRAPH>You can use this address to load or store data into device registers. In the <VARIABLE>pfx</VARIABLE><FUNCTION>map()</FUNCTION> entry point (see <XREF IDREF="34808" TYPE="TITLE">&ldquo;Concepts and Use of mmap()&rdquo;</XREF>), you can use this address with the <FUNCTION>v_mapphys()</FUNCTION> function to map the range of device addresses into the address space of a user process.</PARAGRAPH>
<PARAGRAPH>You cannot extract a kernel address from an unfixed PIO map, as explained under <XREF IDREF="37244" TYPE="TITLE">&ldquo;Unfixed PIO Maps&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using the PIO Map in Functions</TITLE><PARAGRAPH>You can apply a variety of kernel functions to any PIO map, fixed or unfixed. The <INDEXTARGET ID="14.1Y-vmehw36"><!-- POSTPROCESSDATA: 14.1Y-vmehw36|kernel functions:<FUNCTION>pio_bcopyout</FUNCTION>() --><INDEXTARGET ID="14.1Y-vmehw37"><!-- POSTPROCESSDATA: 14.1Y-vmehw37|kernel functions:<FUNCTION>pio_bcopyin</FUNCTION>() --><FUNCTION>pio_bcopyin()</FUNCTION> and <FUNCTION>pio_bcopyout()</FUNCTION> functions copy a range of data between memory and a fixed or unfixed PIO map. These functions are optimized to the hardware that exists, and they do all transfers in the largest size possible (32 or 64 bits per transfer). If you must transfer data in specific sizes of 1 or 2 bytes, use direct loads/stores to mapped addresses.</PARAGRAPH>
<PARAGRAPH>The series of functions <FUNCTION>pio_andb_rmw()</FUNCTION> and <FUNCTION>pio_orb_rmw()</FUNCTION> perform a read-modify-write cycle on the VME bus. You can use them to set or clear bits in device registers. A read-modify-write cycle is faster than a load followed by a store since it uses fewer system bus cycles.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="15681">Fixed PIO Maps</TITLE><PARAGRAPH>On a Challenge or Onyx system, a PIO map can be either &ldquo;fixed&rdquo; or &ldquo;unfixed.&rdquo; This attribute is specified when the map is created.<INDEXTARGET ID="14.1Y-vmehw38"><!-- POSTPROCESSDATA: 14.1Y-vmehw38|fixed PIO map --><INDEXTARGET ID="14.1Y-vmehw39"><!-- POSTPROCESSDATA: 14.1Y-vmehw39|VME bus:PIO to:fixed, unfixed maps --></PARAGRAPH>
<PARAGRAPH>The Challenge and Onyx architecture provides for a total of 15 separate, 8&nbsp;MB windows on VME address space for each VME bus. Two of these are permanently reserved to the kernel, and one window is reserved for use with unfixed mappings. The remaining 12 windows are available to implement fixed PIO maps.<INDEXTARGET ID="14.1Y-vmehw40"><!-- POSTPROCESSDATA: 14.1Y-vmehw40|Challenge/Onyx:VME address windows --></PARAGRAPH>
<PARAGRAPH>When the kernel creates a fixed PIO map, the map is associated with one of the 12 available VME mapping windows. The kernel tries to be clever, so that whenever a PIO map falls within an 8&nbsp;MB window that already exists, the PIO map uses that window. If the desired VME address is not covered by an open window, one of the twelve windows for that bus is opened to expose a mapping for that address.</PARAGRAPH>
<PARAGRAPH>It is possible in principle to configure thirteen devices that are scattered so widely in the A32 address space that twelve, 8&nbsp;MB windows cannot cover all of them. In that unlikely case, the attempt to create the thirteenth fixed PIO map will fail for lack of a mapping window.</PARAGRAPH>
<PARAGRAPH>In order to prevent this, simply configure your PIO addresses into a span of at most 96&nbsp;MB per bus (see <XREF IDREF="96034" TYPE="TITLE">&ldquo;Configuring Device Addresses&rdquo;</XREF>).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="37244">Unfixed PIO Maps</TITLE><PARAGRAPH>When you create an unfixed PIO map, the map is not associated with any of the twelve mapping windows. As a result, the map cannot be queried for a kernel address that might be saved, or mapped into user space.</PARAGRAPH>
<PARAGRAPH>You can use an unfixed map with kernel functions that copy data or perform read-modify-write cycles. These functions use the one mapping window that is reserved for unfixed maps, repositioning it in VME space if necessary.</PARAGRAPH>
<PARAGRAPH>The <COMMAND>lboot</COMMAND> command uses an unfixed map to perform the <COMMAND>probe</COMMAND> and <COMMAND>exprobe</COMMAND> sequences from VECTOR statements (see <XREF IDREF="34376" TYPE="TITLE">&ldquo;Configuring the System Files&rdquo;</XREF>). As a result, these probes do not tie up mapping windows.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>DMA Addressing</TITLE><PARAGRAPH>DMA is supported only for the A24 and A32 address spaces. DMA addresses are always assigned dynamically in the Challenge and Onyx systems.<INDEXTARGET ID="14.1Y-vmehw41"><!-- POSTPROCESSDATA: 14.1Y-vmehw41|VME bus:DMA to:addresses --></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="14998">Mapping DMA Addresses</TITLE><PARAGRAPH>A DMA map is a system object that represents a mapping between a buffer in kernel virtual space and a range of VME bus addresses. After creating a DMA map, a driver uses the map to specify the target address and length to be programmed into a VME bus master before a DMA transfer.<INDEXTARGET ID="14.1Y-vmehw42"><!-- POSTPROCESSDATA: 14.1Y-vmehw42|VME bus:DMA to:address maps --></PARAGRAPH>
<PARAGRAPH>The functions that operate on DMA maps are summarized in <XREF IDREF="38477" TYPE="TABLE">Table&nbsp;14-4</XREF>. </PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="14-4"><PREFIX>Table 14-4 </PREFIX><XREFTARGET ID="38477"> <EMPHASIS>(continued)        </EMPHASIS>Functions That Operate on DMA Maps</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="83"><PARAGRAPH>&lbreak;Function</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="51"><PARAGRAPH>Header 
Files</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="45"><PARAGRAPH>&lbreak;Can Sleep</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="207"><PARAGRAPH>&lbreak;Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH><REFPAGE>dma_map(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="51"><PARAGRAPH>dmamap.h 
&amp; types.h 
&amp; sema.h</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="207"><PARAGRAPH>Load DMA mapping registers for an imminent 
transfer.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH><REFPAGE>dma_mapbp(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="51"><PARAGRAPH>dmamap.h 
&amp; types.h 
&amp; sema.h</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="207"><PARAGRAPH>Load DMA mapping registers for an imminent 
transfer.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH><REFPAGE>dma_mapaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="51"><PARAGRAPH>dmamap.h 
&amp; types.h 
&amp; sema.h</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="207"><PARAGRAPH>Return the &ldquo;bus virtual&rdquo; address for a given map 
and address.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH><REFPAGE>dma_mapalloc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="51"><PARAGRAPH>dmamap.h 
&amp; types.h 
&amp; sema.h</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="45"><PARAGRAPH>Y</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="207"><PARAGRAPH>Allocate a DMA map.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH><REFPAGE>dma_mapfree(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="51"><PARAGRAPH>dmamap.h 
&amp; types.h 
&amp; sema.h</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="207"><PARAGRAPH>Free a DMA map.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH><REFPAGE>vme_adapter(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="51"><PARAGRAPH>vmereg.h 
&amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="207"><PARAGRAPH>Determine VME adapter that corresponds to a 
given memory address.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>A device driver allocates a DMA map using <INDEXTARGET ID="14.1Y-vmehw43"><!-- POSTPROCESSDATA: 14.1Y-vmehw43|kernel functions:<FUNCTION>dma_mapalloc</FUNCTION>() --><FUNCTION>dma_mapalloc()</FUNCTION>. This is typically done in the <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> entry point, provided that the maximum I/O size is known at that time (see <XREF IDREF="14072" TYPE="TITLE">&ldquo;Entry Point edtinit()&rdquo;</XREF>). The important argument to <FUNCTION>dma_mapalloc()</FUNCTION> is the maximum number of pages (I/O pages, the unit is IO_NBPP declared in <FILENAME>sys/immu.h</FILENAME>) to be mapped at one time.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>In the Challenge and Onyx systems, a limit of 64&nbsp;MB of mapped DMA space per VME adapter is imposed by the hardware. Some few megabytes of this are taken early by system drivers. Owing to a bug in IRIX 5.3 and 6.1, a request for 64&nbsp;MB or more is not rejected, but waits forever. However, in any release, a call to <INDEXTARGET ID="14.1Y-vmehw44"><!-- POSTPROCESSDATA: 14.1Y-vmehw44|Challenge/Onyx:limit on VME DMA space --><FUNCTION>dma_mapalloc()</FUNCTION> that requests a single map close to the 64&nbsp;MB limit is likely to wait indefinitely for enough map space to become available. </NOTE>
<PARAGRAPH>DMA maps created by a loadable driver should be released in the <VARIABLE>pfx</VARIABLE><FUNCTION>unload()</FUNCTION> entry point (see <XREF IDREF="57773" TYPE="TITLE">&ldquo;Entry Point unload()&rdquo;</XREF> and <XREF IDREF="53871" TYPE="TITLE">&ldquo;Unloading&rdquo;</XREF>).</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Using a DMA Map</TITLE><PARAGRAPH>A DMA map is used prior to a DMA transfer into or out of a buffer in kernel virtual space. The function <INDEXTARGET ID="14.1Y-vmehw45"><!-- POSTPROCESSDATA: 14.1Y-vmehw45|kernel functions:<FUNCTION>dma_map</FUNCTION>() --><FUNCTION>dma_map()</FUNCTION> takes a DMA map, a buffer address, and a length. It assigns a span of contiguous VME addresses of the specified length, and sets up a mapping between that range of VME addresses and the physical addresses that represent the specified buffer.</PARAGRAPH>
<PARAGRAPH>When the buffer spans two or more physical pages (IO_NBPP units), <FUNCTION>dma_map()</FUNCTION> sets up a scatter/gather operation, so that the VME bus controller will place the data in the appropriate page frames.</PARAGRAPH>
<PARAGRAPH>It is possible that <FUNCTION>dma_map()</FUNCTION> cannot map the entire size of the buffer. This can occur only when the buffer spans two or more pages, and is caused by a shortage of mapping registers in the bus adapter. The function maps as much of the buffer as it can, and returns the length of the mapped data. You must always anticipate that <FUNCTION>dma_map()</FUNCTION> might map less than the requested number of bytes, so that the DMA transfer has to be done in two or more operations.</PARAGRAPH>
<PARAGRAPH>Following the call to <INDEXTARGET ID="14.1Y-vmehw46"><!-- POSTPROCESSDATA: 14.1Y-vmehw46|kernel functions:<FUNCTION>dma_mapaddr</FUNCTION>() --><FUNCTION>dma_map()</FUNCTION>, you call <FUNCTION>dma_mapaddr()</FUNCTION> to get the bus virtual address that represents the first byte of the buffer. This is the address you program into the bus master device (using a PIO store), in order to set its starting transfer address. Then you initiate the DMA transfer (again by storing a command into a device register using PIO).</PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="82448">Configuring VME Devices</TITLE><PARAGRAPH>To install a VME device in a Challenge or Onyx system, you need to configure the device itself to respond to PIO addresses in a supported range of VME bus addresses, and you need to inform IRIX of the device addresses.<INDEXTARGET ID="14.1Y-vmehw47"><!-- POSTPROCESSDATA: 14.1Y-vmehw47|VME bus:configuring --></PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="96034">Configuring Device Addresses</TITLE><PARAGRAPH>Normally a VME card can be programmed to use different VME addresses for PIO, based on jumper or switch settings on the card. The devices on a single VME bus must be configured to use unique addresses. Errors that are hard to diagnose can arise when multiple cards respond to the same bus address. Devices on different VME buses can use the same addresses. Not all parts of each address space are accessible. The accessible parts are summarized in <XREF IDREF="64638" TYPE="TABLE">Table&nbsp;14-5</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="14-5"><PREFIX>Table 14-5 </PREFIX><XREFTARGET ID="64638"> <EMPHASIS>(continued)        </EMPHASIS>Accessible VME Addresses in Challenge and Onyx Systems</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="64"><PARAGRAPH>Address Space</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="288"><PARAGRAPH>Challenge and Onyx Systems</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="64"><PARAGRAPH>A16</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="288"><PARAGRAPH>All</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="64"><PARAGRAPH>A24</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="288"><PARAGRAPH>0x80&nbsp;0000&ndash;0xFF&nbsp;FFFF</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="64"><PARAGRAPH>A32</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="288"><PARAGRAPH>0x0000&nbsp;0000&ndash;0x7FFF&nbsp;FFFF (maximum of 96&nbsp;MB in 8&nbsp;MB units)</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Within the accessible ranges, certain VME bus addresses are used by VME devices. You can find these addresses documented in the <FILENAME>/var/sysgen/system/irix.sm</FILENAME> file. You must configure OEM devices to avoid the addresses used by Silicon Graphics devices that are installed on the same system.</PARAGRAPH>
<PARAGRAPH>Finally, on the Challenge and Onyx systems, take care to cluster PIO addresses in the A32 space so that they occupy at most a 96&nbsp;MB span of addresses. The reasons are explained under <XREF IDREF="15681" TYPE="TITLE">&ldquo;Fixed PIO Maps&rdquo;</XREF>. </PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="34376">Configuring the System Files</TITLE><PARAGRAPH>Inform IRIX and the device driver of the existence of a VME device by adding a VECTOR statement to a file in the directory <INDEXTARGET ID="14.1Y-vmehw48"><!-- POSTPROCESSDATA: 14.1Y-vmehw48|configuration files:<FILENAME>/var/sysgen/system/irix.sm</FILENAME>VME devices --><INDEXTARGET ID="14.1Y-vmehw49"><!-- POSTPROCESSDATA: 14.1Y-vmehw49|VECTOR statement:VME devices --><FILENAME>/var/sysgen/system</FILENAME> (see <XREF IDREF="28517" TYPE="TITLE">&ldquo;Kernel Configuration Files&rdquo;</XREF>). The syntax of a VECTOR statement is documented in two places:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The <FILENAME>/var/sysgen/system/irix.sm</FILENAME> file itself contains descriptive comments on the syntax and meaning of the statement, as well as numerous examples.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The <REFPAGE>system(4)</REFPAGE> reference page gives a more formal definition of the syntax.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>In addition to the VECTOR statement, you may need to code an IPL statement.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Coding the VECTOR Statement</TITLE><PARAGRAPH>The important elements in a VECTOR line are as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="75"><PARAGRAPH><COMMAND>bustype</COMMAND>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="310"><PARAGRAPH>Specified as <COMMAND>VME</COMMAND> for VME devices. The VECTOR statement can be 
used for other types of buses as well.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="75"><PARAGRAPH><COMMAND>module</COMMAND>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="310"><PARAGRAPH>The base name of the device driver for this device, as used in the 
<FILENAME>/var/sysgen/master.d</FILENAME> database (see <XREF IDREF="91260" TYPE="TITLE">&ldquo;Master Configuration Database&rdquo;</XREF> and <XREF IDREF="69523" TYPE="TITLE">&ldquo;How Names Are Used in Configuration&rdquo;</XREF>).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="75"><PARAGRAPH><COMMAND>adapter</COMMAND>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="310"><PARAGRAPH>The number of the VME bus where the device is attached&mdash;the bus 
number in a Challenge or Onyx machine.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="75"><PARAGRAPH><COMMAND>ipl</COMMAND>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="310"><PARAGRAPH>The interrupt level at which the device causes interrupts, from 0 to 7.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="75"><PARAGRAPH><COMMAND>vector</COMMAND>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="310"><PARAGRAPH>An 8-bit value between 1 and 254 that the device returns during an 
interrupt acknowledge cycle.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="75"><PARAGRAPH><COMMAND>ctlr</COMMAND>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="310"><PARAGRAPH>The &ldquo;controller&rdquo; number is simply an integer parameter that is passed 
to the device driver at boot time. It can be used for example to specify 
a logical unit number.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="75"><PARAGRAPH><COMMAND>iospace</COMMAND>, <COMMAND>iospace2</COMMAND>, 
<COMMAND>iospace3</COMMAND>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="310"><PARAGRAPH>Each <COMMAND>iospace</COMMAND> group specifies the VME address space, the starting bus 
address, and the size of a segment of VME address space used by this 
device.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="75"><PARAGRAPH><COMMAND>probe</COMMAND> or <COMMAND>exprobe</COMMAND>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="310"><PARAGRAPH>Specify a hardware test that can be applied at boot time to find out if 
the device exists.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Use the <COMMAND>probe</COMMAND> or <COMMAND>exprobe</COMMAND> parameter to program a test for the existence of the device at boot time. If the device does not respond (because it is offline or because it has been removed from the system), the <COMMAND>lboot</COMMAND> command will not invoke the device driver for this device.</PARAGRAPH>
<PARAGRAPH>The device driver specified by the <COMMAND>module</COMMAND> parameter is invoked at its <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> entry point, where it receives most of the other information specified in the VECTOR statement (see <XREF IDREF="14072" TYPE="TITLE">&ldquo;Entry Point edtinit()&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>Omit the <COMMAND>vector</COMMAND> parameter in either of two cases: when the device does not cause interrupts, or when it supports a programmable interrupt vector (see <XREF IDREF="80180" TYPE="TITLE">&ldquo;Allocating an Interrupt Vector Dynamically&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>Use the <COMMAND>iospace</COMMAND> parameters to pass in the exact VME bus addresses that correspond to this device, as configured in the device. Up to three address space ranges can be passed to the driver. This does not restrict the device&mdash;it can use other ranges of addresses, but the device driver has to deduce their addresses from other information. The device driver typically uses this data to set up PIO maps (see <XREF IDREF="54175" TYPE="TITLE">&ldquo;PIO Addressing in Challenge and Onyx Systems&rdquo;</XREF>)</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using the IPL Statement</TITLE><PARAGRAPH>In a Challenge or Onyx system, you can direct VME interrupts to specific CPUs. This is done with the IPL statement, also written into a file in <INDEXTARGET ID="14.1Y-vmehw50"><!-- POSTPROCESSDATA: 14.1Y-vmehw50|Challenge/Onyx:directing interrupts --><INDEXTARGET ID="14.1Y-vmehw51"><!-- POSTPROCESSDATA: 14.1Y-vmehw51|IPL statement --><FILENAME>/var/sysgen/system</FILENAME>. The IPL statement, which like the VECTOR statement is documented in both the <REFPAGE>system(4)</REFPAGE> reference page and the <FILENAME>/var/sysgen/system/irix.sm</FILENAME> file itself, has only two parameters: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>level</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The VME interrupt level to be directed, 0 to 7 (the same value that is 
coded as <COMMAND>ipl=</COMMAND> in the VECTOR statement.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>cpu</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The number of the CPU that should handle all VME interrupts at this 
level.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The purpose of the IPL statement is to send interrupts from specific devices to a specific CPU. There are two contradictory reasons for doing this:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>That CPU is dedicated to handling those interrupts with minimum latency</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Those interrupts would disrupt high-priority work being done on other CPUs if they were allowed to reach the other CPUs.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The IPL statement cannot direct interrupts from a specific device; it directs all interrupts that occur at the specified level.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="80180">Allocating an Interrupt Vector Dynamically</TITLE><PARAGRAPH>When a VME device generates an interrupt, the Silicon Graphics VME controller initiates an interrupt acknowledge (IACK) cycle on the VME bus. During this cycle, the interrupting device presents a data value that characterizes the interrupt. This is the <INDEXTARGET ID="14.1Y-vmehw52"><!-- POSTPROCESSDATA: 14.1Y-vmehw52|VME bus:interrupt vector --><GLOSSARYITEM>interrupt vector</GLOSSARYITEM>, in VME terminology.</PARAGRAPH>
<PARAGRAPH>According to the VME standard, the interrupt vector can be a data item of 8, 16, or 32 bits. However, Challenge and Onyx systems accept only an 8-bit vector, and its value must fall in the range 1-254 inclusive. (0x00 and 0xFF are excluded because they could be generated by a hardware fault.)</PARAGRAPH>
<PARAGRAPH>The interrupt vector returned by some VME devices is hard-wired or configured into the board with switches or jumpers. When this is the case, the vector number should be written as the <COMMAND>vector</COMMAND> parameter in the VECTOR statement that describes the device (see <XREF IDREF="34376" TYPE="TITLE">&ldquo;Configuring the System Files&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>Some VME devices are programmed with a vector number at runtime. For these devices, you omit the <COMMAND>vector</COMMAND> parameter, or give its value as an asterisk. In the device driver, you use the functions in <XREF IDREF="53301" TYPE="TABLE">Table&nbsp;14-6</XREF> to choose a vector number.</PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="14-6"><PREFIX>Table 14-6 </PREFIX><XREFTARGET ID="53301"> <EMPHASIS>(continued)        </EMPHASIS>Functions to Manage Interrupt Vector Values</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="86"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="84"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="45"><PARAGRAPH>Can Sleep</PARAGRAPH>
</CELL>
<CELL LEFT="235" WIDTH="151"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="86"><PARAGRAPH><REFPAGE>vme_ivec_alloc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="84"><PARAGRAPH>vmereg.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="235" WIDTH="151"><PARAGRAPH>Allocate a VME bus interrupt vector.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="86"><PARAGRAPH><REFPAGE>vme_ivec_free(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="84"><PARAGRAPH>vmereg.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="235" WIDTH="151"><PARAGRAPH>Free a VME bus interrupt vector.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="86"><PARAGRAPH><REFPAGE>vme_ivec_set(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="84"><PARAGRAPH>vmereg.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="235" WIDTH="151"><PARAGRAPH>Register a VME bus interrupt vector.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<SECTION3 LBL="" HELPID = ""><TITLE>Allocating a Vector</TITLE><PARAGRAPH>In the <INDEXTARGET ID="14.1Y-vmehw53"><!-- POSTPROCESSDATA: 14.1Y-vmehw53|kernel functions:<FUNCTION>vme_ivec_alloc</FUNCTION>() --><VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> entry point, the device driver selects a vector number for the device to use. The best way to select a number is to call <FUNCTION>vme_ivec_alloc()</FUNCTION>, which returns a number that has not been registered for that bus, either dynamically or in a VECTOR line.</PARAGRAPH>
<PARAGRAPH>The driver then uses <INDEXTARGET ID="14.1Y-vmehw54"><!-- POSTPROCESSDATA: 14.1Y-vmehw54|kernel functions:<FUNCTION>vme_ivec_set</FUNCTION>() --><FUNCTION>vme_ivec_set()</FUNCTION> to register the chosen vector number. This function takes parameters that specify</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The vector number</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The bus number to which it applies</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The address of the interrupt handler for this vector&mdash;typically but not necessarily the name of the <VARIABLE>pfx</VARIABLE><FUNCTION>intr()</FUNCTION> entry point of the same driver</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>An integer value to be passed to the interrupt entry point&mdash;typically but not necessarily the vector number</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The <FUNCTION>vme_ivec_set()</FUNCTION> function simply registers the number in the kernel, with the following two effects:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The <FUNCTION>vme_ivec_alloc()</FUNCTION> function does not return the same number to another call until the number is released.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The specified handler is called when any device presents this vector number on an interrupt.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Multiple devices can present the identical vector, provided that the interrupt handler has some way of distinguishing one device from another.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>If you are working with both the VME and EISA interfaces, it is worth noting that the number and types of arguments of <FUNCTION>vme_ivec_set()</FUNCTION> differ from the similar EISA support function <FUNCTION>eisa_ivec_set()</FUNCTION>.</NOTE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Releasing a Vector</TITLE><PARAGRAPH>There is a limit of 254 vector numbers per bus, so it is a good idea for a loadable driver, in its <INDEXTARGET ID="14.1Y-vmehw55"><!-- POSTPROCESSDATA: 14.1Y-vmehw55|kernel functions:<FUNCTION>vme_ivec_free</FUNCTION>() --><VARIABLE>pfx</VARIABLE><FUNCTION>unload()</FUNCTION> entry point, to release a vector by calling <FUNCTION>vme_ivec_free()</FUNCTION> (see <XREF IDREF="57773" TYPE="TITLE">&ldquo;Entry Point unload()&rdquo;</XREF> and <XREF IDREF="53871" TYPE="TITLE">&ldquo;Unloading&rdquo;</XREF>).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Vector Errors</TITLE><PARAGRAPH>A common problem with programmable vectors in the Challenge or Onyx systems is the appearance of the following warning in the SYSLOG file:<INDEXTARGET ID="14.1Y-vmehw56"><!-- POSTPROCESSDATA: 14.1Y-vmehw56|VME bus:stray interrupt cause --><INDEXTARGET ID="14.1Y-vmehw57"><!-- POSTPROCESSDATA: 14.1Y-vmehw57|stray VME interrupt --></PARAGRAPH>
<EXAMPLE>
Warning: Stray VME interrupt: vector =0xff
</EXAMPLE>
<PARAGRAPH>One possible cause of this error is that the board is emitting the wrong interrupt vector; another is that the board is emitting the correct vector but with the wrong timing, so that the VME bus adapter samples all-binary-1 instead. Both these conditions can be verified with a VME bus analyzer. In the Challenge or Onyx hardware design, the most likely cause is the presence of empty slots in the VME card cage. All empty slots must be properly jumpered in order to pass interrupts correctly.</PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="79297">VME Hardware in Challenge and Onyx Systems</TITLE><PARAGRAPH>The overview topic, <INDEXTARGET ID="14.1Y-vmehw58"><!-- POSTPROCESSDATA: 14.1Y-vmehw58|Challenge/Onyx:VME hardware --><INDEXTARGET ID="14.1Y-vmehw59"><!-- POSTPROCESSDATA: 14.1Y-vmehw59|VME bus:hardware:Challenge --><XREF IDREF="41896" TYPE="TITLE">&ldquo;VME Bus in Challenge and Onyx Systems&rdquo;</XREF>, provides sufficient orientation for most users of VME devices. However, if you are designing hardware or a high-performance device driver specifically for the Challenge and Onyx systems, the details in this topic are important.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>For information on physical cabinets, panels, slot numbering, cables and jumpers, and data about dimensions and airflow, refer to the Owner's Guide manual for your machine. For example, see the <DOCTITLE>POWER CHALLENGE AND CHALLENGE XL Rackmount Owner's Guide</DOCTITLE> (007-1735) for the physical layout and cabling of VME busses in the large Challenge systems.</NOTE>
<SECTION2 LBL="" HELPID = ""><TITLE>VME Hardware Architecture</TITLE><PARAGRAPH>The VME bus interface circuitry for Challenge and Onyx systems resides on a mezzanine board called the VMEbus Channel Adapter Module (VCAM) board. One VCAM board is standard in every system and mounts directly on top of the IO4 board in the system card cage.<INDEXTARGET ID="14.1Y-vmehw60"><!-- POSTPROCESSDATA: 14.1Y-vmehw60|VMEbus Channel Adapter Module (VCAM) board --></PARAGRAPH>
<PARAGRAPH>The IO4 board is the heart of the I/O subsystem. The IO4 board supplies the system with a basic set of I/O controllers and system boot and configuration devices such as serial and parallel ports, and Ethernet.<INDEXTARGET ID="14.1Y-vmehw61"><!-- POSTPROCESSDATA: 14.1Y-vmehw61|Challenge/Onyx:IO4 board --><INDEXTARGET ID="14.1Y-vmehw62"><!-- POSTPROCESSDATA: 14.1Y-vmehw62|IO4 board --></PARAGRAPH>
<PARAGRAPH>In addition, the IO4 board provides these interfaces:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>two Flat Cable Interconnects (FCIs) for connection to Card Cage 3 (CC3)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>two SCSI-2 cable connections</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>two Ibus connections</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>A Challenge or Onyx system can contain multiple IO4 boards, which can operate in parallel. (Early versions of the IO4 have a possible hardware problem that is described in <XREF IDREF="43623" TYPE="TITLE">Appendix&nbsp;B, &ldquo;Challenge DMA with Multiple IO4 Boards&rdquo;</XREF>.)</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Main System Bus</TITLE><PARAGRAPH>The main set of buses in the Challenge and Onyx system architecture is the Everest address and data buses, Ebus for short. The Ebus provides a 256-bit data bus and a 40-bit address bus that can sustain a bandwidth of 1.2 GB per second. </PARAGRAPH>
<PARAGRAPH>The 256-bit data bus provides the data transfer capability to support a large number of high-performance RISC CPUs. The 40-bit address bus is also wide enough to support 16&nbsp;GB of contiguous memory in addition to an 8 GB I/O address space. </PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Ibus</TITLE><PARAGRAPH>The 64-bit Ibus (also known as the HIO bus) is the main internal bus of the I/O subsystem and interfaces to the high-power Ebus through a group of bus adapters.The Ibus has a bandwidth of 320 MB per second that can sufficiently support a graphics subsystem, a VME64 bus, and as many as eight SCSI channels operating simultaneously. </PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Bus Interfacing</TITLE><PARAGRAPH>Communication with the VME and SCSI buses, the installed set or sets of graphics boards, and Ethernet takes place through the 64-bit Ibus. The Ibus interfaces to the main system bus, the 256-bit Ebus, through a set of interface control devices, an I address (IA) and four I data (ID). The ID ASICs latch the data, and the IA ASIC clocks the data from each ID to the Flat Cable Interface (FCI) through the F controller (or F chip).</PARAGRAPH>
<PARAGRAPH>Two FCI controllers (or F controllers) help handle the data transfers to and from an internal graphics board set (if present) and any VMEbus boards in optional CC3 applications. The SCSI-2 (S1) controller serves as an interface to the various SCSI-2 buses. The Everest peripheral controller (EPC) device manages the data movement to and from the Ethernet, a parallel port, and various types of on-board PROMs and RAM.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Maximum Latency</TITLE><PARAGRAPH>The worst-case delay for the start of a VME access, if all of the devices on the IO4 simultaneously request the IO channel for a 128 byte write and the VME adapter receives the grant last, the VME access start could be delayed for a total of about 2&nbsp;microseconds. Only a VME read would suffer this delay; a VME write would not.</PARAGRAPH>
<PARAGRAPH>There is a another potential delay from an independent cause, which depends on the number of bus master (IO4 and CPU) boards on the system bus. If all the E-bus masters in a fairly large configuration hit the bus at once, a VME read or write could be held up by as much as 1 microsecond in a large system.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>VME Bus Numbering</TITLE><PARAGRAPH>The Challenge and Onyx systems support up to five independent VME buses in a single system. The numbering of these buses is not sequential.<INDEXTARGET ID="14.1Y-vmehw63"><!-- POSTPROCESSDATA: 14.1Y-vmehw63|Challenge/Onyx:VME bus numbers --></PARAGRAPH>
<PARAGRAPH>There is always a VME bus number 0. This is the bus connected to the system midplane. It is always connected by the primary IO4 board (the IO4 board attached to the highest slot on the system bus). Bus numbers for other VME buses depend on the Ebus slot number where their IO4 is attached, and on the I/O adapter number of the VCAM card on the IO4. Each IO4 board supports adapter numbers from 1 to 7, but a VME bus can only be attached to adapter number 2, 3, 5, or 6. These four adapters are given VME index numbers of 0, 1, 2, and 3 respectively.</PARAGRAPH>
<PARAGRAPH>The bus number of a VME bus is given by E*4+A, where E is the Ebus slot of the IO4 card, and A is the index of the adapter on the IO4. A VME bus attached through adapter 3 on the IO4 in Ebus slot 13 is bus number 53, from the sum of adapter index 1 and 4 times the slot number.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>VMEbus Channel Adapter Module (VCAM) Board</TITLE><PARAGRAPH>The VCAM board provides the interface between the Ebus and the VMEbus and manages the signal level conversion between the two buses. The VCAM also provides a pass-through connection that ties the graphics subsystem to the Ebus. The VCAM can operate as either a master or a slave. It supports DMA-to-memory transactions on the Ebus and programmed I/O (PIO) operations from the system bus to addresses on the VMEbus. In addition, the VCAM provides virtual address translation capability and a DMA engine that increases the performance of non-DMA VME boards.<INDEXTARGET ID="14.1Y-vmehw64"><!-- POSTPROCESSDATA: 14.1Y-vmehw64|VMEbus Channel Adapter Module (VCAM) board --></PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>VMECC</TITLE><PARAGRAPH>The VMECC (VME cache controller) gate array is the major active device on the VCAM. The VMECC interfaces and translates host CPU operations to VMEbus operations (see <INDEXTARGET ID="14.1Y-vmehw65"><!-- POSTPROCESSDATA: 14.1Y-vmehw65|VME Cache Controller (VMECC) --><XREF IDREF="88655" TYPE="GRAPHIC">Figure&nbsp;14-2</XREF>). The VMECC also decodes VMEbus operations to translate for the host side.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="13-vmecc.diagram.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="14-2"><PREFIX>Figure 14-2 </PREFIX><XREFTARGET ID="88655">VMECC, the VMEbus Adapter</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>The VMECC provides the following features:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>an internal DMA engine to speed copies between physical memory and VME space (see <XREF IDREF="99131" TYPE="TITLE">&ldquo;Operation of the DMA Engine&rdquo;</XREF>)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>a 16-entry deep PIO FIFO to smooth writing to the VME bus from the host CPUs</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>a built-in VME interrupt handler and built-in VME bus arbiter</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>an explicit internal delay register to aid in spacing PIOs for VME controller boards that cannot accept back-to-back operations</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>support for issuing A16, A24, A32, and A64 addressing modes as a bus master during PIO</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>support for single-item transfers (D8, D16, D32, and D64) as bus master during PIO</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>support for response as a slave to A24, A32, and A64 addressing modes to provide DMA access to the Ebus</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>support for single-item transfers (D8, D16, and D32) as a slave during DMA access to the Ebus</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>support for block item transfers (D8, D16, D32, and D64) as a slave during DMA access to the Ebus</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The VMECC also provides four levels of VMEbus request grants, 0-3 (3 has the highest priority), for DMA arbitration. Do not confuse these bus request levels with the interrupt priority levels 1-7. Bus requests prioritize the use of the physical lines representing the bus and are normally set by means of jumpers on the interface board. </PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>F Controller ASIC </TITLE><PARAGRAPH>Data transfers between VME controller boards and the host CPU(s) takes place through the VMECC on the VCAM board, then through a flat cable interface (FCI), and onto the F controller ASIC. </PARAGRAPH>
<PARAGRAPH>The F controller acts as an interface between the Ibus and the Flat Cable Interfaces (FCIs). This device is primarily composed of FIFO registers and synchronizers that provide protocol conversion and buffer transactions in both directions and translate 34-bit I/O addresses into 40-bit system addresses.</PARAGRAPH>
<PARAGRAPH>Two configurations of the F controller are used on the IO4 board; the difference between them is the instruction set they contain. One version is programmed with a set of instructions designed to communicate with the GFXCC (for graphics); the other version has instructions designed for the VMECC. All communication with the GFXCC or VMECC ICs is done over the FCI, where the F controller is always the slave. Both versions of F controller ASICs have I/O error-detection and handling capabilities. Data errors that occur on either the Ibus or the FCI are recorded by the F controller and sent to the VMECC or GFXCC.</PARAGRAPH>
<PARAGRAPH>ICs must report an error to the appropriate CPU and log any specific information about the operation in progress. FCI errors are recorded in the error status register, which provides status of the first error that occurred, and the cause of the most recent FCI reset.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>VMEbus Interrupt Generation</TITLE><PARAGRAPH>The VME bus supports seven levels of prioritized interrupts, 1 through 7 (where 7 has the highest priority). The VMECC has a register associated with each level. When the system responds to the VMEbus interrupt, it services all devices identified in the interrupt vector register in order of their VMEbus priority (highest number first).</PARAGRAPH>
<PARAGRAPH>The following list outlines how a VMEbus interrupt is generated:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>A VME controller board asserts a VME interrupt on one of the IRQ levels.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The built-in interrupt handler in the VMECC chip checks if the interrupt level is presently enabled by an internal interrupt mask.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The interrupt handler in the VMECC issues a bussed IACK (interrupt acknowledge) response and acquires the vector from the device. The 3-bit response identifies one of the seven VME levels.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>If multiple VME boards are present, the bussed IACK signal is sent to the first VME controller as an IACKIN. When the first controller is not the requesting master, it passes the IACKIN signal to the next board (in the daisy-chain) as IACKOUT.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The requesting board responds to IACKIN by issuing a DTACK* (data acknowledge signal), blocking the IACKOUT signal to the next board, and placing an 8-bit interrupt vector number on the data bus.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The VMECC latches the interrupt vector, and an interrupt signal is sent over the FCI interface to the F-chip and is queued awaiting completion of other F-chip tasks.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The F controller ASIC requests the I-bus and sends the interrupt to the IA chip.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The IA chip requests the Ebus and sends the interrupt over the Ebus to the CC chip on the IP19/IP21 board.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The CC chip interrupts an R4400/R8000, provided the interrupt level is not masked. </PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>The time for this to complete is normally less than 3 microseconds, but will be queued to await completion of other VME activities. </PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>VME Interface Features and Restrictions</TITLE><PARAGRAPH>The Challenge and Onyx VME interface supports all protocols defined in Revision C of the VME specification plus the A64 and D64 modes defined in Revision D. The D64 mode allows DMA bandwidths of up to 60 MB. This bus also supports the following features:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>seven levels of prioritized processor interrupts</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>16-bit, 24-bit, and 32-bit data addresses and 64-bit memory addresses</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>16-bit and 32-bit accesses (and 64-bit accesses in MIPS III mode)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>8-bit, 16-bit, 32-bit, and 64-bit data transfer</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>DMA to and from main memory</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION3 LBL="" HELPID = ""><TITLE>DMA Multiple Address Mapping</TITLE><PARAGRAPH>In the Challenge and Onyx series, a DMA address from a VME controller goes through a two-level translation to generate an acceptable physical address. This requires two levels of mapping. The first level of mapping is done through the map RAM on the IO4 board. The second level is done through the map tables in system memory. This mapping is shown in <XREF IDREF="36111" TYPE="GRAPHIC">Figure&nbsp;14-3</XREF>.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>The second level mapping requires system memory to be reserved for the mapping tables. The current limit on the number of pages that is allocated for map tables is 16 pages and the maximum memory allotted for the map tables is 64 KB. The R4400 provides a 4 KB page size for 16 pages (4 KB * 16 pages= 64 KB). The R8000 provides a 16&nbsp;KB page size for 4pages (16&nbsp;KB * 4 pages = 64 KB).</NOTE>
<PARAGRAPH>Each second-level map table entry corresponds to 4&nbsp;KB of physical memory. In addition, each second-level map table entry is 4 bytes. With 64&nbsp;KB of mapping table, there are a total of 16&nbsp;K entries translating a maximum of 64&nbsp;MB of DMA mapping, setting a limit of 64&nbsp;MB that can be mapped at any time for each VME bus. This does not set any limit on the amount of DMA that can be done by a board during its operation.</PARAGRAPH>
<PARAGRAPH>Referring to the top of <XREF IDREF="36111" TYPE="GRAPHIC">Figure&nbsp;14-3</XREF>, bits 32 and 33 from the IBus address come from the VMECC. These two bits determine a unique VMEbus number for systems with multiple VME buses. Of the remaining 32 bits (31 to 0), 12 are reserved for an offset in physical memory, and the other 20 bits are used to select up to 220 or 1 million pages into the main memory table. However, as stated earlier only 64 KB is allocated for map tables. </PARAGRAPH>
<PARAGRAPH>As shown in <XREF IDREF="36111" TYPE="GRAPHIC">Figure&nbsp;14-3</XREF>, thirteen bits go to the static RAM table. Recall that two of the thirteen bits are from the VMECC to identify the VMEbus number. The static RAM table then generates a 29-bit identifier into the main memory table. These 29 bits select a table in the main memory table. An additional nine bits select an entry or element within the table. A 00 (two zeros) are appended to form a 40-bit address into the main memory table.</PARAGRAPH>
<PARAGRAPH>The main memory table then generates 28-bit address which is then appended to the 12-bit offset of the IBus to form the final 40-bit physical address.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="13-IOaddr.to.sysaddr.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="14-3"><PREFIX>Figure 14-3 </PREFIX><XREFTARGET ID="36111">I/O Address to System Address Mapping</CAPTION>
</FIGURE>
</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>VME Interrupt Priority</TITLE><PARAGRAPH>Interrupts within the Challenge/Onyx architecture are managed by a set of interrupt vectors. An interrupt generated by an I/O device like a VME controller in turn generates an interrupt to the CPU on one of the previously assigned levels.<INDEXTARGET ID="14.1Y-vmehw66"><!-- POSTPROCESSDATA: 14.1Y-vmehw66|VME bus:hardware:interrupt priority --></PARAGRAPH>
<PARAGRAPH>Each IRQ on each VME bus is assigned an internal interrupt level, and by default all these levels are at the same priority. If multiple interrupts arrive simultaneously within a single bus, for example IRQ 3 and IRQ 4 at once, priority is given to the higher-numbered IRQ.</PARAGRAPH>
<PARAGRAPH>All VME interrupts are made to go to CPU&nbsp;0 (unless configured differently with IPL statements). This prevents one interrupt level from preempting the driver handling a different VME interrupt level.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>VME Hardware Features and Restrictions</TITLE><PARAGRAPH>When designing an OEM hardware board to interface to the Challenge or Onyx VME bus, observe the following restrictions:<INDEXTARGET ID="14.1Y-vmehw67"><!-- POSTPROCESSDATA: 14.1Y-vmehw67|Challenge/Onyx:VME design constraints --><INDEXTARGET ID="14.1Y-vmehw68"><!-- POSTPROCESSDATA: 14.1Y-vmehw68|VME bus:hardware:design constraints --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Devices should require 8-bit interrupt vectors only. This is the only interrupt vector size that is supported by the VMECC or recognized by the IRIX kernel.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Devices must not require UAT (unaligned transfer or tri-byte) access.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Devices in slave mode must not require address modifiers other than Supervisory/Nonprivileged data access.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>While in master mode, a device must use only nonprivileged data access or nonprivileged block transfers.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The Challenge or Onyx VME bus does not support VSBbus boards. In addition, there are no pins on the back of the VME backplane. This area is inaccessible for cables or boards.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Metal face plates or front panels on VME boards may prevent the I/O door from properly closing and can possibly damage I/O bulkhead. (In some VME enclosures, a face plate supplies required EMI shielding. However, the Challenge chassis already provides sufficient shielding, so these plates are not necessary.)</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION3 LBL="" HELPID = ""><TITLE>Designing a VME Bus Master for Challenge and Onyx Systems</TITLE><PARAGRAPH>The following notes are related to the design of a VME bus master device to work with a machine in the Challenge/Onyx series. A VME bus master, when programmed using the functions described in <XREF IDREF="14998" TYPE="TITLE">&ldquo;Mapping DMA Addresses&rdquo;</XREF>, can transfer data between itself and system memory.</PARAGRAPH>
<PARAGRAPH>The setup time at the start of a DMA transfer is as follows:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>First word of a read is delivered to the master in 3 to 8 microseconds. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>First word of a write is retrieved from the master in 1 to 3 microseconds. </PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The F controller does the mapping from A32 mode into system memory and automatically handles the crossing of page boundaries. The VME Bus Master is not required to make AS go high and then low on 4 KB boundaries. However, when using A64 addressing, the device may have to change the address on the 4 KB boundaries and cause a transition on AS low to high, and then back to low. This incurs new setup delays.</PARAGRAPH>
<PARAGRAPH>The important parts of the VME handshake cycle are diagrammed in <XREF IDREF="46275" TYPE="GRAPHIC">Figure&nbsp;14-4</XREF>. </PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="13-vme.cycle.time.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="14-4"><PREFIX>Figure 14-4 </PREFIX><XREFTARGET ID="46275">VMECC Contribution to VME Handshake Cycle Time</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>Intervals 1 and 3 represent the response latency in the bus slave (the VMECC). Intervals 2 and 4 represent the latency in the VME Bus Master. In the Challenge and Onyx systems,</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>part 1 is approximately 40 nanoseconds</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>part 3 is approximately 25 nanoseconds</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The total contribution by the VMECC is approximately 65 nanoseconds. If the total of the four intervals can be held to 125 nanoseconds, the absolute peak transfer rate (in D64 mode) is 64&nbsp;MB per second.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>Startup and latency numbers are averages and may occasionally be longer. The system design does not have any guaranteed latency.</NOTE>
<PARAGRAPH>The VME specification provides for a burst length of 265 bytes in D8, D16, and D32 modes, or 2 KB in D64. The burst length is counted in bytes, not transfer cycles.</PARAGRAPH>
<PARAGRAPH>Operating at this burst length, the duration of a single burst of 2&nbsp;KB would be 256 transfers at 125 nanoseconds each, plus a startup of roughly 5 microseconds, giving a total of 37 microseconds per burst. Continuous, back-to-back bursts could achieve at most 55&nbsp;MB per second.</PARAGRAPH>
<PARAGRAPH>However, the Challenge and Onyx VMECC uses a 20-bit burst counter allowing up to 2&nbsp;MB in a burst of any data size. Suppose the bus master transfers 64&nbsp;KB per burst, transferring 4-byte data words. The duration of a single burst would be 8,192 times 125 nanoseconds, plus 5 microseconds startup, or 1,029 microseconds per burst. Continuous bursts of this size achieve a data rate of 63.7&nbsp;MB per second.</PARAGRAPH>
<PARAGRAPH>The use of long bursts violates the VME standard, and a bus master that depends on long bursts is likely not to work in other computers. If you decide to exceed the VME bus specifications, you should condition this feature with a field in a control register on the VME board, so that it can be disabled for use on other VME systems. </PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
</CHAPTER>
