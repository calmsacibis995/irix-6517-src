<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="10"><TITLE><XREFTARGET ID="47470">Testing and Debugging a Driver</TITLE><PARAGRAPH>As a critical system component, a driver deserves careful testing, but because it is part of the kernel, the normal testing tools are not available. This chapter describes some of the available testing tools and methods, in the following major topics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="86033" TYPE="TITLE">&ldquo;Preparing the System for Debugging&rdquo;</XREF> describes how to set up the kernel for use of the debugging tools.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="17373" TYPE="TITLE">&ldquo;Producing Diagnostic Displays&rdquo;</XREF> covers the kernel functions your driver can use to generate diagnostic output as it executes.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="82218" TYPE="TITLE">&ldquo;Using symmon&rdquo;</XREF> describes the use of the standalone debugger.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="98041" TYPE="TITLE">&ldquo;Using idbg&rdquo;</XREF> describes some uses of the kernel-display command.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="86033">Preparing the System for Debugging </TITLE><PARAGRAPH>The standalone debugger <INDEXTARGET ID="11-drvrdebug1"><!-- POSTPROCESSDATA: 11-drvrdebug1|debugging kernel --><INDEXTARGET ID="11-drvrdebug2"><!-- POSTPROCESSDATA: 11-drvrdebug2|driver:debugging --><COMMAND>symmon</COMMAND> is a key tool for driver programming. It must be installed in the volume header of the boot disk. In order for it to be useful you must boot a &ldquo;debugging&rdquo; kernel, that is, one that retains symbols, and contains the display modules, that are used by debugging tools. Normally these modules and symbols are eliminated to save space. You modify the <FILENAME>irix.sm</FILENAME> file to enable debugging, and then generate a new kernel.</PARAGRAPH>
<PARAGRAPH>All these steps should be performed before you attempt to install your device driver.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Placing symmon in the Volume Header</TITLE><PARAGRAPH>The <INDEXTARGET ID="11-drvrdebug3"><!-- POSTPROCESSDATA: 11-drvrdebug3|volume header --><INDEXTARGET ID="11-drvrdebug4"><!-- POSTPROCESSDATA: 11-drvrdebug4|disk volume header --><INDEXTARGET ID="11-drvrdebug5"><!-- POSTPROCESSDATA: 11-drvrdebug5|symmon debugger --><COMMAND>symmon</COMMAND> standalone debugger resides in the volume header of a disk&mdash;not in a normal IRIX filesystem. The volume header is disk partition 8. It always contains a label record (sgilabel). On a bootable disk, the volume header contains the standalone shell <INDEXTARGET ID="11-drvrdebug6"><!-- POSTPROCESSDATA: 11-drvrdebug6|<COMMAND>sash</COMMAND> standalone shell --><COMMAND>sash</COMMAND> that manages the bootstrap operation. Some bootable disks may also contain the <INDEXTARGET ID="11-drvrdebug7"><!-- POSTPROCESSDATA: 11-drvrdebug7|<COMMAND>ide</COMMAND> PROM monitor --><FILENAME>ide</FILENAME> program, a PROM-level diagnostic program. If <FILENAME>symmon</FILENAME> is to be available, it, too, must be placed in the volume header.</PARAGRAPH>
<PARAGRAPH>Normally you acquire <COMMAND>symmon</COMMAND> by installing the debugging kernel feature (eoe.sw.kdebug) in the IRIX Developer Option software distribution. You can verify that this feature has been installed by executing the command <INDEXTARGET ID="11-drvrdebug8"><!-- POSTPROCESSDATA: 11-drvrdebug8|IRIX commands:<COMMAND>versions</COMMAND> --></PARAGRAPH>
<EXAMPLE>
versions eoe.sw.kdebug
</EXAMPLE>
<PARAGRAPH>The response should confirm the presence of this component (it does not show <COMMAND>symmon</COMMAND> by name). When you install the kernel debug feature, the <FILENAME>symmon</FILENAME> program file is copied to the volume header of the current boot disk automatically.</PARAGRAPH>
<PARAGRAPH>You can verify the presence of <INDEXTARGET ID="11-drvrdebug9"><!-- POSTPROCESSDATA: 11-drvrdebug9|IRIX commands:<COMMAND>dvhtool</COMMAND> --><COMMAND>symmon</COMMAND> in the volume header through the use of <COMMAND>dvhtool</COMMAND> (described in the <REFPAGE>dvhtool(1)</REFPAGE> reference page). The results should be similar to the display in <XREF IDREF="42321" TYPE="TEXT">Example&nbsp;10-1</XREF>. The response to the &ldquo;l&rdquo; (list) command shows that the volume header of this disk contains <FILENAME>sgilabel</FILENAME>, <FILENAME>ide</FILENAME>, <FILENAME>sash</FILENAME>, and <FILENAME>symmon</FILENAME>.</PARAGRAPH>
<CODE><CAPTION LBL="10-1"><PREFIX>Example 10-1 </PREFIX><XREFTARGET ID="42321">Verifying Presence of symmon</CAPTION># dvhtool -v list /dev/rvh 
Current&nbsp;contents:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File&nbsp;name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Length&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Block&nbsp;#
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sgilabel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;512&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ide&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;281600&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;278
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;281600&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;828
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symmon&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;248320&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1378
</CODE>
<PARAGRAPH>In the event you need to install <COMMAND>symmon</COMMAND> in the volume header of a disk without using the software manager, you can copy the standalone program to the volume header using <COMMAND>dvhtool</COMMAND>. However, you first need to get a copy of the program in the form of a UNIX file.</PARAGRAPH>
<PARAGRAPH>Starting from a volume that currently has a copy of <COMMAND>symmon</COMMAND> (verified as in <XREF IDREF="42321" TYPE="TEXT">Example&nbsp;10-1</XREF>), use <COMMAND>dvhtool</COMMAND> to extract a copy of <COMMAND>symmon</COMMAND> into a convenient spot.</PARAGRAPH>
<EXAMPLE>
dvhtool -v g symmon /var/tmp/symmon.IP<VARIABLE>xx</VARIABLE>&space;
</EXAMPLE>
<PARAGRAPH>There is a unique version of <COMMAND>symmon</COMMAND> for each CPU module, so it is a good idea to qualify the filename with the CPU module type. Once the program is available as a normal file, you can use <COMMAND>dvhtool</COMMAND> to install it in the volume header of some other disk.</PARAGRAPH>
<PARAGRAPH>In the event there is not enough room in partition 0 (the volume header) of the target disk, it is safe to use <COMMAND>dvhtool</COMMAND> to delete the <FILENAME>ide</FILENAME> program from the volume header. The <COMMAND>ide</COMMAND> application can be booted manually from a CDROM if it is ever required.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Enabling Debugging in irix.sm</TITLE><PARAGRAPH>In order to make debugging symbols available in the kernel, you must make two changes, one required and one optional, in the file <INDEXTARGET ID="11-drvrdebug10"><!-- POSTPROCESSDATA: 11-drvrdebug10|driver debugging:symbols --><INDEXTARGET ID="11-drvrdebug11"><!-- POSTPROCESSDATA: 11-drvrdebug11|idbg debugger --><INDEXTARGET ID="11-drvrdebug12"><!-- POSTPROCESSDATA: 11-drvrdebug12|configuration files:<FILENAME>/var/sysgen/system/irix.sm</FILENAME>:for debugging --><FILENAME>/var/sysgen/system/irix.sm</FILENAME>. As superuser, make a hard link to the file <FILENAME>/var/sysgen/system/irix.sm</FILENAME> as <FILENAME>irix.sm.nondebug</FILENAME>. This enables you to return easily to a nondebugging kernel.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Including Symbols in the Kernel Image</TITLE><PARAGRAPH>Edit <FILENAME>/var/sysgen/system/irix.sm</FILENAME>. Near the end, note the lines that resemble the following:</PARAGRAPH>
<CODE>
* Compilation and load flags
*&nbsp;&nbsp;&nbsp;To load a kernel that can be co-resident with symmon
*&nbsp;&nbsp;&nbsp;(for breakpoint debugging) replace LDOPTS
*&nbsp;&nbsp;&nbsp;with the following.  You must also INCLUDE prf and idbg.
*
*LDOPTS: -non_shared -N -e start -G 8 -elf -woff 84 -woff 47 -woff 17 -mips2 -o32  -nostdlib  -T 88069000   
</CODE>
<PARAGRAPH>The active LDOPTS statement (the one without an initial asterisk) appears a few lines later. Remove the asterisk from the front of the debugging LDOPTS to make it active. Insert an asterisk to convert the original LDOPTS into a comment.</PARAGRAPH>
<TIP><PREFIX>Tip</PREFIX>Despite the residual comment in the irix.sm file, you need not include module <FILENAME>prf</FILENAME> in a debugging kernel. It is only used for kernel profiling.</TIP>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="31432">Including idbg in the Kernel Image</TITLE><PARAGRAPH>The symbol-display routines used by the command-line kernel display tool, <INDEXTARGET ID="11-drvrdebug13"><!-- POSTPROCESSDATA: 11-drvrdebug13|idbg debugger:configuring in kernel --><COMMAND>idbg</COMMAND>, are contained in optional kernel modules. (See <XREF IDREF="98041" TYPE="TITLE">&ldquo;Using idbg&rdquo;</XREF>.) You can change <FILENAME>/var/sysgen/system/irix.sm</FILENAME> so that support for <COMMAND>idbg</COMMAND> is always present in the kernel. Alternatively, you can load these modules manually with <COMMAND>ml</COMMAND> before you use them (see the <REFPAGE>ml(1)</REFPAGE> reference page).</PARAGRAPH>
<PARAGRAPH>If you are entering an extended debugging period, make the modules permanent. Look for the lines in <FILENAME>/var/sysgen/system/irix.sm</FILENAME> that resemble the following:</PARAGRAPH>
<CODE>
*
* Kernel debugging tools (see profiler(1M) and idbg(1M))
*
EXCLUDE: idbg
EXCLUDE: dmiidbg, grioidbg, xfsidbg, xlvidbg, cachefsidbg, mloadidbg
</CODE>
<PARAGRAPH>Change these lines, if necessary, so that all modules ending in <FILENAME>idbg</FILENAME> is marked INCLUDE, not EXCLUDE. (INCLUDE is preferred to USE in order to get an error message if they are not found.) Verify that the corresponding object files <FILENAME>/var/sysgen/boot/*idbg.o</FILENAME> exist. They are normally installed with the debugging kernel feature, although some of them may be installed with specific products.</PARAGRAPH>
<PARAGRAPH>Parts of the <COMMAND>idbg</COMMAND> support that are unique to particular filesystems are in the other modules listed in this area of <FILENAME>irix.sm</FILENAME>. Modules such as <FILENAME>xlvidbg</FILENAME> are useful to Silicon Graphics developers but are not likely to be helpful to developers of third-party drivers. However, it does no harm to change those modules from EXCLUDE to USE also.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="83750">Including Lock Metering in the Kernel Image</TITLE><PARAGRAPH>In addition to the display support included by the idbg modules, you can include modules that support lock metering. This causes the kernel to keep statistics on the use of each semaphore, basic lock, and reader/writer lock, so you can display the statistics through <INDEXTARGET ID="11-drvrdebug14"><!-- POSTPROCESSDATA: 11-drvrdebug14|driver debugging:lock metering --><INDEXTARGET ID="11-drvrdebug15"><!-- POSTPROCESSDATA: 11-drvrdebug15|lock metering support --><COMMAND>idbg</COMMAND> commands. To enable lock metering, find lines in <FILENAME>/var/sysgen/system/irix.sm</FILENAME> that resemble the following:</PARAGRAPH>
<CODE>
* Required kernel modules
...
* ksync - kernel synchronization routines (mutex_lock, sv_wait, psema...)
* &nbsp;&nbsp;or
*   ksync_metered  - metered kernel synchronization routines
...
*
KERNEL: kernel
INCLUDE: os, disp, mem, zero
INCLUDE: ksync
EXCLUDE: ksync_metered
</CODE>
<PARAGRAPH>Reverse the state of the two &ldquo;ksync&rdquo; lines so that ksync is excluded and ksync_metered is included.</PARAGRAPH>
<PARAGRAPH>Then find a line that resembles</PARAGRAPH>
<EXAMPLE>
INCLUDE hardlocks
</EXAMPLE>
<PARAGRAPH>Change this line to a comment, and add a line that says</PARAGRAPH>
<EXAMPLE>
INCLUDE dhardlocks
</EXAMPLE>
<PARAGRAPH>(Inserting the initial letter &ldquo;d&rdquo; in the module name.) This is the module that implements basic locks as spinlocks, and dhardlocks is the metered version.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Generating a Debugging Kernel</TITLE><PARAGRAPH>Run the <INDEXTARGET ID="11-drvrdebug16"><!-- POSTPROCESSDATA: 11-drvrdebug16|IRIX commands:<COMMAND>autoconfig</COMMAND> --><COMMAND>autoconfig</COMMAND> command to generate a new kernel that will reflect the changes made in <FILENAME>irix.sm</FILENAME>. The result is a new kernel file, <FILENAME>/unix.install</FILENAME>, that will be renamed to <FILENAME>/unix</FILENAME> and used when the system is booted. This kernel can support <COMMAND>idbg</COMMAND> but is not yet ready for standalone debugging with <COMMAND>symmon</COMMAND>.</PARAGRAPH>
<PARAGRAPH>The <INDEXTARGET ID="11-drvrdebug17"><!-- POSTPROCESSDATA: 11-drvrdebug17|driver debugging:<COMMAND>setsym</COMMAND> use --><INDEXTARGET ID="11-drvrdebug18"><!-- POSTPROCESSDATA: 11-drvrdebug18|IRIX commands:<COMMAND>setsym</COMMAND> --><COMMAND>setsym</COMMAND> command copies the symbol table from a kernel file and stores it as data within the kernel, so that <COMMAND>symmon</COMMAND> can find it. After autoconfig has created <FILENAME>/unix.install</FILENAME>, apply the setsym command to it, as follows:</PARAGRAPH>
<EXAMPLE>
#setsym /unix.install
</EXAMPLE>
<PARAGRAPH>If this command returns an error message about &ldquo;symbol table overflow,&rdquo; it means you have neglected to activate the debugging LDOPTS statement in <FILENAME>/var/sysgen/irix.sm</FILENAME>.</PARAGRAPH>
<TIP><PREFIX>Tip</PREFIX>You can use <COMMAND>setsym</COMMAND> with the <COMMAND>-d</COMMAND> option to generate a list of all symbols in the kernel being modified. The list is very long; direct it to a file for later reference.</TIP>
<PARAGRAPH>At this time, you may wish to create a link to the current, nondebugging kernel so you can retrieve it easily. You can also return to a nondebugging kernel by restoring the original <FILENAME>irix.sm</FILENAME> file and running <COMMAND>autoconfig</COMMAND> again.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Specifying a Separate System Console</TITLE><PARAGRAPH>In order to use the standalone debugger, you must have an ASCII terminal as a separate system console device. Install a terminal next to the system or workstation and connect it to the first serial port (of a workstation) or the system console serial port (of a server).<INDEXTARGET ID="11-drvrdebug19"><!-- POSTPROCESSDATA: 11-drvrdebug19|driver debugging:alternate console --><INDEXTARGET ID="11-drvrdebug20"><!-- POSTPROCESSDATA: 11-drvrdebug20|terminal as console --><INDEXTARGET ID="11-drvrdebug21"><!-- POSTPROCESSDATA: 11-drvrdebug21|system console:alternate --><INDEXTARGET ID="11-drvrdebug22"><!-- POSTPROCESSDATA: 11-drvrdebug22|alternate console --></PARAGRAPH>
<PARAGRAPH>You may have to modify the file <INDEXTARGET ID="11-drvrdebug23"><!-- POSTPROCESSDATA: 11-drvrdebug23|configuration files:<FILENAME>/etc/inittab</FILENAME> --><FILENAME>/etc/inittab</FILENAME> so that the line for the alternate console is active (see the <REFPAGE>inittab(4)</REFPAGE> reference page). Alternatively, you can use the System Manager application from the 4D desktop. Select the icon for Port Setup. Select the port and click Connect. You can then configure the port for baud rate and terminal type interactively.</PARAGRAPH>
<PARAGRAPH>Verify the terminal's operation by logging in to the system. When you know the terminal works, use the <INDEXTARGET ID="11-drvrdebug24"><!-- POSTPROCESSDATA: 11-drvrdebug24|IRIX commands:<COMMAND>nvram</COMMAND> --><COMMAND>nvram</COMMAND> command to change the nonvolatile RAM variable console from a letter &ldquo;g&rdquo; to a letter &ldquo;d,&rdquo; as follows:</PARAGRAPH>
<CODE>
# nvram console
g
# nvram console d
# nvram console
d
</CODE>
<PARAGRAPH>The <COMMAND>nvram</COMMAND> command is used to report and change the contents of the nonvolatile RAM variables used by the boot PROM and standalone shell (see the <REFPAGE>nvram(1)</REFPAGE> reference page).</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Verifying the Debugging Tools</TITLE><PARAGRAPH>After performing the preceding steps, restart the system. Messages from <COMMAND>sash</COMMAND> appear on the attached terminal, rather than on the graphics screen. If <FILENAME>symmon</FILENAME> is present, it announces itself on the console terminal also.</PARAGRAPH>
<PARAGRAPH>To verify operation of <COMMAND>idbg</COMMAND>, issue the idbg command and display the process list:</PARAGRAPH>
<CODE>
# idbg
idbg> plist
active process list:
34:672:"xdm" pri(60) SLEEP flags: load uload siglck recalc sv 
0:0:"sched" ndpri(39) SLEEP flags: sys nwake load uload sv 
31:193:"inetd" pri(60) SLEEP flags: load uload siglck recalc sv 
...
</CODE>
<PARAGRAPH>To verify operation of <COMMAND>symmon</COMMAND>, press control-A at the console terminal. The prompt string DBG: should appear. At this time the system is frozen and no longer responds to mouse or keyboard input. Type the letter <COMMAND>c</COMMAND> (for continue) and press return (in a multiprocessor, use <COMMAND>c all</COMMAND>). The system returns to life.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="84574"><XREFTARGET ID="17373">Producing Diagnostic Displays</TITLE><PARAGRAPH>Normally a device or STREAMS driver produces display output in only two cases:<INDEXTARGET ID="11-drvrdebug25"><!-- POSTPROCESSDATA: 11-drvrdebug25|kernel functions:<FUNCTION>cmn_err()</FUNCTION> --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>To advise the operator or administrator of a serious problem.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>To display debugging information during software development.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Both of these purposes are served by the <FUNCTION>cmn_err()</FUNCTION> function. It brings to a kernel-level module the abilities that a user-level process gets from <FUNCTION>printf()</FUNCTION> and <FUNCTION>syslog()</FUNCTION>.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="49566">Using cmn_err</TITLE><PARAGRAPH>The details of <INDEXTARGET ID="11-drvrdebug26"><!-- POSTPROCESSDATA: 11-drvrdebug26|header files:<FILENAME>sys/cmnerr.h</FILENAME> --><FUNCTION>cmn_err()</FUNCTION> usage are in the <REFPAGE>cmn_err(D3)</REFPAGE> reference page. The function prototype and the constant values it uses are declared in <FILENAME>sys/cmnerr.h</FILENAME>.</PARAGRAPH>
<PARAGRAPH>In summary, <FUNCTION>cmn_err()</FUNCTION> takes two or more arguments:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>A severity code that specifies how the message should be treated when it is written to the system log.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A message string, which can have substitution points in the style of <FUNCTION>printf()</FUNCTION>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>As many numeric values as are needed to substitute into the message string.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The first character of the message string specifies the destination of the message, either an in-memory buffer or the system log, or both.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Displaying to the System Log</TITLE><PARAGRAPH>The message is sent to the system log daemon whenever the first message character (after substitution) is not an exclamation mark (&ldquo;!&rdquo;). The message is written only to the system log when the first message character is a circumflex (&ldquo;^&rdquo;).<INDEXTARGET ID="11-drvrdebug27"><!-- POSTPROCESSDATA: 11-drvrdebug27|kernel functions:<FUNCTION>cmn_err()</FUNCTION>:system log output --><INDEXTARGET ID="11-drvrdebug28"><!-- POSTPROCESSDATA: 11-drvrdebug28|driver debugging:system log output --><INDEXTARGET ID="11-drvrdebug29"><!-- POSTPROCESSDATA: 11-drvrdebug29|system log display --></PARAGRAPH>
<PARAGRAPH>This is basically the same service that a user-level process receives from the <INDEXTARGET ID="11-drvrdebug30"><!-- POSTPROCESSDATA: 11-drvrdebug30|IRIX functions:<FUNCTION>syslog()</FUNCTION> --><FUNCTION>syslog()</FUNCTION> function. (Compare the <REFPAGE>syslog(3)</REFPAGE> and <REFPAGE>cmn_err(D3)</REFPAGE> reference pages, and examine the <FILENAME>sys/cmnerr.h</FILENAME> header file; the relationship is clear.) The first argument to <FUNCTION>cmn_err()</FUNCTION> is a severity code which corresponds to one of the severity codes supported by <FUNCTION>syslog()</FUNCTION>: CE_WARN equals LOG_WARN, and so on.</PARAGRAPH>
<PARAGRAPH>Use <FUNCTION>cmn_err()</FUNCTION> to write log messages to record serious errors (with CE_ALERT severity) or to advise the administrator of conditions that should be changed (using CE_NOTE).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="37423">Displaying to the Circular Message Buffer</TITLE><PARAGRAPH>The message is stored in the next available position in a circular buffer in kernel memory whenever the first message character (after substitution) is not a circumflex (&ldquo;^&rdquo;). The message is stored only in the memory buffer when the first message character is an exclamation mark (&ldquo;!&rdquo;).<INDEXTARGET ID="11-drvrdebug31"><!-- POSTPROCESSDATA: 11-drvrdebug31|driver debugging:circular buffer output --><INDEXTARGET ID="11-drvrdebug32"><!-- POSTPROCESSDATA: 11-drvrdebug32|kernel functions:<FUNCTION>cmn_err()</FUNCTION>:buffer output --></PARAGRAPH>
<PARAGRAPH>The name of the circular buffer (as a symbol to <INDEXTARGET ID="11-drvrdebug33"><!-- POSTPROCESSDATA: 11-drvrdebug33|putbuf circular buffer --><COMMAND>idbg</COMMAND> or <COMMAND>symmon</COMMAND>) is <VARIABLE>putbuf</VARIABLE>. The contents of <VARIABLE>putbuf</VARIABLE> can be displayed with the <COMMAND>pb</COMMAND> command of either <COMMAND>idbg</COMMAND> or <COMMAND>symmon</COMMAND> (see<XREF IDREF="82218" TYPE="TITLE">&ldquo;Using symmon&rdquo;</XREF> and <XREF IDREF="98041" TYPE="TITLE">&ldquo;Using idbg&rdquo;</XREF>), or in a post-mortem dump using <COMMAND>icrash</COMMAND> (see <XREF IDREF="56887" TYPE="TITLE">&ldquo;Using icrash&rdquo;</XREF>). Use <FUNCTION>cmn_err()</FUNCTION> to store debugging trace data in the circular buffer, and extract it after a stop or breakpoint with <COMMAND>symmon</COMMAND>, or use <COMMAND>idbg</COMMAND> to look at it while the system is running.</PARAGRAPH>
<PARAGRAPH>The size of the buffer can be configured by changing the kernel variable <VARIABLE>putbufsz</VARIABLE>, as shown in the dialog in <XREF IDREF="93489" TYPE="TEXT">Example&nbsp;10-2</XREF>. <INDEXTARGET ID="11-drvrdebug34"><!-- POSTPROCESSDATA: 11-drvrdebug34|IRIX commands:<COMMAND>systune</COMMAND> --></PARAGRAPH>
<CODE><CAPTION LBL="10-2"><PREFIX>Example 10-2 </PREFIX><XREFTARGET ID="93489">Setting Kernel putbuf Size</CAPTION># systune -i
Updates will be made to running system and /unix.install
systune-> putbufsz
&space;       putbufsz = 1024 (0x400)
systune-> putbufsz 4096
&space;       putbufsz = 1024 (0x400)
&space;       Do you really want to change putbufsz to 4096 (0x1000)? (y/n)  y
In order for the change in parameter putbufsz to become effective,
reboot the system 
systune-> quit
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using cmn_err() Through Macros</TITLE><PARAGRAPH>The inventive C programmer can think of many ways to invoke <FUNCTION>cmn_err()</FUNCTION> using macros. One method is illustrated in the example driver displayed in <XREF IDREF="88380" TYPE="TITLE">Chapter&nbsp;11, &ldquo;Driver Example.&rdquo;</XREF> It contains the code shown in <XREF IDREF="68394" TYPE="TEXT">Example&nbsp;10-3</XREF>.</PARAGRAPH>
<CODE><CAPTION LBL="10-3"><PREFIX>Example 10-3 </PREFIX><XREFTARGET ID="68394">Debugging Macros Using cmn_err()</CAPTION>#ifdef DEBUG
#define DBGMSG0(s) cmn_err(CE_DEBUG,s)
#define DBGMSG1(s,x) cmn_err(CE_DEBUG,s,x)
#define DBGMSG2(s,x,y) cmn_err(CE_DEBUG,s,x,y)
#define DBGMSG3(s,x,y,z) cmn_err(CE_DEBUG,s,x,y,z)
#else
#define DBGMSG0(s)
#define DBGMSG1(s,x)
#define DBGMSG2(s,x,y)
#define DBGMSG3(s,x,y,z)
#endif 
</CODE>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Using printf()</TITLE><PARAGRAPH>You can call the <INDEXTARGET ID="11-drvrdebug35"><!-- POSTPROCESSDATA: 11-drvrdebug35|kernel functions:<FUNCTION>printf()</FUNCTION> --><FUNCTION>printf()</FUNCTION> function from a kernel module. The kernel version of <FUNCTION>printf()</FUNCTION> is basically a call to <FUNCTION>cmn_err()</FUNCTION> with severity CE_CONT. In general it is better to use <FUNCTION>cmn_err()</FUNCTION> explicitly.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="85359">Using ASSERT</TITLE><PARAGRAPH>The <INDEXTARGET ID="11-drvrdebug36"><!-- POSTPROCESSDATA: 11-drvrdebug36|ASSERT macro --><FUNCTION>assert()</FUNCTION> macro is familiar to many C programmers; it terminates a program with a message if its argument evaluates to false (see the <REFPAGE>assert(3X)</REFPAGE> reference page). This normal assert<FUNCTION>()</FUNCTION> macro does not work in a kernel module because the normal C library is not available. However, a similar function is available as the ASSERT() macro in the header file <INDEXTARGET ID="11-drvrdebug37"><!-- POSTPROCESSDATA: 11-drvrdebug37|header files:<FILENAME>sys/debug.h</FILENAME> --><FILENAME>sys/debug.h</FILENAME>.</PARAGRAPH>
<PARAGRAPH>The ASSERT() macro compiles to null code unless the compiler variable DEBUG is not only defined, but defined as YES. When it compiles to executable code, ASSERT() tests its argument. If the argument evaluates to false, a kernel panic is forced.</PARAGRAPH>
<PARAGRAPH>Clearly ASSERT() must be used with care, testing conditions that are truly essential to the integrity of the system. When reporting conditions that are merely operational errors, use a call to <FUNCTION>cmn_err()</FUNCTION> with the CE_WARN option.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="82218">Using symmon </TITLE><PARAGRAPH>The <INDEXTARGET ID="11-drvrdebug38"><!-- POSTPROCESSDATA: 11-drvrdebug38|driver debugging:symmon use --><INDEXTARGET ID="11-drvrdebug39"><!-- POSTPROCESSDATA: 11-drvrdebug39|symmon debugger --><COMMAND>symmon</COMMAND> program is a standalone debug monitor that can display and modify memory, and stop, start, and trace execution, without using any kernel facilities. Using <COMMAND>symmon</COMMAND> you can set breakpoints in your driver, single-step its execution, and display the contents of driver and kernel variables. </PARAGRAPH>
<PARAGRAPH>The facilities of <COMMAND>symmon</COMMAND> are unsophisticated compared to the high-level debuggers you might use to debug a user-level application. For example, <COMMAND>symmon</COMMAND> does not understand C syntax, so it cannot display data structures as structures. Execution tracing is done at the level of machine instructions, not at the level of C statements.</PARAGRAPH>
<PARAGRAPH>However, you can use <COMMAND>symmon</COMMAND> to examine the operations of a kernel module in a running system, and resume execution of the system. This is an invaluable facility when debugging a new driver.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>How symmon Is Entered</TITLE><PARAGRAPH>When the system boots a debugging kernel with <INDEXTARGET ID="11-drvrdebug40"><!-- POSTPROCESSDATA: 11-drvrdebug40|symmon debugger:how invoked --><COMMAND>symmon</COMMAND> installed, control can pass into the debug monitor under several different circumstances:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Early in the bootstrap process, if certain environment variables are set in the stand-alone shell (see <XREF IDREF="21688" TYPE="TITLE">&ldquo;Entering symmon at Boot Time&rdquo;</XREF>).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Whenever a control-A character is typed at the system console terminal.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Whenever a breakpoint is reached or a watchpoint is tripped (see <XREF IDREF="66759" TYPE="TITLE">&ldquo;Commands to Control Execution Flow&rdquo;</XREF>).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Whenever a kernel module calls the kernel function <FUNCTION>debug</FUNCTION>(<VARIABLE>uchar_t</VARIABLE> *<VARIABLE>msg</VARIABLE>).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>When a non-maskable interrupt (NMI) is detected.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>When a kernel panic is detected or forced with <FUNCTION>cmn_err()</FUNCTION>.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>When <COMMAND>symmon</COMMAND> gains control, it displays its &ldquo;DBG:&rdquo; prompt at the console terminal and waits for a command. <INDEXTARGET ID="11-drvrdebug41"><!-- POSTPROCESSDATA: 11-drvrdebug41|symmon debugger:prompt --></PARAGRAPH>
<PARAGRAPH>To resume execution at the point of interruption, enter the <COMMAND>c</COMMAND> (continue) command.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Using symmon in a Uniprocessor Workstation</TITLE><PARAGRAPH>In a single-processor workstation, no IRIX execution takes place while <INDEXTARGET ID="11-drvrdebug42"><!-- POSTPROCESSDATA: 11-drvrdebug42|symmon debugger:in uniprocessor --><INDEXTARGET ID="11-drvrdebug43"><!-- POSTPROCESSDATA: 11-drvrdebug43|uniprocessor:using symmon --><COMMAND>symmon</COMMAND> is running. The mouse and keyboard are unresponsive. (One keystroke may be stored in the keyboard hardware to be processed when the system resumes execution.) As a result, time-dependent processes can fail; for example, the system clock is not updated. Network interrupts are not taken, so if the workstation is acting as an NFS server, it will appear to be dead to other systems.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using symmon in a Multiprocessor Workstation</TITLE><PARAGRAPH>In a multiprocessor, the CPU that was interrupted runs <INDEXTARGET ID="11-drvrdebug44"><!-- POSTPROCESSDATA: 11-drvrdebug44|driver debugging:multiprocessor --><INDEXTARGET ID="11-drvrdebug45"><!-- POSTPROCESSDATA: 11-drvrdebug45|symmon debugger:in multiprocessor --><INDEXTARGET ID="11-drvrdebug46"><!-- POSTPROCESSDATA: 11-drvrdebug46|multiprocessor:using symmon in --><COMMAND>symmon</COMMAND> and nothing else. For example, the CPU that executes the breakpoint, or the CPU that handles the interrupt that returns the control-A character, or the CPU in which <FUNCTION>debug()</FUNCTION> was called, comes under the control of <COMMAND>symmon</COMMAND>. Other CPUs continue to execute normally. However, if the <COMMAND>symmon</COMMAND> CPU holds a lock, other CPUs may come to a halt waiting for the lock to be released.</PARAGRAPH>
<PARAGRAPH>The <COMMAND>symmon</COMMAND> breakpoint table is shared by all CPUs. A breakpoint set from one CPU can be taken by another CPU, or by multiple other CPUs. It is possible to run multiple instances of <COMMAND>symmon</COMMAND> concurrently. The output from all instances of <COMMAND>symmon</COMMAND> is multiplexed onto the system console terminal. However, only one CPU at a time issues the DBG: prompt. Use the <COMMAND>cpu</COMMAND> command with no argument to find out which CPU is prompting. Use the <COMMAND>cpu</COMMAND> command with a cpu number to switch to a different CPU. (See <XREF IDREF="66759" TYPE="TITLE">&ldquo;Commands to Control Execution Flow&rdquo;</XREF>.)</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="21688">Entering symmon at Boot Time</TITLE><PARAGRAPH>You can cause the kernel to stop during initialization and enter symmon during the bootstrap process. In order to do this, you must use the miniroot to set environment variables.<INDEXTARGET ID="11-drvrdebug47"><!-- POSTPROCESSDATA: 11-drvrdebug47|driver debugging:stopping during bootstrap --><INDEXTARGET ID="11-drvrdebug48"><!-- POSTPROCESSDATA: 11-drvrdebug48|symmon debugger:invoking at bootstrap --></PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Restart the system, for example by giving the commands <COMMAND>sync</COMMAND> and <COMMAND>halt</COMMAND>. Eventually, the 5-item PROM menu is displayed at the console terminal.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Select item 5, &ldquo;Enter the Command Monitor.&rdquo;</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Set one or both of the environment variables <VARIABLE>dbgstop</VARIABLE> and <VARIABLE>symstop</VARIABLE> to 1, using commands such as the following:</PARAGRAPH>
<EXAMPLE>
>> setenv symstop 1
</EXAMPLE>
</LIST>
<LIST><PARAGRAPH>Return to the PROM menu by entering the command <COMMAND>exit</COMMAND>.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Select menu item 1, &ldquo;Start System.&rdquo;</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>In either case, <COMMAND>symmon</COMMAND> seizes the system and displays its DBG: prompt at the system console during bootstrap. When the <VARIABLE>dbgstop</VARIABLE> variable is set, <COMMAND>symmon</COMMAND> takes control of the system very early in the bootstrap process. Symbolic names are not initialized at this point. However, breakpoints can be set and memory can be displayed using explicit addresses.</PARAGRAPH>
<PARAGRAPH>When the <VARIABLE>symstop</VARIABLE> variable is set, <COMMAND>symmon</COMMAND> takes control after symbols are defined, but before driver initialization is begun. At this stop, you can display memory and set breakpoints based on entry point names of your driver.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Commands of symmon</TITLE><PARAGRAPH>The exact set of commands supported by <INDEXTARGET ID="11-drvrdebug49"><!-- POSTPROCESSDATA: 11-drvrdebug49|symmon debugger:command syntax --><COMMAND>symmon</COMMAND> changes from release to release and from CPU model to CPU model. Many <COMMAND>symmon</COMMAND> commands are useful only to Silicon Graphics engineers who are debugging hardware and kernel problems. For a complete list of commands, see the <REFPAGE>symmon(1M)</REFPAGE> reference page, or enter <COMMAND>symmon</COMMAND> and give the <COMMAND>help</COMMAND> command. You can use control-S and control-Q on the console terminal to pause the scrolling display.</PARAGRAPH>
<PARAGRAPH>The commands described in this section are generally useful and are available on all CPU models under IRIX 6.2. These commands can be grouped into the following categories:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Conversion between symbols and memory addresses.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Execution control, including commands for stopping, starting, and setting breakpoints.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Display and modification of memory, including the display of machine registers and of system data structures such as the <VARIABLE>buf_t</VARIABLE> and <VARIABLE>proc_t</VARIABLE> objects.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Management of the virtual memory system and the TLB.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Syntax of Command Elements</TITLE><PARAGRAPH>The <COMMAND>symmon</COMMAND> commands all have the same form: a keyword, usually followed by one or more arguments separated by spaces. </PARAGRAPH>
<PARAGRAPH>Many commands take an address value. An address argument value can have one of the following forms: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>Decimal number </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>A number starting with 1-9 is decimal, for example <COMMAND>4095</COMMAND>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>Octal number </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>A number starting with 0 and a digit is octal, for example <COMMAND>033</COMMAND>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>Hex number </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>A number starting 0x is hexadecimal, for example <COMMAND>0xffff8000</COMMAND>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>Binary number </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>A number starting 0b is binary, for example <COMMAND>0b0100</COMMAND>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>Symbol </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>A word starting with a non-digit is looked up in the kernel 
symbol table, and its address is the value; for example <COMMAND>dk_open</COMMAND>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>Register </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>A word starting with &ldquo;$&rdquo; is taken as a register name, Its value is 
the contents of the register at the last interrupt; for example <COMMAND>$a2</COMMAND>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>Value and offset </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>A value plus or minus a number is a value, for example 
<COMMAND>$a2-0x100</COMMAND> or <COMMAND>dk_open+128</COMMAND>. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Some commands accept a range of addresses. A range can be written in one of two ways:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>As <VARIABLE>value1</VARIABLE><BOLD>:</BOLD><VARIABLE>value2</VARIABLE>, meaning an inclusive range of addresses from <VARIABLE>value1</VARIABLE> through <VARIABLE>value2</VARIABLE>, for example <COMMAND>prtbuf:prtbuf+4095</COMMAND>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>As <VARIABLE>value1</VARIABLE><BOLD>#</BOLD><VARIABLE>count2</VARIABLE>, meaning a range of <VARIABLE>count2</VARIABLE> bytes beginning at <VARIABLE>value1</VARIABLE>, for example <COMMAND>prtbuf#4095</COMMAND>.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The register names that <COMMAND>symmon</COMMAND> accepts and shows in various displays are the conventional names used in MIPS assembly language programming. Refer to the <DOCTITLE>MIPSpro Assembly Language Programmer's Guide</DOCTITLE> and the processor manuals listed under <XREF IDREF="49142" TYPE="TITLE">&ldquo;Additional Reading&rdquo;</XREF>. </PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Commands for Symbol Conversion and Lookup</TITLE><PARAGRAPH>The commands summarized in <INDEXTARGET ID="11-drvrdebug50"><!-- POSTPROCESSDATA: 11-drvrdebug50|symmon debugger:symbol lookup --><INDEXTARGET ID="11-drvrdebug51"><!-- POSTPROCESSDATA: 11-drvrdebug51|driver debugging:symbol lookup --><XREF IDREF="29277" TYPE="TABLE">Table&nbsp;10-1</XREF> are used to convert between symbolic names and their corresponding addresses. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="10-1"><PREFIX>Table 10-1 </PREFIX><XREFTARGET ID="29277"> <EMPHASIS>(continued)        </EMPHASIS>Commands for Symbol Conversion and Lookup</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="62"><PARAGRAPH>Command</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="151"><PARAGRAPH>Example</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="180"><PARAGRAPH>Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><BOLD>hx</BOLD>&space;<VARIABLE>name</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="151"><PARAGRAPH><BOLD>hx dk_read&lbreak;
</BOLD>dk_read 0xffffffff882b0510 </PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="180"><PARAGRAPH>The name is looked up on the symbol table 
and if it is found, its address is displayed. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><BOLD>lkaddr</BOLD>&space;<VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="151"><PARAGRAPH><BOLD>lkaddr 0x882b0510&lbreak;
</BOLD>0x882af910 lockdisptab&lbreak;0x882b0510 dk_read&lbreak;0x882b051c dk_write </PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="180"><PARAGRAPH>Symbols near to the specified <VARIABLE>addr</VARIABLE> are listed. 
Use this command to find out the symbolic 
location of an unexpected stop. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><BOLD>lkup</BOLD>&space;<VARIABLE>letters</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="151"><PARAGRAPH><BOLD>hx dk_rea&lbreak;
</BOLD>0x880d5f10 dk_readcap&lbreak;0x882b0510 dk_read&lbreak;0x332b0528 dk_readcapacity </PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="180"><PARAGRAPH>Every symbol that contains the specified 
<VARIABLE>letters</VARIABLE> at any point is listed. There is no way 
to anchor the search to the beginning or end 
of the name. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><BOLD>msyms</BOLD>&space;<VARIABLE>ident</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="151"><PARAGRAPH><BOLD>msyms 13&lbreak;
</BOLD>Symbols for module 13 (prefix tcl)&lbreak;tclinit 0xc0403d9c&lbreak;tclmversion 0xc0405fe0 </PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="180"><PARAGRAPH>The symbols for the loadable module <VARIABLE>ident</VARIABLE> 
are listed. Use the <COMMAND>ml</COMMAND> command with no 
arguments to list all modules and their ident 
numbers. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><BOLD>nm</BOLD>&space;<VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="151"><PARAGRAPH><BOLD>nm 0xc0403da0&lbreak;
</BOLD>0xc0403da0 tclinit+0x4 </PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="180"><PARAGRAPH>The symbol nearest to the specified <VARIABLE>addr</VARIABLE> is 
listed. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<NOTE><PREFIX>Note</PREFIX>When symmon displays an address it normally shows a full 64 bits. In a 32-bit kernel, the most-significant 32 bits of a kernel virtual address are all-binary-1, from extension of the sign bit of the 32-bit address&mdash;as shown in the example of <COMMAND>hx</COMMAND> in <XREF IDREF="29277" TYPE="TABLE">Table&nbsp;10-1</XREF>. When you enter an address to a command in a 32-bit system, you only need to type the significant 32-bit value.</NOTE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="66759">Commands to Control Execution Flow</TITLE><PARAGRAPH>The commands summarized in <INDEXTARGET ID="11-drvrdebug52"><!-- POSTPROCESSDATA: 11-drvrdebug52|symmon debugger:breakpoints --><INDEXTARGET ID="11-drvrdebug53"><!-- POSTPROCESSDATA: 11-drvrdebug53|driver debugging:breakpoints --><XREF IDREF="17423" TYPE="TABLE">Table&nbsp;10-2</XREF> stop, start, and single-step kernel execution. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="10-2"><PREFIX>Table 10-2 </PREFIX><XREFTARGET ID="17423"> <EMPHASIS>(continued)        </EMPHASIS>Commands to Control Execution</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="101"><PARAGRAPH>Command</PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="76"><PARAGRAPH>Example</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="207"><PARAGRAPH>Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="101"><PARAGRAPH><BOLD>brk</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="76"><PARAGRAPH><BOLD>brk</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="207"><PARAGRAPH>List all breakpoints currently set. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="101"><PARAGRAPH><BOLD>brk</BOLD>&space;<VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="76"><PARAGRAPH><BOLD>brk dk_read</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="207"><PARAGRAPH>Set a breakpoint at the specified <VARIABLE>addr</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="101"><PARAGRAPH><BOLD>c</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="76"><PARAGRAPH><BOLD>c</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="207"><PARAGRAPH>Restart execution at the point of interruption in the 
current CPU. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="101"><PARAGRAPH><BOLD>c</BOLD>&space;<VARIABLE>cpuid</VARIABLE> [<VARIABLE>cpuid</VARIABLE>]...&lbreak;<BOLD>c</BOLD>&space;<BOLD>all</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="76"><PARAGRAPH>c 0</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="207"><PARAGRAPH>Restart execution in the specified CPU, or in all 
stopped CPUs. Available in multiprocessors only. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="101"><PARAGRAPH><BOLD>call</BOLD>&space;<VARIABLE>addr</VARIABLE> [<VARIABLE>args</VARIABLE>] </PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="76"><PARAGRAPH><BOLD>call geteminor 0</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="207"><PARAGRAPH>Call a kernel function and report the contents of the 
result register on return. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="101"><PARAGRAPH><BOLD>cpu</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="76"><PARAGRAPH><BOLD>cpu</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="207"><PARAGRAPH>Displays the cpu ID of the currently-executing 
CPU. Available in multiprocessors only. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="101"><PARAGRAPH><BOLD>cpu</BOLD>&space;<VARIABLE>cpuid</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="76"><PARAGRAPH><BOLD>cpu</BOLD> 0</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="207"><PARAGRAPH>Force <COMMAND>symmon</COMMAND> execution to the specified CPU. That 
CPU must be executing <COMMAND>symmon</COMMAND>. Other CPUs 
executing <COMMAND>symmon</COMMAND> wait. Available in 
multiprocessors only. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="101"><PARAGRAPH><BOLD>goto</BOLD>&space;<VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="76"><PARAGRAPH><BOLD>goto geteminor</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="207"><PARAGRAPH>Set a temporary breakpoint at <VARIABLE>addr</VARIABLE> and then 
continue execution as for the <COMMAND>c</COMMAND> command (in effect 
&ldquo;go until <VARIABLE>addr</VARIABLE> is reached&rdquo;). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="101"><PARAGRAPH><BOLD>quit</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="76"><PARAGRAPH><BOLD>quit</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="207"><PARAGRAPH>Return to the boot PROM, forcing an instant reboot. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="101"><PARAGRAPH><BOLD>s</BOLD> [<VARIABLE>count</VARIABLE>] </PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="76"><PARAGRAPH><BOLD>s 8</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="207"><PARAGRAPH>Single-step through 1 or <VARIABLE>count</VARIABLE> instructions, 
displaying each instruction and register contents it 
uses. A branch and the instruction in &ldquo;delay slot&rdquo; 
following it count as 1. Steps into subroutines. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="101"><PARAGRAPH><BOLD>S</BOLD> [<VARIABLE>count</VARIABLE>] </PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="76"><PARAGRAPH><BOLD>S 8</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="207"><PARAGRAPH>Single-step through 1 or <VARIABLE>count</VARIABLE> instructions as for 
the <COMMAND>s</COMMAND> command, but do not step into subroutines. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="101"><PARAGRAPH><BOLD>unbrk</BOLD>&space;<VARIABLE>n</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="76"><PARAGRAPH><BOLD>unbrk 2</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="207"><PARAGRAPH>Remove break point number <VARIABLE>n</VARIABLE>. Use <COMMAND>brk</COMMAND> with no 
argument to list break points by number. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="101"><PARAGRAPH><BOLD>wpt</BOLD> {r|w|rw} <VARIABLE>physaddr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="76"><PARAGRAPH><BOLD>wpt r 0x0841f608</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="207"><PARAGRAPH>Set a hardware watchpoint on a physical address. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<TIP><PREFIX>Tip</PREFIX>One way to force a memory dump from <COMMAND>symmon</COMMAND> is the command <COMMAND>call dumpsys</COMMAND>.</TIP>
<PARAGRAPH>Following a break or a watchpoint, use the <COMMAND>bt</COMMAND> command to display the stack history and use <COMMAND>printreg</COMMAND> to display the registers (see <XREF IDREF="98758" TYPE="TITLE">&ldquo;Commands to Display Memory&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>The hardware watchpoint used by the <INDEXTARGET ID="11-drvrdebug54"><!-- POSTPROCESSDATA: 11-drvrdebug54|symmon debugger:watchpoint register use --><INDEXTARGET ID="11-drvrdebug55"><!-- POSTPROCESSDATA: 11-drvrdebug55|CPU:watchpoint registers --><COMMAND>wpt</COMMAND> command uses hardware registers in the MIPS R4000 and R10000 processors (the R8000 does not support the watchpoint registers). When a read or write access is addressed to any byte in the doubleword specified by the physical address, <COMMAND>symmon</COMMAND> gains control and displays the instruction that is attempting the access on the console terminal.</PARAGRAPH>
<PARAGRAPH>The argument of <INDEXTARGET ID="11-drvrdebug56"><!-- POSTPROCESSDATA: 11-drvrdebug56|memory address:physical --><COMMAND>wpt</COMMAND> must be a physical memory address and a multiple of 8. Use <COMMAND>tlbvtop</COMMAND> to get the physical equivalent of an address in a user address space (see <XREF IDREF="45923" TYPE="TITLE">&ldquo;Commands to Manage Virtual Memory&rdquo;</XREF>). In a 32-bit kernel, the physical equivalent of an address in kernel space is obtained by changing the most significant hex digit to 0.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="45923">Commands to Manage Virtual Memory</TITLE><PARAGRAPH>The commands summarized in <INDEXTARGET ID="11-drvrdebug57"><!-- POSTPROCESSDATA: 11-drvrdebug57|symmon debugger:virtual memory commands --><INDEXTARGET ID="11-drvrdebug58"><!-- POSTPROCESSDATA: 11-drvrdebug58|virtual memory:debug display of --><XREF IDREF="66274" TYPE="TABLE">Table&nbsp;10-3</XREF> are used to display and manage the virtual memory translation system. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="10-3"><PREFIX>Table 10-3 </PREFIX><XREFTARGET ID="66274"> <EMPHASIS>(continued)        </EMPHASIS>Commands to Manage Virtual Memory</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Command</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="110"><PARAGRAPH>Example</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="202"><PARAGRAPH>Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>cacheflush <VARIABLE>range</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="110"><PARAGRAPH><BOLD>cacheflush $6:$6+4096</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="202"><PARAGRAPH>Flush both the instruction and data caches when 
they contain data that falls in <VARIABLE>range</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>tlbdump [<VARIABLE>lo:hi</VARIABLE>] </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="110"><PARAGRAPH><BOLD>tlbdump 1:3</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="202"><PARAGRAPH>Display the contents of the TLB registers. When a 
range of numbers is given, the registers from <VARIABLE>lo</VARIABLE> 
through <VARIABLE>hi</VARIABLE>-1 are displayed. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>tlbflush [<VARIABLE>lo:hi</VARIABLE>] </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="110"><PARAGRAPH><BOLD>tlbflush</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="202"><PARAGRAPH>Flush (nullify) the TLB registers specified. The 
registers are reloaded as required during 
subsequent execution. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>tlbpid </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="110"><PARAGRAPH><BOLD>tlbpid</BOLD> &lbreak;Current dbgmon pid = 79 </PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="202"><PARAGRAPH>Display the process slot number of the process 
whose context is in the TLB. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>tlbvtop <VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="110"><PARAGRAPH><BOLD>tlbptov 0xffffc000</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="202"><PARAGRAPH>Display the TLB register that maps <VARIABLE>addr</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="98758">Commands to Display Memory</TITLE><PARAGRAPH>The commands summarized in <INDEXTARGET ID="11-drvrdebug59"><!-- POSTPROCESSDATA: 11-drvrdebug59|driver debugging:memory display --><INDEXTARGET ID="11-drvrdebug60"><!-- POSTPROCESSDATA: 11-drvrdebug60|symmon debugger:memory display --><INDEXTARGET ID="11-drvrdebug61"><!-- POSTPROCESSDATA: 11-drvrdebug61|memory display --><XREF IDREF="72302" TYPE="TABLE">Table&nbsp;10-4</XREF> are used to display memory or variables. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="10-4"><PREFIX>Table 10-4 </PREFIX><XREFTARGET ID="72302"> <EMPHASIS>(continued)        </EMPHASIS>Commands to Display Memory</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="84"><PARAGRAPH>Command</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="79"><PARAGRAPH>Example</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="221"><PARAGRAPH>Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="84"><PARAGRAPH>bt [<VARIABLE>frames</VARIABLE>] </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="79"><PARAGRAPH><BOLD>bt 4</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="221"><PARAGRAPH>Display the calling function, the arguments, and the 
name of the called function for up to <VARIABLE>frames</VARIABLE> stack 
frames. Most useful after a break or interrupt. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="84"><PARAGRAPH>dis <VARIABLE>range</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="79"><PARAGRAPH><BOLD>dis geteminor</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="221"><PARAGRAPH>Disassemble and display the instructions over the 
specified range. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="84"><PARAGRAPH>dump [-b|-h|-w]&lbreak;[-o|-d|-x|-c] <VARIABLE>range</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="79"><PARAGRAPH>dump 0xc0000000 </PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="221"><PARAGRAPH>Display memory over a specified range. The options -b, 
-h, and -w specify how memory is grouped, as units of 
1, 2, or 4 bytes. The options -o, -d, -x, and -c specify 
translation into octal, decimal, hex and character. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="84"><PARAGRAPH>kp [<VARIABLE>routine</VARIABLE>] </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="79"><PARAGRAPH><BOLD>kp plist</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="221"><PARAGRAPH>Invoke a kernel print routine loaded with the idbg 
kernel module. If no routine is given, all available 
names are displayed. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="84"><PARAGRAPH>printregs </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="79"><PARAGRAPH><BOLD>printregs</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="221"><PARAGRAPH>Display all the registers as they were when the 
debugger was entered. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="84"><PARAGRAPH>string <VARIABLE>range</VARIABLE> [<VARIABLE>max</VARIABLE>] </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="79"><PARAGRAPH><BOLD>string $v1 0x80</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="221"><PARAGRAPH>Display memory as an ASCII string in quotes. Display 
stops at the first null byte, or, when <VARIABLE>max</VARIABLE> is specified, 
after at most <VARIABLE>max</VARIABLE> bytes. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The display routines available to the <COMMAND>kp</COMMAND> command are discussed under <XREF IDREF="98041" TYPE="TITLE">&ldquo;Using idbg&rdquo;</XREF>. The names that <COMMAND>idbg</COMMAND> accepts as commands are all available under <COMMAND>symmon</COMMAND> through the <COMMAND>kp</COMMAND> command.</PARAGRAPH>
<PARAGRAPH>Use the <COMMAND>dump</COMMAND> command under <COMMAND>symmon</COMMAND>. Under <COMMAND>idbg</COMMAND>, use the <COMMAND>hd</COMMAND> command for the same purpose.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Commands to Display the hwgraph</TITLE><PARAGRAPH>The commands in <INDEXTARGET ID="11-drvrdebug62"><!-- POSTPROCESSDATA: 11-drvrdebug62|hwgraph:display by symmon --><INDEXTARGET ID="11-drvrdebug63"><!-- POSTPROCESSDATA: 11-drvrdebug63|symmon debugger:hwgraph display --><XREF IDREF="22683" TYPE="TABLE">Table&nbsp;10-5</XREF> are used to display the contents of the hwgraph (see <XREF IDREF="51581" TYPE="TITLE">&ldquo;Hardware Graph&rdquo;</XREF>). </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="10-5"><PREFIX>Table 10-5 </PREFIX><XREFTARGET ID="22683"> <EMPHASIS>(continued)        </EMPHASIS>Utility Commands</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="45"><PARAGRAPH>Command</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="63"><PARAGRAPH>Example</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="218"><PARAGRAPH>Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>graph </PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="63"><PARAGRAPH><BOLD>graph</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="218"><PARAGRAPH>List summary of graph debugging commands. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>gsumm </PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="63"><PARAGRAPH><BOLD>gsumm</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="218"><PARAGRAPH>Summarize a graph (default graph is <FILENAME>/hw</FILENAME>). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>ghdls </PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="63"><PARAGRAPH><BOLD>ghdls</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="218"><PARAGRAPH>List all handles to a graph (<FILENAME>/hw</FILENAME> by default). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>gvertex </PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="63"><PARAGRAPH><BOLD>gvertex 0x004</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="218"><PARAGRAPH>List edges and attributes of a vertex given its handle. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>gname </PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="63"><PARAGRAPH><BOLD>gname 0x004</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="218"><PARAGRAPH>Display name of a vertex given its handle. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Utility Commands</TITLE><PARAGRAPH>The commands summarized in <XREF IDREF="44244" TYPE="TABLE">Table&nbsp;10-6</XREF> are general-purpose utilities. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="10-6"><PREFIX>Table 10-6 </PREFIX><XREFTARGET ID="44244">Utility Commands</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="97"><PARAGRAPH>Command</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="93"><PARAGRAPH>Example</PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="194"><PARAGRAPH>Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="97"><PARAGRAPH>calc</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="93"><PARAGRAPH><BOLD>calc</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="194"><PARAGRAPH>Starts a simple stack-oriented calculator (see 
text).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="97"><PARAGRAPH>clear</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="93"><PARAGRAPH><BOLD>clear</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="194"><PARAGRAPH>Clear the screen of the system console terminal.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="97"><PARAGRAPH>help </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="93"><PARAGRAPH><BOLD>help</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="194"><PARAGRAPH>List one-line summaries of all available 
commands. Use control-S and control-Q to 
control the scrolling of the display.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="97"><PARAGRAPH>g [-b|-h|-w | -d] &lbreak;[<VARIABLE>addr</VARIABLE> | $<VARIABLE>regname</VARIABLE>] </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="93"><PARAGRAPH><BOLD>g $a1&lbreak;
</BOLD>0x882fadf8:&lbreak;4294967295 0xffffffff</PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="194"><PARAGRAPH>Display one byte, halfword, word or 
doubleword (default word) of memory, or the 
contents of one register at the time symmon was 
entered, in decimal and hex.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="97"><PARAGRAPH>p [-b|-h|-w | -d] &lbreak;[<VARIABLE>addr</VARIABLE> | $<VARIABLE>regname</VARIABLE>] <VARIABLE>value</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="93"><PARAGRAPH><BOLD>p -w 0xc0000000 4095</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="194"><PARAGRAPH>Write a byte, halfword, word, or doubleword 
(default word) into a saved register or into 
memory at the specified address.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH></PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="98041">Using idbg</TITLE><PARAGRAPH>The <INDEXTARGET ID="11-drvrdebug64"><!-- POSTPROCESSDATA: 11-drvrdebug64|idbg debugger --><COMMAND>idbg</COMMAND> command is a utility that provides much of the display capability of <COMMAND>symmon</COMMAND> but from the command line of a user process, without stopping the system. Many details of <COMMAND>idbg</COMMAND> use are covered in the <REFPAGE>idbg(1M)</REFPAGE> reference page. Keep in mind that all idbg commands are available under the standalone debugger through the <COMMAND>kp</COMMAND> command (see <XREF IDREF="98758" TYPE="TITLE">&ldquo;Commands to Display Memory&rdquo;</XREF>).</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Loading and Invoking idbg</TITLE><PARAGRAPH>Superuser privilege is required to invoke <INDEXTARGET ID="11-drvrdebug65"><!-- POSTPROCESSDATA: 11-drvrdebug65|idbg debugger:loading --><INDEXTARGET ID="11-drvrdebug66"><!-- POSTPROCESSDATA: 11-drvrdebug66|idbg debugger:invoking --><COMMAND>idbg</COMMAND>, because it maps kernel memory. The command is ineffective unless its support modules have been made part of the kernel. This can be done permanently by changing the <FILENAME>irix.sm</FILENAME> file (see <XREF IDREF="31432" TYPE="TITLE">&ldquo;Including idbg in the Kernel Image&rdquo;</XREF>). Alternatively, you can load the needed modules dynamically using the <COMMAND>ml</COMMAND> command, as follows:</PARAGRAPH>
<EXAMPLE>
# ml ld -i /var/sysgen/boot/idbg.o
</EXAMPLE>
<PARAGRAPH>Dynamic loading is discussed at more length in the <REFPAGE>idbg(1M)</REFPAGE> and <REFPAGE>ml(1M)</REFPAGE> reference pages.</PARAGRAPH>
<PARAGRAPH>When the support modules are loaded, <COMMAND>idbg</COMMAND> can be invoked in three styles.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Invoking idbg for Interactive Use</TITLE><PARAGRAPH>Invoking the command with no arguments causes it to enter interactive mode, prompting for one command after another from standard input, as shown in <INDEXTARGET ID="11-drvrdebug67"><!-- POSTPROCESSDATA: 11-drvrdebug67|idbg debugger:interactive mode --><XREF IDREF="80792" TYPE="TEXT">Example&nbsp;10-4</XREF>.</PARAGRAPH>
<CODE><CAPTION LBL="10-4"><PREFIX>Example 10-4 </PREFIX><XREFTARGET ID="80792">Invoking idbg Interactively</CAPTION># idbg
idbg> plist 187
pid 187 is in proc slot 31
idbg> quit
#
</CODE>
<PARAGRAPH>The command terminates when <COMMAND>quit</COMMAND> is entered or when control-D (end of file) is pressed.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Invoking idbg with a Log File</TITLE><PARAGRAPH>Invoking the command with the <INDEXTARGET ID="11-drvrdebug68"><!-- POSTPROCESSDATA: 11-drvrdebug68|idbg debugger:log file output --><COMMAND>-r</COMMAND> option and a filename causes it to write all its output to the specified file, as shown in <XREF IDREF="67277" TYPE="TEXT">Example&nbsp;10-5</XREF>.</PARAGRAPH>
<CODE><CAPTION LBL="10-5"><PREFIX>Example 10-5 </PREFIX><XREFTARGET ID="67277">Invoking idbg with a Log File</CAPTION># idbg -r /var/tmp/idbg.save
idbg> plist 187
pid 187 is in proc slot 31
idbg> proc 31
proc: slot 31 addr 0x8832db30 pid 187 ppid 1 uid 0 abi IRIX5 
&space;SLEEP flags: load uload siglck recalc sv 
...
idbg> ^D
# cat /var/tmp/idbg.save
pid 187 is in proc slot 31
proc: slot 31 addr 0x8832db30 pid 187 ppid 1 uid 0 abi IRIX5 
&space;SLEEP flags: load uload siglck recalc sv 
...
#
</CODE>
<PARAGRAPH>You can use this method to collect a series of displays in a single file as you test a driver.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Invoking idbg for a Single Command</TITLE><PARAGRAPH>You can invoke <INDEXTARGET ID="11-drvrdebug69"><!-- POSTPROCESSDATA: 11-drvrdebug69|idbg debugger:command line use --><COMMAND>idbg</COMMAND> with a command on the command line. The output of the single command is written to standard output, where it can be captured or piped to another program.</PARAGRAPH>
<PARAGRAPH>The following example shows one simple use of this feature.</PARAGRAPH>
<CODE>
# idbg plist | fgrep -c tcsh
3
#
</CODE>
<PARAGRAPH>Since the displays of <COMMAND>idbg</COMMAND> are very rich, there are endless opportunities to use this mode to generate data within shell scripts, and to process it using tools such as <COMMAND>awk</COMMAND> and <COMMAND>perl</COMMAND>. Using <COMMAND>perl</COMMAND> you could write an intelligent display routine that showed the status of your driver's private data structures using your own terminology and display format.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Commands of idbg</TITLE><PARAGRAPH>Almost all <INDEXTARGET ID="11-drvrdebug70"><!-- POSTPROCESSDATA: 11-drvrdebug70|idbg debugger:command syntax --><COMMAND>idbg</COMMAND> commands are concerned with displaying kernel memory data in different ways. There are commands to display almost every type of kernel data.</PARAGRAPH>
<PARAGRAPH>The vocabulary of commands changes from release to release, and can change within releases by software patches. Also, the commands available depend on which support modules are loaded; for example lock and semaphore meters cannot be displayed unless the <FILENAME>ksynch_meter</FILENAME> module is loaded (see <XREF IDREF="83750" TYPE="TITLE">&ldquo;Including Lock Metering in the Kernel Image&rdquo;</XREF>). Only a few commands are listed in the <REFPAGE>idbg(1M)</REFPAGE> reference page.</PARAGRAPH>
<PARAGRAPH>The commands summarized in this book are generally useful and available on all platforms in the current release of IRIX. For a complete (but cursory) list, use the command itself.</PARAGRAPH>
<EXAMPLE>
# idbg help | lp
</EXAMPLE>
<PARAGRAPH>In general, commands take zero or one argument. Typically the argument is a number, which can be any of the following:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>A kernel symbol, optionally +offset</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A number in hexadecimal (starting with 0x)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A number in octal (starting with 0)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A number in decimal.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The number is interpreted in the context of the command: sometimes it represents a process ID (pid), sometimes a process &ldquo;slot&rdquo; number or a buffer number. Often commands treat positive numbers as slot numbers or table indexes, while negative numbers are treated as addresses in kernel space.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Commands to Display Memory and Symbols</TITLE><PARAGRAPH>The commands summarized in <INDEXTARGET ID="11-drvrdebug71"><!-- POSTPROCESSDATA: 11-drvrdebug71|idbg debugger:memory display --><XREF IDREF="21514" TYPE="TABLE">Table&nbsp;10-7</XREF> are used to display memory based on specific addresses or symbols, and to display the addresses for kernel symbols. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="10-7"><PREFIX>Table 10-7 </PREFIX><XREFTARGET ID="21514"> <EMPHASIS>(continued)        </EMPHASIS>Commands to Display Memory and Symbols</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="81"><PARAGRAPH>Command</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>dsym <VARIABLE>addr</VARIABLE> [<VARIABLE>length</VARIABLE>] </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Dump memory by words, starting at <VARIABLE>addr</VARIABLE>. When a word of memory data is 
reasonably close to the value of a kernel symbol, the symbol plus offset is 
displayed instead of the hex value. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>hd <VARIABLE>addr</VARIABLE> [<VARIABLE>length</VARIABLE>] </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Dump memory in bytes, with ASCII translation, starting at <VARIABLE>addr</VARIABLE>. When <VARIABLE>length</VARIABLE> 
is given, it is a count of words (not bytes) to be displayed. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>pb </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Display the strings in the circular putbuf (see <XREF IDREF="37423" TYPE="TITLE">&ldquo;Displaying to the Circular 
Message Buffer&rdquo;</XREF>). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>string <VARIABLE>addr </VARIABLE>[<VARIABLE>max</VARIABLE>] </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Display memory as an ASCII string. Display stops at the first null byte, or, 
when <VARIABLE>max</VARIABLE> is specified, after at most <VARIABLE>max</VARIABLE> bytes. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>When you display the circular buffer, there is no special indication to show which line is the newest. You have to deduce the boundary between the newest and oldest lines from the content.<INDEXTARGET ID="11-drvrdebug72"><!-- POSTPROCESSDATA: 11-drvrdebug72|putbuf circular buffer --></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Commands to Display Process Information</TITLE><PARAGRAPH>The commands summarized in <INDEXTARGET ID="11-drvrdebug73"><!-- POSTPROCESSDATA: 11-drvrdebug73|process:display data about --><INDEXTARGET ID="11-drvrdebug74"><!-- POSTPROCESSDATA: 11-drvrdebug74|idbg debugger:display process data --><XREF IDREF="84740" TYPE="TABLE">Table&nbsp;10-8</XREF> are concerned with displaying the status of processes. Processes are recorded in an array of &ldquo;slots.&rdquo; The <INDEXTARGET ID="11-drvrdebug75"><!-- POSTPROCESSDATA: 11-drvrdebug75|process:table of in kernel --><COMMAND>plist</COMMAND> command gives the slot number for a given process ID. Many other commands take process addresses. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="10-8"><PREFIX>Table 10-8 </PREFIX><XREFTARGET ID="84740"> <EMPHASIS>(continued)        </EMPHASIS>Commands to Display Process Information</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="97"><PARAGRAPH>Command</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="97"><PARAGRAPH>eframe [ <VARIABLE>addr</VARIABLE> ] </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Displays the contents of an exception frame. With no argument, 
displays the last exception taken for the current process. Otherwise 
displays the exception associated with the process specified by address 
<VARIABLE>addr</VARIABLE> (negative number). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="97"><PARAGRAPH>pchain <VARIABLE>PID</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Display the slot numbers of sibling processes to process number <VARIABLE>PID</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="97"><PARAGRAPH>plist [ <VARIABLE>PID </VARIABLE>] </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>With no argument, displays a one-line summary of every active process 
slot, including slot number and process ID. Given a nonzero <VARIABLE>PID</VARIABLE>, 
displays the slot containing that process number. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="97"><PARAGRAPH>ptree [ <VARIABLE>PID</VARIABLE> | <VARIABLE>addr</VARIABLE> ] </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>With a <VARIABLE>PID </VARIABLE>number (greater than zero), finds the process structure for 
that process. Otherwise tries to use the process structure at <VARIABLE>addr</VARIABLE>, not 
always reliably. Displays the command name and arguments for that 
process and for all processes that descend from it. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="97"><PARAGRAPH>proc [ <VARIABLE>PID</VARIABLE> | <VARIABLE>addr</VARIABLE> ] </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Displays all fields of a process structure specified by process number 
<VARIABLE>PID</VARIABLE> or address <VARIABLE>addr</VARIABLE> (negative number). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="97"><PARAGRAPH>signal [ <VARIABLE>PID</VARIABLE> | <VARIABLE>addr</VARIABLE> ] </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Displays information about pending signals for the process specified by 
process number <VARIABLE>PID</VARIABLE> or address <VARIABLE>addr</VARIABLE> (negative number). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="97"><PARAGRAPH>slpproc [ -2 | -4 | -8 ] </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Displays a summary of all processes with <FUNCTION>p_stat</FUNCTION> of SSLEEP or SXBRK. 
When an argument is given, its absolute value is used as a mask: 2 
ignores processes in <FUNCTION>wait()</FUNCTION>; 4 ignores processes without <FILENAME>upages</FILENAME>; 8 
ignores processes on a sleep semaphore. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="97"><PARAGRAPH>ubt <VARIABLE>slot</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Displays a backtrace of the call stack of the sleeping process in the 
specified slot. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="97"><PARAGRAPH>user [ <VARIABLE>PID</VARIABLE> | <VARIABLE>addr</VARIABLE> ] </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Displays the user area associated with the process specified either by 
process number <VARIABLE>PID</VARIABLE> or address <VARIABLE>addr</VARIABLE> (negative number). Less useful 
now that the user structure has been eliminated. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Commands to Display Locks and Semaphores</TITLE><PARAGRAPH>The commands summarized in <INDEXTARGET ID="11-drvrdebug76"><!-- POSTPROCESSDATA: 11-drvrdebug76|lock metering support --><INDEXTARGET ID="11-drvrdebug77"><!-- POSTPROCESSDATA: 11-drvrdebug77|idbg debugger:lock meter display --><XREF IDREF="80915" TYPE="TABLE">Table&nbsp;10-9</XREF> display the state of semaphores and locks of different kinds, including metering information when the metered-lock module is included in the kernel.</PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="10-9"><PREFIX>Table 10-9 </PREFIX><XREFTARGET ID="80915"> <EMPHASIS>(continued)        </EMPHASIS>Commands to Display Locks and Semaphores</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="55"><PARAGRAPH>Command</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="330"><PARAGRAPH>Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="55"><PARAGRAPH>lock <VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="330"><PARAGRAPH>Display the state of the spinlock at <VARIABLE>addr</VARIABLE>. This command is available only in 
multiprocessor systems. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="55"><PARAGRAPH>mrlock <VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="330"><PARAGRAPH>Display the state of the reader/writer lock at <VARIABLE>addr</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="55"><PARAGRAPH>mutex <VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="330"><PARAGRAPH>Display the state of the mutual exclusion lock at <VARIABLE>addr</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="55"><PARAGRAPH>sema <VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="330"><PARAGRAPH>Display the state of the semaphore at <VARIABLE>addr</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="55"><PARAGRAPH>smeter <VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="330"><PARAGRAPH>Display metering information about the semaphore at <VARIABLE>addr</VARIABLE>. When <VARIABLE>addr</VARIABLE> is positive, 
it is taken as an index to the semaphore metering array. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="55"><PARAGRAPH>sv <VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="330"><PARAGRAPH>Display the state of the synchronizing variable at <VARIABLE>addr</VARIABLE>, including waiting processes 
and metering information. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="98444">Commands to Display I/O Status</TITLE><PARAGRAPH>The commands summarized in <INDEXTARGET ID="11-drvrdebug78"><!-- POSTPROCESSDATA: 11-drvrdebug78|SCSI bus:display request structure --><INDEXTARGET ID="11-drvrdebug79"><!-- POSTPROCESSDATA: 11-drvrdebug79|idbg debugger:display I/O status --><XREF IDREF="12092" TYPE="TABLE">Table&nbsp;10-10</XREF> can be used to display the status of an I/O device or driver.</PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="10-10"><PREFIX>Table 10-10 </PREFIX><XREFTARGET ID="12092"> <EMPHASIS>(continued)        </EMPHASIS>Commands to Display I/O Status</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="45"><PARAGRAPH>Command</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="340"><PARAGRAPH>Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>file [<VARIABLE>addr</VARIABLE>] </PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="340"><PARAGRAPH>When <VARIABLE>addr</VARIABLE> is omitted, displays a summary of all entries of the kernel table of open 
files. When <VARIABLE>addr</VARIABLE> is the address of a file structure, displays only that entry. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>scsi <VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="340"><PARAGRAPH>Display the contents of the <VARIABLE>scsi_request</VARIABLE> structure at <VARIABLE>addr</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>uio <VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="340"><PARAGRAPH>Display the contents of the <VARIABLE>uio_t</VARIABLE> object at <VARIABLE>addr</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="29132">Commands to Display buf_t Objects</TITLE><PARAGRAPH>The commands summarized in <INDEXTARGET ID="11-drvrdebug80"><!-- POSTPROCESSDATA: 11-drvrdebug80|data types:<VARIABLE>buf_t</VARIABLE>:displaying --><XREF IDREF="96653" TYPE="TABLE">Table&nbsp;10-11</XREF> are used to display the state of <VARIABLE>buf_t</VARIABLE> objects and the queue of <VARIABLE>buf_t</VARIABLE> objects maintained by the kernel. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="10-11"><PREFIX>Table 10-11 </PREFIX><XREFTARGET ID="96653"> <EMPHASIS>(continued)        </EMPHASIS>Commands to Display buf_t Objects</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="59"><PARAGRAPH>Command</PARAGRAPH>
</CELL>
<CELL LEFT="65" WIDTH="326"><PARAGRAPH>Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="59"><PARAGRAPH>buf [<VARIABLE>addr</VARIABLE>] </PARAGRAPH>
</CELL>
<CELL LEFT="65" WIDTH="326"><PARAGRAPH>If <VARIABLE>addr</VARIABLE> is omitted, print the entire buffer chain. When <VARIABLE>addr</VARIABLE> is supplied as the 
address of a buf_t, dump that structure. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="59"><PARAGRAPH>findbuf <VARIABLE>blkno</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="65" WIDTH="326"><PARAGRAPH>Display any <VARIABLE>buf_t</VARIABLE> in the buffer chain with <VARIABLE>b_blkno</VARIABLE> containing <VARIABLE>blkno</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="59"><PARAGRAPH>qbuf <VARIABLE>eminor</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="65" WIDTH="326"><PARAGRAPH>Find and display all <VARIABLE>buf_t</VARIABLE> objects that are queued to the device with external 
minor number <VARIABLE>eminor</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="31155">Commands to Display STREAMS Structures</TITLE><PARAGRAPH>The commands summarized in <INDEXTARGET ID="11-drvrdebug81"><!-- POSTPROCESSDATA: 11-drvrdebug81|STREAMS:debugging --><INDEXTARGET ID="11-drvrdebug82"><!-- POSTPROCESSDATA: 11-drvrdebug82|STREAMS:display data structures --><XREF IDREF="68071" TYPE="TABLE">Table&nbsp;10-12</XREF> are concerned with displaying STREAMS data structures such as message buffers. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="10-12"><PREFIX>Table 10-12 </PREFIX><XREFTARGET ID="68071"> <EMPHASIS>(continued)        </EMPHASIS>Commands to Display STREAMS Structures</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="61"><PARAGRAPH>Command</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="248"><PARAGRAPH>Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="61"><PARAGRAPH>datab <VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="248"><PARAGRAPH>Display the contents of the STREAMS data block at <VARIABLE>addr</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="61"><PARAGRAPH>mbuf <VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="248"><PARAGRAPH>Display the contents of the STREAMS <VARIABLE>mbuf</VARIABLE> structure at <VARIABLE>addr</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="61"><PARAGRAPH>modinfo <VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="248"><PARAGRAPH>Display the contents of the module info structure at <VARIABLE>addr</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="61"><PARAGRAPH>msgb <VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="248"><PARAGRAPH>Display the contents of the STREAMS message block at <VARIABLE>addr</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="61"><PARAGRAPH>qband <VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="248"><PARAGRAPH>Display the contents of the <VARIABLE>qband_t</VARIABLE> object at <VARIABLE>addr</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="61"><PARAGRAPH>qinfo <VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="248"><PARAGRAPH>Display the contents of the <VARIABLE>qinit</VARIABLE> structure at <VARIABLE>addr</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="61"><PARAGRAPH>strh <VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="248"><PARAGRAPH>Display the contents of the <VARIABLE>stdata</VARIABLE> structure at <VARIABLE>addr</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="61"><PARAGRAPH>strfq <VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="248"><PARAGRAPH>Display the contents of the <VARIABLE>queue_t </VARIABLE>object at <VARIABLE>addr</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="38031">Commands to Display Network-Related Structures</TITLE><PARAGRAPH>The commands summarized in <INDEXTARGET ID="11-drvrdebug83"><!-- POSTPROCESSDATA: 11-drvrdebug83|network driver:debugging --><XREF IDREF="71401" TYPE="TABLE">Table&nbsp;10-13</XREF> display data structures that are related in one way or another to networking and network device drivers. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="10-13"><PREFIX>Table 10-13 </PREFIX><XREFTARGET ID="71401"> <EMPHASIS>(continued)        </EMPHASIS>Commands to Display Network-Related Structures</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="51"><PARAGRAPH>Command</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="334"><PARAGRAPH>Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="51"><PARAGRAPH>ifnet <VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="334"><PARAGRAPH>Display the contents of the ifnet object at <VARIABLE>addr</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="51"><PARAGRAPH>rawcb <VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="334"><PARAGRAPH>Display the contents of the <VARIABLE>rawcb</VARIABLE> structure at <VARIABLE>addr</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="51"><PARAGRAPH>rawif <VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="334"><PARAGRAPH>Display the contents of the <VARIABLE>rawif</VARIABLE> structure at <VARIABLE>addr</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="51"><PARAGRAPH>sock <VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="334"><PARAGRAPH>Display the <VARIABLE>sockbuf</VARIABLE> structure at <VARIABLE>addr</VARIABLE>. When <VARIABLE>addr</VARIABLE> is positive, it is taken as a physical 
address; otherwise it is a kernel address. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="56887">Using icrash</TITLE><PARAGRAPH>The <COMMAND>icrash</COMMAND> utility generates detailed kernel information in an easy-to-read format, enabling the generation of reports about system crash dumps created by <REFPAGE>savecore(1M)</REFPAGE>. Depending on the type of system crash dump, <COMMAND>icrash</COMMAND> can create unique reports that contain information about what happened when the system crashed. The <COMMAND>icrash</COMMAND> utility can be run on live systems or with a <VARIABLE>namelist</VARIABLE> and core file specified on the command line. The default namelist is <FILENAME>/unix</FILENAME>, used when analyzing a live system.</PARAGRAPH>
<PARAGRAPH>The <COMMAND>icrash</COMMAND> program may be used as a post-mortem tool for analyzing system crashes. For post-mortem analysis of a system crash, specify <FILENAME>/var/adm/crash/unix*</FILENAME> as namelist. You can also use <COMMAND>icrash</COMMAND> to generate a wide variety of reports and displays based on a kernel panic dump from a crashed system. For example, you can display the <VARIABLE>putbuf</VARIABLE> message buffer using the <COMMAND>stat</COMMAND> command of <COMMAND>icrash</COMMAND>. For more information, see the <REFPAGE>icrash(1M)</REFPAGE> reference page for the current release. </PARAGRAPH>
</SECTION1>
</CHAPTER>
