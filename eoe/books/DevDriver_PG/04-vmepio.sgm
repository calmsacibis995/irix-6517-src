<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="4"><TITLE><XREFTARGET ID="66996">User-Level Access to Devices</TITLE><PARAGRAPH>Programmed I/O (PIO) refers to loading and storing data between program variables and device registers. This is done by setting up a memory mapping of a device into the process address space, so that the program can treat device registers as if they were volatile memory locations.<INDEXTARGET ID="04-vmepio1"><!-- POSTPROCESSDATA: 04-vmepio1|Programmed I/O (PIO) --></PARAGRAPH>
<PARAGRAPH>This chapter discusses the methods of setting up this mapping, and the performance that can be obtained. The main topics are as follows:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="91417" TYPE="TITLE">&ldquo;PCI Programmed I/O&rdquo;</XREF> discusses PIO mapping of PCI devices.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="33471" TYPE="TITLE">&ldquo;EISA Programmed I/O&rdquo;</XREF> discusses PIO mapping of EISA bus devices in the Indigo<SUPERSCRIPT>2</SUPERSCRIPT> workstation line.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="70857" TYPE="TITLE">&ldquo;VME Programmed I/O&rdquo;</XREF> discusses PIO mapping of VME devices.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="94776" TYPE="TITLE">&ldquo;VME User-Level DMA&rdquo;</XREF> discusses the use of the VME DMA engine.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Normally, PIO programs are designed in synchronous fashion; that is, the process issues commands to the device and then polls the device to find out when the action is complete. (However, it is possible for a user process to receive interrupts from some mapped devices if you have purchased the optional REACT software.)</PARAGRAPH>
<PARAGRAPH>A user-level process can perform DMA transfers from a VME bus master or (in the Challenge or Onyx series) a VME bus slave, directly into the process address space. The use of these features is covered under <XREF IDREF="94776" TYPE="TITLE">&ldquo;VME User-Level DMA&rdquo;</XREF>.</PARAGRAPH>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="91417">PCI Programmed I/O</TITLE><NOTE><PREFIX>Note</PREFIX>For an overview of the PCI bus and its hardware implementation in Silicon Graphics systems, see <XREF IDREF="46138" TYPE="TITLE">Chapter&nbsp;20, &ldquo;PCI Device Attachment.&rdquo;</XREF> For syntax details of the user interface to PCI, see the <REFPAGE>pciba(7M)</REFPAGE> reference page. As of IRIX 6.5, the <INDEXTARGET ID="04-vmepio2"><!-- POSTPROCESSDATA: 04-vmepio2|Programmed I/O (PIO):PCI bus --><INDEXTARGET ID="04-vmepio3"><!-- POSTPROCESSDATA: 04-vmepio3|PCI bus:user-level PIO --><INDEXTARGET ID="04-vmepio4"><!-- POSTPROCESSDATA: 04-vmepio4|<ITALICS>usrpci, pciba</ITALICS><ITALICS>pciba, usrpci</ITALICS> --><ITALICS>pciba</ITALICS> user-level PCI bus adapter interface has replaced the <ITALICS>usrpci</ITALICS> facility.</NOTE>
<SECTION2 LBL="" HELPID = ""><TITLE>Mapping a PCI Device Into Process Address Space</TITLE><PARAGRAPH>As discussed in <XREF IDREF="65466" TYPE="TITLE">&ldquo;CPU Access to Device Registers&rdquo;</XREF>, an I/O device is represented as an address, or range of addresses, in the address space of its bus. A kernel-level device driver has the ability to set up a mapping between an address on an I/O bus and an arbitrary location in the address space of a user-level process. When this has been done, the bus location appears to be a variable in memory. The program can assign values to it, or refer to it in expressions.</PARAGRAPH>
<PARAGRAPH>The PCI bus addresses managed by a device are not wired or jumpered into the board; they are established dynamically at the time the system attaches the device. The assigned bus addresses can vary from one day to the next, as devices are added to or removed from that PCI bus adapter. For this reason, you cannot program the bus addresses of a PCI device into software or into a configuration file.</PARAGRAPH>
<PARAGRAPH>In order to map bus addresses for a particular device, you must open the device special file that represents that device. You pass the file descriptor for the opened device to the <FUNCTION>mmap()</FUNCTION> function. If the device driver for the device supports memory mapping&mdash;mapping is an optional feature of a PCI device driver&mdash;the mapping is set up.</PARAGRAPH>
<PARAGRAPH>The PCI bus defines three address spaces: configuration space, I/O space, and memory space. It is up to the device driver which of the spaces it allows you to map. Some device drivers may set up a convention allowing you to map in different spaces.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="57267">PCI Device Special Files</TITLE><PARAGRAPH>Device special files for PCI devices are established in the <INDEXTARGET ID="04-vmepio5"><!-- POSTPROCESSDATA: 04-vmepio5|device special file:PCI mapping --><FILENAME>/hw</FILENAME> filesystem by the PCI device driver when the device is attached; see <XREF IDREF="51581" TYPE="TITLE">&ldquo;Hardware Graph&rdquo;</XREF>. These pathnames are dynamic. Typically, the system administrator also creates stable, predictable device special files in the <FILENAME>/dev</FILENAME> filesystem. The path to a specific device is determined by the device driver for that device.</PARAGRAPH>
<PARAGRAPH>The PCI bus adapter also creates a set of generic PCI device names for each PCI slot in the system. The names of these special files can be displayed by the following command:</PARAGRAPH>
<CODE>
<USERINPUT>find /hw -name pci  -print -exec ls -l {} \;</USERINPUT>&space;
/hw/module/1/slot/io1/xwidget/pci/0
total 0
crw-------    0 root     sys        0, 78 Aug 12 15:27 config
crw-------    0 root     sys        0, 79 Aug 12 15:27 default
crw-------    0 root     sys        0, 77 Aug 12 15:27 io
crw-------    0 root     sys        0, 75 Aug 12 15:27 mem
/hw/module/1/slot/io1/xwidget/pci/1
total 0
crw-------    0 root     sys        0, 85 Aug 12 15:27 config
crw-------    0 root     sys        0, 86 Aug 12 15:27 default
crw-------    0 root     sys        0, 84 Aug 12 15:27 io
crw-------    0 root     sys        0, 82 Aug 12 15:27 mem
</CODE>
<PARAGRAPH>The names are not leaf vertexes and cannot be opened. However, the names <FILENAME>config</FILENAME>, <FILENAME>io</FILENAME>, <FILENAME>mem</FILENAME>, and <FILENAME>default</FILENAME> are character special devices that can be opened from a process with the correct privilege. The names represent the following bus addresses: </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="4-1"><PREFIX>Table 4-1 </PREFIX><XREFTARGET ID="41410"> <EMPHASIS>(continued)        </EMPHASIS>PCI Device Special File Names for User Access</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="49"><PARAGRAPH>Name</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="229"><PARAGRAPH>PCI Bus Address Space</PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="108"><PARAGRAPH>Offset in mmap() Call</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH><FILENAME>config</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="229"><PARAGRAPH>Configuration space or spaces on the card in this slot. </PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="108"><PARAGRAPH>Offset in config space. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH><FILENAME>default</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="229"><PARAGRAPH>PCI bus memory space defined by the first base address 
register (BAR) on the card. </PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="108"><PARAGRAPH>Added to BAR. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH><FILENAME>io</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="229"><PARAGRAPH>PCI bus I/O space defined by this card. </PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="108"><PARAGRAPH>Offset in I/O space. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH><FILENAME>mem</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="229"><PARAGRAPH>PCI bus 32-bit or 64-bit memory address space allocated 
to this card when it was attached. </PARAGRAPH>
</CELL>
<CELL LEFT="290" WIDTH="108"><PARAGRAPH>Offset in total allocated 
memory space. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<NOTE><PREFIX>Note</PREFIX>With <ITALICS>pciba</ITALICS> under IRIX 6.5 it is no longer possible to access <FILENAME>config</FILENAME> space directly by means of <FUNCTION>mmap()</FUNCTION> I/O&mdash;<FUNCTION>ioctl()</FUNCTION> calls must be used instead.</NOTE>
<SECTION3 LBL="" HELPID = ""><TITLE>Opening a Device Special File</TITLE><PARAGRAPH>Either kind of pathname is passed to the <FUNCTION>open()</FUNCTION> system function, along with flags representing the type of access (see the <REFPAGE>open(2)</REFPAGE> reference page). You can use the returned file descriptor for any operation supported by the device driver. The <FILENAME>pciba</FILENAME> device driver supports only the <FUNCTION>mmap()</FUNCTION> and <FUNCTION>unmap()</FUNCTION> functions.</PARAGRAPH>
<PARAGRAPH>A driver for a specific PCI device may or may not support <FUNCTION>mmap()</FUNCTION>, <FUNCTION>read()</FUNCTION> and <FUNCTION>write()</FUNCTION>, or <FUNCTION>ioctl()</FUNCTION> operations.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Using mmap() With PCI Devices</TITLE><PARAGRAPH>When you have successfully opened a <INDEXTARGET ID="04-vmepio6"><!-- POSTPROCESSDATA: 04-vmepio6|IRIX functions:<FUNCTION>mmap</FUNCTION>():PCI PIO --><FILENAME>pciba</FILENAME> device special file, you use the file descriptor as the primary input parameter in a call to the <FUNCTION>mmap()</FUNCTION> system function.</PARAGRAPH>
<PARAGRAPH>This function is documented for all its many uses in the <REFPAGE>mmap(2)</REFPAGE> reference page. For purposes of mapping a PCI device into memory, the parameters should be as follows (using the names from the reference page): </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Should be NULL to permit the kernel to choose an address in user process 
space. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>len</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>The length of the span of PCI addresses to map.  </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>prot</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>PROT_READ for input, PROT_WRITE for output, or the logical sum of those 
names when the device will be used for both input and output. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>flags</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>MAP_SHARED. Add MAP_PRIVATE if this mapping is not to be visible to 
child processes created with the <FUNCTION>sproc()</FUNCTION> function (see the <REFPAGE>sproc(2)</REFPAGE> reference 
page). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>fd</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>The file descriptor returned from opening the device special file. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>off</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>The offset into the device address space. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The meaning of the <VARIABLE>off</VARIABLE> value depends on the PCI bus address space represented by the device special file, as indicated in <XREF IDREF="41410" TYPE="TABLE">Table&nbsp;4-1</XREF>.</PARAGRAPH>
<PARAGRAPH>The value returned by <FUNCTION>mmap()</FUNCTION> is the virtual address that corresponds to the starting PCI bus address. When the process accesses that address, the access is implemented by PIO data transfer to or from the PCI bus.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Map Size Limits</TITLE><PARAGRAPH>There are limits to the amount and location of PCI bus address space that can be mapped for PIO. The system architecture can restrict the span of mappable addresses, and kernel resource constraints can impose limits. In order to create the map, the PCI device driver has to create a software object called a PIO map. In some systems, only a limited number of PIO maps can be active at one time.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>PCI Bus Hardware Errors</TITLE><PARAGRAPH>When the PCI bus adapter reports an addressing or access error, the error is reflected back to the device driver. This can take place long after the instruction that initiated the error transaction. For example, a PIO store to a memory-mapped PCI device can (in certain hardware architectures) pass through several layers of translation. An error could be detected several microseconds after the CPU store that initiated the write. By that time, the CPU could have executed hundreds more instructions.</PARAGRAPH>
<PARAGRAPH>When the <FILENAME>pciba</FILENAME> device driver is notified of a PCI Bus error, it looks up the identities of all user processes that had mapped the part of PCI address space where the error occurred. The driver then sends a SIGBUS signal to each such process. As a result of this policy, your process could receive a SIGBUS for an error it did not cause; and when your process did cause the error, the signal could arrive a long time after the erroneous transaction was initiated.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>PCI PIO Example</TITLE><PARAGRAPH>The code in X demonstrates how to dump the standard configuration space registers of a device in PCI slot 1 on an Origin200 (PCI slot 1 is XIO bus slot 5 on this system).</PARAGRAPH>
<CODE><CAPTION LBL="4-1"><PREFIX>Example 4-1 </PREFIX>PCI Configuration Space Dump</CAPTION>/*
&space;* Use pciba to dump the registers found 
&space;* using base address register 0.
&space;*
&space;* See pciba(7m).
&space;*/
#include &lt;sys/types.h>
#include &lt;sys/mman.h>
#include &lt;sys/fcntl.h>
#include &lt;sys/prctl.h>
#include &lt;unistd.h>
#include &lt;stdio.h>
/*
&space;* Path assumes O2000/Onyx2 PCI shoebox installed
&space;* in first CPU module.
&space;*/
#define MEMPATH "/hw/module/1/slot/io2/pci_xio/pci/2/base/0"
#define MEMSIZE (128)
extern int errno;
main(int argc, char *argv[])
{
&space;       volatile u_int *word_addr;
&space;       int     fd;
&space;       char    *path;
&space;       int     size, newline = 0;
&space;       path = MEMPATH;
&space;       size = MEMSIZE;
&space;       fd = open(path, O_RDWR);
&space;       if (fd &lt; 0 ) {
&space;               perror("open ../base/0 ");
&space;               return errno;
&space;       } else {
&space;               printf("Successfully opened %s fd: %d\n", path, fd);
&space;               printf("Trying mmap\n");
&space;               word_addr = (unsigned int *)
&space;                    mmap(0,size,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);
&space;               if (word_addr == (unsigned int *)-1) {
&space;                       perror("mmap");
&space;               } else {
&space;                       int     i;
&space;                       volatile int    x;
&space;                       printf("Dumping registers \n");
&space;                       for (i = 0; i &lt; 32; i++){
&space;                               x = *(volatile int *)(word_addr + i) ;
&space;                               if (newline == 0) {
&space;                                       printf("0x%2.2x:", i*4);
&space;                               }
&space;                               printf(" 0x%8.8x", x);
&space;                               if ((++newline%4) == 0){
&space;                                       newline = 0;
&space;                                       printf("\n");
&space;                               }
&space;                       }
&space;               }
&space;               close (fd);
&space;       }
&space;       exit(0);
} 
</CODE>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="33471"><XREFTARGET ID="93811">EISA Programmed I/O</TITLE><PARAGRAPH>The EISA bus is supported in Silicon Graphics Indigo<INDEXTARGET ID="04-vmepio7"><!-- POSTPROCESSDATA: 04-vmepio7|EISA bus:user-level PIO --><INDEXTARGET ID="04-vmepio8"><!-- POSTPROCESSDATA: 04-vmepio8|Programmed I/O (PIO):EISA bus --><SUPERSCRIPT>2</SUPERSCRIPT> workstations only. For an overview of the EISA bus and its implementation in Silicon Graphics systems, see <XREF IDREF="27909" TYPE="TITLE">Chapter&nbsp;18, &ldquo;EISA Device Drivers.&rdquo;</XREF></PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Mapping an EISA Device Into Memory</TITLE><PARAGRAPH>As discussed in <XREF IDREF="65466" TYPE="TITLE">&ldquo;CPU Access to Device Registers&rdquo;</XREF>, an I/O device is represented as an address or range of addresses in the address space of its bus. A kernel-level device driver has the ability to set up a mapping between the bus address of a device register and an arbitrary location in the address space of a user-level process. When this has been done, the device register appears to be a variable in memory&mdash;the program can assign values to it, or refer to it in expressions.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Learning EISA Device Addresses</TITLE><PARAGRAPH>In order to map an EISA device for PIO, you must know the following points:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>which EISA bus adapter the device is on</PARAGRAPH>
<PARAGRAPH>In all Silicon Graphics systems that support it, there is only one EISA bus adapter, and its number is 0.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>whether you need access to the EISA bus memory or I/O address space</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the address and length of the desired registers within the address space</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>You can find all these values by examining files in the <INDEXTARGET ID="04-vmepio9"><!-- POSTPROCESSDATA: 04-vmepio9|VECTOR statement:EISA PIO --><INDEXTARGET ID="04-vmepio10"><!-- POSTPROCESSDATA: 04-vmepio10|configuration files:<FILENAME>/var/sysgen/system/irix.sm</FILENAME> --><FILENAME>/var/sysgen/system</FILENAME> directory, especially the <FILENAME>/var/sysgen/system/irix.sm</FILENAME> file, in which each configured EISA device is specified by a VECTOR line. When you examine a VECTOR line, note the following parameter values: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><COMMAND>bustype</COMMAND>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Specified as <COMMAND>EISA</COMMAND> for EISA devices. The VECTOR statement can be 
used for other types of buses as well. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><COMMAND>adapter</COMMAND>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The number of the bus where the device is attached (0). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><COMMAND>iospace</COMMAND>, 
<COMMAND>iospace2</COMMAND>, 
<COMMAND>iospace3</COMMAND>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Each <COMMAND>iospace</COMMAND> group specifies the address space, starting bus address, 
and the size of a segment of bus address space used by this device. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Within each <COMMAND>iospace</COMMAND> parameter group you find keywords and numbers for the address space and addresses for a device. The following is an example of a VECTOR line (which must be a single physical line in the system file):</PARAGRAPH>
<CODE>
VECTOR: bustype=EISA module=if_ec3 ctlr=1
iospace=(EISAIO,0x1000,0x1000)
exprobe_space=(r,EISAIO, 0x1c80,4,0x6010d425,0xffffffff)
</CODE>
<PARAGRAPH>This example specifies a device that resides in the I/O space at offset 0x1000 (the slot-1 I/O space) for the usual length of 0x1000 bytes. The <COMMAND>exprobe_space</COMMAND> parameter suggests that a key device register is at 0x1c80.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Opening a Device Special File</TITLE><PARAGRAPH>When you know the device addresses, you can open a device special file that represents the correct range of addresses. The device special files for EISA mapping are found in <INDEXTARGET ID="04-vmepio11"><!-- POSTPROCESSDATA: 04-vmepio11|device special file:EISA mapping --><VARIABLE>/dev/eisa</VARIABLE>.</PARAGRAPH>
<PARAGRAPH>The naming convention for these files is as follows: Each file is named <BOLD>eisa</BOLD><VARIABLE>B</VARIABLE><BOLD>a</BOLD><VARIABLE>M</VARIABLE>, where </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>B</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="288"><PARAGRAPH>is a digit for the bus number (0) </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>M</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="288"><PARAGRAPH>is the modifier, either <COMMAND>io</COMMAND> or <COMMAND>mem</COMMAND>&space;</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The device special file for the device described by the example VECTOR line in the preceding section would be <FILENAME>/dev/vme/eisa0aio</FILENAME>.</PARAGRAPH>
<PARAGRAPH>In order to map a device on a particular bus and address space, you must open the corresponding file in <FILENAME>/dev/eisa</FILENAME>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using the mmap() Function</TITLE><PARAGRAPH>When you have successfully opened the device special file, you use the file descriptor as the primary input parameter in a call to the <INDEXTARGET ID="04-vmepio12"><!-- POSTPROCESSDATA: 04-vmepio12|IRIX functions:<FUNCTION>mmap</FUNCTION>():EISA PIO --><FUNCTION>mmap()</FUNCTION> system function.</PARAGRAPH>
<PARAGRAPH>This function is documented for all its many uses in the <REFPAGE>mmap(2)</REFPAGE> reference page. For purposes of mapping EISA devices, the parameters should be as follows (using the names from the reference page): </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Should be NULL to permit the kernel to choose an address in user process 
space. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>len</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>The length of the span of bus addresses, as documented in the <COMMAND>iospace</COMMAND> group 
in the VECTOR line. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>prot</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>PROT_READ, or PROT_WRITE, or the logical sum of those names when 
the device is used for both input and output. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>flags</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>MAP_SHARED, with the addition of MAP_PRIVATE if this mapping is not 
to be visible to child processes created with the <FUNCTION>sproc()</FUNCTION> function (see the 
<REFPAGE>sproc(2)</REFPAGE> reference page). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>fd</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>The file descriptor from opening the device special file in <FILENAME>/dev/eisa</FILENAME>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>off</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>The starting bus address, as documented in the <COMMAND>iospace</COMMAND> group in the 
VECTOR line. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The value returned by <FUNCTION>mmap()</FUNCTION> is the virtual memory address that corresponds to the starting bus address. When the process accesses that address, the access is implemented by data transfer to the EISA bus.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>When programming EISA PIO, you must always be aware that EISA devices generally store 16-bit and 32-bit values in &ldquo;small-endian&rdquo; order, with the least-significant byte at the lowest address. This is opposite to the order used by the MIPS CPU under IRIX. If you simply assign to a C unsigned integer from a 32-bit EISA register, the value will appear to be byte-inverted.</NOTE>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>EISA PIO Bandwidth</TITLE><PARAGRAPH>The EISA bus adapter is a device on the GIO bus. The GIO bus runs at either 25&nbsp;MHz or 33&nbsp;MHz, depending on the system model. Each EISA device access takes multiple GIO cycles, as follows:<INDEXTARGET ID="04-vmepio13"><!-- POSTPROCESSDATA: 04-vmepio13|EISA bus:PIO bandwidth --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The base time to do a native GIO read (of up to 64 bits) is 1&nbsp;microsecond.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A 32-bit EISA slave read adds 15 GIO cycles to the base GIO read time; hence one EISA access takes 19 GIO cycles, best case.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A 4-byte access to a 16-bit EISA device requires 10 more GIO cycles to transfer the second 2-byte group; hence a 4-byte read to a 16-bit EISA slave requires 25 GIO cycles.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Each wait state inserted by the EISA device adds four GIO cycles.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH><XREF IDREF="56036" TYPE="TABLE">Table&nbsp;4-2</XREF> summarizes best-case (no EISA wait states) data rates for reading and writing a 32-bit EISA device, based on these considerations.</PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="4-2"><PREFIX>Table 4-2 </PREFIX><XREFTARGET ID="56036"> <EMPHASIS>(continued)        </EMPHASIS>EISA Bus PIO Bandwidth (32-Bit Slave, 33-MHz GIO Clock)</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="128"><PARAGRAPH>Data Unit Size</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="128"><PARAGRAPH>Read</PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="128"><PARAGRAPH>Write</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="128"><PARAGRAPH>1 byte</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="128"><PARAGRAPH>0.68 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="128"><PARAGRAPH>1.75 MB/sec</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="128"><PARAGRAPH>2 byte</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="128"><PARAGRAPH>1.38 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="128"><PARAGRAPH>3.51 MB/sec</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="128"><PARAGRAPH>4 bytes</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="128"><PARAGRAPH>2.76 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="128"><PARAGRAPH>7.02 MB/sec</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH><XREF IDREF="39457" TYPE="TABLE">Table&nbsp;4-3</XREF> summarizes the best-case (no wait state) data rates for reading and writing a 16-bit EISA device. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="4-3"><PREFIX>Table 4-3 </PREFIX><XREFTARGET ID="39457">&space;EISA Bus PIO Bandwidth (16-Bit Slave, 33-MHz GIO Clock)</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="128"><PARAGRAPH>Data Unit Size</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="128"><PARAGRAPH>Read</PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="128"><PARAGRAPH>Write</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="128"><PARAGRAPH>1 byte</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="128"><PARAGRAPH>0.68 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="128"><PARAGRAPH>1.75 MB/sec</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="128"><PARAGRAPH>2 byte</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="128"><PARAGRAPH>1.38 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="128"><PARAGRAPH>3.51 MB/sec</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="128"><PARAGRAPH>4 bytes</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="128"><PARAGRAPH>2.29 MB/sec</PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="128"><PARAGRAPH>4.59 MB/sec</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="70857">VME Programmed I/O</TITLE><PARAGRAPH>The VME bus is supported by Origin2000 systems. For an overview of the VME bus and its hardware implementation in Silicon Graphics systems, see <XREF IDREF="46033" TYPE="TITLE">Chapter&nbsp;12, &ldquo;VME Device Attachment on Origin2000/Onyx2.&rdquo;</XREF><INDEXTARGET ID="04-vmepio14"><!-- POSTPROCESSDATA: 04-vmepio14|Programmed I/O (PIO):VME bus --><INDEXTARGET ID="04-vmepio15"><!-- POSTPROCESSDATA: 04-vmepio15|VME bus:user-level PIO --></PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="42950">Mapping a VME Device Into Process Address Space</TITLE><PARAGRAPH>As discussed in <XREF IDREF="65466" TYPE="TITLE">&ldquo;CPU Access to Device Registers&rdquo;</XREF>, an I/O device is represented as an address, or range of addresses, in the address space of its bus. A kernel-level device driver has the ability to set up a mapping between the bus address of a device register and a location in the address space of a user-level process. When this has been done, the device register appears to be a variable in memory. The program can assign values to it, or refer to it in expressions.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="11430">Learning VME Device Addresses</TITLE><PARAGRAPH>In order to map a VME device for PIO, you must know the following points:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The VME bus number on which the device resides. IRIX supports as many as five VME buses. On Challenge and Onyx systems the first VME bus is number 0; on Origin and Onyx2 systems the first VME bus is number 1. Use the <COMMAND>hinv</COMMAND> command to see the numbers of others (and see <XREF IDREF="10612" TYPE="TITLE">&ldquo;About VME Bus Addresses and System Addresses&rdquo;</XREF>).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The VME address space in which the device resides</PARAGRAPH>
<PARAGRAPH>This will be either A16, A24, or A32.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>VME address space modifier that the device uses&mdash;either supervisory (s) or nonprivileged (n)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The VME bus addresses associated with the device</PARAGRAPH>
<PARAGRAPH>This must be a sequential range of VME bus addresses that spans all the device registers you need to map.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>This information is normally documented in VECTOR lines found in a file in the <FILENAME>/var/sysgen/system/</FILENAME> directory (see <XREF IDREF="89231" TYPE="TITLE">&ldquo;Defining VME Devices with the VECTOR Statement&rdquo;</XREF>).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="69075">Opening a Device Special File</TITLE><PARAGRAPH>When you know the device addresses, you can open a device special file that represents the correct range of addresses. The device special files for VME mapping are found in the hardware graph at paths having the form:<INDEXTARGET ID="04-vmepio16"><!-- POSTPROCESSDATA: 04-vmepio16|device special file:VME mapping --></PARAGRAPH>
<CODE>
/hw/module/<VARIABLE>mod</VARIABLE>/slot/io<VARIABLE>n</VARIABLE>/baseio/vme_xtown/pci/7/vmebus/usrvme/a<VARIABLE>ssm</VARIABLE>/<VARIABLE>width</VARIABLE>&space;
</CODE>
<PARAGRAPH>The naming convention for these <FILENAME>hwgraph</FILENAME> paths is documented in the <REFPAGE>usrvme(7)</REFPAGE> reference page. Briefly, each path contains these variable elements:</PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>mod</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="288"><PARAGRAPH>The Origin or Onyx2 module number. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>n</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="288"><PARAGRAPH>The XIO slot number of the VME adapter. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>ss</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="288"><PARAGRAPH>The address space, either 16, 24, or 32. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>m</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="288"><PARAGRAPH>VME address modifier, <COMMAND>s</COMMAND> for supervisory or <COMMAND>n</COMMAND> for nonprivileged. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>width</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="288"><PARAGRAPH>Data width to be used, for example d32; covered in later table. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Shorter names are also created in the form</PARAGRAPH>
<EXAMPLE>
/hw/vme/<VARIABLE>busnumber</VARIABLE>/usrvme/<VARIABLE>ass</VARIABLE>m/<VARIABLE>width</VARIABLE>&space;
</EXAMPLE>
<TIP><PREFIX>Tip</PREFIX>In previous versions of IRIX, comparable device special files were defined in the <FILENAME>/dev</FILENAME> directory using names such as <FILENAME>/dev/vme/vme0a16n</FILENAME> and the like. If you have code that depends on these names&mdash;or if you prefer the shorter names in <FILENAME>/dev</FILENAME>&mdash;feel free to create compatible names in <FILENAME>/dev</FILENAME> in the form of symbolic links to the <FILENAME>/hw.../usrvme</FILENAME> names.</TIP>
<PARAGRAPH>The data width that is designated in the pathname as <VARIABLE>width</VARIABLE> can be selected from the values shown in <XREF IDREF="72880" TYPE="TABLE">Table&nbsp;4-4</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="4-4"><PREFIX>Table 4-4 </PREFIX><XREFTARGET ID="72880"> <EMPHASIS>(continued)        </EMPHASIS>Data Width Names in VME Special Device Names</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="153"><PARAGRAPH>Address Space in Pathname</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="234"><PARAGRAPH>Supported Widths in Pathname</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>a16n, a16s</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="234"><PARAGRAPH>d16, d32 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>a24n, a24s</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="234"><PARAGRAPH>d16, d32 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>a32n, a32s opened for PIO access </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="234"><PARAGRAPH>d8, d16, d32_single </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>a32n, a32s opened for DMA access </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="234"><PARAGRAPH>d8, d16, d32_single, d32_block, d64_single, d64_block </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Opening a device for DMA use is described under <XREF IDREF="94776" TYPE="TITLE">&ldquo;VME User-Level DMA&rdquo;</XREF>.</PARAGRAPH>
<TIP><PREFIX>Tip</PREFIX>You can display all the <FILENAME>usrvme</FILENAME> devices in the system using the find command in the <FILENAME>/hw</FILENAME> directory, as in</TIP>
<EXAMPLE>
# <USERINPUT>find /hw -name /hw/vme/\*/usrvme/\*/\* -type c -print</USERINPUT>&space;
</EXAMPLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using the mmap() Function</TITLE><PARAGRAPH>When you have successfully opened the device special file, you use the file descriptor as the primary input parameter in a call to the <INDEXTARGET ID="04-vmepio17"><!-- POSTPROCESSDATA: 04-vmepio17|IRIX functions:<FUNCTION>mmap</FUNCTION>():VME PIO --><FUNCTION>mmap()</FUNCTION> system function.</PARAGRAPH>
<PARAGRAPH>This function has many different uses, all of which are documented in the <REFPAGE>mmap(2)</REFPAGE> reference page. For purposes of mapping a VME device into memory, the parameters should be as follows (using the names from the reference page): </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Should be NULL to permit the kernel to choose the address in user process 
space. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>len</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>The length of the span of VME addresses, as documented in the <COMMAND>iospace</COMMAND> 
group in the VECTOR line. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>prot</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>PROT_READ for input, PROT_WRITE for output, or the logical sum of 
those names when the device will be used for both. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>flags</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>MAP_SHARED. Add MAP_PRIVATE if this mapping is not to be visible to 
child processes created with the <FUNCTION>sproc()</FUNCTION> function. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>fd</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>The file descriptor returned from opening the device special file. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>off</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>The starting VME bus address, as documented in the <COMMAND>iospace</COMMAND> group in the 
VECTOR line. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The value returned by <FUNCTION>mmap()</FUNCTION> is the virtual address that corresponds to the starting VME bus address. When the process accesses that address, the access is implemented by data transfer to the VME bus.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Limits on Maps</TITLE><PARAGRAPH>There are limits to the amount and location of VME bus address space that can be mapped for PIO. The system architecture can restrict the span of mappable addresses. Kernel resource constraints can impose limits on the number of VME maps that are simultaneously active. You must always inspect the return code from the <FUNCTION>mmap()</FUNCTION> call.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>VME PIO Access</TITLE><PARAGRAPH>Once a VME device has been mapped into memory, your program reads from the device by referencing the mapped address, and writes to the device by storing into the mapped address.</PARAGRAPH>
<PARAGRAPH>Typically you organize the mapped space using a data structure that describes the layout of registers. Two key points to note about the mapped space are:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>You should always declare register variables with the C keyword <BOLD>volatile</BOLD>. This forces the C compiler to generate a reference to memory whenever the register value is needed.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The VME PIO hardware does not support 64-bit integer load or store operations. For this reason you must not:</PARAGRAPH>
<BULLETLISTIND><BULLETIND><PARAGRAPH>Declare a VME item as long long, because the C compiler generates 64-bit loads and stores for such variables</PARAGRAPH>
</BULLETIND>
<BULLETIND><PARAGRAPH>Apply library functions such as <FUNCTION>bcopy()</FUNCTION>, <FUNCTION>bzero()</FUNCTION>, or <FUNCTION>memmove()</FUNCTION> to the VME mapped registers, because these optimized routines use 64-bit loads and stores whenever possible.</PARAGRAPH>
</BULLETIND>
</BULLETLISTIND>
</BULLET>
</BULLETLIST>
<PARAGRAPH>On an Origin or Onyx2 system, a PIO read can take one or more microseconds to complete&mdash;a time in which the R10000 CPU can process many instructions from memory. The R10000 continues to execute instructions following the PIO load until it reaches an instruction that requires the value from that load. Then it stalls until the PIO data arrives from the device.</PARAGRAPH>
<PARAGRAPH>A PIO write is asynchronous at the hardware level. The CPU executes a register-store instruction that is complete as soon as the physical address and data have been placed on the system bus. The actual VME write operation on the VME bus can take 1 or more microseconds to complete. During that time the CPU can execute dozens or even hundreds more instructions from cache memory. </PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="94776">VME User-Level DMA </TITLE><PARAGRAPH>A DMA engine is included as part of each VME bus adapter in an Silicon Graphics Origin2000 system. The DMA engine can perform efficient, block-mode, DMA transfers between system memory and VME bus slave cards&mdash;cards that would normally be capable of only PIO transfers.<INDEXTARGET ID="04-vmepio18"><!-- POSTPROCESSDATA: 04-vmepio18|udmalib --><INDEXTARGET ID="04-vmepio19"><!-- POSTPROCESSDATA: 04-vmepio19|user-level DMA --><INDEXTARGET ID="04-vmepio20"><!-- POSTPROCESSDATA: 04-vmepio20|VME bus:user-level DMA --><INDEXTARGET ID="04-vmepio21"><!-- POSTPROCESSDATA: 04-vmepio21|Direct Memory Access (DMA):user-level --></PARAGRAPH>
<PARAGRAPH>You can use the <FILENAME>udma</FILENAME> functions to access a VME Bus Master device, if the device can respond in slave mode. However, this would normally be less efficient than using the Master device's own DMA circuitry.</PARAGRAPH>
<PARAGRAPH>The DMA engine greatly increases the rate of data transfer compared to PIO, provided that you transfer at least 32 contiguous bytes at a time. The DMA engine can perform D8, D16, D32, D32 Block, and D64 Block data transfers in the A16, A24, and A32 bus address spaces.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Using the DMA Library Functions</TITLE><PARAGRAPH>All DMA engine transfers are initiated by a special device driver. However, you do not access this driver through open/read/write system calls. Instead, you program it through a library of functions. The functions are documented in the <REFPAGE>vme_dma_engine(3)</REFPAGE> reference page. They are used in the following sequence:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Call <FUNCTION>vme_dma_engine_alloc()</FUNCTION> to initialize DMA access to a particular VME bus adapter, specified by device special file name (see <XREF IDREF="69075" TYPE="TITLE">&ldquo;Opening a Device Special File&rdquo;</XREF>). You can create an engine for each available bus.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Call <FUNCTION>vme_dma_engine_buffer_alloc()</FUNCTION> to allocate storage to use for DMA buffers. This function pins the memory pages of the buffers to prevent swapping.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>You can call <FUNCTION>vme_dma_engine_buffer_addr_get()</FUNCTION> to return the address of a buffer allocated by the preceding function.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Call <FUNCTION>vme_dma_engine_transfer_alloc()</FUNCTION> to create a descriptor for an operation, including the buffer, the length, and the direction of transfer as well as several other attributes. The handle can be used repeatedly.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Call <FUNCTION>vme_dma_engine_schedule()</FUNCTION> to schedule one transfer (as described to <FUNCTION>vme_dma_engine_transfer_alloc()</FUNCTION>) for future execution. The transfer does not actually start at this time. This function can be called from multiple, parallel threads.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Call <FUNCTION>vme_dma_engine_commit()</FUNCTION> to commence execution of all scheduled transfers. If you specify a synchronous transfer, the function does not return until the transfer is complete.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>If you specify an asynchronous transfer, call <FUNCTION>vme_dma_engine_rendezvous()</FUNCTION> after starting all transfers. This function does not return until all transfers are complete.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>In prior releases, user-level DMA was provided through a comparable library of functions with different names and calling sequences. That library of functions is supported in the current release (see a prior edition of this manual, and the <REFPAGE>udmalib(3)</REFPAGE> reference page if installed). The new library described here is recommended.</PARAGRAPH>
<PARAGRAPH></PARAGRAPH>
</SECTION2>
</SECTION1>
</CHAPTER>
