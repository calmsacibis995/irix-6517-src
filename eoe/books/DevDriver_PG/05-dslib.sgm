<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="5"><TITLE><XREFTARGET ID="44062">User-Level Access to SCSI Devices</TITLE><PARAGRAPH>IRIX contains a programming library, called <INDEXTARGET ID="05-dslib1"><!-- POSTPROCESSDATA: 05-dslib1|SCSI bus:<ITALICS>See also</ITALICS> dsreq driverSCSI bus:ZZZ --><INDEXTARGET ID="05-dslib2"><!-- POSTPROCESSDATA: 05-dslib2|SCSI bus:user-level access --><FILENAME>dslib</FILENAME>, that allows you to control SCSI devices from a user-level process. This chapter documents the functions in dslib, including the following topics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="57112" TYPE="TITLE">&ldquo;Overview of the dsreq Driver&rdquo;</XREF> gives a summary of the features and use of the generic SCSI device driver.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="41381" TYPE="TITLE">&ldquo;Generic SCSI Device Special Files&rdquo;</XREF> documents the format of the names and major and minor numbers of generic SCSI files.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="23639" TYPE="TITLE">&ldquo;The dsreq Structure&rdquo;</XREF> gives details of the request structure that is the primary input to the generic SCSI driver.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="75233" TYPE="TITLE">&ldquo;Testing the Driver Configuration&rdquo;</XREF> documents the use of the DS_CONF <FUNCTION>ioctl()</FUNCTION> operation.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="65237" TYPE="TITLE">&ldquo;Using the Special DS_RESET and DS_ABORT Calls&rdquo;</XREF> describes two special functions of the generic SCSI driver.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="21211" TYPE="TITLE">&ldquo;Using dslib Functions&rdquo;</XREF> describes the functions that make it simpler to use the generic SCSI driver.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="45470" TYPE="TITLE">&ldquo;Example dslib Program&rdquo;</XREF> shows a simple example of use.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>You must understand the SCSI interface in order to command a SCSI device. For several SCSI information resources, see <XREF IDREF="93189" TYPE="TITLE">&ldquo;Other Sources of Information&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>If you are specifically interested in using audio data from a CDROM or DAT drive, you should use the special-purpose libraries for CDROM and DAT that are included in the IRIS Digital Media Development Environment. These libraries are built upon the generic SCSI driver, but provide convenient, audio-oriented functions. For more information on these libraries, see the <INDEXTARGET ID="05-dslib3"><!-- POSTPROCESSDATA: 05-dslib3|digital media not covered --><INDEXTARGET ID="05-dslib4"><!-- POSTPROCESSDATA: 05-dslib4|audio not covered --><DOCTITLE>IRIS Digital Media Programming Guide</DOCTITLE>, document number 008-1799-040.</PARAGRAPH>
<PARAGRAPH>If your interest is in controlling SCSI devices at the kernel level, see <XREF IDREF="44221" TYPE="TITLE">Part V, &ldquo;SCSI Device Drivers.&rdquo;</XREF></PARAGRAPH>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="57112">Overview of the dsreq Driver</TITLE><PARAGRAPH>IRIX includes a generic SCSI device driver, the <INDEXTARGET ID="05-dslib5"><!-- POSTPROCESSDATA: 05-dslib5|dsreq driver --><ITALICS>dsreq</ITALICS> driver, through which a user-level program can issue SCSI commands to SCSI devices. This is a character device driver that supports only <FUNCTION>open()</FUNCTION>, <FUNCTION>close()</FUNCTION> and <FUNCTION>ioctl()</FUNCTION> operations (see <XREF IDREF="47288" TYPE="TITLE">&ldquo;Kinds of Kernel-Level Drivers&rdquo;</XREF>, and also the <REFPAGE>open(2)</REFPAGE>, <REFPAGE>close(2)</REFPAGE> and <REFPAGE>ioctl(2)</REFPAGE> reference pages). </PARAGRAPH>
<PARAGRAPH>The formal documentation of the <ITALICS>dsreq</ITALICS> driver is found in the <REFPAGE>ds(7)</REFPAGE> reference page. In order to invoke its services, you prepare a <VARIABLE>dsreq</VARIABLE> data structure describing the operation and pass it to the device driver using an <FUNCTION>ioctl()</FUNCTION> call. The device driver issues the SCSI command you specify, and sleeps until it has completed. Then it returns the status in the <VARIABLE>dsreq</VARIABLE> structure.</PARAGRAPH>
<PARAGRAPH>You can request operations for input and output as well as issuing control and diagnostic commands. The <VARIABLE>dsreq</VARIABLE> structure for input and output operations specifies a buffer in memory for data transfer. The <ITALICS>dsreq</ITALICS> driver handles the task of locking the buffer into memory (if necessary) and managing a DMA transfer of data.</PARAGRAPH>
<PARAGRAPH>The programming interface supported by the generic SCSI driver is quite primitive. A library of higher-level functions makes it easier to use. This library is formally documented in the <REFPAGE>dslib(3)</REFPAGE> reference page, and is described under <XREF IDREF="21211" TYPE="TITLE">&ldquo;Using dslib Functions&rdquo;</XREF>.</PARAGRAPH>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="41381">Generic SCSI Device Special Files</TITLE><PARAGRAPH>The creation and use of device special files is discussed under <INDEXTARGET ID="05-dslib6"><!-- POSTPROCESSDATA: 05-dslib6|device special file:<FILENAME>/dev/scsi/*</FILENAME> --><XREF IDREF="91187" TYPE="TITLE">&ldquo;Device Special Files&rdquo;</XREF>. A device special file represents a device, and is the mechanism for associating a device with a kernel-level device driver.</PARAGRAPH>
<PARAGRAPH>The device special files in the <INDEXTARGET ID="05-dslib7"><!-- POSTPROCESSDATA: 05-dslib7|<FILENAME>/dev/MAKEDEV</FILENAME>MAKE --><FILENAME>/dev/scsi</FILENAME> directory are all associated with the <ITALICS>dsreq</ITALICS> driver. A basic set of these names is created automatically by the <FILENAME>/dev/MAKEDEV</FILENAME> script (see <XREF IDREF="14628" TYPE="TITLE">&ldquo;The Script MAKEDEV&rdquo;</XREF>). You have to create additional device special files if you need to control logical units other than logical unit 0.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Major and Minor Device Numbers in /dev/scsi</TITLE><PARAGRAPH>Device special files in <INDEXTARGET ID="05-dslib8"><!-- POSTPROCESSDATA: 05-dslib8|minor device number:in <FILENAME>/dev/scsi</FILENAME> --><INDEXTARGET ID="05-dslib9"><!-- POSTPROCESSDATA: 05-dslib9|major device number:in <FILENAME>/dev/scsi</FILENAME> --><FILENAME>/dev/scsi</FILENAME> have one of the following major device numbers:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>195 for devices on a SCSI bus (files <FILENAME>/dev/scsi/sc*</FILENAME>).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>196 for devices on a <ITALICS>jag</ITALICS> (VME) SCSI bridge (files <FILENAME>/dev/scsi/jag*</FILENAME>).</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The minor number of these files encodes the adapter number, the SCSI ID, and the LUN, using the bit assignments shown in <XREF IDREF="20785" TYPE="GRAPHIC">Figure&nbsp;5-1</XREF>.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="05-scsi.dev.minor.no.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="5-1"><PREFIX>Figure 5-1 </PREFIX><XREFTARGET ID="20785">Bit Assignments in SCSI Device Minor Numbers</CAPTION>
</FIGURE>
</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="10505">Form of Filenames in /dev/scsi</TITLE><PARAGRAPH>Each device special filename in the <INDEXTARGET ID="05-dslib10"><!-- POSTPROCESSDATA: 05-dslib10|device special file:name format --><INDEXTARGET ID="05-dslib11"><!-- POSTPROCESSDATA: 05-dslib11|names of devices --><FILENAME>/dev/scsi</FILENAME> directory reflects the values of the device's adapter (bus) number, SCSI ID, and logical unit number (LUN).</PARAGRAPH>
<TIP><PREFIX>Tip</PREFIX>The character between the SCSI ID and the LUN in these names is the letter &ldquo;l.&rdquo; When reading or copying these device names, take care not to write a digit 1 instead. This is a frequent error.</TIP>
<SECTION3 LBL="" HELPID = ""><TITLE>Names of SCSI Devices on a SCSI Bus</TITLE><PARAGRAPH>Devices attached directly to a SCSI bus have names in this form: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><BOLD>sc</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="288"><PARAGRAPH>Prefix &ldquo;sc&rdquo; for SCSI attachment. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>0 to 137</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="288"><PARAGRAPH>Number of the SCSI adapter, typically 0 or 1.&space;<INDEXTARGET ID="05-dslib12"><!-- POSTPROCESSDATA: 05-dslib12|SCSI bus:adapter number --></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><BOLD>d</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="288"><PARAGRAPH>Constant letter &ldquo;d&rdquo; for device. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>0 to 7 (to 15 for 
wide SCSI)</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="288"><PARAGRAPH>SCSI ID of the target device or control unit, as set by switches on 
the device itself.&space;<INDEXTARGET ID="05-dslib13"><!-- POSTPROCESSDATA: 05-dslib13|SCSI bus:target ID --></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><BOLD>l</BOLD> (letter ell)</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="288"><PARAGRAPH>Constant letter &ldquo;l&rdquo; for logical unit. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>0 to 7</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="288"><PARAGRAPH>Logical unit number (LUN) of this device, typically 0.&space;<INDEXTARGET ID="05-dslib14"><!-- POSTPROCESSDATA: 05-dslib14|SCSI bus:LUN --></PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>A typical device name would be <FILENAME>/dev/scsi/sc1d3l0</FILENAME> meaning a SCSI device configured as ID&nbsp;3 on SCSI bus 1. Either this device has no logical units, or this is the first logical unit on device 3.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Names of SCSI Devices on the Jag (VME Bus) Controller</TITLE><PARAGRAPH>Machines in the Challenge and Onyx systems can optionally have SCSI devices attached to the VME bus through a bridge using the <INDEXTARGET ID="05-dslib15"><!-- POSTPROCESSDATA: 05-dslib15|VME bus:jag adapter --><INDEXTARGET ID="05-dslib16"><!-- POSTPROCESSDATA: 05-dslib16|jag (SCSI-toVME) adapter --><ITALICS>jag</ITALICS> device driver. These devices are also represented in <FILENAME>/dev/scsi</FILENAME> with names of the following form:</PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><BOLD>jag</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="288"><PARAGRAPH>Prefix &ldquo;jag&rdquo; for VME/SCSI attachment. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>0 to 4 </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="288"><PARAGRAPH>Number of the VME adapter, typically 0 or 1.&space;<INDEXTARGET ID="05-dslib17"><!-- POSTPROCESSDATA: 05-dslib17|VME bus:adapter number --></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><BOLD>d</BOLD>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="288"><PARAGRAPH>Constant letter &ldquo;d&rdquo; for device. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>0 to 7 (to 15 for 
wide SCSI) </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="288"><PARAGRAPH>SCSI ID of the target device or control unit, as set by switches on 
the device itself. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><BOLD>l</BOLD> (letter ell) </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="288"><PARAGRAPH>Constant letter &ldquo;l&rdquo; for logical unit. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>0 to 7 </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="288"><PARAGRAPH>Logical unit number (LUN) of this device, typically 0. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>A typical device name would be <FILENAME>/dev/scsi/jag1d3l0</FILENAME> meaning a SCSI device configured as ID 3 on VME bus 1. Either the device has no logical units, or this is the first logical unit on device 3.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Creating Additional Names in /dev/scsi</TITLE><PARAGRAPH>The script <INDEXTARGET ID="05-dslib18"><!-- POSTPROCESSDATA: 05-dslib18|<FILENAME>/dev/MAKEDEV</FILENAME>:adding to <FILENAME>/dev/scsi</FILENAME>MAKE --><FILENAME>/dev/MAKEDEV</FILENAME>, which runs each time the system boots, creates 16 files for each existing SCSI or jag bus. These files represent the possible SCSI ID numbers 0-15 on each bus, with a logical number of 0. If you want to control a device with LUN 0, the device special file exists.</PARAGRAPH>
<PARAGRAPH>In order to control a device with a LUN of 1-7, you must create an additional device special file, using the <COMMAND>mknode</COMMAND> or <COMMAND>install</COMMAND> command (see the <REFPAGE>install(1)</REFPAGE> reference page). For example, before you can operate logical unit 2 of device 5 on SCSI bus 1, you must create <FILENAME>/dev/scsi/sc1d5l2</FILENAME> using a command such as</PARAGRAPH>
<CODE>
install -F /dev/scsi -m 600 -u root -g sys \
-chr 195,165 sc1d5l2
</CODE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="75416">Relationship to Other Device Special Files</TITLE><PARAGRAPH>The files in <FILENAME>/dev/scsi</FILENAME> describe many of the same devices that are described by files in <FILENAME>/dev/dsk</FILENAME>, <FILENAME>/dev/tape</FILENAME>, and other directories. There is a security exposure in that a user-level program could use a <FILENAME>/dev/scsi</FILENAME> file to do almost anything to a disk or tape, including total erasure.</PARAGRAPH>
<PARAGRAPH>The <INDEXTARGET ID="05-dslib19"><!-- POSTPROCESSDATA: 05-dslib19|dsreq driver:exclusive open --><ITALICS>dsreq</ITALICS> device driver forces exclusivity with itself; that is, a given <FILENAME>/dev/scsi</FILENAME> file can be opened only by one process at a time. However, a device could be open through the <ITALICS>dsreq</ITALICS> driver at the same time it is open by another process, or by a filesystem, through a different device special file and device driver. For example, a disk volume could be simultaneously open through the name <FILENAME>/dev/scsi/sc0d0l0</FILENAME> and through <FILENAME>/dev/rdsk/dks0d1s0</FILENAME>.</PARAGRAPH>
<PARAGRAPH>The process that opens a generic SCSI device can request exclusivity using the O_EXCL option to <INDEXTARGET ID="05-dslib20"><!-- POSTPROCESSDATA: 05-dslib20|IRIX functions:<FUNCTION>open</FUNCTION>():with dsreq driver --><FUNCTION>open()</FUNCTION>. In that case, the open is rejected when the device is already open through another driver; and no other driver can open the device until the generic device file is closed.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="23639">The dsreq Structure</TITLE><PARAGRAPH>The primary input to most <INDEXTARGET ID="05-dslib21"><!-- POSTPROCESSDATA: 05-dslib21|data types:<VARIABLE>struct dsreq</VARIABLE> --><INDEXTARGET ID="05-dslib22"><!-- POSTPROCESSDATA: 05-dslib22|dsreq driver:<VARIABLE>struct dsreq</VARIABLE> --><ITALICS>dsreq</ITALICS>&space;<FUNCTION>ioctl()</FUNCTION> calls, as well as the primary input to most dslib functions, is the <VARIABLE>dsreq</VARIABLE> structure. This structure is declared in <FILENAME>/usr/include/sys/dsreq.h</FILENAME>, a header file that rewards careful study.</PARAGRAPH>
<PARAGRAPH>The important fields of the <VARIABLE>dsreq</VARIABLE> structure are shown in <XREF IDREF="30956" TYPE="TABLE">Table&nbsp;5-1</XREF>. Some of the field values are expanded in the following topics. The <FILENAME>sys/dsreq.h</FILENAME> file declares macros for access to many of the fields. Use these macros (listed in <XREF IDREF="30956" TYPE="TABLE">Table&nbsp;5-1</XREF>) in both expressions and assignments in order to insulate your code against future changes. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="5-1"><PREFIX>Table 5-1 </PREFIX><XREFTARGET ID="30956">Fields of the dsreq Structure</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="54"><PARAGRAPH>Field Name</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="81"><PARAGRAPH>Macro</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>ds_flags</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="81"><PARAGRAPH>FLAGS(dp) </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Bits used to determine device driver actions. See <XREF IDREF="30544" TYPE="TITLE">&ldquo;Values for 
ds_flags&rdquo;</XREF>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>ds_time</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="81"><PARAGRAPH>TIME(dp) </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Timeout value in milliseconds. If the command does not 
complete, it is ended with an error code. The driver sets a 
default of 5000 (5 seconds) when this is set to zero. <FUNCTION>dsopen()</FUNCTION> 
initializes it to 10000. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>ds_private</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="81"><PARAGRAPH>PRIVATE(dp) </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Field for use by the calling program. <FUNCTION>dsopen()</FUNCTION> uses this field to 
point to its &ldquo;context&rdquo; data (see <XREF IDREF="38722" TYPE="TITLE">&ldquo;Using dsopen() and dsclose()&rdquo;</XREF>). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>ds_cmdbuf</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="81"><PARAGRAPH>CMDBUF(dp)</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Address of SCSI command string to be sent. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>ds_cmdlen</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="81"><PARAGRAPH>CMDLEN(dp)</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Length of the SCSI command string. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>ds_databuf</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="81"><PARAGRAPH>DATABUF(dp) </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Address of a single data buffer. See <XREF IDREF="86800" TYPE="TITLE">&ldquo;Data Transfer Options&rdquo;</XREF>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>ds_datalen</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="81"><PARAGRAPH>DATALEN(dp) </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Length of data buffer. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><FILENAME>ds_sensebuf</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="81"><PARAGRAPH>SENSEBUF(dp) </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Address to receive sense data after an error. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><FILENAME>ds_senselen</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="81"><PARAGRAPH>SENSELEN(dp) </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Length of sense buffer in bytes. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>ds_iovbuf</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="81"><PARAGRAPH>IOVBUF(dp)</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Address of an <VARIABLE>iov_t</VARIABLE> structure. See <XREF IDREF="86800" TYPE="TITLE">&ldquo;Data Transfer Options&rdquo;</XREF>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>ds_iovlen</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="81"><PARAGRAPH>IOVLEN(dp)</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Length of data described by <VARIABLE>ds_iovbuf</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>ds_link</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="81"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>This field is not supported, and should be zero-filled. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>ds_synch</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="81"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>This field is not supported, and should be zero-filled. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>ds_revcode</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="81"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Intended for the version code of the <ITALICS>dsreq</ITALICS> driver, not currently 
set to a useful value. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>ds_ret</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="81"><PARAGRAPH>RET(dp)</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Return code for the requested operation. See <XREF IDREF="80505" TYPE="TABLE">Table&nbsp;5-3</XREF>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>ds_status</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="81"><PARAGRAPH>STATUS(dp)</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>SCSI status byte from the operation. See <XREF IDREF="57506" TYPE="TABLE">Table&nbsp;5-4</XREF>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>ds_msg</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="81"><PARAGRAPH>MSG(dp)</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>The first byte of a message returned by the target. See 
<XREF IDREF="61261" TYPE="TABLE">Table&nbsp;5-5</XREF>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>ds_cmdsent</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="81"><PARAGRAPH>CMDSENT(dp) </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Length of command string actually sent (same as <VARIABLE>ds_cmdlen</VARIABLE>, 
unless an error occurs). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>ds_datasent</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="81"><PARAGRAPH>DATASENT(dp) </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Length of data transferred. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>ds_sensesent</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="81"><PARAGRAPH>SENSESENT(dp) </PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Length of sense data received. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The dslib library contains functions to simplify the preparation and execution of a <VARIABLE>dsreq</VARIABLE> request; see <XREF IDREF="21211" TYPE="TITLE">&ldquo;Using dslib Functions&rdquo;</XREF>.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="30544">Values for ds_flags</TITLE><PARAGRAPH>The possible flag values in the <INDEXTARGET ID="05-dslib23"><!-- POSTPROCESSDATA: 05-dslib23|data types:<VARIABLE>struct dsreq</VARIABLE>:<VARIABLE>ds_flags</VARIABLE>data types:dsreq --><INDEXTARGET ID="05-dslib24"><!-- POSTPROCESSDATA: 05-dslib24|dsreq driver:<VARIABLE>struct dsreq</VARIABLE>:<VARIABLE>ds_flags</VARIABLE> --><INDEXTARGET ID="05-dslib25"><!-- POSTPROCESSDATA: 05-dslib25|dsreq driver:flags --><VARIABLE>ds_flags</VARIABLE> field are listed in <XREF IDREF="33530" TYPE="TABLE">Table&nbsp;5-2</XREF>. The flag values are designed for the most flexible, capable type of bus, device, and device driver. Not all values are supported, and different host adapters can support different combinations. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="5-2"><PREFIX>Table 5-2 </PREFIX><XREFTARGET ID="33530">Flag Values for ds_flags </CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="90"><PARAGRAPH>&lbreak;Constant Name</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>Supported by 
Any Driver?</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>&lbreak;Meaning When Set to 1</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRQ_ASYNC </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>Yes</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Return at once, do not sleep until the operation is 
complete. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRQ_SENSE </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>Yes</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Get sense data following an error on the requested 
command. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRQ_TARGET </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>No</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Act as the SCSI target, not the SCSI initiator. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRQ_SELATN </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>Yes</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Select with ATN. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRQ_DISC </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>Yes</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Allow identify disconnect. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRQ_SYNXFR </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>Yes</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Negotiate a synchronous transfer if possible. Needed only 
to switch into synchronous mode. Repeated negotiation is 
wasteful. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRQ_ASYNXFR </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>Yes</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Negotiate an asynchronous transfer. Needed only to 
return to asynch after a synchronous transfer. Repeated 
negotiation is wasteful. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRQ_SELMSG </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>No</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>A specific select is coded in the message. This feature is 
not supported. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRQ_IOV </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>Yes</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Use the <VARIABLE>iov_t</VARIABLE> from <VARIABLE>ds_iovbuf</VARIABLE>, not the single buffer from 
<VARIABLE>ds_databuf</VARIABLE> (see <XREF IDREF="86800" TYPE="TITLE">&ldquo;Data Transfer Options&rdquo;</XREF>). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRQ_READ </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>Yes</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>This is a data input command (as opposed to an 
immediate command or an output). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRQ_WRITE </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>Yes</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>This is a data output command (as opposed to an 
immediate command or an input). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRQ_MIXRDWR </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>No</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>This command can both read and write. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRQ_BUF</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>No</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Buffer the input and copy to the supplied buffer, instead 
of direct input to the buffer. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRQ_CALL</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>No</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Notify completion (with DSRQ_ASYNC). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRQ_ACKH</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>No</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Hold ACK asserted. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRQ_ATNH</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>No</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Hold ATN asserted. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRQ_ABORT</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>No</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Send ABORT messages until the bus is clear.Useful only 
with SCSI commands that have the immediate bit set. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRQ_TRACE</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>Yes</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Trace this request (accepted but has no effect). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRQ_PRINT</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>Yes</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Print this request (accepted but has no effect). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRQ_CTRL1</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>Yes</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Request with host control bit 1. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRQ_CTRL2</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="63"><PARAGRAPH>Yes</PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="234"><PARAGRAPH>Request with host control bit 2. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>In order to find out which flags are supported by a particular driver, use the DS_CONF operation (see <XREF IDREF="75233" TYPE="TITLE">&ldquo;Testing the Driver Configuration&rdquo;</XREF>).</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="86800">Data Transfer Options</TITLE><PARAGRAPH>When reading or writing data, you have two design options:<INDEXTARGET ID="05-dslib26"><!-- POSTPROCESSDATA: 05-dslib26|dslib library:data transfer options --><INDEXTARGET ID="05-dslib27"><!-- POSTPROCESSDATA: 05-dslib27|dsreq driver:data transfer options --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>You can transfer a single segment of data directly between the device and a buffer you supply (set neither DSRQ_BUF nor DSRQ_IOV).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>You can transfer segments of data between the device and a series of one or more memory locations based on an <VARIABLE>iov_t</VARIABLE> object (set DSRQ_IOV).</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>All read/write requests are done using DMA. The &ldquo;scatter/gather&rdquo; support of DSRQ_IOV is presently restricted to only one memory segment, so it is not greatly different from single-buffer I/O. If you elect to use it, the <INDEXTARGET ID="05-dslib28"><!-- POSTPROCESSDATA: 05-dslib28|dsreq driver:scatter/gather --><INDEXTARGET ID="05-dslib29"><!-- POSTPROCESSDATA: 05-dslib29|Direct Memory Access (DMA):user-level SCSI --><VARIABLE>iov_t</VARIABLE> structure is declared in <FILENAME>sys/iov.h</FILENAME> (see also the part of the read(2) reference page that deals with the <FUNCTION>readv()</FUNCTION> function).</PARAGRAPH>
<PARAGRAPH>During a direct transfer using either a single buffer or scatter/gather, the data buffer spaces are locked in memory.</PARAGRAPH>
<PARAGRAPH>The maximum amount of data you can transfer in one operation is set by the host adapter driver for the bus, and can be retrieved with an <FUNCTION>ioctl()</FUNCTION> (see <XREF IDREF="75233" TYPE="TITLE">&ldquo;Testing the Driver Configuration&rdquo;</XREF>). The maximum length for a buffered transfer is returned by the same <FUNCTION>ioctl()</FUNCTION>. It can be less than the direct-transfer size because there may be a limit on the size of kernel memory that can be allocated.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="67185">Return Codes and Status Values</TITLE><PARAGRAPH>A zero return code in the <INDEXTARGET ID="05-dslib30"><!-- POSTPROCESSDATA: 05-dslib30|dsreq driver:return codes --><INDEXTARGET ID="05-dslib31"><!-- POSTPROCESSDATA: 05-dslib31|data types:<VARIABLE>struct dsreq</VARIABLE>:<VARIABLE>ds_ret</VARIABLE>data types:dsreq --><INDEXTARGET ID="05-dslib32"><!-- POSTPROCESSDATA: 05-dslib32|dsreq driver:<VARIABLE>struct dsreq</VARIABLE>:<VARIABLE>ds_ret</VARIABLE> --><VARIABLE>ds_ret</VARIABLE> field signifies success. The possible nonzero return codes are summarized in <XREF IDREF="80505" TYPE="TABLE">Table&nbsp;5-3</XREF> and are declared in <FILENAME>sys/dsreq.h</FILENAME>. Not all return codes are possible with every driver. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="5-3"><PREFIX>Table 5-3 </PREFIX><XREFTARGET ID="80505">Return Codes From SCSI Operations</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="90"><PARAGRAPH>Constant Name</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="270"><PARAGRAPH>Meaning</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRT_DEVSCSI </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="270"><PARAGRAPH>General failure from SCSI driver. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRT_MULT</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="270"><PARAGRAPH>General software failure, typically a SCSI-bus request. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRT_CANCEL </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="270"><PARAGRAPH>Operation cancelled in host adapter driver. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRT_REVCODE </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="270"><PARAGRAPH>Software level mismatch, recompile application. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRT_AGAIN</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="270"><PARAGRAPH>Try again, recoverable SCSI-bus error. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRT_HOST</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="270"><PARAGRAPH>Failure reported by host adapter driver for the bus in use. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRT_NOSEL</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="270"><PARAGRAPH>No unit responded to select. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRT_SHORT</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="270"><PARAGRAPH>Incomplete transfer (not an error). See <VARIABLE>ds_datasent</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRT_OK</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="270"><PARAGRAPH>Not returned at this time. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRT_SENSE</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="270"><PARAGRAPH>Command returned with status; sense data successfully retrieved 
from SCSI host (see <VARIABLE>ds_sensesent</VARIABLE>). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRT_NOSENSE </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="270"><PARAGRAPH>Command with status, error occurred while trying to get sense data 
from SCSI host. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRT_TIMEOUT </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="270"><PARAGRAPH>Command did not complete in the time allowed by <VARIABLE>ds_timeout</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRT_LONG </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="270"><PARAGRAPH>Data transfer overran bounds (<VARIABLE>ds_datalen</VARIABLE>). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRT_PROTO </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="270"><PARAGRAPH>Miscellaneous protocol failure. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRT_EBSY </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="270"><PARAGRAPH>Busy dropped unexpectedly; protocol error. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRT_REJECT </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="270"><PARAGRAPH>Message rejected; protocol error. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRT_PARITY </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="270"><PARAGRAPH>Parity error on SCSI bus; protocol error. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRT_MEMORY </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="270"><PARAGRAPH>Memory error in system memory. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRT_CMDO </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="270"><PARAGRAPH>Protocol error during command phase. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRT_STAI </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="270"><PARAGRAPH>Protocol error during status phase. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>DSRT_UNIMPL </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="270"><PARAGRAPH>Command not implemented; protocol error. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The possible SCSI status value in the <INDEXTARGET ID="05-dslib33"><!-- POSTPROCESSDATA: 05-dslib33|data types:<VARIABLE>struct dsreq</VARIABLE>:<VARIABLE>ds_status</VARIABLE>data types:dsreq --><INDEXTARGET ID="05-dslib34"><!-- POSTPROCESSDATA: 05-dslib34|dsreq driver:<VARIABLE>struct dsreq</VARIABLE>:<VARIABLE>ds_status</VARIABLE> --><VARIABLE>ds_status</VARIABLE> field are summarized in <XREF IDREF="57506" TYPE="TABLE">Table&nbsp;5-4</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="5-4"><PREFIX>Table 5-4 </PREFIX><XREFTARGET ID="57506">SCSI Status Codes</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="81"><PARAGRAPH>Constant Name</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Meaning</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>STA_GOOD </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>The target has successfully completed the SCSI command. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>STA_CHECK </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>An error or exception was detected. Sense was attempted if DSRQ_SENSE 
was specified. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>STA_BUSY </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Command not attempted; addressed unit is busy. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>STA_IGOOD </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Linked SCSI command completed. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>STA_RESERV </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Command aborted because it tried to access a logical unit or an extent within 
a logical unit that reserves that type of access to another SCSI device. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The possible SCSI message byte values in the <INDEXTARGET ID="05-dslib35"><!-- POSTPROCESSDATA: 05-dslib35|data types:<VARIABLE>struct dsreq</VARIABLE>:<VARIABLE>ds_msg</VARIABLE>data types:dsreq --><INDEXTARGET ID="05-dslib36"><!-- POSTPROCESSDATA: 05-dslib36|dsreq driver:<VARIABLE>struct dsreq</VARIABLE>:<VARIABLE>ds_msg</VARIABLE> --><VARIABLE>ds_msg</VARIABLE> field are summarized in <XREF IDREF="61261" TYPE="TABLE">Table&nbsp;5-5</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="5-5"><PREFIX>Table 5-5 </PREFIX><XREFTARGET ID="61261">SCSI Message Byte Values</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="81"><PARAGRAPH>Constant Name</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Meaning</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>MSG_COMPL </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Command complete. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>MSG_XMSG </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Extended message (only byte returned). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>MSG_SAVEP </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Initiator should save data pointers. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>MSG_RESTP </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Initiator restore data pointers. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>MSG_DISC </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Disconnect. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>MSG_IERR </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Initiator detected error. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>MSG_ABORT </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Abort. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>MSG_REJECT </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Optional message rejected, not supported. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>MSG_NOOP </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Empty message. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>MSG_MPARITY </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Parity error during Message In phase. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>MSG_LINK </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Linked command complete. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>MSG_LINKF </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Linked command complete with flag. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>MSG_BRESET </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Bus device reset. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>MSG_IDENT </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Value 0x80, first of the 0x80-0xFF identifier messages. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH></PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="75233">Testing the Driver Configuration</TITLE><PARAGRAPH>Different buses have different host adapter drivers that can have different features. The <ITALICS>dsreq</ITALICS> device driver supports an <FUNCTION>ioctl()</FUNCTION> call that retrieves the configuration of the driver for the bus where the device resides. This call fills in the fields of a structure of type <VARIABLE>dsconf</VARIABLE> (declared in <FILENAME>sys/dsreq.h</FILENAME>) listed in <XREF IDREF="26183" TYPE="TABLE">Table&nbsp;5-6</XREF>.&space;&nbsp;&nbsp;<INDEXTARGET ID="05-dslib37"><!-- POSTPROCESSDATA: 05-dslib37|dsreq driver:DS_CONF --><INDEXTARGET ID="05-dslib38"><!-- POSTPROCESSDATA: 05-dslib38|dsreq driver:<VARIABLE>struct dsconf</VARIABLE> --><INDEXTARGET ID="05-dslib39"><!-- POSTPROCESSDATA: 05-dslib39|data types:<VARIABLE>struct dsconf</VARIABLE>data types:dsconf --></PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="5-6"><PREFIX>Table 5-6 </PREFIX><XREFTARGET ID="26183">Fields of the dsconf Structure</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Field Name</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Contents</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>dsc_flags</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>DSRQ flags honored by this driver (see <XREF IDREF="33530" TYPE="TABLE">Table&nbsp;5-2</XREF>). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>dsc_preset</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>DSRQ preset values (defaults) that are merged with the input <VARIABLE>ds_flags</VARIABLE> using 
logical OR in any request. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>dsc_bus</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Number of this SCSI bus, as encoded in the device minor number. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>dsc_imax</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Maximum target ID for this bus (7 for SCSI, 15 for wide SCSI). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>dsc_lmax</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Maximum number LUN values per ID on this bus. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>dsc_iomax</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Maximum length of a single I/O transfer. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>dsc_biomax</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Maximum length of a buffered I/O transfer. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The code in <XREF IDREF="66244" TYPE="TEXT">Example&nbsp;5-1</XREF> shows a function that tests if a particular flag is supported by a particular bus. The input arguments are a file descriptor for an open device special file, and a flag value (or values) from <FILENAME>sys/dsreq.h</FILENAME>.</PARAGRAPH>
<CODE><CAPTION LBL="5-1"><PREFIX>Example 5-1 </PREFIX><XREFTARGET ID="66244">Testing the Generic SCSI Configuration</CAPTION>uint
test_dsreq_flags(int dev_fd, uint flag)
{
&nbsp;&nbsp;&nbsp;dsconf_t config;
&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;ret = ioctl(dev_fd, DS_CONF, &amp;config);
&nbsp;&nbsp;&nbsp;if (!ret) { /* no problem in ioctl */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (flag &amp; config.dsc_flags);
&nbsp;&nbsp;&nbsp;} else { /* ioctl failure */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0; /* not supported, it seems */
&nbsp;&nbsp;&nbsp;}
}
</CODE>
<PARAGRAPH>A program could use the function in <XREF IDREF="66244" TYPE="TEXT">Example&nbsp;5-1</XREF> to find out if a particular feature is supported. For example, a test of support for the DSRQ_SYNXFER feature could be coded as follows:</PARAGRAPH>
<CODE>
if (test_dsreq_flags(the_dev, DSRQ_SYNXFER)) {
&nbsp;&nbsp;&nbsp;/* synchronous negotiation is supported */...
</CODE>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="65237">Using the Special DS_RESET and DS_ABORT Calls</TITLE><PARAGRAPH>Two special functions of the generic SCSI driver are available only as <FUNCTION>ioctl()</FUNCTION> calls, not through dslib functions.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Using DS_ABORT</TITLE><PARAGRAPH>The DS_ABORT <INDEXTARGET ID="05-dslib40"><!-- POSTPROCESSDATA: 05-dslib40|dsreq driver:DS_ABORT --><FUNCTION>ioctl()</FUNCTION> sends a SCSI ABORT message to the bus, target, and LUN defined by the file descriptor. The resulting status is returned in the <VARIABLE>dsreq</VARIABLE> that is also specified. The host adapter driver waits until no commands are pending on that bus, so there is no point in using this function to cancel anything but an immediate command such as a rewind. And example of this call is as follows:</PARAGRAPH>
<EXAMPLE>
ioctl(dev_fd, DS_ABORT, &amp;some_dsreq);
</EXAMPLE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Using DS_RESET</TITLE><PARAGRAPH>The DS_RESET <INDEXTARGET ID="05-dslib41"><!-- POSTPROCESSDATA: 05-dslib41|dsreq driver:DS_RESET --><FUNCTION>ioctl()</FUNCTION> function causes a reset of the SCSI bus specified by the file descriptor. The resulting status is returned in the <VARIABLE>dsreq</VARIABLE> that is also specified. This powerful operation should be used with great care, because it terminates all pending activity on the bus.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="21211">Using dslib Functions</TITLE><PARAGRAPH>The functions in the dslib library are built upon calls to the dsreq device driver, and simplify the process of allocating a dsreq structure, setting values in it, and executing commands. The formal documentation of the library is found in <INDEXTARGET ID="05-dslib42"><!-- POSTPROCESSDATA: 05-dslib42|dslib library --><REFPAGE>dslib(3)</REFPAGE>. The source code is distributed with the system in the <FILENAME>/usr/share/src/irix/examples/scsi</FILENAME> directory so that you can read and extend it. (This directory installs as part of the irix_dev software component, and the examples directory does not install by default.)</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>dslib Functions</TITLE><PARAGRAPH>In order to use the functions in the library, you include <INDEXTARGET ID="05-dslib43"><!-- POSTPROCESSDATA: 05-dslib43|dslib library:function summarydslib library:AAA --><INDEXTARGET ID="05-dslib44"><!-- POSTPROCESSDATA: 05-dslib44|header files:<FILENAME>dslib.h</FILENAME> --><FILENAME>/usr/include/dslib.h</FILENAME> in your code, and link with the <COMMAND>-lds</COMMAND> option so as to link <FILENAME>/usr/lib/libds.so</FILENAME>. Then the functions summarized in <XREF IDREF="59984" TYPE="TABLE">Table&nbsp;5-7</XREF> are available.</PARAGRAPH>
<PARAGRAPH></PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="5-7"><PREFIX>Table 5-7 </PREFIX><XREFTARGET ID="59984">dslib Function Summary</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="90"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="54"><PARAGRAPH></PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>ds_ctostr</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Look up a string in a table using an integer key. </PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="54"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>ds_vtostr</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Look up a string in a table using an integer key. </PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="54"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>dsopen</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Open a device special file and allocate a <VARIABLE>dsreq</VARIABLE> for use with it. </PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="54"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>dsclose</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Free the <VARIABLE>dsreq</VARIABLE> structure and close the device. </PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="54"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>doscsireq</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Perform an operation on a device as specified in a <VARIABLE>dsreq</VARIABLE>. </PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="54"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>filldsreq</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Set values in fields of a <VARIABLE>dsreq</VARIABLE> structure. </PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="54"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>fillg0cmd</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Set up the <VARIABLE>dsreq</VARIABLE> structure for a group 0 SCSI command. </PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="54"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>fillg1cmd</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Set up the <VARIABLE>dsreq</VARIABLE> structure for a group 1 SCSI command. </PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="54"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>inquiry12</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Issue an Inquiry command and retrieve information from 
the device concerning such things as its type. </PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="54"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>modeselect15</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Issue a group 0 Mode Select command to a SCSI device. </PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="54"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>modesense1a</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Send a group 0 Mode Sense command to a device to retrieve 
a parameter page from the device. </PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="54"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>read08</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Issue a group 0 Read command in disk-drive form. </PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="54"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>readextended28</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Issue a group 1 Read command in disk-drive form. </PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="54"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>readcapacity25</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Issue a Read Capacity command. </PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="54"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>requestsense03</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Issue a Request Sense command and test or probe for the 
device. </PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="54"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>reserveunit16</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Issue a Reserve Unit command. </PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="54"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>releaseunit17</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Issue a Release Unit command. </PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="54"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>senddiagnostic1d</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Issue a Send Diagnostic command to test if the device or the 
SCSI bus is online, or run a self-test on the device. </PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="54"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>testunitready00</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Issue a Test Unit Ready command to the SCSI device. </PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="54"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>write0a</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Issue a group 0 Write command to the SCSI device. </PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="54"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FUNCTION>writeextended2a</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Issue an extended Write command to the SCSI device. </PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="54"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="38722">Using dsopen() and dsclose()</TITLE><PARAGRAPH>The <INDEXTARGET ID="05-dslib45"><!-- POSTPROCESSDATA: 05-dslib45|dslib library:<FUNCTION>dsclose()</FUNCTION> --><INDEXTARGET ID="05-dslib46"><!-- POSTPROCESSDATA: 05-dslib46|dslib library:<FUNCTION>dsopen()</FUNCTION> --><FUNCTION>dsopen()</FUNCTION> function opens a device special file for a generic SCSI device, and allocates a <VARIABLE>dsreq</VARIABLE> structure initialized for use with that device. The function prototype is</PARAGRAPH>
<EXAMPLE>
struct dsreq* dsopen(char *<VARIABLE>opath</VARIABLE>, int <VARIABLE>oflags</VARIABLE>);
</EXAMPLE>
<PARAGRAPH>The arguments are </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>opath</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The name of the device special file as a character string, for example 
&ldquo;/dev/scsi/jag0d7l0&rdquo; (see <XREF IDREF="10505" TYPE="TITLE">&ldquo;Form of Filenames in /dev/scsi&rdquo;</XREF>). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>oflags</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The <VARIABLE>oflag</VARIABLE> value expected by <FUNCTION>open()</FUNCTION> when opening this device special 
file. O_EXCL has special meaning; see <XREF IDREF="75416" TYPE="TITLE">&ldquo;Relationship to Other Device 
Special Files&rdquo;</XREF>. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>If the <FUNCTION>open()</FUNCTION> call fails or memory cannot be allocated, the function returns NULL. Otherwise it allocates a <VARIABLE>dsreq</VARIABLE> structure as well as generous buffers for command and sense strings. The following fields of the <VARIABLE>dsreq</VARIABLE> are initialized: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>ds_time</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Set to 10000 (10 second timeout). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>ds_private</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Set to the address of the context that contains the <VARIABLE>dsreq</VARIABLE> as well as the 
command and sense buffers. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>ds_cmdbuf</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Set to the address of the command buffer. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>ds_cmdlen</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Set to the length of the allocated command buffer. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>ds_sensebuf</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Set to the address of the allocated sense buffer. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>ds_senselen</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Set to the length of the sense buffer. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Other fields of the <VARIABLE>dsreq</VARIABLE> are cleared to zero.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>Other functions in dslib assume that a <VARIABLE>dsreq</VARIABLE> has been initialized by <FUNCTION>dsopen()</FUNCTION>. In particular they assume the <VARIABLE>ds_private</VARIABLE> value points to a context block. You should not attempt to use any <VARIABLE>dsreq</VARIABLE> structure with a dslib function except one returned by <FUNCTION>dsopen()</FUNCTION>; and you should not use a <VARIABLE>dsreq</VARIABLE> opened for one file with another file.</NOTE>
<PARAGRAPH>The <FUNCTION>dsclose()</FUNCTION> function releases the <VARIABLE>dsreq</VARIABLE> structure and close the device. Its prototype is</PARAGRAPH>
<EXAMPLE>
void dsclose(struct dsreq *dsp);
</EXAMPLE>
<PARAGRAPH>The only argument is the <VARIABLE>dsreq</VARIABLE> created by <FUNCTION>dsopen()</FUNCTION>.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="53247">Issuing a Request With doscsireq()</TITLE><PARAGRAPH>The <INDEXTARGET ID="05-dslib47"><!-- POSTPROCESSDATA: 05-dslib47|dslib library:<FUNCTION>doscsireq()</FUNCTION> --><FUNCTION>doscsireq()</FUNCTION> function issues a SCSI request by passing a <VARIABLE>dsreq</VARIABLE> to the SCSI device driver using an <FUNCTION>ioctl()</FUNCTION> call. The <VARIABLE>dsreq</VARIABLE> must have been prepared completely beforehand. The function prototype is</PARAGRAPH>
<EXAMPLE>
int doscsireq(int <VARIABLE>fd</VARIABLE>, struct dsreq *<VARIABLE>dsp</VARIABLE>);
</EXAMPLE>
<PARAGRAPH>The arguments are as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>fd</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="270"><PARAGRAPH>The file descriptor for the open device file. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>dsp</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="270"><PARAGRAPH>The address of the <VARIABLE>dsreq</VARIABLE> prepared by <FUNCTION>dsopen()</FUNCTION>. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Normally the returned value is the SCSI status byte. When the requested operation ends with Busy or Reserve Conflict status, the function sleeps 2 seconds and tries the operation up to four times. The returned value is -1 when the device driver rejects the ioctl() or the third retry ends in failure.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>SCSI Utility Functions</TITLE><PARAGRAPH>The functions <FUNCTION>filldsreq()</FUNCTION>, <FUNCTION>fillg0cmd()</FUNCTION>, <FUNCTION>fillg1cmd()</FUNCTION>, <FUNCTION>ds_vtostr()</FUNCTION>, and <FUNCTION>ds_ctostr()</FUNCTION> are not oriented toward particular SCSI operations, but are used to construct your own task-oriented SCSI functions.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="83398">Using filldsreq() </TITLE><PARAGRAPH>The <INDEXTARGET ID="05-dslib48"><!-- POSTPROCESSDATA: 05-dslib48|dslib library:<FUNCTION>filldsreq()</FUNCTION> --><FUNCTION>filldsreq()</FUNCTION> function is used to set the <VARIABLE>ds_flags</VARIABLE>, <VARIABLE>ds_databuf</VARIABLE>, and <VARIABLE>ds_datalen</VARIABLE> members of a <VARIABLE>dsreq</VARIABLE> structure. Its prototype is</PARAGRAPH>
<EXAMPLE>
void filldsreq(struct dsreq *<VARIABLE>dsp</VARIABLE>, uchar_t *<VARIABLE>data</VARIABLE>,long <VARIABLE>datalen</VARIABLE>, long<VARIABLE>&space;flags</VARIABLE>)
</EXAMPLE>
<PARAGRAPH>The arguments are as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>dsp</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The address of a <VARIABLE>dsreq</VARIABLE> prepared by dsopen().</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>data</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The address of a buffer area. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>datalen</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The length of the buffer area. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>flags</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Flag values for <VARIABLE>ds_flags</VARIABLE> (see <XREF IDREF="30544" TYPE="TITLE">&ldquo;Values for ds_flags&rdquo;</XREF>). </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The bits in <VARIABLE>flags</VARIABLE> are added to <VARIABLE>ds_flags</VARIABLE> with an OR; they do not replace the contents of the field.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>Besides the specified values, the function also sets 10000 in <VARIABLE>ds_timeout</VARIABLE> and clears <VARIABLE>ds_link</VARIABLE>, <VARIABLE>ds_synch</VARIABLE>, and <VARIABLE>ds_ret</VARIABLE> to zero.</NOTE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="48919">Using fillg0cmd() and fillg1cmd()</TITLE><PARAGRAPH>The <INDEXTARGET ID="05-dslib49"><!-- POSTPROCESSDATA: 05-dslib49|dslib library:<FUNCTION>fillg1cmd()</FUNCTION> --><INDEXTARGET ID="05-dslib50"><!-- POSTPROCESSDATA: 05-dslib50|dslib library:<FUNCTION>fillg0cmd()</FUNCTION> --><FUNCTION>fillg0cmd()</FUNCTION> function stores a group 0 (6-byte) SCSI command in a command buffer. The <FUNCTION>fillg1cmd()</FUNCTION> stores a group 1 (10-byte) SCSI command in the buffer. Both functions set the <VARIABLE>ds_cmdbuf</VARIABLE> and <VARIABLE>ds_cmdlen</VARIABLE> fields of a <VARIABLE>dsreq</VARIABLE>. The function prototypes are:</PARAGRAPH>
<CODE>
void fillg0cmd(struct dsreq *<VARIABLE>dsp</VARIABLE>, uchar_t *<VARIABLE>cmdbuf</VARIABLE>, <VARIABLE>b0</VARIABLE>, ..., <VARIABLE>b5</VARIABLE>)
void fillg1cmd(struct dsreq *<VARIABLE>dsp</VARIABLE>, uchar_t *<VARIABLE>cmdbuf</VARIABLE>, <VARIABLE>b0</VARIABLE>, ..., <VARIABLE>b9</VARIABLE>)
</CODE>
<PARAGRAPH>The arguments are as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>dsp</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The address of any <VARIABLE>dsreq</VARIABLE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>cmdbuf</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The address of a buffer to receive the command string.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>b0</VARIABLE>, <VARIABLE>b1</VARIABLE>,...</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Expressions for the successive bytes of a SCSI command.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>In typical use, the arguments are as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>dsp</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The address of a <VARIABLE>dsreq</VARIABLE> initialized by <FUNCTION>dsopen()</FUNCTION>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>cmdbuf</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The command buffer allocated by <FUNCTION>dsopen()</FUNCTION>, whose address is stored in 
the <VARIABLE>ds_cmdbuf</VARIABLE> field of the <VARIABLE>dsreq</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>b0</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>A SCSI command verb expressed as one of the constants declared in 
dslib.h, for example G0_INQU.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>A typical call resembles the following:</PARAGRAPH>
<CODE>
fillg0cmd(dsp, (uchar_t *)CMDBUF(dsp), G0_INQU, 1, inq_page, 0, B1(datalen),0);
</CODE>
<PARAGRAPH>The macros B1(), B2(), and B4() defined in <FILENAME>sys/dsreq.h</FILENAME> are useful for expressing halfword and word values as byte sequences.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="77626">Using ds_vtostr() and ds_ctostr()</TITLE><PARAGRAPH>The dslib library module contains six static tables that can be used to convert between numeric values and character strings for message display. The tables are summarized in <INDEXTARGET ID="05-dslib51"><!-- POSTPROCESSDATA: 05-dslib51|dslib library:<FUNCTION>ds_ctostr</FUNCTION>() --><INDEXTARGET ID="05-dslib52"><!-- POSTPROCESSDATA: 05-dslib52|dslib library:<FUNCTION>ds_vtostr()</FUNCTION> --><XREF IDREF="58211" TYPE="TABLE">Table&nbsp;5-8</XREF>. The table definitions are in the source file <FILENAME>dstab.c</FILENAME>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="5-8"><PREFIX>Table 5-8 </PREFIX><XREFTARGET ID="58211">Lookup Tables in dslib</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="72"><PARAGRAPH>External Name</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="27"><PARAGRAPH>Type</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="288"><PARAGRAPH>Table Contents</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>cmdnametab </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="27"><PARAGRAPH>vtab </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="288"><PARAGRAPH>Names for SCSI command bytes, for example &ldquo;Test Unit.&rdquo; </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>cmdstatustab </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="27"><PARAGRAPH>vtab </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="288"><PARAGRAPH>Names for SCSI status byte codes, for example &ldquo;BUSY.&rdquo; </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>dsrqnametab </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="27"><PARAGRAPH>vtab </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="288"><PARAGRAPH>Descriptions of flag values from <VARIABLE>ds_flags</VARIABLE>, for example &ldquo;select with 
(without) atn&rdquo; for DSRQ_SELATN. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>dsrtnametab </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="27"><PARAGRAPH>vtab </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="288"><PARAGRAPH>Descriptions of return values in ds_ret, for example &ldquo;parity error on 
SCSI bus&rdquo; for DSRT_PARITY. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>msgnametab </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="27"><PARAGRAPH>vtab </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="288"><PARAGRAPH>Descriptions of SCSI message bytes, for example &ldquo;Save Pointers.&rdquo; </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>sensekeytab </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="27"><PARAGRAPH>ctab </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="288"><PARAGRAPH>Descriptions of SCSI sense byte values, for example &ldquo;Illegal Request.&rdquo; </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The <FUNCTION>ds_vtostr()</FUNCTION> function searches any of the five vtab tables for the string matching an integer key. The <FUNCTION>ds_ctostr()</FUNCTION> function searches a ctab (currently, only sensekeytab is a ctab) for the string matching a key. The function prototypes are</PARAGRAPH>
<CODE>
char * ds_vtostr(unsigned long <VARIABLE>v</VARIABLE>, struct vtab *<VARIABLE>table</VARIABLE>);
char * ds_ctostr(unsigned long <VARIABLE>v</VARIABLE>, struct ctab *<VARIABLE>table</VARIABLE>);
</CODE>
<PARAGRAPH>Each function searches the specified table for a row containing the numeric value <VARIABLE>v</VARIABLE>, and returns address of the corresponding string. If there is no such row, the functions return the address of a zero-length string.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Using Command-Building Functions</TITLE><PARAGRAPH>The remaining functions in dslib each construct and execute a specific type of common SCSI command. Each function follows this general pattern:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Use <FUNCTION>fillg0cmd()</FUNCTION> or <FUNCTION>fillg1cmd()</FUNCTION> to set up the command string, based on the function's arguments.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Use <FUNCTION>filldsreq()</FUNCTION> to set up the remaining fields of the <VARIABLE>dsreq</VARIABLE> structure.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Execute the command using <FUNCTION>doscsireq()</FUNCTION>.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Return the value returned by <FUNCTION>doscsireq()</FUNCTION>.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>You can construct similar, additional functions using the utility functions in this same way. In particular you are likely to need to construct your own function to issue Read commands.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="44768">inquiry12()&mdash;Issue an Inquiry Command</TITLE><PARAGRAPH>The <INDEXTARGET ID="05-dslib53"><!-- POSTPROCESSDATA: 05-dslib53|SCSI bus:command:Inquiry --><INDEXTARGET ID="05-dslib54"><!-- POSTPROCESSDATA: 05-dslib54|dslib library:<FUNCTION>inquiry12()</FUNCTION> --><FUNCTION>inquiry12()</FUNCTION> function prepares and issues an Inquiry command to retrieve device-specific information. The function prototype is</PARAGRAPH>
<EXAMPLE>
int inquiry12(struct dsreq *<VARIABLE>dsp</VARIABLE>, caddr_t <VARIABLE>data</VARIABLE>, long <VARIABLE>datalen</VARIABLE>, int <VARIABLE>vu</VARIABLE>);
</EXAMPLE>
<PARAGRAPH>The arguments are as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>dsp</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The address of a <VARIABLE>dsreq</VARIABLE> structure prepared by <FUNCTION>dsopen()</FUNCTION>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>data</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The address of a buffer to receive the inquiry response. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>datalen</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The length of the buffer, at least 36 and typically 64. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>vu</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The least-significant two bits are used to set the vendor-specific bits in 
the Control byte in the command. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="76316">modeselect15()&mdash;Issue a Group 0 Mode Select Command</TITLE><PARAGRAPH>The <INDEXTARGET ID="05-dslib55"><!-- POSTPROCESSDATA: 05-dslib55|SCSI bus:command:Mode Select --><INDEXTARGET ID="05-dslib56"><!-- POSTPROCESSDATA: 05-dslib56|dslib library:<FUNCTION>modeselect15()</FUNCTION> --><FUNCTION>modeselect15()</FUNCTION> function prepares and issues a group 0 Mode Select command. This command is used to control a variety of standard and vendor-specific device parameters. Typically, <FUNCTION>modesense1A()</FUNCTION> is first used to retrieve the current parameters. The function prototype is</PARAGRAPH>
<CODE>
int modeselect15(struct dsreq *<VARIABLE>dsp</VARIABLE>, caddr_t <VARIABLE>data</VARIABLE>, long <VARIABLE>datalen</VARIABLE>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int <VARIABLE>save</VARIABLE>, int <VARIABLE>vu</VARIABLE>);
</CODE>
<PARAGRAPH>The arguments are as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>dsp</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The address of a <VARIABLE>dsreq</VARIABLE> structure prepared by <FUNCTION>dsopen()</FUNCTION>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>data</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The address of a mode data page to send. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>datalen</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The length of the data. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>save</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The least significant bit sets the SP bit in the command. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>vu</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The least-significant two bits are used to set the vendor-specific bits in 
the Control byte in the command. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="11723">modesense1a()&mdash;Send a Group 0 Mode Sense Command</TITLE><PARAGRAPH>The <INDEXTARGET ID="05-dslib57"><!-- POSTPROCESSDATA: 05-dslib57|SCSI bus:command:Mode Sense --><INDEXTARGET ID="05-dslib58"><!-- POSTPROCESSDATA: 05-dslib58|dslib library:<FUNCTION>modesense1a()</FUNCTION> --><FUNCTION>modesense1a()</FUNCTION> function prepares and issues a group 0 Mode Sense command to a SCSI device to retrieve a page of device-dependent information. The function prototype:</PARAGRAPH>
<CODE>
int modesense1a(struct dsreq *<VARIABLE>dsp</VARIABLE>, caddr_t <VARIABLE>data</VARIABLE>, long <VARIABLE>datalen</VARIABLE>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int <VARIABLE>pagectrl</VARIABLE>, int <VARIABLE>pagecode</VARIABLE>, int <VARIABLE>vu</VARIABLE>);
</CODE>
<PARAGRAPH>The arguments are as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>dsp</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The address of a <VARIABLE>dsreq</VARIABLE> structure prepared by <FUNCTION>dsopen()</FUNCTION>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>data</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The address of a buffer to receive the page of data. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>datalen</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The length of the buffer. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>pagectrl</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The least significant 2 bits are set as the PCF bits in the command. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>pagecode</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The least significant 6 bits are set as the page number. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>vu</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The least-significant two bits are used to set the vendor-specific bits in 
the Control byte in the command. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>For reference, the PCF codes are as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>0 </PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="288"><PARAGRAPH>Current values. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>1 </PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="288"><PARAGRAPH>Changeable values. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>2 </PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="288"><PARAGRAPH>Default values. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>3 </PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="288"><PARAGRAPH>Saved values. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>For reference, some page numbers are as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>0 </PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Vendor unique. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>1 </PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Read/write error recovery. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>2 </PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Disconnect/reconnect. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>3 </PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Direct access device format; parallel interface; measurement units. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>4 </PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Rigid disk geometry; serial interface. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>5 </PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Flexible disk; printer options. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>6 </PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Optical memory. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>7 </PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Verification error. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>8 </PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Caching. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>9 </PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Peripheral device. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>63 (0x3f) </PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Return all pages supported. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="51959">read08() and readextended28()&mdash;Issue a Read Command</TITLE><PARAGRAPH>The <INDEXTARGET ID="05-dslib59"><!-- POSTPROCESSDATA: 05-dslib59|SCSI bus:command:Read --><INDEXTARGET ID="05-dslib60"><!-- POSTPROCESSDATA: 05-dslib60|dslib library:<FUNCTION>readextended28()</FUNCTION> --><INDEXTARGET ID="05-dslib61"><!-- POSTPROCESSDATA: 05-dslib61|dslib library:<FUNCTION>read08()</FUNCTION> --><FUNCTION>read08()</FUNCTION> and <FUNCTION>readextended28()</FUNCTION> functions prepare and issue particular forms of SCSI Read commands. The Read and extended Read commands have so many variations that it is unlikely that either of these functions will work with your device. However, you can use them as models to build additional variations on Read. Do not preempt the function names.</PARAGRAPH>
<PARAGRAPH>The function prototypes are</PARAGRAPH>
<CODE>
int
read08(struct dsreq *<VARIABLE>dsp</VARIABLE>, caddr_t <VARIABLE>data</VARIABLE>, long <VARIABLE>datalen</VARIABLE>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long <VARIABLE>lba</VARIABLE>, int <VARIABLE>vu</VARIABLE>);
int
readextended28(struct dsreq *<VARIABLE>dsp</VARIABLE>, caddr_t <VARIABLE>data</VARIABLE>, long <VARIABLE>datalen</VARIABLE>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long <VARIABLE>lba</VARIABLE>, int <VARIABLE>vu</VARIABLE>);
</CODE>
<PARAGRAPH>The arguments are as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>dsp</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The address of a <VARIABLE>dsreq</VARIABLE> structure prepared by <FUNCTION>dsopen()</FUNCTION>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>data</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The address of a buffer to receive the data. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>datalen</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The length of the buffer (not exceeding 255 for <FUNCTION>read08</FUNCTION>). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>lba</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The logical block address for the start of the read (not exceeding 16 bits 
for <FUNCTION>read08</FUNCTION>). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>vu</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The least-significant two bits are used to set the vendor-specific bits in 
the Control byte in the command. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The functions set the transfer length in the command to the number of bytes given by datalen. This is often incorrect; many devices want a number of blocks of some size. Function <FUNCTION>read08()</FUNCTION> sets only 16 bits from lba as the logical block number, although the SCSI command format permits another 5 bits to be encoded in the command. For these and other reasons you are likely to need to create customized Read functions of your own.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="66799">readcapacity25()&mdash;Issue a Read Capacity Command</TITLE><PARAGRAPH>The <INDEXTARGET ID="05-dslib62"><!-- POSTPROCESSDATA: 05-dslib62|SCSI bus:command:Read Capacity --><INDEXTARGET ID="05-dslib63"><!-- POSTPROCESSDATA: 05-dslib63|dslib library:<FUNCTION>readcapacity25()</FUNCTION> --><FUNCTION>readcapacity25()</FUNCTION> function prepares and issues a Read Capacity command to a SCSI device. The function prototype is</PARAGRAPH>
<CODE>
int
readcapacity25(struct dsreq *<VARIABLE>dsp</VARIABLE>, caddr_t <VARIABLE>data</VARIABLE>, long <VARIABLE>datalen</VARIABLE>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long <VARIABLE>lba</VARIABLE>, int <VARIABLE>pmi</VARIABLE>, int <VARIABLE>vu</VARIABLE>);
</CODE>
<PARAGRAPH>The arguments are as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>dsp</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The address of a <VARIABLE>dsreq</VARIABLE> structure prepared by <FUNCTION>dsopen()</FUNCTION>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>data</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The address of a buffer to receive the capacity data. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>datalen</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The length of the buffer, typically 8. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>lba</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Last block address, 0 unless <VARIABLE>pmi</VARIABLE> is nonzero. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>pmi</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The least-significant bit is used to set the partial medium indicator 
(PMI) bit of the command. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>vu</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The least-significant two bits are used to set the vendor-specific bits in 
the Control byte in the command. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>When <VARIABLE>pmi</VARIABLE> is 0, <VARIABLE>lba</VARIABLE> should be given as 0 and the command returns the device capacity. When <VARIABLE>pmi</VARIABLE> is 1, the command returns the last block following block <VARIABLE>lba</VARIABLE> before which a delay (seek) will occur.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="60582">requestsense03()&mdash;Issue a Request Sense Command</TITLE><PARAGRAPH>The <INDEXTARGET ID="05-dslib64"><!-- POSTPROCESSDATA: 05-dslib64|SCSI bus:command:Request Sense --><INDEXTARGET ID="05-dslib65"><!-- POSTPROCESSDATA: 05-dslib65|dslib library:<FUNCTION>requestsense03()</FUNCTION> --><FUNCTION>requestsense03()</FUNCTION> function prepares and issues a Request Sense command. If you include DSRQ_SENSE in the <VARIABLE>flag</VARIABLE> argument to <FUNCTION>doscsireq()</FUNCTION>, a Request Sense is sent automatically after an error in a command. The function prototype is</PARAGRAPH>
<CODE>
int&lbreak;requestsense03(struct dsreq *<VARIABLE>dsp</VARIABLE>, caddr_t <VARIABLE>data</VARIABLE>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long <VARIABLE>datalen</VARIABLE>, int vu);
</CODE>
<PARAGRAPH>The arguments are: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>dsp</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The address of a <VARIABLE>dsreq</VARIABLE> structure prepared by <FUNCTION>dsopen()</FUNCTION>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>data</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The address of a buffer to receive the sense data. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>datalen</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The length of the buffer. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>vu</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The least-significant two bits are used to set the vendor-specific bits in 
the Control byte in the command.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="15033">reserveunit16() and releaseunit17()&mdash;Control Logical Units</TITLE><PARAGRAPH>The <INDEXTARGET ID="05-dslib66"><!-- POSTPROCESSDATA: 05-dslib66|SCSI bus:command:Reserve Unit --><INDEXTARGET ID="05-dslib67"><!-- POSTPROCESSDATA: 05-dslib67|dslib library:<FUNCTION>reserveunit16()</FUNCTION> --><INDEXTARGET ID="05-dslib68"><!-- POSTPROCESSDATA: 05-dslib68|dslib library:<FUNCTION>releaseunit17()</FUNCTION> --><FUNCTION>reserveunit16()</FUNCTION> function prepares and issues a Reserve Unit command to reserve a logical unit, causing it to return Reservation Conflict status to requests from other initiators. The <FUNCTION>releaseunit17()</FUNCTION> function prepares and issues a Release Unit command to release a reserved unit. The function prototypes are</PARAGRAPH>
<CODE>
int
reservunit16(struct dsreq *<VARIABLE>dsp</VARIABLE>, caddr_t <VARIABLE>data</VARIABLE>, long <VARIABLE>datalen</VARIABLE>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int <VARIABLE>tpr</VARIABLE>, int <VARIABLE>tpdid</VARIABLE>, int <VARIABLE>extent</VARIABLE>, int <VARIABLE>res_id</VARIABLE>, int <VARIABLE>vu</VARIABLE>);
int
releaseunit17(struct dsreq *<VARIABLE>dsp</VARIABLE>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int <VARIABLE>tpr</VARIABLE>, int <VARIABLE>tpdid</VARIABLE>, int <VARIABLE>extent</VARIABLE>, int <VARIABLE>res_id</VARIABLE>, int <VARIABLE>vu</VARIABLE>);
</CODE>
<PARAGRAPH>The arguments are as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>dsp</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The address of a <VARIABLE>dsreq</VARIABLE> structure prepared by <FUNCTION>dsopen()</FUNCTION>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>data</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The address of data to send with the Reserve Unit. (This may be NULL 
for <FUNCTION>reservunit16()</FUNCTION> which does not normally transfer data.) </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>datalen</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The length of the data (typically 0). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>tpr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The least-significant bit is used to set the Third-Party Reservation bit in 
the command: 1 means the reservation is on behalf of another initiator. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>tpdid</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The device ID for the device to hold the reservation: 0 unless <VARIABLE>tpr</VARIABLE> is 1. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>extent</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The least-significant bit sets the least-significant bit of byte 1 of the 
command string. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>res_id</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Passed as byte 2 of the command string. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>vu</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The least-significant two bits are used to set the vendor-specific bits in 
the Control byte in the command. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="25175">senddiagnostic1d()&mdash;Issue a Send Diagnostic Command</TITLE><PARAGRAPH>The <INDEXTARGET ID="05-dslib69"><!-- POSTPROCESSDATA: 05-dslib69|SCSI bus:command:Send Diagnostic --><INDEXTARGET ID="05-dslib70"><!-- POSTPROCESSDATA: 05-dslib70|dslib library:<FUNCTION>senddiagnostic1d()</FUNCTION> --><FUNCTION>senddiagnostic1d()</FUNCTION> function prepares and issues a Send Diagnostic command. The function prototype is</PARAGRAPH>
<CODE>
int
senddiagnostic1d(struct dsreq *<VARIABLE>dsp</VARIABLE>, caddr_t <VARIABLE>data</VARIABLE>, long <VARIABLE>datalen</VARIABLE>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int <VARIABLE>self</VARIABLE>, int <VARIABLE>dofl</VARIABLE>, int <VARIABLE>uofl</VARIABLE>, int <VARIABLE>vu</VARIABLE>);
</CODE>
<PARAGRAPH>The arguments are as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>dsp</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The address of a <VARIABLE>dsreq</VARIABLE> structure prepared by <FUNCTION>dsopen()</FUNCTION>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>data</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The address of a page or pages of diagnostic parameter data to be sent. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>datalen</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The length of the data (0 if none). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>self</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The least-significant bit sets the Self Test (ST) bit in the command: 1 
means return status from the self-test; 0 means hold the results. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>dofl</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The least-significant bit sets the Device Offline bit of the command: 1 
authorizes tests that can change the status of other logical units. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>uofl</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The least-significant bit sets the Unit Offline bit of the command: 1 
authorizes tests that can change the status of the logical unit. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>vu</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The least-significant two bits are used to set the vendor-specific bits in 
the Control byte in the command. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>When <VARIABLE>self</VARIABLE> is 1, the status reflects the success of the self-test. You should either set the DSRQ_SENSE flag in the <VARIABLE>dsreq</VARIABLE> so that if the self-test fails, a Sense command will be issued, or be prepared to call <FUNCTION>requestsense03()</FUNCTION>. When <VARIABLE>self</VARIABLE> is 0, you can use a Read Diagnostic command to return detailed results of the test (however, dslib does not contain a predefined function for Read Diagnostic).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="39709">testunitready00&mdash;Issue a Test Unit Ready Command</TITLE><PARAGRAPH>The <INDEXTARGET ID="05-dslib71"><!-- POSTPROCESSDATA: 05-dslib71|SCSI bus:command:Test Unit Ready --><INDEXTARGET ID="05-dslib72"><!-- POSTPROCESSDATA: 05-dslib72|dslib library:<FUNCTION>testunitready00()</FUNCTION> --><FUNCTION>testunitready00()</FUNCTION> function prepares and issues a Test Unit Ready command to a SCSI device. The function prototype is</PARAGRAPH>
<CODE>
int
testunitready00(struct dsreq *<VARIABLE>dsp</VARIABLE>);
</CODE>
<PARAGRAPH>This function is reproduced here in <XREF IDREF="79150" TYPE="TEXT">Example&nbsp;5-2</XREF> as an example of how other command-oriented functions can be created.</PARAGRAPH>
<CODE><CAPTION LBL="5-2"><PREFIX>Example 5-2 </PREFIX><XREFTARGET ID="79150">Code of the testunitread00() Function</CAPTION>int
testunitready00(struct dsreq *dsp)
{
&nbsp;&nbsp;&nbsp;fillg0cmd(dsp, CMDBUF(dsp), G0_TEST, 0, 0, 0, 0, 0);
&nbsp;&nbsp;&nbsp;filldsreq(dsp, 0, 0, DSRQ_READ|DSRQ_SENSE);
&nbsp;&nbsp;&nbsp;return(doscsireq(getfd(dsp), dsp));
}
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="33383">write0a() and writeextended2a()&mdash;Issue a Write Command</TITLE><PARAGRAPH>The <INDEXTARGET ID="05-dslib73"><!-- POSTPROCESSDATA: 05-dslib73|SCSI bus:command:Write --><INDEXTARGET ID="05-dslib74"><!-- POSTPROCESSDATA: 05-dslib74|dslib library:<FUNCTION>write0a()</FUNCTION> --><INDEXTARGET ID="05-dslib75"><!-- POSTPROCESSDATA: 05-dslib75|dslib library:<FUNCTION>writeextended2a()</FUNCTION> --><FUNCTION>write0a()</FUNCTION> function prepares and issues a group 0 Write command. The <FUNCTION>writeextended2a()</FUNCTION> function prepares and issues an extended (10-byte) Write command. As with Read commands (see <XREF IDREF="51959" TYPE="TITLE">&ldquo;read08() and readextended28()&mdash;Issue a Read Command&rdquo;</XREF>), Write commands have many device-specific features, and you will very likely have to create your own customized version of these functions.</PARAGRAPH>
<PARAGRAPH>The function prototypes are</PARAGRAPH>
<CODE>
int
write0a(struct dsreq *<VARIABLE>dsp</VARIABLE>, caddr_t <VARIABLE>data</VARIABLE>, long <VARIABLE>datalen</VARIABLE>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long <VARIABLE>lba</VARIABLE>, int <VARIABLE>vu</VARIABLE>);
int
writeextended2a(struct dsreq *<VARIABLE>dsp</VARIABLE>, caddr_t <VARIABLE>data</VARIABLE>, long <VARIABLE>datalen</VARIABLE>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long <VARIABLE>lba</VARIABLE>, int <VARIABLE>vu</VARIABLE>);
</CODE>
<PARAGRAPH>The arguments are as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>dsp</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The address of a <VARIABLE>dsreq</VARIABLE> structure prepared by <FUNCTION>dsopen()</FUNCTION>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>data</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The address of the data to be sent. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>datalen</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The length of the data (at most 255 for <FUNCTION>write0a</FUNCTION>). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>lba</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The logical block address (at most 16 bits for <FUNCTION>write0a</FUNCTION>). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>vu</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The least-significant two bits are used to set the vendor-specific bits in 
the Control byte in the command. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="45470">Example dslib Program</TITLE><PARAGRAPH>The program in <XREF IDREF="51065" TYPE="TEXT">Example&nbsp;5-3</XREF> illustrates the use of the dslib functions. This is an edited version of a program that can be obtained in full from Dave Olson's home page, <DOCTITLE>http://reality.sgi.com/employees/olson/Olson/index.html</DOCTITLE>. </PARAGRAPH>
<CODE><CAPTION LBL="5-3"><PREFIX>Example 5-3 </PREFIX><XREFTARGET ID="51065">Program That Uses dslib Functions</CAPTION>#ident&nbsp;"scsicontrol.c:&nbsp;$Revision&nbsp;$"
#include&nbsp;&lt;sys/types.h>
#include&nbsp;&lt;stddef.h>
#include&nbsp;&lt;stdlib.h>
#include&nbsp;&lt;unistd.h>
#include&nbsp;&lt;ctype.h>
#include&nbsp;&lt;errno.h>
#include&nbsp;&lt;fcntl.h>
#include&nbsp;&lt;stdio.h>
#include&nbsp;&lt;string.h>
#include&nbsp;&lt;dslib.h>
typedef&nbsp;struct
{
&nbsp;&nbsp;&nbsp;&nbsp;unchar&nbsp;&nbsp;pqt:3;&nbsp;&nbsp;/*&nbsp;peripheral&nbsp;qual&nbsp;type&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;unchar&nbsp;&nbsp;pdt:5;&nbsp;&nbsp;/*&nbsp;peripheral&nbsp;device&nbsp;type&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;unchar&nbsp;&nbsp;rmb:1,&nbsp;&nbsp;/*&nbsp;removable&nbsp;media&nbsp;bit&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dtq:7;&nbsp;&nbsp;/*&nbsp;device&nbsp;type&nbsp;qualifier&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;unchar&nbsp;&nbsp;iso:2,&nbsp;&nbsp;/*&nbsp;ISO&nbsp;version&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ecma:3,&nbsp;/*&nbsp;ECMA&nbsp;version&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ansi:3;&nbsp;/*&nbsp;ANSI&nbsp;version&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;unchar&nbsp;&nbsp;aenc:1,&nbsp;/*&nbsp;async&nbsp;event&nbsp;notification&nbsp;supported&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trmiop:1,&nbsp;&nbsp;&nbsp;/*&nbsp;device&nbsp;supports&nbsp;'terminate&nbsp;io&nbsp;process'&nbsp;msg&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res0:2,&nbsp;/*&nbsp;reserved&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;respfmt:3;&nbsp;&nbsp;/*&nbsp;SCSI&nbsp;1,&nbsp;CCS,&nbsp;SCSI&nbsp;2&nbsp;inq&nbsp;data&nbsp;format&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;unchar&nbsp;&nbsp;ailen;&nbsp;&nbsp;/*&nbsp;additional&nbsp;inquiry&nbsp;length&nbsp;*/&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;unchar&nbsp;&nbsp;res1;&nbsp;&nbsp;&nbsp;/*&nbsp;reserved&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;unchar&nbsp;&nbsp;res2;&nbsp;&nbsp;&nbsp;/*&nbsp;reserved&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;unchar&nbsp;&nbsp;reladr:1,&nbsp;&nbsp;&nbsp;/*&nbsp;supports&nbsp;relative&nbsp;addressing&nbsp;(linked&nbsp;cmds)&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wide32:1,&nbsp;&nbsp;&nbsp;/*&nbsp;supports&nbsp;32&nbsp;bit&nbsp;wide&nbsp;SCSI&nbsp;bus&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wide16:1,&nbsp;&nbsp;&nbsp;/*&nbsp;supports&nbsp;16&nbsp;bit&nbsp;wide&nbsp;SCSI&nbsp;bus&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synch:1,&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;supports&nbsp;synch&nbsp;mode&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;link:1,&nbsp;/*&nbsp;supports&nbsp;linked&nbsp;commands&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res3:1,&nbsp;/*&nbsp;reserved&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmdq:1,&nbsp;/*&nbsp;supports&nbsp;cmd&nbsp;queuing&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;softre:1;&nbsp;&nbsp;&nbsp;/*&nbsp;supports&nbsp;soft&nbsp;reset&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;unchar&nbsp;&nbsp;vid[8];&nbsp;/*&nbsp;vendor&nbsp;ID&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;unchar&nbsp;&nbsp;pid[16];&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;product&nbsp;ID&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;unchar&nbsp;&nbsp;prl[4];&nbsp;/*&nbsp;product&nbsp;revision&nbsp;level*/
&nbsp;&nbsp;&nbsp;&nbsp;unchar&nbsp;&nbsp;vendsp[20];&nbsp;/*&nbsp;vendor&nbsp;specific;&nbsp;typically&nbsp;firmware&nbsp;info&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;unchar&nbsp;&nbsp;res4[40];&nbsp;&nbsp;&nbsp;/*&nbsp;reserved&nbsp;for&nbsp;scsi&nbsp;3,&nbsp;etc.&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;more&nbsp;vendor&nbsp;specific&nbsp;information&nbsp;may&nbsp;follow&nbsp;*/
}&nbsp;inqdata;
struct&nbsp;msel&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;rsv,&nbsp;mtype,&nbsp;vendspec,&nbsp;blkdesclen;&nbsp;/*&nbsp;header&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;dens,&nbsp;nblks[3],&nbsp;rsv1,&nbsp;bsize[3];&nbsp;&nbsp;&nbsp;/*&nbsp;block&nbsp;desc&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;pgnum,&nbsp;pglen;&nbsp;/*&nbsp;modesel&nbsp;page&nbsp;num&nbsp;and&nbsp;length&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;data[240];&nbsp;/*&nbsp;some&nbsp;drives&nbsp;get&nbsp;upset&nbsp;if&nbsp;no&nbsp;data&nbsp;requested
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on&nbsp;sense*/
};
#define&nbsp;hex(x)&nbsp;"0123456789ABCDEF"&nbsp;[&nbsp;(x)&nbsp;&amp;&nbsp;0xF&nbsp;]
/*&nbsp;only&nbsp;looks&nbsp;OK&nbsp;if&nbsp;nperline&nbsp;a&nbsp;multiple&nbsp;of&nbsp;4,&nbsp;but&nbsp;that's&nbsp;OK.
&nbsp;*&nbsp;value&nbsp;of&nbsp;space&nbsp;must&nbsp;be&nbsp;0&nbsp;&lt;=&nbsp;space&nbsp;&lt;=&nbsp;3;
&nbsp;*/
void
hprint(unsigned&nbsp;char&nbsp;*s,&nbsp;int&nbsp;n,&nbsp;int&nbsp;nperline,&nbsp;int&nbsp;space)
{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;i,&nbsp;x,&nbsp;startl;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;for(startl=i=0;i&lt;n;i++)&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;s[i];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%c%c",&nbsp;hex(x>>4),&nbsp;hex(x));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(space)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%.*s",&nbsp;((i%4)==3)+space,&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;i%nperline&nbsp;==&nbsp;(nperline&nbsp;-&nbsp;1)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;putchar('\t');
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(startl&nbsp;&lt;&nbsp;i)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(isprint(s[startl]))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;putchar(s[startl]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;putchar('.');
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startl++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;putchar('\n');
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if(space&nbsp;&amp;&amp;&nbsp;(i%nperline))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;putchar('\n');
}
/*&nbsp;aenc,&nbsp;trmiop,&nbsp;reladr,&nbsp;wbus*,&nbsp;synch,&nbsp;linkq,&nbsp;softre&nbsp;are&nbsp;only&nbsp;valid&nbsp;if
&nbsp;*&nbsp;if&nbsp;respfmt&nbsp;has&nbsp;the&nbsp;value&nbsp;2&nbsp;(or&nbsp;possibly&nbsp;larger&nbsp;values&nbsp;for&nbsp;future
&nbsp;*&nbsp;versions&nbsp;of&nbsp;the&nbsp;SCSI&nbsp;standard).&nbsp;*/
static&nbsp;char&nbsp;pdt_types[][16]&nbsp;=&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;"Disk",&nbsp;"Tape",&nbsp;"Printer",&nbsp;"Processor",&nbsp;"WORM",&nbsp;"CD-ROM",
&nbsp;&nbsp;&nbsp;&nbsp;"Scanner",&nbsp;"Optical",&nbsp;"Jukebox",&nbsp;"Comm",&nbsp;"Unknown"
};
#define&nbsp;NPDT&nbsp;(sizeof&nbsp;pdt_types&nbsp;/&nbsp;sizeof&nbsp;pdt_types[0])
void
printinq(struct&nbsp;dsreq&nbsp;*dsp,&nbsp;inqdata&nbsp;*inq,&nbsp;int&nbsp;allinq)
{
&nbsp;&nbsp;&nbsp;&nbsp;if(DATASENT(dsp)&nbsp;&lt;&nbsp;1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("No&nbsp;inquiry&nbsp;data&nbsp;returned\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;printf("%-10s",&nbsp;pdt_types[(inq->pdt&lt;NPDT)&nbsp;?&nbsp;inq->pdt&nbsp;:&nbsp;NPDT-1]);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(DATASENT(dsp)&nbsp;>&nbsp;8)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%12.8s",&nbsp;inq->vid);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(DATASENT(dsp)&nbsp;>&nbsp;16)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%.16s",&nbsp;inq->pid);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(DATASENT(dsp)&nbsp;>&nbsp;32)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%.4s",&nbsp;inq->prl);
&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
&nbsp;&nbsp;&nbsp;&nbsp;if(DATASENT(dsp)&nbsp;>&nbsp;1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("ANSI&nbsp;vers&nbsp;%d,&nbsp;ISO&nbsp;ver:&nbsp;%d,&nbsp;ECMA&nbsp;ver:&nbsp;%d;&nbsp;",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inq->ansi,&nbsp;inq->iso,&nbsp;inq->ecma);
&nbsp;&nbsp;&nbsp;&nbsp;if(DATASENT(dsp)&nbsp;>&nbsp;2)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unchar&nbsp;special&nbsp;=&nbsp;*(inq->vid-1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(inq->respfmt&nbsp;>=&nbsp;2&nbsp;||&nbsp;special)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(inq->respfmt&nbsp;&lt;&nbsp;2)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\nResponse&nbsp;format&nbsp;type&nbsp;%d,&nbsp;but&nbsp;has&nbsp;"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"SCSI-2&nbsp;capability&nbsp;bits&nbsp;set\n",&nbsp;inq->respfmt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("supports:&nbsp;");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(inq->aenc)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;AENC");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(inq->trmiop)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;termiop");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(inq->reladr)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;reladdr");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(inq->wide32)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;32bit");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(inq->wide16)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;16bit");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(inq->synch)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;synch");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(inq->synch)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;linkedcmds");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(inq->cmdq)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;cmdqueing");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(inq->softre)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("&nbsp;softreset");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(inq->respfmt&nbsp;&lt;&nbsp;2)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(special)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(".&nbsp;&nbsp;");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("inquiry&nbsp;format&nbsp;is&nbsp;%s",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inq->respfmt&nbsp;?&nbsp;"SCSI&nbsp;1"&nbsp;:&nbsp;"CCS");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;putchar('\n');
&nbsp;&nbsp;&nbsp;&nbsp;printf("Device&nbsp;is&nbsp;&nbsp;");
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;&nbsp;do&nbsp;test&nbsp;unit&nbsp;ready&nbsp;only&nbsp;if&nbsp;inquiry&nbsp;successful,&nbsp;since&nbsp;many
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;devices,&nbsp;such&nbsp;as&nbsp;tapes,&nbsp;return&nbsp;inquiry&nbsp;info,&nbsp;even&nbsp;if
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;not&nbsp;ready&nbsp;(i.e.,&nbsp;no&nbsp;tape&nbsp;in&nbsp;a&nbsp;tape&nbsp;drive).&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if(testunitready00(dsp)&nbsp;!=&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%s\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(RET(dsp)==DSRT_NOSEL)&nbsp;?&nbsp;"not&nbsp;responding"&nbsp;:&nbsp;"not&nbsp;ready");
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("ready");
&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
}
/*&nbsp;inquiry&nbsp;cmd&nbsp;that&nbsp;does&nbsp;vital&nbsp;product&nbsp;data&nbsp;as&nbsp;spec'ed&nbsp;in&nbsp;SCSI2&nbsp;*/
int
vpinquiry12(&nbsp;struct&nbsp;dsreq&nbsp;*dsp,&nbsp;caddr_t&nbsp;data,&nbsp;long&nbsp;datalen,&nbsp;char&nbsp;vu, int&nbsp;page)
{
&nbsp;&nbsp;fillg0cmd(dsp,&nbsp;(uchar_t&nbsp;*)CMDBUF(dsp),&nbsp;G0_INQU,&nbsp;1,&nbsp;page,&nbsp;0,&nbsp;B1(datalen),
&nbsp;&nbsp;&nbsp;&nbsp;B1(vu&lt;&lt;6));
&nbsp;&nbsp;filldsreq(dsp,&nbsp;(uchar_t&nbsp;*)data,&nbsp;datalen,&nbsp;DSRQ_READ|DSRQ_SENSE);
&nbsp;&nbsp;return(doscsireq(getfd(dsp),&nbsp;dsp));
}
int
startunit1b(struct&nbsp;dsreq&nbsp;*dsp,&nbsp;int&nbsp;startstop,&nbsp;int&nbsp;vu)
{
&nbsp;&nbsp;fillg0cmd(dsp,(uchar_t&nbsp;*)CMDBUF(dsp),0x1b,0,0,0,(uchar_t)startstop,B1(vu&lt;&lt;6));
&nbsp;&nbsp;filldsreq(dsp,&nbsp;NULL,&nbsp;0,&nbsp;DSRQ_READ|DSRQ_SENSE);
&nbsp;&nbsp;dsp->ds_time&nbsp;=&nbsp;1000&nbsp;*&nbsp;90;&nbsp;/*&nbsp;90&nbsp;seconds&nbsp;*/
&nbsp;&nbsp;return(doscsireq(getfd(dsp),&nbsp;dsp));
}
int
myinquiry12(struct&nbsp;dsreq&nbsp;*dsp,&nbsp;uchar_t&nbsp;*data,&nbsp;long&nbsp;datalen,&nbsp;int&nbsp;vu,&nbsp;int&nbsp;neg)
{
&nbsp;&nbsp;fillg0cmd(dsp,&nbsp;(uchar_t&nbsp;*)CMDBUF(dsp),&nbsp;G0_INQU,&nbsp;0,0,0,&nbsp;B1(datalen),&nbsp;B1(vu&lt;&lt;6));
&nbsp;&nbsp;filldsreq(dsp,&nbsp;data,&nbsp;datalen,&nbsp;DSRQ_READ|DSRQ_SENSE|neg);
&nbsp;&nbsp;dsp->ds_time&nbsp;=&nbsp;1000&nbsp;*&nbsp;30;&nbsp;/*&nbsp;90&nbsp;seconds&nbsp;*/
&nbsp;&nbsp;return(doscsireq(getfd(dsp),&nbsp;dsp));
}
int
dsreset(struct&nbsp;dsreq&nbsp;*dsp)
{
&nbsp;&nbsp;return&nbsp;ioctl(getfd(dsp),&nbsp;DS_RESET,&nbsp;dsp);
}
void
usage(char&nbsp;*prog)
{
&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,
&nbsp;&nbsp;&nbsp;&nbsp;"Usage:&nbsp;%s&nbsp;[-i&nbsp;(inquiry)]&nbsp;[-e&nbsp;(exclusive)]&nbsp;[-s&nbsp;(sync)&nbsp;|&nbsp;-a&nbsp;(async)]\n"
&nbsp;&nbsp;&nbsp;&nbsp;"\t[-l&nbsp;(long&nbsp;inq)]&nbsp;[-v&nbsp;(vital&nbsp;proddata)]&nbsp;[-r&nbsp;(reset)]&nbsp;[-D&nbsp;(diagselftest)]\n"
&nbsp;&nbsp;&nbsp;&nbsp;"\t[-H&nbsp;(halt/stop)]&nbsp;[-b&nbsp;blksize]\n"
&nbsp;&nbsp;&nbsp;&nbsp;"\t[-g&nbsp;(get&nbsp;host&nbsp;flags)]&nbsp;[-d&nbsp;(debug)]&nbsp;[-q&nbsp;(quiet)]&nbsp;scsidevice&nbsp;[...]\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prog);
&nbsp;&nbsp;&nbsp;&nbsp;exit(1);
}
main(int&nbsp;argc,&nbsp;char&nbsp;**argv)
{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;dsreq&nbsp;*dsp;
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*fn;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;int&nbsp;because&nbsp;they&nbsp;must&nbsp;be&nbsp;word&nbsp;aligned.&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;errs&nbsp;=&nbsp;0,&nbsp;c;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;vital=0,&nbsp;doreset=0,&nbsp;exclusive=0,&nbsp;dosync=0;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;dostart&nbsp;=&nbsp;0,&nbsp;dostop&nbsp;=&nbsp;0,&nbsp;dosenddiag&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;doinq&nbsp;=&nbsp;0,&nbsp;printname&nbsp;=&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;bsize&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;extern&nbsp;char&nbsp;*optarg;
&nbsp;&nbsp;&nbsp;&nbsp;extern&nbsp;int&nbsp;optind,&nbsp;opterr;
&nbsp;&nbsp;&nbsp;&nbsp;opterr&nbsp;=&nbsp;0;&nbsp;/*&nbsp;handle&nbsp;errors&nbsp;ourselves.&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;((c&nbsp;=&nbsp;getopt(argc,&nbsp;argv,&nbsp;"b:HDSaserdvlgCiq"))&nbsp;!=&nbsp;-1)
&nbsp;&nbsp;&nbsp;&nbsp;switch(c)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'i':
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doinq&nbsp;=&nbsp;1;&nbsp;&nbsp;/*&nbsp;do&nbsp;inquiry&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'D':
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dosenddiag&nbsp;=&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'r':
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doreset&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;do&nbsp;a&nbsp;scsi&nbsp;bus&nbsp;reset&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'e':
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exclusive&nbsp;=&nbsp;O_EXCL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'d':
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dsdebug++;&nbsp;&nbsp;/*&nbsp;enable&nbsp;debug&nbsp;info&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'q':
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printname&nbsp;=&nbsp;0;&nbsp;&nbsp;/*&nbsp;print&nbsp;devicename&nbsp;only&nbsp;if&nbsp;error&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'v':
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vital&nbsp;=&nbsp;1;&nbsp;&nbsp;/*&nbsp;set&nbsp;evpd&nbsp;bit&nbsp;for&nbsp;scsi&nbsp;2&nbsp;vital&nbsp;product&nbsp;data&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'H':
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dostop&nbsp;=&nbsp;1;&nbsp;/*&nbsp;send&nbsp;a&nbsp;stop&nbsp;(Halt)&nbsp;command&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'S':
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dostart&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;send&nbsp;a&nbsp;startunit/spinup&nbsp;command&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'s':
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dosync&nbsp;=&nbsp;DSRQ_SYNXFR;&nbsp;&nbsp;&nbsp;/*&nbsp;attempt&nbsp;to&nbsp;negotiate&nbsp;sync&nbsp;scsi&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'a':
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dosync&nbsp;=&nbsp;DSRQ_ASYNXFR;&nbsp;&nbsp;/*&nbsp;attempt&nbsp;to&nbsp;negotiate&nbsp;async&nbsp;scsi&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;usage(argv[0]);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if(optind&nbsp;>=&nbsp;argc&nbsp;||&nbsp;optind&nbsp;==&nbsp;1)&nbsp;&nbsp;&nbsp;/*&nbsp;need&nbsp;at&nbsp;1&nbsp;arg&nbsp;and&nbsp;one&nbsp;option&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;usage(argv[0]);
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(optind&nbsp;&lt;&nbsp;argc)&nbsp;{&nbsp;/*&nbsp;loop&nbsp;over&nbsp;each&nbsp;filename&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fn&nbsp;=&nbsp;argv[optind++];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(printname)&nbsp;printf("%s:&nbsp;&nbsp;",&nbsp;fn);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if((dsp&nbsp;=&nbsp;dsopen(fn,&nbsp;O_RDONLY|exclusive))&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;if&nbsp;open&nbsp;fails,&nbsp;try&nbsp;pre-pending&nbsp;/dev/scsi&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;buf[256];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcpy(buf,&nbsp;"/dev/scsi/");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if((strlen(buf)&nbsp;+&nbsp;strlen(fn))&nbsp;&lt;&nbsp;sizeof(buf))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcat(buf,&nbsp;fn);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dsp&nbsp;=&nbsp;dsopen(buf,&nbsp;O_RDONLY|exclusive);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!dsp)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!printname)&nbsp;printf("%s:&nbsp;&nbsp;",&nbsp;fn);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fflush(stdout);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("cannot&nbsp;open");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errs++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;try&nbsp;to&nbsp;order&nbsp;for&nbsp;reasonableness;&nbsp;reset&nbsp;first&nbsp;in&nbsp;case
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;hung,&nbsp;then&nbsp;inquiry,&nbsp;etc.&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(doreset)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(dsreset(dsp)&nbsp;!=&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!printname)&nbsp;printf("%s:&nbsp;&nbsp;",&nbsp;fn);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("reset&nbsp;failed:&nbsp;%s\n",&nbsp;strerror(errno));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errs++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(doinq)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;inqbuf[sizeof(inqdata)/sizeof(int)];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(myinquiry12(dsp,&nbsp;(uchar_t&nbsp;*)inqbuf,&nbsp;sizeof&nbsp;inqbuf,&nbsp;0,&nbsp;dosync))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!printname)&nbsp;printf("%s:&nbsp;&nbsp;",&nbsp;fn);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("inquiry&nbsp;failure\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errs++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printinq(dsp,&nbsp;(inqdata&nbsp;*)inqbuf,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(vital)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;*vpinq;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;vpinqbuf[sizeof(inqdata)/sizeof(int)];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;vpinqbuf0[sizeof(inqdata)/sizeof(int)];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i,&nbsp;serial&nbsp;=&nbsp;0,&nbsp;asciidef&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(vpinquiry12(dsp,&nbsp;(char&nbsp;*)vpinqbuf0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(vpinqbuf)-1,&nbsp;0,&nbsp;0))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!printname)&nbsp;printf("%s:&nbsp;&nbsp;",&nbsp;fn);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("inquiry&nbsp;(vital&nbsp;data)&nbsp;failure\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errs++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(DATASENT(dsp)&nbsp;&lt;4)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("vital&nbsp;data&nbsp;inquiry&nbsp;OK,&nbsp;but&nbsp;says&nbsp;no"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"pages&nbsp;supported&nbsp;(page&nbsp;0)\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vpinq&nbsp;=&nbsp;(unsigned&nbsp;char&nbsp;*)vpinqbuf0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Supported&nbsp;vital&nbsp;product&nbsp;pages:&nbsp;");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(i&nbsp;=&nbsp;vpinq[3]+3;&nbsp;i>3;&nbsp;i--)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(vpinq[i]&nbsp;==&nbsp;0x80)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serial&nbsp;=&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(vpinq[i]&nbsp;==&nbsp;0x82)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;asciidef&nbsp;=&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%2x&nbsp;&nbsp;",&nbsp;vpinq[i]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vpinq&nbsp;=&nbsp;(unsigned&nbsp;char&nbsp;*)vpinqbuf;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(serial)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(vpinquiry12(dsp,&nbsp;(char&nbsp;*)vpinqbuf,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(vpinqbuf)-1,&nbsp;0,&nbsp;0x80)&nbsp;!=&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!printname)&nbsp;printf("%s:&nbsp;&nbsp;",&nbsp;fn);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("inquiry&nbsp;(serial&nbsp;#)&nbsp;failure\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errs++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if(DATASENT(dsp)>3)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Serial&nbsp;#:&nbsp;");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fflush(stdout);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;use&nbsp;write,&nbsp;because&nbsp;there&nbsp;may&nbsp;well&nbsp;be
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*nulls;&nbsp;don't&nbsp;bother&nbsp;to&nbsp;strip&nbsp;them&nbsp;out&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(1,&nbsp;vpinq+4,&nbsp;vpinq[3]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(asciidef)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(vpinquiry12(dsp,&nbsp;(char&nbsp;*)vpinqbuf,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof(vpinqbuf)-1,&nbsp;0,&nbsp;0x82)&nbsp;!=&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!printname)&nbsp;printf("%s:&nbsp;&nbsp;",&nbsp;fn);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("inquiry&nbsp;(ascii&nbsp;definition)&nbsp;failure\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errs++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if(DATASENT(dsp)>3)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("Ascii&nbsp;definition:&nbsp;");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fflush(stdout);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;use&nbsp;write,&nbsp;because&nbsp;there&nbsp;may&nbsp;well&nbsp;be
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*nulls;&nbsp;don't&nbsp;bother&nbsp;to&nbsp;strip&nbsp;them&nbsp;out&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(1,&nbsp;vpinq+4,&nbsp;vpinq[3]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(dostop&nbsp;&amp;&amp;&nbsp;startunit1b(dsp,&nbsp;0,&nbsp;0))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!printname)&nbsp;printf("%s:&nbsp;&nbsp;",&nbsp;fn);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("stopunit&nbsp;fails\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errs++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(dostart&nbsp;&amp;&amp;&nbsp;startunit1b(dsp,&nbsp;1,&nbsp;0))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!printname)&nbsp;printf("%s:&nbsp;&nbsp;",&nbsp;fn);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("startunit&nbsp;fails\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errs++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(dosenddiag&nbsp;&amp;&amp;&nbsp;senddiagnostic1d(dsp,&nbsp;NULL,&nbsp;0,&nbsp;1,&nbsp;0,&nbsp;0,&nbsp;0))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!printname)&nbsp;printf("%s:&nbsp;&nbsp;",&nbsp;fn);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("self&nbsp;test&nbsp;fails\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errs++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
dsclose(dsp);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return(errs);
}
</CODE>
</SECTION1>
</CHAPTER>
