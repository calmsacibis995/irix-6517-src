<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="15"><TITLE><XREFTARGET ID="14611">Services for VME Drivers on Challenge/Onyx</TITLE><PARAGRAPH>This chapter provides an overview of the kernel services needed by a kernel-level VME device driver on Challenge and Onyx systems. It contains a complete example driver.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>For information on writing VME device drivers for Origin and Onyx2 systems, refer to <XREF IDREF="13012" TYPE="TITLE">Chapter&nbsp;13</XREF>. For information on porting IRIX 6.2 drivers to IRIX 6.5, refer to <XREF IDREF="70048" TYPE="TITLE">&ldquo;Porting From IRIX 6.2&rdquo;</XREF>.</NOTE>
<SECTION1 LBL="" HELPID = ""><TITLE>Kernel Services for VME</TITLE><PARAGRAPH>The kernel provides services for mapping the VME bus into the kernel virtual address space for PIO or DMA, and for transferring data using maps. It also provides services for allocating interrupt vector numbers.<INDEXTARGET ID="14.1Z-vmesvcs1"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs1|VME bus:kernel services --></PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Mapping PIO Addresses</TITLE><PARAGRAPH>A PIO map is a system object that represents the mapping from a location in the kernel's virtual address space to some small range of addresses on a VME or EISA bus. After creating a PIO map, a device driver can use it in the following ways:<INDEXTARGET ID="14.1Z-vmesvcs2"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs2|Programmed I/O (PIO):address maps for --><INDEXTARGET ID="14.1Z-vmesvcs3"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs3|VME bus:PIO to:address maps --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Use the specific kernel virtual address that represents the device, either to load or store data, or to map that address into user process space.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Copy data between the device and memory without learning the specific kernel addresses involved.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Perform bus read-modify-write cycles to apply Boolean operators efficiently to device data.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The kernel virtual address returned by PIO mapping is not a physical memory address and is not a bus address. The kernel virtual address and the VME or EISA bus address need not have any bits in common.</PARAGRAPH>
<PARAGRAPH>The functions used with PIO maps are summarized in <XREF IDREF="99779" TYPE="TABLE">Table&nbsp;15-1</XREF>. </PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="15-1"><PREFIX>Table 15-1 </PREFIX><XREFTARGET ID="99779"> <EMPHASIS>(continued)        </EMPHASIS>Functions to Create and Use PIO Maps</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="108"><PARAGRAPH>&lbreak;Function</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>&lbreak;Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="42"><PARAGRAPH>Can 
Sleep</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="173"><PARAGRAPH>&lbreak;Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_mapalloc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="42"><PARAGRAPH>Y</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="173"><PARAGRAPH>Allocate a PIO map.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_mapfree(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="42"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="173"><PARAGRAPH>Free a PIO map.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_badaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="42"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="173"><PARAGRAPH>Check for bus error when reading an 
address.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_badaddr_val(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="42"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="173"><PARAGRAPH>Check for bus error when reading an 
address and return the value read.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_wbadaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="42"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="173"><PARAGRAPH>Check for bus error when writing to an 
address.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_wbadaddr_val(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="42"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="173"><PARAGRAPH>Check for bus error when writing a 
specified value to an address.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_mapaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="42"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="173"><PARAGRAPH>Convert a bus address to a virtual address.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_bcopyin(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="42"><PARAGRAPH>Y</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="173"><PARAGRAPH>Copy data from a bus address to kernel's 
virtual space.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_bcopyout(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="42"><PARAGRAPH>Y</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="173"><PARAGRAPH>Copy data from kernel's virtual space to a 
bus address.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_andb_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="42"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="173"><PARAGRAPH>Byte read-and-write.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_andh_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="42"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="173"><PARAGRAPH>16-bit read-and-write.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_andw_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="42"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="173"><PARAGRAPH>32-bit read-and-write.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_orb_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="42"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="173"><PARAGRAPH>Byte read-or-write.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_orh_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="42"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="173"><PARAGRAPH>16-bit read-or-write.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pio_orw_rmw(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="72"><PARAGRAPH>pio.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="42"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="245" WIDTH="173"><PARAGRAPH>32-bit read-or-write.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>A kernel-level device driver creates a PIO map by calling <INDEXTARGET ID="14.1Z-vmesvcs4"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs4|kernel functions:<FUNCTION>pio_mapalloc</FUNCTION>() --><FUNCTION>pio_mapalloc()</FUNCTION>. This function performs memory allocation and so can sleep. PIO maps are typically created in the <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> entry point, where the driver first learns about the device addresses from the contents of the <VARIABLE>edt_t</VARIABLE> structure (see <XREF IDREF="14072" TYPE="TITLE">&ldquo;Entry Point edtinit()&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>The parameters to <FUNCTION>pio_mapalloc()</FUNCTION> describe the range of addresses that can be mapped in terms of</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>the bus type, ADAP_VME or ADAP_EISA from <FILENAME>sys/edt.h</FILENAME>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the bus number, when more than one bus is supported</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the address space, using constants such as PIOMAP_A24N or PIOMAP_EISA_IO from <FILENAME>sys/pio.h</FILENAME>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the starting bus address and a length</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>This call also specifies a &ldquo;fixed&rdquo; or &ldquo;unfixed&rdquo; map. The usual type is &ldquo;fixed.&rdquo; For the differences, see <XREF IDREF="90507" TYPE="TITLE">&ldquo;Fixed PIO Maps&rdquo;</XREF> and <XREF IDREF="49481" TYPE="TITLE">&ldquo;Unfixed PIO Maps&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>A call to <FUNCTION>pio_mapfree()</FUNCTION> releases a PIO map. PIO maps created by a loadable driver must be released in the <VARIABLE>pfx</VARIABLE><FUNCTION>unload()</FUNCTION> entry point (see <XREF IDREF="57773" TYPE="TITLE">&ldquo;Entry Point unload()&rdquo;</XREF> and <XREF IDREF="53871" TYPE="TITLE">&ldquo;Unloading&rdquo;</XREF>).</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Testing the PIO Map</TITLE><PARAGRAPH>The PIO map is created from the parameters that are passed. These are not validated by <FUNCTION>pio_mapalloc()</FUNCTION>. If there is any possibility that the mapped device is not installed, not active, or improperly configured, you should test the mapped address.</PARAGRAPH>
<PARAGRAPH>The <INDEXTARGET ID="14.1Z-vmesvcs5"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs5|IRIX functions:<FUNCTION>pio_badaddr</FUNCTION>() --><FUNCTION>pio_badaddr()</FUNCTION> and <FUNCTION>pio_badaddr_val()</FUNCTION> functions test the mapped address to see if it is usable for input. Both functions perform the same operation: operating through a PIO map, they test a specified bus address for validity by reading 1, 2, 4, or 8 bytes from it. The <FUNCTION>pio_badaddr_val()</FUNCTION> function returns the value that it reads while making the test. This can simplify coding, as shown in <XREF IDREF="34932" TYPE="TEXT">Example&nbsp;15-1</XREF>.</PARAGRAPH>
<CODE><CAPTION LBL="15-1"><PREFIX>Example 15-1 </PREFIX><XREFTARGET ID="34932">Comparing pio_badaddr() to pio_badaddr_val()</CAPTION>unsigned int gotvalue;
piomap_t *themap;
/* Using only pio_badaddr() */
&nbsp;&nbsp;&nbsp;if (!pio_badaddr(themap,CTLREG,4)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void) pio_bcopyin(themap,CTLREG,&amp;gotvalue,4,4,0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...use "gotvalue"
/* Using pio_badaddr_val() */
&nbsp;&nbsp;&nbsp;if (!pio_badaddr_val(themap,CTLREG,4,&amp;gotvalue))
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...use "gotvalue"
</CODE>
<PARAGRAPH>The <FUNCTION>pio_wbadaddr()</FUNCTION> function tests a mapped device address for writability. The <FUNCTION>pio_wbadaddr_val()</FUNCTION> not only tests the address but takes a specific value to write to that address in the course of testing it.<INDEXTARGET ID="14.1Z-vmesvcs6"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs6|kernel functions:<FUNCTION>pio_wbadaddr</FUNCTION>() --></PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using the Mapped Address</TITLE><PARAGRAPH>From a fixed PIO map you can recover a kernel virtual address that corresponds to the first bus address in the map. The <INDEXTARGET ID="14.1Z-vmesvcs7"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs7|kernel functions:<FUNCTION>pio_mapaddr</FUNCTION>() --><FUNCTION>pio_mapaddr()</FUNCTION> function is used for this.</PARAGRAPH>
<PARAGRAPH>You can use this address to load or store data into device registers. In the <VARIABLE>pfx</VARIABLE><FUNCTION>map()</FUNCTION> entry point (see <XREF IDREF="34808" TYPE="TITLE">&ldquo;Concepts and Use of mmap()&rdquo;</XREF>), you can use this address with the <FUNCTION>v_mapphys()</FUNCTION> function to map the range of device addresses into the address space of a user process.</PARAGRAPH>
<PARAGRAPH>You cannot extract a kernel address from an unfixed PIO map, as explained under <XREF IDREF="49481" TYPE="TITLE">&ldquo;Unfixed PIO Maps&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using the PIO Map in Functions</TITLE><PARAGRAPH>You can apply a variety of kernel functions to any PIO map, fixed or unfixed. The <INDEXTARGET ID="14.1Z-vmesvcs8"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs8|kernel functions:<FUNCTION>pio_bcopyout</FUNCTION>() --><INDEXTARGET ID="14.1Z-vmesvcs9"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs9|kernel functions:<FUNCTION>pio_bcopyin</FUNCTION>() --><FUNCTION>pio_bcopyin()</FUNCTION> and <FUNCTION>pio_bcopyout()</FUNCTION> functions copy a range of data between memory and a fixed or unfixed PIO map. These functions are optimized to the hardware that exists, and they do all transfers in the largest size possible (32 or 64 bits per transfer). If you need to transfer data in specific sizes of 1 or 2 bytes, use direct loads and stores to the mapped addresses.</PARAGRAPH>
<PARAGRAPH>The series of functions <FUNCTION>pio_andb_rmw()</FUNCTION> and <FUNCTION>pio_orb_rmw()</FUNCTION> perform a read-modify-write cycle on the VME bus. You can use them to set or clear bits in device registers. A read-modify-write cycle is faster than a load followed by a store since it uses fewer system bus cycles.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="90507">Fixed PIO Maps</TITLE><PARAGRAPH>On a Challenge or Onyx system, a PIO map can be either &ldquo;fixed&rdquo; or &ldquo;unfixed.&rdquo; This attribute is specified when the map is created.<INDEXTARGET ID="14.1Z-vmesvcs10"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs10|fixed PIO map --><INDEXTARGET ID="14.1Z-vmesvcs11"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs11|VME bus:PIO to:fixed, unfixed maps --></PARAGRAPH>
<PARAGRAPH>The Challenge and Onyx architecture provides for a total of 15 separate, 8&nbsp;MB windows on VME address space for each VME bus. Two of these are permanently reserved to the kernel, and one window is reserved for use with unfixed mappings. The remaining 12 windows are available to implement fixed PIO maps.<INDEXTARGET ID="14.1Z-vmesvcs12"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs12|Challenge/Onyx:VME address windows --></PARAGRAPH>
<PARAGRAPH>When the kernel creates a fixed PIO map, the map is associated with one of the 12 available VME mapping windows. The kernel tries to be clever, so that whenever a PIO map falls within an 8&nbsp;MB window that already exists, the PIO map uses that window. If the desired VME address is not covered by an open window, one of the twelve windows for that bus is opened to expose a mapping for that address.</PARAGRAPH>
<PARAGRAPH>It is possible in principle to configure thirteen devices that are scattered so widely in the A32 address space that twelve, 8&nbsp;MB windows cannot cover all of them. In that unlikely case, the attempt to create the thirteenth fixed PIO map will fail for lack of a mapping window.</PARAGRAPH>
<PARAGRAPH>In order to prevent this, simply configure your PIO addresses into a span of at most 96&nbsp;MB per bus (see <XREF IDREF="55330" TYPE="TITLE">&ldquo;Available PIO Addresses&rdquo;</XREF>).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="49481">Unfixed PIO Maps</TITLE><PARAGRAPH>When you create an unfixed PIO map, the map is not associated with any of the twelve mapping windows. As a result, the map cannot be queried for a kernel address that might be saved, or mapped into user space.</PARAGRAPH>
<PARAGRAPH>You can use an unfixed map with kernel functions that copy data or perform read-modify-write cycles. These functions use the one mapping window that is reserved for unfixed maps, repositioning it in VME space if necessary.</PARAGRAPH>
<PARAGRAPH>The <COMMAND>lboot</COMMAND> command uses an unfixed map to perform the <COMMAND>probe</COMMAND> and <COMMAND>exprobe</COMMAND> sequences from VECTOR statements (see <XREF IDREF="22127" TYPE="TITLE">&ldquo;Configuring VME Devices&rdquo;</XREF>). As a result, these probes do not tie up mapping windows.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Mapping DMA Addresses</TITLE><PARAGRAPH>A DMA map is a system object that represents a mapping between a buffer in kernel virtual space and a range of VME bus addresses. After creating a DMA map, a driver uses the map to specify the target address and length to be programmed into a VME bus master before a DMA transfer.<INDEXTARGET ID="14.1Z-vmesvcs13"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs13|VME bus:DMA to:address maps --></PARAGRAPH>
<PARAGRAPH>The functions that operate on DMA maps are summarized in <XREF IDREF="44538" TYPE="TABLE">Table&nbsp;15-2</XREF>. </PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="15-2"><PREFIX>Table 15-2 </PREFIX><XREFTARGET ID="44538"> <EMPHASIS>(continued)        </EMPHASIS>Functions That Operate on DMA Maps</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="83"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="62"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="45"><PARAGRAPH>Can Sleep</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="195"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH><REFPAGE>dma_map(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="62"><PARAGRAPH>dmamap.h &amp; 
types.h &amp; 
sema.h</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="195"><PARAGRAPH>Load DMA mapping registers for an imminent 
transfer.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH><REFPAGE>dma_mapbp(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="62"><PARAGRAPH>dmamap.h &amp; 
types.h &amp; 
sema.h</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="195"><PARAGRAPH>Load DMA mapping registers for an imminent 
transfer.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH><REFPAGE>dma_mapaddr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="62"><PARAGRAPH>dmamap.h &amp; 
types.h &amp; 
sema.h</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="195"><PARAGRAPH>Return the &ldquo;bus virtual&rdquo; address for a given 
map and address.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH><REFPAGE>dma_mapalloc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="62"><PARAGRAPH>dmamap.h &amp; 
types.h &amp; 
sema.h</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="45"><PARAGRAPH>Y</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="195"><PARAGRAPH>Allocate a DMA map.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH><REFPAGE>dma_mapfree(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="62"><PARAGRAPH>dmamap.h &amp; 
types.h &amp; 
sema.h</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="195"><PARAGRAPH>Free a DMA map.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH><REFPAGE>vme_adapter(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="62"><PARAGRAPH>vmereg.h &amp; 
types.h</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="195"><PARAGRAPH>Determine VME adapter that corresponds to a 
given memory address.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>A device driver allocates a DMA map using <INDEXTARGET ID="14.1Z-vmesvcs14"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs14|kernel functions:<FUNCTION>dma_mapalloc</FUNCTION>() --><FUNCTION>dma_mapalloc()</FUNCTION>. This is typically done in the <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> entry point, provided that the maximum I/O size is known at that time (see <XREF IDREF="14072" TYPE="TITLE">&ldquo;Entry Point edtinit()&rdquo;</XREF>). The important argument to <FUNCTION>dma_mapalloc()</FUNCTION> is the maximum number of pages (I/O pages, the unit is IO_NBPP declared in <FILENAME>sys/immu.h</FILENAME>) to be mapped at one time.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>In the Challenge and Onyx systems, a limit of 64&nbsp;MB of mapped DMA space per VME adapter is imposed by the hardware. Some few megabytes of this are taken early by system drivers. Owing to a bug in IRIX 5.3 and 6.1, a request for 64&nbsp;MB or more is not rejected, but waits forever. However, in any release, a call to <INDEXTARGET ID="14.1Z-vmesvcs15"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs15|Challenge/Onyx:limit on VME DMA space --><FUNCTION>dma_mapalloc()</FUNCTION> that requests a single map close to the 64&nbsp;MB limit is likely to wait indefinitely for enough map space to become available. </NOTE>
<PARAGRAPH>DMA maps created by a loadable driver should be released in the <VARIABLE>pfx</VARIABLE><FUNCTION>unload()</FUNCTION> entry point (see <XREF IDREF="57773" TYPE="TITLE">&ldquo;Entry Point unload()&rdquo;</XREF> and <XREF IDREF="53871" TYPE="TITLE">&ldquo;Unloading&rdquo;</XREF>).</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Using a DMA Map</TITLE><PARAGRAPH>A DMA map is used before a DMA transfer into or out of a buffer in kernel virtual space.<INDEXTARGET ID="14.1Z-vmesvcs16"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs16|kernel functions:<FUNCTION>dma_map</FUNCTION>() --></PARAGRAPH>
<PARAGRAPH>The function <FUNCTION>dma_map()</FUNCTION> takes a DMA map, a buffer address, and a length. It assigns a span of contiguous VME addresses of the specified length, and sets up a mapping between that range of VME addresses and the physical addresses that represent the specified buffer.</PARAGRAPH>
<PARAGRAPH>When the buffer spans two or more physical pages (IO_NBPP units), <FUNCTION>dma_map()</FUNCTION> sets up a scatter/gather operation, so that the VME bus controller will place the data in the appropriate page frames.</PARAGRAPH>
<PARAGRAPH>It is possible that <FUNCTION>dma_map()</FUNCTION> cannot map the entire size of the buffer. This can occur only when the buffer spans two or more pages, and is caused by a shortage of mapping registers in the bus adapter. The function maps as much of the buffer as it can, and returns the length of the mapped data.</PARAGRAPH>
<PARAGRAPH>You must always anticipate that <FUNCTION>dma_map()</FUNCTION> might map less than the requested number of bytes, so that the DMA transfer has to be done in two or more operations.</PARAGRAPH>
<PARAGRAPH>Following the call to <INDEXTARGET ID="14.1Z-vmesvcs17"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs17|kernel functions:<FUNCTION>dma_mapaddr</FUNCTION>() --><FUNCTION>dma_map()</FUNCTION>, you usually call <FUNCTION>dma_mapaddr()</FUNCTION> to get the bus virtual address that represents the first byte of the buffer. This is the address you program into the bus master device (using a PIO store), in order to set its starting transfer address. Then you initiate the DMA transfer (again by storing a command into a device register using PIO).</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Allocating an Interrupt Vector Dynamically</TITLE><PARAGRAPH>When a VME device generates an interrupt, the Silicon Graphics VME controller initiates an interrupt acknowledge (IACK) cycle on the VME bus. During this cycle, the interrupting device presents a data value that characterizes the interrupt. This is the <INDEXTARGET ID="14.1Z-vmesvcs18"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs18|VME bus:interrupt vector --><GLOSSARYITEM>interrupt vector</GLOSSARYITEM>, in VME terminology.</PARAGRAPH>
<PARAGRAPH>According to the VME standard, the interrupt vector can be a data item of 8, 16, or 32 bits. However, Silicon Graphics systems accept only an 8-bit vector, and its value must fall in the range 1-254 inclusive. (0x00 and 0xFF are excluded because they could be generated by a hardware fault.)</PARAGRAPH>
<PARAGRAPH>The interrupt vector returned by some VME devices is hard-wired or configured into the board with switches or jumpers. When this is the case, the vector number should be written as the <COMMAND>vector</COMMAND> parameter in the VECTOR statement that describes the device (see <XREF IDREF="22127" TYPE="TITLE">&ldquo;Configuring VME Devices&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>Some VME devices are programmed with a vector number at runtime. For these devices, you omit the <COMMAND>vector</COMMAND> parameter, or give its value as an asterisk. In the device driver, you use the functions in <XREF IDREF="42835" TYPE="TABLE">Table&nbsp;15-3</XREF> to choose a vector number.</PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="15-3"><PREFIX>Table 15-3 </PREFIX><XREFTARGET ID="42835"> <EMPHASIS>(continued)        </EMPHASIS>Functions to Manage Interrupt Vector Values</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="90"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="100"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="45"><PARAGRAPH>Can Sleep</PARAGRAPH>
</CELL>
<CELL LEFT="250" WIDTH="153"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>vme_ivec_alloc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="100"><PARAGRAPH>vmereg.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="250" WIDTH="153"><PARAGRAPH>Allocate a VME bus interrupt vector.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>vme_ivec_free(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="100"><PARAGRAPH>vmereg.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="250" WIDTH="153"><PARAGRAPH>Free a VME bus interrupt vector.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><REFPAGE>vme_ivec_set(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="100"><PARAGRAPH>vmereg.h &amp; types.h</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="45"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="250" WIDTH="153"><PARAGRAPH>Register a VME bus interrupt vector.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<SECTION3 LBL="" HELPID = ""><TITLE>Allocating a Vector</TITLE><PARAGRAPH>In the <INDEXTARGET ID="14.1Z-vmesvcs19"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs19|kernel functions:<FUNCTION>vme_ivec_alloc</FUNCTION>() --><VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> entry point, the device driver selects a vector number for the device to use. The best way to select a number is to call <FUNCTION>vme_ivec_alloc()</FUNCTION>, which returns a number that has not been registered for that bus, either dynamically or in a VECTOR line. The driver then uses <INDEXTARGET ID="14.1Z-vmesvcs20"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs20|kernel functions:<FUNCTION>vme_ivec_set</FUNCTION>() --><FUNCTION>vme_ivec_set()</FUNCTION> to register the chosen vector number. This function takes parameters that specify</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The vector number</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The bus number to which it applies</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The address of the interrupt handler for this vector&mdash;typically but not necessarily the name of the <VARIABLE>pfx</VARIABLE><FUNCTION>intr()</FUNCTION> entry point of the same driver</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>An integer value to be passed to the interrupt entry point&mdash;typically but not necessarily the vector number</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The <FUNCTION>vme_ivec_set()</FUNCTION> function simply registers the number in the kernel, with the following two effects:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The <FUNCTION>vme_ivec_alloc()</FUNCTION> function does not return the same number to another call until the number is released.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The specified handler is called when a device presents this vector number on an interrupt.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Multiple devices can present the identical vector, provided that the interrupt handler has some way of distinguishing one device from another.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>If you are working with both the VME and EISA interfaces, it is worth noting that the number and types of arguments of <FUNCTION>vme_ivec_set()</FUNCTION> differ from the similar EISA support function <FUNCTION>eisa_ivec_set()</FUNCTION>.</NOTE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Releasing a Vector</TITLE><PARAGRAPH>There is a limit of 254 vector numbers per bus, so it is a good idea for a loadable driver, in its <INDEXTARGET ID="14.1Z-vmesvcs21"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs21|kernel functions:<FUNCTION>vme_ivec_free</FUNCTION>() --><VARIABLE>pfx</VARIABLE><FUNCTION>unload()</FUNCTION> entry point, to release a vector by calling <FUNCTION>vme_ivec_free()</FUNCTION> (see <XREF IDREF="57773" TYPE="TITLE">&ldquo;Entry Point unload()&rdquo;</XREF> and <XREF IDREF="53871" TYPE="TITLE">&ldquo;Unloading&rdquo;</XREF>).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Vector Errors</TITLE><PARAGRAPH>A common problem with programmable vectors in the Challenge or Onyx systems is the appearance of the following warning in the SYSLOG file:<INDEXTARGET ID="14.1Z-vmesvcs22"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs22|VME bus:stray interrupt cause --><INDEXTARGET ID="14.1Z-vmesvcs23"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs23|stray VME interrupt --></PARAGRAPH>
<EXAMPLE>
Warning: Stray VME interrupt: vector =0xff
</EXAMPLE>
<PARAGRAPH>One possible cause of this error is that the board is emitting the wrong interrupt vector; another is that the board is emitting the correct vector but with the wrong timing, so that the VME bus adapter samples all-binary-1 instead. Both these conditions can be verified with a VME bus analyzer. In the Challenge or Onyx hardware design, the most likely cause is the presence of empty slots in the VME card cage. All empty slots must be properly jumpered in order to pass interrupts correctly.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Supporting Early IO4 Cache Problems</TITLE><PARAGRAPH>VME drivers that support DMA to buffers that are not cache-aligned multiples of a cache-line need to take special precautions in a Challenge system; see <XREF IDREF="43623" TYPE="TITLE">Appendix&nbsp;B, &ldquo;Challenge DMA with Multiple IO4 Boards&rdquo;</XREF>.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE>Sample VME Device Driver</TITLE><PARAGRAPH>The source module displayed in <INDEXTARGET ID="14.1Z-vmesvcs24"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs24|driver:examples:VME --><INDEXTARGET ID="14.1Z-vmesvcs25"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs25|VME bus:example driver --><INDEXTARGET ID="14.1Z-vmesvcs26"><!-- POSTPROCESSDATA: 14.1Z-vmesvcs26|example driver --><XREF IDREF="44538" TYPE="TABLE">Table&nbsp;15-2</XREF> contains a complete character device driver for a hypothetical VME device. Although it is a character driver, it contains a strategy routine (the <FUNCTION>cdev_strategy()</FUNCTION> function). Both the <VARIABLE>pfx</VARIABLE><FUNCTION>read()</FUNCTION> and <VARIABLE>pfx</VARIABLE><FUNCTION>write()</FUNCTION> entry points call the strategy routine to perform the actual I/O. As a result, this driver could be installed as either a block device driver or a character driver, or as both.</PARAGRAPH>
<PARAGRAPH>The driver is multiprocessor-aware, so its <VARIABLE>pfx</VARIABLE><FUNCTION>devflag</FUNCTION> global contains D_MP. It uses two locks. A basic lock (<VARIABLE>board.cd_lock</VARIABLE>) is used for short-term mutual exclusion, to block a potential race between the strategy routine and the interrupt routine. A semaphore (<VARIABLE>board.cd_rwsema</VARIABLE>) is used for long-term mutual exclusion to make sure that only one process uses the device for reading or writing at any time.</PARAGRAPH>
<CODE><CAPTION LBL="15-2"><PREFIX>Example 15-2 </PREFIX>Example VME Character Driver</CAPTION>/***********************************************************************\
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cdev.c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;following&nbsp;is&nbsp;an&nbsp;example&nbsp;of&nbsp;how&nbsp;a&nbsp;device&nbsp;driver&nbsp;for&nbsp;a&nbsp;VME&nbsp;&nbsp;&nbsp;&nbsp;*
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;character&nbsp;device&nbsp;might&nbsp;be&nbsp;written.&nbsp;&nbsp;The&nbsp;sample&nbsp;driver&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;illustrates&nbsp;how&nbsp;to&nbsp;write&nbsp;code&nbsp;which&nbsp;performs&nbsp;DMA&nbsp;into&nbsp;both&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kernel&nbsp;and&nbsp;user&nbsp;address&nbsp;space,&nbsp;as&nbsp;well&nbsp;as&nbsp;how&nbsp;a&nbsp;sample&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;driver's&nbsp;registers&nbsp;would&nbsp;be&nbsp;mapped&nbsp;into&nbsp;user&nbsp;address&nbsp;space.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
\***********************************************************************/
#include&nbsp;&lt;sys/types.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Contains&nbsp;basic&nbsp;kernel&nbsp;typedefs&nbsp;*/
#include&nbsp;&lt;sys/param.h>
#include&nbsp;&lt;sys/immu.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Contains&nbsp;VM-specific&nbsp;definitions&nbsp;(map)&nbsp;*/
#include&nbsp;&lt;sys/region.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Contains&nbsp;VM&nbsp;data&nbsp;structure&nbsp;defs&nbsp;(map)&nbsp;*/
#include&nbsp;&lt;sys/conf.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Contains&nbsp;cdevsw&nbsp;and&nbsp;driver&nbsp;flag&nbsp;defs&nbsp;*/
#include&nbsp;&lt;sys/vmereg.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Contains&nbsp;VME&nbsp;bus-specific&nbsp;definitions&nbsp;*/
#include&nbsp;&lt;sys/edt.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Contains&nbsp;definition&nbsp;of&nbsp;edt&nbsp;structs&nbsp;*/
#include&nbsp;&lt;sys/dmamap.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Definitions&nbsp;for&nbsp;dma&nbsp;structs&nbsp;and&nbsp;routines&nbsp;*/
#include&nbsp;&lt;sys/pio.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Definitions&nbsp;for&nbsp;pio&nbsp;structs&nbsp;and&nbsp;routines&nbsp;*/
#include&nbsp;&lt;sys/cmn_err.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Definitions&nbsp;for&nbsp;cmn_err&nbsp;constants&nbsp;*/
#include&nbsp;&lt;sys/errno.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Define&nbsp;classic&nbsp;error&nbsp;numbers&nbsp;*/
#include&nbsp;&lt;sys/open.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Define&nbsp;open&nbsp;types&nbsp;used&nbsp;in&nbsp;otyp&nbsp;open&nbsp;parm&nbsp;*/
#include&nbsp;&lt;sys/cred.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Contains&nbsp;credential&nbsp;structure&nbsp;declaration&nbsp;*/
#include&nbsp;&lt;sys/ksynch.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Define&nbsp;ddi-compliant&nbsp;synch&nbsp;primitives&nbsp;*/
#include&nbsp;&lt;sys/sema.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Include&nbsp;semaphore&nbsp;prototypes&nbsp;*/
#include&nbsp;&lt;sys/ddi.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Include&nbsp;the&nbsp;ddi-compliant&nbsp;stuff&nbsp;*/
/*&nbsp;Some&nbsp;constants&nbsp;used&nbsp;throughout&nbsp;the&nbsp;driver&nbsp;*/
#define&nbsp;CDEV_MAX_XFERSIZE&nbsp;65536
#define&nbsp;VALID_DEVICE&nbsp;0x0acedeed
/*&nbsp;The&nbsp;following&nbsp;structure&nbsp;is&nbsp;provided&nbsp;so&nbsp;that&nbsp;we&nbsp;can&nbsp;memory&nbsp;map&nbsp;the
&nbsp;*&nbsp;device's&nbsp;control&nbsp;registers.&nbsp;&nbsp;For&nbsp;purposes&nbsp;of&nbsp;illustration,&nbsp;we&nbsp;
&nbsp;*&nbsp;provide&nbsp;a&nbsp;couple&nbsp;of&nbsp;generic&nbsp;registers;&nbsp;a&nbsp;real&nbsp;device&nbsp;would&nbsp;have
&nbsp;*&nbsp;completely&nbsp;different&nbsp;mappings.
&nbsp;*/
#define&nbsp;CMD_READ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x1
#define&nbsp;CMD_WRITE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x2
#define&nbsp;CMD_CLEAR_INTR&nbsp;&nbsp;0x4
#define&nbsp;CMD_RESET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x8
typedef&nbsp;struct&nbsp;deviceregs_s&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;volatile&nbsp;unsigned&nbsp;short&nbsp;&nbsp;cr_status;&nbsp;/*&nbsp;The&nbsp;device's&nbsp;status&nbsp;register&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;volatile&nbsp;unsigned&nbsp;short&nbsp;&nbsp;cr_cmd;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;The&nbsp;device's&nbsp;command&nbsp;register&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;volatile&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;cr_dmaaddr;/*&nbsp;The&nbsp;DMA&nbsp;address&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;volatile&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;cr_count;&nbsp;&nbsp;/*&nbsp;The&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;xfer&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;volatile&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;cr_devid;&nbsp;&nbsp;/*&nbsp;The&nbsp;device&nbsp;ID&nbsp;register&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;volatile&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;cr_parm;&nbsp;&nbsp;&nbsp;/*&nbsp;A&nbsp;device&nbsp;parameter&nbsp;*/
}&nbsp;deviceregs_t;
/*&nbsp;The&nbsp;cdevboard&nbsp;structure&nbsp;contains&nbsp;about&nbsp;a&nbsp;device&nbsp;which&nbsp;the
&nbsp;*&nbsp;driver&nbsp;needs&nbsp;to&nbsp;maintain.&nbsp;&nbsp;In&nbsp;general,&nbsp;each&nbsp;instance&nbsp;of&nbsp;a
&nbsp;*&nbsp;device&nbsp;in&nbsp;the&nbsp;system&nbsp;has&nbsp;an&nbsp;associated&nbsp;cdevboard&nbsp;structure
&nbsp;*&nbsp;which&nbsp;contains&nbsp;driver-specific&nbsp;information&nbsp;about&nbsp;that&nbsp;board.
&nbsp;*/
#define&nbsp;STATUS_PRESENT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x1
#define&nbsp;STATUS_OPEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x2
#define&nbsp;STATUS_INTRPENDING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x4
#define&nbsp;STATUS_TIMEOUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x8
#define&nbsp;FLAG_SET(_x,&nbsp;_y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(((_x)->cd_status)&nbsp;|=&nbsp;(_y))
#define&nbsp;FLAG_CLEAR(_x,&nbsp;_y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(((_x)->cd_status)&nbsp;&amp;=&nbsp;(~(_y)))
#define&nbsp;FLAG_TEST(_x,&nbsp;_y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(((_x)->cd_status)&nbsp;&amp;&nbsp;(_y))
typedef&nbsp;struct&nbsp;cdevboard_s&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;lock_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cd_lock;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Used&nbsp;for&nbsp;mutual&nbsp;exclusion&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;sema_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cd_rwsema;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Prevents&nbsp;simult.&nbsp;read&nbsp;&amp;&nbsp;write&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;volatile&nbsp;deviceregs_t&nbsp;*cd_regs;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Memory-mapped&nbsp;control&nbsp;regs&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;dmamap_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*cd_map;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;DMA&nbsp;Map&nbsp;for&nbsp;this&nbsp;device&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cd_ctlr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;The&nbsp;controller&nbsp;#&nbsp;of&nbsp;this&nbsp;device&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cd_status;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;The&nbsp;board's&nbsp;status.&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cd_strayintr;&nbsp;&nbsp;&nbsp;/*&nbsp;Counts&nbsp;stray&nbsp;interrupts&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;buf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*cd_buf;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Pointer&nbsp;to&nbsp;buffer&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cd_count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Count&nbsp;of&nbsp;bytes&nbsp;being&nbsp;transferred&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;toid_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cd_tout;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Timeout&nbsp;handle&nbsp;*/
}&nbsp;cdevboard_t;
/*&nbsp;We&nbsp;need&nbsp;to&nbsp;tell&nbsp;the&nbsp;kernel&nbsp;what&nbsp;kind&nbsp;of&nbsp;interface&nbsp;this&nbsp;driver
&nbsp;*&nbsp;expects.&nbsp;&nbsp;For&nbsp;a&nbsp;simple,&nbsp;non-MP&nbsp;driver,&nbsp;the&nbsp;devflag&nbsp;can&nbsp;be&nbsp;set&nbsp;to
&nbsp;*&nbsp;0.&nbsp;&nbsp;Since&nbsp;we're&nbsp;going&nbsp;to&nbsp;be&nbsp;a&nbsp;little&nbsp;more&nbsp;ambitious,&nbsp;we'll&nbsp;tell
&nbsp;*&nbsp;the&nbsp;kernel&nbsp;that&nbsp;we&nbsp;are&nbsp;capable&nbsp;of&nbsp;running&nbsp;MP.
&nbsp;*/
int&nbsp;cdev_devflag&nbsp;=&nbsp;D_MP;
/*&nbsp;Forward&nbsp;declarations&nbsp;of&nbsp;general&nbsp;driver&nbsp;functions&nbsp;*/
int&nbsp;&nbsp;cdev_intr(int&nbsp;board);
int&nbsp;&nbsp;cdev_strategy(struct&nbsp;buf&nbsp;*bp);
void&nbsp;cdev_timeout(cdevboard_t&nbsp;*board);
/*&nbsp;Driver&nbsp;global&nbsp;data&nbsp;structures;&nbsp;to&nbsp;minimize&nbsp;memory&nbsp;use,&nbsp;we&nbsp;create
&nbsp;*&nbsp;an&nbsp;array&nbsp;of&nbsp;pointers&nbsp;to&nbsp;audioboard&nbsp;structures&nbsp;and&nbsp;only&nbsp;allocate&nbsp;the
&nbsp;*&nbsp;actual&nbsp;structure&nbsp;if&nbsp;the&nbsp;corresponding&nbsp;board&nbsp;is&nbsp;configured.&nbsp;
&nbsp;*/
#define&nbsp;CDEV_MAX_BOARDS&nbsp;4
static&nbsp;cdevboard_t&nbsp;*CDevBoards[CDEV_MAX_BOARDS&nbsp;+&nbsp;1];
#if&nbsp;DEBUG
#define&nbsp;DPRINTF(_x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;debug_printf&nbsp;_x
void&nbsp;debug_printf(char&nbsp;*fmt,&nbsp;...)
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;va_list&nbsp;ap;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extern&nbsp;void&nbsp;icmn_err();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;va_start(ap,&nbsp;fmt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;icmn_err(CE_NOTE,&nbsp;fmt,&nbsp;ap);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;va_end(ap);
}
#else
#define&nbsp;DPRINTF(_x)&nbsp;
#endif
&nbsp;
/************************************************************************
&nbsp;*&nbsp;edtinit&nbsp;is&nbsp;the&nbsp;first&nbsp;routine&nbsp;all&nbsp;VME&nbsp;drivers&nbsp;need&nbsp;to&nbsp;provide.
&nbsp;*&nbsp;This&nbsp;function&nbsp;is&nbsp;called&nbsp;early&nbsp;during&nbsp;kernel&nbsp;initialization,&nbsp;and
&nbsp;*&nbsp;drivers&nbsp;generally&nbsp;use&nbsp;it&nbsp;to&nbsp;set&nbsp;up&nbsp;driver-global&nbsp;data&nbsp;structures
&nbsp;*&nbsp;and&nbsp;device&nbsp;mappings&nbsp;for&nbsp;any&nbsp;devices&nbsp;which&nbsp;exist.&nbsp;&nbsp;The&nbsp;kernel&nbsp;calls
&nbsp;*&nbsp;it&nbsp;once&nbsp;for&nbsp;each&nbsp;VECTOR&nbsp;line&nbsp;in&nbsp;the&nbsp;appropriate&nbsp;.sm&nbsp;file.&nbsp;
&nbsp;*/
void
cdev_edtinit(struct&nbsp;edt&nbsp;*e)
{
&nbsp;&nbsp;&nbsp;&nbsp;piomap_t&nbsp;*piomap;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Control&nbsp;register&nbsp;mapping&nbsp;descriptor&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;dmamap_t&nbsp;*dmamap;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;DMA&nbsp;mapping&nbsp;for&nbsp;read/write&nbsp;buffers&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;volatile&nbsp;deviceregs_t&nbsp;*base;&nbsp;&nbsp;&nbsp;/*&nbsp;Base&nbsp;address&nbsp;of&nbsp;device's&nbsp;control&nbsp;regs&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;vme_intrs_t&nbsp;*intrs;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Pointer&nbsp;to&nbsp;VME&nbsp;interrupt&nbsp;information&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;intr_vec;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Actual&nbsp;vector&nbsp;to&nbsp;use&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ctlr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Board&nbsp;number&nbsp;to&nbsp;be&nbsp;configured&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;cdevboard_t&nbsp;*board;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;New&nbsp;board&nbsp;data&nbsp;structure&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Make&nbsp;sure&nbsp;that&nbsp;the&nbsp;the&nbsp;controller&nbsp;number&nbsp;is&nbsp;within&nbsp;range&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;ctlr&nbsp;=&nbsp;e->e_ctlr;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ctlr&nbsp;&lt;&nbsp;0&nbsp;||&nbsp;ctlr&nbsp;>&nbsp;CDEV_MAX_BOARDS)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err(CE_WARN,&nbsp;&ldquo;cdev%d:&nbsp;controller&nbsp;number&nbsp;is&nbsp;invalid&rdquo;,&nbsp;ctlr);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Allocate&nbsp;a&nbsp;programmed&nbsp;I/O&nbsp;mapping&nbsp;structure&nbsp;for&nbsp;the&nbsp;particular&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;device.&nbsp;&nbsp;The&nbsp;kernel&nbsp;uses&nbsp;the&nbsp;data&nbsp;in&nbsp;the&nbsp;e_space&nbsp;field&nbsp;to&nbsp;figure
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;out&nbsp;both&nbsp;the&nbsp;VME&nbsp;base&nbsp;address&nbsp;and&nbsp;the&nbsp;total&nbsp;size&nbsp;of&nbsp;the&nbsp;register&nbsp;area.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;piomap&nbsp;=&nbsp;pio_mapalloc(e->e_bus_type,&nbsp;e->e_adap,&nbsp;e->e_space,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PIOMAP_FIXED,&nbsp;&ldquo;cdev&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;XXX&nbsp;Check&nbsp;for&nbsp;the&nbsp;success&nbsp;of&nbsp;piomap&nbsp;allocation&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(piomap&nbsp;==&nbsp;(piomap_t&nbsp;*)NULL){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err(CE_WARN,&nbsp;&ldquo;cdev%d:&nbsp;Could&nbsp;not&nbsp;allocate&nbsp;piomap&rdquo;,&nbsp;ctlr);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Now&nbsp;that&nbsp;the&nbsp;map&nbsp;is&nbsp;allocated,&nbsp;we&nbsp;position&nbsp;it&nbsp;so&nbsp;that&nbsp;it&nbsp;overlays
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;the&nbsp;device's&nbsp;hardware&nbsp;registers.&nbsp;&nbsp;Since&nbsp;this&nbsp;is&nbsp;a&nbsp;fixed&nbsp;map,&nbsp;we
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;just&nbsp;pass&nbsp;in&nbsp;the&nbsp;base&nbsp;address&nbsp;of&nbsp;the&nbsp;control&nbsp;register&nbsp;range.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;iobase&nbsp;comes&nbsp;from&nbsp;the&nbsp;VECTOR&nbsp;line&nbsp;in&nbsp;the&nbsp;.sm&nbsp;file.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;base&nbsp;=&nbsp;(volatile&nbsp;deviceregs_t*)&nbsp;pio_mapaddr(piomap,&nbsp;e->e_iobase);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;We're&nbsp;going&nbsp;to&nbsp;need&nbsp;to&nbsp;DMA&nbsp;map&nbsp;the&nbsp;user's&nbsp;buffer&nbsp;during&nbsp;read&nbsp;and
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;write&nbsp;requests,&nbsp;so&nbsp;we&nbsp;preallocate&nbsp;a&nbsp;fixed&nbsp;number&nbsp;of&nbsp;dma&nbsp;mapping
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;entries&nbsp;based&nbsp;on&nbsp;the&nbsp;constant&nbsp;CDEV_MAX_XFERSIZE.&nbsp;&nbsp;If&nbsp;we&nbsp;allowed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;multiple&nbsp;users&nbsp;to&nbsp;perform&nbsp;reads&nbsp;and&nbsp;writes&nbsp;simultaneously&nbsp;we'd
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;probably&nbsp;want&nbsp;to&nbsp;allocate&nbsp;one&nbsp;map&nbsp;for&nbsp;reads&nbsp;and&nbsp;one&nbsp;for&nbsp;writes.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Since&nbsp;we&nbsp;only&nbsp;allow&nbsp;one&nbsp;operation&nbsp;to&nbsp;occur&nbsp;at&nbsp;any&nbsp;given&nbsp;time,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;though,&nbsp;we&nbsp;can&nbsp;get&nbsp;away&nbsp;with&nbsp;only&nbsp;one.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;IMPORTANT&nbsp;NOTE:&nbsp;There&nbsp;are&nbsp;only&nbsp;a&nbsp;limited&nbsp;number&nbsp;of&nbsp;dma&nbsp;mapping
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;registers&nbsp;available&nbsp;in&nbsp;a&nbsp;system;&nbsp;you&nbsp;should&nbsp;be&nbsp;somewhat&nbsp;conservative
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;in&nbsp;your&nbsp;use&nbsp;of&nbsp;them.&nbsp;&nbsp;It&nbsp;is&nbsp;reasonable&nbsp;to&nbsp;consume&nbsp;up&nbsp;to&nbsp;100&nbsp;per&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;device&nbsp;(you&nbsp;can&nbsp;use&nbsp;more&nbsp;if&nbsp;you&nbsp;expect&nbsp;that&nbsp;only&nbsp;a&nbsp;couple&nbsp;devices
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;will&nbsp;be&nbsp;attached&nbsp;for&nbsp;each&nbsp;driver.&nbsp;&nbsp;If,&nbsp;for&nbsp;example,&nbsp;this&nbsp;driver
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;will&nbsp;never&nbsp;control&nbsp;more&nbsp;than&nbsp;two&nbsp;devices,&nbsp;you&nbsp;could&nbsp;probably&nbsp;use
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;up&nbsp;to&nbsp;512&nbsp;mapping&nbsp;registers&nbsp;for&nbsp;each&nbsp;device.&nbsp;&nbsp;If&nbsp;however,&nbsp;you'd&nbsp;expect
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;to&nbsp;see&nbsp;hundreds&nbsp;of&nbsp;devices,&nbsp;you'd&nbsp;need&nbsp;to&nbsp;be&nbsp;more&nbsp;conservative.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;dmamap&nbsp;=&nbsp;dma_mapalloc(DMA_A24VME,&nbsp;e->e_adap,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;io_btoc(CDEV_MAX_XFERSIZE)&nbsp;+&nbsp;1,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(dmamap&nbsp;==&nbsp;(dmamap_t*)&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err(CE_WARN,&nbsp;&ldquo;cdev%d:&nbsp;Could&nbsp;not&nbsp;allocate&nbsp;dmamaps&rdquo;,&nbsp;ctlr);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pio_mapfree(piomap);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;The&nbsp;next&nbsp;step&nbsp;would&nbsp;be&nbsp;to&nbsp;probe&nbsp;the&nbsp;device&nbsp;to&nbsp;determine&nbsp;whether
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;it&nbsp;is&nbsp;actually&nbsp;present.&nbsp;&nbsp;To&nbsp;do&nbsp;this,&nbsp;we&nbsp;attempt&nbsp;to&nbsp;read&nbsp;some
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;registers&nbsp;which&nbsp;behave&nbsp;in&nbsp;a&nbsp;manner&nbsp;unique&nbsp;to&nbsp;this&nbsp;particular
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;hardware.&nbsp;&nbsp;We&nbsp;need&nbsp;to&nbsp;protect&nbsp;ourselves&nbsp;in&nbsp;the&nbsp;event&nbsp;that&nbsp;the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;device&nbsp;isn't&nbsp;actually&nbsp;present,&nbsp;however,&nbsp;so&nbsp;we&nbsp;use&nbsp;the&nbsp;badaddr
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;and&nbsp;wbadaddr&nbsp;routines.&nbsp;&nbsp;For&nbsp;our&nbsp;example,&nbsp;we&nbsp;assume&nbsp;that&nbsp;the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;device&nbsp;is&nbsp;present&nbsp;if&nbsp;it's&nbsp;device
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((badaddr(&amp;(base->cr_devid),&nbsp;4)&nbsp;==&nbsp;0)&nbsp;&amp;&amp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(base->cr_devid&nbsp;==&nbsp;VALID_DEVICE))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DPRINTF((&ldquo;cdev%d:&nbsp;found&nbsp;valid&nbsp;device&rdquo;,&nbsp;ctlr));
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;It&nbsp;doesn't&nbsp;look&nbsp;like&nbsp;the&nbsp;device&nbsp;is&nbsp;there.&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err(CE_WARN,&nbsp;&ldquo;cdev%d:&nbsp;cannot&nbsp;find&nbsp;actual&nbsp;device&rdquo;,&nbsp;ctlr);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pio_mapfree(piomap);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dma_mapfree(dmamap);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Now&nbsp;we&nbsp;set&nbsp;up&nbsp;the&nbsp;interrupt&nbsp;for&nbsp;this&nbsp;device.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;It&nbsp;is&nbsp;possible&nbsp;to&nbsp;specify&nbsp;a&nbsp;vector&nbsp;and&nbsp;priority&nbsp;level&nbsp;on&nbsp;the&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;VECTOR&nbsp;line&nbsp;in&nbsp;the&nbsp;.sm&nbsp;file,&nbsp;so&nbsp;we&nbsp;check&nbsp;to&nbsp;see&nbsp;if&nbsp;such&nbsp;was&nbsp;the&nbsp;case.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;intrs&nbsp;=&nbsp;(vme_intrs_t*)&nbsp;e->e_bus_info;
&nbsp;&nbsp;&nbsp;&nbsp;intr_vec&nbsp;=&nbsp;intrs->v_vec;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;If&nbsp;intr_vec&nbsp;is&nbsp;non-zero,&nbsp;user&nbsp;specified&nbsp;specific&nbsp;vec&nbsp;in&nbsp;.sm&nbsp;file.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;If&nbsp;the&nbsp;interrupt&nbsp;was&nbsp;specified&nbsp;on&nbsp;the&nbsp;VECTOR&nbsp;line,&nbsp;the&nbsp;kernel&nbsp;has
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;already&nbsp;established&nbsp;a&nbsp;vector&nbsp;for&nbsp;us,&nbsp;so&nbsp;we&nbsp;don't&nbsp;need&nbsp;to&nbsp;do&nbsp;it
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;ourselves.&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(intr_vec&nbsp;==&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intr_vec&nbsp;=&nbsp;vme_ivec_alloc(e->e_adap);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Make&nbsp;sure&nbsp;that&nbsp;we&nbsp;got&nbsp;a&nbsp;good&nbsp;interrupt&nbsp;vector&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(intr_vec&nbsp;==&nbsp;-1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err(CE_WARN,&nbsp;&ldquo;cdev%d:&nbsp;could&nbsp;not&nbsp;allocate&nbsp;intr&nbsp;vector\n&rdquo;,&nbsp;ctlr);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pio_mapfree(piomap);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dma_mapfree(dmamap);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Associate&nbsp;this&nbsp;driver's&nbsp;interrupt&nbsp;routine&nbsp;with&nbsp;the&nbsp;acquired&nbsp;vec&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vme_ivec_set(e->e_adap,&nbsp;intr_vec,&nbsp;cdev_intr,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Initialize&nbsp;the&nbsp;board&nbsp;structure&nbsp;for&nbsp;this&nbsp;board&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;board&nbsp;=&nbsp;(cdevboard_t*)&nbsp;kmem_alloc(sizeof(cdevboard_t));
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(board&nbsp;==&nbsp;(void*)&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err(CE_WARN,&nbsp;&ldquo;cdev%d:&nbsp;kmem_alloc&nbsp;failed&rdquo;,&nbsp;ctlr);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pio_mapfree(piomap);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dma_mapfree(dmamap);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;XXX&nbsp;Need&nbsp;to&nbsp;check&nbsp;whether&nbsp;it&nbsp;is&nbsp;allocated??&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vme_ivec_free(e->e_adap,&nbsp;intr_vec);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;board&nbsp;=&nbsp;CDevBoards[ctlr];
&nbsp;&nbsp;&nbsp;&nbsp;board->cd_regs&nbsp;=&nbsp;base;
&nbsp;&nbsp;&nbsp;&nbsp;board->cd_ctlr&nbsp;=&nbsp;ctlr;
&nbsp;&nbsp;&nbsp;&nbsp;board->cd_status&nbsp;=&nbsp;STATUS_PRESENT;
&nbsp;&nbsp;&nbsp;&nbsp;board->cd_strayintr&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;board->cd_map&nbsp;=&nbsp;dmamap;
&nbsp;&nbsp;&nbsp;&nbsp;initnsema(&amp;board->cd_rwsema,&nbsp;1,&nbsp;&ldquo;CDevRWM&rdquo;);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Finally,&nbsp;call&nbsp;any&nbsp;one-time-only&nbsp;device&nbsp;initialization&nbsp;routines;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;this&nbsp;particular&nbsp;device&nbsp;doesn't&nbsp;have&nbsp;any.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;return;
}
/************************************************************************
&nbsp;*&nbsp;cdev_open&nbsp;--&nbsp;When&nbsp;opening&nbsp;a&nbsp;device,&nbsp;we&nbsp;need&nbsp;to&nbsp;check&nbsp;for&nbsp;mutual
&nbsp;*&nbsp;exclusion&nbsp;(if&nbsp;desired)&nbsp;and&nbsp;then&nbsp;set&nbsp;up&nbsp;an&nbsp;additional&nbsp;data&nbsp;structures
&nbsp;*&nbsp;if&nbsp;this&nbsp;is&nbsp;the&nbsp;first&nbsp;time&nbsp;the&nbsp;device&nbsp;has&nbsp;been&nbsp;opened.&nbsp;&nbsp;Remember&nbsp;that
&nbsp;*&nbsp;the&nbsp;OS&nbsp;usually&nbsp;doesn't&nbsp;call&nbsp;close&nbsp;until&nbsp;all&nbsp;users&nbsp;close&nbsp;the&nbsp;device,
&nbsp;*&nbsp;so&nbsp;you&nbsp;can't&nbsp;count&nbsp;on&nbsp;being&nbsp;able&nbsp;to&nbsp;set&nbsp;up&nbsp;unique&nbsp;data&nbsp;for&nbsp;each&nbsp;user
&nbsp;*&nbsp;of&nbsp;the&nbsp;device&nbsp;unless&nbsp;you&nbsp;either&nbsp;disallow&nbsp;multiple&nbsp;opens&nbsp;at&nbsp;the&nbsp;same&nbsp;time
&nbsp;*&nbsp;or&nbsp;mark&nbsp;the&nbsp;device&nbsp;as&nbsp;being&nbsp;a&nbsp;layered&nbsp;(otype&nbsp;=&nbsp;O_LYR)&nbsp;device.
&nbsp;*/
int
cdev_open(dev_t&nbsp;*dev,&nbsp;int&nbsp;flag,&nbsp;int&nbsp;otyp,&nbsp;cred_t&nbsp;*cred)
{
&nbsp;&nbsp;&nbsp;&nbsp;minor_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctlr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Controller&nbsp;#&nbsp;of&nbsp;cdev&nbsp;being&nbsp;opened&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;cdevboard_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*board;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;per-board&nbsp;data&nbsp;for&nbsp;opened&nbsp;cdev*/
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Opaque&nbsp;lock&nbsp;value&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;We&nbsp;assume&nbsp;that&nbsp;the&nbsp;minor&nbsp;number&nbsp;encodes&nbsp;the&nbsp;ctlr&nbsp;number,&nbsp;so
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;we&nbsp;just&nbsp;go&nbsp;ahead&nbsp;and&nbsp;use&nbsp;it&nbsp;to&nbsp;index&nbsp;the&nbsp;CDevBoards&nbsp;array&nbsp;once
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;we've&nbsp;validated&nbsp;it.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;ctlr&nbsp;=&nbsp;geteminor(*dev);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ctlr&nbsp;>&nbsp;CDEV_MAX_BOARDS)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DPRINTF((&ldquo;cdev%d:&nbsp;open:&nbsp;minor&nbsp;number&nbsp;out&nbsp;of&nbsp;range&rdquo;,&nbsp;ctlr));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ENXIO;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;board&nbsp;=&nbsp;CDevBoards[ctlr];
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(FLAG_TEST(board,&nbsp;STATUS_PRESENT)&nbsp;||&nbsp;(board->cd_ctlr&nbsp;!=&nbsp;ctlr))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DPRINTF((&ldquo;cdev%d:&nbsp;open:&nbsp;device&nbsp;not&nbsp;found&rdquo;,&nbsp;ctlr));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ENXIO;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;If&nbsp;exclusiveness&nbsp;is&nbsp;desired,&nbsp;we&nbsp;now&nbsp;need&nbsp;to&nbsp;atomically&nbsp;insure&nbsp;that
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;we&nbsp;are&nbsp;the&nbsp;owners&nbsp;of&nbsp;the&nbsp;device.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;LOCK(&amp;board->cd_lock,&nbsp;splhi);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(FLAG_TEST(board,&nbsp;STATUS_OPEN))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(&amp;board->cd_lock,&nbsp;s);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;EBUSY;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ASSERT(board->cd_status&nbsp;==&nbsp;STATUS_PRESENT);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FLAG_SET(board,&nbsp;STATUS_OPEN);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(&amp;board->cd_lock,&nbsp;s);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
&nbsp;
/************************************************************************
&nbsp;*&nbsp;cdev_close&nbsp;--&nbsp;Called&nbsp;when&nbsp;the&nbsp;open&nbsp;reference&nbsp;count&nbsp;drops&nbsp;to&nbsp;zero.
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cleans&nbsp;up&nbsp;any&nbsp;leftover&nbsp;data&nbsp;structure&nbsp;and&nbsp;marks&nbsp;the&nbsp;device&nbsp;as&nbsp;
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;available.&nbsp;&nbsp;
&nbsp;*/
int&nbsp;
cdev_close(dev_t&nbsp;dev,&nbsp;int&nbsp;flag,&nbsp;int&nbsp;otyp,&nbsp;cred_t&nbsp;*cred)
{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctlr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Controller&nbsp;#&nbsp;of&nbsp;dev&nbsp;being&nbsp;closed&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;cdevboard_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*board;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;per-board&nbsp;data&nbsp;structure&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;ctlr&nbsp;=&nbsp;geteminor(dev);
&nbsp;&nbsp;&nbsp;&nbsp;ASSERT(ctlr&nbsp;&lt;=&nbsp;CDEV_MAX_BOARDS);
&nbsp;&nbsp;&nbsp;&nbsp;board&nbsp;=&nbsp;CDevBoards[ctlr];
&nbsp;&nbsp;&nbsp;&nbsp;ASSERT(board&nbsp;&amp;&amp;&nbsp;FLAG_TEST(board,&nbsp;STATUS_OPEN|STATUS_PRESENT));
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Do&nbsp;any&nbsp;cleanup&nbsp;required&nbsp;here&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Reset&nbsp;the&nbsp;board's&nbsp;status&nbsp;flags&nbsp;(to&nbsp;clear&nbsp;the&nbsp;OPEN&nbsp;flag)&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;FLAG_CLEAR(board,&nbsp;STATUS_OPEN);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
/************************************************************************
&nbsp;*&nbsp;cdev_intr&nbsp;--&nbsp;Called&nbsp;when&nbsp;an&nbsp;interrupt&nbsp;occurs.&nbsp;&nbsp;We&nbsp;check&nbsp;to&nbsp;see&nbsp;if&nbsp;
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;process&nbsp;was&nbsp;waiting&nbsp;for&nbsp;an&nbsp;I/O&nbsp;operation&nbsp;to&nbsp;complete&nbsp;and&nbsp;
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;re-activate&nbsp;that&nbsp;process&nbsp;if&nbsp;such&nbsp;is&nbsp;the&nbsp;case.&nbsp;&nbsp;
&nbsp;*/
#ifdef EVEREST /* IO4 fix for Challenge */
extern int io4_flush_cache(caddr_t piomap);
#endif
int
cdev_intr(int&nbsp;ctlr)
{
&nbsp;&nbsp;&nbsp;&nbsp;cdevboard_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*board;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;per-board&nbsp;data&nbsp;structure&nbsp;pointer&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;s;&nbsp;&nbsp;/*&nbsp;lock&nbsp;return&nbsp;value&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Make&nbsp;sure&nbsp;that&nbsp;the&nbsp;controller&nbsp;value&nbsp;is&nbsp;legitimate&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;ASSERT(ctlr&nbsp;&lt;=&nbsp;CDEV_MAX_BOARDS);
&nbsp;&nbsp;&nbsp;&nbsp;board&nbsp;=&nbsp;CDevBoards[ctlr];
&nbsp;&nbsp;&nbsp;&nbsp;ASSERT(board&nbsp;&amp;&amp;&nbsp;FLAG_TEST(board,&nbsp;STATUS_PRESENT));
#ifdef EVEREST /* flush IO4 cache */
&nbsp;&nbsp;&nbsp;&nbsp;(void)io4_flush_cache((caddr_t)board->cd_regs);
#endif
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Get&nbsp;exclusive&nbsp;use&nbsp;of&nbsp;the&nbsp;board.&nbsp;This&nbsp;ensures&nbsp;that&nbsp;the&nbsp;strategy
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;routine&nbsp;is&nbsp;completely&nbsp;finished&nbsp;setting&nbsp;STATUS_INTRPENDING&nbsp;before
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;we&nbsp;examine&nbsp;it.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;LOCK(&amp;board->cd_lock,&nbsp;splhi);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;It's&nbsp;possible&nbsp;that&nbsp;we&nbsp;could&nbsp;get&nbsp;a&nbsp;stray&nbsp;interrupt&nbsp;if&nbsp;the&nbsp;hardware
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;is&nbsp;flaky,&nbsp;so&nbsp;we&nbsp;keep&nbsp;a&nbsp;count&nbsp;of&nbsp;bogus&nbsp;interrupts&nbsp;and&nbsp;ignore&nbsp;them.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(FLAG_TEST(board,&nbsp;STATUS_OPEN|STATUS_INTRPENDING))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board->cd_strayintr++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Acknowledge&nbsp;the&nbsp;interrupt&nbsp;from&nbsp;the&nbsp;device&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;board->cd_regs->cr_cmd&nbsp;=&nbsp;CMD_CLEAR_INTR;
&nbsp;&nbsp;&nbsp;&nbsp;FLAG_CLEAR(board,&nbsp;STATUS_INTRPENDING);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Remove&nbsp;the&nbsp;timeout&nbsp;request&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;untimeout(board->cd_tout);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Update&nbsp;the&nbsp;buffer's&nbsp;parameters&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;ASSERT(board->cd_buf->b_bcount&nbsp;>&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;board->cd_buf->b_bcount&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-=&nbsp;board->cd_count;
&nbsp;&nbsp;&nbsp;&nbsp;board->cd_buf->b_dmaaddr&nbsp;&nbsp;&nbsp;&nbsp;+=&nbsp;board->cd_count;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Release&nbsp;the&nbsp;mutual&nbsp;exclusion&nbsp;on&nbsp;the&nbsp;board.&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(&amp;board->cd_lock,s);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;If&nbsp;the&nbsp;transfer&nbsp;count&nbsp;is&nbsp;0,&nbsp;then&nbsp;we've&nbsp;transferred&nbsp;all&nbsp;of&nbsp;the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;bytes&nbsp;in&nbsp;the&nbsp;request,&nbsp;so&nbsp;we&nbsp;call&nbsp;iodone&nbsp;to&nbsp;awaken&nbsp;the&nbsp;user&nbsp;process.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Otherwise,&nbsp;we&nbsp;call&nbsp;cdev_strat&nbsp;to&nbsp;initiate&nbsp;another&nbsp;transfer.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(board->cd_buf->b_bcount&nbsp;==&nbsp;0)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iodone(board->cd_buf);
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cdev_strategy(board->cd_buf);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
/************************************************************************
&nbsp;*&nbsp;cdev_read&nbsp;--&nbsp;reads&nbsp;data&nbsp;from&nbsp;the&nbsp;device.&nbsp;&nbsp;We&nbsp;employ&nbsp;the&nbsp;uiophysio&nbsp;
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;routine&nbsp;to&nbsp;perform&nbsp;all&nbsp;the&nbsp;requisite&nbsp;mapping&nbsp;of&nbsp;the&nbsp;buffer
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;us&nbsp;and&nbsp;then&nbsp;call&nbsp;the&nbsp;cdev_strat&nbsp;routine.&nbsp;&nbsp;The&nbsp;big&nbsp;advantage
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;uiophysio()&nbsp;is&nbsp;that&nbsp;it&nbsp;sets&nbsp;up&nbsp;memory&nbsp;such&nbsp;that&nbsp;the&nbsp;device&nbsp;can
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMA&nbsp;directly&nbsp;into&nbsp;the&nbsp;user&nbsp;address&nbsp;space.&nbsp;&nbsp;The&nbsp;strategy&nbsp;routine
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;responsible&nbsp;for&nbsp;actually&nbsp;setting&nbsp;up&nbsp;and&nbsp;initiating&nbsp;the&nbsp;transfer.
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;process&nbsp;will&nbsp;block&nbsp;in&nbsp;uiophysio&nbsp;until&nbsp;the&nbsp;interrupt&nbsp;handler
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calls&nbsp;iodone()&nbsp;on&nbsp;buffer&nbsp;pointer.
&nbsp;*/
int
cdev_read(dev_t&nbsp;dev,&nbsp;uio_t&nbsp;*uio,&nbsp;cred_t&nbsp;*cred)
{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctlr;
&nbsp;&nbsp;&nbsp;&nbsp;cdevboard_t&nbsp;*board;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;ASSERT(ctlr&nbsp;>=&nbsp;0&nbsp;&amp;&amp;&nbsp;ctlr&nbsp;&lt;=&nbsp;CDEV_MAX_BOARDS);
&nbsp;&nbsp;&nbsp;&nbsp;ctlr&nbsp;=&nbsp;geteminor(ctlr);
&nbsp;&nbsp;&nbsp;&nbsp;ASSERT(board&nbsp;&amp;&amp;&nbsp;FLAG_TEST(board,&nbsp;STATUS_OPEN|STATUS_PRESENT));
&nbsp;&nbsp;&nbsp;&nbsp;board&nbsp;=&nbsp;CDevBoards[ctlr];
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Since&nbsp;we&nbsp;allocated&nbsp;only&nbsp;a&nbsp;single&nbsp;DMA&nbsp;buffer,&nbsp;we&nbsp;need&nbsp;to&nbsp;block
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;if&nbsp;a&nbsp;previous&nbsp;transfer&nbsp;hasn't&nbsp;completed.&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;psema(&amp;board->cd_rwsema,&nbsp;PZERO+1);
&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;=&nbsp;uiophysio(cdev_strat,&nbsp;NULL,&nbsp;dev,&nbsp;B_READ,&nbsp;uio);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Check&nbsp;to&nbsp;see&nbsp;if&nbsp;the&nbsp;transfer&nbsp;timed&nbsp;out&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(FLAG_TEST(board,&nbsp;STATUS_TIMEOUT))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FLAG_CLEAR(board,&nbsp;STATUS_TIMEOUT);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;=&nbsp;EIO;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;vsema(&amp;board->cd_rwsema);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;error;
}
/************************************************************************
&nbsp;*&nbsp;cdev_write&nbsp;--&nbsp;writes&nbsp;data&nbsp;from&nbsp;a&nbsp;user&nbsp;buffer&nbsp;to&nbsp;the&nbsp;device.&nbsp;
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We&nbsp;employ&nbsp;the&nbsp;uiophysio&nbsp;routine&nbsp;to&nbsp;set&nbsp;up&nbsp;the&nbsp;mappings&nbsp;for&nbsp;us.
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Once&nbsp;the&nbsp;mappings&nbsp;are&nbsp;established,&nbsp;uiophysio&nbsp;will&nbsp;call&nbsp;the
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;given&nbsp;strategy&nbsp;routine&nbsp;(cdev_strat)&nbsp;with&nbsp;a&nbsp;buffer&nbsp;pointer.
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;strategy&nbsp;routine&nbsp;is&nbsp;then&nbsp;responsible&nbsp;for&nbsp;kicking&nbsp;off&nbsp;the
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transfer.&nbsp;&nbsp;The&nbsp;process&nbsp;will&nbsp;block&nbsp;in&nbsp;uiophysio&nbsp;until&nbsp;the&nbsp;
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interrupt&nbsp;handler&nbsp;calls&nbsp;iodone()&nbsp;on&nbsp;the&nbsp;buffer&nbsp;pointer.
&nbsp;*/
int
cdev_write(dev_t&nbsp;dev,&nbsp;uio_t&nbsp;*uio,&nbsp;cred_t&nbsp;*cred)
{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctlr;
&nbsp;&nbsp;&nbsp;&nbsp;cdevboard_t&nbsp;*board;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;ASSERT(ctlr&nbsp;>=&nbsp;0&nbsp;&amp;&amp;&nbsp;ctlr&nbsp;&lt;=&nbsp;CDEV_MAX_BOARDS);
&nbsp;&nbsp;&nbsp;&nbsp;ctlr&nbsp;=&nbsp;geteminor(ctlr);
&nbsp;&nbsp;&nbsp;&nbsp;ASSERT(board&nbsp;&amp;&amp;&nbsp;FLAG_TEST(board,&nbsp;STATUS_OPEN|STATUS_PRESENT));
&nbsp;&nbsp;&nbsp;&nbsp;board&nbsp;=&nbsp;CDevBoards[ctlr];
&nbsp;&nbsp;&nbsp;&nbsp;psema(&amp;board->cd_rwsema,&nbsp;PZERO+1);
&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;=&nbsp;uiophysio(cdev_strat,&nbsp;NULL,&nbsp;dev,&nbsp;B_WRITE,&nbsp;uio);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Check&nbsp;to&nbsp;see&nbsp;if&nbsp;the&nbsp;transfer&nbsp;timed&nbsp;out&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(FLAG_TEST(board,&nbsp;STATUS_TIMEOUT))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FLAG_CLEAR(board,&nbsp;STATUS_TIMEOUT);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;=&nbsp;EIO;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;vsema(&amp;board->cd_rwsema);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;error;
}
/************************************************************************
&nbsp;*&nbsp;cdev_strat&nbsp;--&nbsp;Called&nbsp;by&nbsp;uiophysio,&nbsp;cdev_strat&nbsp;actually&nbsp;performs&nbsp;all
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;device-specific&nbsp;actions&nbsp;needed&nbsp;to&nbsp;initiate&nbsp;the&nbsp;transfer,
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;such&nbsp;as&nbsp;establishing&nbsp;the&nbsp;DMA&nbsp;mapping&nbsp;of&nbsp;the&nbsp;transfer&nbsp;buffer&nbsp;and
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actually&nbsp;programming&nbsp;the&nbsp;device.&nbsp;&nbsp;There&nbsp;is&nbsp;an&nbsp;implicit&nbsp;assumption
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that&nbsp;the&nbsp;device&nbsp;will&nbsp;interrupt&nbsp;at&nbsp;some&nbsp;later&nbsp;point&nbsp;when&nbsp;the&nbsp;I/O
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;operation&nbsp;is&nbsp;complete.
&nbsp;*/
int&nbsp;
cdev_strategy(struct&nbsp;buf&nbsp;*bp)
{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ctlr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Controller&nbsp;#&nbsp;being&nbsp;accessed&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;cdevboard_t&nbsp;*board;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Board&nbsp;data&nbsp;structure&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;mapcount;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Count&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;opaque&nbsp;lock&nbsp;value&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Get&nbsp;a&nbsp;reference&nbsp;to&nbsp;the&nbsp;actual&nbsp;board&nbsp;structure&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;ctlr&nbsp;=&nbsp;geteminor(bp->b_edev);
&nbsp;&nbsp;&nbsp;&nbsp;ASSERT(ctlr&nbsp;>=&nbsp;0&nbsp;&amp;&amp;&nbsp;ctlr&nbsp;&lt;=&nbsp;CDEV_MAX_BOARDS);
&nbsp;&nbsp;&nbsp;&nbsp;board&nbsp;=&nbsp;CDevBoards[ctlr];
&nbsp;&nbsp;&nbsp;&nbsp;ASSERT(board&nbsp;&amp;&amp;&nbsp;FLAG_TEST(board,&nbsp;STATUS_OPEN|STATUS_PRESENT));
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;We&nbsp;start&nbsp;by&nbsp;mapping&nbsp;the&nbsp;appropriate&nbsp;region&nbsp;into&nbsp;VME&nbsp;address&nbsp;space.&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Because&nbsp;of&nbsp;the&nbsp;mapping&nbsp;registers&nbsp;we&nbsp;don't&nbsp;have&nbsp;to&nbsp;worry&nbsp;about&nbsp;the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;fact&nbsp;that&nbsp;the&nbsp;physical&nbsp;pages&nbsp;backing&nbsp;the&nbsp;data&nbsp;regions&nbsp;may&nbsp;be&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;physically&nbsp;discontinuous;&nbsp;in&nbsp;effect,&nbsp;the&nbsp;DMA&nbsp;mapping&nbsp;is&nbsp;taking&nbsp;the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;place&nbsp;of&nbsp;scatter/gather&nbsp;hardware.&nbsp;&nbsp;Nonetheless,&nbsp;in&nbsp;order&nbsp;to&nbsp;avoid
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;consuming&nbsp;an&nbsp;excessive&nbsp;number&nbsp;of&nbsp;translation&nbsp;entries&nbsp;we&nbsp;limit&nbsp;the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;size&nbsp;of&nbsp;the&nbsp;transfer&nbsp;to&nbsp;CDEV_MAX_XFERSIZE.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;mapcount&nbsp;=&nbsp;MIN(bp->b_bcount,&nbsp;CDEV_MAX_XFERSIZE);
&nbsp;&nbsp;&nbsp;&nbsp;mapcount&nbsp;=&nbsp;dma_map(board->cd_map,&nbsp;bp->b_dmaaddr,&nbsp;mapcount);
&nbsp;&nbsp;&nbsp;&nbsp;ASSERT(mapcount&nbsp;>&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Before&nbsp;starting&nbsp;the&nbsp;I/O,&nbsp;get&nbsp;exclusive&nbsp;use&nbsp;of&nbsp;the&nbsp;board&nbsp;struct.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;This&nbsp;ensures&nbsp;that,&nbsp;if&nbsp;this&nbsp;CPU&nbsp;is&nbsp;interrupted&nbsp;and&nbsp;we&nbsp;are&nbsp;slow&nbsp;to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;set&nbsp;STATUS_INTRPENDING,&nbsp;cdev_intr()&nbsp;will&nbsp;be&nbsp;locked&nbsp;out&nbsp;until&nbsp;we&nbsp;do.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;LOCK(&amp;board->cd_lock,&nbsp;splhi);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Now&nbsp;we&nbsp;start&nbsp;the&nbsp;transfer&nbsp;by&nbsp;writing&nbsp;into&nbsp;memory-mapped&nbsp;registers&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;board->cd_regs->cr_dmaaddr&nbsp;=&nbsp;dma_mapaddr(board->cd_map,&nbsp;bp->b_dmaaddr);
&nbsp;&nbsp;&nbsp;&nbsp;board->cd_regs->cr_count&nbsp;=&nbsp;mapcount;
&nbsp;&nbsp;&nbsp;&nbsp;board->cd_regs->cr_cmd&nbsp;=&nbsp;((bp->b_flags&nbsp;&amp;&nbsp;B_WRITE)&nbsp;?&nbsp;CMD_WRITE&nbsp;:&nbsp;CMD_READ);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Schedule&nbsp;a&nbsp;timeout,&nbsp;just&nbsp;in&nbsp;case&nbsp;the&nbsp;device&nbsp;decides&nbsp;to&nbsp;hang&nbsp;forever&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;itimeout(cdev_timeout,&nbsp;board,&nbsp;2000,&nbsp;splhi);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Finally,&nbsp;we&nbsp;update&nbsp;some&nbsp;of&nbsp;the&nbsp;board&nbsp;data&nbsp;structures&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;board->cd_buf&nbsp;&nbsp;&nbsp;=&nbsp;bp;
&nbsp;&nbsp;&nbsp;&nbsp;board->cd_count&nbsp;=&nbsp;mapcount;
&nbsp;&nbsp;&nbsp;&nbsp;FLAG_SET(board,&nbsp;STATUS_INTRPENDING);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Release&nbsp;the&nbsp;board&nbsp;struct,&nbsp;so&nbsp;the&nbsp;interrupt&nbsp;handler&nbsp;can&nbsp;use&nbsp;it.&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;UNLOCK(&amp;board->cd_lock,&nbsp;s);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Upon&nbsp;returning,&nbsp;uiophysio&nbsp;will&nbsp;block&nbsp;until&nbsp;cdev_intr&nbsp;calls&nbsp;iodone()&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
/************************************************************************
&nbsp;*&nbsp;cdev_ioctl&nbsp;--&nbsp;Not&nbsp;too&nbsp;exciting.&nbsp;&nbsp;We'll&nbsp;assume&nbsp;that&nbsp;the&nbsp;device&nbsp;has
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one&nbsp;controllable&nbsp;parameter&nbsp;which&nbsp;can&nbsp;be&nbsp;both&nbsp;written&nbsp;and&nbsp;received.
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To&nbsp;help&nbsp;users&nbsp;avoid&nbsp;errors,&nbsp;we&nbsp;use&nbsp;unusual&nbsp;constants&nbsp;for&nbsp;the&nbsp;ioctl
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;values.&nbsp;&nbsp;In&nbsp;a&nbsp;real&nbsp;driver,&nbsp;the&nbsp;CDIOC&nbsp;definitions&nbsp;would&nbsp;go&nbsp;into&nbsp;a
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header&nbsp;file.
&nbsp;*/
#define&nbsp;CDIOC_SETPARM&nbsp;&nbsp;&nbsp;0xcd01
#define&nbsp;CDIOC_GETPARM&nbsp;&nbsp;&nbsp;0xcd02
int
cdev_ioctl(dev_t&nbsp;dev,&nbsp;int&nbsp;cmd,&nbsp;int&nbsp;arg,&nbsp;int&nbsp;mode,&nbsp;cred_t&nbsp;*cred)
{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctlr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Controller&nbsp;number&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;cdevboard_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*board;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Per-controller&nbsp;data&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Error&nbsp;return&nbsp;value&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;ctlr&nbsp;=&nbsp;geteminor(dev);
&nbsp;&nbsp;&nbsp;&nbsp;ASSERT(ctlr&nbsp;>=&nbsp;0&nbsp;&amp;&amp;&nbsp;ctlr&nbsp;&lt;=&nbsp;CDEV_MAX_BOARDS);
&nbsp;&nbsp;&nbsp;&nbsp;board&nbsp;=&nbsp;CDevBoards[ctlr];
&nbsp;&nbsp;&nbsp;&nbsp;ASSERT(board&nbsp;&amp;&amp;&nbsp;FLAG_TEST(board,&nbsp;STATUS_OPEN|STATUS_PRESENT));
&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(cmd)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;CDIOC_SETPARM:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board->cd_regs->cr_parm&nbsp;=&nbsp;arg;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;CDIOC_GETPARM:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;value;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;=&nbsp;board->cd_regs->cr_parm;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(copyout(&amp;value,&nbsp;(void*)&nbsp;arg,&nbsp;sizeof(int)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;=&nbsp;EFAULT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;=&nbsp;EINVAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;error;
}
/************************************************************************
&nbsp;*&nbsp;cdev_timeout&nbsp;--&nbsp;If&nbsp;an&nbsp;I/O&nbsp;request&nbsp;takes&nbsp;a&nbsp;really&nbsp;long&nbsp;time&nbsp;to&nbsp;complete
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;some&nbsp;reason&nbsp;(if,&nbsp;for&nbsp;example,&nbsp;someone&nbsp;takes&nbsp;the&nbsp;device&nbsp;offline),
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it&nbsp;is&nbsp;better&nbsp;to&nbsp;warn&nbsp;the&nbsp;user&nbsp;than&nbsp;to&nbsp;simply&nbsp;hang.&nbsp;&nbsp;This&nbsp;timeout&nbsp;
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;routine&nbsp;will&nbsp;cancel&nbsp;any&nbsp;pending&nbsp;I/O&nbsp;requests&nbsp;and&nbsp;display&nbsp;a&nbsp;message.&nbsp;&nbsp;
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;more&nbsp;sophisticated&nbsp;routine&nbsp;might&nbsp;try&nbsp;resetting&nbsp;the&nbsp;device&nbsp;and&nbsp;
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;re-executing&nbsp;the&nbsp;operation.
&nbsp;*/
void
cdev_timeout(cdevboard_t&nbsp;*board)
{
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Clear&nbsp;the&nbsp;pending&nbsp;request&nbsp;from&nbsp;the&nbsp;device.&nbsp;&nbsp;This&nbsp;operation
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;is&nbsp;extremely&nbsp;dependent&nbsp;on&nbsp;the&nbsp;actual&nbsp;device.&nbsp;&nbsp;This&nbsp;driver
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;pretends&nbsp;that&nbsp;we&nbsp;simply&nbsp;can&nbsp;use&nbsp;the&nbsp;reset&nbsp;command.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;board->cd_regs->cr_cmd&nbsp;=&nbsp;CMD_RESET;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Make&nbsp;a&nbsp;note&nbsp;that&nbsp;the&nbsp;operation&nbsp;timed&nbsp;out&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;FLAG_SET(board,&nbsp;STATUS_TIMEOUT);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Display&nbsp;a&nbsp;warning&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;cmn_err(CE_WARN,&nbsp;&ldquo;cdev%d:&nbsp;device&nbsp;timed&nbsp;out&rdquo;,&nbsp;board->cd_ctlr);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Notify&nbsp;the&nbsp;user&nbsp;process&nbsp;that&nbsp;the&nbsp;operation&nbsp;has&nbsp;&ldquo;finished&rdquo;.&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;iodone(board->cd_buf);
}
/************************************************************************
&nbsp;*&nbsp;cdev_map&nbsp;--&nbsp;For&nbsp;illustrative&nbsp;purposes,&nbsp;we&nbsp;show&nbsp;how&nbsp;one&nbsp;would&nbsp;go&nbsp;about
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapping&nbsp;the&nbsp;device's&nbsp;control&nbsp;registers.&nbsp;&nbsp;
&nbsp;*/
int
cdev_map(dev_t&nbsp;dev,&nbsp;vhandl_t&nbsp;*vt,&nbsp;off_t&nbsp;off,&nbsp;int&nbsp;len,&nbsp;int&nbsp;prot)
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ctlr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Controller&nbsp;number&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;cdevboard_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*board;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Per-controller&nbsp;data&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;ctlr&nbsp;=&nbsp;geteminor(dev);
&nbsp;&nbsp;&nbsp;&nbsp;ASSERT(ctlr&nbsp;>=&nbsp;0&nbsp;&amp;&amp;&nbsp;ctlr&nbsp;&lt;=&nbsp;CDEV_MAX_BOARDS);
&nbsp;&nbsp;&nbsp;&nbsp;board&nbsp;=&nbsp;CDevBoards[ctlr];
&nbsp;&nbsp;&nbsp;&nbsp;ASSERT(board&nbsp;&amp;&amp;&nbsp;FLAGS_TEST(board,&nbsp;STATUS_OPEN|STATUS_PRESENT));
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(v_mapphys(vt,&nbsp;(void*)&nbsp;board->cd_regs,&nbsp;len))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ENOMEM;
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}

&nbsp;
/************************************************************************
&nbsp;*&nbsp;cdev_unmap&nbsp;--&nbsp;Called&nbsp;when&nbsp;a&nbsp;region&nbsp;is&nbsp;unmapped.&nbsp;&nbsp;We&nbsp;don't&nbsp;actually
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;need&nbsp;to&nbsp;do&nbsp;anything.
&nbsp;*/
int
cdev_unmap(dev_t&nbsp;dev,&nbsp;vhandl_t&nbsp;*vt)
{
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;No&nbsp;need&nbsp;to&nbsp;do&nbsp;anything&nbsp;here;&nbsp;unmapping&nbsp;is&nbsp;handled&nbsp;by&nbsp;upper&nbsp;levels
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;of&nbsp;the&nbsp;kernel.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}

</CODE>
</SECTION1>
</CHAPTER>
