<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="12"><TITLE><XREFTARGET ID="46033">VME Device Attachment on Origin2000/Onyx2</TITLE><PARAGRAPH>This chapter describes IRIX 6.5 VME support for Origin2000 and Onyx2 systems. For information on VME drivers on Challenge and ONYX systems, refer to This chapter gives a high-level overview of the VME bus, and describes how the VME bus is attached to an Origin2000 or Onyx2 system and how it is configured.<INDEXTARGET ID="13-vmehw1"><!-- POSTPROCESSDATA: 13-vmehw1|VME bus --><INDEXTARGET ID="13-vmehw2"><!-- POSTPROCESSDATA: 13-vmehw2|VME bus, hardware --></PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>This chapter has no information about VME in Challenge and Onyx systems. For those systems, refer to <XREF IDREF="90512" TYPE="TITLE">Chapter&nbsp;14, &ldquo;VME Device Attachment on Challenge/Onyx,&rdquo;</XREF> and <XREF IDREF="14611" TYPE="TITLE">Chapter&nbsp;15, &ldquo;Services for VME Drivers on Challenge/Onyx.&rdquo;</XREF></NOTE>
<PARAGRAPH>This chapter contains important details on VME operation if you are writing a kernel-level VME device driver. It contains useful background information if you plan to control a VME device from a user-level program. </PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="96643" TYPE="TITLE">&ldquo;Overview of the VME Bus&rdquo;</XREF> summarizes the history and features of the VME bus architecture.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="30252" TYPE="TITLE">&ldquo;About VME Bus Attachment&rdquo;</XREF> gives a conceptual overview of how VME support is provided in all Silicon Graphics systems that have it.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="10612" TYPE="TITLE">&ldquo;About VME Bus Addresses and System Addresses&rdquo;</XREF> describes the important relationship between addresses on the VME bus and addresses in the physical address space of the system.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="74935" TYPE="TITLE">&ldquo;About VME in the Origin2000&rdquo;</XREF> documents the hardware details of the VME implementation on Origin2000 and Origin200 systems.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="50904" TYPE="TITLE">&ldquo;Configuring VME Devices&rdquo;</XREF> tells how to configure a device so that IRIX       6.4 can recognize it and initialize its device driver.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>More information about VME device control appears in these chapters:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="66996" TYPE="TITLE">Chapter&nbsp;4, &ldquo;User-Level Access to Devices,&rdquo;</XREF> covers PIO and DMA access from the user process.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="13012" TYPE="TITLE">Chapter&nbsp;13, &ldquo;Services for VME Drivers on Origin2000/Onyx2,&rdquo;</XREF>discusses the kernel services used by a kernel-level VME device driver, and contains an example.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="96643">Overview of the VME Bus</TITLE><PARAGRAPH>The VME bus was standardized in the early 1980s. It was designed as a flexible interconnection between multiple master and slave devices using a variety of address and data precisions. While VME is not the fastest bus design available, its well-defined protocols, comparatively low signaling speeds, and ample board dimensions make it an easy bus to design for, whether to create intelligent I/O devices or special-purpose and one-off interfaces. As a result, VME has become a popular standard bus used in a variety of general-purpose and embedded products.<INDEXTARGET ID="13-vmehw3"><!-- POSTPROCESSDATA: 13-vmehw3|VME bus:overview --></PARAGRAPH>
<PARAGRAPH>In its original applications, the VME bus was used as the primary system bus, with a CPU card as the principal (or only) bus master. In Silicon Graphics systems, however, the VME bus is treated as an I/O device&mdash;it is never the main system bus. </PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>VME History</TITLE><PARAGRAPH>The VME bus descends from the VERSAbus, a bus design published by Motorola, Inc., in 1980 to support the needs of the MC68000 line of microprocessors. The bus timing relationships and some signal names still reflect this heritage, although the VME bus is used by devices from many manufacturers today.<INDEXTARGET ID="13-vmehw4"><!-- POSTPROCESSDATA: 13-vmehw4|VME bus:history --></PARAGRAPH>
<PARAGRAPH>The original VERSAbus design specified a large form factor for pluggable cards. Because of this, it was not popular with European designers. A bus with a smaller form factor but similar functions and electrical specifications was designed for European use, and promoted by Motorola, Phillips, Thompson, and other companies. This was the VersaModule European, or VME, bus. Beginning with rev B of 1982, the bus quickly became an accepted standard. (For ordering information on the standards documents, see <XREF IDREF="39610" TYPE="TITLE">&ldquo;Standards Documents&rdquo;</XREF>.)</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>VME Features</TITLE><PARAGRAPH>A VME bus is a set of parallel conductors that interconnect multiple processing devices. The devices can exchange data in units of 8, 16, 32 or 64 bits during a bus cycle.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>VME Address Spaces</TITLE><PARAGRAPH>Each VME device associates itself with a range of bus addresses. A bus address has either 16, 24, 32, or 64 bits of precision. Each width of address forms a separate address space. That is, the same numeric value can refer to one device in the 24-bit address space, and to a different device in the 32-bit address space. Typically, a device operates in only one address space, but some devices can be configured into multiple address spaces.<INDEXTARGET ID="13-vmehw5"><!-- POSTPROCESSDATA: 13-vmehw5|VME bus:bus address spaces --></PARAGRAPH>
<PARAGRAPH>Each VME bus cycle contains the bits of an address. The address is qualified by sets of address-modifier bits that specify the following:<INDEXTARGET ID="13-vmehw6"><!-- POSTPROCESSDATA: 13-vmehw6|VME bus:address modifier --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>the address space (A16, A24, A32, or A64)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>whether the operation is single or a block transfer</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>whether the access is to what, in the MC68000 architecture, would be data or code, in a supervisor or user area. Silicon Graphics systems support only data area transactions, supervisor-data or user-data. </PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Master and Slave Devices</TITLE><PARAGRAPH>Each VME device acts as either a bus master or a bus slave. Typically a bus master is a programmable device with a microprocessor&mdash;for example, a disk controller. A slave device is typically a nonprogrammable device like a memory board or set of A/D inputs.<INDEXTARGET ID="13-vmehw7"><!-- POSTPROCESSDATA: 13-vmehw7|VME bus:slave device --><INDEXTARGET ID="13-vmehw8"><!-- POSTPROCESSDATA: 13-vmehw8|VME bus:master device --></PARAGRAPH>
<PARAGRAPH>Each data transfer is initiated by a master device. The master</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>asserts ownership of the bus</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>specifies the address modifier bits for the transfer, including the address space, single/block mode, and supervisor/normal mode</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>specifies the address for the transfer</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>specifies the data unit size for the transfer (8, 16, 32 or 64 bits)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>specifies the direction of the transfer with respect to the master</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The VME bus design permits multiple master devices to exist on the bus, and provides a hardware-based arbitration system so that they can share the bus in alternation.</PARAGRAPH>
<PARAGRAPH>A slave device responds to a master when the master specifies one of the slave's addresses. The addressed slave accepts data, or provides data, as directed.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>VME Transactions</TITLE><PARAGRAPH>The VME design allows for four types of data transfer bus cycles:<INDEXTARGET ID="13-vmehw9"><!-- POSTPROCESSDATA: 13-vmehw9|VME bus:bus cycles --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>A read cycle returns data from the slave to the master.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A write cycle sends data from the master to the slave.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A read-modify-write cycle takes data from the slave, and on the following bus cycle sends it back to the same address, possibly altered.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A block-transfer transaction sends multiple data units to adjacent addresses in a burst of consecutive bus cycles.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The VME design also allows for interrupts. A device can raise an interrupt on any of seven <INDEXTARGET ID="13-vmehw10"><!-- POSTPROCESSDATA: 13-vmehw10|VME bus:interrupt levels --><GLOSSARYITEM>interrupt level</GLOSSARYITEM>s. The interrupt is acknowledged by a bus master. The bus master interrogates the interrupting device in an interrupt-acknowledge bus cycle, and the device returns an interrupt vector number.</PARAGRAPH>
<PARAGRAPH>In Silicon Graphics systems, VME interrupts are received by the VME controller. If the controller has been configured by a VECTOR statement (see <XREF IDREF="14072" TYPE="TITLE">&ldquo;Entry Point edtinit()&rdquo; in Chapter&nbsp;7</XREF>) to handle a given interrupt level, it acknowledges the interrupt and sends an interrupt to one of the CPUs in the system.</PARAGRAPH>
<PARAGRAPH>If the controller has not been configured to acknowledge an interrupt level, the interrupt level is ignored and can be handled by another device on the VME bus.</PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="30252">About VME Bus Attachment</TITLE><PARAGRAPH>The VME bus was designed as the system backplane for a workstation, supporting one or more CPU modules along with the memory and I/O modules they used. However, no Silicon Graphics computer uses the VME bus as the system backplane. In all Silicon Graphics computers, the main system bus that connects CPUs to memory is a proprietary bus design. The VME bus is attached to the system as an I/O device.<INDEXTARGET ID="13-vmehw11"><!-- POSTPROCESSDATA: 13-vmehw11|VME bus:hardware:overview --><INDEXTARGET ID="13-vmehw12"><!-- POSTPROCESSDATA: 13-vmehw12|Silicon Graphics:VME bus hardware --></PARAGRAPH>
<PARAGRAPH>This section provides a conceptual overview of the design of the VME bus in any Silicon Graphics system. It is sufficient background for most users of VME devices. A more detailed look at the hardware follows in later topics</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>The VME Bus Controller</TITLE><PARAGRAPH>A VME bus controller is attached to the system bus to act as a bridge between the system bus and the VME bus. This arrangement is shown in <XREF IDREF="87253" TYPE="GRAPHIC">Figure&nbsp;12-1</XREF>.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="13-vme.to.system.bus.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="12-1"><PREFIX>Figure 12-1 </PREFIX><XREFTARGET ID="87253">Relationship of VME Bus to System Bus</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>On the Silicon Graphics system bus, the VME bus controller acts as an I/O device. On the VME bus, the bus controller acts as a VME bus master. The VME controller has several tasks. Its most important task is mapping&mdash;that is, translating&mdash;some range of physical addresses in the Silicon Graphics system address space to a range of VME bus addresses. The VME controller performs a variety of other duties for different kinds of VME access.<INDEXTARGET ID="13-vmehw13"><!-- POSTPROCESSDATA: 13-vmehw13|VME bus:hardware:relation to system bus --></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>VME PIO Operations</TITLE><PARAGRAPH>During programmed I/O (PIO) to the VME bus, software in the CPU loads or stores the contents of CPU registers to a device on the VME bus. The operation of a CPU load from a VME device register is as follows:<INDEXTARGET ID="13-vmehw14"><!-- POSTPROCESSDATA: 13-vmehw14|Programmed I/O (PIO):VME bus --><INDEXTARGET ID="13-vmehw15"><!-- POSTPROCESSDATA: 13-vmehw15|VME bus:hardware:PIO cycle --></PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>The CPU executes a load from a system physical address.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The physical address is placed on a system bus.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The VME controller recognizes the address as one it has been programmed to map.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The VME controller translates the system address to an address in one of the VME bus address spaces.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Acting as a VME bus master, the VME bus controller starts a read cycle on the VME bus, using the translated address.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>A device on the VME bus responds to the VME address and returns data.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The VME controller initiates a system bus cycle to return the data packet to the CPU, thus completing the load operation.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>A VME device store is similar except it performs a VME bus write; no data is returned.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>PIO Latency and R10000 Execution</TITLE><PARAGRAPH>PIO input and output are fundamentally different in the following way: PIO input requires two system bus cycles&mdash;one to request the data and one to return it&mdash;separated by the cycle time of the VME bus. PIO output takes only one system bus cycle, and the VME bus write cycle run concurrently with the next system bus cycle. As a result, PIO input always takes at least twice as much time as PIO output.</PARAGRAPH>
<PARAGRAPH>The MIPS R10000 CPU can execute instructions out of sequence, leaving a memory-load operation pending while executing instructions that logically follow, provided that those instructions do not depend on loaded data. PIO input requires a microsecond or more, a time during which an R10000 can execute 200 or more instructions. An R10000 can execute many instructions following a PIO load before the CPU has to stall and wait for the PIO data to arrive. In a similar way, the R10000 CPU can execute hundreds of instructions after the beginning of a PIO write, concurrently with the output operation.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>VME DMA Operations</TITLE><PARAGRAPH>A VME device that can act as a bus master can perform DMA into system memory. The general sequence of operations in this case is as follows:<INDEXTARGET ID="13-vmehw16"><!-- POSTPROCESSDATA: 13-vmehw16|Direct Memory Access (DMA):VME bus --><INDEXTARGET ID="13-vmehw17"><!-- POSTPROCESSDATA: 13-vmehw17|VME bus:hardware:DMA cycle --></PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>The device driver allocates a DMA map object to represent the operation. When the kernel creates the DMA map, it programs the VME controller to map a certain range of VME bus addresses to a range of system memory locations.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The device driver uses PIO to program the device registers of the VME device, instructing it to perform DMA to the assigned range of VME bus address for a specified length of data.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The VME bus master device initiates the first read, write, block-read, or block-write cycle on the VME bus.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The VME controller, recognizing a mapped address, responds as a slave device on the VME bus.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>If the bus master is writing, the VME controller accepts the data and initiates a system bus cycle to write the data to system memory at the mapped address.</PARAGRAPH>
<PARAGRAPH>If the bus master is reading, the VME controller uses a system bus cycle to read data from system memory, and returns the data to the bus master.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The bus master device continues to use the VME controller as a slave device until it has completed the DMA transfer.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>During a DMA transaction, the VME bus controller operates independently of any CPU. CPUs in the system execute software concurrently with the data transfer. Since the system bus is faster than the VME bus, the data transfer typically takes place at the maximum data rate that the VME bus master can sustain.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="24551">Operation of the DMA Engine</TITLE><PARAGRAPH>In the Origin2000 and Onyx2 systems (and in the Challenge and Onyx lines), the VME controller contains an additional &ldquo;DMA Engine&rdquo; that can be programmed to perform DMA-type transfers between memory and a VME device that is a slave, not a bus master. The general course of operations in a DMA engine transfer is as follows:<INDEXTARGET ID="13-vmehw18"><!-- POSTPROCESSDATA: 13-vmehw18|VME bus:DMA engine --><INDEXTARGET ID="13-vmehw19"><!-- POSTPROCESSDATA: 13-vmehw19|Challenge/Onyx:DMA engine in --><INDEXTARGET ID="13-vmehw20"><!-- POSTPROCESSDATA: 13-vmehw20|Direct Memory Access (DMA):DMA engine for VME bus --></PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>The VME bus controller is programmed to perform a DMA transfer to a certain physical memory address for a specified amount of data from a specified device address in VME address space.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The VME bus controller, acting as the VME bus master, initiates a block read or block write to the specified device.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>As the slave device responds to successive VME bus cycles, the VME bus controller transfers data to or from memory using the system bus.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>The DMA engine transfers data independently of any CPU, and at the maximum rate the VME bus slave can sustain. In addition, the VME controller collects smaller data units into blocks of the full system bus width, minimizing the number of system bus cycles needed to transfer data. For both these reasons, DMA engine transfers are faster than PIO transfers for all but very short transfer lengths. (For details, see &ldquo;DMA Engine Bandwidth&rdquo; on page&nbsp;72.)</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="10612">About VME Bus Addresses and System Addresses</TITLE><PARAGRAPH>Devices on the VME bus exist in one of the following address spaces:<INDEXTARGET ID="13-vmehw21"><!-- POSTPROCESSDATA: 13-vmehw21|VME bus:bus address spaces --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The 16-bit space (A16) permits addresses from 0x0000 to 0xffff.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The 24-bit space (A24) permits addresses from 0x00&nbsp;0000 to 0xff&nbsp;ffff.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The 32-bit space (A32) permits addresses 0x0000&nbsp;0000 to 0xffff&nbsp;ffff.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The 64-bit space (A64), defined in the revision D specification, uses 64-bit addresses.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The Silicon Graphics system bus uses 64-bit numbers to address memory and other I/O devices on the system bus (discussed in <XREF IDREF="24376" TYPE="TITLE">Chapter&nbsp;1</XREF>). Much of the physical address space is used to address system memory. Portions of physical address space are set aside dynamically to represent VME addresses. Parts of the VME address spaces are mapped, that is, translated, into these ranges of physical addresses.</PARAGRAPH>
<PARAGRAPH>The translation is performed by the VME bus controller: It is programmed to recognize certain ranges of addresses on the system bus and translate them into VME bus addresses; and it recognizes certain VME bus addresses and translates them into physical addresses on the system bus.</PARAGRAPH>
<PARAGRAPH>The entire A32 or A64 address space cannot be mapped into the physical address space. No Silicon Graphics system can provide access to all VME address spaces at one time. Only parts of the VME address spaces are available at any time. The limits on how many addresses can be mapped at any time are different in different architectures.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>User-Level and Kernel-Level Addressing</TITLE><PARAGRAPH>In a user-level program you can perform PIO and certain types of DMA operations (see <INDEXTARGET ID="13-vmehw22"><!-- POSTPROCESSDATA: 13-vmehw22|VME bus:bus address spaces:mapping --><XREF IDREF="66996" TYPE="TITLE">Chapter&nbsp;4, &ldquo;User-Level Access to Devices&rdquo;</XREF>). You call on the services of a kernel-level device driver to map a portion of VME address space into the address space of your process. The requested segment of VME space is mapped dynamically to a segment of your user-level address space&mdash;a segment that can differ from one run of the program to the next.</PARAGRAPH>
<PARAGRAPH>In a kernel-level device driver, you request mappings for both PIO and DMA operations using <ITALICS>maps</ITALICS>&mdash;software objects that represent a mapping between kernel virtual memory and a range of VME bus addresses.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>The remainder of this chapter has direct meaning only for kernel-level drivers.</NOTE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>PIO Addressing and DMA Addressing</TITLE><PARAGRAPH>The addressing needs of PIO access and DMA access are different.</PARAGRAPH>
<PARAGRAPH>PIO deals in small amounts of data, typically single words. PIO is directed to device registers that are identified with specific VME bus addresses. The association between a device register and its VME address is fixed, typically by setting jumpers or switches on the VME card.<INDEXTARGET ID="13-vmehw23"><!-- POSTPROCESSDATA: 13-vmehw23|VME bus:PIO to:addresses --><INDEXTARGET ID="13-vmehw24"><!-- POSTPROCESSDATA: 13-vmehw24|Programmed I/O (PIO):VME bus --></PARAGRAPH>
<PARAGRAPH>DMA deals with extended segments of kilobytes or megabytes. The addresses used in DMA are not fixed in the device, but are programmed into it just before the data transfer begins. For example, a disk controller can be programmed to read a certain disk sector and write the sector data to a range of 512 consecutive bytes in the VME bus address space. The programming of the disk controller is done by storing numbers into its registers using PIO. While the registers respond only to fixed addresses that are configured into the board, the address for sector data is just a number that is programmed into the controller before a transfer is to start.<INDEXTARGET ID="13-vmehw25"><!-- POSTPROCESSDATA: 13-vmehw25|Direct Memory Access (DMA):VME bus --></PARAGRAPH>
<PARAGRAPH>These are the key differences between PIO addresses and addresses used for DMA:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>PIO addresses are relatively few in number and cover small spans of data, while DMA addresses can span large ranges of data.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>PIO addresses are closely related to the hardware architecture of the device and are configured by hardware or firmware, while DMA addresses are simply parameters programmed into the device before each operation.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>In systems supported by IRIX 6.4, all mappings from VME address spaces to system physical memory are dynamic, assigned as needed. Kernel functions are provided to create and use map objects that represent the translation between designated VME addresses and kernel addresses (described in detail in <XREF IDREF="13012" TYPE="TITLE">Chapter&nbsp;13, &ldquo;Services for VME Drivers on Origin2000/Onyx2&rdquo;</XREF>). An Origin2000 system can support a maximum of five VME bus adapters per module. Although a system can comprise numerous modules, there is also a limit of five VME bus adapters, total, per system. <INDEXTARGET ID="13-vmehw26"><!-- POSTPROCESSDATA: 13-vmehw26|VME bus:PIO to:addressing in --></PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="55330">Available PIO Addresses</TITLE><PARAGRAPH>Normally a VME card can be programmed to use different VME addresses for PIO, based on jumper or switch settings on the card. Each device plugged into a single VME bus must be configured to use unique addresses. Errors that are hard to diagnose can arise when multiple cards respond to the same bus address. Devices on different VME buses can of course use the same addresses.</PARAGRAPH>
<PARAGRAPH>Not all parts of each address space are accessible. The accessible parts are summarized in <XREF IDREF="18234" TYPE="TABLE">Table&nbsp;12-1</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="12-1"><PREFIX>Table 12-1 </PREFIX><XREFTARGET ID="18234">Accessible VME PIO Addresses on Any Bus</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="45"><PARAGRAPH>Address 
Space</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="161"><PARAGRAPH>&lbreak;Origin2000 Systems </PARAGRAPH>
</CELL>
<CELL LEFT="220" WIDTH="180"><PARAGRAPH>&lbreak;Challenge and Onyx Systems</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>A16</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="161"><PARAGRAPH>All</PARAGRAPH>
</CELL>
<CELL LEFT="220" WIDTH="180"><PARAGRAPH>All</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>A24</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="161"><PARAGRAPH>0x80&nbsp;0000&ndash;0xF<BOLD>E</BOLD>&nbsp;0000</PARAGRAPH>
</CELL>
<CELL LEFT="220" WIDTH="180"><PARAGRAPH>0x80&nbsp;0000&ndash;0xF<BOLD>F</BOLD>&nbsp;FFFF</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>A32</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="161"><PARAGRAPH>0x0000&nbsp;0000&ndash;0x7FFF&nbsp;FFFF</PARAGRAPH>
</CELL>
<CELL LEFT="220" WIDTH="180"><PARAGRAPH>0x0000&nbsp;0000&ndash;0x7FFF&nbsp;FFFF </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>There are additional limits on the maximum size of any single PIO map and limits on the aggregate size of all maps per bus. These limits differ between the Origin2000 and the Challenge architectures; the details are given in the discussion of allocating maps.</PARAGRAPH>
<PARAGRAPH>In general, however, when configuring the devices on a bus, it is best if you can locate all device registers in a single, relatively compact, range of addresses. This economizes on kernel resources used for mapping.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Available DMA Addresses</TITLE><PARAGRAPH>When you program a bus master to perform DMA, you load it with a starting target address in one of the VME address spaces, and a length. This address and length is dynamically mapped to a corresponding range of memory addresses. You can obtain a map to memory for a range of addresses in any of the A16, A24, or A32 data address spaces. The A64 address space is not available for either PIO or DMA on Origin2000 or Onyx2 systems.</PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="74935">About VME in the Origin2000</TITLE><PARAGRAPH>In the Origin2000 (including Origin Deskside) and Onyx2 systems, external I/O is provided through the XIO interface. The VME bus and adapter is an external I/O device interfaced through one XIO slot. A typical installation is shown in <XREF IDREF="62706" TYPE="GRAPHIC">Figure&nbsp;12-2</XREF>.</PARAGRAPH>
<PARAGRAPH>For more information about the external features, options, and availability of the VME Expansion unit, you can consult one of these sources: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH>Marketing Information</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH><LAUNCHWORD APP="/usr/sbin/nr" PARMS="http://www.sgi.com/Products/software/REACT/vme.html">http://www.sgi.com/Products/software/REACT/vme.html</LAUNCHWORD>
&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH>Owner's Guide</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH><DOCTITLE>VME Option Owner's Guide</DOCTITLE>, document number 007-3618-<ITALICS>nnn</ITALICS></PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH><FIGURE><GRAPHIC FILE="13-vme.deskside.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="12-2"><PREFIX>Figure 12-2 </PREFIX><XREFTARGET ID="62706">VME Bus Enclosure and Cable to an Origin2000 Deskside</CAPTION>
</FIGURE>
</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>About the VME Controller</TITLE><PARAGRAPH>The VME controller for Origin2000 is physically located on a VME board plugged into the VME bus enclosure. It is logically connected to the system as shown in <XREF IDREF="54181" TYPE="GRAPHIC">Figure&nbsp;12-3</XREF>.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="13-cpu.xio.pci.vme.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="12-3"><PREFIX>Figure 12-3 </PREFIX><XREFTARGET ID="54181">VME Bus Connection to System Bus</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>As suggested by <XREF IDREF="54181" TYPE="GRAPHIC">Figure&nbsp;12-3</XREF>, data to and from the VME bus passes through multiple layers of bus protocols. For example, on a PIO write from the CPU to a VME device, the following functional units are involved:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>The CPU sends a word to a physical memory address.</PARAGRAPH>
<PARAGRAPH>In the Origin2000 architecture, physical addressing is managed by the Hub chip on the node board (not shown). The Hub chip directs the word to the XIO interface.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The XIO interface passes the word down the Craylink cable (see <XREF IDREF="62706" TYPE="GRAPHIC">Figure&nbsp;12-2</XREF>) to the VME controller board, which is a VME 6U or 9U card mounted in the card cage.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>On the VME controller board, an XIO-to-PCI converter called a Bridge chip. The transaction is converted to a PCI bus write.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The sole device on the PCI bus is the VME controller, a PCI-to-VME bridge chip.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The VME controller operates the signal and data lines of the VME enclosure to execute a write the desired VME address.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="25615">Universe II Controller Chip</TITLE><PARAGRAPH>The VME controller chip is a PCI-to-VME bridge named the Universe&nbsp;II, produced by Tundra Semiconductor Corporation (<LAUNCHWORD APP="/usr/sbin/nr" PARMS="http://www.sgi.com/Products/software/REACT/vme.html">http://www.tundra.com</LAUNCHWORD>
).</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Universe II Features</TITLE><PARAGRAPH>The Universe&nbsp;II contains:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>FIFO buffers for asynchronous staging of data between the two buses.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Mapping registers for translating VME bus addresses.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A DMA engine comparable to the DMA engine in the Challenge systems, with the added ability to handle linked lists of data (scatter/gather). This engine is accessible only to user-level processes through the <FILENAME>udmalib</FILENAME> interface.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The ability to pack and unpack multiple D8, D16 and D32 data units from 64-bit PCI data words.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>It is important to note that although the data path spans three different bus protocols and multiple bus controller chips, <ITALICS>none</ITALICS> of these controllers are directly accessible to a VME device driver. The device driver calls on the kernel to create software objects called maps, either PIO maps or DMA maps. When the kernel creates a map, it sets up all the multiple layers of hardware needed to implement that map. The driver uses the map to obtain physical addresses that can be used as if they were wired directly to the VME bus. All the layers of protocol translation between memory and the VME device are transparent to the device driver.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Kernel Settings of Universe II Registers</TITLE><PARAGRAPH>In the event you possess the Tundra Corp Data book describing the Universe&nbsp;II, the settings of important Universe&nbsp;II control registers is listed in <XREF IDREF="87908" TYPE="TABLE">Table&nbsp;12-2</XREF>. This table is provided for information only. The Universe&nbsp;II registers are loaded by the kernel VME support, and none of these settings is accessible to the device driver. Also, this information is subject to change from release to release.</PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="12-2"><PREFIX>Table 12-2 </PREFIX><XREFTARGET ID="87908"> <EMPHASIS>(continued)        </EMPHASIS>Universe II Register Settings</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Register</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="49"><PARAGRAPH>Field</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="193"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="54"><PARAGRAPH>Setting</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>MAST_CTL</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="49"><PARAGRAPH>PWON</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="193"><PARAGRAPH>Max posted write length</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="54"><PARAGRAPH>4096</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>MAST_CTL</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="49"><PARAGRAPH>VRL</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="193"><PARAGRAPH>VMEbus Request Level</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="54"><PARAGRAPH>3</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>MAST_CTL</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="49"><PARAGRAPH>VRM</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="193"><PARAGRAPH>VMEbus Request Mode</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="54"><PARAGRAPH>demand</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>MAST_CTL</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="49"><PARAGRAPH>VREL</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="193"><PARAGRAPH>VMEbus Release Mode</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="54"><PARAGRAPH>On-request</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>MAST_CTL</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="49"><PARAGRAPH>VOWN</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="193"><PARAGRAPH>VME ownership</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="54"><PARAGRAPH>n.a.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>MAST_CTL</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="49"><PARAGRAPH>PABS</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="193"><PARAGRAPH>PCI Burst Size</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="54"><PARAGRAPH>128 bytes</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>MISC_CTL</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="49"><PARAGRAPH>VBTO</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="193"><PARAGRAPH>Vmebus timeout</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="54"><PARAGRAPH>64us</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>MISC_CTL</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="49"><PARAGRAPH>VARB</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="193"><PARAGRAPH>VMEbus arbitration type</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="54"><PARAGRAPH>priority</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>MISC_CTL</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="49"><PARAGRAPH>VARBTO</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="193"><PARAGRAPH>VMEbus arbitration timeout</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="54"><PARAGRAPH>16us</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>MISC_CTL</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="49"><PARAGRAPH>RESCIND</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="193"><PARAGRAPH>VMEbus DTACK* release</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="54"><PARAGRAPH>rescind</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>MISC_CTL</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="49"><PARAGRAPH>SYSCON</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="193"><PARAGRAPH>Universe is system controller at power-up</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="54"><PARAGRAPH>on</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>MISC_CTL</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="49"><PARAGRAPH>V64AUTO</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="193"><PARAGRAPH>Auto slot ID</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="54"><PARAGRAPH>n.a.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="50904"><XREFTARGET ID="22127">Configuring VME Devices</TITLE><PARAGRAPH>You (or the system administrator) must configure a VME bus and device to the IRIX system in order to direct interrupts and to associate each VME device with its device driver. In order to configure the bus you need to know how VME devices are represented in the hardware graph (see <INDEXTARGET ID="13-vmehw27"><!-- POSTPROCESSDATA: 13-vmehw27|VME bus, configuration --><XREF IDREF="51581" TYPE="TITLE">&ldquo;Hardware Graph&rdquo;</XREF>).</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="93344">VME Bus and Interrupt Naming</TITLE><PARAGRAPH>Each VME bus is entered into the IRIX hardware graph during bootstrap, as a connection point for devices and as a source of interrupts.<INDEXTARGET ID="13-vmehw28"><!-- POSTPROCESSDATA: 13-vmehw28|hwgraph:and VME --><INDEXTARGET ID="13-vmehw29"><!-- POSTPROCESSDATA: 13-vmehw29|VME bus:hwgraph use --></PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>VME Bus Paths in the Hardware Graph</TITLE><PARAGRAPH>The actual hardware graph path to a VME bus has this form:</PARAGRAPH>
<EXAMPLE>
/hw/module/<VARIABLE>mod</VARIABLE>/slot/io<VARIABLE>n</VARIABLE>/baseio/vme_xtown/pci/7/vmebus/
</EXAMPLE>
<PARAGRAPH>The integer <VARIABLE>mod</VARIABLE> is the number of the Origin module to which the VME option is attached. Vertex io<VARIABLE>n</VARIABLE> designates the XIO slot to which the VME option is cabled.</PARAGRAPH>
<PARAGRAPH>The <FILENAME>hwgraph</FILENAME> vertex named <FILENAME>vmebus</FILENAME> represents the VME controller. Vertexes for devices on the bus are found under that vertex. A convenience path is also created for each bus in the form:</PARAGRAPH>
<EXAMPLE>
/hw/vme/<VARIABLE>b</VARIABLE>/
</EXAMPLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>VME Bus Numbers Assigned by ioconfig</TITLE><PARAGRAPH>The bus number <INDEXTARGET ID="13-vmehw30"><!-- POSTPROCESSDATA: 13-vmehw30|configuration files:/etc/ioconfig.config --><INDEXTARGET ID="13-vmehw31"><!-- POSTPROCESSDATA: 13-vmehw31|IRIX commands:ioconfig:with VME --><VARIABLE>b</VARIABLE> is assigned by the <COMMAND>ioconfig</COMMAND> command (see <XREF IDREF="83505" TYPE="TITLE">&ldquo;Using ioconfig for Global Controller Numbers&rdquo;</XREF>). The number <VARIABLE>b</VARIABLE> is arbitrarily assigned the first time <COMMAND>ioconfig</COMMAND> runs after a VME option is added to the system. The first VME bus must be number 1 (not 0).</PARAGRAPH>
<PARAGRAPH>The bus numbers as assigned are recorded in the <COMMAND>ioconfig</COMMAND> database file <FILENAME>/etc/ioconfig.config</FILENAME> (see <XREF IDREF="81705" TYPE="TITLE">&ldquo;Configuration Control File&rdquo;</XREF>). The administrator can edit that file to change the numbering, for example to force a certain bus to be number 1.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>VME Bus Interrupt Level Names</TITLE><PARAGRAPH>In order to direct VME bus interrupt levels to specified CPUs, you need to be able to name the interrupt levels of a bus. For this purpose, the kernel creates names of the following form in the hwgraph:</PARAGRAPH>
<EXAMPLE>
/hw/module/<VARIABLE>mod</VARIABLE>/slot/io<VARIABLE>n</VARIABLE>/baseio/vme_xtown/pci/7/vmebus/ipl/<VARIABLE>i</VARIABLE>&space;
</EXAMPLE>
<PARAGRAPH>Seven of these names appear under each <FILENAME>vmebus</FILENAME> vertex, with <VARIABLE>i</VARIABLE> ranging from 1 to 7. Each vertex represents one VME bus interrupt priority level.</PARAGRAPH>
<PARAGRAPH>The same vertexes are accessible under the convenience names:</PARAGRAPH>
<EXAMPLE>
/hw/vme/<VARIABLE>b</VARIABLE>/ipl/<VARIABLE>i</VARIABLE>&space;
</EXAMPLE>
<PARAGRAPH>You can use either of these pathnames in a DEVICE_ADMIN command to direct VME interrupts.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="21468">Directing VME Interrupts</TITLE><PARAGRAPH>VME interrupts are handled in two phases. The first phase, which executes at a high priority and is extremely quick, involves acknowledging the interrupt and locating the device driver interrupt handler that should be notified. In the second phase, the device driver's specified handler executes as an independent thread (see <INDEXTARGET ID="13-vmehw32"><!-- POSTPROCESSDATA: 13-vmehw32|configuration files:/var/sysgen/irix.sm --><XREF IDREF="23200" TYPE="TITLE">&ldquo;Handling VME Interrupts&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>The first phase of processing executes on the CPU to which the interrupt is directed by hardware. When nothing is done, all interrupts from a VME bus controller are directed to CPU 0 in the Origin module to which the VME bus is attached.</PARAGRAPH>
<PARAGRAPH>The system administrator can use the DEVICE_ADMIN statement to direct VME interrupts to a specific CPU. The DEVICE_ADMIN statement is placed in a file in the <FILENAME>/var/sysgen/system</FILENAME> directory, possibly (but not necessarily) <FILENAME>/var/sysgen/system/irix.sm</FILENAME>. The form of the statement to direct interrupts is:</PARAGRAPH>
<CODE>
DEVICE_ADMIN: <VARIABLE>device_path</VARIABLE> INTR_TARGET=<VARIABLE>cpu_path</VARIABLE>&space;
</CODE>
<PARAGRAPH>The <VARIABLE>device_path</VARIABLE> is the hwgraph path specifying one of the VME interrupt levels for a bus (see <XREF IDREF="93344" TYPE="TITLE">&ldquo;VME Bus and Interrupt Naming&rdquo;</XREF>). The <VARIABLE>cpu_path</VARIABLE> is the hwgraph path that specifies a CPU. For example, to send VME level-7 interrupts from the first VME bus to CPU 12, you could write</PARAGRAPH>
<EXAMPLE>
DEVICE_ADMIN: /hw/vme/1/ipl/7 INTR_TARGET=/hw/cpunum/12
</EXAMPLE>
<PARAGRAPH>Although there are seven VME interrupt levels, only six unique redirections of this type can be supported for any VME bus. In other words, you can direct the seven levels to at most six different CPUs. You must send at least two levels to the same CPU. (Typically you direct all the levels to a single CPU.)</PARAGRAPH>
<PARAGRAPH>The DEVICE_ADMIN statement directs interrupt detection. The device driver itself specifies the CPU in which the interrupt handler code executes. By default this is the same CPU where detection takes place.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="34212">VME Device Naming</TITLE><PARAGRAPH>VME devices are entered as vertexes in the hwgraph while the VECTOR statements are processed during system startup. The kernel creates a vertex for each device with the following form:</PARAGRAPH>
<EXAMPLE>
/hw/module/<VARIABLE>mod</VARIABLE>/slot/io<VARIABLE>n</VARIABLE>/baseio/vme_xtown/pci/7/vmebus/a<VARIABLE>ssm</VARIABLE>/<VARIABLE>addr</VARIABLE>/ 
</EXAMPLE>
<PARAGRAPH>The vertex shown here as a<VARIABLE>ssm</VARIABLE> is the name of the VME address space, one of a16s, a16n, a24s, a24n, a32s, or a32n. The vertex <VARIABLE>addr</VARIABLE> is the primary address of the device, from its VECTOR statement. The address is in hexadecimal digits with leading zeros suppressed. For example, a device located at 0x00108000 in the A32 non-supervisory space would appear in the hwgraph as</PARAGRAPH>
<EXAMPLE>
/hw/module/<VARIABLE>mod</VARIABLE>/slot/io<VARIABLE>n</VARIABLE>/baseio/vme_xtown/pci/7/vmebus/a32n/108000 
</EXAMPLE>
<PARAGRAPH>The same vertex appears also under the convenience vertex for that bus:</PARAGRAPH>
<EXAMPLE>
/hw/vme/<VARIABLE>b</VARIABLE>/a32n/108000
</EXAMPLE>
<PARAGRAPH>This kernel-created vertex is the &ldquo;connection point&rdquo; that is passed to the device driver when the driver is called to initialize the device. The device driver is allowed (encouraged) to create additional vertexes with more meaningful names (the initialization process is described under <XREF IDREF="20724" TYPE="TITLE">&ldquo;Initializing a VME Device&rdquo;</XREF>).</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="89231">Defining VME Devices with the VECTOR Statement</TITLE><PARAGRAPH>Devices on the VME bus do not identify themselves to the system automatically (as devices on the PCI bus do). You must tell IRIX that a device exists, or should exist. You do this using the VECTOR statement. The VECTOR statement is placed in a file in the directory <INDEXTARGET ID="13-vmehw33"><!-- POSTPROCESSDATA: 13-vmehw33|configuration files:/var/sysgen/irix.sm --><FILENAME>/var/sysgen/system</FILENAME> (see <XREF IDREF="28517" TYPE="TITLE">&ldquo;Kernel Configuration Files&rdquo;</XREF>). For VME, the syntax of the VECTOR statement is as follows:</PARAGRAPH>
<CODE>
VECTOR: bustype=VME module=<VARIABLE>modname</VARIABLE> [ adapter=<VARIABLE>b</VARIABLE> [ ctlr=<VARIABLE>c</VARIABLE> ] ] 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;ipl=<VARIABLE>i</VARIABLE> ] [ vector=<VARIABLE>v</VARIABLE> ]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iospace=(A<VARIABLE>nnM</VARIABLE>,<VARIABLE>addr</VARIABLE>,<VARIABLE>size</VARIABLE>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;iospace2=(A<VARIABLE>nnM</VARIABLE>,<VARIABLE>addr</VARIABLE>,<VARIABLE>size</VARIABLE>)&nbsp;]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;iospace3=(A<VARIABLE>nnM</VARIABLE>,<VARIABLE>addr</VARIABLE>,<VARIABLE>size</VARIABLE>)&nbsp;]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;exprobe=((<VARIABLE>cmd</VARIABLE>,<VARIABLE>paddr</VARIABLE>,<VARIABLE>width</VARIABLE>,<VARIABLE>value</VARIABLE>,<VARIABLE>mask</VARIABLE>)&nbsp;[,...] ]
</CODE>
<PARAGRAPH>The variable elements of this statement, in order of appearance, are as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>modname</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Name of the configuration file for the device driver for this type of device (see 
<XREF IDREF="91260" TYPE="TITLE">&ldquo;Master Configuration Database&rdquo;</XREF>). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>b</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Number of the VME bus as assigned by ioconfig (see <XREF IDREF="93344" TYPE="TITLE">&ldquo;VME Bus and 
Interrupt Naming&rdquo;</XREF>) </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>c</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Arbitrary number to distinguish this device to the driver. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>i</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Interrupt priority level used by this device, if it produces interrupts. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>v</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Interrupt vector value returned by this device, when that is known (some 
devices are dynamically configured with vector numbers by the driver). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>A<VARIABLE>nnM</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Name of the address space used by this device, one of A16S, A16NP, A24S, 
A24NP, A32S, A32NP </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Lowest address in a range of addresses used by the device. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>size</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Number of bytes in the range of addresses.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>cmd</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Probe command, either <BOLD>w</BOLD> meaning write, <BOLD>r</BOLD> meaning read and test equal, or 
<BOLD>rn</BOLD> meaning read and test not-equal. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>paddr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Address to probe (in the address space given by <COMMAND>iospace</COMMAND>). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>width</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>The width of data to read or write in the probe: 1, 2, 4 or 8 bytes. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>value</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>A value to be written, or to be compared to the data returned by read. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>mask</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>A mask to be ANDed with the value before writing, or to be ANDed with the 
data returned by a read before comparison. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Numeric values (variables <VARIABLE>b</VARIABLE>, <VARIABLE>c</VARIABLE>, <VARIABLE>i</VARIABLE>, <VARIABLE>v</VARIABLE>, <VARIABLE>nn</VARIABLE>, <VARIABLE>addr</VARIABLE>, <VARIABLE>size</VARIABLE>, <VARIABLE>paddr</VARIABLE>, <VARIABLE>width</VARIABLE>, <VARIABLE>value</VARIABLE> and <VARIABLE>mask</VARIABLE>) can be written in decimal, or in hexadecimal with a prefix of &ldquo;0x.&rdquo;</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>The VECTOR statement is written as a single physical line in a text file. In this book, VECTOR statements are broken across multiple lines for readability. Do not break a VECTOR statement across multiple text lines in a configuration file.</NOTE>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="96837">Example VME Configuration</TITLE><PARAGRAPH>As an example, imagine you have two VME boards on bus number 1, with these features:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Reside in A32NP address spaces starting 0x001008000 and 0x00108020 respectively.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Support 8, 4-byte registers.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Writing a zero word into the first register resets a board; after which the least significant bit of the eighth register should be zero.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The driver for this type of board is configured in a file named <FILENAME>/var/sysgen/master.d/vme_examp</FILENAME>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Jumpered to generate interrupts on IPL 5 with vectors of 0x0e and 0x0f respectively.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>To configure these boards you could prepare a file named <FILENAME>/var/sysgen/system/twoboards.sm</FILENAME> with these contents:</PARAGRAPH>
<CODE><CAPTION LBL="12-1"><PREFIX>Example 12-1 </PREFIX><XREFTARGET ID="70238">Hypothetical VME Configuration File</CAPTION>* First board, "controller" 0, base 10 8000, vector 0e
VECTOR: bustype=VME module=vme_examp adapter=1 ctlr=0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ipl=5 vector=0x0e iospace=(A32NP,0x00108000,32)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exprobe=((w,0x001080000,4,0,0),(r,0x0010801c,4,0,1))
* Second board, "controller" 1, base 10 8020, vector 0f
VECTOR: bustype=VME module=vme_examp adapter=1 ctlr=1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ipl=5 vector=0x0f iospace=(A32NP,0x00108020,32)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exprobe=((w,0x001080020,4,0,0),(r,0x0010803c,4,0,1))
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="49107">Using the exprobe Parameter</TITLE><PARAGRAPH>You use the exprobe= parameter to specify one or more PIO writes and reads to the bus. You can use the parameter to initialize multiple registers, and to test the values in multiple registers before or after writing.</PARAGRAPH>
<PARAGRAPH>The primary purpose of the exprobe parameter is to make the call to a device driver conditional on the presence of the device. When the probe fails because a read did not return the expected value, the kernel assumes the device is not present (or is not operating correctly, or is the wrong type of device), and the kernel does not call the device driver to initialize the device.</PARAGRAPH>
<PARAGRAPH>When you do not specify a probe sequence, the kernel assumes the device exists, and calls the driver to initialize the device. In this case, the driver can be called when no device is present. You must write code into the driver to verify that a device of expected type is actually present on the bus. (See <XREF IDREF="53019" TYPE="TITLE">&ldquo;Verifying Device Addresses&rdquo;</XREF>.)</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="90601">Using the adapter=b Parameter</TITLE><PARAGRAPH>VECTOR statements are processed in two sets, depending on whether or not the adapter=<VARIABLE>b</VARIABLE> parameter is present. The presence or absence of this parameter has an important effect on the scope and timing of device initialization.</PARAGRAPH>
<PARAGRAPH>When you <ITALICS>omit</ITALICS> adapter=<VARIABLE>b</VARIABLE>, the kernel applies the VECTOR statement to <ITALICS>every</ITALICS> VME bus in the system. The exprobe, if one is given, is executed against every VME bus found, as soon as the bus is found. The device driver is called when a probe succeeds on a bus. The driver is called for every bus when no probe is given</PARAGRAPH>
<PARAGRAPH>When you specify adapter=<VARIABLE>b</VARIABLE>, the kernel does not execute the VECTOR statement until after all buses have been found, and <COMMAND>ioconfig</COMMAND> has run to apply numbering to the buses. Then the kernel executes these VECTOR statements, applying each one only to the bus you specify.</PARAGRAPH>
<PARAGRAPH>The differences are that, with adapter=<VARIABLE>b</VARIABLE>, the probe is executed and the driver called only for the specified bus, and this occurs quite a bit later in the startup sequence. It is almost always a better idea to code adapter=<VARIABLE>b</VARIABLE> than to omit it.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Initialization Process</TITLE><PARAGRAPH>Assuming that adapter=<VARIABLE>b</VARIABLE> is supplied, the following steps take place:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The kernel discovers each VME bus and builds a hwgraph vertexes for it.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The <COMMAND>ioconfig</COMMAND> program runs and numbers the buses.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The kernel processes the VECTOR statements.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The kernel executes the specified probes; for example, assuming the first statement in <XREF IDREF="70238" TYPE="TEXT">Example&nbsp;12-1</XREF>, the kernel writes a word of zero to A32NP address 0x0010080000, then reads a word from address 0x001008001c, ANDs the returned data with 1, and compares the result to 0. If the comparison is equal, the device exists.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>When the probe succeeds, the kernel creates <FILENAME>hwgraph</FILENAME> vertices for the device; given <XREF IDREF="70238" TYPE="TEXT">Example&nbsp;12-1</XREF> it might build:</PARAGRAPH>
<CODE>
/hw/module/<VARIABLE>mod</VARIABLE>/slot/io<VARIABLE>n</VARIABLE>/baseio/vme_xtown/pci/7/vmebus/a32n/1008000
/hw/vme/1/a32n/1008000
</CODE>
</BULLET>
<BULLET><PARAGRAPH>The kernel loads the specified device driver (if necessary) and calls it to initialize the device, passing it much of the information from the VECTOR statement.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION3>
</SECTION2>
</SECTION1>
</CHAPTER>
