<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="22"><TITLE><XREFTARGET ID="94967">STREAMS Drivers</TITLE><PARAGRAPH>The IRIX implementation of STREAMS drivers is intended to be compatible with the multiprocessor implementation of STREAMS in UNIX version SVR4.2.<INDEXTARGET ID="21-streams1"><!-- POSTPROCESSDATA: 21-streams1|STREAMS --></PARAGRAPH>
<PARAGRAPH>STREAMS programming in SVR4.2 is documented in <DOCTITLE>STREAMS Modules and Drivers, UNIX SVR4.2</DOCTITLE>. That book contains detailed discussion and many examples of STREAMS programming.</PARAGRAPH>
<PARAGRAPH>References in this chapter to <DOCTITLE>STREAMS Modules and Drivers</DOCTITLE> are to the edition copyright 1992 by UNIX System Laboratories, published by UNIX Press/Prentice-Hall, and bearing ISBN&nbsp;0-13-066879. If you are using an earlier edition, you should upgrade it. If you have a later edition, you may have to interpret references carefully.</PARAGRAPH>
<PARAGRAPH>This chapter contains the following major sections:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="45757" TYPE="TITLE">&ldquo;Driver Exported Names&rdquo;</XREF> summarizes the public names and functions that a STREAMS driver must export.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="18642" TYPE="TITLE">&ldquo;Building and Debugging&rdquo;</XREF> describes the ways that building a STREAMS driver are like and unlike other kernel-level drivers.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="34867" TYPE="TITLE">&ldquo;Special Considerations for Multiprocessing&rdquo;</XREF> describes the methods you must use to work with the multi-threaded STREAMS monitor.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="91783" TYPE="TITLE">&ldquo;Special Considerations for IRIX&rdquo;</XREF> details the points at which IRIX differs from the SVR4 STREAMS environment.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="39006" TYPE="TITLE">&ldquo;Summary of Standard STREAMS Functions&rdquo;</XREF> lists the available kernel functions used by STREAMS drivers.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="88686" TYPE="TITLE">&ldquo;STREAMS Modules for X Input Devices&rdquo;</XREF> describes the use of configuration files for special input devices used by the X display manager.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="45757">Driver Exported Names</TITLE><PARAGRAPH>A STREAMS driver or module must define certain public names for use by <FILENAME>lboot</FILENAME>, as described in <XREF IDREF="90745" TYPE="TITLE">&ldquo;Summary of Driver Structure&rdquo;</XREF>. Only one of these names, the info structure, is unique to a STREAMS driver or module; all the others are also defined by kernel-level device drivers.</PARAGRAPH>
<PARAGRAPH>The public names all begin with a prefix (see <XREF IDREF="72688" TYPE="TITLE">&ldquo;Driver Name Prefix&rdquo;</XREF>); the same prefix is specified in the configuration file (see <XREF IDREF="71839" TYPE="TITLE">&ldquo;Describing the Driver in /var/sysgen/master.d&rdquo;</XREF>).</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="87888">Streamtab Structure </TITLE><PARAGRAPH>A STREAMS driver or module must provide a global <INDEXTARGET ID="21-streams2"><!-- POSTPROCESSDATA: 21-streams2|STREAMS:<VARIABLE>streamtab</VARIABLE> structure --><INDEXTARGET ID="21-streams3"><!-- POSTPROCESSDATA: 21-streams3|entry points:info --><VARIABLE>streamtab</VARIABLE> structure containing pointers to the <VARIABLE>qinit</VARIABLE> structures for its read and write queues. These structures in turn point to required <INDEXTARGET ID="21-streams4"><!-- POSTPROCESSDATA: 21-streams4|STREAMS:<VARIABLE>module_info</VARIABLE> structure --><VARIABLE>module_info</VARIABLE> structures. The name of the streamtab is <VARIABLE>pfx</VARIABLE><FUNCTION>info</FUNCTION>.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="22560">Driver Flag Constant</TITLE><PARAGRAPH>A STREAMS driver or module should provide a driver flag constant containing either 0 or the flag D_MP. (See <INDEXTARGET ID="21-streams5"><!-- POSTPROCESSDATA: 21-streams5|driver:flag constant --><XREF IDREF="67704" TYPE="TITLE">&ldquo;Driver Flag Constant&rdquo;</XREF> and <XREF IDREF="56945" TYPE="TITLE">&ldquo;Flag D_MP&rdquo;</XREF>). The name of the constant is <VARIABLE>pfx</VARIABLE><FUNCTION>devflag</FUNCTION>.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>A driver or module that does not export <VARIABLE>pfx</VARIABLE><FUNCTION>devflag</FUNCTION> is assumed to use SVR3 calling conventions at its <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> and <VARIABLE>pfx</VARIABLE><FUNCTION>close()</FUNCTION> entry points. However, this support will be withdrawn in a release of IRIX in the very near term. If you are porting a STREAMS driver or module to IRIX you are urged to make sure it uses SVR4 conventions and exports a <VARIABLE>pfx</VARIABLE><FUNCTION>devflag</FUNCTION> containing at least 0.</NOTE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="84133">Initialization Entry Points</TITLE><PARAGRAPH>A STREAMS driver or module can define an entry point <INDEXTARGET ID="21-streams6"><!-- POSTPROCESSDATA: 21-streams6|entry points:start --><INDEXTARGET ID="21-streams7"><!-- POSTPROCESSDATA: 21-streams7|entry points:init --><VARIABLE>pfx</VARIABLE><FUNCTION>init()</FUNCTION>, or an entry point <VARIABLE>pfx</VARIABLE><FUNCTION>start()</FUNCTION>, or both. These entry points will be called during boot if the driver or module is included in the kernel, or when the driver or module is loaded if it is loadable. The operation of these entry points is the same as for device drivers (see <XREF IDREF="60095" TYPE="TITLE">&ldquo;Initialization Entry Points&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>Many STREAMS drivers perform all initialization at open time, and have no <VARIABLE>pfx</VARIABLE><FUNCTION>init()</FUNCTION> or <VARIABLE>pfx</VARIABLE><FUNCTION>start()</FUNCTION> entry points. Many STREAMS modules perform initialization when they receive the I_PUSH <FUNCTION>ioctl</FUNCTION> message.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="71515">Entry Point open()</TITLE><PARAGRAPH>A STREAMS driver (but not module) must export a <INDEXTARGET ID="21-streams8"><!-- POSTPROCESSDATA: 21-streams8|STREAMS:open entry point --><INDEXTARGET ID="21-streams9"><!-- POSTPROCESSDATA: 21-streams9|entry points:open --><VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> entry point. The argument list for a STREAMS driver's open differs from that of a device driver. The prototype for a STREAMS <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> entry point is:</PARAGRAPH>
<EXAMPLE>
int&lbreak;<VARIABLE>pfx</VARIABLE>open(queue_t *q, dev_t *devp, int oflag, int sflag, cred_t *crp);
</EXAMPLE>
<PARAGRAPH>The argument values are </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>*q</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Pointer to the <VARIABLE>queue</VARIABLE> structure being opened.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>*devp</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Pointer to a <VARIABLE>dev_t</VARIABLE> value from which you can extract both the major and 
minor device numbers.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>oflag</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Flag bits specifying user mode options on the <FUNCTION>open()</FUNCTION> call.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>sflag</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Flag bits specifying the type of STREAM open: driver, module or clone.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>*crp</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Pointer to a <VARIABLE>cred_t</VARIABLE> object&mdash;an opaque structure for use in authentication.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> entry point is a public name. In addition a pointer to it must be defined in the <VARIABLE>qinit</VARIABLE> structure for the read queue.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Entry Point close()</TITLE><PARAGRAPH>A STREAMS driver (but not module) must export a <INDEXTARGET ID="21-streams10"><!-- POSTPROCESSDATA: 21-streams10|STREAMS:close entry point --><INDEXTARGET ID="21-streams11"><!-- POSTPROCESSDATA: 21-streams11|entry points:close --><VARIABLE>pfx</VARIABLE><FUNCTION>close()</FUNCTION> entry point. The argument list for a STREAMS driver's close differs from that of a device driver. The prototype for a STREAMS <VARIABLE>pfx</VARIABLE><FUNCTION>close()</FUNCTION> entry point is:</PARAGRAPH>
<CODE>
int
<VARIABLE>pfx</VARIABLE>close(queue_t *q, int oflag, cred_t *crp);
</CODE>
<PARAGRAPH>The argument values are the same as passed to <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION>. The <VARIABLE>pfx</VARIABLE><FUNCTION>close()</FUNCTION> entry point is a public name. In addition a pointer to it must be defined in the <VARIABLE>qinit</VARIABLE> structure for the read queue.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="22527">Put Functions wput() and rput()</TITLE><PARAGRAPH>Every STREAMS driver and module must define a <INDEXTARGET ID="21-streams12"><!-- POSTPROCESSDATA: 21-streams12|STREAMS:put functions --><FUNCTION>put()</FUNCTION> function to handle messages as they are delivered to a queue. </PARAGRAPH>
<PARAGRAPH>The prototype of a <FUNCTION>put()</FUNCTION> function is as follows:</PARAGRAPH>
<CODE>
int
<VARIABLE>name</VARIABLE>(queue_t *q, mblk_t *mp);
</CODE>
<PARAGRAPH>Because the <FUNCTION>put()</FUNCTION> function for a given queue is addressed from the associated <VARIABLE>qinit</VARIABLE> structure, there is no requirement that the <FUNCTION>put()</FUNCTION> function be a public name, and no requirement that it begin with the prefix string. The <FUNCTION>put()</FUNCTION> function for the write queue, which handles messages moving &ldquo;downstream&rdquo; from the user process toward the driver, is conventionally called the <FUNCTION>wput()</FUNCTION> function. All write queues need a <FUNCTION>wput()</FUNCTION> function.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>put()</FUNCTION> function for the read queue, which handles messages moving &ldquo;upstream&rdquo; from the driver toward the user process, is conventionally called the <FUNCTION>rput()</FUNCTION> function. In some cases the <FUNCTION>rput()</FUNCTION> function is not required, for example in a driver where all upstream messages are generated by an interrupt handler.</PARAGRAPH>
<PARAGRAPH>Typically, a <FUNCTION>put()</FUNCTION> function decides what to do by switching on the message type value from <FILENAME>mp->b_datap->db_type</FILENAME>. A <FUNCTION>put</FUNCTION> routine must do at least one of the following:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Process the message, if immediate processing is required, consuming the message or transforming it.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Pass the original or processed message to the next component in the stream by calling the <FUNCTION>putnext()</FUNCTION> function (see the <REFPAGE>putnext(D3)</REFPAGE> reference page).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Queue the message for deferred processing by the service routine with the <FUNCTION>putq()</FUNCTION> function (see the <REFPAGE>putq(D3)</REFPAGE> reference page).</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>When all processing is deferred to the service function, the address of the kernel function <FUNCTION>putq()</FUNCTION> can be given as a queue's <FUNCTION>put()</FUNCTION> function.</PARAGRAPH>
<PARAGRAPH>In a multiprocessor, a <FUNCTION>put()</FUNCTION> function can be called concurrently with user-level code, and concurrently with another <FUNCTION>put()</FUNCTION> function for the same or a different queue. A service function for the same or different queue can also be executing concurrently. </PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="85058">Service Functions rsrv() and wsrv()</TITLE><PARAGRAPH>When a STREAMS driver defers message processing by setting the kernel function <INDEXTARGET ID="21-streams13"><!-- POSTPROCESSDATA: 21-streams13|STREAMS:srv functions --><FUNCTION>putq()</FUNCTION> address as the driver's <FUNCTION>put()</FUNCTION> function, the queue must also define a service function <FUNCTION>srv()</FUNCTION>. </PARAGRAPH>
<PARAGRAPH>Because the <FUNCTION>srv()</FUNCTION> function for a given queue is addressed from the associated <VARIABLE>qinit</VARIABLE> structure, there is no requirement that the <FUNCTION>srv()</FUNCTION> function be a public name, and no requirement that it begin with the prefix string.</PARAGRAPH>
<PARAGRAPH>The prototype of a <FUNCTION>svr()</FUNCTION> function is as follows:</PARAGRAPH>
<CODE>
int
<VARIABLE>name</VARIABLE>(queue_t *q);
</CODE>
<PARAGRAPH>The <FUNCTION>srv()</FUNCTION> function for the write queue, which handles messages moving &ldquo;downstream&rdquo; from the user process toward the driver, is conventionally called the <FUNCTION>wsrv()</FUNCTION> function. The <FUNCTION>srv()</FUNCTION> function for the read queue, which handles messages moving &ldquo;upstream&rdquo; from the driver toward the user process, is conventionally called the <FUNCTION>rsrv()</FUNCTION> function.</PARAGRAPH>
<PARAGRAPH>An <FUNCTION>srv()</FUNCTION> function is called by the STREAMS monitor to deal with queued messages. It is called at a time chosen by the monitor, not necessarily related to any call to the <FUNCTION>put()</FUNCTION> function for the same queue. In a multiprocessor, only one instance of <FUNCTION>srv()</FUNCTION> is called per queue at any time. However, one or more instances of the <FUNCTION>put()</FUNCTION> function could execute concurrently with the <FUNCTION>srv()</FUNCTION> function&mdash;so any data that is used in common by <FUNCTION>put()</FUNCTION> and <FUNCTION>srv()</FUNCTION> must be protected with a lock (see <XREF IDREF="14643" TYPE="TITLE">&ldquo;Waiting and Mutual Exclusion&rdquo;</XREF>). User-level code can also execute concurrently with a service function.</PARAGRAPH>
<PARAGRAPH>The service function is expected to dispose of all queued messages through one of the following actions:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Consuming and freeing the message.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Passing the message on to the following queue using <FUNCTION>putnext()</FUNCTION> (see the <REFPAGE>putnext(D3)</REFPAGE> reference page).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Replacing the message on the same queue using <FUNCTION>putbq()</FUNCTION> for processing later (see the <REFPAGE>putbq(D3)</REFPAGE> reference page).</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The service function implements flow control (which the <FUNCTION>put()</FUNCTION> function cannot do). Before applying <FUNCTION>putnext()</FUNCTION>, the service function calls a flow control function such as <FUNCTION>canputnext()</FUNCTION> to find out if the following queue can accept a message. If the following queue cannot accept a message, the service function replaces the message with <FUNCTION>putbq()</FUNCTION> and exits.</PARAGRAPH>
<PARAGRAPH>A STREAMS module or driver that is not multiprocessor-aware (lacks D_MP in its <VARIABLE>pfx</VARIABLE><FUNCTION>devflags</FUNCTION>) uses one set of functions for flow control (see the <REFPAGE>canput(D3)</REFPAGE> and <REFPAGE>bcanputnext(D3)</REFPAGE> reference pages), while one that is multiprocessor-aware uses a different set (see <REFPAGE>canputnext(D3)</REFPAGE> and <REFPAGE>bcanputnext(D3)</REFPAGE>).</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="18642">Building and Debugging</TITLE><PARAGRAPH>A STREAMS driver or module is a kernel module and is compiled using the same compiler options as any driver (see <XREF IDREF="66363" TYPE="TITLE">&ldquo;Compiling and Linking&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>You configure each STREAMS driver or module as part of the IRIX kernel by:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Placing the executable module in <FILENAME>/var/sysgen/boot</FILENAME>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Writing a descriptive file and placing it in <FILENAME>/var/sysgen/master.d</FILENAME> (see <XREF IDREF="71839" TYPE="TITLE">&ldquo;Describing the Driver in /var/sysgen/master.d&rdquo;</XREF>)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Placing a USE or INCLUDE line in <FILENAME>/var/sysgen/system</FILENAME> (see <XREF IDREF="98580" TYPE="TITLE">&ldquo;Configuring a Kernel&rdquo;</XREF>)</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>When a STREAMS driver or module is loadable, you specify the appropriate options in the descriptive file (see <XREF IDREF="36166" TYPE="TITLE">&ldquo;Master File for Loadable Drivers&rdquo;</XREF>). You can configure a STREAMS driver or module to be autoregistered and loaded automatically (see <XREF IDREF="88940" TYPE="TITLE">&ldquo;Registration&rdquo;</XREF>). Alternatively, you can require a STREAMS driver or module to be loaded manually using the <COMMAND>ml</COMMAND> command (see <XREF IDREF="36255" TYPE="TITLE">&ldquo;Loading&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>When you have configured a debugging kernel (see <XREF IDREF="86033" TYPE="TITLE">&ldquo;Preparing the System for Debugging&rdquo;</XREF>), the symbols of a STREAMS driver or module are available for display. You can set breakpoints using <COMMAND>symmon</COMMAND> (see <XREF IDREF="82218" TYPE="TITLE">&ldquo;Using symmon&rdquo;</XREF>). You can display symbols using <COMMAND>symmon</COMMAND> or <COMMAND>idbg</COMMAND> (see <XREF IDREF="98041" TYPE="TITLE">&ldquo;Using idbg&rdquo;</XREF>). In particular, <COMMAND>idbg</COMMAND> has built-in support for displaying the contents of structures used by a STREAMS module or driver (see <XREF IDREF="31155" TYPE="TITLE">&ldquo;Commands to Display STREAMS Structures&rdquo;</XREF>).</PARAGRAPH>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="34867">Special Considerations for Multiprocessing </TITLE><PARAGRAPH>In IRIX releases prior to 6.2, the STREAMS monitor was single-threaded, so that only one <INDEXTARGET ID="21-streams14"><!-- POSTPROCESSDATA: 21-streams14|STREAMS:multiprocessor design --><INDEXTARGET ID="21-streams15"><!-- POSTPROCESSDATA: 21-streams15|multiprocessor:driver design for --><FUNCTION>put()</FUNCTION> or <FUNCTION>srv()</FUNCTION> function in the entire system could execute at any time. That one <FUNCTION>put()</FUNCTION> or <FUNCTION>srv()</FUNCTION> function might execute concurrently with user-level code, but no two STREAMS functions could execute concurrently.</PARAGRAPH>
<PARAGRAPH>Beginning with IRIX 6.2, the STREAMS monitor is multi-threaded. Depending on the version of IRIX and on the number of CPUs in the system, the following functions can run concurrently in any combination: one <INDEXTARGET ID="21-streams16"><!-- POSTPROCESSDATA: 21-streams16|STREAMS:multithreaded monitor --><FUNCTION>srv()</FUNCTION> function for each queue; any number of <FUNCTION>put()</FUNCTION> functions for each queue; and one or more user processes. For general discussion of the consequences, see <XREF IDREF="32791" TYPE="TITLE">&ldquo;Designing for Multiprocessor Use&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>In the multithreaded monitor, when a module or driver calls <FUNCTION>putq()</FUNCTION> or <FUNCTION>qenable()</FUNCTION>, the service function for the enabled queue can begin to execute at any time. It can begin execution before the <FUNCTION>putq()</FUNCTION> or <FUNCTION>qenable()</FUNCTION> call has returned, and can run concurrently with the module or driver that enabled the queue.</PARAGRAPH>
<PARAGRAPH>The STREAMS monitor runs concurrently with interrupt handling. For this reason, the interrupt handler of a STREAMS driver must take an extra step before it performs any STREAMS-related processing such as <FUNCTION>allocb()</FUNCTION>, <FUNCTION>putq()</FUNCTION>, or <FUNCTION>qenable()</FUNCTION>. The IRIX-unique functions provided for this purpose are summarized in <XREF IDREF="47530" TYPE="TABLE">Table&nbsp;22-1</XREF>.</PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="22-1"><PREFIX>Table 22-1 </PREFIX><XREFTARGET ID="47530">Multiprocessing STREAMS Functions</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="125"><PARAGRAPH>Name</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="50"><PARAGRAPH>Can Sleep?</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="219"><PARAGRAPH>Summary</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="125"><PARAGRAPH><REFPAGE>streams_interrupt(D3)</REFPAGE></PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="219"><PARAGRAPH>Synchronize interrupt-level function with STREAMS 
mechanism.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="125"><PARAGRAPH><REFPAGE>STREAMS_TIMEOUT(D3)</REFPAGE></PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="219"><PARAGRAPH>Synchronize timeout with STREAMS mechanism.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Suppose that the interrupt handler of a STREAMS driver needs to add a message to the read queue with <FUNCTION>putq()</FUNCTION>. It cannot simply call that function, since the STREAMS monitor might be using the queue at the same time in another CPU. The driver must define a function in which the <FUNCTION>putq()</FUNCTION> call is written. The name of this function and the pointer to the queue are passed to <FUNCTION>streams_interrupt()</FUNCTION>. As soon as possible, <FUNCTION>streams_interrupt()</FUNCTION> gets control of the queue and executes the passed function.</PARAGRAPH>
<PARAGRAPH>A callback function scheduled using <FUNCTION>itimeout()</FUNCTION> and similar functions (see <XREF IDREF="56199" TYPE="TITLE">&ldquo;Waiting for Time to Pass&rdquo;</XREF>) must also be synchronized with the STREAMS monitor.</PARAGRAPH>
<PARAGRAPH>Suppose that a STREAMS driver or module needs to schedule a function to execute at a later time. (In a nonSTREAMS driver the function would be scheduled with <FUNCTION>itimeout()</FUNCTION>.) In the time-delayed function is a call to <FUNCTION>qenable()</FUNCTION>. That call cannot be executed freely whenever the interval expires, because the state of the STREAMS monitor is not known at that time.</PARAGRAPH>
<PARAGRAPH>The STREAMS_TIMEOUT macros provide a solution. Like <FUNCTION>itimeout()</FUNCTION>, it schedules a function to be executed at a later time. However, it defers calling the function until the function is synchronized with the STREAMS monitor, so that it can execute calls such as <FUNCTION>qenable()</FUNCTION>. </PARAGRAPH>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="98261">Expanded Termio Interface</TITLE><PARAGRAPH>Beginning in IRIX 6.3, the <VARIABLE>termio</VARIABLE> and <VARIABLE>termios</VARIABLE> structures (defined in the header files <FILENAME>termio.h</FILENAME> and <FILENAME>termios.h</FILENAME>) are expanded with two additional fields. These data structures are documented in the <REFPAGE>termio(7)</REFPAGE> reference page.</PARAGRAPH>
<PARAGRAPH>In order to ensure forward compatibility for user programs, the original structures are still supported at the level of the user process. The <REFPAGE>termio(7)</REFPAGE> reference page contains a discussion of how to ensure continued compilation of the old structure, under the heading &ldquo;Mixing old and new interfaces.&rdquo;</PARAGRAPH>
<PARAGRAPH>Some STREAMS drivers may use the <VARIABLE>termios</VARIABLE> structure as an argument of an ioctl message. The STREAMS head, when processing an ioctl message that is known to take a <VARIABLE>termio</VARIABLE> structure, always converts the old (pre-6.3) structure to the new format. As a result, STREAMS drivers that process standard ioctl messages must be prepared to use the new structure. This is largely a matter of recompiling, because the names and types of the fields in the old structure are unchanged in the new structure.</PARAGRAPH>
<PARAGRAPH>STREAMS drivers that define and implement their own unique ioctl messages, and which take a termios structure as an argument of the ioctl, must be prepared to receive either the old termios format or the new one, depending on whether or not the user program has been recompiled on the current system.</PARAGRAPH>
<PARAGRAPH>The prinicipal difference between the old and new structures, and the reason for the change, is that input and output baud rates are no longer encoded in a few bits, but are represented as integer fields. This permits specification of a much wider range of rates.</PARAGRAPH>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="91783">Special Considerations for IRIX</TITLE><PARAGRAPH>While IRIX is largely compatible with UNIX SVR4.2, there are points of difference in the implementation of IRIX that have to be reflected in the design of a STREAMS driver or module. This topic lists points at which the contents of <DOCTITLE>STREAMS Modules and Drivers, UNIX SVR4.2</DOCTITLE> is not a correct description of IRIX and STREAMS use within IRIX.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="65511">Extension of Poll and Select</TITLE><PARAGRAPH>Under IRIX, the <INDEXTARGET ID="21-streams17"><!-- POSTPROCESSDATA: 21-streams17|STREAMS:extended poll support --><FUNCTION>poll()</FUNCTION> system function is not limited to testing STREAMS, but can be applied to file descriptors of all types (see the <REFPAGE>poll(2)</REFPAGE> and <REFPAGE>select(2)</REFPAGE> reference pages). In addition the <FUNCTION>select()</FUNCTION> function can be applied to STREAMS file descriptors. You may want to note this under the heading &ldquo;STREAMS System Calls&rdquo; in Chapter 2 of <DOCTITLE>STREAMS Modules and Drivers, UNIX SVR4.2</DOCTITLE>.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="18598">Support for Pipes</TITLE><PARAGRAPH>IRIX supports two kinds of pipes with different semantics, as described in the <INDEXTARGET ID="21-streams18"><!-- POSTPROCESSDATA: 21-streams18|pipe semantics --><REFPAGE>pipe(2)</REFPAGE> reference page. The default type of pipe is compatible with UNIX SVR3, and does not conform to the description in Chapter 2 of <DOCTITLE>STREAMS Modules and Drivers, UNIX SVR4.2</DOCTITLE> under the heading &ldquo;Creating a STREAMS-based Pipe.&rdquo;</PARAGRAPH>
<PARAGRAPH>The SVR4 pipe semantics are enabled on a system-wide basis by using the <COMMAND>systune</COMMAND> command to set the tuning parameter <VARIABLE>svr3pipe</VARIABLE> to 0. First test the configuration as shown in <XREF IDREF="47857" TYPE="TEXT">Example&nbsp;22-1</XREF>.</PARAGRAPH>
<CODE><CAPTION LBL="22-1"><PREFIX>Example 22-1 </PREFIX><XREFTARGET ID="47857">Testing Pipe Configuration</CAPTION># systune | grep svr3pipe
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;svr3pipe = 1 (0x1)
</CODE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="92878">Service Scheduling</TITLE><PARAGRAPH>At two points in <INDEXTARGET ID="21-streams19"><!-- POSTPROCESSDATA: 21-streams19|STREAMS:service scheduling --><DOCTITLE>STREAMS Modules and Drivers, UNIX SVR4.2</DOCTITLE> (Under &ldquo;Service Procedure&rdquo; in Chapter 4 and under &ldquo;Message Processing&rdquo; in Chapter 5), the book explicitly says that in a uniprocessor, enabled service functions are always executed before returning to user-level processing. This promise is not supported by IRIX. In both uniprocessors and multiprocessors, user-level processes can potentially execute after a service function is enabled and before it executes.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="18131">Supplied STREAMS Modules</TITLE><PARAGRAPH><DOCTITLE>STREAMS Modules and Drivers, UNIX SVR4.2</DOCTITLE>, Chapter 4, refers to some example STREAMS drivers named CHARPROC, CANONPROC, and ASCEBC. These examples are not supplied with IRIX.</PARAGRAPH>
<PARAGRAPH>The following STREAMS-based modules are supplied with IRIX. You can read their reference pages in volume 7: <INDEXTARGET ID="21-streams20"><!-- POSTPROCESSDATA: 21-streams20|STREAMS:supplied drivers --></PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>alp(7)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="315"><PARAGRAPH>Algorithm pool management module.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>clone(7)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="315"><PARAGRAPH>Clone-open driver; see <XREF IDREF="32390" TYPE="TITLE">&ldquo;Support for CLONE Drivers&rdquo;</XREF>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>connld(7)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="315"><PARAGRAPH>Line discipline for unique stream connections.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>kbd(7)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="315"><PARAGRAPH>Generalized string translation module.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>log(7)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="315"><PARAGRAPH>Interface to STREAMS error logging and event tracing.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>sad(7)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="315"><PARAGRAPH>STREAMS Administrative Driver.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>streamio(7)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="315"><PARAGRAPH>STREAMS ioctl commands.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>timod(7)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="315"><PARAGRAPH>Transport Interface cooperating STREAMS module.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>tirdwr(7)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="315"><PARAGRAPH>Transport Interface read/write interface STREAMS module.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><REFPAGE>tsd(7)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="315"><PARAGRAPH>TELNET server protocol STREAMS device.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>No #idefs</TITLE><PARAGRAPH>Chapter 4 of <DOCTITLE>STREAMS Modules and Drivers, UNIX SVR4.2</DOCTITLE> refers in a note to the use of the #idef and a transition period for SVR3-compatible drivers. None of this material is relevant to IRIX. IRIX is SVR4-compatible, with no special provision for SVR3 drivers.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Different I/O Hardware Model</TITLE><PARAGRAPH>Chapter 5 of <DOCTITLE>STREAMS Modules and Drivers, UNIX SVR4.2</DOCTITLE> discusses the use of memory-mapped hardware and of Dual-Access RAM (DARAM). None of these considerations are relevant in a MIPS processor. The MIPS I/O model is discussed in <XREF IDREF="24376" TYPE="TITLE">Chapter&nbsp;1, &ldquo;Physical and Virtual Memory.&rdquo;</XREF></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Different Network Model</TITLE><PARAGRAPH>Chapter 10 of <DOCTITLE>STREAMS Modules and Drivers, UNIX SVR4.2 </DOCTITLE>describes the TPI interface model. This model is supported in IRIX. When an application uses the TLI library functions such as <FUNCTION>t_open()</FUNCTION>, the library uses IRIX-provided TPI STREAMS modules which implement the protocol described in chapter 10.</PARAGRAPH>
<PARAGRAPH>Chapter 11 of <DOCTITLE>STREAMS Modules and Drivers, UNIX SVR4.2</DOCTITLE> describes the Data Link Provider Interface (DLPI) as implemented using STREAMS facilities.</PARAGRAPH>
<PARAGRAPH>The IRIX networking support is not STREAMS-based, but rather is based on BSD <COMMAND>ifnet</COMMAND> architecture. This is discussed in <XREF IDREF="12931" TYPE="TITLE">Chapter&nbsp;17, &ldquo;Network Device Drivers.&rdquo;</XREF> The IRIX network support includes DLPI support as an add-on feature to the <VARIABLE>ifnet</VARIABLE> driver interface. If you are porting a network device driver to IRIX, it is better to convert it to the <COMMAND>ifnet</COMMAND> interface. You can install a DLPI-based network device driver, but only other STREAMS modules could use it&mdash;there would be no connection to the rest of the IRIX networking system.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="32390">Support for CLONE Drivers</TITLE><PARAGRAPH><INDEXTARGET ID="21-streams21"><!-- POSTPROCESSDATA: 21-streams21|STREAMS:clone driver --><DOCTITLE>STREAMS Modules and Drivers, UNIX SVR4.2</DOCTITLE> discusses CLONE drivers; that is, STREAMS drivers that generate a new minor device number for each open. Refer to Chapter 3, &ldquo;The CLONE Driver,&rdquo; and to Chapter 8, &ldquo;Cloning.&rdquo; Clone opens and the clone driver are implemented under IRIX. This section clarifies the discussion in the SVR4 manual.</PARAGRAPH>
<PARAGRAPH>The essence of cloned access to a STREAMS driver is that the user process is indifferent to the minor device number, and simply wants to open a stream from this driver. A cloned stream is created using the following steps:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Recognize that the process calling <FUNCTION>open()</FUNCTION> is indifferent to the minor device number and simply wants cloned access.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Choose an unused minor device number from the set of minor numbers the driver supports.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Construct a new device number <VARIABLE>dev_t</VARIABLE> value based on the chosen minor number, and assign it to the argument passed to <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION>.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<SECTION3 LBL="" HELPID = ""><TITLE>Using the CLONE Driver</TITLE><PARAGRAPH>The IRIX-supplied clone driver automates some of these steps for your driver. In order to use it, prepare a device special file with these characteristics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>A device name that is related to the actual device name</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The major device number (10 decimal) that specifies the clone driver<INDEXTARGET ID="21-streams22"><!-- POSTPROCESSDATA: 21-streams22|major device number:for STREAMS clone --></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A minor device number equal to the major number of the actual driver<INDEXTARGET ID="21-streams23"><!-- POSTPROCESSDATA: 21-streams23|minor device number:for STREAMS clone driver --></PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>You can view the descriptive file for the clone driver in <FILENAME>/var/sysgen/master.d/clone</FILENAME>. This file sets its major number (10) and states that it is not loadable. Although the clone driver is not specifically configured in the <FILENAME>/var/sysgen/system/irix.sm</FILENAME> file, it is included in any kernel because it is listed as a dependency in the descriptive file of several other drivers (use <COMMAND>fgrep clone /var/sysgen/master.d/*</COMMAND> to see which drivers depend on it; and see <XREF IDREF="15136" TYPE="TITLE">&ldquo;Listing Dependencies&rdquo;</XREF>). You can specify it as a dependency in the same way, if your driver depends on it.</PARAGRAPH>
<PARAGRAPH>When a user process opens a device special file with the major number of the clone driver, the kernel naturally calls the clone driver's open entry point. The clone driver verifies that the minor number passed is the major number of an existing, STREAMS driver. (If it is not, the clone driver returns ENXIO).</PARAGRAPH>
<PARAGRAPH>The clone driver sets up the <VARIABLE>qinit</VARIABLE> structure appropriately for the target driver's queue and calls that driver's <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> entry point, passing the CLONEOPEN flag in the <VARIABLE>sflag</VARIABLE> argument (see <XREF IDREF="71515" TYPE="TITLE">&ldquo;Entry Point open()&rdquo;</XREF>).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Recognizing a Clone Request Independently</TITLE><PARAGRAPH>It is not essential to use the clone driver. You can instead designate a particular minor device number to stand for &ldquo;clone open.&rdquo; You prepare a device special file with these characteristics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>A device name related to the actual device name</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The major number of your driver<INDEXTARGET ID="21-streams24"><!-- POSTPROCESSDATA: 21-streams24|major device number:for STREAMS clone --></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Some minor number you define to mean &ldquo;clone open&rdquo; <INDEXTARGET ID="21-streams25"><!-- POSTPROCESSDATA: 21-streams25|minor device number:for STREAMS clone driver --></PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>When a user process opens this device special file, the kernel calls the <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> entry point of your driver. It does not pass the CLONEOPEN flag in <VARIABLE>sflag</VARIABLE>, but your driver can recognize a request for a clone open based on the minor device number.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Responding to a Clone Request</TITLE><PARAGRAPH>In response to a clone request coming from either of the two methods described, your <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> entry point must select an unused minor device number. (If no minor number is available, return EBUSY.)</PARAGRAPH>
<PARAGRAPH>Text in Chapter 3 of <DOCTITLE>STREAMS Modules and Drivers, UNIX SVR4.2</DOCTITLE> seems to suggest that your driver should scan through the kernel's <VARIABLE>cdevsw</VARIABLE> table to find an unused minor number (see <XREF IDREF="35727" TYPE="TITLE">&ldquo;Kernel Switch Tables&rdquo;</XREF>). Under IRIX, the <VARIABLE>cdevsw</VARIABLE> table is not accessible to drivers. The reason is that the table layout differs between 32-bit and 64-bit kernels, and can change between releases. Instead, your driver must know the minor numbers that it supports, and must know which ones are currently in use.</PARAGRAPH>
<TIP><PREFIX>Tip</PREFIX>You can design your driver so that the number of supported devices is specified in the descriptive file in <FILENAME>/var/sysgen/master.d</FILENAME>, and passed in to the driver through that descriptive file (see <XREF IDREF="54399" TYPE="TITLE">&ldquo;Variables Section&rdquo;</XREF>). Your driver can allocate and initialize an array of device information structures in its <VARIABLE>pfx</VARIABLE><FUNCTION>init()</FUNCTION> entry point.</TIP>
<PARAGRAPH>Your driver constructs a new <VARIABLE>dev_t</VARIABLE> value, specifying its major number and the selected minor number. The <FUNCTION>makedevice()</FUNCTION> function is used for this (see the <REFPAGE>makedevice(D3)</REFPAGE> reference page, which has some sample code for use in a clone open). The new <VARIABLE>dev_t</VARIABLE> value is stored into the <VARIABLE>*devp</VARIABLE> argument passed to <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION>. </PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="39006">Summary of Standard STREAMS Functions</TITLE><PARAGRAPH>The supported kernel functions for STREAMS operations are summarized for reference in <INDEXTARGET ID="21-streams26"><!-- POSTPROCESSDATA: 21-streams26|STREAMS:function summarySTREAMS:AAA --><XREF IDREF="58252" TYPE="TABLE">Table&nbsp;22-2</XREF>. To declare the necessary prototypes and data types, include <FILENAME>sys/types</FILENAME>.h and <FILENAME>sys/stream.h</FILENAME>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="22-2"><PREFIX>Table 22-2 </PREFIX><XREFTARGET ID="58252"> <EMPHASIS>(continued)        </EMPHASIS>Kernel Entry Points</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="109"><PARAGRAPH>Name</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>Can Sleep?</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Summary</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>adjmsg(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Trim bytes from a message.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>allocb(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Allocate a message block.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>bcanput(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Test for flow control in a specified priority band.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>bcanputnext(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Test for flow control in a specified priority band.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>bufcall(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Call a function when a buffer becomes available.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>canput(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Test for room in a message queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>canputnext(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Test for room in a message queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>copyb(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Copy a message block.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>copymsg(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Copy a message.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>datamsg(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Test whether a message is a data message.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>dupb(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Duplicate a message block.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>dupmsg(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Duplicate a message.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>enableok(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Allow a queue to be serviced.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>esballoc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Allocate a message block using an externally-supplied 
buffer.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>esbbcall(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Call a function when an externally-supplied buffer can 
be allocated.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>flushband(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Flush messages in a specified priority band.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>flushq(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Flush messages on a queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>freeb(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Free a message block.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>freemsg(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Free a message.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>freezestr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Freeze the state of a stream.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>getq(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Get the next message from a queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>insq(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Insert a message into a queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>linkb(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Concatenate two message blocks.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>msgdsize(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Return number of bytes of data in a message.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>msgpullup(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Concatenate bytes in a message.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>noenable(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Prevent a queue from being scheduled.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>OTHERQ(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Get a pointer to queue's partner queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>pcmsg(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Test whether a message is a priority control message.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>pullupmsg(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Concatenate bytes in a message.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>putbq(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Place a message at the head of a queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>putctl(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Send a control message to a queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>putctl1(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Send a control message with a one-byte parameter to a 
queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>putnext(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Send a message to the next queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>putnextctl(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Send a control message to a queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>putnextctl1(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Send a control message with a one-byte parameter to a 
queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>putq(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Put a message on a queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>qenable(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Schedule a queue's service routine to be run.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>qprocsoff(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>Y</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Enable put and service routines.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>qprocson(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>Y</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Disable put and service routines</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>qreply(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Send a message in the opposite direction in a stream.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>qsize(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Find the number of messages on a queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>RD(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Get a pointer to the read queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>rmvb(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Remove a message block from a message.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>rmvq(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Remove a message from a queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>SAMESTR(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Test if next queue is of the same type.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>strqget(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Get information about a queue or band of the queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>strqset(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Change information about a queue or band of the queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>unbufcall(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Cancel a pending bufcall request.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>unfreezestr(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Unfreeze the state of a stream.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>unlinkb(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Remove a message block from the head of a message.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="109"><PARAGRAPH><REFPAGE>WR(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="50"><PARAGRAPH>N</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="227"><PARAGRAPH>Get a pointer to the write queue.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="88686">STREAMS Modules for X Input Devices</TITLE><PARAGRAPH>The Silicon Graphics, Inc. implementation of the X display manager, <COMMAND>Xsgi</COMMAND>, is a customized version of the MIT X11 Sample Server. Besides other enhancements such as integration with Silicon Graphics proprietary graphics subsystems, <COMMAND>Xsgi</COMMAND> implements a generalized input subsystem so that unusual input devices can easily be integrated into the X window system. The input system is based on STREAMS modules.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>The X Input Subsystem</TITLE><PARAGRAPH>While X mandates that every X server support a keyboard and mouse, there is no standard system interface for accessing such devices on UNIX systems. This means each vendor has its own input subsystem for its X server. Silicon Graphics' input subsystem not only meets the basic requirement to support a keyboard and mouse but also has the following features: </PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>A shared memory input queue is supported for high performance</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A wide variety of input devices is supported, including 3D devices such as the Spaceball</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Input devices are supported abstractly; knowledge of specific input devices is isolated to modular kernel-level device drivers</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Hardware cursor tracking is supported in the kernel</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>These features provide a more functional, responsive input subsystem than that available in the MIT Sample Server.</PARAGRAPH>
<PARAGRAPH>The programming interface to the input subsystem from the X client API is covered in the <DOCTITLE>X11 Input Extension Library Specification</DOCTITLE>, an online book that is distributed with the IRIX Developer's Option.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>Numerous code examples demonstrating the X input system are available in the X developer component (x_dev component) of the IRIX Developer Option. Source for STREAMS modules to integrate a Spaceball, a dial-and-button box, and other devices can be found in subdirectories of <FILENAME>/usr/share/src/X</FILENAME>.</NOTE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Shared Memory Input Queue</TITLE><PARAGRAPH>A shared memory input queue (called a <ITALICS>shmiq</ITALICS> in Silicon Graphics code comments, and pronounced &ldquo;shmick&rdquo;) is a fast way of receiving input device events by eliminating the filesystem overhead to receive data from input devices. Instead of the X server reading the input devices through file descriptors, a kernel-level driver deposits input events directly into a region of the X server's address space, organized as a ring buffer.</PARAGRAPH>
<PARAGRAPH>The IRIX shmiq device driver is implemented as a STREAMS multiplexor. This allows an arbitrary number of input sources (in the form of STREAMS modules) to be linked to it so all input sources are funneled through the shmiq.</PARAGRAPH>
<PARAGRAPH>In addition to processing input events from input device modules, the schmiq driver also processes events from the graphics subsystem, and updates the screen cursor position. This allows smooth cursor movement since cursor positioning is done in kernel code, without <COMMAND>Xsgi</COMMAND> involvement.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>IDEV Interface</TITLE><PARAGRAPH>X input devices are integrated into the shmiq driver by implementing STREAMS modules that translate raw device input into abstract events which are sent to the shmiq driver (and on to the server). For example, an input device that connects to a serial port can be integrated in the form of a STREAMS module that is pushed onto the stream from that serial device, and translates incoming bytes into event messages.</PARAGRAPH>
<PARAGRAPH>The shmiq driver expects messages from all input devices to be in the form of IDEV events, as documented in the <FILENAME>/usr/include/sys/idev.h</FILENAME> header file; hence this is called the IDEV interface. IDEV device events appear as valuator, button, and pointer state changes.</PARAGRAPH>
<PARAGRAPH>The IDEV interface defines two-way communications between the input device and <COMMAND>Xsgi</COMMAND>. Besides the uniform set of IDEV input events, the interface defines a standard set of abstract commands that <COMMAND>Xsgi</COMMAND> can send down (using IOCTL messages) to initialize and control input devices. This allows the server to see input devices as abstract input sources and does not require special server code to be written every time a new input device is supported. Instead, device specific knowledge of each devices is encapsulated in an IDEV-based STREAMS module linked into the kernel.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Input Device Naming</TITLE><PARAGRAPH><COMMAND>Xsgi</COMMAND> recognizes as input devices, any device special files named in the <FILENAME>/dev/input</FILENAME> directory. On a machine with graphics, this includes <FILENAME>/dev/input/keyboard</FILENAME> and <FILENAME>/dev/input/mouse</FILENAME>. (A server-type machine without graphics typically has no names in <FILENAME>/dev/input</FILENAME>.) Other input devices that are to be integrated into the IDEV interface must also appear as symbolic links in <FILENAME>/dev/input</FILENAME>.</PARAGRAPH>
<PARAGRAPH>Typically an X input device is defined as a link from <FILENAME>/dev/input</FILENAME> to some other device special file, typically a serial port in the <FILENAME>/hw/ttys/tty*</FILENAME> group. The filename in <FILENAME>/dev/input</FILENAME> determines the name of the STREAMS module that is used to interface that device to the IDEV input system. For example, if the file is <FILENAME>/dev/input/calcomp</FILENAME>, the <FILENAME>calcomp</FILENAME> STREAMS module is loaded and pushed onto the stream from the device.</PARAGRAPH>
<PARAGRAPH>When a single STREAMS module is used to support two or more devices, you can use a hyphen-digit suffix on the filename. For example, the <FILENAME>calcomp</FILENAME> STREAMS module would be used for both <FILENAME>/dev/input/calcomp-1</FILENAME> and <FILENAME>/dev/input/calcomp-2</FILENAME>.</PARAGRAPH>
<PARAGRAPH>When a device is initialized (as described in the next section), the STREAMS module is asked to return the X name of the input device. This name can be the same as the name of the device and the module, or it can be different. Typically the device and module names will reflect the hardware type (for example <FILENAME>calcomp</FILENAME>), while the X name reflects the kind of device (for example <FILENAME>tablet</FILENAME>).</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="94289">Opening Input Devices</TITLE><PARAGRAPH>An input device is opened at one of two times: when the X server starts up, and when an X client requests an open.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Starting Up the Server</TITLE><PARAGRAPH>When <COMMAND>Xsgi</COMMAND> starts up, it opens each device name in <FILENAME>/dev/input</FILENAME> and for each one it:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Loads a STREAMS module that has the same name as the name of the device special file, and pushes it onto the stream from the device, below the shmiq multiplexor.</PARAGRAPH>
<PARAGRAPH>The STREAMS module may be loadable, and most IDEV modules are loadable.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Looks for a file in <FILENAME>/usr/lib/X11/input/config</FILENAME> having the same name as the module. The device controls in that file are sent down the stream as IOCTL messages.</PARAGRAPH>
<PARAGRAPH>The format of device controls is discussed under <XREF IDREF="27290" TYPE="TITLE">&ldquo;Device Controls&rdquo;</XREF>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Asks the device to describe itself. This is done by sending down an IOCTL message of the type IDEVDESC. The module must return the IOCTL message with descriptive data.</PARAGRAPH>
<PARAGRAPH>The IDEV IOCTL structures are declared in <FILENAME>/usr/include/sys/idev.h</FILENAME>. A key element of the device description is the X name of the input device.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Looks for a file in <FILENAME>/usr/lib/X11/input/config</FILENAME> having the X name of the device as returned in the device description. The X init controls in this file are processed by the X server.</PARAGRAPH>
<PARAGRAPH>The format of X init controls is discussed under <XREF IDREF="27290" TYPE="TITLE">&ldquo;Device Controls&rdquo;</XREF>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Unless autostart was specified for this device, the device is closed.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="96063">Opening from a Client</TITLE><PARAGRAPH>An X application can use the <FUNCTION>XListInputDevices()</FUNCTION> function to get a list of available input devices. Then it can call <FUNCTION>XOpenDevice()</FUNCTION> to open a selected device, so that input events from that device will be processed by the X server (see the <REFPAGE>XListInputDevices(3X)</REFPAGE> and <REFPAGE>XOpenDevice(3X)</REFPAGE> reference pages).</PARAGRAPH>
<PARAGRAPH>When <FUNCTION>XOpenDevice()</FUNCTION> is called for an input device that is not already open, it repeats the process done at startup time:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Loads the STREAMS module and pushes it on the device stream, feeding the shmiq multiplexor.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Sends device controls from a file in <FILENAME>/usr/lib/X11/input/config</FILENAME> having the same name as the module.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Asks the device (module) to describe itself, including the X name of the device.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Processes X init controls from a file in <FILENAME>/usr/lib/X11/input/config</FILENAME> having the X name of the device.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="27290">Device Controls</TITLE><PARAGRAPH>Device controls are string values that are passed via an IOCTL message to the STREAMS module for an input device at the time the device is opened. You can use device controls as a way of configuring the device module at runtime. Device controls are interpreted only by the module.</PARAGRAPH>
<PARAGRAPH>X init controls have the same syntax as device controls, but are processed by the X server after the device has been initialized.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Where Controls Are Stored</TITLE><PARAGRAPH>You can issue X server device controls on the fly by calling <FUNCTION>XSGIDeviceControl</FUNCTION> from within a program, or by storing them in configuration files in the <FILENAME>/usr/lib/X11/input/config</FILENAME> directory. Specific documentation on controls can be found in <FILENAME>/usr/lib/X11/input/config/README</FILENAME>.</PARAGRAPH>
<PARAGRAPH>There are (potentially) two configuration files per device. As noted under <XREF IDREF="94289" TYPE="TITLE">&ldquo;Opening Input Devices&rdquo;</XREF>, the X server looks for device controls in a file with the same name as the STREAMS module that implements the device. After the module returns the X name of the device, the X server looks for X init controls in a file with the X name of the device.</PARAGRAPH>
<PARAGRAPH>Some devices use the same name for the STREAMS module and for the X device (<FILENAME>tablet</FILENAME>, <FILENAME>mouse</FILENAME>), but some use different names for the two. For example, the STREAMS module for the Spaceball device is <FILENAME>sball</FILENAME>, while the X name is <FILENAME>spaceball</FILENAME>. </PARAGRAPH>
<PARAGRAPH>The X server intercepts about a dozen <FUNCTION>x_init</FUNCTION> controls. For a list of the <FUNCTION>x_init</FUNCTION> controls and some of the more common <FUNCTION>device_init</FUNCTION> controls, see the file </PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Control Syntax</TITLE><PARAGRAPH>When the X server opens a file to look for device controls, it searches the file for a single set of controls with the following format:</PARAGRAPH>
<CODE>
device_init {
&nbsp;&nbsp;&nbsp;<VARIABLE>name</VARIABLE>&nbsp;&nbsp;&nbsp;"<VARIABLE>value</VARIABLE>"
&nbsp;&nbsp;&nbsp;...
}
</CODE>
<PARAGRAPH>Each <VARIABLE>name</VARIABLE> may have at most 15 characters. Each <VARIABLE>value</VARIABLE> may have at most 23 characters. Each pair of name and value are put in an IOCTL message of <VARIABLE>idevOtherControl</VARIABLE> type and sent down to the device module for interpretation.</PARAGRAPH>
<PARAGRAPH>When the X server opens a file to look for X init controls, it searches the file for a single set of controls with the following format:</PARAGRAPH>
<CODE>
x_init {
&nbsp;&nbsp;&nbsp;<VARIABLE>name</VARIABLE>&nbsp;&nbsp;&nbsp;"<VARIABLE>value</VARIABLE>"
&nbsp;&nbsp;&nbsp;...
}
</CODE>
<PARAGRAPH>The syntax is the same, except for the use of x_init instead of device_init.</PARAGRAPH>
<PARAGRAPH>The specific <VARIABLE>name</VARIABLE> and <VARIABLE>value</VARIABLE> strings that the X server supports are documented in the file <FILENAME>/usr/lib/X11/input/config/README</FILENAME>. Any <VARIABLE>name</VARIABLE> strings that are not recognized by the X server are sent down to the device module, just as if they were device controls.</PARAGRAPH>
<PARAGRAPH></PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
</CHAPTER>
