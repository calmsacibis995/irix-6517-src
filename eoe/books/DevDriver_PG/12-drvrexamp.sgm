<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="11"><TITLE><XREFTARGET ID="88380">Driver Example</TITLE><PARAGRAPH>This chapter displays the code of a complete device driver. The driver has no hardware dependencies, so it can be used for experimentation in any IRIX 6.5 system.<INDEXTARGET ID="12-drvrexamp1"><!-- POSTPROCESSDATA: 12-drvrexamp1|example driver --></PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>This driver is not intended to have a practical use, and it should not be installed in a production system.</NOTE>
<PARAGRAPH>The example driver has the following purposes:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>You can use it as an experimental animal with the <COMMAND>symmon</COMMAND> and <COMMAND>idbg</COMMAND> debugging tools.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>You can use it to experiment with loading and unloading a driver.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>You can modify the source code and use it to try out different kernel function calls, especially to the <FILENAME>hwgraph</FILENAME> package.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE>Installing the Example Driver</TITLE><PARAGRAPH>Use the following steps to install and test the example driver. Each step is expanded in the following topics.</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Obtain the source code files.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Compile the source to obtain an object file.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Set up the appropriate configuration files.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Reboot the system and verify driver operation using the supplied unit-test program.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<SECTION2 LBL="" HELPID = ""><TITLE>Obtaining the Source Files</TITLE><PARAGRAPH>The example driver consists of the following five source files: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FILENAME>snoop.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="297"><PARAGRAPH>Header file that declares <FUNCTION>ioctl</FUNCTION> command codes, data structures, 
and macros used in the driver.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FILENAME>snoop.c</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="297"><PARAGRAPH>Driver source module.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FILENAME>snoop.master</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="297"><PARAGRAPH>Descriptive file for <FILENAME>/var/sysgen/master.d</FILENAME>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FILENAME>snoop.sm</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="297"><PARAGRAPH>A USE statement for <FILENAME>/var/sysgen/system</FILENAME>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><FILENAME>usnoop.c</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="297"><PARAGRAPH>User-level program to exercise the driver. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>These files, and other example code in this book, are available from the Silicon Graphics TechPubs server, <LAUNCHWORD APP="/usr/sbin/nr" PARMS="http://techpubs.sgi.com/">http://techpubs.sgi.com/</LAUNCHWORD>
 (it requires patience to re-create the files by copying and pasting from the online manual).</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Compiling the Example Driver</TITLE><PARAGRAPH>Compile using the techniques described under <XREF IDREF="66363" TYPE="TITLE">&ldquo;Compiling and Linking&rdquo;</XREF>. </PARAGRAPH>
<PARAGRAPH>When the driver is compiled with the -DDEBUG option, all its informational displays are enabled. Without that option, it only displays messages related to unexpected error returns from kernel functions.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Configuring the Example Driver</TITLE><PARAGRAPH>Before you configure the example driver into the kernel, you should set the system with a debugging kernel, as described under <XREF IDREF="86033" TYPE="TITLE">&ldquo;Preparing the System for Debugging&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>Configure the example driver to IRIX by copying files as follows:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Copy the object file, <FILENAME>snoop.o</FILENAME>, to <FILENAME>/var/sysgen/boot</FILENAME>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Edit the descriptive file, <FILENAME>snoop.master</FILENAME>, and make any desired changes&mdash;for example, making the driver nonloadable.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Copy the edited descriptive file to <FILENAME>/var/sysgen/master.d/snoop</FILENAME> (do not use the <FILENAME>.master</FILENAME> suffix on the filename).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Review the <FILENAME>snoop.sm</FILENAME> file. It must contain the statement USE snoop. You can also insert a DRIVER_ADMIN statement, as described under <XREF IDREF="92285" TYPE="TITLE">&ldquo;Creating Device Special Files&rdquo;</XREF>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Copy the <FILENAME>snoop.sm</FILENAME> file to <FILENAME>/var/sysgen/system</FILENAME>. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Run the <COMMAND>autoconfig</COMMAND> program to build a new kernel. Run <COMMAND>setsym</COMMAND> to install symbols in the kernel. Reboot the system.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>If you compiled the example driver with -DDEBUG, it displays several informational lines to the system console from its <VARIABLE>pfx</VARIABLE><FUNCTION>init()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>start()</FUNCTION>, and <VARIABLE>pfx</VARIABLE><FUNCTION>reg()</FUNCTION> entry points, as shown in <XREF IDREF="11796" TYPE="TEXT">Example&nbsp;11-1</XREF>. </PARAGRAPH>
<CODE><CAPTION LBL="11-1"><PREFIX>Example 11-1 </PREFIX><XREFTARGET ID="11796">Startup Messages from snoop Driver</CAPTION>snoop_: created /snoop
snoop_: added device edge, base 0xa80000002044d800
snoop_: added device attr, base 0xa80000002044d980
snoop_: added device hinv, base 0xa80000002044db00
snoop_: start() entry point called
snoop_: reg() entry point called
</CODE>
<PARAGRAPH>To disable the driver later, change USE to EXCLUDE, run <COMMAND>autoconfig</COMMAND>, and reboot.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="92285">Creating Device Special Files</TITLE><PARAGRAPH>The driver creates three vertexes in the hwgraph. By default they are named <FILENAME>/hw/snoop/edge</FILENAME>, <FILENAME>/hw/snoop/attr</FILENAME>, and <FILENAME>/hw/snoop/hinv</FILENAME>. The three device names &ldquo;edge,&rdquo; &ldquo;attr,&rdquo; and &ldquo;hinv&rdquo; are fixed, but the path leading to them is under your control. To use a path other than <FILENAME>/hw/snoop</FILENAME>, for example <FILENAME>/hw/dtest/snoop</FILENAME>, you place a DRIVER_ADMIN statement in the <FILENAME>snoop.sm</FILENAME> file, as shown in <XREF IDREF="49651" TYPE="TEXT">Example&nbsp;11-2</XREF>.</PARAGRAPH>
<CODE><CAPTION LBL="11-2"><PREFIX>Example 11-2 </PREFIX><XREFTARGET ID="49651">Driver Administration Statement in snoop.sm</CAPTION>TO BE SUPPLIED - API UNDER DESIGN
</CODE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Verifying Driver Operation</TITLE><PARAGRAPH>You can verify operation of the driver by operating the <COMMAND>usnoop</COMMAND> program. Compile the <FILENAME>usnoop.c</FILENAME> source file. Run it with root privileges. If you have changed the path for the snoop devices as described in the preceding topic, specify the changed path as the command argument. At the prompt &ldquo;path:&rdquo; enter an absolute or relative path in <FILENAME>/hw</FILENAME>.</PARAGRAPH>
<CODE><CAPTION LBL="11-3"><PREFIX>Example 11-3 </PREFIX>Typical Output of snoop Driver Unit Test</CAPTION># ./usnoop
enter path: <USERINPUT>/hw/rdisk</USERINPUT>&space;
&nbsp;
Path read:
/hw/rdisk
&nbsp;
Edges:
dks0d1s0
dks0d1s1
swap
root
volume_header
dks0d1vol
dks0d1vh
&nbsp;
Attrs:
&nbsp;
Hinv:
enter path: <USERINPUT>volume_header</USERINPUT>&space;
&nbsp;
Path read:
/hw/scsi_ctlr/0/target/1/lun/0/disk/volume_header/char
&nbsp;
Edges:
&nbsp;
Attrs:
&nbsp;
Hinv:
enter path: <USERINPUT>../../..</USERINPUT>&space;
&nbsp;
Path read:
/hw/scsi_ctlr/0/target/1/lun/0
&nbsp;
Edges:
scsi
disk
&nbsp;
Attrs:
&nbsp;
Hinv:
enter path:
</CODE>
<PARAGRAPH>When the <COMMAND>snoop</COMMAND> driver is compiled with -DDEBUG, numerous debugging messages appear on the console terminal at the same time. If you run <COMMAND>usnoop</COMMAND> from the console terminal, the debugging messages are interspersed with <COMMAND>usnoop</COMMAND> output.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE>Example Driver Source Files</TITLE><PARAGRAPH>The four source files of the example driver are displayed in the following topics:<INDEXTARGET ID="12-drvrexamp2"><!-- POSTPROCESSDATA: 12-drvrexamp2|configuration files:<FILENAME>/var/sysgen/master.d</FILENAME>:example --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="17193" TYPE="TITLE">&ldquo;Descriptive File&rdquo;</XREF> displays the <FILENAME>/var/sysgen/master.d</FILENAME> file that describes the driver to <FILENAME>lboot</FILENAME>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><INDEXTARGET ID="12-drvrexamp3"><!-- POSTPROCESSDATA: 12-drvrexamp3|configuration files:<FILENAME>/var/sysgen/system</FILENAME>:example --><XREF IDREF="54893" TYPE="TITLE">&ldquo;System File&rdquo;</XREF> displays the <FILENAME>/var/sysgen/system</FILENAME> file that contains the VECTOR statements to initialize the driver.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="66543" TYPE="TITLE">&ldquo;Header File&rdquo;</XREF> displays the driver's header file.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="35247" TYPE="TITLE">&ldquo;Driver Source&rdquo;</XREF> displays the source of the kernel driver.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="96910" TYPE="TITLE">&ldquo;User Program Source&rdquo;</XREF> displays the unit-test program <COMMAND>usnoop</COMMAND>.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="17193">Descriptive File</TITLE><CODE>
*
*&nbsp;IRIX&nbsp;6.4&nbsp;Example&nbsp;driver&nbsp;"snoop"&nbsp;descriptive&nbsp;file
*&nbsp;Store&nbsp;in&nbsp;/var/sysgen/master.d/snoop
*
*&nbsp;Flags&nbsp;used:
*&nbsp;c:&nbsp;character&nbsp;type&nbsp;device&nbsp;(only)
*&nbsp;d:&nbsp;dynamically&nbsp;loadable&nbsp;kernel&nbsp;module
*&nbsp;R:&nbsp;autoregister&nbsp;loadable&nbsp;driver
*&nbsp;n:&nbsp;driver&nbsp;is&nbsp;semaphored
*&nbsp;s:&nbsp;software&nbsp;device&nbsp;driver
*&nbsp;w:&nbsp;driver&nbsp;is&nbsp;prepared&nbsp;to&nbsp;perform&nbsp;any&nbsp;cache&nbsp;write&nbsp;back&nbsp;operation&nbsp;(none)
*
*&nbsp;External&nbsp;major&nbsp;number&nbsp;(SOFT)&nbsp;is&nbsp;an&nbsp;arbitrary&nbsp;choice&nbsp;from
*&nbsp;the&nbsp;range&nbsp;of&nbsp;numbers&nbsp;reserved&nbsp;for&nbsp;customer&nbsp;drivers.
*
*&nbsp;#DEV&nbsp;is&nbsp;passed&nbsp;in&nbsp;to&nbsp;the&nbsp;driver&nbsp;and&nbsp;used&nbsp;to&nbsp;configure&nbsp;its&nbsp;info&nbsp;array.
*
*FLAG&nbsp;&nbsp;&nbsp;PREFIX&nbsp;&nbsp;SOFT&nbsp;&nbsp;&nbsp;&nbsp;#DEV&nbsp;&nbsp;&nbsp;&nbsp;DEPENDENCIES
cdnswR&nbsp;&nbsp;&nbsp;snoop_&nbsp;&nbsp;&nbsp;77&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-b
&nbsp;
$$$
</CODE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="54893">System File</TITLE><CODE>
*
* Lboot config file for IRIX 6.4 example driver "snoop"
* Store as /var/sysgen/system/snoop.sm
*
USE: snoop
</CODE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="66543">Header File</TITLE><CODE>
/**************************************************************************
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copyright&nbsp;(C)&nbsp;1993,&nbsp;Silicon&nbsp;Graphics,&nbsp;Inc.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;*&nbsp;&nbsp;These&nbsp;coded&nbsp;instructions,&nbsp;statements,&nbsp;and&nbsp;computer&nbsp;programs&nbsp;&nbsp;contain&nbsp;&nbsp;*
&nbsp;*&nbsp;&nbsp;unpublished&nbsp;&nbsp;proprietary&nbsp;&nbsp;information&nbsp;of&nbsp;Silicon&nbsp;Graphics,&nbsp;Inc.,&nbsp;and&nbsp;&nbsp;*
&nbsp;*&nbsp;&nbsp;are&nbsp;protected&nbsp;by&nbsp;Federal&nbsp;copyright&nbsp;law.&nbsp;&nbsp;They&nbsp;&nbsp;may&nbsp;&nbsp;not&nbsp;be&nbsp;disclosed&nbsp;&nbsp;*
&nbsp;*&nbsp;&nbsp;to&nbsp;&nbsp;third&nbsp;&nbsp;parties&nbsp;&nbsp;or&nbsp;copied&nbsp;or&nbsp;duplicated&nbsp;in&nbsp;any&nbsp;form,&nbsp;in&nbsp;whole&nbsp;or&nbsp;&nbsp;*
&nbsp;*&nbsp;&nbsp;in&nbsp;part,&nbsp;without&nbsp;the&nbsp;prior&nbsp;written&nbsp;consent&nbsp;of&nbsp;Silicon&nbsp;Graphics,&nbsp;Inc.&nbsp;&nbsp;*
&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
&nbsp;**************************************************************************/
#ifndef&nbsp;__SNOOP_H__
#define&nbsp;__SNOOP_H__
#ifdef&nbsp;__cplusplus
extern&nbsp;"C"&nbsp;{
#endif
/**************************************************************************
|&nbsp;The&nbsp;driver&nbsp;creates&nbsp;character&nbsp;special&nbsp;device&nbsp;nodes&nbsp;in&nbsp;the&nbsp;hwgraph,&nbsp;by
|&nbsp;default&nbsp;at&nbsp;/hw/snoop/{edge,attr,hinv}&nbsp;&nbsp;However&nbsp;you&nbsp;can&nbsp;place&nbsp;a&nbsp;statement
|&nbsp;in&nbsp;the&nbsp;/var/sysgen/system/irix.sm&nbsp;file&nbsp;to&nbsp;establish&nbsp;a&nbsp;different&nbsp;path,
|&nbsp;for&nbsp;example:
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DRIVER_ADMIN&nbsp;snoop_&nbsp;hwpath&nbsp;=&nbsp;/hw/admin/snoopy/nodes
|&nbsp;The&nbsp;driver&nbsp;prefix&nbsp;must&nbsp;be&nbsp;given&nbsp;exactly,&nbsp;as&nbsp;must&nbsp;the&nbsp;name&nbsp;"hwpath".
|&nbsp;The&nbsp;argument&nbsp;must&nbsp;be&nbsp;a&nbsp;valid&nbsp;/hw&nbsp;path&nbsp;that&nbsp;does&nbsp;not&nbsp;exist&nbsp;when&nbsp;the
|&nbsp;driver&nbsp;initializes.&nbsp;&nbsp;The&nbsp;following&nbsp;constant&nbsp;gives&nbsp;the&nbsp;attr-name&nbsp;used:
***************************************************************************/
#define&nbsp;ADMIN_LABEL&nbsp;"hwpath"
/**************************************************************************
|&nbsp;The&nbsp;following&nbsp;definitions&nbsp;establish&nbsp;the&nbsp;ioctl()&nbsp;command&nbsp;numbers&nbsp;that&nbsp;
|&nbsp;are&nbsp;recognized&nbsp;by&nbsp;this&nbsp;driver.&nbsp;&nbsp;See&nbsp;ioctl(D2)&nbsp;for&nbsp;comments.&nbsp;&nbsp;Ascii
|&nbsp;uppercase&nbsp;letters,&nbsp;minus&nbsp;64,&nbsp;fit&nbsp;in&nbsp;5&nbsp;bits,&nbsp;so&nbsp;the&nbsp;command&nbsp;#s&nbsp;are:
|&nbsp;&nbsp;&nbsp;&nbsp;0b0000&nbsp;0000&nbsp;0sss&nbsp;ssnn&nbsp;nnno&nbsp;oooo&nbsp;####&nbsp;####
|&nbsp;These&nbsp;definitions&nbsp;are&nbsp;useful&nbsp;in&nbsp;client&nbsp;code&nbsp;as&nbsp;well&nbsp;as&nbsp;the&nbsp;driver.
***************************************************************************/
#define&nbsp;IOCTL_BASE&nbsp;((('S'-64)&lt;&lt;18)|(('N'-64)&lt;&lt;13)|(('O'-64)&lt;&lt;8))
#define&nbsp;IOCTL_MASTER_TEST&nbsp;&nbsp;&nbsp;(IOCTL_BASE&nbsp;+&nbsp;1)
#define&nbsp;IOCTL_MASTER_GO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(IOCTL_BASE&nbsp;+&nbsp;2)
#define&nbsp;IOCTL_CLOSING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(IOCTL_BASE&nbsp;+&nbsp;6)
#define&nbsp;IOCTL_PATH_READ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(IOCTL_BASE&nbsp;+&nbsp;9)
#define&nbsp;IOCTL_VERTEX_GET&nbsp;&nbsp;&nbsp;&nbsp;(IOCTL_BASE&nbsp;+&nbsp;15)
#define&nbsp;IOCTL_VERTEX_SET&nbsp;&nbsp;&nbsp;&nbsp;(IOCTL_BASE&nbsp;+&nbsp;16)
&nbsp;
#ifdef&nbsp;_KERNEL&nbsp;/*&nbsp;remainder&nbsp;is&nbsp;only&nbsp;useful&nbsp;to&nbsp;the&nbsp;driver&nbsp;*/
#include&nbsp;&lt;sys/types.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;all&nbsp;kinds&nbsp;of&nbsp;types&nbsp;inc.&nbsp;vertex_hdl_t&nbsp;*/
#include&nbsp;&lt;sys/kmem.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;kmem_zalloc,&nbsp;kmem_free&nbsp;*/
#include&nbsp;&lt;sys/ksynch.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;locks&nbsp;*/
#include&nbsp;&lt;sys/ddi.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;many&nbsp;utility&nbsp;functions&nbsp;*/
#include&nbsp;&lt;sys/invent.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;inventory_t&nbsp;*/
#include&nbsp;&lt;sys/hwgraph.h>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;hwgraph&nbsp;functions&nbsp;*/
#include &lt;sys/driver.h> &nbsp;&nbsp;&nbsp;&nbsp;/* driver_admin functions */
#include&nbsp;&lt;sys/cred.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;for&nbsp;cred_t&nbsp;used&nbsp;in&nbsp;open/read/write&nbsp;*/
#include&nbsp;&lt;sys/cmn_err.h>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;for&nbsp;cmn_err&nbsp;and&nbsp;its&nbsp;constants&nbsp;*/
#include&nbsp;&lt;sys/errno.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;error&nbsp;constants&nbsp;*/
#include&nbsp;&lt;sys/mload.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;mload&nbsp;version&nbsp;string&nbsp;*/
/**************************************************************************
|&nbsp;The&nbsp;purpose&nbsp;of&nbsp;the&nbsp;following&nbsp;macros&nbsp;are&nbsp;to&nbsp;make&nbsp;it&nbsp;possible&nbsp;to&nbsp;define
|&nbsp;the&nbsp;driver&nbsp;prefix&nbsp;in&nbsp;exactly&nbsp;one&nbsp;place&nbsp;(the&nbsp;PREFIX_NAME&nbsp;macro)&nbsp;and&nbsp;then
|&nbsp;to&nbsp;invoke&nbsp;that&nbsp;prefix&nbsp;anywhere&nbsp;else&nbsp;-
|&nbsp;&nbsp;&nbsp;-&nbsp;as&nbsp;part&nbsp;of&nbsp;function&nbsp;names,&nbsp;e.g.&nbsp;&lt;prefix>open(),&nbsp;&lt;prefix>init().
|&nbsp;&nbsp;&nbsp;-&nbsp;as&nbsp;a&nbsp;character&nbsp;literal,&nbsp;as&nbsp;in&nbsp;pciio_driver_register(..."prefix")
|&nbsp;&nbsp;&nbsp;-&nbsp;automatically&nbsp;as&nbsp;part&nbsp;of&nbsp;other&nbsp;macros&nbsp;for&nbsp;example&nbsp;debug&nbsp;displays
***************************************************************************/
#define&nbsp;PREFIX_NAME(name)&nbsp;snoop_&nbsp;##&nbsp;name
/*&nbsp;-----&nbsp;&nbsp;driver&nbsp;prefix:&nbsp;&nbsp;^^^^^^&nbsp;&nbsp;defined&nbsp;here&nbsp;only&nbsp;*/
/*&nbsp;utility&nbsp;macros,&nbsp;not&nbsp;to&nbsp;be&nbsp;used&nbsp;directly&nbsp;*/
#define&nbsp;PREFIX_ONLY&nbsp;PREFIX_NAME(&nbsp;)
#define&nbsp;STRINGIZER(x)&nbsp;#&nbsp;x
#define&nbsp;EVALUEIZER(x)&nbsp;STRINGIZER(x)
#define&nbsp;PREFIX_STRING&nbsp;EVALUEIZER(PREFIX_ONLY)
/*
|&nbsp;Define&nbsp;driver&nbsp;entry&nbsp;point&nbsp;macros&nbsp;in&nbsp;alpha&nbsp;order.&nbsp;&nbsp;This&nbsp;is&nbsp;your&nbsp;basic
|&nbsp;character&nbsp;driver:&nbsp;open-read-write-ioctl-close.
*/
#define&nbsp;PFX_CLOSE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PREFIX_NAME(close)
#define&nbsp;PFX_DEVFLAG&nbsp;&nbsp;&nbsp;PREFIX_NAME(devflag)
#define&nbsp;PFX_INIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PREFIX_NAME(init)
#define&nbsp;PFX_IOCTL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PREFIX_NAME(ioctl)
#define&nbsp;PFX_MVERSION&nbsp;&nbsp;PREFIX_NAME(mversion)
#define&nbsp;PFX_OPEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PREFIX_NAME(open)
#define&nbsp;PFX_READ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PREFIX_NAME(read)
#define&nbsp;PFX_REG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PREFIX_NAME(reg)
#define&nbsp;PFX_START&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PREFIX_NAME(start)
#define&nbsp;PFX_UNLOAD&nbsp;&nbsp;&nbsp;&nbsp;PREFIX_NAME(unload)
#define&nbsp;PFX_WRITE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PREFIX_NAME(write)
/**************************************************************************
|&nbsp;Debug&nbsp;display&nbsp;macros:&nbsp;one&nbsp;each&nbsp;for&nbsp;cmn_err&nbsp;calls&nbsp;with&nbsp;0,&nbsp;1,&nbsp;2,&nbsp;3&nbsp;or&nbsp;4
|&nbsp;arguments.&nbsp;&nbsp;The&nbsp;macros&nbsp;generate&nbsp;the&nbsp;PREFIX_STRING,&nbsp;colon,&nbsp;space&nbsp;at&nbsp;the
|&nbsp;front&nbsp;of&nbsp;the&nbsp;message&nbsp;and&nbsp;\n&nbsp;on&nbsp;the&nbsp;end.&nbsp;&nbsp;For&nbsp;example,
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG2("one&nbsp;%d&nbsp;two&nbsp;%x",a,b)&nbsp;is&nbsp;the&nbsp;same&nbsp;as
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err(CE_DEBUG,"snoop_:&nbsp;one&nbsp;%d&nbsp;two&nbsp;%x\n",a,b)
|**************************************************************************/
#ifndef&nbsp;DEBUG
#define&nbsp;DBGMSG0(s)
#define&nbsp;DBGMSG1(s,x)
#define&nbsp;DBGMSG2(s,x,y)
#define&nbsp;DBGMSG3(s,x,y,z)
#define&nbsp;DBGMSG4(s,x,y,z,w)
#else
#define&nbsp;DBGMSGX(s)&nbsp;cmn_err(CE_DEBUG,PREFIX_STRING&nbsp;":&nbsp;"&nbsp;s&nbsp;"\n"
#define&nbsp;DBGMSG0(s)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSGX(s)&nbsp;)
#define&nbsp;DBGMSG1(s,x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSGX(s)&nbsp;,x)
#define&nbsp;DBGMSG2(s,x,y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSGX(s)&nbsp;,x,y)
#define&nbsp;DBGMSG3(s,x,y,z)&nbsp;&nbsp;&nbsp;DBGMSGX(s)&nbsp;,x,y,z)
#define&nbsp;DBGMSG4(s,x,y,z,w)&nbsp;DBGMSGX(s)&nbsp;,x,y,z,w)
#endif
/**************************************************************************
|&nbsp;The&nbsp;ERRMSGn&nbsp;macros&nbsp;are&nbsp;the&nbsp;same&nbsp;as&nbsp;the&nbsp;DGBMSGn&nbsp;macros,&nbsp;except&nbsp;they&nbsp;are
|&nbsp;always&nbsp;defined&nbsp;(not&nbsp;conditional&nbsp;on&nbsp;DEBUG)&nbsp;and&nbsp;use&nbsp;CE_WARN&nbsp;status.
|**************************************************************************/
#define&nbsp;ERRMSGX(s)&nbsp;cmn_err(CE_WARN,PREFIX_STRING&nbsp;":&nbsp;"&nbsp;s&nbsp;"\n"
#define&nbsp;ERRMSG0(s)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERRMSGX(s)&nbsp;)
#define&nbsp;ERRMSG1(s,x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERRMSGX(s)&nbsp;,x)
#define&nbsp;ERRMSG2(s,x,y)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERRMSGX(s)&nbsp;,x,y)
#define&nbsp;ERRMSG3(s,x,y,z)&nbsp;&nbsp;&nbsp;ERRMSGX(s)&nbsp;,x,y,z)
#define&nbsp;ERRMSG4(s,x,y,z,w)&nbsp;ERRMSGX(s)&nbsp;,x,y,z,w)
/**************************************************************************
|&nbsp;One&nbsp;instance&nbsp;of&nbsp;the&nbsp;following&nbsp;structure&nbsp;is&nbsp;created&nbsp;when&nbsp;any&nbsp;of&nbsp;our&nbsp;
|&nbsp;devices&nbsp;is&nbsp;opened.&nbsp;&nbsp;The&nbsp;structure&nbsp;is&nbsp;by&nbsp;default&nbsp;allocated&nbsp;in
|&nbsp;the&nbsp;node&nbsp;where&nbsp;the&nbsp;open()&nbsp;is&nbsp;executed.&nbsp;&nbsp;The&nbsp;structure&nbsp;is&nbsp;protected&nbsp;by&nbsp;a&nbsp;
|&nbsp;lock&nbsp;because&nbsp;it&nbsp;is&nbsp;possible&nbsp;for&nbsp;multiple&nbsp;threads&nbsp;in&nbsp;a&nbsp;pgroup&nbsp;to&nbsp;attempt
|&nbsp;concurrent&nbsp;read/write/ioctl&nbsp;calls&nbsp;to&nbsp;the&nbsp;same&nbsp;FD.
|&nbsp;&nbsp;&nbsp;&nbsp;use_lock&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;ensure&nbsp;only&nbsp;one&nbsp;thread&nbsp;modifies&nbsp;structure&nbsp;at&nbsp;a&nbsp;time
|&nbsp;&nbsp;&nbsp;&nbsp;read_ptr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;address&nbsp;of&nbsp;data&nbsp;to&nbsp;return&nbsp;to&nbsp;read()
|&nbsp;&nbsp;&nbsp;&nbsp;read_len&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;length&nbsp;of&nbsp;data&nbsp;remaining&nbsp;to&nbsp;read()
|&nbsp;&nbsp;&nbsp;&nbsp;v_current&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;hwgraph&nbsp;vertex&nbsp;being&nbsp;snooped&nbsp;(initially&nbsp;/hw)
|&nbsp;&nbsp;&nbsp;&nbsp;v_last_edge&nbsp;&nbsp;:&nbsp;vertex&nbsp;at&nbsp;end&nbsp;of&nbsp;last-scanned&nbsp;edge
|&nbsp;&nbsp;&nbsp;&nbsp;edge_place&nbsp;&nbsp;&nbsp;:&nbsp;position&nbsp;in&nbsp;edge&nbsp;list,&nbsp;for&nbsp;/hw/snoop/edge
|&nbsp;&nbsp;&nbsp;&nbsp;info_place&nbsp;&nbsp;&nbsp;:&nbsp;position&nbsp;in&nbsp;the&nbsp;info&nbsp;list,&nbsp;for&nbsp;/hw/snoop/attr
|&nbsp;&nbsp;&nbsp;&nbsp;hinv_place&nbsp;&nbsp;&nbsp;:&nbsp;position&nbsp;in&nbsp;the&nbsp;hinv&nbsp;list,&nbsp;for&nbsp;/hw/snoop/hinv
|&nbsp;&nbsp;&nbsp;&nbsp;scratch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;buffer&nbsp;to&nbsp;hold&nbsp;maximal&nbsp;/hw&nbsp;path&nbsp;on&nbsp;write()&nbsp;call
|&nbsp;Only&nbsp;one&nbsp;of&nbsp;the&nbsp;_place&nbsp;fields&nbsp;is&nbsp;used&nbsp;in&nbsp;any&nbsp;one&nbsp;structure,&nbsp;but&nbsp;the&nbsp;
|&nbsp;memory&nbsp;saved&nbsp;by&nbsp;making&nbsp;a&nbsp;union&nbsp;of&nbsp;them&nbsp;is&nbsp;not&nbsp;worth&nbsp;the&nbsp;coding&nbsp;bother.
|**************************************************************************/
typedef&nbsp;struct&nbsp;snoop_user_s&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;mutex_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use_lock;
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read_ptr;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read_len;
&nbsp;&nbsp;&nbsp;&nbsp;vertex_hdl_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v_current;
&nbsp;&nbsp;&nbsp;&nbsp;vertex_hdl_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v_last_edge;
&nbsp;&nbsp;&nbsp;&nbsp;graph_edge_place_t&nbsp;&nbsp;edge_place;
&nbsp;&nbsp;&nbsp;&nbsp;graph_info_place_t&nbsp;&nbsp;info_place;
&nbsp;&nbsp;&nbsp;&nbsp;invplace_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hinv_place;
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;scratch[HWGRAPH_VPATH_LEN_MAX*LABEL_LENGTH_MAX];
}&nbsp;snoop_user_t;
/**************************************************************************
|&nbsp;One&nbsp;instance&nbsp;of&nbsp;the&nbsp;following&nbsp;structure&nbsp;is&nbsp;created&nbsp;for&nbsp;each&nbsp;char&nbsp;device
|&nbsp;we&nbsp;create&nbsp;(3&nbsp;in&nbsp;all),&nbsp;and&nbsp;its&nbsp;address&nbsp;is&nbsp;saved&nbsp;with&nbsp;device_info_set().
|&nbsp;&nbsp;&nbsp;&nbsp;dev_lock&nbsp;&nbsp;&nbsp;:&nbsp;for&nbsp;controlled&nbsp;access&nbsp;to&nbsp;the&nbsp;device&nbsp;data
|&nbsp;&nbsp;&nbsp;&nbsp;val_func&nbsp;&nbsp;&nbsp;:&nbsp;function&nbsp;to&nbsp;set&nbsp;up&nbsp;data&nbsp;for&nbsp;a&nbsp;read
|&nbsp;&nbsp;&nbsp;&nbsp;nopen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;number&nbsp;of&nbsp;opened/allocated&nbsp;users
|&nbsp;&nbsp;&nbsp;&nbsp;user_list&nbsp;&nbsp;:&nbsp;vector&nbsp;of&nbsp;pointers&nbsp;to&nbsp;snoop_user&nbsp;structs
|&nbsp;Use&nbsp;of&nbsp;this&nbsp;structure&nbsp;is&nbsp;controlled&nbsp;by&nbsp;a&nbsp;reader/writer&nbsp;lock.&nbsp;Only&nbsp;the
|&nbsp;open&nbsp;&amp;&nbsp;close&nbsp;entries&nbsp;modify&nbsp;the&nbsp;user&nbsp;list,&nbsp;and&nbsp;so&nbsp;claim&nbsp;the&nbsp;writer&nbsp;lock.
|&nbsp;Other&nbsp;entries&nbsp;claim&nbsp;it&nbsp;as&nbsp;readers.
|
|&nbsp;The&nbsp;reason&nbsp;for&nbsp;making&nbsp;user_list&nbsp;a&nbsp;fixed&nbsp;array&nbsp;(as&nbsp;opposed&nbsp;to&nbsp;linking
|&nbsp;the&nbsp;snoop_user&nbsp;structs&nbsp;in&nbsp;a&nbsp;chain)&nbsp;is&nbsp;because&nbsp;each&nbsp;snoop_user_t&nbsp;can&nbsp;be
|&nbsp;in&nbsp;a&nbsp;different&nbsp;module,&nbsp;and&nbsp;we&nbsp;want&nbsp;to&nbsp;touch&nbsp;only&nbsp;the&nbsp;one&nbsp;for&nbsp;the&nbsp;caller.&nbsp;
|**************************************************************************/
#define&nbsp;MAX_PGID&nbsp;20
typedef&nbsp;void&nbsp;(*val_func)(snoop_user_t&nbsp;*puser);
typedef&nbsp;struct&nbsp;snoop_base_s&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;rwlock_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dev_lock;
&nbsp;&nbsp;&nbsp;&nbsp;val_func&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vector;
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nopen;
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pid_t&nbsp;user;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;pgid&nbsp;at&nbsp;open()&nbsp;time&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;generation;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;number&nbsp;of&nbsp;occupants&nbsp;of&nbsp;this&nbsp;slot&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;snoop_user_t&nbsp;*work;&nbsp;/*&nbsp;->&nbsp;corresponding&nbsp;work&nbsp;area&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;user_list[MAX_PGID];
}&nbsp;snoop_base_t;
&nbsp;
#ifdef&nbsp;__cplusplus
}
#endif
#endif&nbsp;/*&nbsp;_KERNEL&nbsp;*/
#endif&nbsp;/*&nbsp;__SNOOP_H__&nbsp;*/
&nbsp;
</CODE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="35247">Driver Source</TITLE><CODE>
/**************************************************************************
|
|&nbsp;This&nbsp;is&nbsp;snoop.c,&nbsp;a&nbsp;pseudo-device&nbsp;driver&nbsp;for&nbsp;IRIX&nbsp;6.4&nbsp;and&nbsp;later.
|
|&nbsp;At&nbsp;snoop_init(),&nbsp;create&nbsp;three&nbsp;char&nbsp;device&nbsp;vertexes&nbsp;in&nbsp;the&nbsp;hwgraph,
|&nbsp;/hw/snoop/{edge,attr,hinv}.&nbsp;&nbsp;Each&nbsp;device&nbsp;supports&nbsp;open,&nbsp;read,&nbsp;write,
|&nbsp;close,&nbsp;and&nbsp;ioctl.
|
|&nbsp;At&nbsp;most&nbsp;one&nbsp;open()&nbsp;from&nbsp;any&nbsp;process&nbsp;group&nbsp;is&nbsp;accepted&nbsp;for&nbsp;any&nbsp;device.
|&nbsp;Second&nbsp;attempts&nbsp;are&nbsp;rejected&nbsp;with&nbsp;EBUSY.&nbsp;However,&nbsp;multiple&nbsp;processes
|&nbsp;and&nbsp;POSIX&nbsp;threads&nbsp;in&nbsp;a&nbsp;process&nbsp;group&nbsp;may&nbsp;use&nbsp;the&nbsp;open&nbsp;FD&nbsp;concurrently.
|
|&nbsp;The&nbsp;driver&nbsp;maintains&nbsp;a&nbsp;current&nbsp;status&nbsp;for&nbsp;each&nbsp;process&nbsp;group&nbsp;open&nbsp;of
|&nbsp;each&nbsp;device.&nbsp;The&nbsp;two&nbsp;key&nbsp;status&nbsp;variables&nbsp;are:
|&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;position&nbsp;on&nbsp;a&nbsp;current&nbsp;vertex&nbsp;in&nbsp;the&nbsp;hwgraph
|&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;scan&nbsp;position&nbsp;for&nbsp;reading&nbsp;out&nbsp;edges,&nbsp;attributes,&nbsp;or&nbsp;inventory_t's
|
|&nbsp;Each&nbsp;read()&nbsp;of&nbsp;/hw/snoop/edge&nbsp;returns&nbsp;the&nbsp;next&nbsp;(first)&nbsp;edge&nbsp;from&nbsp;the
|&nbsp;current&nbsp;vertex&nbsp;as&nbsp;a&nbsp;character&nbsp;string.&nbsp;If&nbsp;the&nbsp;read&nbsp;length&nbsp;is&nbsp;less&nbsp;than
|&nbsp;the&nbsp;string&nbsp;length,&nbsp;the&nbsp;byte&nbsp;position&nbsp;is&nbsp;remembered&nbsp;and&nbsp;the&nbsp;rest&nbsp;of&nbsp;the
|&nbsp;string&nbsp;is&nbsp;returned&nbsp;on&nbsp;the&nbsp;next&nbsp;read.
|
|&nbsp;Each&nbsp;read()&nbsp;of&nbsp;/hw/snoop/attr&nbsp;returns&nbsp;the&nbsp;first/next&nbsp;attribute&nbsp;label
|&nbsp;from&nbsp;the&nbsp;current&nbsp;vertex&nbsp;under&nbsp;the&nbsp;same&nbsp;rule&nbsp;as&nbsp;edges.
|
|&nbsp;Each&nbsp;read()&nbsp;of&nbsp;/hw/snoop/hinv&nbsp;returns&nbsp;the&nbsp;first/next&nbsp;invent_t&nbsp;ditto.
|&nbsp;Note&nbsp;that&nbsp;an&nbsp;invent_t&nbsp;is&nbsp;binary&nbsp;data,&nbsp;not&nbsp;ascii.&nbsp;
|
|&nbsp;For&nbsp;any&nbsp;device,&nbsp;a&nbsp;call&nbsp;to&nbsp;write()&nbsp;must&nbsp;present&nbsp;an&nbsp;absolute&nbsp;or&nbsp;relative
|&nbsp;path&nbsp;in&nbsp;the&nbsp;/hw&nbsp;filesystem.&nbsp;The&nbsp;device&nbsp;moves&nbsp;to&nbsp;the&nbsp;selected&nbsp;vertex
|&nbsp;and&nbsp;initializes&nbsp;the&nbsp;input&nbsp;scan&nbsp;of&nbsp;edges,&nbsp;attrs,&nbsp;or&nbsp;hinvs.&nbsp;&nbsp;For&nbsp;example,
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(FD,"/hw/snoop")&nbsp;&nbsp;moves&nbsp;to&nbsp;that&nbsp;vertex.
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(FD,"..")&nbsp;moves&nbsp;back&nbsp;to&nbsp;/hw
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(FD,"snoop/edge")&nbsp;moves&nbsp;down&nbsp;to&nbsp;/hw/snoop/edge.
|
|&nbsp;The&nbsp;following&nbsp;IOCTL&nbsp;calls&nbsp;are&nbsp;supported&nbsp;(declared&nbsp;in&nbsp;snoop.h):
|
|&nbsp;&nbsp;&nbsp;IOCTL_MASTER_TEST&nbsp;&nbsp;returns&nbsp;0&nbsp;if&nbsp;a&nbsp;"master"&nbsp;vertex&nbsp;exists,&nbsp;or&nbsp;ENOENT
|
|&nbsp;&nbsp;&nbsp;IOCTL_MASTER_GO&nbsp;&nbsp;&nbsp;&nbsp;moves&nbsp;the&nbsp;current&nbsp;vertex&nbsp;to&nbsp;its&nbsp;master,&nbsp;if&nbsp;any
|
|&nbsp;&nbsp;&nbsp;IOCTL_PATH_READ&nbsp;&nbsp;&nbsp;&nbsp;sets&nbsp;to&nbsp;return&nbsp;the&nbsp;complete&nbsp;"/hw..."&nbsp;path&nbsp;of&nbsp;the
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current&nbsp;vertex&nbsp;on&nbsp;the&nbsp;next&nbsp;read()&nbsp;call,&nbsp;in&nbsp;place
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;the&nbsp;next&nbsp;edge/attr/hinv.
|
|&nbsp;&nbsp;&nbsp;IOCTL_CLOSING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notifies&nbsp;the&nbsp;driver&nbsp;that&nbsp;this&nbsp;process&nbsp;group&nbsp;is
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;about&nbsp;to&nbsp;close&nbsp;the&nbsp;device.&nbsp;Subsequent&nbsp;attempts&nbsp;to
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;that&nbsp;open&nbsp;file&nbsp;are&nbsp;rejected.&nbsp;Interesting
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutual-exclusion&nbsp;problems&nbsp;arise&nbsp;here.
|
|&nbsp;&nbsp;&nbsp;IOCTL_VERTEX_GET&nbsp;&nbsp;&nbsp;retrieve&nbsp;the&nbsp;current&nbsp;vertex&nbsp;handle.&nbsp;&nbsp;Argument&nbsp;is
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;an&nbsp;address&nbsp;in&nbsp;user&nbsp;memory&nbsp;to&nbsp;place&nbsp;the&nbsp;handle.
|
|&nbsp;&nbsp;&nbsp;IOCTL_VERTEX_SET&nbsp;&nbsp;&nbsp;set&nbsp;a&nbsp;new&nbsp;current&nbsp;vertex.&nbsp;Argument&nbsp;is&nbsp;an&nbsp;address
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;user&nbsp;memory&nbsp;where&nbsp;a&nbsp;handle&nbsp;sits,&nbsp;presumably
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one&nbsp;retrieved&nbsp;with&nbsp;IOCTL_VERTEX_GET.
|
|**************************************************************************/
#include&nbsp;"snoop.h"&nbsp;&nbsp;/*&nbsp;all&nbsp;#includes&nbsp;are&nbsp;inside&nbsp;this&nbsp;header&nbsp;*/
int&nbsp;PFX_DEVFLAG&nbsp;=&nbsp;D_MP;
char&nbsp;*&nbsp;PFX_MVERSION&nbsp;=&nbsp;M_VERSION;
/*&nbsp;Function&nbsp;Directory&nbsp;*/
static&nbsp;int
&nbsp;&nbsp;&nbsp;&nbsp;alloc_user(snoop_base_t&nbsp;*pbase);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;make&nbsp;&amp;&nbsp;init&nbsp;snoop_user_t&nbsp;on&nbsp;open&nbsp;*/
static&nbsp;pid_t
&nbsp;&nbsp;&nbsp;&nbsp;get_pgroup(void);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;get&nbsp;PGID&nbsp;of&nbsp;client&nbsp;*/
static&nbsp;int
&nbsp;&nbsp;&nbsp;&nbsp;get_user_index(snoop_base_t&nbsp;*pbase,&nbsp;pid_t&nbsp;pgroup);&nbsp;&nbsp;/*&nbsp;get&nbsp;index&nbsp;of&nbsp;client&nbsp;*/
static&nbsp;snoop_user_t&nbsp;*
&nbsp;&nbsp;&nbsp;&nbsp;get_user(snoop_base_t&nbsp;*pbase);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;locate&nbsp;snoop_user_t&nbsp;for&nbsp;client&nbsp;*/
static&nbsp;int
&nbsp;&nbsp;&nbsp;&nbsp;init_dev(char&nbsp;*name,&nbsp;vertex_hdl_t&nbsp;v_snoop,&nbsp;val_func&nbsp;func);
static&nbsp;void
&nbsp;&nbsp;&nbsp;&nbsp;reset_scans(snoop_user_t&nbsp;*puser);&nbsp;&nbsp;&nbsp;/*&nbsp;reset&nbsp;input&nbsp;scans&nbsp;for&nbsp;client&nbsp;*/
static&nbsp;void
&nbsp;&nbsp;&nbsp;&nbsp;val_attr(snoop_user_t&nbsp;*puser);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;scan&nbsp;next&nbsp;attr&nbsp;for&nbsp;read()&nbsp;*/
static&nbsp;void
&nbsp;&nbsp;&nbsp;&nbsp;val_edge(snoop_user_t&nbsp;*puser);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;scan&nbsp;next&nbsp;edge&nbsp;for&nbsp;read()&nbsp;*/
static&nbsp;void
&nbsp;&nbsp;&nbsp;&nbsp;val_hinv(snoop_user_t&nbsp;*puser);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;scan&nbsp;next&nbsp;inventory_t&nbsp;for&nbsp;read()&nbsp;*/
int
&nbsp;&nbsp;&nbsp;&nbsp;PFX_INIT();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;init()&nbsp;entry&nbsp;point&nbsp;*/
int
&nbsp;&nbsp;&nbsp;&nbsp;PFX_OPEN(dev_t&nbsp;*devp,&nbsp;int&nbsp;oflag,&nbsp;int&nbsp;otyp,&nbsp;cred_t&nbsp;*crp);
int
&nbsp;&nbsp;&nbsp;&nbsp;PFX_REG();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;reg()&nbsp;entry&nbsp;point&nbsp;*/
int
&nbsp;&nbsp;&nbsp;&nbsp;PFX_START();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;start()&nbsp;entry&nbsp;point&nbsp;*/
int
&nbsp;&nbsp;&nbsp;&nbsp;PFX_WRITE(dev_t&nbsp;dev,&nbsp;uio_t&nbsp;*uiop,&nbsp;cred_t&nbsp;*crp);
int
PFX_IOCTL(dev_t&nbsp;dev,&nbsp;int&nbsp;cmd,&nbsp;void&nbsp;*arg,&nbsp;int&nbsp;mode,&nbsp;cred_t&nbsp;*crp,&nbsp;int&nbsp;*rvalp);
/**************************************************************************
|&nbsp;Get&nbsp;the&nbsp;process&nbsp;group&nbsp;ID&nbsp;for&nbsp;the&nbsp;client&nbsp;process.&nbsp;The&nbsp;pgid&nbsp;is&nbsp;used&nbsp;as
|&nbsp;a&nbsp;key&nbsp;to&nbsp;search&nbsp;the&nbsp;user_list.
|**************************************************************************/
static&nbsp;pid_t
get_pgroup(void)
{
&nbsp;&nbsp;&nbsp;&nbsp;ulong_t&nbsp;val&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;(void)drv_getparm(PPGRP,&amp;val);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(pid_t)&nbsp;val;
}
/**************************************************************************
|&nbsp;Get&nbsp;the&nbsp;index&nbsp;of&nbsp;the&nbsp;snoop_user_t&nbsp;for&nbsp;the&nbsp;client&nbsp;process&nbsp;in&nbsp;the
|&nbsp;user_list.&nbsp;&nbsp;Return&nbsp;-1&nbsp;if&nbsp;the&nbsp;specified&nbsp;pgid&nbsp;is&nbsp;not&nbsp;found.&nbsp;"Not&nbsp;Found"
|&nbsp;is&nbsp;the&nbsp;expected&nbsp;result&nbsp;when&nbsp;this&nbsp;function&nbsp;is&nbsp;called&nbsp;from&nbsp;the
|&nbsp;pfx_open()&nbsp;entry.&nbsp;&nbsp;It&nbsp;is&nbsp;a&nbsp;possible&nbsp;result&nbsp;in&nbsp;other&nbsp;entry&nbsp;points,&nbsp;but
|&nbsp;only&nbsp;when&nbsp;the&nbsp;client&nbsp;calls&nbsp;ioctl(IOCTL_CLOSING)&nbsp;and&nbsp;then&nbsp;continues
|&nbsp;to&nbsp;use&nbsp;the&nbsp;file&nbsp;descriptor.
|**************************************************************************/
static&nbsp;int
get_user_index(snoop_base_t&nbsp;*pbase,&nbsp;pid_t&nbsp;pgid)
{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;j;

&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(j=0&nbsp;;j&lt;MAX_PGID;++j)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pbase->user_list[j].user&nbsp;==&nbsp;pgid)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;j;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;
}
/**************************************************************************
|&nbsp;Locate&nbsp;the&nbsp;snoop_user_t&nbsp;for&nbsp;the&nbsp;client&nbsp;process.&nbsp;The&nbsp;caller&nbsp;is&nbsp;assumed
|&nbsp;to&nbsp;hold&nbsp;pbase->dev_lock&nbsp;as&nbsp;reader&nbsp;at&nbsp;least.
|**************************************************************************/
static&nbsp;snoop_user_t&nbsp;*
get_user(snoop_base_t&nbsp;*pbase)
{
&nbsp;&nbsp;&nbsp;&nbsp;snoop_user_t&nbsp;*puser&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;j;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(-1&nbsp;!=&nbsp;(j&nbsp;=&nbsp;get_user_index(pbase,&nbsp;get_pgroup()))&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puser&nbsp;=&nbsp;pbase->user_list[j].work;
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;puser;
}
/**************************************************************************
|&nbsp;Reset&nbsp;all&nbsp;three&nbsp;data&nbsp;scans&nbsp;for&nbsp;this&nbsp;user.&nbsp;Only&nbsp;one&nbsp;scan&nbsp;is&nbsp;actually&nbsp;in
|&nbsp;use&nbsp;on&nbsp;a&nbsp;given&nbsp;device,&nbsp;but&nbsp;it's&nbsp;less&nbsp;trouble&nbsp;to&nbsp;have&nbsp;a&nbsp;single&nbsp;function.
|**************************************************************************/
static&nbsp;void
reset_scans(snoop_user_t&nbsp;*puser)
{
&nbsp;&nbsp;&nbsp;&nbsp;puser->read_len&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;puser->v_last_edge&nbsp;=&nbsp;GRAPH_VERTEX_NONE;
&nbsp;&nbsp;&nbsp;&nbsp;puser->edge_place&nbsp;=&nbsp;EDGE_PLACE_WANT_REAL_EDGES;
&nbsp;&nbsp;&nbsp;&nbsp;puser->info_place&nbsp;=&nbsp;GRAPH_INFO_PLACE_NONE;
&nbsp;&nbsp;&nbsp;&nbsp;puser->hinv_place&nbsp;=&nbsp;INVPLACE_NONE;
}
/**************************************************************************
|&nbsp;Allocate&nbsp;a&nbsp;snoop_user_t&nbsp;for&nbsp;the&nbsp;calling&nbsp;process&nbsp;and&nbsp;install&nbsp;it&nbsp;in&nbsp;the
|&nbsp;user_list.&nbsp;&nbsp;The&nbsp;caller&nbsp;must&nbsp;hold&nbsp;dev_lock&nbsp;as&nbsp;a&nbsp;writer.&nbsp;&nbsp;Errors:
|&nbsp;&nbsp;&nbsp;if&nbsp;the&nbsp;calling&nbsp;pgroup&nbsp;already&nbsp;has&nbsp;this&nbsp;device&nbsp;open,&nbsp;EBUSY
|&nbsp;&nbsp;&nbsp;if&nbsp;there&nbsp;is&nbsp;no&nbsp;open&nbsp;slot&nbsp;in&nbsp;the&nbsp;user_list,&nbsp;EMFILE
|&nbsp;&nbsp;&nbsp;if&nbsp;kmem_alloc&nbsp;fails,&nbsp;ENOMEM
|&nbsp;Initialize&nbsp;the&nbsp;lock&nbsp;and&nbsp;all&nbsp;3&nbsp;data&nbsp;scans&nbsp;before&nbsp;setting&nbsp;the&nbsp;pointer.
|&nbsp;Increment&nbsp;the&nbsp;generation&nbsp;count&nbsp;of&nbsp;the&nbsp;slot.
|**************************************************************************/
static&nbsp;int
alloc_user(snoop_base_t&nbsp;*pbase)
{
&nbsp;&nbsp;&nbsp;&nbsp;snoop_user_t&nbsp;*puser;
&nbsp;&nbsp;&nbsp;&nbsp;pid_t&nbsp;pgroup&nbsp;=&nbsp;get_pgroup();
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;j&nbsp;=&nbsp;get_user_index(pbase,pgroup);

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(j&nbsp;!=&nbsp;-1)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG0("rejecting&nbsp;open,&nbsp;pgid&nbsp;in&nbsp;list");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;EBUSY;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;for(j=0&nbsp;;j&lt;MAX_PGID;++j)&nbsp;{&nbsp;/*&nbsp;find&nbsp;empty&nbsp;user_list&nbsp;slot&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!(pbase->user_list[j].user))&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(j>=MAX_PGID)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG0("user&nbsp;list&nbsp;full&nbsp;at&nbsp;open");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;EMFILE;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;puser&nbsp;=&nbsp;kmem_alloc(sizeof(*puser),KM_SLEEP+KM_CACHEALIGN);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!puser)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERRMSG0("unable&nbsp;to&nbsp;allocate&nbsp;user&nbsp;struct&nbsp;at&nbsp;open");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ENOMEM;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_INIT(&amp;puser->use_lock,MUTEX_DEFAULT,PREFIX_STRING);
&nbsp;&nbsp;&nbsp;&nbsp;puser->v_current&nbsp;=&nbsp;hwgraph_root;&nbsp;/*&nbsp;"/hw"&nbsp;vertex,&nbsp;see&nbsp;hwgraph.h&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;reset_scans(puser);
&nbsp;&nbsp;&nbsp;&nbsp;pbase->user_list[j].user&nbsp;=&nbsp;pgroup;
&nbsp;&nbsp;&nbsp;&nbsp;pbase->user_list[j].generation&nbsp;+=&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;pbase->user_list[j].work&nbsp;=&nbsp;puser;
&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG3("user&nbsp;for&nbsp;pgid&nbsp;%d&nbsp;at&nbsp;0x%x&nbsp;in&nbsp;slot&nbsp;%d",pgroup,puser,j);
&nbsp;&nbsp;&nbsp;&nbsp;++&nbsp;pbase->nopen;
&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG1("&nbsp;&nbsp;&nbsp;now&nbsp;%d&nbsp;open",pbase->nopen);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
/**************************************************************************
|&nbsp;Set&nbsp;up&nbsp;the&nbsp;next&nbsp;edge&nbsp;label&nbsp;from&nbsp;the&nbsp;current&nbsp;vertex&nbsp;as&nbsp;the&nbsp;read&nbsp;data.
|&nbsp;If&nbsp;there&nbsp;is&nbsp;no&nbsp;next&nbsp;edge&nbsp;label,&nbsp;set&nbsp;up&nbsp;to&nbsp;return&nbsp;0&nbsp;bytes.
|&nbsp;This&nbsp;function&nbsp;is&nbsp;used&nbsp;for&nbsp;read()&nbsp;to&nbsp;the&nbsp;device&nbsp;/hw/snoop/edge.
|&nbsp;The&nbsp;caller,&nbsp;snoop_read(),&nbsp;has&nbsp;checked&nbsp;that&nbsp;puser->read&nbsp;==&nbsp;0.
|**************************************************************************/
static&nbsp;void
val_edge(snoop_user_t&nbsp;*puser)
{
&nbsp;&nbsp;&nbsp;&nbsp;graph_error_t&nbsp;err;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(puser->v_current&nbsp;!=&nbsp;GRAPH_VERTEX_NONE)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err&nbsp;=&nbsp;hwgraph_edge_get_next(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puser->v_current,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;in&nbsp;source&nbsp;vertex&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puser->scratch,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;out&nbsp;big&nbsp;buffer&nbsp;for&nbsp;string&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;puser->v_last_edge,&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;out&nbsp;save&nbsp;destination&nbsp;vertex&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;puser->edge_place);&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;inout&nbsp;scan&nbsp;position&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!err)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;we&nbsp;got&nbsp;a&nbsp;string...&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puser->read_ptr&nbsp;=&nbsp;puser->scratch;&nbsp;&nbsp;&nbsp;/*&nbsp;..set&nbsp;up&nbsp;as&nbsp;read&nbsp;data&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puser->read_len&nbsp;=&nbsp;1+strlen(puser->scratch);&nbsp;/*&nbsp;incl.&nbsp;null&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;no&nbsp;edge&nbsp;string,&nbsp;leave&nbsp;len=0&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(err&nbsp;!=&nbsp;GRAPH_NOT_FOUND)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;..unexpected&nbsp;cause?&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERRMSG1("hwgraph_edge_get_next&nbsp;err&nbsp;%d",&nbsp;err);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}
/**************************************************************************
|&nbsp;Set&nbsp;up&nbsp;the&nbsp;next&nbsp;attr&nbsp;label&nbsp;from&nbsp;the&nbsp;current&nbsp;vertex&nbsp;as&nbsp;the&nbsp;read&nbsp;data.
|&nbsp;If&nbsp;there&nbsp;is&nbsp;no&nbsp;next&nbsp;attr&nbsp;label,&nbsp;set&nbsp;up&nbsp;to&nbsp;return&nbsp;0&nbsp;bytes.
|&nbsp;This&nbsp;function&nbsp;is&nbsp;used&nbsp;for&nbsp;read()&nbsp;to&nbsp;the&nbsp;device&nbsp;/hw/snoop/attr.
|**************************************************************************/
static&nbsp;void
val_attr(snoop_user_t&nbsp;*puser)
{
&nbsp;&nbsp;&nbsp;&nbsp;graph_error_t&nbsp;err;
&nbsp;&nbsp;&nbsp;&nbsp;arbitrary_info_t&nbsp;junk;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(puser->v_current&nbsp;!=&nbsp;GRAPH_VERTEX_NONE)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err&nbsp;=&nbsp;hwgraph_info_get_next_LBL(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puser->v_current,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;in&nbsp;source&nbsp;vertex&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puser->scratch,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;out&nbsp;big&nbsp;buffer&nbsp;for&nbsp;string&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;junk,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;don't&nbsp;want&nbsp;the&nbsp;info&nbsp;ptr&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;puser->info_place);&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;inout&nbsp;scan&nbsp;position&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!err)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;we&nbsp;got&nbsp;a&nbsp;string...&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puser->read_ptr&nbsp;=&nbsp;puser->scratch;&nbsp;&nbsp;&nbsp;/*&nbsp;..set&nbsp;up&nbsp;as&nbsp;read&nbsp;data&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puser->read_len&nbsp;=&nbsp;1+strlen(puser->scratch);&nbsp;/*&nbsp;incl.&nbsp;null&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;no&nbsp;edge&nbsp;string,&nbsp;leave&nbsp;len=0&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(err&nbsp;!=&nbsp;GRAPH_NOT_FOUND)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;..unexpected&nbsp;cause?&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERRMSG1("hwgraph_info_get_next&nbsp;err&nbsp;%d\n",&nbsp;err);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}
/**************************************************************************
|&nbsp;Set&nbsp;up&nbsp;the&nbsp;next&nbsp;inventory_t&nbsp;from&nbsp;the&nbsp;current&nbsp;vertex&nbsp;as&nbsp;the&nbsp;read&nbsp;data.
|&nbsp;If&nbsp;there&nbsp;is&nbsp;no&nbsp;next&nbsp;data,&nbsp;set&nbsp;up&nbsp;to&nbsp;return&nbsp;0&nbsp;bytes.
|&nbsp;This&nbsp;function&nbsp;is&nbsp;used&nbsp;for&nbsp;read()&nbsp;to&nbsp;the&nbsp;device&nbsp;/hw/snoop/hinv.
|**************************************************************************/
static&nbsp;void
val_hinv(snoop_user_t&nbsp;*puser)
{
&nbsp;&nbsp;&nbsp;&nbsp;graph_error_t&nbsp;err;
&nbsp;&nbsp;&nbsp;&nbsp;inventory_t&nbsp;*invp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(puser->v_current&nbsp;!=&nbsp;GRAPH_VERTEX_NONE)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err&nbsp;=&nbsp;hwgraph_inventory_get_next(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puser->v_current,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;in&nbsp;source&nbsp;vertex&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;puser->hinv_place,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;inout&nbsp;scan&nbsp;position&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;invp&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;out&nbsp;->inventory_t&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!err)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puser->read_ptr&nbsp;=&nbsp;(char*)invp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puser->read_len&nbsp;=&nbsp;sizeof(inventory_t);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;no&nbsp;inv&nbsp;data,&nbsp;leave&nbsp;len=0&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(err&nbsp;!=&nbsp;GRAPH_NOT_FOUND)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;..unexpected&nbsp;cause?&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERRMSG1("hwgraph_info_get_next&nbsp;err&nbsp;%d\n",&nbsp;err);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}
/**************************************************************************
|&nbsp;At&nbsp;initialization&nbsp;time,&nbsp;create&nbsp;a&nbsp;char&nbsp;special&nbsp;device&nbsp;"/hw/snoop/&lt;name>"
|&nbsp;The&nbsp;&lt;name>&nbsp;is&nbsp;"edge,"&nbsp;"attr,"&nbsp;or&nbsp;"hinv."&nbsp;&nbsp;v_snoop&nbsp;is&nbsp;the&nbsp;handle&nbsp;of&nbsp;the
|&nbsp;master&nbsp;node,&nbsp;expected&nbsp;to&nbsp;be&nbsp;"/hw/snoop."
|**************************************************************************/
static&nbsp;int
init_dev(char&nbsp;*name,&nbsp;vertex_hdl_t&nbsp;v_snoop,&nbsp;val_func&nbsp;func)
{
&nbsp;&nbsp;&nbsp;&nbsp;graph_error_t&nbsp;err;
&nbsp;&nbsp;&nbsp;&nbsp;vertex_hdl_t&nbsp;v_dev&nbsp;=&nbsp;GRAPH_VERTEX_NONE;
&nbsp;&nbsp;&nbsp;&nbsp;snoop_base_t&nbsp;*pbase&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;See&nbsp;if&nbsp;the&nbsp;device&nbsp;already&nbsp;exists.
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;err&nbsp;=&nbsp;hwgraph_edge_get(v_snoop,name,&amp;v_dev);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(err&nbsp;!=&nbsp;GRAPH_SUCCESS)&nbsp;{&nbsp;/*&nbsp;it&nbsp;does&nbsp;not.&nbsp;create&nbsp;it.&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err&nbsp;=&nbsp;hwgraph_char_device_add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v_snoop,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;starting&nbsp;vertex&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;path,&nbsp;in&nbsp;this&nbsp;case&nbsp;just&nbsp;a&nbsp;name&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PREFIX_STRING,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;our&nbsp;driver&nbsp;prefix&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;v_dev);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;out:&nbsp;new&nbsp;vertex&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(err)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERRMSG2("char_device_add(%s)&nbsp;error&nbsp;%d",name,err);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;err;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG2("created&nbsp;device&nbsp;%s,&nbsp;vhdl&nbsp;0x%x",name,v_dev);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG2("found&nbsp;device&nbsp;%s,&nbsp;vhdl&nbsp;0x%x",name,v_dev);
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;The&nbsp;device&nbsp;vertex&nbsp;exists.&nbsp;See&nbsp;if&nbsp;it&nbsp;already&nbsp;contains&nbsp;a&nbsp;snoop_base_t
&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;from&nbsp;a&nbsp;previous&nbsp;load.&nbsp;If&nbsp;the&nbsp;vertex&nbsp;was&nbsp;only&nbsp;just&nbsp;created,
&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;this&nbsp;returns&nbsp;NULL&nbsp;and&nbsp;we&nbsp;need&nbsp;to&nbsp;aallocate&nbsp;a&nbsp;base&nbsp;struct.
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;pbase&nbsp;=&nbsp;device_info_get(v_dev);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!pbase)&nbsp;{&nbsp;/*&nbsp;no&nbsp;device&nbsp;info&nbsp;yet&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pbase&nbsp;=&nbsp;kmem_zalloc(sizeof(*pbase),KM_SLEEP);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!pbase)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERRMSG0("failed&nbsp;to&nbsp;allocate&nbsp;base&nbsp;struct");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ENOMEM;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RW_INIT(&amp;pbase->dev_lock,&nbsp;PREFIX_STRING);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG1("&nbsp;&nbsp;&nbsp;base&nbsp;struct&nbsp;at&nbsp;0x%x",pbase);
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;This&nbsp;is&nbsp;a&nbsp;key&nbsp;step:&nbsp;on&nbsp;a&nbsp;reload,&nbsp;we&nbsp;must&nbsp;refresh&nbsp;the&nbsp;address
&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;of&nbsp;the&nbsp;value&nbsp;function,&nbsp;which&nbsp;is&nbsp;different&nbsp;from&nbsp;when&nbsp;we&nbsp;last&nbsp;loaded.
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;pbase->vector&nbsp;=&nbsp;func;
&nbsp;&nbsp;&nbsp;&nbsp;device_info_set(v_dev,pbase);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
/**************************************************************************
|&nbsp;At&nbsp;the&nbsp;pfx_init()&nbsp;entry&nbsp;point&nbsp;we&nbsp;establish&nbsp;our&nbsp;hwgraph&nbsp;presence
|&nbsp;consisting&nbsp;of&nbsp;three&nbsp;character&nbsp;special&nbsp;devices.&nbsp;&nbsp;The&nbsp;base&nbsp;path&nbsp;string
|&nbsp;is&nbsp;"/hw/snoop"&nbsp;by&nbsp;default,&nbsp;however&nbsp;we&nbsp;accept&nbsp;input&nbsp;from&nbsp;the&nbsp;
|&nbsp;driver-administration&nbsp;interface.
|&nbsp;Unload/reload&nbsp;issues:&nbsp;hwgraph_path_add&nbsp;and&nbsp;hwgraph_char_device_add&nbsp;do
|&nbsp;not&nbsp;return&nbsp;error&nbsp;codes&nbsp;when&nbsp;called&nbsp;to&nbsp;add&nbsp;an&nbsp;existing&nbsp;path!&nbsp;&nbsp;The&nbsp;only
|&nbsp;way&nbsp;to&nbsp;tell&nbsp;if&nbsp;our&nbsp;device&nbsp;paths&nbsp;exist&nbsp;already&nbsp;--&nbsp;meaning&nbsp;we&nbsp;have&nbsp;been
|&nbsp;unloaded&nbsp;and&nbsp;reloaded&nbsp;--&nbsp;is&nbsp;to&nbsp;test&nbsp;for&nbsp;them&nbsp;explicitly.
|**************************************************************************/
int
PFX_INIT()
{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;err;
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*&nbsp;path;
&nbsp;&nbsp;&nbsp;&nbsp;vertex_hdl_t&nbsp;v_snoop;
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;testpath[256];
&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*&nbsp;admin;
&nbsp;&nbsp;&nbsp;&nbsp;admin&nbsp;=&nbsp;device_driver_admin_info_get(PREFIX_STRING,ADMIN_LABEL);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(admin)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path&nbsp;=&nbsp;admin;
&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path&nbsp;=&nbsp;"/snoop";
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;The&nbsp;following&nbsp;call&nbsp;returns&nbsp;success&nbsp;when&nbsp;the&nbsp;requested&nbsp;path
&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;exists&nbsp;already,&nbsp;or&nbsp;when&nbsp;the&nbsp;path&nbsp;can&nbsp;be&nbsp;created&nbsp;at&nbsp;this&nbsp;time.
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;err&nbsp;=&nbsp;hwgraph_path_add(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GRAPH_VERTEX_NONE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;start&nbsp;at&nbsp;/hw&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;this&nbsp;is&nbsp;the&nbsp;path&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;v_snoop);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;put&nbsp;vertex&nbsp;there&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG2("adding&nbsp;path&nbsp;%s&nbsp;returns&nbsp;%d",path,err);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!err)&nbsp;err&nbsp;=&nbsp;init_dev("edge",v_snoop,val_edge);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!err)&nbsp;err&nbsp;=&nbsp;init_dev("attr",v_snoop,val_attr);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!err)&nbsp;err&nbsp;=&nbsp;init_dev("hinv",v_snoop,val_hinv);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;err;
}
/**************************************************************************
|&nbsp;The&nbsp;pfx_start()&nbsp;entry&nbsp;point&nbsp;is&nbsp;only&nbsp;included&nbsp;to&nbsp;prove&nbsp;it&nbsp;is&nbsp;called.
|**************************************************************************/
int
PFX_START()
{
&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG0("start()&nbsp;entry&nbsp;point&nbsp;called");
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
/**************************************************************************
|&nbsp;The&nbsp;pfx_reg()&nbsp;entry&nbsp;point&nbsp;is&nbsp;only&nbsp;included&nbsp;to&nbsp;prove&nbsp;it&nbsp;is&nbsp;called.
|**************************************************************************/
int
PFX_REG()
{
&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG0("reg()&nbsp;entry&nbsp;point&nbsp;called");
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
/**************************************************************************
|&nbsp;The&nbsp;pfx_unload()&nbsp;entry&nbsp;point&nbsp;is&nbsp;not&nbsp;supposed&nbsp;to&nbsp;be&nbsp;called&nbsp;unless&nbsp;all
|&nbsp;uses&nbsp;of&nbsp;our&nbsp;devices&nbsp;have&nbsp;been&nbsp;closed&nbsp;and&nbsp;pfx_close&nbsp;called.&nbsp;&nbsp;That&nbsp;had
|&nbsp;better&nbsp;be&nbsp;right,&nbsp;because&nbsp;there&nbsp;is&nbsp;no&nbsp;convenient&nbsp;way&nbsp;for&nbsp;us&nbsp;at&nbsp;this&nbsp;time
|&nbsp;to&nbsp;double-check.&nbsp;&nbsp;If&nbsp;this&nbsp;was&nbsp;not&nbsp;a&nbsp;loadable&nbsp;driver,&nbsp;we&nbsp;could&nbsp;keep&nbsp;
|&nbsp;static&nbsp;pointers&nbsp;to&nbsp;our&nbsp;snoop_base_t&nbsp;structures,&nbsp;and&nbsp;a&nbsp;static&nbsp;count&nbsp;of
|&nbsp;open&nbsp;files,&nbsp;for&nbsp;that&nbsp;matter.&nbsp;&nbsp;However,&nbsp;static&nbsp;variables&nbsp;are&nbsp;zero'd&nbsp;
|&nbsp;following&nbsp;a&nbsp;reload.&nbsp;&nbsp;So&nbsp;those&nbsp;would&nbsp;only&nbsp;be&nbsp;good&nbsp;until&nbsp;the&nbsp;first
|&nbsp;unload/reload&nbsp;sequence.
|**************************************************************************/
int
PFX_UNLOAD()
{
&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG0("unload()&nbsp;entry&nbsp;point&nbsp;called");
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
/**************************************************************************
|&nbsp;At&nbsp;the&nbsp;pfx_open()&nbsp;entry&nbsp;point&nbsp;we&nbsp;allocate&nbsp;a&nbsp;work&nbsp;structure&nbsp;for&nbsp;the
|&nbsp;client&nbsp;process&nbsp;group,&nbsp;if&nbsp;possible.&nbsp;&nbsp;This&nbsp;requires&nbsp;getting&nbsp;a&nbsp;writer&nbsp;lock
|&nbsp;on&nbsp;the&nbsp;dev_lock.&nbsp;&nbsp;It&nbsp;is&nbsp;possible,&nbsp;in&nbsp;principle,&nbsp;for&nbsp;this&nbsp;entry&nbsp;point
|&nbsp;to&nbsp;be&nbsp;called&nbsp;while&nbsp;the&nbsp;init()&nbsp;entry&nbsp;point&nbsp;is&nbsp;still&nbsp;running,&nbsp;after&nbsp;the
|&nbsp;vertex&nbsp;has&nbsp;been&nbsp;created&nbsp;and&nbsp;before&nbsp;the&nbsp;device&nbsp;info&nbsp;has&nbsp;been&nbsp;stored.
|&nbsp;So&nbsp;in&nbsp;this&nbsp;entry&nbsp;point&nbsp;only,&nbsp;we&nbsp;check&nbsp;to&nbsp;make&nbsp;sure&nbsp;device&nbsp;info&nbsp;exists.
|**************************************************************************/
int
PFX_OPEN(dev_t&nbsp;*devp,&nbsp;int&nbsp;oflag,&nbsp;int&nbsp;otyp,&nbsp;cred_t&nbsp;*crp) {
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ret;
&nbsp;&nbsp;&nbsp;&nbsp;vertex_hdl_t&nbsp;v_dev&nbsp;=&nbsp;(vertex_hdl_t)*devp;
&nbsp;&nbsp;&nbsp;&nbsp;snoop_base_t&nbsp;*pbase&nbsp;=&nbsp;device_info_get(v_dev);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!pbase)&nbsp;return&nbsp;ENODEV;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG3("open(dev=0x%x,&nbsp;oflag=0x%x,&nbsp;otyp=0x%x...)",v_dev,oflag,otyp);
&nbsp;&nbsp;&nbsp;&nbsp;RW_WRLOCK(&amp;pbase->dev_lock);
&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;alloc_user(pbase);
&nbsp;&nbsp;&nbsp;&nbsp;RW_UNLOCK(&amp;pbase->dev_lock);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ret;
}
/**************************************************************************
|&nbsp;The&nbsp;pfx_close()&nbsp;entry&nbsp;point&nbsp;is&nbsp;called&nbsp;only&nbsp;when&nbsp;>>all&lt;&lt;&nbsp;processes&nbsp;have
|&nbsp;closed&nbsp;a&nbsp;device.&nbsp;&nbsp;The&nbsp;entire&nbsp;user_list&nbsp;array&nbsp;can&nbsp;be&nbsp;cleared&nbsp;out&nbsp;and
|&nbsp;any&nbsp;remaining&nbsp;snoop_user&nbsp;structs&nbsp;freed.
|**************************************************************************/
int
PFX_CLOSE(dev_t&nbsp;dev,&nbsp;int&nbsp;flag,&nbsp;int&nbsp;otyp,&nbsp;cred_t&nbsp;*crp)
{
&nbsp;&nbsp;&nbsp;&nbsp;vertex_hdl_t&nbsp;v_dev&nbsp;=&nbsp;(vertex_hdl_t)dev;
&nbsp;&nbsp;&nbsp;&nbsp;snoop_base_t&nbsp;*pbase&nbsp;=&nbsp;device_info_get(v_dev);
&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;j;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG2("close(dev=0x%x,&nbsp;%d&nbsp;opens)",v_dev,pbase->nopen);
&nbsp;&nbsp;&nbsp;&nbsp;RW_WRLOCK(&amp;pbase->dev_lock);
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(j=0;j&lt;MAX_PGID;++j)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pbase->user_list[j].user)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kmem_free(pbase->user_list[j].work,sizeof(snoop_user_t));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pbase->user_list[j].user&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pbase->user_list[j].work&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;pbase->nopen&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;RW_UNLOCK(&amp;pbase->dev_lock);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
/**************************************************************************
|&nbsp;The&nbsp;pfx_read()&nbsp;entry&nbsp;point&nbsp;finds&nbsp;some&nbsp;data&nbsp;by&nbsp;calling&nbsp;the&nbsp;one&nbsp;(of&nbsp;3)
|&nbsp;scan&nbsp;functions&nbsp;appropriate&nbsp;to&nbsp;this&nbsp;device.&nbsp;&nbsp;If&nbsp;data&nbsp;is&nbsp;found,&nbsp;it&nbsp;is
|&nbsp;copied&nbsp;to&nbsp;the&nbsp;user&nbsp;buffer,&nbsp;up&nbsp;to&nbsp;min(data&nbsp;length,&nbsp;user&nbsp;buffer&nbsp;size).
|&nbsp;This&nbsp;function&nbsp;does&nbsp;not&nbsp;modify&nbsp;the&nbsp;snoop_base,&nbsp;so&nbsp;it&nbsp;needs&nbsp;only&nbsp;the
|&nbsp;reader&nbsp;lock.&nbsp;It&nbsp;does&nbsp;modify&nbsp;the&nbsp;snoop_user,&nbsp;so&nbsp;has&nbsp;to&nbsp;lock&nbsp;that&nbsp;because
|&nbsp;multiple&nbsp;user&nbsp;threads&nbsp;can&nbsp;read&nbsp;the&nbsp;same&nbsp;FD&nbsp;concurrently.
|**************************************************************************/ 
int
PFX_READ(dev_t&nbsp;dev,&nbsp;uio_t&nbsp;*uiop,&nbsp;cred_t&nbsp;*crp)
{
&nbsp;&nbsp;&nbsp;&nbsp;vertex_hdl_t&nbsp;v_dev&nbsp;=&nbsp;(vertex_hdl_t)dev;
&nbsp;&nbsp;&nbsp;&nbsp;snoop_base_t&nbsp;*pbase&nbsp;=&nbsp;device_info_get(v_dev);
&nbsp;&nbsp;&nbsp;&nbsp;snoop_user_t&nbsp;*puser;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;RW_RDLOCK(&amp;pbase->dev_lock);&nbsp;/*&nbsp;block&nbsp;out&nbsp;open,&nbsp;close&nbsp;on&nbsp;device&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;puser&nbsp;=&nbsp;get_user(pbase);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!puser)&nbsp;{&nbsp;/*&nbsp;very&nbsp;unlikely&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG0("reject&nbsp;read&nbsp;-&nbsp;no&nbsp;user");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RW_UNLOCK(&amp;pbase->dev_lock);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;EINVAL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_LOCK(&amp;puser->use_lock,-1);&nbsp;/*&nbsp;block&nbsp;other&nbsp;threads&nbsp;from&nbsp;work&nbsp;area&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG2("read&nbsp;request&nbsp;%d&nbsp;bytes&nbsp;to&nbsp;0x%x",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uiop->uio_resid,uiop->uio_iov->iov_base);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(0&nbsp;==&nbsp;puser->read_len)&nbsp;{&nbsp;/*&nbsp;need&nbsp;to&nbsp;rustle&nbsp;up&nbsp;some&nbsp;data&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pbase->vector(puser);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(puser->read_len)&nbsp;{&nbsp;/*&nbsp;we&nbsp;have&nbsp;some&nbsp;data&nbsp;(now)&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;j,&nbsp;ret;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;(uiop->uio_resid>puser->read_len)?puser->read_len:uiop->uio_resid;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;uiomove(puser->read_ptr,j,UIO_READ,uiop);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(0==ret)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puser->read_len&nbsp;-=&nbsp;j;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puser->read_ptr&nbsp;+=&nbsp;j;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG1("&nbsp;&nbsp;&nbsp;moved&nbsp;%d&nbsp;bytes",j);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERRMSG1("error&nbsp;%d&nbsp;from&nbsp;uiomove",ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG0("&nbsp;&nbsp;&nbsp;&nbsp;no&nbsp;data&nbsp;available");
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_UNLOCK(&amp;puser->use_lock);
&nbsp;&nbsp;&nbsp;&nbsp;RW_UNLOCK(&amp;pbase->dev_lock);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;
}
/**************************************************************************
|&nbsp;The&nbsp;pfx_write()&nbsp;entry&nbsp;point&nbsp;accepts&nbsp;data&nbsp;into&nbsp;the&nbsp;scratch&nbsp;area.&nbsp;No&nbsp;matter
|&nbsp;what&nbsp;happens,&nbsp;the&nbsp;input&nbsp;scan&nbsp;on&nbsp;this&nbsp;user&nbsp;is&nbsp;going&nbsp;to&nbsp;be&nbsp;reset,&nbsp;so&nbsp;if
|&nbsp;there&nbsp;is&nbsp;residual&nbsp;data&nbsp;in&nbsp;the&nbsp;scratch&nbsp;area,&nbsp;it&nbsp;can&nbsp;be&nbsp;overwritten.
|&nbsp;All&nbsp;the&nbsp;write&nbsp;data&nbsp;is&nbsp;moved&nbsp;to&nbsp;scratch&nbsp;and&nbsp;treated&nbsp;as&nbsp;a&nbsp;hwgraph&nbsp;path.
|&nbsp;It&nbsp;can&nbsp;be&nbsp;absolute&nbsp;or&nbsp;relative&nbsp;to&nbsp;the&nbsp;current&nbsp;vertex.&nbsp;&nbsp;We&nbsp;traverse
|&nbsp;to&nbsp;that&nbsp;vertex&nbsp;and&nbsp;if&nbsp;it&nbsp;is&nbsp;found,&nbsp;make&nbsp;it&nbsp;the&nbsp;current&nbsp;vertex.
|**************************************************************************/
int
PFX_WRITE(dev_t&nbsp;dev,&nbsp;uio_t&nbsp;*uiop,&nbsp;cred_t&nbsp;*crp)
{
&nbsp;&nbsp;&nbsp;&nbsp;vertex_hdl_t&nbsp;v_dev&nbsp;=&nbsp;(vertex_hdl_t)dev;
&nbsp;&nbsp;&nbsp;&nbsp;snoop_base_t&nbsp;*pbase&nbsp;=&nbsp;device_info_get(v_dev);
&nbsp;&nbsp;&nbsp;&nbsp;snoop_user_t&nbsp;*puser;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ret&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;user_lock&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;len;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;RW_RDLOCK(&amp;pbase->dev_lock);&nbsp;/*&nbsp;block&nbsp;out&nbsp;open,&nbsp;close&nbsp;on&nbsp;device&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;puser&nbsp;=&nbsp;get_user(pbase);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!puser)&nbsp;{&nbsp;/*&nbsp;very&nbsp;unlikely&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG0("reject&nbsp;write&nbsp;-&nbsp;no&nbsp;user");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;EINVAL;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!ret)&nbsp;{&nbsp;/*&nbsp;user&nbsp;(pgroup)&nbsp;is&nbsp;valid&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len&nbsp;=&nbsp;uiop->uio_resid;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG2("write&nbsp;request&nbsp;%d&nbsp;bytes&nbsp;from&nbsp;0x%x",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uiop->uio_iov->iov_base);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(len&nbsp;>=&nbsp;sizeof(puser->scratch))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;ENOSPC;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG0("&nbsp;&nbsp;&nbsp;rejected,&nbsp;path&nbsp;too&nbsp;long");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(!len)&nbsp;{&nbsp;/*&nbsp;write&nbsp;for&nbsp;0&nbsp;bytes?&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;EINVAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG0("&nbsp;&nbsp;&nbsp;rejected,&nbsp;0&nbsp;length");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!ret)&nbsp;{&nbsp;/*&nbsp;data&nbsp;length&nbsp;is&nbsp;acceptable&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_LOCK(&amp;puser->use_lock,-1);&nbsp;/*&nbsp;block&nbsp;others&nbsp;from&nbsp;work&nbsp;area&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user_lock&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;remember&nbsp;to&nbsp;unlock&nbsp;it&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reset_scans(puser);&nbsp;/*&nbsp;now&nbsp;we&nbsp;lose&nbsp;scan&nbsp;positioning&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;uiomove(puser->scratch,len,UIO_WRITE,uiop);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(0&nbsp;==&nbsp;ret)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puser->scratch[len]&nbsp;=&nbsp;'\0';&nbsp;/*&nbsp;terminate&nbsp;string&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;/*&nbsp;couldn't&nbsp;move&nbsp;it?&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ERRMSG1("error&nbsp;%d&nbsp;from&nbsp;uiomove",ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!ret)&nbsp;{&nbsp;/*&nbsp;path&nbsp;data&nbsp;has&nbsp;been&nbsp;copied&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertex_hdl_t&nbsp;v_end;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*&nbsp;path&nbsp;=&nbsp;puser->scratch;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(*path&nbsp;==&nbsp;'/')&nbsp;{&nbsp;/*&nbsp;absolute&nbsp;path&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v_end&nbsp;=&nbsp;hwgraph_path_to_vertex(path);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(v_end&nbsp;==&nbsp;GRAPH_VERTEX_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;GRAPH_NOT_FOUND;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;/*&nbsp;relative&nbsp;path&nbsp;to&nbsp;current&nbsp;vertex&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;hwgraph_traverse(puser->v_current,path,&amp;v_end);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!ret)&nbsp;{&nbsp;/*&nbsp;v_end&nbsp;is&nbsp;a&nbsp;valid&nbsp;endpoint&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void)hwgraph_vertex_unref(puser->v_current);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puser->v_current&nbsp;=&nbsp;v_end;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG2("lookup&nbsp;(%s)&nbsp;=&nbsp;%d",puser->scratch,ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;ESPIPE;&nbsp;/*&nbsp;"illegal&nbsp;seek"&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(user_lock)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_UNLOCK(&amp;puser->use_lock);
&nbsp;&nbsp;&nbsp;&nbsp;RW_UNLOCK(&amp;pbase->dev_lock);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ret;
}
/**************************************************************************
|&nbsp;the&nbsp;pfx_ioctl()&nbsp;entry&nbsp;point&nbsp;receives&nbsp;ioctl()&nbsp;calls.&nbsp;Cleverly,&nbsp;all&nbsp;the
|&nbsp;supported&nbsp;ioctl&nbsp;calls&nbsp;are&nbsp;designed&nbsp;to&nbsp;use&nbsp;no&nbsp;"arg"&nbsp;parameters,&nbsp;thus
|&nbsp;avoiding&nbsp;all&nbsp;questions&nbsp;of&nbsp;user&nbsp;ABI.
***************************************************************************/
int
PFX_IOCTL(dev_t&nbsp;dev,&nbsp;int&nbsp;cmd,&nbsp;void&nbsp;*arg,&nbsp;int&nbsp;mode,&nbsp;cred_t&nbsp;*crp,&nbsp;int&nbsp;*rvalp)
{
&nbsp;&nbsp;&nbsp;&nbsp;vertex_hdl_t&nbsp;v_dev&nbsp;=&nbsp;(vertex_hdl_t)dev;
&nbsp;&nbsp;&nbsp;&nbsp;snoop_base_t&nbsp;*pbase&nbsp;=&nbsp;device_info_get(v_dev);
&nbsp;&nbsp;&nbsp;&nbsp;snoop_user_t&nbsp;*puser;
&nbsp;&nbsp;&nbsp;&nbsp;vertex_hdl_t&nbsp;v_mast;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ret&nbsp;=&nbsp;0;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;RW_RDLOCK(&amp;pbase->dev_lock);&nbsp;/*&nbsp;block&nbsp;out&nbsp;open,&nbsp;close&nbsp;on&nbsp;device&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;puser&nbsp;=&nbsp;get_user(pbase);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!puser)&nbsp;{&nbsp;/*&nbsp;very&nbsp;unlikely&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG0("reject&nbsp;ioctl&nbsp;-&nbsp;no&nbsp;user");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RW_UNLOCK(&amp;pbase->dev_lock);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(*rvalp&nbsp;=&nbsp;EINVAL);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_LOCK(&amp;puser->use_lock,-1);&nbsp;/*&nbsp;block&nbsp;out&nbsp;other&nbsp;threads&nbsp;on&nbsp;file&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;switch(cmd)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;IOCTL_MASTER_TEST:&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;Request&nbsp;the&nbsp;master&nbsp;vertex&nbsp;and&nbsp;return&nbsp;either&nbsp;0&nbsp;or&nbsp;ENOENT.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v_mast&nbsp;=&nbsp;device_master_get(puser->v_current);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(v_mast&nbsp;==&nbsp;GRAPH_VERTEX_NONE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;ENOENT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG1("IOCTL_MASTER_TEST:&nbsp;%d",ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;IOCTL_MASTER_GO:&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;Request&nbsp;the&nbsp;master&nbsp;vertex&nbsp;and&nbsp;if&nbsp;we&nbsp;get&nbsp;it,&nbsp;make&nbsp;it&nbsp;current.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v_mast&nbsp;=&nbsp;device_master_get(puser->v_current);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(v_mast&nbsp;!=&nbsp;GRAPH_VERTEX_NONE)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hwgraph_vertex_unref(puser->v_current);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reset_scans(puser);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puser->v_current&nbsp;=&nbsp;v_mast;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;ENOENT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG1("IOCTL_MASTER_GO:&nbsp;%d",ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;IOCTL_VERTEX_GET:&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;&lt;arg>&nbsp;is&nbsp;a&nbsp;pointer&nbsp;to&nbsp;user&nbsp;space&nbsp;where&nbsp;we&nbsp;store&nbsp;a&nbsp;vertex&nbsp;handle.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(copyout(&amp;puser->v_current,arg,sizeof(puser->v_current)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;EINVAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG2("IOCTL_VERTEX_GET(0x%x):&nbsp;%d",arg,ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;IOCTL_VERTEX_SET:&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;&lt;arg>&nbsp;is&nbsp;a&nbsp;pointer&nbsp;to&nbsp;a&nbsp;vertex&nbsp;handle&nbsp;in&nbsp;user&nbsp;memory,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;hopefully&nbsp;one&nbsp;retrieved&nbsp;with&nbsp;IOCTL_VERTEX_GET.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;Use&nbsp;hwgraph_vertex_ref()&nbsp;for&nbsp;a&nbsp;quick&nbsp;validity&nbsp;check,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;and&nbsp;make&nbsp;it&nbsp;the&nbsp;current&nbsp;vertex.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertex_hdl_t&nbsp;temp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(copyin(arg,&amp;temp,sizeof(temp)))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;EINVAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!ret)&nbsp;{&nbsp;/*&nbsp;copy&nbsp;was&nbsp;ok&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;hwgraph_vertex_ref(temp);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ret==GRAPH_SUCCESS)&nbsp;{&nbsp;/*&nbsp;it's&nbsp;a&nbsp;real&nbsp;vertex&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void)&nbsp;hwgraph_vertex_unref(puser->v_current);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puser->v_current&nbsp;=&nbsp;temp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;/*&nbsp;bogus&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG2("vertex_ref(%d)&nbsp;->&nbsp;%d",temp,ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;EINVAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG2("IOCTL_VERTEX_SET(0x%x):&nbsp;%d",arg,ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;IOCTL_PATH_READ:&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;Request&nbsp;the&nbsp;"canonical&nbsp;name"&nbsp;of&nbsp;the&nbsp;current&nbsp;vertex.&nbsp;There&nbsp;are
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;cases&nbsp;in&nbsp;which&nbsp;that&nbsp;name&nbsp;cannot&nbsp;be&nbsp;formed,&nbsp;in&nbsp;which&nbsp;event&nbsp;we
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;return&nbsp;EBADF&nbsp;(seems&nbsp;logical).&nbsp;&nbsp;Otherwise,&nbsp;we&nbsp;reset&nbsp;the&nbsp;input
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;scan&nbsp;and&nbsp;set&nbsp;the&nbsp;new&nbsp;path&nbsp;as&nbsp;the&nbsp;input.&nbsp;&nbsp;The&nbsp;pfx_read()&nbsp;entry
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;will&nbsp;return&nbsp;this&nbsp;data&nbsp;until&nbsp;it&nbsp;is&nbsp;consumed.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;This&nbsp;function&nbsp;has&nbsp;to&nbsp;reset&nbsp;the&nbsp;scans&nbsp;because&nbsp;it&nbsp;has&nbsp;to&nbsp;use
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;the&nbsp;generous&nbsp;puser->scratch&nbsp;buffer.&nbsp;The&nbsp;alternative&nbsp;is&nbsp;to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;allocate&nbsp;an&nbsp;equally&nbsp;generous&nbsp;work&nbsp;area&nbsp;on&nbsp;the&nbsp;stack,&nbsp;and&nbsp;to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;copy&nbsp;the&nbsp;result&nbsp;to&nbsp;scratch&nbsp;only&nbsp;when&nbsp;hwgraph_vertex_name_get
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;succeeds.&nbsp;However,&nbsp;one,&nbsp;it&nbsp;almost&nbsp;always&nbsp;succeeds,&nbsp;and&nbsp;two,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;that&nbsp;would&nbsp;use&nbsp;too&nbsp;much&nbsp;driver&nbsp;stack&nbsp;space.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reset_scans(puser);&nbsp;/*&nbsp;ensure&nbsp;no&nbsp;pending&nbsp;data&nbsp;in&nbsp;scratch&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;hwgraph_vertex_name_get(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puser->v_current,puser->scratch,sizeof(puser->scratch));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!ret)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puser->read_ptr&nbsp;=&nbsp;puser->scratch;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puser->read_len&nbsp;=&nbsp;1+strlen(puser->scratch);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;/*&nbsp;cannot&nbsp;work&nbsp;out&nbsp;path&nbsp;for&nbsp;current&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG1("hwgraph_vertex_name_get&nbsp;ret&nbsp;%d",ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;EBADF;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG1("IOCTL_PATH_READ:&nbsp;%d",ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;IOCTL_CLOSING:&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;The&nbsp;client&nbsp;process&nbsp;(on&nbsp;behalf&nbsp;of&nbsp;its&nbsp;pgroup)&nbsp;promises&nbsp;to&nbsp;close
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;this&nbsp;device,&nbsp;permitting&nbsp;us&nbsp;to&nbsp;dispose&nbsp;of&nbsp;its&nbsp;work&nbsp;area&nbsp;in
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;advance&nbsp;of&nbsp;a&nbsp;call&nbsp;to&nbsp;pfx_close(),&nbsp;which&nbsp;only&nbsp;comes&nbsp;when&nbsp;all
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;clients&nbsp;close&nbsp;their&nbsp;files.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;&nbsp;&nbsp;In&nbsp;order&nbsp;to&nbsp;free&nbsp;the&nbsp;work&nbsp;area&nbsp;we&nbsp;must&nbsp;be&nbsp;sure&nbsp;not&nbsp;only&nbsp;that
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;no&nbsp;other&nbsp;process&nbsp;is&nbsp;using&nbsp;it,&nbsp;but&nbsp;that&nbsp;no&nbsp;other&nbsp;process&nbsp;is
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;waiting&nbsp;on&nbsp;its&nbsp;lock!&nbsp;Do&nbsp;that&nbsp;by&nbsp;releasing&nbsp;both&nbsp;locks&nbsp;and
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;getting&nbsp;the&nbsp;base&nbsp;lock&nbsp;as&nbsp;Writer.&nbsp;&nbsp;However,&nbsp;in&nbsp;the&nbsp;interval
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;after&nbsp;releasing&nbsp;the&nbsp;lock,&nbsp;strange&nbsp;things&nbsp;could&nbsp;happen!
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pid_t&nbsp;pgroup&nbsp;=&nbsp;get_pgroup();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;index_now&nbsp;=&nbsp;get_user_index(pbase,pgroup);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;gen_now&nbsp;=&nbsp;pbase->user_list[index_now].generation;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;index_then;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_UNLOCK(&amp;puser->use_lock);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RW_UNLOCK(&amp;pbase->dev_lock);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;Right&nbsp;here,&nbsp;another&nbsp;thread&nbsp;of&nbsp;the&nbsp;pgroup&nbsp;could&nbsp;call&nbsp;this
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;operation&nbsp;and&nbsp;complete&nbsp;it,&nbsp;leaving&nbsp;us&nbsp;holding&nbsp;a&nbsp;stale&nbsp;puser.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;Even&nbsp;stranger,&nbsp;it&nbsp;could&nbsp;then&nbsp;CLOSE&nbsp;the&nbsp;device&nbsp;and
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;reOPEN&nbsp;it,&nbsp;ending&nbsp;up&nbsp;in&nbsp;a&nbsp;different,&nbsp;or&nbsp;even&nbsp;in&nbsp;the&nbsp;SAME,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;slot&nbsp;of&nbsp;user_list.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RW_WRLOCK(&amp;pbase->dev_lock);&nbsp;/*&nbsp;block&nbsp;all&nbsp;other&nbsp;use&nbsp;of&nbsp;dev&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index_then&nbsp;=&nbsp;get_user_index(pbase,pgroup);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((gen_now&nbsp;==&nbsp;pbase->user_list[index_now].generation)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;&nbsp;&nbsp;(index_now&nbsp;==&nbsp;index_then))&nbsp;{&nbsp;/*&nbsp;no&nbsp;races&nbsp;going&nbsp;on&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kmem_free(puser,sizeof(snoop_user_t));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pbase->user_list[index_now].user&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pbase->user_list[index_now].work&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;puser&nbsp;=&nbsp;NULL;&nbsp;/*&nbsp;don't&nbsp;try&nbsp;to&nbsp;unlock,&nbsp;it's&nbsp;gone...&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret=EBUSY;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DBGMSG1("IOCTL_CLOSING:&nbsp;%d",ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;EINVAL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(puser)&nbsp;/*&nbsp;not&nbsp;IOCTL_CLOSING&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MUTEX_UNLOCK(&amp;puser->use_lock);
&nbsp;&nbsp;&nbsp;&nbsp;RW_UNLOCK(&amp;pbase->dev_lock);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(*rvalp&nbsp;=&nbsp;ret);
}
</CODE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="96910">User Program Source</TITLE><CODE>
/*
|     usnoop [snoop_path]
|
| Elementary unit-test of the snoop_ device driver.
|
| 1. Open all three /hw/snoop devices. Use snoop_path, if given,
|    as the base path to the edge, attr, and hinv devices.
| 2. In a loop:
|    a. Prompt the user for a path. Quit on null input.
|    b. Use write() to position the edge device to the given path.
|    c. Use ioctl to position the other two devices to that vertex.
|    d. Use read() on all 3 and dump the results.
*/
#include &lt;stdio.h>
#include &lt;errno.h> /* for errno */
#include &lt;sys/types.h> /* for vertex_hdl_t */
#include &lt;sys/stat.h> /* wanted by open */
#include &lt;fcntl.h>   /* open */
#include &lt;unistd.h> /* for read, write */
#include &lt;invent.h> /* for inventory_t */
#include "snoop.h" /* KERNEL is not defined */
#define SNOOPATH "/hw/snoop/"
#define BIG 65536
#define FAIL(x) {perror(x);fflush(stderr);return errno;}
static int edgeFD, attrFD, hinvFD; /* FD's of three devices */
int open3(char *snoop)
{ /* open all three special devices, store FD's */
&space;   int ret;
&space;   char snoopath[256];

&space;   sprintf(snoopath,"%s/%s",snoop,"edge");
&space;   edgeFD = open(snoopath, O_RDWR);
&space;   if (-1 == edgeFD) FAIL("open edge");
&space;   sprintf(snoopath,"%s/%s",snoop,"attr");
&space;   attrFD = open(snoopath, O_RDWR);
&space;   if (-1 == attrFD) FAIL("open attr");
&space;   sprintf(snoopath,"%s/%s",snoop,"hinv");
&space;   hinvFD = open(snoopath, O_RDWR);
&space;   if (-1 == hinvFD) FAIL("open hinv");
&space;   return 0;
}
int point3(char *hwpath)
{ /* position all 3 device FD's at the given path */
&space;   int ret;
&space;   unsigned long long v_targ;
&space;   int len = strlen(hwpath); /* assumes nonzero length */
&space;   ret = write(edgeFD,hwpath,len);
&space;   if (-1 == ret) FAIL("write edge");
&space;   /* read back the vhandle of each device - to see if we can */
&space;   ret = ioctl(edgeFD,IOCTL_VERTEX_GET,&amp;v_targ);
&space;   if (ret) FAIL("ioctl(edge,IOCTL_VERTEX_GET)");
&space;   ret = ioctl(attrFD,IOCTL_VERTEX_SET,&amp;v_targ);
&space;   if (ret) FAIL("ioctl(attr,IOCTL_VERTEX_SET)");
&space;   ret = ioctl(hinvFD,IOCTL_VERTEX_SET,&amp;v_targ);
&space;   if (ret) FAIL("ioctl(hinv,IOCTL_VERTEX_SET)");
&space;   return 0;
}
int dump3()
{ /* read all data from all 3 device FD's and display */
&space;   int ret;
&space;   int len;
&space;   inventory_t *i;
&space;   char buf[BIG];
&space;   /* Read &amp; display canonical path of current vertex */
&space;   ret = ioctl(edgeFD,IOCTL_PATH_READ);
&space;   if (ret) FAIL("ioctl(edge,IOCTL_PATH_READ)");
&space;   puts("\nPath read:");
&space;   len = read(edgeFD,buf,BIG);
&space;   if (-1 == len) FAIL("read edge path");
&space;   puts(buf);
&space;   puts("\nEdges:");
&space;   do { /* display all edges from current vertex */
&space;       len = read(edgeFD,buf,BIG);
&space;       if (-1 == len) FAIL("read edge");
&space;       if (len) puts(buf);
&space;   } while (len);
&space;   puts("\nAttrs:");
&space;   do { /* display all labelled attributes at this vertex */
&space;       len = read(attrFD,buf,BIG);
&space;       if (-1 == len) FAIL("read attr");
&space;       if (len) puts(buf);
&space;   } while (len);
&space;   puts("\nHinv:");
&space;   do { /* dump all inventory records at this vertex */
&space;       len = read(hinvFD,buf,BIG);
&space;       if (-1 == len) FAIL("read hinv");
&space;       if (len)
&space;       {
&space;           i = (inventory_t *)&amp;buf[0];
&space;           printf("class:%d type%d controller:%d unit:%d state:%d\n",
&space;       i->inv_class,i->inv_type,i->inv_controller,i->inv_unit,i->inv_state);
&space;       }
&space;   } while(len);
&space;   return 0;
}
int main(int argc, char *argv[])
{
&space;   int ret = 0;
&space;   char ans[256];
&space;   ret = open3((argc>1)?argv[1]:SNOOPATH);  
&space;   while (0==ret)
&space;   {
&space;       printf("enter path: ");
&space;       gets(ans);
&space;       if (0==strlen(ans)) break;  
&space;       ret = point3(ans);
&space;       if (!ret) ret = dump3();
&space;   }
&space;   return ret;
}
</CODE>
</SECTION2>
</SECTION1>
</CHAPTER>
