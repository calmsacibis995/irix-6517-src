<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="7"><TITLE><XREFTARGET ID="19192">Structure of a Kernel-Level Driver</TITLE><PARAGRAPH>A kernel-level device driver consists of a module of subroutines that supply services to the kernel. The subroutines are public entry points in the driver. When an event occurs, the kernel calls one of these entry points. The driver takes action and returns a result code. <INDEXTARGET ID="08-drvrstruct1"><!-- POSTPROCESSDATA: 08-drvrstruct1|kernel-level driver --></PARAGRAPH>
<PARAGRAPH>This chapter discusses when the driver entry points are called, what parameters they receive, and what actions they are expected to take. For a conceptual overview of the kernel and drivers, see <XREF IDREF="87778" TYPE="TITLE">&ldquo;Kernel-Level Device Control&rdquo;</XREF>. For details on how a driver is compiled, linked, and added to IRIX, see <XREF IDREF="82892" TYPE="TITLE">Chapter&nbsp;9, &ldquo;Building and Installing a Driver.&rdquo;</XREF></PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>This chapter concentrates on device drivers. Entry points unique to STREAMS drivers are covered in <XREF IDREF="94967" TYPE="TITLE">Chapter&nbsp;22, &ldquo;STREAMS Drivers.&rdquo;</XREF></NOTE>
<PARAGRAPH>The primary topics covered in this chapter are:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="90745" TYPE="TITLE">&ldquo;Summary of Driver Structure&rdquo;</XREF> summarizes the entry points and how they are made known to the kernel.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="67704" TYPE="TITLE">&ldquo;Driver Flag Constant&rdquo;</XREF> describes the public constant that documents the driver type for <COMMAND>lboot</COMMAND> and <COMMAND>mload</COMMAND>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="60095" TYPE="TITLE">&ldquo;Initialization Entry Points&rdquo;</XREF> discusses the entry points at which a driver initializes its own data and its devices.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="85243" TYPE="TITLE">&ldquo;Attach and Detach Entry Points&rdquo;</XREF> discusses the entry points that handle dynamic attachment of PCI devices.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="83352" TYPE="TITLE">&ldquo;Open and Close Entry Points&rdquo;</XREF> discusses the entry points called by the <FUNCTION>open()</FUNCTION> and <FUNCTION>close()</FUNCTION> kernel functions.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="17370" TYPE="TITLE">&ldquo;Control Entry Point&rdquo;</XREF> documents the entry point called by the <FUNCTION>ioctl()</FUNCTION> kernel function.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="67201" TYPE="TITLE">&ldquo;Data Transfer Entry Points&rdquo;</XREF> documents the entry points called by the <FUNCTION>read()</FUNCTION> and <FUNCTION>write()</FUNCTION> kernel functions.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="93582" TYPE="TITLE">&ldquo;Poll Entry Point&rdquo;</XREF> documents the entry point called by the <FUNCTION>poll()</FUNCTION> kernel function.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="87164" TYPE="TITLE">&ldquo;Memory Map Entry Points&rdquo;</XREF> tells how a driver supports memory mapping of devices and buffers.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="41192" TYPE="TITLE">&ldquo;Interrupt Entry Point and Handler&rdquo;</XREF> discusses the design and operation of interrupt handlers.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="62463" TYPE="TITLE">&ldquo;Support Entry Points&rdquo;</XREF> describes several entry points that support kernel operations.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="87735" TYPE="TITLE">&ldquo;Handling 32-Bit and 64-Bit Execution Models&rdquo;</XREF> covers the techniques of supporting user processes that have different execution models.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="32791" TYPE="TITLE">&ldquo;Designing for Multiprocessor Use&rdquo;</XREF> covers the techniques of making a driver work in a multiprocessor, multithreading environment.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="90745">Summary of Driver Structure</TITLE><PARAGRAPH>A driver consists of a binary object module in ELF format stored in the <FILENAME>/var/sysgen/boot</FILENAME> directory. As a program, the driver consists of a set of functional entry points that supply services to the IRIX kernel. There is a large set of entry points to cover different situations. Some entry points are historical relics, while others were first defined in IRIX       6.4. No single driver supports all possible entry points.&space;&space;<INDEXTARGET ID="08-drvrstruct2"><!-- POSTPROCESSDATA: 08-drvrstruct2|kernel-level driver:structure of --><INDEXTARGET ID="08-drvrstruct3"><!-- POSTPROCESSDATA: 08-drvrstruct3|structure of driver --></PARAGRAPH>
<PARAGRAPH>The entry points that a driver supports must be named according to a specified convention. The <COMMAND>lboot</COMMAND> command uses entry point names to build tables used by the kernel.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Entry Point Naming and lboot</TITLE><PARAGRAPH>The device driver makes known which entry points it supports by giving them public names in its object module. The <COMMAND>lboot</COMMAND> command links together the object modules of drivers and other kernel modules to make a bootable kernel. <COMMAND>lboot</COMMAND> recognizes the entry points by the form of their names. (See the <REFPAGE>lboot(1M)</REFPAGE> and <REFPAGE>autoconfig(1M)</REFPAGE> reference pages.)&space;<INDEXTARGET ID="08-drvrstruct4"><!-- POSTPROCESSDATA: 08-drvrstruct4|IRIX commands:<COMMAND>lboot</COMMAND>:driver prefix with --></PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="72688">Driver Name Prefix</TITLE><PARAGRAPH>A device driver must be described by a file in the <FILENAME>/var/sysgen/master.d</FILENAME> directory (see <XREF IDREF="91260" TYPE="TITLE">&ldquo;Master Configuration Database&rdquo;</XREF>). In that configuration file you specify the driver <GLOSSARYITEM>prefix</GLOSSARYITEM>, a string of 1 to 14 characters that is unique to that driver. For example, the prefix of the SCSI driver is <VARIABLE>scsi_</VARIABLE>.&space;<INDEXTARGET ID="08-drvrstruct5"><!-- POSTPROCESSDATA: 08-drvrstruct5|driver:prefixprefix --></PARAGRAPH>
<PARAGRAPH>The prefix string is defined in the <FILENAME>/var/sysgen/master.d</FILENAME> file only. The string does not have to appear as a constant in the driver, and the name of the driver object file does not have to correspond to the prefix (although the object module typically has a related name).</PARAGRAPH>
<PARAGRAPH>The <COMMAND>lboot</COMMAND> command recognizes driver entry points by searching the driver object module for public names that begin with the prefix string. For example, the entry point for the <FUNCTION>open()</FUNCTION> operation must have a name that consists of the prefix string followed by the letters &ldquo;open.&rdquo;</PARAGRAPH>
<PARAGRAPH>In this book, entry point names are written as follows: <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION>, where <VARIABLE>pfx</VARIABLE> stands for the driver's prefix string.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="56544">Driver Name Prefix as a Compiler Constant</TITLE><PARAGRAPH>The driver prefix string appears as part of the name of each public entry point. In addition, you sometimes need the driver prefix string as a character string literal, for example in a PCI driver as an argument to <FUNCTION>pciio_driver_register()</FUNCTION>. You would like to define the prefix string in one place and then generate it automatically where needed in the code. The C macro code in <XREF IDREF="88664" TYPE="TEXT">Example&nbsp;7-1</XREF> accomplishes this goal.</PARAGRAPH>
<CODE><CAPTION LBL="7-1"><PREFIX>Example 7-1 </PREFIX><XREFTARGET ID="88664">Compiling Driver Prefix as a Macro</CAPTION>#define PREFIX_NAME(name) sample_ ## name
/* -----  driver prefix:  ^^^^^^^ defined there only */
#define PREFIX_ONLY PREFIX_NAME( )
#define STRINGIZER(x) # x
#define PREFIX_STRING STRINGIZER(PREFIX_ONLY)
</CODE>
<PARAGRAPH>A macro call to PREFIX_STRING generates a character literal (&ldquo;sample_&rdquo; in this case). You can use this macro wherever a character literal is allowed, for example, as a function argument. The &ldquo;##&rdquo; operator is ANSI C syntax for string concatenation.</PARAGRAPH>
<PARAGRAPH>Further down, in the STRINGIZER macro, the &ldquo;#&rdquo; operator is ANSI C syntax for string (double quoted) substitution.</PARAGRAPH>
<PARAGRAPH>A call to PREFIX_NAME(<VARIABLE>name</VARIABLE>) generates an identifier composed of the prefix concatenated to <VARIABLE>name</VARIABLE>. You can define the <VARIABLE>init</VARIABLE> entry point as follows:</PARAGRAPH>
<CODE>
PREFIX_NAME(init)()
{ ... }
</CODE>
<PARAGRAPH>However, this can be confusing to read. You can also define one macro for each entry point, as shown in <XREF IDREF="75811" TYPE="TEXT">Example&nbsp;7-2</XREF>.</PARAGRAPH>
<CODE><CAPTION LBL="7-2"><PREFIX>Example 7-2 </PREFIX><XREFTARGET ID="75811">Entry Point Name Macros</CAPTION>#define PFX_INIT      PREFIX_NAME(init)
#define PFX_START     PREFIX_NAME(start)
</CODE>
<PARAGRAPH>Using macros such as these you can define an entry point as follows:</PARAGRAPH>
<CODE>
PFX_INIT()
{ ... }
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="35727">Kernel Switch Tables</TITLE><PARAGRAPH>The IRIX kernel maintains tables that allow it to dispatch calls to device drivers quickly. These tables are built by <INDEXTARGET ID="08-drvrstruct6"><!-- POSTPROCESSDATA: 08-drvrstruct6|<VARIABLE>vfssw</VARIABLE> table --><INDEXTARGET ID="08-drvrstruct7"><!-- POSTPROCESSDATA: 08-drvrstruct7|<VARIABLE>fmodsw</VARIABLE> table --><INDEXTARGET ID="08-drvrstruct8"><!-- POSTPROCESSDATA: 08-drvrstruct8|<VARIABLE>cdevsw</VARIABLE> table --><INDEXTARGET ID="08-drvrstruct9"><!-- POSTPROCESSDATA: 08-drvrstruct9|<VARIABLE>bdevsw</VARIABLE>table --><INDEXTARGET ID="08-drvrstruct10"><!-- POSTPROCESSDATA: 08-drvrstruct10|IRIX commands:<COMMAND>lboot</COMMAND>:builds switch tables --><INDEXTARGET ID="08-drvrstruct11"><!-- POSTPROCESSDATA: 08-drvrstruct11|switch tablekernel switch tables --><COMMAND>lboot</COMMAND> based on the names of the driver entry points. The tables are named as follows:</PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>bdevsw</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Table of block device drivers</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>cdevsw</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Table of character device drivers</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>fmodsw</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Table of STREAMS drivers</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>vfssw</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Table of filesystem modules (not related to device drivers)</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Conceptually, the tables for block and character drivers have one row for each driver, and one column for each possible driver entry point. (Historically, the major device number was the driver's row number in the switch table. This simple data structure is no longer used.)</PARAGRAPH>
<PARAGRAPH>As <COMMAND>lboot</COMMAND> loads a driver, it fills in that driver's row of a switch table with the addresses of the driver's entry points. Where an entry point is not defined in the driver object file, <COMMAND>lboot</COMMAND> leaves the address of a null routine that returns the ENODEV error code. Thus no driver needs to define all entry points&mdash;only the ones it can support in a useful way.</PARAGRAPH>
<PARAGRAPH>The sizes of the switch tables are fixed at boot time in order to minimize kernel data space. The table sizes are tunable parameters that can be set with <COMMAND>systune</COMMAND> (see the <REFPAGE>systune(1)</REFPAGE> reference page).&space;<INDEXTARGET ID="08-drvrstruct12"><!-- POSTPROCESSDATA: 08-drvrstruct12|IRIX commands:<COMMAND>systune</COMMAND>:switch table size --></PARAGRAPH>
<PARAGRAPH>When a driver is loaded dynamically (see <INDEXTARGET ID="08-drvrstruct13"><!-- POSTPROCESSDATA: 08-drvrstruct13|loadable driver:and switch table --><XREF IDREF="54976" TYPE="TITLE">&ldquo;Configuring a Loadable Driver&rdquo;</XREF>), the associated row of the switch table is not filled at link time but rather is filled when the driver is loaded. When you add new, loadable drivers, you might need to specify a larger switch table. The book <DOCTITLE>IRIX Admin: System Configuration and Operation</DOCTITLE> documents these tunable parameters.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="69038">Entry Point Summary</TITLE><PARAGRAPH>The names of all possible driver entry points and their purposes are summarized in <INDEXTARGET ID="08-drvrstruct14"><!-- POSTPROCESSDATA: 08-drvrstruct14|entry points:summary tableentry points:AAA --><XREF IDREF="74255" TYPE="TABLE">Table&nbsp;7-1</XREF>. The entry point names are in alphabetic order, not logical order. Device driver entry points are discussed in this chapter. Entry points to STREAMS drivers are discussed in <XREF IDREF="94967" TYPE="TITLE">Chapter&nbsp;22, &ldquo;STREAMS Drivers.&rdquo;</XREF></PARAGRAPH>
<PARAGRAPH>&space;To open the reference page, click on the reference page name. To jump to the discussion of an entry point, click on the &ldquo;Discussion&rdquo; cross-reference.</PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="7-1"><PREFIX>Table 7-1 </PREFIX><XREFTARGET ID="74255">Entry Points in Alphabetic Order</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="62"><PARAGRAPH>Entry Point</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH>Discussion</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH>Reference Page</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>attach</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Attach </PARAGRAPH>
a new device to the system. <PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="54429" TYPE="TEXT">page&nbsp;153</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>close</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Note the device is not in use.</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="14026" TYPE="TEXT">page&nbsp;160</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH><REFPAGE>close(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>devflag</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Constant flag bits for driver features.</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="67704" TYPE="TEXT">page&nbsp;148</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH><REFPAGE>devflag(D1)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>detach</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Detach a device from the system.</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="83670" TYPE="TEXT">page&nbsp;156</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>edtinit</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Initialize EISA or VME driver from VECTOR 
statement.</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="14072" TYPE="TEXT">page&nbsp;151</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH><REFPAGE>edtinit(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>halt</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Prepare for system shutdown.</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="96840" TYPE="TEXT">page&nbsp;180</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH><REFPAGE>halt(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>init</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Initialize driver globals at load or boot time.</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="25548" TYPE="TEXT">page&nbsp;150</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH><REFPAGE>init(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>intr</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Handle device interrupt (not used).</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="41192" TYPE="TEXT">page&nbsp;174</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH><REFPAGE>intr(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>ioctl</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Implement control operations.</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="17370" TYPE="TEXT">page&nbsp;161</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH><REFPAGE>ioctl(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>map</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Implement memory-mapping (IRIX).</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="20168" TYPE="TEXT">page&nbsp;170</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH><REFPAGE>map(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>mmap</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Implement memory-mapping (SVR4).</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="11008" TYPE="TEXT">page&nbsp;172</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH><REFPAGE>mmap(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>open</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Connect a process to a device.</PARAGRAPH>
<PARAGRAPH>Connect a stream module.</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="86115" TYPE="TEXT">page&nbsp;157</XREF></PARAGRAPH>
<PARAGRAPH><XREF IDREF="71515" TYPE="TEXT">page&nbsp;751</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH><REFPAGE>open(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>poll</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Implement device event test.</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="19826" TYPE="TEXT">page&nbsp;167</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH><REFPAGE>poll(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>print</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Display diagnostic about block device.</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="94783" TYPE="TEXT">page&nbsp;181</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH><REFPAGE>print(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>read</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Character-mode input.</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="66358" TYPE="TEXT">page&nbsp;162</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH><REFPAGE>read(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>reg</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Register a driver at load or boot time.</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="36838" TYPE="TEXT">page&nbsp;152</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>rput</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>STREAMS message on read queue.</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="22527" TYPE="TEXT">page&nbsp;752</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH><REFPAGE>put(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>size</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Return logical size of block device.</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="63295" TYPE="TEXT">page&nbsp;181</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH><REFPAGE>size(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>srv</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>STREAMS service queued messages.</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="85058" TYPE="TEXT">page&nbsp;753</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH><REFPAGE>srv(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>start</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Initialize driver at load or boot time.</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="97690" TYPE="TEXT">page&nbsp;152</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH><REFPAGE>start(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>strategy</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Block-mode input and output.</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="66319" TYPE="TEXT">page&nbsp;164</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH><REFPAGE>strategy(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>unload</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Prepare loadable module for unloading.</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="57773" TYPE="TEXT">page&nbsp;179</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH><REFPAGE>unload(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>unmap</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Note the end of a memory mapping.</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="61378" TYPE="TEXT">page&nbsp;173</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH><REFPAGE>unmap(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>unreg</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Undo driver registration prior to unloading.</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="39118" TYPE="TEXT">page&nbsp;179</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>wput</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>STREAMS message on write queue.</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="22527" TYPE="TEXT">page&nbsp;752</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH><REFPAGE>put(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="62"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>write</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="185"><PARAGRAPH>Character-mode output.</PARAGRAPH>
</CELL>
<CELL LEFT="260" WIDTH="57"><PARAGRAPH><XREF IDREF="66358" TYPE="TEXT">page&nbsp;162</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="81"><PARAGRAPH><REFPAGE>write(D2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<SECTION3 LBL="" HELPID = ""><TITLE>Entry Point Usage</TITLE><PARAGRAPH>No driver supports all entry points. Typical entry point usage is as follows:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>A minimal driver for a character device supports <VARIABLE>pfx</VARIABLE><FUNCTION>init()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>read()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>write()</FUNCTION>, and <VARIABLE>pfx</VARIABLE><FUNCTION>close()</FUNCTION>. The <VARIABLE>pfx</VARIABLE><FUNCTION>ioctl()</FUNCTION> and <VARIABLE>pfx</VARIABLE><FUNCTION>poll()</FUNCTION> entry points are optional.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A minimal block device driver supports <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>size()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION>, and <VARIABLE>pfx</VARIABLE><FUNCTION>close()</FUNCTION>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A minimal pseudo-device driver supports <VARIABLE>pfx</VARIABLE><FUNCTION>start()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>map()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>unmap()</FUNCTION>, and <VARIABLE>pfx</VARIABLE><FUNCTION>close()</FUNCTION> (the latter two possibly as mere stubs).</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>In addition:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>All drivers need a <VARIABLE>pfx</VARIABLE><FUNCTION>devflag</FUNCTION> constant.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Loadable drivers may support <VARIABLE>pfx</VARIABLE><FUNCTION>unreg()</FUNCTION> and <VARIABLE>pfx</VARIABLE><FUNCTION>unload()</FUNCTION>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A block or character driver for a PCI device should support <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>detach()</FUNCTION>, and <VARIABLE>pfx</VARIABLE><FUNCTION>reg()</FUNCTION>. The <VARIABLE>pfx</VARIABLE><FUNCTION>enable()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>disable()</FUNCTION>, and <VARIABLE>pfx</VARIABLE><FUNCTION>error()</FUNCTION> entry points are optional.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A block or character driver for aVME, EISA or GIO device should support <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION>.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Entry Point Calling Sequence</TITLE><PARAGRAPH>Entry points of a nonloadable driver are called as follows.<INDEXTARGET ID="08-drvrstruct15"><!-- POSTPROCESSDATA: 08-drvrstruct15|entry points:when called --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The first call is to <VARIABLE>pfx</VARIABLE><FUNCTION>init()</FUNCTION> if it exists.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A driver for a VME, EISA, or GIO bus device is then called at its <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> entry points once for each VECTOR line that specifies that driver.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>start()</FUNCTION> entry point is called, if it exists.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>reg()</FUNCTION> entry point is called, if it exists.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A driver for a PCI device is called at its <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> entry point once for each device that it supports, as the kernel discovers the devices.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> entry point is called whenever any process opens a device controlled by this driver.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>read()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>write()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>map()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>poll()</FUNCTION> and <VARIABLE>pfx</VARIABLE><FUNCTION>ioctl()</FUNCTION> calls are exercised as long as any device is open.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>unmap()</FUNCTION> entry point is called when all processes have unmapped a given segment of memory.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>close()</FUNCTION> entry point is called when the last process closes a device, so the device is known to be no longer in use.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>detach()</FUNCTION> entry point can be called only when a device has been closed.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The sequence of entry points called for a loadable driver is similar, with additional calls that are discussed under <XREF IDREF="39118" TYPE="TITLE">&ldquo;Entry Point unreg()&rdquo;</XREF> and <XREF IDREF="57773" TYPE="TITLE">&ldquo;Entry Point unload()&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="67704">Driver Flag Constant</TITLE><PARAGRAPH>Any device driver or STREAMS module must define a public name <INDEXTARGET ID="08-drvrstruct16"><!-- POSTPROCESSDATA: 08-drvrstruct16|driver:flag constant --><INDEXTARGET ID="08-drvrstruct17"><!-- POSTPROCESSDATA: 08-drvrstruct17|entry points:devflag --><VARIABLE>pfx</VARIABLE><FUNCTION>devflag</FUNCTION> as a static integer. This integer contains a bitmask with one or more of the following flags, which are declared in <FILENAME>sys/conf.h</FILENAME>:</PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>D_MP </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="297"><PARAGRAPH>The driver is prepared for multiprocessor systems. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>D_MT </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="297"><PARAGRAPH>The driver is prepared for a multithreaded kernel. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>D_WBACK </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="297"><PARAGRAPH>The driver handles its own cache-writeback operations. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>A typical definition would resemble the following:</PARAGRAPH>
<EXAMPLE>
int testdrive_devflag = D_MP+D_MT;
</EXAMPLE>
<PARAGRAPH>A STREAMS module should also provide this flag, but the only relevant bit value for a STREAMS driver is D_MP (see <XREF IDREF="22560" TYPE="TITLE">&ldquo;Driver Flag Constant&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>The flag value is saved in the kernel switch table with the driver's entry points (see <XREF IDREF="35727" TYPE="TITLE">&ldquo;Kernel Switch Tables&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>When a driver (or STREAMS module) does not define a <VARIABLE>pfx</VARIABLE><FUNCTION>devflag</FUNCTION>, or defines one containing 0, <COMMAND>lboot</COMMAND> refuses to load it as part of the kernel.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="56945">Flag D_MP</TITLE><PARAGRAPH>You specify D_MP in <INDEXTARGET ID="08-drvrstruct18"><!-- POSTPROCESSDATA: 08-drvrstruct18|multiprocessor:driver flag D_MP --><INDEXTARGET ID="08-drvrstruct19"><!-- POSTPROCESSDATA: 08-drvrstruct19|D_MP flag --><VARIABLE>pfx</VARIABLE><FUNCTION>devflag</FUNCTION> to tell <COMMAND>lboot</COMMAND> that your driver is designed to operate in a multiprocessor system. The top half of the driver is designed to cope with multiple concurrent entries in multiple CPUs. The top and bottom halves synchronize through the use of semaphores or locks and do not rely on interrupt masking for critical sections. These issues are discussed further under <XREF IDREF="32791" TYPE="TITLE">&ldquo;Designing for Multiprocessor Use&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>All drivers must be designed in this fashion and confirm it with D_MP, even drivers written for uniprocessor workstations.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Flag D_MT</TITLE><PARAGRAPH>Driver interrupt routines execute as independent, preemptable threads of control within the kernel address space (see <INDEXTARGET ID="08-drvrstruct20"><!-- POSTPROCESSDATA: 08-drvrstruct20|D_MT flag --><XREF IDREF="26467" TYPE="TITLE">&ldquo;Interrupts as Threads&rdquo;</XREF>). D_MT indicates that this driver understands that it can be run as one or more cooperating threads, and uses kernel synchronization primitives to serialize access to driver common data structures.</PARAGRAPH>
<PARAGRAPH>In IRIX 6.4, D_MT does not commit a driver to anything beyond the meaning of D_MP.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Flag D_WBACK</TITLE><PARAGRAPH>You specify D_WBACK in <INDEXTARGET ID="08-drvrstruct21"><!-- POSTPROCESSDATA: 08-drvrstruct21|D_WBACK flag --><VARIABLE>pfx</VARIABLE><FUNCTION>devflag</FUNCTION> to tell <COMMAND>lboot</COMMAND> that a block driver performs any necessary cache write-back operations through explicit calls to <FUNCTION>dki_dcache_wb()</FUNCTION> and related functions (see the <REFPAGE>dki_dcache_wb(D3)</REFPAGE> reference page).</PARAGRAPH>
<PARAGRAPH>When D_WBACK is not present in <VARIABLE>pfx</VARIABLE><FUNCTION>devflag</FUNCTION>, the <FUNCTION>physiock()</FUNCTION> function ensures that all cached data related to <VARIABLE>buf_t</VARIABLE> structures is written back to main memory before it enters the driver's strategy routine. (See the physiock(D3) reference page and <XREF IDREF="66319" TYPE="TITLE">&ldquo;Entry Point strategy()&rdquo;</XREF>.)<INDEXTARGET ID="08-drvrstruct22"><!-- POSTPROCESSDATA: 08-drvrstruct22|kernel functions:<FUNCTION>physiock()</FUNCTION> --></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="49069">Flag D_OLD Not Supported</TITLE><PARAGRAPH>In versions prior to IRIX       6.4, a driver was allowed to have no <INDEXTARGET ID="08-drvrstruct23"><!-- POSTPROCESSDATA: 08-drvrstruct23|D_OLD flag --><VARIABLE>pfx</VARIABLE><FUNCTION>devflag</FUNCTION>, or to have one containing only a flag named D_OLD. This flag, or the absence of a flag, requested compatibility handling for an obsolete driver interface. Support for this interface has been withdrawn effective with IRIX       6.4. </PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="60095">Initialization Entry Points</TITLE><PARAGRAPH>The kernel calls a driver to initialize itself at four different entry points, as follows:<INDEXTARGET ID="08-drvrstruct24"><!-- POSTPROCESSDATA: 08-drvrstruct24|initialization --><INDEXTARGET ID="08-drvrstruct25"><!-- POSTPROCESSDATA: 08-drvrstruct25|driver:initialization --></PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>init</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Initialize self-defining hardware or a pseudo-device. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>edtinit</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Initialize a hardware device based on VECTOR data. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>start</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>General initialization. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>reg</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>For a driver that supports the <VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>attach()</FUNCTION> entry point, register the 
driver as ready to attach devices. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Historically, these calls were made at different times in the boot process and the driver had different abilities at each time. Now they are all called at nearly the same time. A driver may define any combination of these entry points. Typically a PCI driver will define <VARIABLE>pfx</VARIABLE><FUNCTION>init()</FUNCTION> and <VARIABLE>pfx</VARIABLE><FUNCTION>reg()</FUNCTION>, while a VME or EISA device will define <VARIABLE>pfx</VARIABLE><FUNCTION>init()</FUNCTION> and <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION>.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="92032">When Initialization Is Performed</TITLE><PARAGRAPH>The initialization entry points of ordinary (nonloadable) drivers are called during system startup, after interrupts have been enabled and before the message &ldquo;The system is coming up&rdquo; is displayed on the console. In all cases, interrupts are enabled and basic kernel services are available at this time. However, other loadable or optional kernel modules might not have been initialized, depending on the sequence of statements in the files in <INDEXTARGET ID="08-drvrstruct26"><!-- POSTPROCESSDATA: 08-drvrstruct26|interrupt:enabled during initialization --><FILENAME>/var/sysgen/system</FILENAME>.</PARAGRAPH>
<PARAGRAPH>Whenever a driver is initialized, the entry points are called in the following sequence:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH><VARIABLE>pfx</VARIABLE><FUNCTION>init()</FUNCTION> is called. </PARAGRAPH>
</LIST>
<LIST><PARAGRAPH><VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> is called once for each VECTOR statement in reverse order of the VECTOR statements found in <FILENAME>/var/sysgen/system</FILENAME> files.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH><VARIABLE>pfx</VARIABLE><FUNCTION>start()</FUNCTION> is called.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH><VARIABLE>pfx</VARIABLE><FUNCTION>reg()</FUNCTION> is called.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<SECTION3 LBL="" HELPID = ""><TITLE>Initialization of Loadable Drivers</TITLE><PARAGRAPH>A loadable driver (see <INDEXTARGET ID="08-drvrstruct27"><!-- POSTPROCESSDATA: 08-drvrstruct27|loadable driver:autoregister --><INDEXTARGET ID="08-drvrstruct28"><!-- POSTPROCESSDATA: 08-drvrstruct28|loadable driver:initialization --><XREF IDREF="27851" TYPE="TITLE">&ldquo;Loadable Drivers&rdquo;</XREF>) is initialized any time it is loaded. This can occur more than once, if the driver is loaded, unloaded, and reloaded. When a loadable driver is configured for autoregister, it is loaded with other drivers during system startup. (For more information on autoregister, see <XREF IDREF="54976" TYPE="TITLE">&ldquo;Configuring a Loadable Driver&rdquo;</XREF>.) Such a driver is initialized at system startup time along with the nonloadable drivers.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="25548">Entry Point init()</TITLE><PARAGRAPH>The <INDEXTARGET ID="08-drvrstruct29"><!-- POSTPROCESSDATA: 08-drvrstruct29|entry points:init --><VARIABLE>pfx</VARIABLE><FUNCTION>init()</FUNCTION> entry point is called once during system startup or when a loadable driver is loaded. It receives no input arguments; its prototype is simply:</PARAGRAPH>
<EXAMPLE>
void <VARIABLE>pfx</VARIABLE>init(void);
</EXAMPLE>
<PARAGRAPH>You can use this entry point for any of the following purposes:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>To initialize global data used by more than one entry point or with more than one device.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>To initialize a hardware device that is self-defining; that is, all the information the driver needs is either coded into the driver, or can be gotten by probing the device itself.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>To initialize a pseudo-device driver; that is, a driver that does not have real hardware attached.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>A driver that is brought into the system by a USE or INCLUDE line in a system configuration file (see <XREF IDREF="98580" TYPE="TITLE">&ldquo;Configuring a Kernel&rdquo;</XREF>) typically initializes in the <VARIABLE>pfx</VARIABLE><FUNCTION>init()</FUNCTION> entry point.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="14072">Entry Point edtinit()<INDEXTARGET ID="08-drvrstruct30"><!-- POSTPROCESSDATA: 08-drvrstruct30|USE statement --><INDEXTARGET ID="08-drvrstruct31"><!-- POSTPROCESSDATA: 08-drvrstruct31|INCLUDE statement --></TITLE><PARAGRAPH>The <INDEXTARGET ID="08-drvrstruct32"><!-- POSTPROCESSDATA: 08-drvrstruct32|VECTOR statement:edtinit entry point --><INDEXTARGET ID="08-drvrstruct33"><!-- POSTPROCESSDATA: 08-drvrstruct33|entry points:edtinit --><VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> entry is designed to initialize devices that are configured using the VECTOR statement in the system configuration file (see <XREF IDREF="28517" TYPE="TITLE">&ldquo;Kernel Configuration Files&rdquo;</XREF>). This includes GIO, EISA, and VME devices. The entry point name is a contraction of &ldquo;<ITALICS>e</ITALICS>arly <ITALICS>d</ITALICS>evice <ITALICS>t</ITALICS>able <ITALICS>init</ITALICS>ialization.&rdquo;</PARAGRAPH>
<PARAGRAPH>The VECTOR statement specifies hardware details about a device on the VME, GIO, or EISA bus, including such items as iospace addresses, interrupt level, bus number, and a driver-defined integer value referred to as the controller number. The VECTOR statement also specifies the driver that is to manage the device; and it can specify probe operations that let the kernel test for the existence of the device.</PARAGRAPH>
<PARAGRAPH>When the kernel processes a VECTOR statement during bootstrap, it executes the probe, if one is specified. When the probe is successful (or no probe is given), the kernel makes sure that the specified driver is loaded. Then it stores the hardware parameters from the VECTOR statement in a structure of type <VARIABLE>edt_t</VARIABLE>. (This structure is declared in <FILENAME>sys/edt.h</FILENAME>.)</PARAGRAPH>
<PARAGRAPH>The kernel calls the specified driver's <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> entry one time for each VECTOR statement that named that driver and had a successful probe (or had no probe). VECTOR statements are processed in reverse sequence to the order in which they are coded in <FILENAME>/var/sysgen/system</FILENAME> files.</PARAGRAPH>
<PARAGRAPH>The prototype of the <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> entry is</PARAGRAPH>
<EXAMPLE>
void <VARIABLE>pfx</VARIABLE>edtinit(edt_t *<VARIABLE>e</VARIABLE>);
</EXAMPLE>
<PARAGRAPH>The <INDEXTARGET ID="08-drvrstruct34"><!-- POSTPROCESSDATA: 08-drvrstruct34|data types:<VARIABLE>edt_t</VARIABLE> --><VARIABLE>edt_t</VARIABLE> contains at least the following fields (see the <REFPAGE>system(4)</REFPAGE> reference page for the corresponding VECTOR parameters): </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><VARIABLE>e_bus_type</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Integer specifying the bus type; constant values are declared in 
<FILENAME>sys/edt.h</FILENAME>, for example ADAP_VME, ADAP_GIO, or ADAP_EISA.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><VARIABLE>e_adap</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>For EISA or VME, an integer specifying the adapter (bus) number.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><VARIABLE>e_ctlr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Value from the VECTOR <COMMAND>ctlr=</COMMAND> parameter; typically a device number 
used to distinguish one device from another.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><VARIABLE>e_space</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Array of up to three I/O space structures of type <VARIABLE>iospace_t</VARIABLE>.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The VME form of the VECTOR statement for IRIX 6.4 is discussed at length under <XREF IDREF="89231" TYPE="TITLE">&ldquo;Defining VME Devices with the VECTOR Statement&rdquo;</XREF>. The operation of the <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> entry for VME is discussed under <XREF IDREF="20724" TYPE="TITLE">&ldquo;Initializing a VME Device&rdquo;</XREF>.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="97690">Entry Point start()</TITLE><PARAGRAPH>The <INDEXTARGET ID="08-drvrstruct35"><!-- POSTPROCESSDATA: 08-drvrstruct35|entry points:start --><VARIABLE>pfx</VARIABLE><FUNCTION>start()</FUNCTION> entry point is called at system startup, and whenever a loadable driver is loaded. It is called after <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION> and <VARIABLE>pfx</VARIABLE><FUNCTION>init()</FUNCTION>, but before any other entry point such as <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION>. The <VARIABLE>pfx</VARIABLE><FUNCTION>start()</FUNCTION> entry point receives no arguments; its prototype is simply</PARAGRAPH>
<EXAMPLE>
void <VARIABLE>pfx</VARIABLE>start(void);
</EXAMPLE>
<PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>start()</FUNCTION> entry point is a suitable place to allocate a poll-head structure using <FUNCTION>phalloc()</FUNCTION>, as discussed in <XREF IDREF="57221" TYPE="TITLE">&ldquo;Use and Operation of poll(2)&rdquo;</XREF>.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="36838">Entry Point reg()</TITLE><PARAGRAPH>The <INDEXTARGET ID="08-drvrstruct36"><!-- POSTPROCESSDATA: 08-drvrstruct36|register a driver:reg entry point --><INDEXTARGET ID="08-drvrstruct37"><!-- POSTPROCESSDATA: 08-drvrstruct37|entry points:reg --><VARIABLE>pfx</VARIABLE><FUNCTION>reg()</FUNCTION> entry point is specifically intended to allow a driver that supports the <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> entry point (see <XREF IDREF="54429" TYPE="TITLE">&ldquo;Entry Point attach()&rdquo;</XREF>) to register with the kernel. At present, the only buses that support device attachment and registration (accessible to OEMs) are the PCI and SCSI buses. The functions used to register as a PCI driver are discussed in <XREF IDREF="64517" TYPE="TITLE">&ldquo;Configuration Register Initialization&rdquo;</XREF>.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="85243">Attach and Detach Entry Points </TITLE><PARAGRAPH>First defined in IRIX&nbsp;6.3, the <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> entry point informs the driver that the kernel has found a device that matches the driver. This is the time at which the driver initializes data that is unique to one instance of a device. The <VARIABLE>pfx</VARIABLE><FUNCTION>detach()</FUNCTION> entry point informs the driver that the device has been removed from the system. The driver undoes whatever <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> did for that device instance.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="54429">Entry Point attach()</TITLE><PARAGRAPH>The <INDEXTARGET ID="08-drvrstruct38"><!-- POSTPROCESSDATA: 08-drvrstruct38|entry points:attach --><VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> entry point is called to notify the driver that the PCI bus adapter has located a device that has a vendor and device ID for which the driver has registered (see <XREF IDREF="36838" TYPE="TITLE">&ldquo;Entry Point reg()&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>This entry point is typically called during bootstrap, while the kernel is probing the PCI bus. However, it can occur at a later time, if the device is physically plugged in or activated after the system has initialized. In an Origin2000 system, the entry point is executed in the hardware node closest to the device being attached. (See <XREF IDREF="16279" TYPE="TITLE">&ldquo;Allocating Memory in Specific Nodes of a Origin2000 System&rdquo;</XREF>.)</PARAGRAPH>
<PARAGRAPH>The purpose of the entry point is to make the device usable, including making it visible in the <GLOSSARYITEM>hwgraph</GLOSSARYITEM> by creating vertexes and edges to represent it.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Matching A Device to A Driver</TITLE><PARAGRAPH>When the system boots up, the kernel probes the PCI bus configuration space and takes a census of active devices. For each device it notes</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Vendor and device ID numbers</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Requested size of memory space</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Requested size of I/O space</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The kernel assigns starting bus addresses for memory and I/O space and sets these addresses in the Base Address Registers (BARs) in the device. Then the kernel looks for a driver that has registered a matching set of vendor and device IDs using <FUNCTION>pciio_driver_register()</FUNCTION> (for discussion, see <XREF IDREF="64517" TYPE="TITLE">&ldquo;Configuration Register Initialization&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>If no matching driver has registered, the device remains inactive. For example, the driver might be a loadable driver that has not been loaded as yet. When the driver is loaded and registers, the kernel will match it to any unattached devices.</PARAGRAPH>
<PARAGRAPH>When the kernel matches a device to its registered driver, the kernel calls the driver's <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> entry point. It passes one argument, a handle to the <FILENAME>hwgraph</FILENAME> vertex representing the hardware connection point for the device. This handle is used to:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Request PIO and DMA maps on the device</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Register an interrupt handler for the device</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="20718">Completing the hwgraph</TITLE><PARAGRAPH>The handle passed to <INDEXTARGET ID="08-drvrstruct39"><!-- POSTPROCESSDATA: 08-drvrstruct39|hwgraph:and attach entry point --><VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> addresses the hwgraph vertex that represents a slot on a bus. This is not informative to users, because a card can be plugged into any slot. Nor is this a reliable target for a symbolic link from <FILENAME>/dev</FILENAME>. In any case, the driver cannot store information in this vertex. At attach time the driver needs to create at least one additional hwgraph vertex in order to:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Create a device vertex for use by user programs.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Provide a vertex to hold the device information.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Establish a well-known, convenient names high up in the <FILENAME>/hw</FILENAME> filesystem.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Provide extra device names that represent different aspects of the same device (for example, different partitions), or different access modes to the device (a character device and a block device), or different treatments of the device (for example, byte-swapped and nonswapped).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Establish predictable names that satisfy symbolic links that exist in <FILENAME>/dev</FILENAME>.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Each leaf vertex you create in the hwgraph is a device special file the user can open. You create a leaf vertex by calling <FUNCTION>hwgraph_block_device_add()</FUNCTION> or <FUNCTION>hwgraph_char_device_add()</FUNCTION>. You can make each leaf vertex distinct by attaching distinct information to it using <FUNCTION>device_info_set()</FUNCTION>. </PARAGRAPH>
<PARAGRAPH>You create additional vertexes and edges using the functions discussed under <XREF IDREF="50960" TYPE="TITLE">&ldquo;Hardware Graph Management&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="61268">Allocating Storage for Device Information</TITLE><PARAGRAPH>A driver needs to save information about each device, usually in a structure. Fields in a typical structure might include:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Locks or semaphores used for mutual exclusion among upper-half entry points and between them and the interrupt handler.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Addresses of allocated PIO and DMA maps for this device (see <XREF IDREF="23749" TYPE="TITLE">&ldquo;PIO Address Mapping&rdquo;</XREF> and <XREF IDREF="69807" TYPE="TITLE">&ldquo;DMA Address Mapping&rdquo;</XREF>).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Address of an interrupt connection object for the device (see <XREF IDREF="70224" TYPE="TITLE">&ldquo;Interrupt Signal Distribution&rdquo;</XREF>).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>In a block driver, anchors for a queue of <VARIABLE>buf_t</VARIABLE> objects being filled or emptied.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Device status flags.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>A problem is that at initialization time a driver does not know how many devices it will be asked to manage. In the past this problem has been handled by allocating an array of a fixed number of information structures, indexed by the device minor number.</PARAGRAPH>
<PARAGRAPH>In a PCI driver, you dynamically allocate memory for an information structure to hold information about the one device being attached. (See <XREF IDREF="68494" TYPE="TITLE">&ldquo;General-Purpose Allocation&rdquo;</XREF>.) You save the address of the structure in the leaf vertex you create, using the <FUNCTION>device_info_set()</FUNCTION> function, which associates an arbitrary pointer with a <VARIABLE>vertex_hdl_t</VARIABLE> (see <REFPAGE>hwgraph(d3x)</REFPAGE> and <XREF IDREF="65256" TYPE="TITLE">&ldquo;Extending the hwgraph&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>The information structure can easily be recovered in any top-half routine; see <XREF IDREF="70160" TYPE="TITLE">&ldquo;Interrogating the hwgraph&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Inserting Hardware Inventory Data</TITLE><PARAGRAPH>You attach the hardware inventory data for the attached device to the hwgraph vertex passed to the <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> entry point&mdash;see <XREF IDREF="91306" TYPE="TITLE">&ldquo;Creating an Inventory Entry&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Return Value from Attach</TITLE><PARAGRAPH>The return code from <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> is tested by the kernel. The driver can reject an attachment. When your driver cannot allocate memory, or fails due to another problem, it should:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Use <FUNCTION>cmn_err()</FUNCTION> to document the problem (see <XREF IDREF="49566" TYPE="TITLE">&ldquo;Using cmn_err&rdquo;</XREF>)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Release any objects such as PIO and DMA maps that were created.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Release any space allocated to the device such as a device information structure.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Return an informative return code which might be meaningful in future releases.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>More than one driver can register to support the same vendor ID and device ID. When the first driver fails to complete the attachment, the kernel continues on to test the next, until all have refused or one accepts. The <VARIABLE>pfx</VARIABLE><FUNCTION>detach()</FUNCTION> entry point can only be called if the <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> entry point returns success (0).</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="83670">Entry Point detach()</TITLE><PARAGRAPH>The <INDEXTARGET ID="08-drvrstruct40"><!-- POSTPROCESSDATA: 08-drvrstruct40|entry points:detach --><VARIABLE>pfx</VARIABLE><FUNCTION>detach()</FUNCTION> entry point is called when the kernel decides to detach a device. As of IRIX       6.4 this is only done for PCI devices. The need to detach can be created by a hardware failure or by administrator action. If the entry point is not defined, the device cannot be detached.</PARAGRAPH>
<PARAGRAPH>In general, the detach entry point must undo as much as possible of the work done by the <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> entry point (see <XREF IDREF="54429" TYPE="TITLE">&ldquo;Entry Point attach()&rdquo;</XREF>). This includes such actions as:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Disconnect a registered interrupt handler.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>If any I/O operations are pending on the device, cancel them. If any top-half entry points are waiting on the completion of these operations, wake them up.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Release all software objects allocated, such as PIO maps, DMA maps, and interrupt objects.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Release any allocated kernel memory used for buffers or for a device information structure.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Detach and release any edges and vertexes in the hwgraph created at attach time.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The state of the device itself is not known. If the detach code attempts to reset the device or put it in a quiescent state, the code should be prepared for errors to occur.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="83352">Open and Close Entry Points</TITLE><PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> and <VARIABLE>pfx</VARIABLE><FUNCTION>close()</FUNCTION> entries for block and character devices are called when a device comes into use and when use of it is finished. For a conceptual overview of the <FUNCTION>open()</FUNCTION> process, see <XREF IDREF="42814" TYPE="TITLE">&ldquo;Overview of Device Open&rdquo;</XREF>.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="86115">Entry Point open()</TITLE><PARAGRAPH>The kernel calls a device driver's <INDEXTARGET ID="08-drvrstruct41"><!-- POSTPROCESSDATA: 08-drvrstruct41|IRIX functions:<FUNCTION>open()</FUNCTION> --><INDEXTARGET ID="08-drvrstruct42"><!-- POSTPROCESSDATA: 08-drvrstruct42|IRIX commands:<COMMAND>mount</COMMAND> --><INDEXTARGET ID="08-drvrstruct43"><!-- POSTPROCESSDATA: 08-drvrstruct43|entry points:open --><VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> entry when a process executes the <FUNCTION>open()</FUNCTION> system call on any device special file (see the <REFPAGE>open(2)</REFPAGE> reference page). It is also called when a process executes the <FUNCTION>mount()</FUNCTION> system call on a block device (see the <REFPAGE>mount(2)</REFPAGE> reference page). (For the <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> entry point of a STREAMS driver, see <XREF IDREF="71515" TYPE="TITLE">&ldquo;Entry Point open()&rdquo;</XREF>.)</PARAGRAPH>
<PARAGRAPH>The prototype of <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> is as follows:</PARAGRAPH>
<EXAMPLE>
int <ITALICS>pfx</ITALICS>open(dev_t *<ITALICS>devp</ITALICS>, int <ITALICS>oflag</ITALICS>, int <ITALICS>otyp</ITALICS>, cred_t *<ITALICS>crp</ITALICS>);
</EXAMPLE>
<PARAGRAPH>The argument values are </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>*devp</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Pointer to a <VARIABLE>dev_t</VARIABLE> value, actually a handle to a leaf vertex in the hwgraph. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>otyp</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>An integer flag specifying the source of the call: a user process opening a 
character device or block device, or another driver. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>oflag</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Flag bits specifying user mode options on the <FUNCTION>open()</FUNCTION> call. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>crp</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>A <VARIABLE>cred_t</VARIABLE> object&mdash;an opaque structure for use in authentication. Standard 
access privileges to the special device file have already been verified. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<NOTE><PREFIX>Note</PREFIX>In releases prior to IRIX       6.4, a driver's <INDEXTARGET ID="08-drvrstruct44"><!-- POSTPROCESSDATA: 08-drvrstruct44|D_OLD flag --><VARIABLE>pfx</VARIABLE><FUNCTION>devflag</FUNCTION> constant could contain D_OLD. In that case, the first argument to <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> was a <VARIABLE>dev_t</VARIABLE> value, not a pointer to a <VARIABLE>dev_t</VARIABLE> value. However, this compatibility mode is no longer supported. The first argument to <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> is always a pointer to a <VARIABLE>dev_t</VARIABLE>.</NOTE>
<PARAGRAPH>The <REFPAGE>open(D2)</REFPAGE> reference page discusses the kind of work the <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> entry point can do. In general, the driver is expected to verify that this user process is permitted access in the way specified in <VARIABLE>otyp</VARIABLE> (reading, writing, or both) for the device specified in <VARIABLE>*devp</VARIABLE>. If access is not allowable, the driver returns a nonzero error code from <FILENAME>sys/errno.h</FILENAME>, for example ENOMEM or EBUSY.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Use of the Device Handle</TITLE><PARAGRAPH>The <INDEXTARGET ID="08-drvrstruct45"><!-- POSTPROCESSDATA: 08-drvrstruct45|hwgraph:and top-half entry point --><INDEXTARGET ID="08-drvrstruct46"><!-- POSTPROCESSDATA: 08-drvrstruct46|minor device number:input to open --><INDEXTARGET ID="08-drvrstruct47"><!-- POSTPROCESSDATA: 08-drvrstruct47|data types:<VARIABLE>dev_t</VARIABLE> --><VARIABLE>dev_t</VARIABLE> value input to <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> and all other top-half entry points is the key parameter that specifies the device. You use the <VARIABLE>dev_t</VARIABLE> to locate the hwgraph vertex that is being opened. From that vertex you extract the address of the device information structure that was stored when the device was attached (see <XREF IDREF="61268" TYPE="TITLE">&ldquo;Allocating Storage for Device Information&rdquo;</XREF>). In <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> or any other top-half entry point, the driver retrieves the device information by applying <FUNCTION>device_info_get()</FUNCTION> to the <VARIABLE>dev_t</VARIABLE> value (see <XREF IDREF="70160" TYPE="TITLE">&ldquo;Interrogating the hwgraph&rdquo;</XREF>).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Use of the Open Type</TITLE><PARAGRAPH>The <INDEXTARGET ID="08-drvrstruct48"><!-- POSTPROCESSDATA: 08-drvrstruct48|entry points:open:type flag --><INDEXTARGET ID="08-drvrstruct49"><!-- POSTPROCESSDATA: 08-drvrstruct49|header files:<FILENAME>sys/open.h</FILENAME> --><VARIABLE>otyp</VARIABLE> flag distinguishes between the following possible sources of this call to <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> (the constants are defined in <FILENAME>sys/open.h</FILENAME>).</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>a call to open a character device (OTYP_CHR)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>a call to open a block device (OTYP_BLK)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>a call to a mount a block device as a filesystem (OTYP_MNT)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>a call to open a block device as swapping device (OTYP_SWP)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>a call direct from a device driver at a higher level (OTYP_LYR)</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Typically a driver is written only to be a character driver or a block driver, and can be called only through the switch table for that type of device. When this is the case, the <VARIABLE>otyp</VARIABLE> value has little use.</PARAGRAPH>
<PARAGRAPH>It is possible to have the same driver treated as both block and character, in which case the driver needs to know whether the <INDEXTARGET ID="08-drvrstruct50"><!-- POSTPROCESSDATA: 08-drvrstruct50|character device:combined with block --><INDEXTARGET ID="08-drvrstruct51"><!-- POSTPROCESSDATA: 08-drvrstruct51|block device:combined with character --><FUNCTION>open()</FUNCTION> call addressed a block or character special device. It is possible for a block device to support different partitions with different uses, in which case the driver might need to record the fact that a device has been mounted, or opened as a swap device.</PARAGRAPH>
<PARAGRAPH>With all open types except OTYP_LYR, <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> is called for every open or mount operation, but <VARIABLE>pfx</VARIABLE><FUNCTION>close()</FUNCTION> is called only when the last close or unmount occurs. The OTYP_LYR feature is used almost exclusively by drivers distributed with IRIX, like the host adapter SCSI driver (see <XREF IDREF="21920" TYPE="TITLE">&ldquo;Host Adapter Concepts&rdquo;</XREF>). For each open of this type, there is one call to <VARIABLE>pfx</VARIABLE><FUNCTION>close()</FUNCTION>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Use of the Open Flag</TITLE><PARAGRAPH>The interpretation of the open mode flags is up to the designer of the driver. Four modes can be requested (declared in <INDEXTARGET ID="08-drvrstruct52"><!-- POSTPROCESSDATA: 08-drvrstruct52|entry points:open:mode flag --><INDEXTARGET ID="08-drvrstruct53"><!-- POSTPROCESSDATA: 08-drvrstruct53|header files:<FILENAME>sys/file.h</FILENAME> --><FILENAME>sys/file.h</FILENAME>): </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>FREAD </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="297"><PARAGRAPH>Input access wanted. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>FWRITE </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="297"><PARAGRAPH>Output access wanted (both FREAD and FWRITE may be set, 
corresponding to O_RDWR mode). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>FNDELAY or 
FNONBLOCK </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="297"><PARAGRAPH>Return at once, do not sleep if the open cannot be done 
immediately. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>FEXCL </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="297"><PARAGRAPH>Request exclusive use of the device. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>You decide which of the flags have meaning with respect to the abilities of this device. You can return an EINVAL error when an unsupported mode is requested.</PARAGRAPH>
<PARAGRAPH>A key decision is whether the device can be opened only by one process at a time, or by multiple processes. If multiple opens are supported, a process can still request exclusive access with the FEXCL mode.</PARAGRAPH>
<PARAGRAPH>When the device can be used by only one process, or when FEXCL access is supported, the driver must keep track of the fact that the device is open. When the device is busy, the driver can test the FNDELAY and FNONBLOCK flags; if either is set, it can return EBUSY. Otherwise, the driver should sleep until the device is free; this requires coordination with the <VARIABLE>pfx</VARIABLE><FUNCTION>close()</FUNCTION> entry point.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Use of the cred_t Object</TITLE><PARAGRAPH>The <INDEXTARGET ID="08-drvrstruct54"><!-- POSTPROCESSDATA: 08-drvrstruct54|kernel functions:<FUNCTION>drv_priv()</FUNCTION> --><INDEXTARGET ID="08-drvrstruct55"><!-- POSTPROCESSDATA: 08-drvrstruct55|data types:<VARIABLE>cred_t</VARIABLE> --><VARIABLE>cred_t</VARIABLE> object passed to <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>close()</FUNCTION>, and <VARIABLE>pfx</VARIABLE><FUNCTION>ioctl()</FUNCTION> can be used with the <FUNCTION>drv_priv()</FUNCTION> function to find out if the effective calling user ID is privileged or not (see the <REFPAGE>drv_priv(D3)</REFPAGE> reference page). Do not examine the object in detail, since its contents are subject to change from release to release.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Saving the Size of a Block Device</TITLE><PARAGRAPH>In a block device driver, the <INDEXTARGET ID="08-drvrstruct56"><!-- POSTPROCESSDATA: 08-drvrstruct56|entry points:size --><VARIABLE>pfx</VARIABLE><FUNCTION>size()</FUNCTION> entry point will be called soon after <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> (see <XREF IDREF="63295" TYPE="TITLE">&ldquo;Entry Point size()&rdquo;</XREF>). It is typically best to calculate or read the device capacity at open time, and save it to be reported from <VARIABLE>pfx</VARIABLE><FUNCTION>size()</FUNCTION>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Completing the hwgraph</TITLE><PARAGRAPH>Some device drivers distributed with IRIX test, at open time, to see if this is the first open since the attachment of the specified device. For these devices, the first <FUNCTION>open()</FUNCTION> call is guaranteed to come from the <COMMAND>ioconfig</COMMAND> program after it has assigned a stable controller number (see <XREF IDREF="83505" TYPE="TITLE">&ldquo;Using ioconfig for Global Controller Numbers&rdquo;</XREF>). When these drivers detect the first open for a device, they retrieve the assigned controller number from the device vertex using <FUNCTION>device_controller_num_get()</FUNCTION> (see <REFPAGE>hwgraph.inv(d3x)</REFPAGE>, and possibly add convenience vertexes to the hwgraph.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="14026">Entry Point close()</TITLE><PARAGRAPH>The kernel calls the <INDEXTARGET ID="08-drvrstruct57"><!-- POSTPROCESSDATA: 08-drvrstruct57|IRIX commands:<COMMAND>umount</COMMAND> --><INDEXTARGET ID="08-drvrstruct58"><!-- POSTPROCESSDATA: 08-drvrstruct58|IRIX functions:<FUNCTION>close()</FUNCTION> --><INDEXTARGET ID="08-drvrstruct59"><!-- POSTPROCESSDATA: 08-drvrstruct59|entry points:close --><VARIABLE>pfx</VARIABLE><FUNCTION>close()</FUNCTION> entry when the last process calls <FUNCTION>close()</FUNCTION> or <FUNCTION>umount()</FUNCTION> for the device special file. It is important to know that when the device can be opened by multiple processes, <VARIABLE>pfx</VARIABLE><FUNCTION>close()</FUNCTION> is not called for every <FUNCTION>close()</FUNCTION> function, but only when the last remaining process closes the device and no other processes have it open. The function prototype and arguments of <VARIABLE>pfx</VARIABLE><FUNCTION>close()</FUNCTION> are</PARAGRAPH>
<EXAMPLE>
int <VARIABLE>pfx</VARIABLE>close(dev_t <VARIABLE>dev</VARIABLE>, int <VARIABLE>flag</VARIABLE>, int <VARIABLE>otyp</VARIABLE>, cred_t *<VARIABLE>crp</VARIABLE>);
</EXAMPLE>
<PARAGRAPH>The arguments are the same as were passed to <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION>. However, the flag argument is not necessarily the same as at any particular call to <FUNCTION>open()</FUNCTION>.</PARAGRAPH>
<PARAGRAPH>It is up to you to design the meaning of &ldquo;close&rdquo; for this type of device. The <REFPAGE>close(D2)</REFPAGE> reference page discusses some of the actions the driver can do. Some considerations are:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>If the device is opened and closed frequently, you may decide to retain dynamic data structures.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>If the device can perform an action such as &ldquo;rewind&rdquo; or &ldquo;eject,&rdquo; you decide whether that action should be done upon close. Possibly the choice of acting or not acting can be set by an <FUNCTION>ioctl()</FUNCTION> call; or possibly the choice can be encoded into the device minor number&mdash;for example, the no-rewind-on-close option is encoded in certain tape minor device numbers.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>If the <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> entry point supports exclusive access, and it can be waiting for the device to be free, <VARIABLE>pfx</VARIABLE><FUNCTION>close()</FUNCTION> must release the wait.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>When a device can do DMA, the <VARIABLE>pfx</VARIABLE><FUNCTION>close()</FUNCTION> entry point is the appropriate place to make sure that all I/O has terminated. Since all processes have closed the device, there is no reason for it to continue transmitting data into memory; and if it does continue, it might corrupt memory.</PARAGRAPH>
<PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>close()</FUNCTION> entry can detect an error and report it with a return code. However, the file is closed or unmounted regardless.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="17370">Control Entry Point</TITLE><PARAGRAPH>The <INDEXTARGET ID="08-drvrstruct60"><!-- POSTPROCESSDATA: 08-drvrstruct60|entry points:ioctl --><VARIABLE>pfx</VARIABLE><FUNCTION>ioctl()</FUNCTION> entry point is called by the kernel when a user process executes the <FUNCTION>ioctl()</FUNCTION> system call (see the <REFPAGE>ioctl(2)</REFPAGE> reference page). This entry point is allowed in character drivers only. Block device drivers do not support it. STREAMS drivers pass control information as messages.</PARAGRAPH>
<PARAGRAPH>For an overview of the relationship between the user process, kernel, and the control entry point, see <XREF IDREF="12595" TYPE="TITLE">&ldquo;Overview of Device Control&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>The prototype of the entry point is</PARAGRAPH>
<CODE>
int <ITALICS>pfx</ITALICS>ioctl(dev_t <ITALICS>dev</ITALICS>, int <ITALICS>cmd</ITALICS>, void *<ITALICS>arg</ITALICS>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int <ITALICS>mode</ITALICS>, cred_t *<ITALICS>crp</ITALICS>, int *<ITALICS>rvalp</ITALICS>);
</CODE>
<PARAGRAPH>The argument values are </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>dev</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>A <VARIABLE>dev_t</VARIABLE> value from which you can extract the major and minor device 
numbers, or the device information from the hwgraph vertex. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>cmd</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>The request value specified in the <FUNCTION>ioctl()</FUNCTION> call. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>arg</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>The optional argument value specified in the <FUNCTION>ioctl()</FUNCTION> call, or NULL if none was 
specified. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>mode</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Flag bits specifying the <FUNCTION>open()</FUNCTION> mode, as associated with the file descriptor 
passed to the <FUNCTION>ioctl()</FUNCTION> system function. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>crp</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>A <VARIABLE>cred_t</VARIABLE> object&mdash;an opaque structure for use in authentication, describing the 
process that is in-context. Standard access privileges to the special device file 
have already been verified. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>*rvalp </PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>The integer result to be returned to the user process. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>It is up to the device driver to interpret the <VARIABLE>cmd</VARIABLE> and <VARIABLE>arg</VARIABLE> values in the light of the <VARIABLE>mode</VARIABLE> and other arguments. When the <VARIABLE>arg</VARIABLE> value is a pointer to data in the process address space, the driver uses the <FUNCTION>copyin()</FUNCTION> kernel function to copy the data into kernel space, and the <FUNCTION>copyout()</FUNCTION> function to return updated values. (See the <REFPAGE>copyin(D3)</REFPAGE> and <REFPAGE>copyout(D3)</REFPAGE> reference pages, and also <XREF IDREF="20796" TYPE="TITLE">&ldquo;Transferring Data&rdquo;</XREF>.) <INDEXTARGET ID="08-drvrstruct61"><!-- POSTPROCESSDATA: 08-drvrstruct61|kernel functions:<FUNCTION>copyin()</FUNCTION> --><INDEXTARGET ID="08-drvrstruct62"><!-- POSTPROCESSDATA: 08-drvrstruct62|kernel functions:<FUNCTION>copyout()</FUNCTION> --></PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Choosing the Command Numbers</TITLE><PARAGRAPH>The command numbers supported by <VARIABLE>pfx</VARIABLE><FUNCTION>ioctl()</FUNCTION> are arbitrary; but the recommended practice is to make sure that they are different from those of any other driver. One method to achieve this is suggested in the <REFPAGE>ioctl(D2)</REFPAGE> reference page.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Supporting 32-Bit and 64-Bit Callers</TITLE><PARAGRAPH>The <FUNCTION>ioctl()</FUNCTION> entry point may need to interpret a structure prepared in the user process. In a 64-bit system, the user process can be either a 32-bit or a 64-bit program. For discussion of this issue, see <XREF IDREF="87735" TYPE="TITLE">&ldquo;Handling 32-Bit and 64-Bit Execution Models&rdquo;</XREF>.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>User Return Value</TITLE><PARAGRAPH>The kernel returns 0 to the <FUNCTION>ioctl()</FUNCTION> system function unless the <VARIABLE>pfx</VARIABLE><FUNCTION>ioctl()</FUNCTION> function returns an error code. In the event of an error, the kernel may also return the code the driver places in <VARIABLE>*rvalp</VARIABLE>, if any, or -1. To ensure that the user process sees a specific error code, it is a good idea to set the code in <VARIABLE>*rvalp</VARIABLE>, and return that value. If your device driver does not define a <VARIABLE>pfx</VARIABLE><FUNCTION>devflag</FUNCTION> or sets it to D_OLD, see <XREF IDREF="67704" TYPE="TITLE">&ldquo;Driver Flag Constant&rdquo;</XREF>. </PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="67201">Data Transfer Entry Points</TITLE><PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>read()</FUNCTION> and <VARIABLE>pfx</VARIABLE><FUNCTION>write()</FUNCTION> entry points are supported by character device drivers and pseudo-device drivers that allow reading and writing. They are called by the kernel when the user process calls the <FUNCTION>read()</FUNCTION>, <FUNCTION>readv()</FUNCTION>, <FUNCTION>write()</FUNCTION>, or <FUNCTION>writev()</FUNCTION> system function.</PARAGRAPH>
<PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> entry point is required of block device drivers. It is called by the kernel when either a filesystem or the paging subsystem needs to transfer a block of data.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="66358">Entry Points read() and write()</TITLE><PARAGRAPH>The <INDEXTARGET ID="08-drvrstruct63"><!-- POSTPROCESSDATA: 08-drvrstruct63|data types:<VARIABLE>uio_t</VARIABLE> --><INDEXTARGET ID="08-drvrstruct64"><!-- POSTPROCESSDATA: 08-drvrstruct64|entry points:read --><INDEXTARGET ID="08-drvrstruct65"><!-- POSTPROCESSDATA: 08-drvrstruct65|entry points:write --><VARIABLE>pfx</VARIABLE><FUNCTION>read()</FUNCTION> and <VARIABLE>pfx</VARIABLE><FUNCTION>write()</FUNCTION> entry points are similar to each other&mdash;only the direction of data transfer differs. The prototypes of the functions are</PARAGRAPH>
<CODE>
int <COMMAND>pfx</COMMAND>read (dev_t <ITALICS>dev</ITALICS>, uio_t *<ITALICS>uiop</ITALICS>, cred_t *<ITALICS>crp</ITALICS>);
int <COMMAND>pfx</COMMAND>write(dev_t <ITALICS>dev</ITALICS>, uio_t *<ITALICS>uiop</ITALICS>, cred_t *<ITALICS>crp</ITALICS>);
</CODE>
<PARAGRAPH>The arguments are </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>dev</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>A <VARIABLE>dev_t</VARIABLE> value from which you can extract the major and minor device 
numbers, or the device information from the hwgraph vertex. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>*uiop</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>A <VARIABLE>uio_t</VARIABLE> object&mdash;a structure that defines the user's buffer memory areas. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>crp</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>A <VARIABLE>cred_t</VARIABLE> object&mdash;an opaque structure for use in authentication. Standard 
access privileges to the special device file have already been verified. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<SECTION3 LBL="" HELPID = ""><TITLE>Data Transfer for a PIO Device</TITLE><PARAGRAPH>A character device driver using PIO transfers data in the following steps:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>If there is a possibility of a timeout, start a timeout delay (see <XREF IDREF="56199" TYPE="TITLE">&ldquo;Waiting for Time to Pass&rdquo;</XREF>).</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Initiate the device operation as required.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Transfer data between the device and the buffer represented by the <VARIABLE>uio_t</VARIABLE> (see <XREF IDREF="75852" TYPE="TITLE">&ldquo;Transferring Data Through a uio_t Object&rdquo;</XREF>).</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>If it is necessary to wait for an interrupt, put the process to sleep (see <XREF IDREF="14643" TYPE="TITLE">&ldquo;Waiting and Mutual Exclusion&rdquo;</XREF>).</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>When data transfer is complete, or when an error occurs, clear any pending timeout and return the final status of the operation. If the return code is 0, the final state of the <VARIABLE>uio_t</VARIABLE> determines the byte count returned by the <FUNCTION>read()</FUNCTION> or <FUNCTION>write()</FUNCTION> call.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="31423">Calling Entry Point strategy() From Entry Point read() or write()</TITLE><PARAGRAPH>A device driver that supports both character and block interfaces must have a <INDEXTARGET ID="08-drvrstruct66"><!-- POSTPROCESSDATA: 08-drvrstruct66|kernel functions:<FUNCTION>physiock()</FUNCTION> --><INDEXTARGET ID="08-drvrstruct67"><!-- POSTPROCESSDATA: 08-drvrstruct67|kernel functions:<FUNCTION>uiophysio()</FUNCTION> --><INDEXTARGET ID="08-drvrstruct68"><!-- POSTPROCESSDATA: 08-drvrstruct68|entry points:strategy:called from read or write --><VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> routine in which it performs the actual I/O.</PARAGRAPH>
<PARAGRAPH>For example, the IRIX disk drivers support both character and block driver interfaces, and perform all I/O operations in the <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> function. However, the <VARIABLE>pfx</VARIABLE><FUNCTION>read()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>write()</FUNCTION> and <VARIABLE>pfx</VARIABLE><FUNCTION>ioctl()</FUNCTION> entries supported for character-type access also need to perform I/O operations. They do this by calling the <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> routine indirectly, using the kernel function <FUNCTION>physiock()</FUNCTION> or <FUNCTION>uiophysio()</FUNCTION> (see the <REFPAGE>physiock(D3)</REFPAGE> and <REFPAGE>uiophysio(D3)</REFPAGE> reference pages, and see <XREF IDREF="78884" TYPE="TITLE">&ldquo;Waiting for Block I/O to Complete&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>Both the <FUNCTION>physiock()</FUNCTION> and <FUNCTION>uiophysio()</FUNCTION> functions takes care of the housekeeping needed to interface to the <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> entry, including the work of allocating a buffer and a <VARIABLE>buf_t</VARIABLE> structure, locking buffer pages in memory and waiting for I/O completion. Both routines require the <VARIABLE>uio_t</VARIABLE> to describe only a single segment of data (<VARIABLE>uio_iovcnt</VARIABLE> of 1). Although they are very similar, the two functions differ in the following ways:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><FUNCTION>physiock()</FUNCTION> returns EINVAL if the initial offset is not a multiple of 512 bytes. If this is a requirement of your <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> routine, use <FUNCTION>physiock()</FUNCTION>; if not, use <FUNCTION>uiophysio()</FUNCTION>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><FUNCTION>physiock()</FUNCTION> is compatible with SVR4, while <FUNCTION>uiophysio()</FUNCTION> is unique to IRIX.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH><XREF IDREF="93418" TYPE="TEXT">Example&nbsp;7-3</XREF> shows the skeleton of a hypothetical driver in which the <VARIABLE>pfx</VARIABLE><FUNCTION>read()</FUNCTION> entry does its work through the <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> entry.</PARAGRAPH>
<CODE><CAPTION LBL="7-3"><PREFIX>Example 7-3 </PREFIX><XREFTARGET ID="93418">Hypothetical pfxread() entry in a Character/Block Driver</CAPTION>hypo_read (dev_t dev, uio_t *uiop, cred_t *crp)
{
&nbsp;&nbsp;&nbsp;// ...validate the operation... //
&nbsp;&nbsp;&nbsp;return physiock(hypo_strategy, /* our strategy entry */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;/* allocate temp buffer &amp; buf_t */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dev, /* dev_t arg for strategy */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B_READ, /* direction flag for buf_t */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uiop);
}
</CODE>
<PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>write()</FUNCTION> entry would be identical except for passing B_WRITE instead of B_READ.</PARAGRAPH>
<PARAGRAPH>This dual-entry strategy is required only in a driver that supports both character and block access. </PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="66319">Entry Point strategy()</TITLE><PARAGRAPH>A block device driver does not directly support system calls by user processes. Instead, it provides services to a filesystem such as XFS, or to the memory paging subsystem of IRIX. These subsystems call the <INDEXTARGET ID="08-drvrstruct69"><!-- POSTPROCESSDATA: 08-drvrstruct69|entry points:strategy --><VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> entry point to read data in whole blocks.</PARAGRAPH>
<PARAGRAPH>Calls to <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> are not directly related in time to system functions called by a user process. For example, a filesystem may buffer many blocks of data in memory, so that the user process may execute dozens or hundreds of <FUNCTION>write()</FUNCTION> calls without causing an entry to the device driver. When the user function closes the file or calls <FUNCTION>fsync()</FUNCTION>&mdash;or when for unrelated reasons the filesystem needs to free some buffers&mdash;the filesystem calls <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> to write numerous blocks of data.</PARAGRAPH>
<PARAGRAPH>In a driver that supports the character interface as well, the <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> entry can be called indirectly from the <VARIABLE>pfx</VARIABLE><FUNCTION>read()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>write()</FUNCTION> and <VARIABLE>pfx</VARIABLE><FUNCTION>ioctl()</FUNCTION> entries, as described under <XREF IDREF="31423" TYPE="TITLE">&ldquo;Calling Entry Point strategy() From Entry Point read() or write()&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>The prototype of the <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> entry point is</PARAGRAPH>
<EXAMPLE>
int <ITALICS>pfx</ITALICS>strategy(struct buf *<ITALICS>bp</ITALICS>);
</EXAMPLE>
<PARAGRAPH>The argument is the address of a <INDEXTARGET ID="08-drvrstruct70"><!-- POSTPROCESSDATA: 08-drvrstruct70|data types:<VARIABLE>buf_t</VARIABLE> --><VARIABLE>buf_t</VARIABLE> structure, which gives the strategy routine the information it needs to perform the I/O:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The <VARIABLE>dev_t</VARIABLE>, from which the driver can get major and minor device numbers or the device information from the <FILENAME>hwgraph</FILENAME> vertex</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The direction of the transfer (read or write)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The location of the buffer in kernel memory</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The amount of data to transfer</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The starting block number on the device</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>For more on the contents of the <VARIABLE>buf_t</VARIABLE> structure, see <XREF IDREF="34384" TYPE="TITLE">&ldquo;Structure buf_t&rdquo;</XREF> and the <REFPAGE>buf(D4)</REFPAGE> reference page.</PARAGRAPH>
<PARAGRAPH>The driver uses the information in the <VARIABLE>buf_t</VARIABLE> to validate the data transfer and programs the device to start the transfer. Then it stores the address of the <VARIABLE>buf_t</VARIABLE> where the interrupt handler can find it (see <XREF IDREF="41192" TYPE="TITLE">&ldquo;Interrupt Entry Point and Handler&rdquo;</XREF>) and calls <FUNCTION>biowait()</FUNCTION> to wait for the operation to complete. For the next step, see <XREF IDREF="43724" TYPE="TITLE">&ldquo;Completing Block I/O&rdquo;</XREF> (see also the <REFPAGE>biowait(D3)</REFPAGE> reference page).&space;</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="93582">Poll Entry Point</TITLE><PARAGRAPH>The <INDEXTARGET ID="08-drvrstruct71"><!-- POSTPROCESSDATA: 08-drvrstruct71|entry points:poll --><VARIABLE>pfx</VARIABLE><FUNCTION>poll()</FUNCTION> entry point is called by the kernel when a user process calls the <FUNCTION>poll()</FUNCTION> or <FUNCTION>select()</FUNCTION> system function asking for status on a character special device. To implement it, you need to understand the IRIX implementation of <FUNCTION>poll()</FUNCTION>.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="57221">Use and Operation of poll(2)</TITLE><PARAGRAPH>The IRIX version of <INDEXTARGET ID="08-drvrstruct72"><!-- POSTPROCESSDATA: 08-drvrstruct72|IRIX functions:<FUNCTION>poll()</FUNCTION> --><FUNCTION>poll()</FUNCTION> allows a process to wait for events of different types to occur on any combination of devices, files, and STREAMS (see the <REFPAGE>poll(2)</REFPAGE> and <REFPAGE>select(2)</REFPAGE> reference pages). It is possible for multiple processes to be waiting for events on the same device.</PARAGRAPH>
<PARAGRAPH>It is up to you as the designer of a driver to decide which of the events that are documented in <REFPAGE>poll(2)</REFPAGE> are meaningful for your device. Other requested events simply never happen to the device.</PARAGRAPH>
<PARAGRAPH>Much of the complexity of <INDEXTARGET ID="08-drvrstruct73"><!-- POSTPROCESSDATA: 08-drvrstruct73|kernel functions:<FUNCTION>phalloc()</FUNCTION> --><INDEXTARGET ID="08-drvrstruct74"><!-- POSTPROCESSDATA: 08-drvrstruct74|header files:<FILENAME>sys/poll.h</FILENAME> --><INDEXTARGET ID="08-drvrstruct75"><!-- POSTPROCESSDATA: 08-drvrstruct75|data types:<VARIABLE>struct pollhead</VARIABLE>data types:pollhead --><FUNCTION>poll()</FUNCTION> is handled by the IRIX kernel, but the kernel requires the assistance of any device driver that supports <FUNCTION>poll()</FUNCTION>. The driver is expected to allocate and hold a <VARIABLE>pollhead</VARIABLE> structure (declared in <FILENAME>sys/poll.h</FILENAME>) for each minor device that it supports. Allocation is simple; the driver merely calls the <FUNCTION>phalloc()</FUNCTION> kernel function. (The <VARIABLE>pfx</VARIABLE><FUNCTION>start()</FUNCTION> entry point is a suitable place for this call; see <XREF IDREF="97690" TYPE="TITLE">&ldquo;Entry Point start()&rdquo;</XREF>.)</PARAGRAPH>
<PARAGRAPH>There are two phases to the operation of <FUNCTION>poll()</FUNCTION>. When the system function is called, the kernel calls the <VARIABLE>pfx</VARIABLE><FUNCTION>poll()</FUNCTION> entry point to find out if any requested events are pending at this time. If the kernel finds any event s pending (on this or any other polled object), the <FUNCTION>poll()</FUNCTION> function returns to the user process. Nothing further is required.</PARAGRAPH>
<PARAGRAPH>However, when no requested event has happened, the user process expects the <FUNCTION>poll()</FUNCTION> function to block until an event has occurred. The kernel must implement this delay. It would be too inefficient for the kernel to repeatedly test for events. The kernel must rely on device drivers to notify it when an event has occurred.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="35890">Use of pollwakeup()</TITLE><PARAGRAPH>A device driver that supports <INDEXTARGET ID="08-drvrstruct76"><!-- POSTPROCESSDATA: 08-drvrstruct76|kernel functions:<FUNCTION>pollwakeup()</FUNCTION> --><VARIABLE>pfx</VARIABLE><FUNCTION>poll()</FUNCTION> is required to notify the kernel whenever an event that the driver supports has occurred. The driver does this by calling a kernel function, <FUNCTION>pollwakeup()</FUNCTION>, passing the <VARIABLE>pollhead</VARIABLE> structure for the affected device, and bit flags for the events that have taken place. In the event that one or more user processes are blocked in a <FUNCTION>poll()</FUNCTION>, waiting for an event from this device, the call to <FUNCTION>pollwakeup()</FUNCTION> will release the sleeping processes. For an example, see <XREF IDREF="26077" TYPE="TITLE">&ldquo;Calling pollwakeup()&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Use of pollwakeup() Without Interrupts</TITLE><PARAGRAPH>If the device in question does not support interrupts, the driver cannot support <INDEXTARGET ID="08-drvrstruct77"><!-- POSTPROCESSDATA: 08-drvrstruct77|kernel functions:<FUNCTION>itimeout()</FUNCTION> --><FUNCTION>poll()</FUNCTION> unless it can somehow get control to discover an event and report it to <FUNCTION>pollwakeup()</FUNCTION>. One possibility is that the driver could simulate interrupts by setting a succession of <FUNCTION>itimeout()</FUNCTION> delays. On each timeout the driver would test its device for a change of status, call <FUNCTION>pollwakeup()</FUNCTION> when an event has occurred; and schedule a new delay. (See <XREF IDREF="56199" TYPE="TITLE">&ldquo;Waiting for Time to Pass&rdquo;</XREF>.) </PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="19826">Entry Point poll()</TITLE><PARAGRAPH>The prototype for <VARIABLE>pfx</VARIABLE><FUNCTION>poll()</FUNCTION> is as follows:</PARAGRAPH>
<CODE>
int <VARIABLE>pfx</VARIABLE>poll(dev_t <ITALICS>dev</ITALICS>, short <ITALICS>events</ITALICS>, int <ITALICS>anyyet</ITALICS>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short *<ITALICS>reventsp</ITALICS>, struct pollhead **<ITALICS>phpp,</ITALICS>&space;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int <ITALICS>*genp</ITALICS>);
</CODE>
<PARAGRAPH>The argument values are </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><VARIABLE>dev</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>A <VARIABLE>dev_t</VARIABLE> value from which you can extract the major and minor device 
numbers, or the device information from the hwgraph vertex.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><VARIABLE>events</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Bit-flags for the events the user process is testing, as passed to <FUNCTION>poll()</FUNCTION> 
and declared in <FILENAME>sys/poll.h</FILENAME>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><VARIABLE>*reventsp</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>A field to receive the bit-flags of events that have occurred, or to 
receive 0x0000 if no requested events have occurred.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><VARIABLE>anyyet</VARIABLE> and *<VARIABLE>phpp</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>When <VARIABLE>anyyet</VARIABLE> is zero and no events have occurred, the kernel requires 
the address of the pollhead structure for this minor device to be 
returned in <VARIABLE>*phpp</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><ITALICS>*genp</ITALICS>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>A pointer to an unsigned integer that is used by the driver to store 
the current value of the pollhead's generation number at the time of 
the poll. (New in IRIX 6.5.)</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH><XREF IDREF="26373" TYPE="TEXT">Example&nbsp;7-4</XREF> shows the <VARIABLE>pfx</VARIABLE><FUNCTION>poll()</FUNCTION> code of a hypothetical device driver. Only three event tests are supported: POLLIN and POLLRDNORM (treated as equivalent) and POLLOUT. The device driver maintains an array of <VARIABLE>pollhead</VARIABLE> structures, one for each supported minor device. These are presumably allocated during initialization.</PARAGRAPH>
<CODE><CAPTION LBL="7-4"><PREFIX>Example 7-4 </PREFIX><VARIABLE><XREFTARGET ID="26373">pfx</VARIABLE>poll() Code for Hypothetical Driver</CAPTION>struct pollhead phds[MAXMINORS];
#define OUR_EVENTS (POLLIN|POLLOUT|POLLRDNORM)
hypo_poll(dev_t dev, short events, int anyyet,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short *reventsp, struct pollhead **phpp, unsigned int *genp)
{
&nbsp;&nbsp;&nbsp;minor_t dminor = geteminor(dev);
&nbsp;&nbsp;&nbsp;short happened = 0;
&nbsp;&nbsp;&nbsp;short wanted = events &amp; OUR_EVENTS;&lbreak;   *genp = POLLGEN(&amp;phds[dminor])
&nbsp;&nbsp;&nbsp;if (wanted &amp; (POLLIN|POLLRDNORM))
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (device_has_data_ready(dminor))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;happened |= (POLLIN|POLLRDNORM);
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if (wanted &amp; POLLOUT)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (device_ready_for_output(dminor))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;happened |= POLLOUT;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if (device_pending_error(dminor))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;happened |= POLLERR;
&nbsp;&nbsp;&nbsp;if (0 == (*reventsp = happened))
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (anyyet) *phpp = &amp;phds[dminor]
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;return 0;
}
</CODE>
<PARAGRAPH>The code in <XREF IDREF="26373" TYPE="TEXT">Example&nbsp;7-4</XREF> begins by discarding any unsupported event flags that might have been requested, and passes back the driver's pollhead generation number before probing the device. Then it tests the remaining flags against the device status. If the device has an uncleared error, the code inserts the POLLERR event. If no events were detected, and if the kernel requested it, the address of the <VARIABLE>pollhead</VARIABLE> structure for this minor device is returned.</PARAGRAPH>
<PARAGRAPH>If no requested event has occurred, the process will queue awaiting the requested events, provided that no event has occurred in the interim&mdash;before it is able to queue. This is determined by comparing the pollhead generation number at the time of queueing with the pollhead generation number passed back at the initial request. Since a call to pollwakeup() increments the pollhead generation number, any difference in the current pollhead generation number to the one at the time of the initial request indicates a device event has occurred, and the device must be queried again to determine if it was a requested event. If the values of the previous and current pollhead generation numbers are equal, the process queues. </PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="87164">Memory Map Entry Points</TITLE><PARAGRAPH>A user process requests memory mapping by calling the system function <INDEXTARGET ID="08-drvrstruct78"><!-- POSTPROCESSDATA: 08-drvrstruct78|memory mapping --><FUNCTION>mmap()</FUNCTION>. When the mapped object is a character device special file, the kernel calls the <VARIABLE>pfx</VARIABLE><FUNCTION>mmap()</FUNCTION> or <VARIABLE>pfx</VARIABLE><FUNCTION>map()</FUNCTION> entry to validate and complete the mapping. To understand these entry points, you must understand the <FUNCTION>mmap()</FUNCTION> system function.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="34808">Concepts and Use of mmap()</TITLE><PARAGRAPH>The purpose of the <INDEXTARGET ID="08-drvrstruct79"><!-- POSTPROCESSDATA: 08-drvrstruct79|IRIX functions:<FUNCTION>mmap()</FUNCTION> --><FUNCTION>mmap()</FUNCTION> system function (see the <REFPAGE>mmap(2)</REFPAGE> reference page) is to make the contents of a file directly accessible as part of the virtual address space of the user process. The results depend on the kind of file that is mapped:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>When the mapped object is a normal file, the process can load and store data from the file as if it were an array in memory.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>When the mapped object is a character device special file, the process can load and store data from device registers as if they were memory variables.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>When the mapped object is a block of memory owned and prepared by a pseudo-device driver, the process gains access to some special piece of memory data that it would not normally be able to access.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>In all cases, access is gained through normal load and store instructions, without the overhead of calling system functions such as <FUNCTION>read()</FUNCTION>. Furthermore, the same mapping can be executed by other processes, in which case the same memory, or file, or device is shared by multiple, concurrent processes. This is how shared memory segments are achieved.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Use of mmap()</TITLE><PARAGRAPH>The <FUNCTION>mmap()</FUNCTION> system function takes four key parameters:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>the file descriptor for an open file, which can be either a normal disk file or a device special file</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>an offset within that file at which the mapped data is to start. For a normal file, this is a file offset; for a device file, it represents an address in the address space of the device or the bus</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the length of data to be mapped</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>protection flags, showing whether the mapped data is read-only or read-write</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>When the mapped object is a normal file, the filesystem implements the mapping. The filesystem does not call the block device driver for assistance in mapping a file. It does call the block device driver <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> entry to read and write blocks of file data as necessary, but the mapping of pages of data into pages of memory is controlled in the filesystem code.</PARAGRAPH>
<PARAGRAPH>When the mapped object is a device special file, the <FUNCTION>mmap()</FUNCTION> parameters are passed to the device driver at either its <VARIABLE>pfx</VARIABLE><FUNCTION>mmap()</FUNCTION> or <VARIABLE>pfx</VARIABLE><FUNCTION>map()</FUNCTION> entry point. The device driver interprets the parameters in the context of the device, and uses a kernel function to create the mapping.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Persistent Mappings</TITLE><PARAGRAPH>Once a device or kernel memory has been mapped into some user address space, the mapping persists until the user process terminates or calls <FUNCTION>unmap()</FUNCTION> (see the <REFPAGE>unmap(2)</REFPAGE> reference page). In particular, the mapping does not end simply because the device special file is closed. You cannot assume, in the <INDEXTARGET ID="08-drvrstruct80"><!-- POSTPROCESSDATA: 08-drvrstruct80|entry points:close --><VARIABLE>pfx</VARIABLE><FUNCTION>close()</FUNCTION> or <INDEXTARGET ID="08-drvrstruct81"><!-- POSTPROCESSDATA: 08-drvrstruct81|entry points:unload --><VARIABLE>pfx</VARIABLE><FUNCTION>unload()</FUNCTION> entry points, that all mappings to devices have ended. </PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="20168">Entry Point map()</TITLE><PARAGRAPH>The <INDEXTARGET ID="08-drvrstruct82"><!-- POSTPROCESSDATA: 08-drvrstruct82|data types:<VARIABLE>vhandl_t</VARIABLE> --><INDEXTARGET ID="08-drvrstruct83"><!-- POSTPROCESSDATA: 08-drvrstruct83|entry points:map --><VARIABLE>pfx</VARIABLE><FUNCTION>map()</FUNCTION> entry point can be defined in either a character or a block driver (it is the only mapping entry point that a block driver can supply). The function prototype is</PARAGRAPH>
<CODE>
int <ITALICS>pfx</ITALICS>map(dev_t <ITALICS>dev</ITALICS>, vhandl_t *<ITALICS>vt</ITALICS>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;off_t <ITALICS>off</ITALICS>, int <ITALICS>len</ITALICS>, int <ITALICS>prot</ITALICS>);
</CODE>
<PARAGRAPH>The argument values are </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>dev</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>A <VARIABLE>dev_t</VARIABLE> value from which you can extract both the major and minor 
device numbers. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>vt</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>The address of an opaque structure that describes the assigned address 
in the user process address space. The structure contents are subject to 
change. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>off</VARIABLE>, <VARIABLE>len</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>The offset and length arguments passed to <FUNCTION>mmap()</FUNCTION> by the user process. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>prot</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Flags showing the access intentions of the user process. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The first task of the driver is to verify that the access specified in <VARIABLE>prot</VARIABLE> is allowed. The next task is to validate the <VARIABLE>off</VARIABLE> and <VARIABLE>len</VARIABLE> values: do they fall in the valid address space of the device?</PARAGRAPH>
<PARAGRAPH>When the device driver approves of a mapping, it uses a kernel function, <INDEXTARGET ID="08-drvrstruct84"><!-- POSTPROCESSDATA: 08-drvrstruct84|kernel functions:<FUNCTION>v_mapphys()</FUNCTION> --><FUNCTION>v_mapphys()</FUNCTION>, to establish the mapping. This function (documented in the <REFPAGE>v_mapphys(D3)</REFPAGE> reference page) takes the <VARIABLE>vhandle_t</VARIABLE>, an address in kernel cached or uncached memory, and a length. It makes the specified region of kernel space a part of the address space of the user process.</PARAGRAPH>
<PARAGRAPH>For example, a pseudo-device driver that intends to share kernel virtual memory with user processes would first allocate the memory:</PARAGRAPH>
<EXAMPLE>
caddr_t *kaddr = kmem_alloc (len, KM_CACHEALIGN);
</EXAMPLE>
<PARAGRAPH>It would then use the address of the allocated memory with the <VARIABLE>vhandle_t</VARIABLE> value it had received to map the allocated memory into the user space:</PARAGRAPH>
<EXAMPLE>
v_mapphys (vt, kaddr, len)
</EXAMPLE>
<NOTE><PREFIX>Note</PREFIX>There are no special precautions to take when mapping cached memory into user space, or when mapping device registers or bus addresses. However, you should almost never map <INDEXTARGET ID="08-drvrstruct85"><!-- POSTPROCESSDATA: 08-drvrstruct85|uncached memory access:do not map --><ITALICS>uncached</ITALICS>&space;<ITALICS>memory</ITALICS> into user space. The effects of uncached memory access are hardware dependent and differ between multiprocessors and uniprocessors. Among uniprocessors, the IP26 and IP28 CPU modules have highly restrictive rules for the use of uncached memory (see <XREF IDREF="17413" TYPE="TITLE">&ldquo;Uncached Memory Access in the IP26 and IP28&rdquo;</XREF>). In general, mapping uncached memory makes a driver nonportable and is likely to lead to subtle failures that are hard to resolve.</NOTE>
<PARAGRAPH><XREF IDREF="51573" TYPE="TEXT">Example&nbsp;7-5</XREF> contains an edited fragment of code from a Silicon Graphics device driver. This pseudo-device driver, whose prefix is <VARIABLE>flash_</VARIABLE>, provides access to &ldquo;flash&rdquo; PROM in certain computer models. It allows a user process to map the PROM into user space.</PARAGRAPH>
<CODE><CAPTION LBL="7-5"><PREFIX>Example 7-5 </PREFIX><XREFTARGET ID="51573">Edited Fragment of flash_map()</CAPTION>int flash_map(dev_t dev, vhandl_t *vt, off_t off, long len)
{
&nbsp;&nbsp;&nbsp;long offset = (long) off; /*Actual offset in flash prom*/
/* Don't allow requests which exceed the flash prom size */
&nbsp;&nbsp;&nbsp;if ((offset + len) > FLASHPROM_SIZE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ENOSPC;
/* Don't allow non page-aligned offsets */
&nbsp;&nbsp;&nbsp;if ((offset % NBPC) != 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return EIO;
/* Only allow mapping of entire pages */
&nbsp;&nbsp;&nbsp;if ((len % NBPC) != 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return EIO;
&nbsp;&nbsp;&nbsp;return v_mapphys(vt, FLASHMAP_ADDR + offset, len);
}
</CODE>
<NOTE><PREFIX>Note</PREFIX>Because there is no way for a driver to retract a successful call to <FUNCTION>v_mapphys()</FUNCTION>, your driver must return success to a <VARIABLE>pfx</VARIABLE><FUNCTION>map()</FUNCTION> call if <FUNCTION>v_mapphys()</FUNCTION> succeeds. In other words, you should make the call to <FUNCTION>v_mapphys()</FUNCTION> the last part of your <VARIABLE>pfx</VARIABLE><FUNCTION>map()</FUNCTION> routine, and only call it if you have determined that there have been no errors in any previous part of this routine. If there have been errors, the routine should return an error and not call <FUNCTION>v_mapphys()</FUNCTION>. If there have been no errors, then <VARIABLE>pfx</VARIABLE><FUNCTION>map()</FUNCTION> can return error or success based on the call to <FUNCTION>v_mapphys()</FUNCTION>. </NOTE>
<PARAGRAPH>When the driver allocates some memory resource associated with the mapping, and when more than one mapping can be active at a time, the driver needs to tag each memory resource so it can be located when the <INDEXTARGET ID="08-drvrstruct86"><!-- POSTPROCESSDATA: 08-drvrstruct86|header files:<FILENAME>sys/region.h</FILENAME> --><INDEXTARGET ID="08-drvrstruct87"><!-- POSTPROCESSDATA: 08-drvrstruct87|kernel functions:<FUNCTION>vt_gethandle()</FUNCTION> --><VARIABLE>pfx</VARIABLE><FUNCTION>unmap()</FUNCTION> entry point is called. One answer is to use the <FUNCTION>v_gethandle()</FUNCTION> macro defined in <FILENAME>ksys/ddmap.h</FILENAME>. This macro takes a pointer to a <VARIABLE>vhandle_t</VARIABLE> and returns a unique pointer-sized integer that can be used to tag allocations. No other information in <FILENAME>ksys/ddmap.h</FILENAME> is supported for driver use. </PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="11008">Entry Point mmap()</TITLE><PARAGRAPH>The <INDEXTARGET ID="08-drvrstruct88"><!-- POSTPROCESSDATA: 08-drvrstruct88|entry points:mmap --><VARIABLE>pfx</VARIABLE><FUNCTION>mmap()</FUNCTION> (note: <ITALICS>two</ITALICS> letters &ldquo;m&rdquo;) entry can be used only in a character device driver. The prototype is</PARAGRAPH>
<EXAMPLE>
int <ITALICS>pfx</ITALICS>mmap(dev_t <ITALICS>dev</ITALICS>, off_t <ITALICS>off</ITALICS>, int <ITALICS>prot</ITALICS>);
</EXAMPLE>
<PARAGRAPH>The argument values are </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>dev</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>A <VARIABLE>dev_t</VARIABLE> value from which you can extract both the major and minor device 
numbers. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>off</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>The offset argument passed to <FUNCTION>mmap()</FUNCTION> by the user process. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>prot</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Flags showing the access intentions of the user process. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The function is expected to return the page frame number (PFN) that corresponds to the offset <VARIABLE>off</VARIABLE> in the device address space. A PFN is an address divided by the page size. (See <XREF IDREF="54064" TYPE="TITLE">&ldquo;Working With Page and Sector Units&rdquo;</XREF> for page unit conversion functions.)</PARAGRAPH>
<PARAGRAPH>This entry point is supported only for compatibility with SVR4. When the kernel needs to map a character device, it looks first for <VARIABLE>pfx</VARIABLE><FUNCTION>map()</FUNCTION>. It calls <VARIABLE>pfx</VARIABLE><FUNCTION>mmap()</FUNCTION> only when <VARIABLE>pfx</VARIABLE><FUNCTION>map()</FUNCTION> is not available. The differences between the two entry points are as follows:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>This entry point receives no <VARIABLE>vhandl_t</VARIABLE> argument, so it cannot use <FUNCTION>v_mapphys()</FUNCTION>. It must calculate a page frame number, which means that it has to be aware of the current page size, obtainable from the <FUNCTION>ptob()</FUNCTION> kernel function, see <REFPAGE>ptob(D3)</REFPAGE>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>This entry point does not receive a length argument, so it has to assume a default length for every map (typically the page size).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>When a mapping is created with this entry point, the <VARIABLE>pfx</VARIABLE><FUNCTION>unmap()</FUNCTION> entry is not called.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="61378">Entry Point unmap()</TITLE><PARAGRAPH>The kernel calls the <INDEXTARGET ID="08-drvrstruct89"><!-- POSTPROCESSDATA: 08-drvrstruct89|entry points:unmap --><VARIABLE>pfx</VARIABLE><FUNCTION>unmap()</FUNCTION> entry point after a mapping is created using the <VARIABLE>pfx</VARIABLE><FUNCTION>map()</FUNCTION> entry point. This entry should be supplied, even if it is an empty function, when the <VARIABLE>pfx</VARIABLE><FUNCTION>map()</FUNCTION> entry point is supplied. If it is not supplied, the <FUNCTION>munmap()</FUNCTION> system function returns the ENODEV error to the user process.</PARAGRAPH>
<PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>unmap()</FUNCTION> entry point is only called when the mapped region has been completely unmapped by all processes. For example, suppose a parent process calls <FUNCTION>mmap()</FUNCTION> to map a device. Then the parent creates one or more child processes using <FUNCTION>sproc()</FUNCTION>. Each child shares the address space, including the mapped segment. A process in the share group can terminate, or can explicitly <FUNCTION>unmap()</FUNCTION> the segment or part of the segment, but these actions do not result in a call to <VARIABLE>pfx</VARIABLE><FUNCTION>unmap()</FUNCTION>. Only when the last process with access to the segment has fully unmapped the segment is <VARIABLE>pfx</VARIABLE><FUNCTION>unmap()</FUNCTION> called.</PARAGRAPH>
<PARAGRAPH>On entry, the kernel has completed unmapping the object from the user process address space. This entry point does not need to do anything to affect the user address space; it only needs to release any resources that were allocated to support the mapping. The prototype is<INDEXTARGET ID="08-drvrstruct90"><!-- POSTPROCESSDATA: 08-drvrstruct90|IRIX functions:<FUNCTION>munmap()</FUNCTION> --></PARAGRAPH>
<EXAMPLE>
int <ITALICS>pfx</ITALICS>unmap(dev_t <ITALICS>dev</ITALICS>, vhandl_t *<ITALICS>vt</ITALICS>);
</EXAMPLE>
<PARAGRAPH>The argument values are </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>dev</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>A <VARIABLE>dev_t</VARIABLE> value from which you can extract both the major and minor device 
numbers. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>vt</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>The address of an opaque structure that describes the assigned address in 
the user process address space. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>If the driver allocated no resources to support a mapping, no action is needed here; the entry point can consist of a &ldquo;return 0&rdquo; statement.</PARAGRAPH>
<PARAGRAPH>When the driver does allocate memory or a PIO map to support a mapping, and supports multiple mappings, the driver needs to identify the resource associated with this particular mapping in order to release it. The <INDEXTARGET ID="08-drvrstruct91"><!-- POSTPROCESSDATA: 08-drvrstruct91|kernel functions:<FUNCTION>vt_gethandle()</FUNCTION> --><FUNCTION>vt_gethandle()</FUNCTION> function returns a unique number based on the <VARIABLE>vt</VARIABLE> argument; this can be used to identify resources. </PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="41192"><XREFTARGET ID="55793">Interrupt Entry Point and Handler</TITLE><PARAGRAPH>In traditional UNIX, when a hardware device presents an interrupt, the kernel locates the device driver for the device and calls the <INDEXTARGET ID="08-drvrstruct92"><!-- POSTPROCESSDATA: 08-drvrstruct92|entry points:interrupt --><VARIABLE>pfx</VARIABLE><FUNCTION>intr()</FUNCTION> entry point (see the <REFPAGE>intr(D2)</REFPAGE> reference page). In current practice, an entry point named <VARIABLE>pfx</VARIABLE><FUNCTION>intr()</FUNCTION> is not given any special treatment&mdash;although driver writers often give this name to the interrupt-handling function even so.</PARAGRAPH>
<PARAGRAPH>A device driver must register a specific interrupt handler for each device. The kernel functions for doing this are bus-specific, and are discussed in the bus-specific chapters. For example, the means of registering a VME interrupt handler is discussed in <XREF IDREF="13012" TYPE="TITLE">Chapter&nbsp;13, &ldquo;Services for VME Drivers on Origin2000/Onyx2.&rdquo;</XREF> However, the discussion of interrupts that follows is still relevant to any interrupt handler.</PARAGRAPH>
<PARAGRAPH>In principle an interrupt can happen at any time. Normally an interrupt occurs because at some previous time, the driver initiated a device operation. Some devices can interrupt without a preceding command.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Associating Interrupt to Driver</TITLE><PARAGRAPH>The association between an interrupt and the driver is established in different ways depending on the hardware.<INDEXTARGET ID="08-drvrstruct93"><!-- POSTPROCESSDATA: 08-drvrstruct93|interrupt:associating to a driver --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The VECTOR statement establishes the interrupt level and the associated driver for devices on the EISA and VME busses.<INDEXTARGET ID="08-drvrstruct94"><!-- POSTPROCESSDATA: 08-drvrstruct94|VECTOR statement --></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>For some VME devices, the interrupt level is set dynamically using <FUNCTION>vme_ivec_set()</FUNCTION> (see <XREF IDREF="13012" TYPE="TITLE">Chapter&nbsp;13, &ldquo;Services for VME Drivers on Origin2000/Onyx2&rdquo;</XREF>).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>For devices on the SCSI bus, all interrupts are handled by a single, low-level driver which notifies a callback function (see <XREF IDREF="33977" TYPE="TITLE">Chapter&nbsp;16, &ldquo;SCSI Device Drivers&rdquo;</XREF>).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>For devices on the PCI bus, the driver registers an interrupt handler using <FUNCTION>pci_intr_connect()</FUNCTION> at the time the device is attached (<XREF IDREF="70224" TYPE="TITLE">&ldquo;Interrupt Signal Distribution&rdquo;</XREF>).</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>In all cases, the driver specifies the interrupt handler as the address of a function to be called, with an argument to be passed to the function when it is called. This argument value is typically the address of a data structure in which the driver has stored information about the device. Alternatively, it could be the dev_t that names the device&mdash;from which the interrupt handler can get device information, see <XREF IDREF="61268" TYPE="TITLE">&ldquo;Allocating Storage for Device Information&rdquo;</XREF>.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="95841">Interrupt Handler Operation</TITLE><PARAGRAPH>In general, the interrupt handler implements the following tasks.</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>When the driver supports multiple logical units, use its argument value to locate the data structure for the interrupting unit.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Determine the reason for the interrupt by interrogating the device. This is typically done with PIO loads and stores of device registers.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>When the interrupt is a response to an I/O operation, note the success or failure of the operation.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>When the driver top half is waiting for the interrupt, waken it.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>If the driver supports polling, and the interrupt represents a pollable event, call <FUNCTION>pollwakeup()</FUNCTION>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>If the device is not in an error state and another operation is waiting to be started, start it.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The details of each of these tasks depends on the hardware and on the design of the data structures used by the driver top half. In general, you should design an interrupt handler so that it does the least possible and exits as quickly as possible.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="43724">Completing Block I/O</TITLE><PARAGRAPH>In a block device driver, an I/O operation is represented by the <INDEXTARGET ID="08-drvrstruct95"><!-- POSTPROCESSDATA: 08-drvrstruct95|entry points:strategy:and interrupts --><INDEXTARGET ID="08-drvrstruct96"><!-- POSTPROCESSDATA: 08-drvrstruct96|interrupt:and strategy entry point --><VARIABLE>buf_t</VARIABLE> structure. The <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> routine starts operations and waits for them to complete (see <XREF IDREF="66319" TYPE="TITLE">&ldquo;Entry Point strategy()&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>The interrupt entry point sets the residual count in <INDEXTARGET ID="08-drvrstruct97"><!-- POSTPROCESSDATA: 08-drvrstruct97|kernel functions:<FUNCTION>biodone()</FUNCTION> --><INDEXTARGET ID="08-drvrstruct98"><!-- POSTPROCESSDATA: 08-drvrstruct98|kernel functions:<FUNCTION>bioerror()</FUNCTION> --><INDEXTARGET ID="08-drvrstruct99"><!-- POSTPROCESSDATA: 08-drvrstruct99|data types:<VARIABLE>buf_t</VARIABLE>:interrupt handling --><VARIABLE>b_resid</VARIABLE>. It can post an error using <FUNCTION>bioerror()</FUNCTION>. It posts the operation complete and wakens the <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> routine by calling <FUNCTION>biodone()</FUNCTION>. If the <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> entry has set the address of a completion callback function in the <VARIABLE>b_iodone</VARIABLE> field of the <VARIABLE>buf_t</VARIABLE>, <FUNCTION>biodone()</FUNCTION> invokes it. (For more discussion, see <XREF IDREF="78884" TYPE="TITLE">&ldquo;Waiting for Block I/O to Complete&rdquo;</XREF>.)</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Completing Character I/O</TITLE><PARAGRAPH>In a character device driver, the driver top half typically awaits an interrupt by sleeping on a semaphore or synchronizing variable, and the interrupt routine posts the semaphore (see <XREF IDREF="59737" TYPE="TITLE">&ldquo;Waiting for a General Event&rdquo;</XREF>). Error information must be passed in driver variables according to some local convention.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="26077">Calling pollwakeup()</TITLE><PARAGRAPH>When the interrupt represents an event that can be reported by the driver's <INDEXTARGET ID="08-drvrstruct100"><!-- POSTPROCESSDATA: 08-drvrstruct100|kernel functions:<FUNCTION>pollwakeup()</FUNCTION> --><INDEXTARGET ID="08-drvrstruct101"><!-- POSTPROCESSDATA: 08-drvrstruct101|entry points:poll:and interrupts --><VARIABLE>pfx</VARIABLE><FUNCTION>poll()</FUNCTION> entry point (see <XREF IDREF="19826" TYPE="TITLE">&ldquo;Entry Point poll()&rdquo;</XREF>), the interrupt handler must report the event to the kernel, in case some user process is waiting in a <FUNCTION>poll()</FUNCTION> call. Hypothetical code to do this is shown in <XREF IDREF="65436" TYPE="TEXT">Example&nbsp;7-6</XREF>.</PARAGRAPH>
<CODE><CAPTION LBL="7-6"><PREFIX>Example 7-6 </PREFIX><XREFTARGET ID="65436">Hypothetical Call to pollwakeup()</CAPTION>hypo_intr(int ivec)
{
&nbsp;&nbsp;&nbsp;struct hypo_dev_info *pinfo;
&nbsp;&nbsp;&nbsp;if (! pinfo = find_dev_info(ivec))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return; /* not our device */
&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;if (pinfo->have_data_flag)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pollwakeup (pinfo->phead, POLLIN, POLLRDNORM);
&nbsp;&nbsp;&nbsp;if (pinfo->output_ok_flag)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pollwakeup (pinfo->phead, POLLOUT);
&nbsp;&nbsp;&nbsp;...
</CODE>
<NOTE><PREFIX>Note</PREFIX>It's important that the call to <FUNCTION>pollwakeup</FUNCTION>() occurs <ITALICS>after</ITALICS> any state has been updated by the event interrupt routine.</NOTE>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="26467">Interrupts as Threads</TITLE><PARAGRAPH>In traditional UNIX design, and in versions of IRIX preceding IRIX       6.4, an interrupt is handled as an asynchronous trap. The hardware trap handler calls the driver's interrupt function as a subroutine. In these systems, when the interrupt handler code is entered the system is in an unknown state. As a result, the interrupt handler can use only a restricted set of kernel services, and no services that can sleep.<INDEXTARGET ID="08-drvrstruct102"><!-- POSTPROCESSDATA: 08-drvrstruct102|thread:interrupt runs on --><INDEXTARGET ID="08-drvrstruct103"><!-- POSTPROCESSDATA: 08-drvrstruct103|interrupt:handler runs as thread --></PARAGRAPH>
<PARAGRAPH>Starting with IRIX       6.4, the IRIX kernel does all its work under control of lightweight executable entities called &ldquo;kernel threads.&rdquo; When a device driver registers an interrupt handler, the kernel allocates a thread to execute that handler. The thread begins execution by waiting on an internal semaphore.</PARAGRAPH>
<PARAGRAPH>When a hardware interrupt occurs, the trap code merely posts the semaphore on which the handler's thread is waiting. Soon thereafter, the interrupt thread is scheduled to execute, and it calls the function registered by the driver.</PARAGRAPH>
<PARAGRAPH>The differences from previous releases are small. It is still true that the interrupt handler code is entered unpredictably, at a high priority; does little; and exits quickly. However, there are the following differences compared to earlier systems:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The interrupt handler can be preempted by kernel threads running at higher priorities.</PARAGRAPH>
<PARAGRAPH>Previously, an interrupt handler in a uniprocessor system could only be preempted by an interrupt from a device with higher hardware priority. In IRIX 6.4, the handler can be preempted by kernel threads running daemons and high-priority real-time tasks, in addition to other interrupt threads.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>There are no restrictions on the kernel services an interrupt handler may call.</PARAGRAPH>
<PARAGRAPH>In particular, the interrupt handler is permitted to call services that could sleep. However, this is still typically not a good idea. For example, an interrupt handler should almost never allocate memory. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Mutual exclusion between the interrupt handler the driver top half can be done with mutex locks, instead of requiring the use of spinlocks.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The handler can do more work, and more elaborate work, if that leads to a better design for the driver.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>In IRIX 6.4, the driver writer has no control over the selection of interrupt thread priority. The kernel assigns a high relative priority to threads that execute interrupt handlers. However, higher priorities exist, and an interrupt thread can be preempted.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Mutual Exclusion</TITLE><PARAGRAPH>In historical UNIX systems, which were uniprocessor systems, when the only CPU is executing the interrupt handler, nothing else is executing. The hardware architecture ensured that top-half code could not preempt the interrupt handler; and the top half could use functions such as <INDEXTARGET ID="08-drvrstruct104"><!-- POSTPROCESSDATA: 08-drvrstruct104|interrupt:mutual exclusion with --><INDEXTARGET ID="08-drvrstruct105"><!-- POSTPROCESSDATA: 08-drvrstruct105|interrupt:on multiprocessor --><INDEXTARGET ID="08-drvrstruct106"><!-- POSTPROCESSDATA: 08-drvrstruct106|multiprocessor:interrupt handling on --><FUNCTION>splhi()</FUNCTION> to block interrupts during critical sections (see <XREF IDREF="75168" TYPE="TITLE">&ldquo;Priority Level Functions&rdquo;</XREF>). An interrupt handler could only be preempted by an interrupt of higher priority&mdash;which would be an interrupt for a different driver, and so would have no conflicts with this driver over the use of data. </PARAGRAPH>
<PARAGRAPH>None of these comfortable assumptions are tenable any longer.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Hardware Exclusion Is Ineffective</TITLE><PARAGRAPH>In a multiprocessor, an interrupt can be taken on any CPU, while other CPUs continue to execute kernel or user code. This means that the top half code cannot block out interrupts using a function such as <FUNCTION>splhi()</FUNCTION>, because the interrupt could be taken on another CPU. Nor can the interrupt handler assume that it is safe; another CPU could be executing a top-half entry point to the same driver, for the same device, as an interrupt handler.</PARAGRAPH>
<PARAGRAPH>With the threaded kernel of IRIX 6.4, it is even possible for a process with an extremely high priority, in the same CPU (or in the only CPU of a uniprocessor), to enter the driver top half, preempting the thread that is executing the interrupt handler.<INDEXTARGET ID="08-drvrstruct107"><!-- POSTPROCESSDATA: 08-drvrstruct107|interrupt:preemption of --></PARAGRAPH>
<PARAGRAPH>It is theoretically possible in a threaded kernel for a device to interrupt; for the kernel thread to be scheduled and enter the interrupt handler; and for the device to interrupt again, resulting in multiple concurrent entries to the same interrupt handler. However, IRIX prevents this. The interrupt handler for a device is entered serially. If you register the same handler function for multiple devices, it can be entered concurrently when <ITALICS>different</ITALICS> devices present interrupts at the same time.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using Locking Between Top and Bottom Half</TITLE><PARAGRAPH>The only solution possible is that you must use a software lock of some kind to protect the data objects that can be accessed concurrently by top-half code and the interrupt handler. Before using that shared data, a function must acquire the lock. Options for the type of lock are discussed under <XREF IDREF="32791" TYPE="TITLE">&ldquo;Designing for Multiprocessor Use&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Interrupt Performance and Latency</TITLE><PARAGRAPH>Another interrupt cannot be handled from the same device until the interrupt handler function returns. The interrupt thread runs at very nearly the highest priority, so all but the most essential work is suspended in the interrupted CPU until the handler returns.<INDEXTARGET ID="08-drvrstruct108"><!-- POSTPROCESSDATA: 08-drvrstruct108|interrupt:latency --></PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="62463">Support Entry Points</TITLE><PARAGRAPH>Certain driver entry points are used to support the operations of the kernel or the administration of the system.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="39118">Entry Point unreg()</TITLE><PARAGRAPH>The <INDEXTARGET ID="08-drvrstruct109"><!-- POSTPROCESSDATA: 08-drvrstruct109|entry points:unreg --><VARIABLE>pfx</VARIABLE><FUNCTION>unreg()</FUNCTION> entry point is called in a loadable driver, prior to the call to the <VARIABLE>pfx</VARIABLE><FUNCTION>unload()</FUNCTION> entry point. This entry point is used by drivers that support the <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> entry point (see <XREF IDREF="85243" TYPE="TITLE">&ldquo;Attach and Detach Entry Points&rdquo;</XREF>). Such drivers have to register with the kernel as supporting devices of certain types. Before unloading, a driver needs to retract this registration, so the kernel will not call the driver to attach another device.</PARAGRAPH>
<PARAGRAPH>If <VARIABLE>pfx</VARIABLE><FUNCTION>unreg()</FUNCTION> returns a nonzero error code, the driver is not unloaded.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="57773">Entry Point unload()</TITLE><PARAGRAPH>The <INDEXTARGET ID="08-drvrstruct110"><!-- POSTPROCESSDATA: 08-drvrstruct110|entry points:unload --><VARIABLE>pfx</VARIABLE><FUNCTION>unload()</FUNCTION> entry point is called when the kernel is about to dynamically remove a loadable driver from the running system. A driver can be unloaded either because all its devices are closed and a timeout has elapsed, or because the operator has used the <COMMAND>ml</COMMAND> command (see the <REFPAGE>ml(1)</REFPAGE> reference page). The kernel calls <VARIABLE>pfx</VARIABLE><FUNCTION>unload()</FUNCTION> only when no device special files managed by the driver are open. If any device had been opened, the <VARIABLE>pfx</VARIABLE><FUNCTION>close()</FUNCTION> entry has been called.</PARAGRAPH>
<PARAGRAPH>It is not easy to retain state information about the device over the time when the driver is not in memory. The entire text and data of a loadable driver, including static variables, are removed and reloaded. Global variables defined in the descriptive file (see <XREF IDREF="71839" TYPE="TITLE">&ldquo;Describing the Driver in /var/sysgen/master.d&rdquo;</XREF>) remain in memory after the driver is unloaded, as do any allocated memory addressed from a hwgraph vertex (see <XREF IDREF="53606" TYPE="TITLE">&ldquo;Attaching Information to Vertexes&rdquo;</XREF>). Be sure not to store any addresses of driver code or driver static variables in global variables or vertex structures, since the driver addresses will be different when the driver is reloaded.</PARAGRAPH>
<PARAGRAPH>Other than data addressed from the hwgraph, allocated dynamic memory should be released. The driver should also release any process handles (see <XREF IDREF="66916" TYPE="TITLE">&ldquo;Sending a Process Signal&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>The driver is not required to unload. If the driver should not be unloaded at this time, it returns a nonzero return code to the call, and the kernel does not unload it. There are several reasons why a driver should not be unloaded.</PARAGRAPH>
<PARAGRAPH>A driver should never permit unloading when there is any kind of pointer to the driver held in any kernel data structure. It is a frequent design error to unload when there is a live pointer to the driver. Unpredictable kernel panics often result.</PARAGRAPH>
<PARAGRAPH>One example of a live pointer to a driver is a pending callback function. Any pending <FUNCTION>itimeout()</FUNCTION> or <FUNCTION>bufcall()</FUNCTION> timers should be cancelled before returning 0 from <VARIABLE>pfx</VARIABLE><FUNCTION>unload()</FUNCTION>. Another example is a registered interrupt handler. The driver must disconnect any interrupt handler before unloading; or else refuse to unload. </PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="96840">Entry Point halt()</TITLE><PARAGRAPH>The kernel calls the <INDEXTARGET ID="08-drvrstruct111"><!-- POSTPROCESSDATA: 08-drvrstruct111|entry points:halt --><VARIABLE>pfx</VARIABLE><FUNCTION>halt()</FUNCTION> entry point, if one exists, while performing an orderly system shutdown (see the <REFPAGE>halt(1)</REFPAGE> reference page). No other driver entry points are called after this one. The prototype is simply</PARAGRAPH>
<EXAMPLE>
void <ITALICS>pfx</ITALICS>halt(void);
</EXAMPLE>
<PARAGRAPH>Since the system is shutting down, there is no point in returning allocated memory. The only purpose this entry point can serve is to leave the device in a safe and stable condition. For example, this is the place at which a disk driver could command the heads of the drive to move to a safe zone for power off.</PARAGRAPH>
<PARAGRAPH>The driver cannot assume that interrupts are disabled or enabled. The driver cannot block waiting for device actions, so whatever commands it issues to the device must take effect immediately.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="63295">Entry Point size()</TITLE><PARAGRAPH>The <INDEXTARGET ID="08-drvrstruct112"><!-- POSTPROCESSDATA: 08-drvrstruct112|entry points:size --><VARIABLE>pfx</VARIABLE><FUNCTION>size()</FUNCTION> entry point is required of block device drivers. It reports the size of the device in &ldquo;sector&rdquo; units, where a &ldquo;sector&rdquo; size is declared as NBPSCTR in <FILENAME>sys/param.h</FILENAME> (currently 512). The prototype is</PARAGRAPH>
<EXAMPLE>
int <ITALICS>pfx</ITALICS>size(dev_t <ITALICS>dev</ITALICS>);
</EXAMPLE>
<PARAGRAPH>The device major and minor numbers can be extracted from the dev argument. The entry point is not called until <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> has been called. Typically the driver will calculate the size of the medium during <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION>.</PARAGRAPH>
<PARAGRAPH>Since the <VARIABLE>int</VARIABLE> return value is 32 bits in all systems, the largest possible block device is 1,024 gigabytes ((2<SUPERSCRIPT>31</SUPERSCRIPT>*512)/1,024<SUPERSCRIPT>3</SUPERSCRIPT>).</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="94783">Entry Point print()</TITLE><PARAGRAPH>The <INDEXTARGET ID="08-drvrstruct113"><!-- POSTPROCESSDATA: 08-drvrstruct113|entry points:print --><VARIABLE>pfx</VARIABLE><FUNCTION>print()</FUNCTION> entry point is called from the kernel to display a diagnostic message when an error is detected on a block device. The prototype and the complete logic of the entry point is shown in <XREF IDREF="82745" TYPE="TEXT">Example&nbsp;7-7</XREF>.</PARAGRAPH>
<CODE><CAPTION LBL="7-7"><PREFIX>Example 7-7 </PREFIX><XREFTARGET ID="82745">Entry Point pfxprint()</CAPTION>#include &lt;sys/cmn_err.h>
#include &lt;sys/ddi.h>
int hypo_print(dev_t dev, char *str)
{
&nbsp;&nbsp;&nbsp;cmn_err(CE_NOTE,"Error on dev %d: %s\n",geteminor(dev),str);
&nbsp;&nbsp;&nbsp;return 0;
}
</CODE>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="87735">Handling 32-Bit and 64-Bit Execution Models</TITLE><PARAGRAPH>The <INDEXTARGET ID="08-drvrstruct114"><!-- POSTPROCESSDATA: 08-drvrstruct114|entry points:ioctl --><INDEXTARGET ID="08-drvrstruct115"><!-- POSTPROCESSDATA: 08-drvrstruct115|execution model --><VARIABLE>pfx</VARIABLE><FUNCTION>ioctl()</FUNCTION> entry point can be passed a data structure from the user process address space; that is, the <VARIABLE>arg</VARIABLE> value can be a pointer to a structure or an array of data. In order to interpret such a structure, the driver has to know the execution model for which the user process was compiled.</PARAGRAPH>
<PARAGRAPH>The execution model is specified when code is compiled. The 32-bit model (compiler option -32 or -n32) uses 32-bit address values and a <VARIABLE>long int</VARIABLE> contains 32 bits. The 64-bit model (compiler option -64) uses 64-bit address values and a <VARIABLE>long int</VARIABLE> contains 64 bits. (The size of an unqualified <VARIABLE>int</VARIABLE> is 32 bits in both models.) The execution model is sometimes casually called the &ldquo;ABI&rdquo; (Authorized Binary Interface), but this is an improper use of that term&mdash;an ABI comprises calling conventions, public names, and structure definitions, as well as the execution model.<INDEXTARGET ID="08-drvrstruct116"><!-- POSTPROCESSDATA: 08-drvrstruct116|authorized binary interface (ABI) --></PARAGRAPH>
<PARAGRAPH>An IRIX kernel compiled to the 32-bit model contains 32-bit drivers and supports only 32-bit user processes. A kernel compiled to the 64-bit model contains 64-bit drivers, but it supports user processes compiled to <INDEXTARGET ID="08-drvrstruct117"><!-- POSTPROCESSDATA: 08-drvrstruct117|kernel execution model --><ITALICS>either</ITALICS> 32-bit or 64-bit models. Therefore, in a 64-bit kernel, a driver can be asked to interpret data produced by a 32-bit program.</PARAGRAPH>
<PARAGRAPH>This is true only of the <VARIABLE>pfx</VARIABLE><FUNCTION>ioctl()</FUNCTION> entry point. Other driver entry points move data to and from user space as streams or blocks of bytes&mdash;not as a structure with fields to be interpreted.</PARAGRAPH>
<PARAGRAPH>Since in other respects it is easy to make your driver portable between 64-bit and 32-bit systems, you should design your driver so that it can handle the case of operating in a 64-bit kernel, receiving <FUNCTION>ioctl()</FUNCTION> requests alternately from 32-bit and 64-bit programs.</PARAGRAPH>
<PARAGRAPH>The simplest way to do this is to define the arguments passed to the entry points in such a way that they have the same precision in either system. However, this is not always possible. To handle the general case, the driver must know to which model the user process was compiled.</PARAGRAPH>
<PARAGRAPH>In any top-half entry point (where there is a user process context), you find this out by calling the <INDEXTARGET ID="08-drvrstruct118"><!-- POSTPROCESSDATA: 08-drvrstruct118|kernel functions:<FUNCTION>userabi()</FUNCTION> --><FUNCTION>userabi()</FUNCTION> function (for which there is no reference page available). The prototype of <FUNCTION>userabi()</FUNCTION> (declared in <FILENAME>sys/ddi.h</FILENAME>) is</PARAGRAPH>
<EXAMPLE>
int userabi(__userabi_t *);
</EXAMPLE>
<PARAGRAPH>If there is no user process context, <INDEXTARGET ID="08-drvrstruct119"><!-- POSTPROCESSDATA: 08-drvrstruct119|data types:<VARIABLE>__userabi_t</VARIABLE>data types:userabi --><FUNCTION>userabi()</FUNCTION> returns ESRCH. Otherwise it fills out a <VARIABLE>__userabi_t</VARIABLE> structure and returns 0. The structure of type <VARIABLE>__userabi_t</VARIABLE> (declared in <FILENAME>sys/types.h</FILENAME>) contains the fields listed below:</PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><VARIABLE>uabi_szint</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Size of a user int (4). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><VARIABLE>uabi_szlong</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Size of a user long (4 or 8). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><VARIABLE>uabi_szptr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Size of a user address (4 or 8). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><VARIABLE>uabi_szlonglong</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Size of a user long long (8). </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Store the value of <VARIABLE>uabi_szptr</VARIABLE> when opening a device. Then you can use it to choose between 32-bit and 64-bit declarations of a structure passed to <VARIABLE>pfx</VARIABLE><FUNCTION>ioctl()</FUNCTION> or an address passed to <VARIABLE>pfx</VARIABLE><FUNCTION>poll()</FUNCTION>.</PARAGRAPH>
<PARAGRAPH>In any part of the driver, including interrupt threads, you can get the current ABI by calling the kernel function <INDEXTARGET ID="08-drvrstruct120"><!-- POSTPROCESSDATA: 08-drvrstruct120|kernel functions:<FUNCTION>get_current_abi()</FUNCTION> --><FUNCTION>get_current_abi()</FUNCTION>. It takes no argument. It returns an unsigned character value that can be decoded using macros and constants that are declared in the header file <FILENAME>sys/kabi.h</FILENAME>.</PARAGRAPH>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="32791">Designing for Multiprocessor Use</TITLE><PARAGRAPH>Multiprocessor computers are central to the Silicon Graphics product line and are becoming increasingly common. A device driver that is not multiprocessor-ready can be used in a multiprocessor, but it is likely to cause a performance bottleneck. By contrast, a multiprocessor-ready driver works well in a uniprocessor with no cost in performance.<INDEXTARGET ID="08-drvrstruct121"><!-- POSTPROCESSDATA: 08-drvrstruct121|multiprocessor:driver design for --></PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>The Multiprocessor Environment</TITLE><PARAGRAPH>A multiprocessor has two or more CPU modules, all of the same type. The CPUs execute independently, but all share the same main memory. Any CPU can execute the code of the IRIX kernel, and it is common for two or more CPUs to be executing kernel code, including driver code, simultaneously.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Uniprocessor Assumptions</TITLE><PARAGRAPH>Traditional UNIX architecture assumes a uniprocessor hardware environment with a hierarchy of interrupt levels. Ordinary code could be preempted by an interrupt, but an interrupt handler could only be preempted by an interrupt at a higher level.<INDEXTARGET ID="08-drvrstruct122"><!-- POSTPROCESSDATA: 08-drvrstruct122|multiprocessor:uniprocessor assumptions invalid --></PARAGRAPH>
<PARAGRAPH>This assumed hardware environment was reflected in the design of device drivers and kernel support functions.</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>In a uniprocessor, an upper-half driver entry point such as <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> cannot be preempted except by an interrupt. It has exclusive access to driver variables except for those changed by the interrupt handler.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Once in an interrupt handler, no other code can possibly execute except an interrupt of a higher hardware level. The interrupt handler has exclusive access to driver variables.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The interrupt handler can use kernel functions such as <FUNCTION>splhi()</FUNCTION> to set the hardware interrupt mask, blocking interrupts of all kinds, and thus getting exclusive access to all memory including kernel data structures.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>All of these assumptions fail in a multiprocessor.</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Upper-half entry points can be entered concurrently on multiple CPUs. For example, one CPU can be executing <INDEXTARGET ID="08-drvrstruct123"><!-- POSTPROCESSDATA: 08-drvrstruct123|upper half of of driver --><INDEXTARGET ID="08-drvrstruct124"><!-- POSTPROCESSDATA: 08-drvrstruct124|driver:upper half:in multiprocessor --><VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> while another CPU is in <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION>. Exclusive use of driver variables cannot be assumed.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>An interrupt can be taken on one CPU while upper-half routines or a timeout function execute concurrently on other CPUs. The interrupt routine cannot assume exclusive use of driver variables.<INDEXTARGET ID="08-drvrstruct125"><!-- POSTPROCESSDATA: 08-drvrstruct125|interrupt:concurrent with processing --></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Interrupt-level functions such as <INDEXTARGET ID="08-drvrstruct126"><!-- POSTPROCESSDATA: 08-drvrstruct126|multiprocessor:<FUNCTION>splhi()</FUNCTION> useless in --><INDEXTARGET ID="08-drvrstruct127"><!-- POSTPROCESSDATA: 08-drvrstruct127|kernel functions:<FUNCTION>splhi()</FUNCTION>:meaningless --><FUNCTION>splhi()</FUNCTION> are meaningless, since at best they set the interrupt mask on the current CPU only. Other CPUs can accept interrupts at all levels. The interrupt handler can never gain exclusive access to kernel data.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The process of making a driver multiprocessor-ready consists of changing all code whose correctness depends on uniprocessor assumptions. </PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Protecting Common Data</TITLE><PARAGRAPH>Whenever a common resource can be updated by two processes concurrently, the resource must be protected by a <INDEXTARGET ID="08-drvrstruct128"><!-- POSTPROCESSDATA: 08-drvrstruct128|mutual exclusion:in multiprocessor drivers --><GLOSSARYITEM>lock</GLOSSARYITEM> that represents the exclusive right to update the resource. Before changing the resource, the software acquires the lock, claiming exclusive access. After changing the resource, the software releases the lock.</PARAGRAPH>
<PARAGRAPH>The IRIX kernel provides a set of functions for creating and using locks. It provides another set of functions for creating and using <GLOSSARYITEM>semaphore</GLOSSARYITEM> objects, which are like locks but sometimes more flexible. Both sets of functions are discussed under <XREF IDREF="14643" TYPE="TITLE">&ldquo;Waiting and Mutual Exclusion&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Sleeping and Waking</TITLE><PARAGRAPH>Sometimes the lock is not available&mdash;some other process executing in another CPU has acquired the lock. When this happens, the requesting process is delayed in the lock function until the lock is free. To delay, or <GLOSSARYITEM>sleep</GLOSSARYITEM>, is allowed for upper-half entry points, because they execute (in effect) as subroutines of user processes.</PARAGRAPH>
<PARAGRAPH>Interrupt handlers and timeout functions are not permitted to sleep. They have no process identity and so there is no mechanism for saving and restoring their state. An interrupt handler can test a lock, and can claim the lock conditionally, but if a lock is already held, the handler must have some alternate way of storing data.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Synchronizing Within Upper-Half Functions</TITLE><PARAGRAPH>When designing an upper-half entry point, keep in mind that it could be executed concurrently with any other upper-half entry point, and that the one entry point could even be executed concurrently by multiple CPUs. Only a few entry points are immune:<INDEXTARGET ID="08-drvrstruct129"><!-- POSTPROCESSDATA: 08-drvrstruct129|multiprocessor:synchronizing upper-half code --><INDEXTARGET ID="08-drvrstruct130"><!-- POSTPROCESSDATA: 08-drvrstruct130|upper half of of driver --><INDEXTARGET ID="08-drvrstruct131"><!-- POSTPROCESSDATA: 08-drvrstruct131|driver:upper half:in multiprocessor --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>init()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>edtinit()</FUNCTION>, and <VARIABLE>pfx</VARIABLE><FUNCTION>start()</FUNCTION> entry points cannot be entered concurrently with each other or any other entry point (<VARIABLE>pfx</VARIABLE><FUNCTION>start()</FUNCTION> could be entered concurrently with the interrupt handler).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>unload()</FUNCTION> and <VARIABLE>pfx</VARIABLE><FUNCTION>halt()</FUNCTION> entry points cannot be entered concurrently with any other entry point except for stray interrupts.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Certain entry points have no cause to use shared data; for example, <VARIABLE>pfx</VARIABLE><FUNCTION>size()</FUNCTION> and <VARIABLE>pfx</VARIABLE><FUNCTION>print()</FUNCTION> normally do not need to take any precautions.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Other upper-half entry points, and all STREAMS entry points, can be entered concurrently by multiple CPUs, when the driver is multiprocessor-aware. In earlier versions of IRIX, you could place a flag in the <VARIABLE>pfx</VARIABLE><FUNCTION>devflag</FUNCTION> of a character driver that made the kernel run the driver only on CPU 0. This effectively serialized all use of that driver. That feature is no longer supported. You must deal with concurrency.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Serializing on a Single Lock</TITLE><PARAGRAPH>You can create a single lock for upper-half serialization. Each upper-half function begins with read-only operations such as extracting the device minor number, getting device information from the hwgraph vertex, and testing and validating arguments. You allow these to execute concurrently on any CPU.</PARAGRAPH>
<PARAGRAPH>In each entry point, when the preliminaries are complete, you acquire the single lock, and release it just before returning. The result is that processes are serialized for I/O through the driver. If the driver supports only a single device, processes would be serialized in any case, waiting for the device to operate. Since the upper half can execute on any CPU, latency is more predictable.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Serializing on a Lock Per Device</TITLE><PARAGRAPH>When the driver supports multiple minor devices, you will normally have a data structure per device. An upper-half routine is concerned only with one device. You can define a lock in the data structure for each device instance, and acquire that lock as soon as the device information structure is known.</PARAGRAPH>
<PARAGRAPH>This method permits concurrent execution of upper-half requests for different minor devices, but it serializes access to any one device.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Coordinating Upper-Half and Interrupt Entry Points</TITLE><PARAGRAPH>Upper-half entry points prepare work for the device to do, and the interrupt handler reports the completion of the device action (see <XREF IDREF="95841" TYPE="TITLE">&ldquo;Interrupt Handler Operation&rdquo;</XREF>). In a block device driver, this communication is relatively simple. In a character driver, you have more design options. The kernel functions mentioned in the following topics are covered under <XREF IDREF="51251" TYPE="TITLE">&ldquo;Waiting and Mutual Exclusion&rdquo;</XREF>.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Coordinating Through the buf_t</TITLE><PARAGRAPH>In a block device driver, the <INDEXTARGET ID="08-drvrstruct132"><!-- POSTPROCESSDATA: 08-drvrstruct132|data types:<VARIABLE>buf_t</VARIABLE>:for syncronization --><VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> routine initiates a read or a write based on a <VARIABLE>buf_t</VARIABLE> structure (see <XREF IDREF="66319" TYPE="TITLE">&ldquo;Entry Point strategy()&rdquo;</XREF>), and leaves the address of the <VARIABLE>buf_t</VARIABLE> where the interrupt routine can find it. Then <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> calls the <FUNCTION>biowait()</FUNCTION> kernel function to wait for completion.</PARAGRAPH>
<PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>intr()</FUNCTION> entry point updates the <VARIABLE>buf_t</VARIABLE> (using <VARIABLE>pfx</VARIABLE><FUNCTION>bioerror()</FUNCTION> if necessary) and then uses <FUNCTION>biodone()</FUNCTION> to mark the <VARIABLE>buf_t</VARIABLE> as complete. This ends the wait for <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Coordination in a Character Driver</TITLE><PARAGRAPH>In a character driver that supports interrupts, you design your own coordination mechanism. The simplest (and not recommended) would be based on using the kernel function <FUNCTION>sleep()</FUNCTION> in the upper half, and <FUNCTION>wakeup()</FUNCTION> in the interrupt routine. It is better to use a semaphore and use <FUNCTION>psema()</FUNCTION> in the upper half and <FUNCTION>vsema()</FUNCTION> in the interrupt handler.</PARAGRAPH>
<PARAGRAPH>If you need to allow for timeouts in addition to interrupts, you have to deal with the complication that the timeout function can be called concurrently with an interrupt. In this case it is better to use synchronization variables (see <XREF IDREF="41132" TYPE="TITLE">&ldquo;Using Synchronization Variables&rdquo;</XREF>).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Choice of Lock Type</TITLE><PARAGRAPH>In versions before IRIX       6.4, interrupt handlers must not use kernel services that can sleep. This prevented you from using normal locks to provide mutual exclusion between the upper half and the interrupt handler. The lock had to be a basic lock (see <XREF IDREF="59834" TYPE="TITLE">&ldquo;Basic Locks&rdquo;</XREF>), a type that is implemented as a spinning lock in a multiprocessor.</PARAGRAPH>
<PARAGRAPH>Now that interrupt handlers execute as kernel threads, they have the ability to sleep if necessary. This means that you can now use mutex locks (see <XREF IDREF="29043" TYPE="TITLE">&ldquo;Using Mutex Locks&rdquo;</XREF>) between the upper half and interrupt handler. Although you do not want an interrupt handler to be delayed, it is much better for a kernel thread to sleep briefly while waiting for a lock, than for it to spin in a tight loop. In general, mutex locks are more efficient than spinning locks.</PARAGRAPH>
<PARAGRAPH>In the event you must maintain a multiprocessor driver that operates in both IRIX 6.4 and an earlier, nonthreaded version, you can make the choice of lock type dynamically using conditional compilation. <XREF IDREF="71183" TYPE="TEXT">Example&nbsp;7-8</XREF> shows one technique.</PARAGRAPH>
<CODE><CAPTION LBL="7-8"><PREFIX>Example 7-8 </PREFIX><XREFTARGET ID="71183">Conditional Choice of Mutual Exclusion Lock Type</CAPTION>#ifdef INTR_KTHREADS
#define INT_LOCK_TYPE mutex_t
#define INT_LOCK_INIT(p) MUTEX_INIT(p,MUTEX_DEFAULT,&rdquo;DRIVER_NAME&rdquo;)
#define INT_LOCK_LOCK(p) MUTEX_LOCK(p,-1)
#define INT_LOCK_FREE(p) MUTEX_UNLOCK(p)
#else /* not a threaded kernel */
#define INT_LOCK_TYPE struct{lock_t lk, int cookie}
#define INT_LOCK_INIT(p) LOCK_INIT(&amp;p->lk,(uchar_t)-1,plhi,(lkinfo_t)-1)
#define INT_LOCK_LOCK(p) (p->cookie=LOCK(&amp;p->lk,plhi))
#define INT_LOCK_FREE(p) UNLOCK(&amp;p->lk,p->cookie)
#endif
</CODE>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Converting a Uniprocessor Driver</TITLE><PARAGRAPH>As a general approach, you can convert a uniprocessor driver to make it multiprocessor-safe in the following steps:<INDEXTARGET ID="08-drvrstruct133"><!-- POSTPROCESSDATA: 08-drvrstruct133|multiprocessor:converting to --><INDEXTARGET ID="08-drvrstruct134"><!-- POSTPROCESSDATA: 08-drvrstruct134|uniprocessor:converting driver --></PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>If it currently uses the D_OLD flag, or has no <VARIABLE>pfx</VARIABLE><FUNCTION>devflag</FUNCTION> constant, convert it to use the current interface, with a <VARIABLE>pfx</VARIABLE><FUNCTION>devflag</FUNCTION> of D_MP.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Make sure it works in the original uniprocessor at the current release of IRIX.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Begin adding semaphores, locks, and other exclusion and synchronization tools. Continue to test the driver on the uniprocessor. It will never wait for a lock, but the coordination between upper half and interrupt handler should work.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Test on a multiprocessor.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>In performing the conversion, you can look for calls to <FUNCTION>spl</FUNCTION>*<FUNCTION>()</FUNCTION> functions as marking points at which work is needed. These functions are used for mutual exclusion in a uniprocessor, but they are all ineffective or unnecessary in a multiprocessor-safe driver.</PARAGRAPH>
<PARAGRAPH>The code in <XREF IDREF="76629" TYPE="TEXT">Example&nbsp;7-9</XREF> shows typical logic in a uniprocessor character driver.</PARAGRAPH>
<CODE><CAPTION LBL="7-9"><PREFIX>Example 7-9 </PREFIX><XREFTARGET ID="76629">Uniprocessor Upper-Half Wait Logic</CAPTION>s = splvme();
flag |= WAITING;
while (flag &amp; WAITING) {
&nbsp;&nbsp;&nbsp;sleep(&amp;flag, PZERO);
}
splx(s);
</CODE>
<PARAGRAPH>The upper half calls the <INDEXTARGET ID="08-drvrstruct135"><!-- POSTPROCESSDATA: 08-drvrstruct135|kernel functions:<FUNCTION>splvme()</FUNCTION>:useless --><FUNCTION>splvme()</FUNCTION> function with the intention of blocking interrupts, and thus preventing execution of this driver's interrupt handler while the <VARIABLE>flag</VARIABLE> variable is updated. In a multiprocessor this is ineffective because at best it sets the interrupt level on the current CPU. The interrupt handler can execute on another CPU and change the variable. The corresponding interrupt handler is shown in the following example.</PARAGRAPH>
<CODE>
if (flag &amp; WAITING) {
&nbsp;&nbsp;&nbsp;wakeup(&amp;flag);
&nbsp;&nbsp;&nbsp;flag &amp;= ~WAITING;
}
</CODE>
<PARAGRAPH>The interrupt handler could execute on another CPU, and test the flag after the upper half has called <FUNCTION>splvme()</FUNCTION> and before it has set WAITING in <VARIABLE>flag</VARIABLE>. The interrupt is effectively lost. This would happen rarely and would be hard to repeat, but it would happen and would be hard to trace. A more reliable, and simpler, technique is to use a semaphore. The driver defines a global semaphore:</PARAGRAPH>
<EXAMPLE>
static sema_t sleeper;
</EXAMPLE>
<PARAGRAPH>A driver with multiple devices would have a semaphore per device, perhaps as an array of <VARIABLE>sema_t</VARIABLE> items indexed by device minor number. The semaphore (or array) would be initialized to a starting value of 1 in the <INDEXTARGET ID="08-drvrstruct136"><!-- POSTPROCESSDATA: 08-drvrstruct136|kernel functions:<FUNCTION>initnsema()</FUNCTION> --><VARIABLE>pfx</VARIABLE><FUNCTION>init()</FUNCTION> or <VARIABLE>pfx</VARIABLE><FUNCTION>start()</FUNCTION> entry:</PARAGRAPH>
<CODE>
void hypo_start()
{
...
&nbsp;&nbsp;&nbsp;initnsema(&amp;sleeper,1,"sleeper");
}
</CODE>
<PARAGRAPH>After the upper half started a device operation, it would await the interrupt using <INDEXTARGET ID="08-drvrstruct137"><!-- POSTPROCESSDATA: 08-drvrstruct137|kernel functions:<FUNCTION>psema()</FUNCTION> --><FUNCTION>psema()</FUNCTION>:</PARAGRAPH>
<EXAMPLE>
psema(sleeper,PZERO);
</EXAMPLE>
<PARAGRAPH>The PZERO argument makes the wait immune to signals. If the driver should wake up when a signal is sent to the calling process (such as SIGINT or SIGTERM), the second argument can be PCATCH. A return value of -1 indicates the semaphore was posted by a signal, not by a <INDEXTARGET ID="08-drvrstruct138"><!-- POSTPROCESSDATA: 08-drvrstruct138|kernel functions:<FUNCTION>vsema()</FUNCTION> --><FUNCTION>vsema()</FUNCTION> call. The interrupt handler would use <FUNCTION>vsema()</FUNCTION> to post the semaphore.</PARAGRAPH>
</SECTION2>
</SECTION1>
</CHAPTER>
