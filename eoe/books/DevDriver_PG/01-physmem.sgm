<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="1"><TITLE><XREFTARGET ID="24376">Physical and Virtual Memory</TITLE><PARAGRAPH>This chapter gives an overview of the management of physical and virtual memory in Silicon Graphics systems based on the MIPS R5000 and R10000 processors. The purpose is to give you the background to understand terms used in device driver header files and reference pages, and to understand the limitations and special conventions used by some kernel functions.&space;<INDEXTARGET ID="01-physmem1"><!-- POSTPROCESSDATA: 01-physmem1|memory --><INDEXTARGET ID="01-physmem2"><!-- POSTPROCESSDATA: 01-physmem2|addressing --></PARAGRAPH>
<PARAGRAPH>This information is only of academic interest if you intend to control a device from a user-level process. (See <XREF IDREF="62332" TYPE="TITLE">Chapter&nbsp;3, &ldquo;Device Control Software,&rdquo;</XREF> for the difference between user-level and kernel-level drivers.) For a deeper level of detail on Origin2000 memory hardware, see the hardware manuals listed under <XREF IDREF="49142" TYPE="TITLE">&ldquo;Additional Reading&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>The following main topics are covered in this chapter.</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="22357" TYPE="TITLE">&ldquo;CPU Access to Memory and Devices&rdquo;</XREF> summarizes the hardware architecture by which the CPU accesses memory.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="93894" TYPE="TITLE">&ldquo;The 32-Bit Address Space&rdquo;</XREF> describes the parts of the physical address space when 32-bit addressing is used.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="86234" TYPE="TITLE">&ldquo;The 64-Bit Address Space&rdquo;</XREF> describes the 64-bit physical address space.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="69605" TYPE="TITLE">&ldquo;Address Space Usage in Origin2000 Systems&rdquo;</XREF> gives an overview of how physical memory is addressed in the complex architecture of the Origin2000.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="22357">CPU Access to Memory and Devices</TITLE><PARAGRAPH>Each Silicon Graphics computer system has one or more CPU modules. A CPU reads data from memory or a device by placing an address on a system bus, and receiving data back from the addressed memory or device. An address can be translated more than once as it passes through multiple layers of bus adapters. Access to memory can pass through multiple levels of cache.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="38795">CPU Modules</TITLE><PARAGRAPH>A CPU is a hardware module containing a MIPS processor chip such as the R8000, together with system interface chips and possibly a secondary cache. Silicon Graphics CPU modules have model designation of the form IP<INDEXTARGET ID="01-physmem3"><!-- POSTPROCESSDATA: 01-physmem3|CPU --><VARIABLE>nn</VARIABLE>; for example, the IP22 module is used in the Indy workstation. The CPU modules supported by IRIX       6.4 are listed in <XREF IDREF="34124" TYPE="TABLE">Table&nbsp;1-1</XREF>.&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<INDEXTARGET ID="01-physmem4"><!-- POSTPROCESSDATA: 01-physmem4|processor:types --><INDEXTARGET ID="01-physmem5"><!-- POSTPROCESSDATA: 01-physmem5|CPU:processors in --><INDEXTARGET ID="01-physmem6"><!-- POSTPROCESSDATA: 01-physmem6|CPU:type numbers --></PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="1-1"><PREFIX>Table 1-1 </PREFIX><XREFTARGET ID="34124">CPU Modules and System Names</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Module</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>MIPS Processor</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="189"><PARAGRAPH>System Families</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>IP19</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>R4<VARIABLE>x</VARIABLE>00</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="189"><PARAGRAPH>CHALLENGE (other than S model), Onyx </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>IP20</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>R4<VARIABLE>x</VARIABLE>00</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="189"><PARAGRAPH>Indigo</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>IP21</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>R8000</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="189"><PARAGRAPH>POWER Challenge, POWER Onyx </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>IP22</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>R4<VARIABLE>x</VARIABLE>00</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="189"><PARAGRAPH>Indigo, Indy, Challenge S </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>IP25</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>R10000</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="189"><PARAGRAPH>POWER Challenge R10000</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>IP26</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>R8000</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="189"><PARAGRAPH>POWER Indigo</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>IP27</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>R10000</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="189"><PARAGRAPH>Origin2000</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>IP28</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>R10000</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="189"><PARAGRAPH>POWER Indigo<SUPERSCRIPT>2</SUPERSCRIPT> R10000 </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>IP30</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>R10000</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="189"><PARAGRAPH>OCTANE </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>IP32</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>R10000</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="189"><PARAGRAPH>O2</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Modules with the same IP designation can be built in a variety of clock speeds, and they can differ in other ways. (For example, an IP27 can have 0, 1 or 2 R10000 modules plugged into it.) Also, the choice of graphics hardware is independent of the CPU model. However, all these CPUs are basically identical as seen from software.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Interrogating the CPU Type</TITLE><PARAGRAPH>At the interactive command line, you can determine which CPU module a system uses with the following command:&space;<INDEXTARGET ID="01-physmem7"><!-- POSTPROCESSDATA: 01-physmem7|IRIX commands:<COMMAND>hinv</COMMAND>:for CPU type --></PARAGRAPH>
<EXAMPLE>
hinv -c processor
</EXAMPLE>
<PARAGRAPH>Within a shell script, it is more convenient to process the terse output of</PARAGRAPH>
<EXAMPLE>
uname -m
</EXAMPLE>
<PARAGRAPH>(See the <REFPAGE>uname(1)</REFPAGE> and <REFPAGE>hinv(1)</REFPAGE> reference pages.)<INDEXTARGET ID="01-physmem8"><!-- POSTPROCESSDATA: 01-physmem8|IRIX commands:<COMMAND>uname</COMMAND> --></PARAGRAPH>
<PARAGRAPH>Within a program, you can get the CPU model using the <FUNCTION>getinvent()</FUNCTION> function. For an example, see <XREF IDREF="78617" TYPE="TITLE">&ldquo;Testing the Inventory In Software&rdquo;</XREF>.&space;<INDEXTARGET ID="01-physmem9"><!-- POSTPROCESSDATA: 01-physmem9|kernel functions:<FUNCTION>getinvent()</FUNCTION> --></PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>CPU Access to Memory</TITLE><PARAGRAPH>The CPU generates the address of data that it needs&mdash;the address of an instruction to fetch, or the address of an operand of an instruction. It requests the data through a mechanism that is depicted in simplified form in <XREF IDREF="28485" TYPE="GRAPHIC">Figure&nbsp;1-1</XREF>.<INDEXTARGET ID="01-physmem10"><!-- POSTPROCESSDATA: 01-physmem10|CPU:memory access by --></PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="01-cpu.memory.access.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="1-1"><PREFIX>Figure 1-1 </PREFIX><XREFTARGET ID="28485">CPU Access to Memory</CAPTION>
</FIGURE>
</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>The address of the needed data is formed in the processor execution or instruction-fetch unit. Most addresses are then mapped from virtual to real through the Translation Lookaside Buffer (TLB). Certain ranges of addresses are not mapped, and bypass the TLB.&space;<INDEXTARGET ID="01-physmem11"><!-- POSTPROCESSDATA: 01-physmem11|virtual memory --><INDEXTARGET ID="01-physmem12"><!-- POSTPROCESSDATA: 01-physmem12|Translate Lookaside Buffer (TLB) --></PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Most addresses are presented to the <GLOSSARYITEM>primary cache</GLOSSARYITEM>, a cache in the processor chip. If a copy of the data with that address is found, it is returned immediately. Certain address ranges are never cached; these addresses pass directly to the bus.&space;<INDEXTARGET ID="01-physmem13"><!-- POSTPROCESSDATA: 01-physmem13|primary cachecache:primary --></PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>When the primary cache does not contain the data, the address is presented to the secondary cache. If it contains a copy of the data, the data is returned immediately. The size and the architecture of the secondary cache differ from one CPU model to another.&space;<INDEXTARGET ID="01-physmem14"><!-- POSTPROCESSDATA: 01-physmem14|secondary cachecache:secondary --></PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The address is placed on the system bus. The memory module that recognizes the address places the data on the bus.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>The process in <XREF IDREF="28485" TYPE="GRAPHIC">Figure&nbsp;1-1</XREF> is correct for an Origin2000 system when the addressed data is in the local node. When the address applies to memory in another node, the address passes out through the connection fabric to a memory module in another node, from which the data is returned.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Processor Operating Modes</TITLE><PARAGRAPH>The MIPS processor under IRIX operates in one of two modes: kernel and user. The processor enters the more privileged kernel mode when an interrupt, a system instruction, or an exception occurs. It returns to user mode only with a &ldquo;Return from Exception&rdquo; instruction.&space;<INDEXTARGET ID="01-physmem15"><!-- POSTPROCESSDATA: 01-physmem15|processor:kernel modeprocessor:user mode kernel mode of processor user mode of processor --></PARAGRAPH>
<PARAGRAPH>Certain instructions cannot be executed in user mode. Certain segments of memory can be accessed only in kernel mode, and other segments only in user mode.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="16985">Virtual Address Mapping</TITLE><PARAGRAPH>The MIPS processor contains an array of Translation Lookaside Buffer (TLB) entries that map, or translate, virtual addresses to physical ones. Most memory accesses are first mapped by reference to the TLB. This permits the IRIX kernel to relocate parts of the kernel's memory and to implement <INDEXTARGET ID="01-physmem16"><!-- POSTPROCESSDATA: 01-physmem16|Translation Lookaside Buffer (TLB) --><INDEXTARGET ID="01-physmem17"><!-- POSTPROCESSDATA: 01-physmem17|virtual memory --><GLOSSARYITEM>virtual memory</GLOSSARYITEM> for user processes. The translation scheme is summarized in the following sections and covered in detail in the hardware manuals listed under <XREF IDREF="49142" TYPE="TITLE">&ldquo;Additional Reading&rdquo;</XREF>.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>TLB Misses and TLB Sizes</TITLE><PARAGRAPH>Each TLB entry describes a segment of memory containing two adjacent <GLOSSARYITEM>page</GLOSSARYITEM><ITALICS>s</ITALICS>. When the input address falls in a page described by a TLB entry, the TLB supplies the physical memory address for that page. The translated address, now physical instead of virtual, is passed on to the cache, as shown in <XREF IDREF="28485" TYPE="GRAPHIC">Figure&nbsp;1-1</XREF>.</PARAGRAPH>
<PARAGRAPH>When the input address is not covered by any active TLB entry, the MIPS processor generates a &ldquo;TLB miss&rdquo; interrupt, which is handled by an IRIX kernel routine. The kernel routine inspects the address. When the address has a valid translation to some page in the address space, the kernel loads a TLB entry to describe that page, and restarts the instruction.</PARAGRAPH>
<PARAGRAPH>The size of the TLB is important for performance. The size of the TLB in different processors is shown in <XREF IDREF="38880" TYPE="TABLE">Table&nbsp;1-2</XREF>.&nbsp;&nbsp;&nbsp; <INDEXTARGET ID="01-physmem18"><!-- POSTPROCESSDATA: 01-physmem18|Translation Lookaside Buffer (TLB):number of entries in --></PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="1-2"><PREFIX>Table 1-2 </PREFIX><XREFTARGET ID="38880">Number of TLB Entries by Processor Type</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="134"><PARAGRAPH>Processor Type</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="134"><PARAGRAPH>Number of TBL Entries</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="134"><PARAGRAPH>R4x00 </PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="134"><PARAGRAPH>96</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="134"><PARAGRAPH>R5000</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="134"><PARAGRAPH>96</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="134"><PARAGRAPH>R8000</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="134"><PARAGRAPH>384</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="134"><PARAGRAPH>R10000</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="134"><PARAGRAPH>128</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Address Space Creation</TITLE><PARAGRAPH>There are not sufficient TLB entries to describe the entire address space of even a single process. The IRIX kernel creates a page table in kernel memory for each process. The page table contains one entry for each virtual memory page in the address space of that process. Whenever an executing program refers to an address for which there is no current TLB entry, the CPU traps to the TLB miss handler. The handler loads one TLB entry from the appropriate page table entry of the current process, in order to describe the needed virtual address. Then it resumes execution with the failed instruction.</PARAGRAPH>
<PARAGRAPH>In order to extend a virtual address space, the kernel takes the following two steps.</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>It allocates unused page table entries to describe the needed pages. This defines the virtual addresses the pages will have.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>It allocates page frames in memory to contain the pages themselves, and puts their physical addresses in the page table entries.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Address Exceptions</TITLE><PARAGRAPH>When the CPU requests an invalid address&mdash;because the processor is in the wrong mode, or an address does not translate to a valid location in the address space, or an address refers to hardware that does not exist in the system&mdash;an addressing exception occurs. The processor traps to a particular address in the kernel.<INDEXTARGET ID="01-physmem19"><!-- POSTPROCESSDATA: 01-physmem19|kernel panic:address exception --><INDEXTARGET ID="01-physmem20"><!-- POSTPROCESSDATA: 01-physmem20|SIGSEGV --><INDEXTARGET ID="01-physmem21"><!-- POSTPROCESSDATA: 01-physmem21|address exception --></PARAGRAPH>
<PARAGRAPH>An addressing exception can also be detected in the course of handling a TLB miss. If there is no page table entry assigned for the desired address, that address is not part of the address space of the process.</PARAGRAPH>
<PARAGRAPH>When a user-mode process caused the addressing exception, the kernel sends the process a SIGSEGV (see the <REFPAGE>signal(5)</REFPAGE> reference page), usually causing a segmentation fault. When kernel-level code such as a device driver causes the exception, the kernel executes a &ldquo;panic,&rdquo; taking a crash dump and shutting down the system.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="65466">CPU Access to Device Registers</TITLE><PARAGRAPH>The CPU accesses a device register using <INDEXTARGET ID="01-physmem22"><!-- POSTPROCESSDATA: 01-physmem22|CPU:device accessdevice accessProgrammed I/O (PIO) --><GLOSSARYITEM>programmed I/O</GLOSSARYITEM> (PIO), a process illustrated in <XREF IDREF="57175" TYPE="GRAPHIC">Figure&nbsp;1-2</XREF>. Access to device registers is always uncached. It is not affected by considerations of cache coherency in any system (see <XREF IDREF="69794" TYPE="TITLE">&ldquo;Cache Use and Cache Coherency&rdquo;</XREF>).&space;<INDEXTARGET ID="01-physmem23"><!-- POSTPROCESSDATA: 01-physmem23|cache:device access always uncached --></PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="01-cpu.device.registers.access.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="1-2"><PREFIX>Figure 1-2 </PREFIX><XREFTARGET ID="57175">CPU Access to Device Registers (Programmed I/O)</CAPTION>
</FIGURE>
</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>The address of the device is formed in the Execution unit. It may or may not be an address that is mapped by the TLB.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>A device address, after mapping if necessary, always falls in one of the ranges that is not cached, so it passes directly to the system bus.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The device or bus attachment recognizes its physical address and responds with data.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>The PIO process shown in <XREF IDREF="57175" TYPE="GRAPHIC">Figure&nbsp;1-2</XREF> is correct for an Origin2000 system when the addressed device is attached to the same node. When the device is attached to a different node, the address passes through the connection fabric to that node, and the data returns the same way.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="91137">Direct Memory Access</TITLE><PARAGRAPH>Some devices can perform <INDEXTARGET ID="01-physmem24"><!-- POSTPROCESSDATA: 01-physmem24|Direct Memory Access (DMA) --><GLOSSARYITEM>direct memory access</GLOSSARYITEM> (DMA), in which the device itself, not the CPU, reads or writes data into memory. A device that can perform DMA is called a <GLOSSARYITEM>bus master</GLOSSARYITEM> because it independently generates a sequence of bus accesses without help from the CPU.</PARAGRAPH>
<PARAGRAPH>In order to read or write a sequence of memory addresses, the bus master has to be told the proper physical address range to use. This is done by storing a bus address and length into the device's registers from the CPU. When the device has the DMA information, it can access memory through the system bus as shown in <XREF IDREF="80773" TYPE="GRAPHIC">Figure&nbsp;1-3</XREF>.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="01-device.access.to.memory.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="1-3"><PREFIX>Figure 1-3 </PREFIX><XREFTARGET ID="80773">Device Access to Memory</CAPTION>
</FIGURE>
</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>The device places the next physical address, and data, on the system bus.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The memory module stores the data.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>In a Origin2000 system, the device and the memory module can be in different nodes, with address and data passing through the connection fabric between nodes.</PARAGRAPH>
<PARAGRAPH>When a device is programmed with an invalid physical address, the result is a bus error interrupt. The interrupt is taken by some CPU that is enabled for bus error interrupts. These interrupts are not simple to process for two reasons. First, the CPU that receives the interrupt is not necessarily the CPU from which the DMA operation was programmed. Second, the bus error can occur a long time after the operation was initiated.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="29796">PIO Addresses and DMA Addresses</TITLE><PARAGRAPH><INDEXTARGET ID="01-physmem25"><!-- POSTPROCESSDATA: 01-physmem25|address space:bus virtualbus virtual address --><XREF IDREF="80773" TYPE="GRAPHIC">Figure&nbsp;1-3</XREF> is too simple for some devices that are attached through a bus adapter. A bus adapter connects a bus of a different type to the system bus, as shown in <XREF IDREF="93424" TYPE="GRAPHIC">Figure&nbsp;1-4</XREF>.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="01-device.access.thru.bus.adapt.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="1-4"><PREFIX>Figure 1-4 </PREFIX><XREFTARGET ID="93424">Device Access Through a Bus Adapter</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>For example, the PCI bus adapter connects a PCI bus to the system bus. Multiple PCI devices can be plugged into the PCI bus and use the bus to read and write. The bus adapter translates the PCI bus protocol into the system bus protocol. (For details on the PCI bus adapter, see <XREF IDREF="92297" TYPE="TITLE">Part IX, &ldquo;PCI Drivers.&rdquo;</XREF>)</PARAGRAPH>
<PARAGRAPH>Each bus has address lines that carry the address values used by devices on the bus. These bus addresses are not related to the physical addresses used on the system bus. The issue of bus addressing is made complicated by three facts:<INDEXTARGET ID="01-physmem26"><!-- POSTPROCESSDATA: 01-physmem26|bus adapter:translates addresses --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Bus-master devices independently generate memory-read and memory-write commands that are intended to access system memory.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The bus adapter can translate addresses between addresses on the bus it manages, and different addresses on the system bus it uses.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The translation done by the bus adapter can be programmed dynamically, and can change from one I/O operation to another.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>This subject can be simplified by dividing it into two distinct subjects: PIO addressing, used by the CPU to access a device, and DMA addressing, used by a bus master to access memory. These addressing modes need to be treated differently.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>PIO Addressing</TITLE><PARAGRAPH>Programmed I/O (PIO) is the term for a load or store instruction executed by the CPU that names an I/O device as its operand. The CPU places a physical address on the system bus. The bus adapter repeats the read or write command on its bus, but not necessarily using the same address bits as the CPU put on the system bus. </PARAGRAPH>
<PARAGRAPH>One task of a bus adapter is to translate between the physical addresses used on the system bus and the addressing scheme used within the proprietary bus. The address placed on the target bus is not necessarily the same as the address generated by the CPU. The translation is done differently with different bus adapters and in different system models.</PARAGRAPH>
<PARAGRAPH>In some older Silicon Graphics systems, the translation was hard-wired. For a simple example, the address translation from the Indigo2 system bus to the EISA bus was hardwired, so that, for example, CPU access to a physical address of 0x0000&nbsp;4010 was always translated to location 0x0010 in the I/O address space of EISA slot 4. </PARAGRAPH>
<PARAGRAPH>With the more sophisticated PCI and VME buses, the translation is dynamic. Both of these buses support bus address spaces that are as large or larger than the physical address space of the system bus. It is impossible to hard-wire a translation of the entire bus address space.</PARAGRAPH>
<PARAGRAPH>In order to use a dynamic PIO address, a device driver creates a software object called a PIO map that represents that portion of bus address space that contains the device registers the driver uses. When the driver wants to use the PIO map, the kernel dynamically sets up a translation from an unused part of physical address space to the needed part of the bus address space. The driver extracts an address from the PIO map and uses it as the base for accessing the device registers. PIO maps are discussed in <XREF IDREF="13012" TYPE="TITLE">Chapter&nbsp;13, &ldquo;Services for VME Drivers on Origin2000/Onyx2,&rdquo;</XREF> and in <XREF IDREF="46138" TYPE="TITLE">Chapter&nbsp;20, &ldquo;PCI Device Attachment.&rdquo;</XREF></PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>DMA Addressing</TITLE><PARAGRAPH>A bus-master device on the PCI or VME bus can be programmed to perform transfers to or from memory independently and asynchronously. A bus master is programmed using PIO with a starting bus address and a length. The bus master generates a series of memory-read or memory-write operations to successive addresses. But what <ITALICS>bus</ITALICS> addresses should it use in order to store into the proper <ITALICS>memory</ITALICS> addresses?</PARAGRAPH>
<PARAGRAPH>The bus adapter translates the addresses used on the proprietary bus to corresponding addresses on the system bus. Considering <XREF IDREF="93424" TYPE="GRAPHIC">Figure&nbsp;1-4</XREF>, the operation of a DMA device is as follows:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>The device places a bus address and data on the PCI or VME bus.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The bus adapter translates the address to a meaningful physical address, and places that address and the data on the system bus.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The memory modules stores the data.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>The translation of bus virtual to physical addresses is done by the bus adapter and programmed by the kernel. A device driver requests the kernel to set up a dynamic mapping from a designated memory buffer to bus addresses. The map is represented by a software object called a DMA map.</PARAGRAPH>
<PARAGRAPH>The driver calls kernel functions to establish the range of memory addresses that the bus master device will need to access&mdash;typically the address of an I/O buffer. When the driver activates the DMA map, the kernel sets up the bus adapter hardware to translate between some range of bus addresses and the desired range of memory space. The driver extracts from the DMA map the starting bus address, and (using PIO) programs that bus address into the bus master device.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="69794">Cache Use and Cache Coherency</TITLE><PARAGRAPH>The primary and secondary caches shown in <INDEXTARGET ID="01-physmem27"><!-- POSTPROCESSDATA: 01-physmem27|cache --><XREF IDREF="28485" TYPE="GRAPHIC">Figure&nbsp;1-1</XREF>&space;are essential to CPU performance. There is an order of magnitude difference in the speed of access between cache memory and main memory. Execution speed remains high only as long as a very high proportion of memory accesses are satisfied from the primary or secondary cache.</PARAGRAPH>
<PARAGRAPH>The use of caches means that there are often multiple copies of data: a copy in main memory, a copy in the secondary cache (when one is used) and a copy in the primary cache. Moreover, a multiprocessor system has multiple CPU modules like the one shown, and there can be copies of the same data in the cache of <ITALICS>each</ITALICS> CPU.</PARAGRAPH>
<PARAGRAPH>The problem of <GLOSSARYITEM>cache coherency</GLOSSARYITEM> is to ensure that all cache copies of data are true reflections of the data in main memory. Different Silicon Graphics systems use different hardware designs to achieve cache coherency.</PARAGRAPH>
<PARAGRAPH>In most cases, cache coherence is achieved by the hardware, without any effect on software. In a few cases, specialized software, such as a kernel-level device driver, must take specific steps to maintain cache coherency.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Cache Coherency in Multiprocessors</TITLE><PARAGRAPH>Multiprocessor systems have more complex cache coherency protection because it is possible to have data in multiple caches. In a multiprocessor system, the hardware ensures that cache coherency is maintained under all conditions, including DMA input and output, without action by the software. However, in some systems the cache coherency hardware works correctly only when a DMA buffer is aligned on a cache-line-sized boundary. You ensure this by using the KM_CACHEALIGN flag when allocating buffer space with <INDEXTARGET ID="01-physmem28"><!-- POSTPROCESSDATA: 01-physmem28|cache:coherency --><FUNCTION>kmem_alloc()</FUNCTION> (see <XREF IDREF="77267" TYPE="TITLE">&ldquo;Kernel Memory Allocation&rdquo;</XREF> and the <REFPAGE>kmem_alloc(D3)</REFPAGE> reference page).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Cache Coherency in Uniprocessors</TITLE><PARAGRAPH>In some uniprocessor systems, it is possible for the CPU cache to have newer information than appears in memory. This is a problem only when a bus master device is going to perform DMA. If the bus master reads memory, it can get old data. If it writes memory, the input data can be destroyed when the CPU writes the modified cache line back to memory.</PARAGRAPH>
<PARAGRAPH>In systems where this is possible, a device driver calls a kernel function to ensure that all cached data has been written to memory prior to DMA output (the <REFPAGE>dki_dcache_wb(D3)</REFPAGE> reference page). The device driver calls a kernel function to ensure that the CPU receives the latest data following a DMA input (see the <REFPAGE>dki_dcache_inval(D3)</REFPAGE> reference page). In a multiprocessor these functions do nothing, but it is always safe to call them.</PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="93894">The 32-Bit Address Space</TITLE><PARAGRAPH>The MIPS processors can operate in one of two address modes: 32-bit and 64-bit. The choice of address mode is independent of other features of the instruction set architecture such as the number of available registers and the precision of integer arithmetic. For example, programs compiled to the n32 binary interface use 32-bit addresses but 64-bit integers. The implications for user programs are documented in manuals listed under <INDEXTARGET ID="01-physmem29"><!-- POSTPROCESSDATA: 01-physmem29|address space:32-bit --><XREF IDREF="49142" TYPE="TITLE">&ldquo;Additional Reading&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>The addressing mode can be switched dynamically; for example, the IRIX kernel can operate with 64-bit addresses, but the kernel can switch to 32-bit address when it dispatches a user program that was compiled for that mode. The 32-bit address space is the range of all addresses that can be used when in 32-bit mode. This space is discussed first because it is simpler and more familiar than the 64-bit space.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Segments of the 32-bit Address Space</TITLE><PARAGRAPH>When operating in 32-bit mode, the MIPS architecture uses addresses that are 32-bit unsigned integers from 0x0000&nbsp;0000 to 0xFFFF&nbsp;FFFF. However, this address space is not uniform. The MIPS hardware divides it into segments, and treats each segment differently. The ranges are shown graphically in <INDEXTARGET ID="01-physmem30"><!-- POSTPROCESSDATA: 01-physmem30|address space:32-bit:segments of --><XREF IDREF="39413" TYPE="GRAPHIC">Figure&nbsp;1-5</XREF>.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="01-32.bit.address.space.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="1-5"><PREFIX>Figure 1-5 </PREFIX><XREFTARGET ID="39413">The 32-Bit Address Space</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>The address segments differ in three characteristics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>whether access to an address is mapped; that is, passed through the translation lookaside buffer (TLB)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>whether an address can be accessed when the CPU is operating in user mode or in kernel mode</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>whether access to an address is cached; that is, looked up in the primary and secondary caches before it is sent to main memory</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Virtual Address Mapping</TITLE><PARAGRAPH>In the mapped segments, each 32-bit address value is treated as shown in <INDEXTARGET ID="01-physmem31"><!-- POSTPROCESSDATA: 01-physmem31|address space:32-bit:virtual mapping --><INDEXTARGET ID="01-physmem32"><!-- POSTPROCESSDATA: 01-physmem32|virtual memory:32-bit mapping --><XREF IDREF="76746" TYPE="GRAPHIC">Figure&nbsp;1-6</XREF>.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="01-32.bit.virt.addr.format.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="1-6"><PREFIX>Figure 1-6 </PREFIX><XREFTARGET ID="76746">MIPS 32-Bit Virtual Address Format</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>The three most significant bits of the address choose the segment among those drawn in <XREF IDREF="39413" TYPE="GRAPHIC">Figure&nbsp;1-5</XREF>. When bit 31 is 0, bits 30:12 select a <GLOSSARYITEM>virtual page number</GLOSSARYITEM> (VPN) from 2<SUPERSCRIPT>19</SUPERSCRIPT> possible pages in the address space of the current user process. When bits 31:30 are 11, bits 29:12 select a VPN from 2<SUPERSCRIPT>18</SUPERSCRIPT> possible pages in the kernel virtual address space.&space;<INDEXTARGET ID="01-physmem33"><!-- POSTPROCESSDATA: 01-physmem33|virtual page number (VPN):32-bit --></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>User Process Space&mdash;kuseg</TITLE><PARAGRAPH>The total 32-bit address space is divided in half. Addresses with a most significant bit of 0 constitute the 2&nbsp;GB user process space. When executing in user mode, only addresses in <INDEXTARGET ID="01-physmem34"><!-- POSTPROCESSDATA: 01-physmem34|address space:user process --><INDEXTARGET ID="01-physmem35"><!-- POSTPROCESSDATA: 01-physmem35|address space:32-bit:kuseg --><ITALICS>kuseg</ITALICS> are valid; an attempt to use an address with bit 31=1 causes an addressing exception.</PARAGRAPH>
<PARAGRAPH>Access to <INDEXTARGET ID="01-physmem36"><!-- POSTPROCESSDATA: 01-physmem36|Translation Lookaside Buffer (TLB):maps kuseg --><ITALICS>kuseg</ITALICS> is always mapped through the TLB. The kernel creates a unique address space for each user process. Of the 2<SUPERSCRIPT>19</SUPERSCRIPT> possible pages in an address space, most are typically unassigned&mdash;few processes ever occupy more than a fraction of <ITALICS>kuseg</ITALICS>&mdash;and many are shared pages of program text from dynamic shared objects (DSOs) that are mapped into the address space of every process that needs them.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Kernel Virtual Space&mdash;kseg2</TITLE><PARAGRAPH>When bits 31:30 are 11, access is to kernel virtual memory. Only code that is part of the kernel can access this space. References to this space are translated through the TLB. The kernel uses the TLB to map kernel pages in memory as required, possibly in noncontiguous locations. Although pages in kernel space are mapped, they are always associated with real memory. Kernel memory is never paged to secondary storage.<INDEXTARGET ID="01-physmem37"><!-- POSTPROCESSDATA: 01-physmem37|address space:kernel --><INDEXTARGET ID="01-physmem38"><!-- POSTPROCESSDATA: 01-physmem38|address space:32-bit:kseg2 --></PARAGRAPH>
<PARAGRAPH>This is the space in which the IRIX kernel allocates such objects as stacks, user page tables, and per-process data that must be accessible on context switches. This area contains automatic variables declared by loadable device drivers. It is the space in which kernel-level device drivers allocate memory. Since kernel space is mapped, addresses in <INDEXTARGET ID="01-physmem39"><!-- POSTPROCESSDATA: 01-physmem39|kernel functions:<FUNCTION>kmem_alloc()</FUNCTION> --><ITALICS>kseg2</ITALICS> that are apparently contiguous need not be contiguous in physical memory. However, a device driver can allocate space that is both logically and physically contiguous, when that is required (see for example the <REFPAGE>kmem_alloc(D3)</REFPAGE> reference page).</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="98461">Cached Physical Memory&mdash;kseg0</TITLE><PARAGRAPH>When address bits 31:29 contain 100, access is directed to physical memory through the cache. If the addressed location is not in the cache, bits 28:0 are placed on the system bus as a physical memory address, and the data presented by memory or a device is returned. <INDEXTARGET ID="01-physmem40"><!-- POSTPROCESSDATA: 01-physmem40|memory address:cached --><INDEXTARGET ID="01-physmem41"><!-- POSTPROCESSDATA: 01-physmem41|address space:32-bit:kseg0 --><INDEXTARGET ID="01-physmem42"><!-- POSTPROCESSDATA: 01-physmem42|address space:32-bit:kseg0 --><ITALICS>Kseg0</ITALICS> contains the exception address to which the MIPS processor branches it when it detects an exception such as an addressing exception or TLB miss.</PARAGRAPH>
<PARAGRAPH>Since only 29 bits are available for mapping physical memory, only 512&nbsp;MB of physical memory space can be accessed through this segment in 32-bit mode. Some of this space must be reserved for device addressing. It is possible to gain cached access to wider physical addresses by mapping through the TLB into <ITALICS>kseg2</ITALICS>, but systems that need access to more physical memory typically run in 64-bit mode (see <XREF IDREF="82738" TYPE="TITLE">&ldquo;Cache-Controlled Physical Memory&mdash;xkphys&rdquo;</XREF>).</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="45748">Uncached Physical Memory&mdash;kseg1</TITLE><PARAGRAPH>When address bits 31:29 contain 101, access is directly to physical memory, bypassing the cache. Bits 28:0 are placed on the system bus for memory or device transfer.<INDEXTARGET ID="01-physmem43"><!-- POSTPROCESSDATA: 01-physmem43|uncached memory access:32-bit --><INDEXTARGET ID="01-physmem44"><!-- POSTPROCESSDATA: 01-physmem44|memory address:uncached --><INDEXTARGET ID="01-physmem45"><!-- POSTPROCESSDATA: 01-physmem45|address space:32-bit:kseg1 --></PARAGRAPH>
<PARAGRAPH>The kernel refers to <VARIABLE>kseg1</VARIABLE> when performing PIO to devices because loads or stores from device registers should not pass through cache memory. The kernel also uses <VARIABLE>kseg1</VARIABLE> when operating on certain data structures that might be <GLOSSARYITEM>volatile</GLOSSARYITEM>. Kernel-level device drivers sometimes need to write to uncached memory, and must take special precautions when doing so (see <XREF IDREF="17413" TYPE="TITLE">&ldquo;Uncached Memory Access in the IP26 and IP28&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>Portions of <ITALICS>kseg0</ITALICS> or <ITALICS>kseg1</ITALICS> can be mapped into <ITALICS>kuseg</ITALICS> by the <FUNCTION>mmap()</FUNCTION> function. This is covered at more length under <XREF IDREF="22114" TYPE="TITLE">&ldquo;Memory Use in User-Level Drivers&rdquo;</XREF>. </PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="86234">The 64-Bit Address Space</TITLE><PARAGRAPH>The 64-bit mode is an upward extension of 32-bit mode. All MIPS processors from the R4000 on support 64-bit mode. However, this mode was not used in Silicon Graphics software until IRIX 6.0 was released.<INDEXTARGET ID="01-physmem46"><!-- POSTPROCESSDATA: 01-physmem46|address space:64-bit --></PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Segments of the 64-Bit Address Space</TITLE><PARAGRAPH>When operating in 64-bit mode, the MIPS architecture uses addresses that are 64-bit unsigned integers from 0x0000&nbsp;0000&nbsp;0000&nbsp;0000 to 0xFFFF&nbsp;FFFF&nbsp;FFFF&nbsp;FFFF. This is an immense span of numbers&mdash;if it were drawn to a scale of 1 millimeter per terabyte, the drawing would be 16.8 kilometers long (just over 10 miles).<INDEXTARGET ID="01-physmem47"><!-- POSTPROCESSDATA: 01-physmem47|address space:64-bit:segments of --></PARAGRAPH>
<PARAGRAPH>The MIPS hardware divides the address space into segments based on the most significant bits, and treats each segment differently. The ranges are shown graphically in <XREF IDREF="83664" TYPE="GRAPHIC">Figure&nbsp;1-7</XREF>. These major segments define only a fraction of the 64-bit space. Most of the possible addresses are undefined and cause an addressing exception (segmentation fault) if used.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="01-64.bit.address.space.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="1-7"><PREFIX>Figure 1-7 </PREFIX><XREFTARGET ID="83664">Main Parts of the 64-Bit Address Space </CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>As in the 32-bit space, these major segments differ in three characteristics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>whether access to an address is mapped; that is, passed through the translation lookaside buffer (TLB)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>whether an address can be accessed when the CPU is operating in user mode or in kernel mode.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>whether access to an address is cached; that is, looked up in the primary and secondary caches before it is sent to main memory</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Compatibility of 32-Bit and 64-Bit Spaces</TITLE><PARAGRAPH>The MIPS-3 instruction set (which is in use when the processor is in 64-bit mode) is designed so that when a 32-bit instruction is used to generate or to load an address, the 32-bit operand is automatically sign-extended to fill the high-order 32 bits.<INDEXTARGET ID="01-physmem48"><!-- POSTPROCESSDATA: 01-physmem48|address space:64-bit:sign extension --><INDEXTARGET ID="01-physmem49"><!-- POSTPROCESSDATA: 01-physmem49|sign extension of 32-bit addresses --><INDEXTARGET ID="01-physmem50"><!-- POSTPROCESSDATA: 01-physmem50|address space:32-bit:embedding in 64-bit --></PARAGRAPH>
<PARAGRAPH>As a result, any 32-bit address that falls in the user segment <ITALICS>kuseg</ITALICS>, and which must have a sign bit of 0, is extended to a 64-bit integer with 32 high-order 0 bits. This automatically places the 32-bit <ITALICS>kuseg</ITALICS> in the bottom of the 64-bit <ITALICS>xkuseg</ITALICS>, as shown in <XREF IDREF="83664" TYPE="GRAPHIC">Figure&nbsp;1-7</XREF>.</PARAGRAPH>
<PARAGRAPH>A 32-bit kernel address, which must have a sign bit of 1, is automatically extended to a 64-bit integer with 32 high-order 1 bits. This places all kernel segments shown in <XREF IDREF="39413" TYPE="GRAPHIC">Figure&nbsp;1-5</XREF> at the extreme top of the 64-bit address space. However, these 32-bit kernel spaces are not used by a kernel operating in 64-bit mode.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Virtual Address Mapping</TITLE><PARAGRAPH>In the mapped segments, each 64-bit address value is treated as shown in <INDEXTARGET ID="01-physmem51"><!-- POSTPROCESSDATA: 01-physmem51|address space:64-bit:virtual mapping --><INDEXTARGET ID="01-physmem52"><!-- POSTPROCESSDATA: 01-physmem52|virtual memory:64-bit mapping --><XREF IDREF="13558" TYPE="GRAPHIC">Figure&nbsp;1-8</XREF>.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="01-64.bit.virt.addr.format.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="1-8"><PREFIX>Figure 1-8 </PREFIX><XREFTARGET ID="13558">MIPS 64-Bit Virtual Address Format</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>The two most significant bits select the major segment (compare these to the address boundaries in <XREF IDREF="83664" TYPE="GRAPHIC">Figure&nbsp;1-7</XREF>). Bits 61:40 must all be 0. (In principle, references to 32-bit kernel segments would have bits 61:40 all 1, but these segments are not used in 64-bit mode.)</PARAGRAPH>
<PARAGRAPH>The size of a page of virtual memory can vary from system to system and release to release, so always determine it dynamically. In a user-level program, call the <INDEXTARGET ID="01-physmem53"><!-- POSTPROCESSDATA: 01-physmem53|virtual memory:page size --><INDEXTARGET ID="01-physmem54"><!-- POSTPROCESSDATA: 01-physmem54|page size:memory --><INDEXTARGET ID="01-physmem55"><!-- POSTPROCESSDATA: 01-physmem55|IRIX functions:<FUNCTION>getpagesize()</FUNCTION> --><INDEXTARGET ID="01-physmem56"><!-- POSTPROCESSDATA: 01-physmem56|kernel functions:<FUNCTION>ptob()</FUNCTION> --><FUNCTION>getpagesize()</FUNCTION> function (see the <REFPAGE>getpagesize(2)</REFPAGE> reference page). In a kernel-level driver, use the <FUNCTION>ptob()</FUNCTION> kernel function (see the <REFPAGE>ptob(D3)</REFPAGE> reference page) or the constant NBPP declared in <FILENAME>sys/immu.h</FILENAME>.)</PARAGRAPH>
<PARAGRAPH>When the page size is 16&nbsp;KB, bits 13:0 of the address represent the offset within the page, and bits 39:14 select a VPN from the 2<SUPERSCRIPT>26</SUPERSCRIPT>, or 64&nbsp;M, pages in the virtual segment.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>User Process Space&mdash;xkuseg</TITLE><PARAGRAPH>The first 16&nbsp;TB of the address space are devoted to user process space. Access to <INDEXTARGET ID="01-physmem57"><!-- POSTPROCESSDATA: 01-physmem57|address space:64-bit:xkuseg --><INDEXTARGET ID="01-physmem58"><!-- POSTPROCESSDATA: 01-physmem58|address space:user process --><ITALICS>xkuseg</ITALICS> is always mapped through the TLB. The kernel creates a unique address space for each user process. Of the 2<SUPERSCRIPT>26</SUPERSCRIPT> possible pages in a process's address space, most are typically unassigned, and many are shared pages of program text from dynamic shared objects (DSOs) that are mapped into the address space of every process that needs them.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Supervisor Mode Space&mdash;xksseg</TITLE><PARAGRAPH>The MIPS architecture permits three modes of operation: user, kernel, and supervisor. When operating in kernel or supervisor mode, the 2&nbsp;TB space beginning at 0x4000&nbsp;0000&nbsp;0000&nbsp;0000 is accessible. IRIX does not employ the supervisor mode, and does not use <INDEXTARGET ID="01-physmem59"><!-- POSTPROCESSDATA: 01-physmem59|address space:64-bit:xksseg --><INDEXTARGET ID="01-physmem60"><!-- POSTPROCESSDATA: 01-physmem60|address space:supervisor --><ITALICS>xksseg</ITALICS>. If <ITALICS>xksseg</ITALICS> were used, it would be mapped and cached.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="16268">Kernel Virtual Space&mdash;xkseg</TITLE><PARAGRAPH>When bits 63:62 are 11, access is to kernel virtual memory. Only code that is part of the kernel can access this space, a 2&nbsp;TB segment starting at 0xC000&nbsp;0000&nbsp;0000 0000. References to this space are translated through the TLB, and cached. The kernel uses the TLB to map kernel pages in memory as required, possibly in noncontiguous locations. Although pages in kernel space are mapped, they are always associated with real memory. Kernel pages are never paged to secondary storage. <INDEXTARGET ID="01-physmem61"><!-- POSTPROCESSDATA: 01-physmem61|address space:64-bit:xkseg --><INDEXTARGET ID="01-physmem62"><!-- POSTPROCESSDATA: 01-physmem62|address space:kernel --><INDEXTARGET ID="01-physmem63"><!-- POSTPROCESSDATA: 01-physmem63|Translation Lookaside Buffer (TLB):maps kernel space --></PARAGRAPH>
<PARAGRAPH>This is the space in which the IRIX kernel allocates such objects as stacks, per-process data that must be accessible on context switches, and user page tables. This area contains automatic variables declared by loadable device drivers. It is the space in which kernel-level device drivers allocate memory. Since kernel space is mapped, addresses in <ITALICS>kseg2</ITALICS> that are apparently contiguous need not be contiguous in physical memory. However, a device driver can allocate space that is both logically and physically contiguous, when that is required (see for example the <REFPAGE>kmem_alloc(D3)</REFPAGE> reference page).</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="82738">Cache-Controlled Physical Memory&mdash;xkphys</TITLE><PARAGRAPH>One-quarter of the 64-bit address space&mdash;all addresses with bits 63:62 containing 10&mdash;are devoted to special access to one or more 1&nbsp;TB physical address spaces. Any reference to the other spaces (<INDEXTARGET ID="01-physmem64"><!-- POSTPROCESSDATA: 01-physmem64|uncached memory access:64-bit --><INDEXTARGET ID="01-physmem65"><!-- POSTPROCESSDATA: 01-physmem65|address space:64-bit:cache-controlled --><INDEXTARGET ID="01-physmem66"><!-- POSTPROCESSDATA: 01-physmem66|cache:64-bit access --><ITALICS>xkuseg</ITALICS> and <ITALICS>xkseg</ITALICS>) is transformed by the TLB into a reference to <ITALICS>xkphys</ITALICS>. Addresses in this space are interpreted as shown in <XREF IDREF="97695" TYPE="GRAPHIC">Figure&nbsp;1-9</XREF>.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="01-phys.mem.access.add.decod.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="1-9"><PREFIX>Figure 1-9 </PREFIX><XREFTARGET ID="97695">Address Decoding for Physical Memory Access</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>Bits 39:0 select a physical address in a 1&nbsp;TB range. Bits 57:40 must always contain 0. Bits 61:59 select the hardware cache algorithm to be used. The only values defined for these bits are summarized in <XREF IDREF="65743" TYPE="TABLE">Table&nbsp;1-3</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="1-3"><PREFIX>Table 1-3 </PREFIX><XREFTARGET ID="65743">Cache Algorithm Selection&space;<INDEXTARGET ID="01-physmem67"><!-- POSTPROCESSDATA: 01-physmem67|cache algorithm --></CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Address 61:59</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="125"><PARAGRAPH>Algorithm</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="198"><PARAGRAPH>Meaning</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>010</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="125"><PARAGRAPH>Uncached </PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="198"><PARAGRAPH>This is the 64-bit equivalent of <ITALICS>kseg1</ITALICS> in 32-bit 
mode&mdash;uncached access to physical memory. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>110</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="125"><PARAGRAPH>Cacheable coherent exclusive 
on write </PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="198"><PARAGRAPH>This is the 64-bit equivalent of <ITALICS>kseg0</ITALICS> in 32-bit 
mode&mdash;cached access to physical memory, 
coherent access in a multiprocessor. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>011</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="125"><PARAGRAPH>Cacheable non-coherent </PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="198"><PARAGRAPH>Data is cached; on a cache miss the processor 
issues a non-coherent read (one without regard 
to other CPUs). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>100</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="125"><PARAGRAPH>Cacheable coherent exclusive </PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="198"><PARAGRAPH>Data is cached; on a read miss the processor 
issues a coherent read exclusive. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>101</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="125"><PARAGRAPH>Cacheable coherent update on 
write </PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="198"><PARAGRAPH>Same as 110, but updates memory on a store hit 
in cache. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>111</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="125"><PARAGRAPH>Uncached Accelerated </PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="198"><PARAGRAPH>Same as 010, but the cache hardware is permitted 
to defer writes to memory until it has collected a 
larger block, improving write utilization. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Only the 010 (uncached) and 110 (cached) algorithms are implemented on all systems. The others may or may not be implemented on particular systems.</PARAGRAPH>
<PARAGRAPH>Bits 58:57 must be 00 unless the cache algorithm is 010 (uncached) or 111(uncached accelerated). Then bits 58:57 can in principle be used to select four other properties to qualify the uncached operation. These bits are first put to use in the Origin2000 system, described under <XREF IDREF="57946" TYPE="TITLE">&ldquo;Uncached and Special Address Spaces&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>It is not possible for a user process to access either <ITALICS>xkphys</ITALICS> or <ITALICS>xkseg</ITALICS>; and not possible for a kernel-level driver to access <ITALICS>xkphys</ITALICS> directly. Portions of <ITALICS>xkphys</ITALICS> and <ITALICS>xkseg</ITALICS> can be mapped to user process space by the <FUNCTION>mmap()</FUNCTION> function. This is covered in more detail under <XREF IDREF="22114" TYPE="TITLE">&ldquo;Memory Use in User-Level Drivers&rdquo;</XREF>. Portions of <ITALICS>xkphys</ITALICS> can be accessed by a driver using DMA-mapping and PIO-mapping functions (see <XREF IDREF="29796" TYPE="TITLE">&ldquo;PIO Addresses and DMA Addresses&rdquo;</XREF>).&space;</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="69605">Address Space Usage in Origin2000 Systems</TITLE><PARAGRAPH>An Origin2000 system contains one or more nodes. Each node can contain one or two CPUs as well as up to 2&nbsp;GB of memory. There is a single, flat, address space that contains all memory in all nodes. All memory can be accessed from any CPU. However, a CPU can access memory in its own node in less time than it can access memory in a different node.</PARAGRAPH>
<PARAGRAPH>The node hardware provides a variety of special-purpose access modes to make kernel programming simpler. These special modes are described here at a high level. For details refer to the hardware manuals listed in <XREF IDREF="49142" TYPE="TITLE">&ldquo;Additional Reading&rdquo;</XREF>. These special addressing modes are a feature of the Origin2000 node hardware, not of the R10000 CPU chip. As such they are available only in the Origin2000 and Origin200 systems.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>User Process Space and Kernel Virtual Space</TITLE><PARAGRAPH>Virtual addresses with bits 63:62 containing 00 are references to the user process address space. The kernel creates a virtual address space for each user process as described before (see <XREF IDREF="16985" TYPE="TITLE">&ldquo;Virtual Address Mapping&rdquo;</XREF>). The Origin2000 architecture adds the complication that the location of a page, relative to the location where the process executes, has an effect on the performance of the process. The kernel uses a variety of strategies to locate pages of memory in the same node as the CPU that is running the process. </PARAGRAPH>
<PARAGRAPH>Kernel virtual addresses (in which bits 63:62 contain 11) are mapped as already described (see <XREF IDREF="16268" TYPE="TITLE">&ldquo;Kernel Virtual Space&mdash;xkseg&rdquo;</XREF>). Certain important data structures may be replicated into each node for faster access.</PARAGRAPH>
<PARAGRAPH>The stack and data areas used by device drivers are in <ITALICS>xkseg</ITALICS>. A driver has the ability to request memory allocation in a particular node, in order to make sure that data about a device is stored in the same node where the device is attached and where device interrupts are taken (see <XREF IDREF="77267" TYPE="TITLE">&ldquo;Kernel Memory Allocation&rdquo;</XREF>).</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="57946">Uncached and Special Address Spaces</TITLE><PARAGRAPH>A physical address in <ITALICS>xkphys</ITALICS> (bits 63:62 contain 10) has different meanings depending on the settings of bits 61:57 (see <XREF IDREF="97695" TYPE="GRAPHIC">Figure&nbsp;1-9</XREF> and <XREF IDREF="65743" TYPE="TABLE">Table&nbsp;1-3</XREF>). In the Origin2000 architecture, these bits are interpreted by the memory control circuits of the node, external to the CPU. The possibilities are listed in <XREF IDREF="13137" TYPE="TABLE">Table&nbsp;1-4</XREF>. Some are covered in more detail in following topics. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="1-4"><PREFIX>Table 1-4 </PREFIX><XREFTARGET ID="13137">Special Address Spaces in Origin2000</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Address 61:59 
(Algorithm)</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>&lbreak;Address 58:57</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>&lbreak;Meaning</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>110 (cached)</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>n.a.</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Cached access to physical memory</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>010 (uncached) </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>00</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Node special memory areas including directory cache, ECC, 
PROM, and other node hardware locations.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>010 (uncached) </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>01</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>I/O space: addresses that can be mapped into the address 
space of any bus adapter.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>010 (uncached) </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>10</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Synchronization access to memory.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>010 (uncached) </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>11</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Uncached access to physical memory.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="65843">Cached Access to Physical Memory</TITLE><PARAGRAPH>When the CPU emits a translated virtual address with bits 63:62 containing 10 and bits 61:59 specifying cached access, the address is a cached reference to physical memory. When the referenced location is not contained in the secondary cache, it is fetched from memory in the node that contains it. This is the normal outcome of the translation of a user or kernel virtual address through the TLB.</PARAGRAPH>
<PARAGRAPH>The actual address is the physical address in bits 39:0, interpreted as shown in <XREF IDREF="79289" TYPE="GRAPHIC">Figure&nbsp;1-10</XREF>.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="01-O2.physical.address.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="1-10"><PREFIX>Figure 1-10 </PREFIX><XREFTARGET ID="79289">Origin2000 Physical Address Decoding</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>The node hardware can operate in either of two modes, called `M' and `N'.</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>Mode `M'</HANGITEM>
<HANGBODY><PARAGRAPH>Bits 39:32 select one of 256 nodes. Remaining bits select an address in as &lbreak;much as 4&nbsp;GB of memory in that node.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>Mode `N'</HANGITEM>
<HANGBODY><PARAGRAPH>Bits 39:31 select one of 512 nodes. Remaining bits select an address in as &lbreak;much as 2&nbsp;GB of memory in that node.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>Either mode places the memory that is part of each node in a flat address space with a potential size of 1&nbsp;TB. All locations are accessed in the same way&mdash;there is a single address space for the entire system. For example, the memory that is part of node 1 begins at 0x0000&nbsp;0001&nbsp;0000&nbsp;0000 (in mode `M') or 0x0000&nbsp;0000&nbsp;8000&nbsp;0000 (in mode `N').</PARAGRAPH>
<PARAGRAPH>The node hardware implements one special case: addresses in the range 0-63&nbsp;MB (0 through 0x0000&nbsp;0000&nbsp;03ff&nbsp;ffff) are always treated as a reference to the current node. In effect, the current node number is logically ORed with the address. This allows trap handlers and other special code to refer to node-specific data without having to know the&nbsp;number of the node in which they execute.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Uncached Access to Memory</TITLE><PARAGRAPH>A physical address in <ITALICS>xkphys</ITALICS> (bits 63:62 contain 10) that has the uncached algorithm (bits 61:59 contain 010) always bypasses the secondary cache. An address of this form can access physical memory in either of two ways.</PARAGRAPH>
<PARAGRAPH>When bits 58:57 contain 11, the address bits 39:0 are decoded as shown in <XREF IDREF="79289" TYPE="GRAPHIC">Figure&nbsp;1-10</XREF>. In this mode there is no aliasing of addresses in the range 0-63&nbsp;MB to the current node; the node number must be given explicitly.</PARAGRAPH>
<PARAGRAPH>However, when bits 58:57 contain 00, an address in the range 0-768&nbsp;MB is interpreted as uncached access to the memory in the current node. In effect, the node number is ORed into the address. Also in this mode, access to the lowest 64&nbsp;KB is swapped between the two CPUs in a node. CPU 0 access to addresses 0x0&nbsp;0000 through 0x1&nbsp;ffff is directed to those addresses. But CPU 1 access to 0x0&nbsp;0000 goes to 0x1&nbsp;0000, and access to 0x1&nbsp;0000 goes to 0x0&nbsp;0000&mdash;reversing the use of the first two 64&nbsp;KB blocks. This helps trap handlers that need quick access to a 64&nbsp;KB space that is unique to the CPU.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Synchronization Access to Memory</TITLE><PARAGRAPH>An uncached physical address with bits 58:57 containing 10 is an atomic fetch-and-modify access. Bits 39:6 select a memory unit of 64 bytes (half a cache line) and bits 5:3 select an operation, as shown in <XREF IDREF="20061" TYPE="GRAPHIC">Figure&nbsp;1-11</XREF>. </PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="01-O2.fetch.op.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="1-11"><PREFIX>Figure 1-11 </PREFIX><XREFTARGET ID="20061">Origin2000 Fetch-and-Op Address Decoding</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>The first word or doubleword (depending on the instruction being executed) of the addressed unit is treated as shown in <XREF IDREF="68567" TYPE="TABLE">Table&nbsp;1-5</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="1-5"><PREFIX>Table 1-5 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="68567">Origin2000 Fetch-and-Op Operations</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="54"><PARAGRAPH>Instruction</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="54"><PARAGRAPH>Address 5:3</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="279"><PARAGRAPH>Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>Load</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="54"><PARAGRAPH>000</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="279"><PARAGRAPH>An uncached read of the location. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>Load</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="54"><PARAGRAPH>001</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="279"><PARAGRAPH>Fetch-and-increment: the old value is fetched and the memory value 
is incremented. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>Load</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="54"><PARAGRAPH>010</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="279"><PARAGRAPH>Fetch-and-decrement: the old value is fetched and the memory value 
is decremented. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>Load</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="54"><PARAGRAPH>011</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="279"><PARAGRAPH>Fetch-and-zero: the old value is returned and zero is stored. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>Store</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="54"><PARAGRAPH>000</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="279"><PARAGRAPH>An uncached store of the location. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>Store</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="54"><PARAGRAPH>001</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="279"><PARAGRAPH>Increment: the memory location is incremented. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>Store</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="54"><PARAGRAPH>010</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="279"><PARAGRAPH>Decrement: the memory location is decremented. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>Store</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="54"><PARAGRAPH>011</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="279"><PARAGRAPH>AND: memory data is ANDed with the store data. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>Store</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="54"><PARAGRAPH>100</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="279"><PARAGRAPH>OR: memory data is ORed with the store data. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>These are atomic operations; that is, no other CPU can perform an interleaved operation to the same 64-byte unit. The kernel can use this addressing mode to implement locks and other synchronization operations. A user-level library is also available so that normal programs can use these facilities when they are available; see the <REFPAGE>fetchop(3)</REFPAGE> reference page.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="60442">Device Driver Use of Memory</TITLE><PARAGRAPH>Memory use by device drivers is simpler than the details in this chapter suggest. The primary complication for the designer is the use of 64-bit addresses, which may be unfamiliar.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Allowing for 64-Bit Mode</TITLE><PARAGRAPH>You must take account of a number of considerations when porting an existing C program to an environment where 64-bit mode is used, or might be used. This can be an issue for all types of drivers, kernel-level and user-level alike. For detailed discussion, see the <INDEXTARGET ID="01-physmem68"><!-- POSTPROCESSDATA: 01-physmem68|64-bit mode --><DOCTITLE>MIPSpro 64-Bit Porting and Transition Guide</DOCTITLE> listed on <XREF IDREF="49142" TYPE="TEXT">page&nbsp;xxxix</XREF>.</PARAGRAPH>
<PARAGRAPH>The most common problems arise because the size of a pointer and of a long integer changes between a program compiled with the -64 option and one compiled -32. When you use pointers, longs, or types derived from longs, in structures, the field offsets differ between the two modes.</PARAGRAPH>
<PARAGRAPH>When all programs in the system are compiled to the same mode, there is no problem. This is the case for a system in which the kernel is compiled to 32-bit mode: only 32-bit user programs are supported. However, a kernel compiled to 64-bit mode executes user programs in 32-bit or 64-bit mode. A structure prepared by a 32-bit program&mdash;a structure passed as an argument to <FUNCTION>ioctl()</FUNCTION>, for example&mdash;does not have fields at the offsets expected by a 64-bit kernel device driver. For more on this specific problem, see <XREF IDREF="87735" TYPE="TITLE">&ldquo;Handling 32-Bit and 64-Bit Execution Models&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>The basic strategy to make your code portable between 32-bit and 64-bit kernels is to be extremely specific when declaring the types of data. You should almost never declare a simple &ldquo;int&rdquo; or &ldquo;char.&rdquo; Instead, use a data type that is explicit as to the precision and the sign of the variable. The header files <FILENAME>sgidefs.h</FILENAME> and <FILENAME>sys/types.h</FILENAME> define type names that you can use to declare structures that always have the same size. The type <VARIABLE>__psint_t</VARIABLE>, for example, is an integer the same size as a pointer; you can use it safely as alias for a pointer. Similarly, the type <VARIABLE>__uint32_t</VARIABLE> is guaranteed to be an unsigned, 32-bit, integer in all cases.<INDEXTARGET ID="01-physmem69"><!-- POSTPROCESSDATA: 01-physmem69|header files:<FILENAME>sgidefs.h</FILENAME> --><INDEXTARGET ID="01-physmem70"><!-- POSTPROCESSDATA: 01-physmem70|header files:<FILENAME>sys/types.h</FILENAME> --></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="22114">Memory Use in User-Level Drivers</TITLE><PARAGRAPH>When you control a device from a user process, your code executes entirely in user process space, and has no direct access to any of the other spaces described in this chapter.<INDEXTARGET ID="01-physmem71"><!-- POSTPROCESSDATA: 01-physmem71|driver:user-level --></PARAGRAPH>
<PARAGRAPH>Depending on the device and other considerations, you may use the <FUNCTION>mmap()</FUNCTION> function to map device registers into the address space of your process (see the <REFPAGE>mmap(2)</REFPAGE> reference page). When the kernel maps a device address into process space, it does it using the TLB mechanism. From <FUNCTION>mmap()</FUNCTION> you receive a valid address in process space. This address is mapped through a TLB entry to an address in segment that accesses uncached physical memory. When your program refers to this address, the reference is directed to the system bus and the device.</PARAGRAPH>
<PARAGRAPH>Portions of kernel virtual memory (<INDEXTARGET ID="01-physmem72"><!-- POSTPROCESSDATA: 01-physmem72|memory mapping --><INDEXTARGET ID="01-physmem73"><!-- POSTPROCESSDATA: 01-physmem73|kernel address space:mapping to user space --><INDEXTARGET ID="01-physmem74"><!-- POSTPROCESSDATA: 01-physmem74|address space:kernel:map to user --><ITALICS>kseg0</ITALICS> or <ITALICS>xkseg</ITALICS>) can be accessed from a user process. Access is based on the use of device special files (see the <REFPAGE>mem(7)</REFPAGE> reference page). Access is done using two models, a device model and a memory map model.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Access Using a Device Model</TITLE><PARAGRAPH>The device special file <INDEXTARGET ID="01-physmem75"><!-- POSTPROCESSDATA: 01-physmem75|device special file:<FILENAME>/dev/mem</FILENAME> --><FILENAME>/dev/mem</FILENAME> represents physical memory. A process that can open this device can use <FUNCTION>lseek()</FUNCTION> and <FUNCTION>read()</FUNCTION> to copy physical memory into process virtual memory. If the process can open the device for output, it can use <FUNCTION>write()</FUNCTION> to patch physical memory.</PARAGRAPH>
<PARAGRAPH>The device special file <INDEXTARGET ID="01-physmem76"><!-- POSTPROCESSDATA: 01-physmem76|device special file:<FILENAME>/dev/kmem</FILENAME> --><FILENAME>/dev/kmem</FILENAME> represents kernel virtual memory (<ITALICS>kseg0</ITALICS> or <ITALICS>xkseg</ITALICS>). It can be opened, read and written similarly to <FILENAME>/dev/mem</FILENAME>. Clearly both of these devices should have file permissions that restrict their use even for input.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Access Using mmap()</TITLE><PARAGRAPH>The <INDEXTARGET ID="01-physmem77"><!-- POSTPROCESSDATA: 01-physmem77|device special file:<FILENAME>/dev/mem</FILENAME> --><INDEXTARGET ID="01-physmem78"><!-- POSTPROCESSDATA: 01-physmem78|IRIX functions:<FUNCTION>mmap()</FUNCTION> --><FUNCTION>mmap()</FUNCTION> function allows a user process to map an open file into the process address space (see the <REFPAGE>mmap(2)</REFPAGE> reference page). When the file that is mapped is <FILENAME>/dev/mem</FILENAME>, the process can map a specified segment of physical memory. The effect of <FUNCTION>mmap()</FUNCTION> is to set up a page table entry and TLB entry so that access to a range of virtual addresses in user space is redirected to the mapped physical addresses in cached physical memory (<ITALICS>kseg0</ITALICS> or the equivalent segment of <ITALICS>xkphys</ITALICS>).</PARAGRAPH>
<PARAGRAPH>The <INDEXTARGET ID="01-physmem79"><!-- POSTPROCESSDATA: 01-physmem79|configuration files:<FILENAME>/var/sysgen/master.d/mem</FILENAME> --><INDEXTARGET ID="01-physmem80"><!-- POSTPROCESSDATA: 01-physmem80|device special file:<FILENAME>/dev/mmem</FILENAME> --><INDEXTARGET ID="01-physmem81"><!-- POSTPROCESSDATA: 01-physmem81|device special file<FILENAME>/dev/kmem</FILENAME> --><FILENAME>/dev/kmem</FILENAME> device, representing kernel virtual memory, cannot be used with <FUNCTION>mmap()</FUNCTION>. However, a third device special, <FILENAME>/dev/mmem</FILENAME> (note the double &ldquo;m&rdquo;), represents access to only those addresses that are configured in the file <FILENAME>/var/sysgen/master.d/mem</FILENAME>. As distributed, this file is configured to allow access to the free-running timer device and, in some systems, to graphics hardware.</PARAGRAPH>
<PARAGRAPH>For an example of mapped access to physical memory, see the example code in the <REFPAGE>syssgi(2)</REFPAGE> reference page related to the SGI_QUERY_CYCLECNTR option. In this operation, the address of the timer (a device register) is mapped into the process's address space using a TLB entry. When the user process accesses the mapped address, the TLB entry converts it to an address in <ITALICS>kseg1</ITALICS>/<ITALICS>xkphys</ITALICS>, which then bypasses the cache.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Mapped Access Provided by a Device Driver</TITLE><PARAGRAPH>A kernel-level device driver can provide mapped access to device registers or to memory allocated in kernel virtual space. An example of such a driver is shown in <XREF IDREF="19849" TYPE="TITLE">Part III, &ldquo;Kernel-Level Drivers.&rdquo;</XREF></PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Memory Use in Kernel-Level Drivers</TITLE><PARAGRAPH>When you control a device from a kernel-level driver, your code executes in kernel virtual space. The allocation of memory for program text, local (stack) variables, and static global variables is handled automatically by the kernel. Besides designing data structures so they have a consistent size, you have to consider these special cases:<INDEXTARGET ID="01-physmem82"><!-- POSTPROCESSDATA: 01-physmem82|driver:types of:kernel-level --><INDEXTARGET ID="01-physmem83"><!-- POSTPROCESSDATA: 01-physmem83|kernel address space:driver runs in --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>dynamic memory allocation for data and for buffers</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>transferring data between kernel space and user process space</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>getting addresses of device registers to use for PIO</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The kernel supplies utility functions to help you deal with each of these issues, all of which are discussed in <XREF IDREF="31965" TYPE="TITLE">Chapter&nbsp;8, &ldquo;Device Driver/Kernel Interface.&rdquo;</XREF></PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Uncached Memory Access in Origin2000 and in Challenge and Onyx Series</TITLE><PARAGRAPH>Access to uncached memory is not supported in these systems, in which cache coherency is maintained by the hardware, even under access from CPUs and concurrent DMA. There is never a need (and no approved way) to access uncached memory in these systems.<INDEXTARGET ID="01-physmem84"><!-- POSTPROCESSDATA: 01-physmem84|Challenge/Onyx:no uncached memory --><INDEXTARGET ID="01-physmem85"><!-- POSTPROCESSDATA: 01-physmem85|uncached memory access:none in Challenge --></PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="17413">Uncached Memory Access in the IP26 and IP28</TITLE><PARAGRAPH>The IP26 CPU module is used in the Silicon Graphics Power Indigo2 workstation and the Power Challenge M workstation. Both are deskside workstations using the R8000 processor chip. These remarks also apply to the IP28 CPU used in the Power Indigo2 R10000 workstation. In these machines, extra care must be taken in cache management.<INDEXTARGET ID="01-physmem86"><!-- POSTPROCESSDATA: 01-physmem86|CPU:IP26 --><INDEXTARGET ID="01-physmem87"><!-- POSTPROCESSDATA: 01-physmem87|IP26 CPU --><INDEXTARGET ID="01-physmem88"><!-- POSTPROCESSDATA: 01-physmem88|uncached memory access:IP26 --></PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Cache Invalidation and Writeback</TITLE><PARAGRAPH>When an I/O device is going to perform DMA input to memory, the device driver must invalidate any cached copies of the buffer that will receive the data. If this is not done, the CPU could go on using the &ldquo;stale&rdquo; data in the cache, ignoring the input data placed in memory by the device. This is done by calling the <FUNCTION>dki_dcache_inval()</FUNCTION> function to invalidate the range of addresses where DMA input is planned.</PARAGRAPH>
<PARAGRAPH>In the IP28 CPU, the delayed and speculative execution features of the R10000 processor make it necessary for the driver to invalidate the cache twice: once before initiating the DMA input, and once again immediately after DMA ends.</PARAGRAPH>
<PARAGRAPH>Before initiating DMA output, the driver must force all cached data to memory by calling <FUNCTION>dki_dcache_wb()</FUNCTION>. This ensures that recent data in the cache is also present in memory before the device begins to access memory. The use of both these functions is discussed further under <XREF IDREF="65953" TYPE="TITLE">&ldquo;Managing Memory for Cache Coherency&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>Cache invalidation is handled automatically when you use the <FUNCTION>userdma()</FUNCTION> and <FUNCTION>undma()</FUNCTION> functions to lock memory for DMA (see <XREF IDREF="40016" TYPE="TITLE">&ldquo;Setting Up a DMA Transfer&rdquo;</XREF>).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Program Access to Uncached Memory</TITLE><PARAGRAPH>The Indigo2 systems use ECC memory (error-correcting code memory, which can correct for single-bit errors on the fly). ECC memory is also used in large multiprocessor systems from Silicon Graphics, where it has no effect on performance.</PARAGRAPH>
<PARAGRAPH>In the IP26 and IP28, although ECC memory has no impact on the performance of normal, cached memory access, uncached access can be permitted only when the CPU is placed in a special, &ldquo;slow&rdquo; access mode.</PARAGRAPH>
<PARAGRAPH>A device driver may occasionally need to write directly to uncached memory (although it is better to write to cached memory and then use <FUNCTION>dki_dcache_wb()</FUNCTION>). Before doing so, the driver must put the CPU in &ldquo;slow&rdquo; mode by calling the function <FUNCTION>ip26_enable_ucmem()</FUNCTION>. As soon as the uncached store is complete, return the system to &ldquo;fast&rdquo; mode by calling <FUNCTION>ip26_return_ucmem()</FUNCTION>. (See the <REFPAGE>ip26_ucmem(D3)</REFPAGE> reference page.) While the CPU is in &ldquo;slow&rdquo; mode, several clock cycles are added to every memory access, so do not keep it in &ldquo;slow&rdquo; mode any longer than necessary.<INDEXTARGET ID="01-physmem89"><!-- POSTPROCESSDATA: 01-physmem89|kernel functions:<FUNCTION>ip26_enable_ucmem()</FUNCTION> --><INDEXTARGET ID="01-physmem90"><!-- POSTPROCESSDATA: 01-physmem90|kernel functions:<FUNCTION>ip26_return_ucmem()</FUNCTION> --></PARAGRAPH>
<PARAGRAPH>These functions can be called in any system. They do nothing unless the CPU is an IP26 or IP28.</PARAGRAPH>
<PARAGRAPH></PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
</CHAPTER>
