<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="16"><TITLE><XREFTARGET ID="33977">SCSI Device Drivers</TITLE><PARAGRAPH>All Silicon Graphics systems support the small computer systems interface (SCSI) bus for the attachment of disks, tapes, and other devices. This chapter details the kernel-level support for SCSI device drivers.<INDEXTARGET ID="15-scsi1"><!-- POSTPROCESSDATA: 15-scsi1|SCSI bus --></PARAGRAPH>
<PARAGRAPH>If your aim is to control a SCSI device from a user-level process, this chapter contains some useful background information to supplement <XREF IDREF="44062" TYPE="TITLE">Chapter&nbsp;5, &ldquo;User-Level Access to SCSI Devices.&rdquo;</XREF> If you are designing a kernel-level SCSI driver, this chapter contains essential information on kernel support. The major topics in this chapter are as follows:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="71030" TYPE="TITLE">&ldquo;SCSI Support in Silicon Graphics Systems&rdquo;</XREF> gives an overview of the hardware and software support for SCSI.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="96683" TYPE="TITLE">&ldquo;Host Adapter Facilities&rdquo;</XREF> documents the use of the host adapter driver to access a SCSI device.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="76204" TYPE="TITLE">&ldquo;Designing a SCSI Driver&rdquo;</XREF> provides information on how to design a third party SCSI device drivers.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="16890" TYPE="TITLE">&ldquo;SCSI Reference Data&rdquo;</XREF> tabulates SCSI codes and messages for reference.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="78816" TYPE="TITLE">&ldquo;A Note on FibreChannel Drivers&rdquo;</XREF> correlates writing SCSI device Drivers with writing FibreChannel device drivers.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>In addition, you may want to review the following additional sources: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="201"><PARAGRAPH><REFPAGE>intro(7)</REFPAGE> reference page </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="185"><PARAGRAPH>Documents the naming conventions for 
disk and tape device special files.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="201"><PARAGRAPH><REFPAGE>dksc(7)</REFPAGE> reference page </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="185"><PARAGRAPH>Documents the Silicon Graphics disk 
volume partition layout and the <FUNCTION>ioctl</FUNCTION> 
support in the base-level SCSI drivers.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="201"><PARAGRAPH>ANSI <DOCTITLE>X3.131-1986</DOCTITLE> and <DOCTITLE>X3T9.2/85-52 Rev 4B</DOCTITLE>.</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="185"><PARAGRAPH>SCSI standards documents.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="201"><PARAGRAPH><LAUNCHWORD APP="/usr/sbin/nr" PARMS="http://www.abekas.com:8080/SCSI2/">http://scitexdv.com:8080/SCSI2/ </LAUNCHWORD>
</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="185"><PARAGRAPH>Web page containing the complete 
SCSI-2 standard in HTML form.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="201"><PARAGRAPH>master.d/scsi </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="185"><PARAGRAPH>Driver registration tables used for 
registering third party drivers.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="71030">SCSI Support in Silicon Graphics Systems</TITLE><PARAGRAPH>All current Silicon Graphics systems rely on the SCSI bus as the primary attachment for disks and tapes. The IRIX kernel also provides support for OEM drivers for SCSI devices.</PARAGRAPH>
<PARAGRAPH>As used here, the term &ldquo;adapter&rdquo; means a SCSI controller such as the Western Digital W93 chip, which attaches a unique chain of SCSI devices. In this sense, a SCSI adapter and a SCSI bus are the same. &ldquo;Adapter number&rdquo; is used instead of &ldquo;bus number.&rdquo;</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>SCSI Hardware Support</TITLE><PARAGRAPH>The Silicon Graphics computer systems supported by IRIX 6.5 can attach multiple SCSI adapters, as follows:<INDEXTARGET ID="15-scsi2"><!-- POSTPROCESSDATA: 15-scsi2|SCSI bus:hardware support overview --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The Origin2000 and Onyx2 systems have two SCSI controllers on each Base I/O module. Several additional SCSI controllers can be added to each module.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The Origin200 system has two SCSI controllers per chassis and the possibility of optional SCSI controllers using PCI and MSCSI interfaces.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The OCTANE workstation has two SCSI controllers, one for the internal disks and one for the external chain. In addition, PCI and MSCSI controllers can be added.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The Indy workstation has at least one SCSI adapter on its motherboard, and can have up to two additional adapters on a GIO option board.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The Indigo<SUPERSCRIPT>2</SUPERSCRIPT> series supports two SCSI adapters on the motherboard.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The Challenge S system has two SCSI adapters on the motherboard, and can have one or two additional on each of one or two additional GIO option boards, for a maximum of six adapters.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The Challenge M system supports one SCSI adapter on the CPU board and can have up to two additional adapters on a GIO option board.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The Power Channel-2 (IO4) boards used in the Challenge and Onyx series support two SCSI adapters, plus many as six additional SCSI adapters on mezzanine cards, for a maximum of eight adapters per IO4.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>In all systems, DMA mapping hardware allows a SCSI adapter to treat discontiguous memory locations as if they were a contiguous buffer, providing scatter and gather support.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>IRIX Kernel SCSI Support</TITLE><PARAGRAPH>The IRIX kernel contains two levels of SCSI support. An inner SCSI driver, the <INDEXTARGET ID="15-scsi3"><!-- POSTPROCESSDATA: 15-scsi3|SCSI bus:kernel overview --><ITALICS>host adapter driver</ITALICS>, manages all communication with a SCSI hardware adapter. The kernel-level SCSI device driver for a particular device prepares SCSI commands and calls on the host adapter driver to execute them. This design centralizes the management of SCSI adapters. Centralization is necessary because the use of the SCSI bus is shared by many devices, while recovery and error-handling are handled at the adapter level. In addition, use of the host adapter driver makes it simpler to write a SCSI device driver.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Host Adapter Drivers</TITLE><PARAGRAPH>Different host adapter drivers are loaded, depending on the hardware in the system. Some examples of host adapter drivers are <INDEXTARGET ID="15-scsi4"><!-- POSTPROCESSDATA: 15-scsi4|SCSI bus:host adapter --><VARIABLE>wd93</VARIABLE> and <VARIABLE>ql</VARIABLE>.</PARAGRAPH>
<PARAGRAPH>The host adapter drivers support all levels of the SCSI standard: SCSI-1, the Common Command Set (CCS, superceded by SCSI-2), and SCSI-2. Not all optional features of the standard are supported. Different systems support different feature combinations (such as synchronous, fast, and wide SCSI), depending on the available hardware.</PARAGRAPH>
<PARAGRAPH>The host adapter drivers handle the low-level communication over the SCSI interface, such as programming the SCSI interface chip or board, negotiating synchronous or wide mode, and handling disconnect and reconnect.</PARAGRAPH>
<PARAGRAPH>A host adapter driver is not, strictly speaking, a proper device driver because it does not support all the entry points documented in <XREF IDREF="19192" TYPE="TITLE">Chapter&nbsp;7, &ldquo;Structure of a Kernel-Level Driver.&rdquo;</XREF> You can think of it as a specialized library module for SCSI-bus management or as a device driver, whichever you prefer. The software interface to the host adapter driver is documented under <XREF IDREF="96683" TYPE="TITLE">&ldquo;Host Adapter Facilities&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="48208">SCSI Devices in the hwgraph</TITLE><PARAGRAPH>When planning a SCSI device driver, it is informative to spend some time exploring the rather complex network of hwgraph vertexes that is set up by the existing SCSI drivers. Your tools for this are the <INDEXTARGET ID="15-scsi5"><!-- POSTPROCESSDATA: 15-scsi5|hwgraph:use by SCSI driver --><COMMAND>find</COMMAND> and <COMMAND>grep</COMMAND> commands. For example:</PARAGRAPH>
<EXAMPLE>
find /hw -print | grep scsi | grep -v disk
</EXAMPLE>
<PARAGRAPH>The result is voluminous even on a relatively small system and reveals that there are many vertexes created for each logical unit (LUN) on each controller. Here is a sample with repetitions edited out:</PARAGRAPH>
<CODE>
houston 30% find /hw -print | grep scsi | grep -v disk
/hw/module/1/slot/io1/baseio/pci/0/scsi_ctlr
/hw/module/1/slot/io1/baseio/pci/0/scsi_ctlr/0
/hw/module/1/slot/io1/baseio/pci/0/scsi_ctlr/0/bus
/hw/module/1/slot/io1/baseio/pci/0/scsi_ctlr/0/target
/hw/module/1/slot/io1/baseio/pci/0/scsi_ctlr/0/target/1
/hw/module/1/slot/io1/baseio/pci/0/scsi_ctlr/0/target/1/lun
/hw/module/1/slot/io1/baseio/pci/0/scsi_ctlr/0/target/1/lun/0
/hw/module/1/slot/io1/baseio/pci/0/scsi_ctlr/0/target/1/lun/0/scsi
/hw/module/1/slot/io1/baseio/pci/0/scsi_ctlr/0/target/1/lun/1
...
/hw/module/1/slot/io1/baseio/pci/0/scsi_ctlr/0/target/2
...
/hw/module/1/slot/io1/baseio/pci/1/scsi_ctlr
...
/hw/scsi_ctlr
/hw/scsi_ctlr/0
/hw/scsi_ctlr/1
/hw/scsi
/hw/scsi/sc0d1l0
/hw/scsi/sc0d2l0
</CODE>
<SECTION3 LBL="" HELPID = ""><TITLE>Controller Vertexes</TITLE><PARAGRAPH>Paths of the form <FILENAME>/hw/.../scsi_ctlr/...</FILENAME> are hwgraph vertexes that represent SCSI host adapters (controllers) discovered during boot time. Each of these is presented to a host adapter at its <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> entry point (see <XREF IDREF="54429" TYPE="TITLE">&ldquo;Entry Point attach()&rdquo;</XREF>). All the other hwgraph paths that contain the word <FILENAME>scsi</FILENAME> were created by the host adapter driver or by SCSI device drivers (see <XREF IDREF="65256" TYPE="TITLE">&ldquo;Extending the hwgraph&rdquo;</XREF>).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Target Vertexes and LUN Vertexes</TITLE><PARAGRAPH>Paths that contain <FILENAME>scsi_ctlr/</FILENAME><FILENAME>N</FILENAME><FILENAME>/target/</FILENAME><FILENAME>N</FILENAME> were created by the host adapter driver to represent each target that it discovered while probing its bus at attach time. Attached to these are paths containing <FILENAME>lun/</FILENAME><FILENAME>N</FILENAME>, for example:</PARAGRAPH>
<CODE>
/hw/module/1/slot/io1/baseio/pci/0/scsi_ctlr/0/target/1/lun/0/scsi
</CODE>
<PARAGRAPH>Whenever a target is found to have logical units, a vertex is created for each, and when the LUN responds, a character device vertex is created for it.</PARAGRAPH>
<CODE>
ls -l /hw/module/1/slot/io1/baseio/pci/0/scsi_ctlr/0/target/1/lun/0
total 0
drwxr-xr-x    2 root     sys            0 Mar 12 14:30 disk
crw-------    1 root     sys        0,116 Mar 12 14:30 scsi
</CODE>
<PARAGRAPH>The character device <FILENAME>scsi</FILENAME> represents the addressable LUN. The vertex disk was installed by the disk device driver. It is the attachment vertex for a number of device vertexes that represent the parts of a disk volume, such as <FILENAME>disk/partition/1/block</FILENAME> and <FILENAME>disk/partition/1/char</FILENAME>, character and block access to a disk (see <XREF IDREF="59531" TYPE="TITLE">&ldquo;Block and Character Device Access&rdquo;</XREF>).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="40257">Convenience Vertexes</TITLE><PARAGRAPH>In addition to the lengthy pathnames, there are shortcut names:</PARAGRAPH>
<CODE>
% ls -l /hw/scsi
total 0
crw-------    1 root     sys        0,116 Mar 12 14:41 sc0d1l0
crw-------    1 root     sys        0,133 Mar 12 14:41 sc0d2l0
crw-------    1 root     sys        0,150 Mar 12 14:41 sc0d3l0
crw-------    1 root     sys        0,167 Mar 12 14:41 sc0d4l0
crw-------    1 root     sys        0,184 Mar 12 14:41 sc0d5l0
</CODE>
<PARAGRAPH>These were created by the SCSI driver as shortcut links to the <FILENAME>lun/</FILENAME><FILENAME>N</FILENAME><FILENAME>/scsi</FILENAME> vertexes, as you can verify with the <COMMAND>-S</COMMAND> option of <COMMAND>ls</COMMAND>: </PARAGRAPH>
<CODE>
% ls -S /hw/scsi/sc0d1l0
/hw/scsi/sc0d1l0 ->
/hw/module/1/slot/io1/baseio/pci/0/scsi_ctlr/0/target/1/lun/0/scsi
</CODE>
<PARAGRAPH>In the system used to create this example, a second SCSI controller exists but has no LUNs. If it had LUNs, there would be shortcut names <FILENAME>sc1d1l0</FILENAME> and so forth in <FILENAME>/hw/scsi</FILENAME>, as well.</PARAGRAPH>
<PARAGRAPH>At boot time, the host adapter driver creates a vertex and adds an edge labelled &ldquo;scsi&rdquo; from the root vertex to the new vertex. The <COMMAND>ioconfig</COMMAND> command (see <XREF IDREF="83505" TYPE="TITLE">&ldquo;Using ioconfig for Global Controller Numbers&rdquo;</XREF>) then adds edges from it labelled &ldquo;sc0d1l0,&rdquo; &ldquo;sc0d2l0,&rdquo; and so forth, each ending at one of the<FILENAME>&space;lun/N/scsi</FILENAME> vertexes.</PARAGRAPH>
<PARAGRAPH>Although it is created dynamically, the shortcut name <FILENAME>/hw/scsi</FILENAME> is the target of a symbolic link in <FILENAME>/dev</FILENAME>. Thus all convenience links such as <FILENAME>/hw/scsi/sc0d1l0</FILENAME> can also be addressed as <FILENAME>/dev/scsi/sc0d1l0</FILENAME> and so on.</PARAGRAPH>
<CODE>
ls -l /dev/scsi
lrwxr-xr-x    1 root     sys            8 Jan 10 15:33 /dev/scsi->/hw/scsi
% ls -l /dev/scsi/sc0d1l0
crw-------    1 root     sys        0,116 Mar 12 15:21 /dev/scsi/sc0d1l0
</CODE>
<PARAGRAPH>Additional convenience vertexes are created to point to the controllers themselves. These can be used by <COMMAND>scsiha</COMMAND> to pass requests to the scsi host adapter drivers to perform activities that aren't related to the SCSI commands (see <REFPAGE>scsiha(7M)</REFPAGE> and <REFPAGE>scsiha(1M)</REFPAGE>.</PARAGRAPH>
<CODE>
% ls -l /hw/scsi_ctlr
total 0
lrw-------    1 root     sys           47 Mar 12 14:42 0 ->
/hw/module/1/slot/io1/baseio/pci/0/scsi_ctlr/0
lrw-------    1 root     sys           47 Mar 12 14:42 1 ->
/hw/module/1/slot/io1/baseio/pci/1/scsi_ctlr/0
</CODE>
<PARAGRAPH>These were also created by <COMMAND>ioconfig</COMMAND> for each of the controller vertexes (controller 0 in PCI slot 0, later controller 0 in PCI slot 1). When they were created, the driver:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Created a vertex.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Added an edge from the root vertex with the label &ldquo;scsi_ctlr,&rdquo; ending at the new vertex.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Added an edge labelled &ldquo;0&rdquo; from that vertex ending at the controller vertex.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>The next time the driver found the <FILENAME>/hw/scsi_ctlr</FILENAME> edge already existed, and only added the new edge &ldquo;1&rdquo; pointing to its controller vertex.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Disk Driver Vertexes</TITLE><PARAGRAPH>Bring more command-line utilities to bear on the task of displaying the vertexes built by the disk device driver:</PARAGRAPH>
<CODE>
% find /hw -print | grep scsi | grep disk | \
sed `s/hw.*_ctlr/.../' | more
/.../0/target/1/lun/0/disk
/.../0/target/1/lun/0/disk/volume
/.../0/target/1/lun/0/disk/volume/char
/.../0/target/1/lun/0/disk/volume_header
/.../0/target/1/lun/0/disk/volume_header/block
/.../0/target/1/lun/0/disk/volume_header/char
/.../0/target/1/lun/0/disk/partition
/.../0/target/1/lun/0/disk/partition/0
/.../0/target/1/lun/0/disk/partition/0/block
/.../0/target/1/lun/0/disk/partition/0/char
/.../0/target/1/lun/0/disk/partition/1
/.../0/target/1/lun/0/disk/partition/1/block
/.../0/target/1/lun/0/disk/partition/1/char
/.../0/target/2/lun/0/disk
...
</CODE>
<PARAGRAPH>These names are created dynamically, but at a slightly different time. The names reflect the actual layout of the disk volume. For example, a disk could be reformatted to have more or fewer partitions. The disk device driver removes and rebuilds all the names that depend on the volume format (such as ...<FILENAME>/lun/0/disk/partition/0/block</FILENAME>) each time the disk volume header is read into memory. That normally occurs only the first time the disk is opened&mdash;which is usually done by <COMMAND>ioconfig</COMMAND>.</PARAGRAPH>
<PARAGRAPH>Note that similar to the creation and removal of hwgraph entries by the host adapter driver, a third-party SCSI device driver must also create and remove hwgraph entries as described in <XREF IDREF="76204" TYPE="TITLE">&ldquo;Designing a SCSI Driver&rdquo;</XREF>. </PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Hardware Administration</TITLE><PARAGRAPH>Some bus protocol features such as connect and disconnect are controlled by configuration files that are used by the host adapter drivers. For example, the <FILENAME>wd93</FILENAME> driver has a number of configurable options coded in the descriptive file <FILENAME>/var/sysgen/master.d</FILENAME> (for the format of descriptive files, see <XREF IDREF="71839" TYPE="TITLE">&ldquo;Describing the Driver in /var/sysgen/master.d&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>The QLogic driver <FILENAME>ql</FILENAME> takes its options by the more modern route of the DEVICE_ADMIN statement (see <XREF IDREF="58068" TYPE="TITLE">&ldquo;Storing Device and Driver Attributes&rdquo;</XREF> and <XREF IDREF="57823" TYPE="TITLE">&ldquo;Retrieving Administrator Attributes&rdquo;</XREF>). You can peruse <FILENAME>/var/sysgen/system/irix.sm</FILENAME> to see DEVICE_ADMIN statements addressed to &ldquo;ql_&rdquo; and associated comments.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>The connect/disconnect strategy is enabled on any SCSI bus by default (the option is controlled by a constant defined in the host adapter driver descriptive file in <FILENAME>/var/sysgen/master.d</FILENAME>). When disconnect is enabled on a bus, and a device on that bus refuses to disconnect, it can cause timeouts on other devices.</NOTE>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="96683">Host Adapter Facilities</TITLE><PARAGRAPH>The principal difference between a SCSI driver and other kernel-level drivers is that, while other kinds of drivers are expected to control devices directly using PIO and DMA, a SCSI driver operates its devices indirectly, by making function calls to the host adapter driver. This section documents the functional interface to the host adapter driver.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Purpose of the Host Adapter Driver</TITLE><PARAGRAPH>IRIX uses host adapter drivers because the SCSI bus is shared among multiple devices of different types, each type controlled by a different driver. A disk, a tape, a CDROM, and a scanner could all be cabled from the same SCSI adapter. Each device has a different driver, but each driver needs to use the adapter, a single chip-set, to communicate with its device.<INDEXTARGET ID="15-scsi6"><!-- POSTPROCESSDATA: 15-scsi6|SCSI bus:host adapter:purpose --></PARAGRAPH>
<PARAGRAPH>If IRIX allowed multiple drivers to operate the host adapter, there would be confusion and errors from the conflicting uses. IRIX puts the management of each host adapter under the control of a host adapter driver, whose job is to issue commands on its bus and report the results. The host adapter driver is tailored to the hardware of the particular host adapter and to the architecture of the host system.</PARAGRAPH>
<PARAGRAPH>The interface to the host adapter driver is the same no matter what type of hardware the adapter uses. This insulates the individual device drivers from details of the adapter hardware.</PARAGRAPH>
<PARAGRAPH>The driver for each type of device is responsible for preparing the SCSI command bytes for its device, for passing the command requests to the correct host adapter driver, and for interpreting sense and status data as it comes back.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="21920">Host Adapter Concepts</TITLE><PARAGRAPH>The host adapter driver is the driver that is called by the kernel to attach the SCSI controller at boot time while the kernel is exploring the hardware and building the hwgraph (see <XREF IDREF="54429" TYPE="TITLE">&ldquo;Entry Point attach()&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>The host adapter driver places information in the hwgraph vertex that represents the controller, and extends the hwgraph with subordinate vertexes that represent targets and LUNs (see <XREF IDREF="48208" TYPE="TITLE">&ldquo;SCSI Devices in the hwgraph&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>A SCSI driver is called to manage one or more SCSI target devices. Each target is physically connected to a SCSI adapter. The hwgraph echoes this connectivity: the SCSI target vertex is connected to the SCSI adapter vertex. Thus when the SCSI driver knows its target device vertex, it can access the corresponding host adapter vertex, and through this vertex, can invoke the host adapter driver.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Target Numbers</TITLE><PARAGRAPH>The purpose of a host adapter driver is to carry communications between a SCSI driver and a <INDEXTARGET ID="15-scsi7"><!-- POSTPROCESSDATA: 15-scsi7|SCSI bus:target number --><ITALICS>target</ITALICS>. A target is a device on the SCSI chain that responds to SCSI commands. A target can be a single device, or it can be a controller that in turn manages other devices.</PARAGRAPH>
<PARAGRAPH>A target is identified by a number between 0 and 15. Normally this number is configured into the device with switches or jumpers. The SCSI controller itself has a target number (usually number 0), but it cannot be used as a target.</PARAGRAPH>
<PARAGRAPH>The SCSI device driver needs to know the number of its target in order to format a request structure. The target number is accessible from the target vertex, as shown under <XREF IDREF="53006" TYPE="TITLE">&ldquo;Using the Function Vector Macros&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Logical Unit Numbers (LUNs)</TITLE><PARAGRAPH>When the target is a controller, it manages one or more subdevices, each one a <INDEXTARGET ID="15-scsi8"><!-- POSTPROCESSDATA: 15-scsi8|SCSI bus:LUN --><ITALICS>logical unit</ITALICS> of that target. The logical unit being addressed is identified by a logical unit number (LUN). When the target is a single device, its LUN is 0.</PARAGRAPH>
<PARAGRAPH>A SCSI device driver needs the unit number of a device when it formats a request structure. The unit number is accessible from the vertex for the LUN, as shown under <XREF IDREF="53006" TYPE="TITLE">&ldquo;Using the Function Vector Macros&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="33200">Overview of Host Adapter Functions</TITLE><PARAGRAPH>Each host adapter driver provides the same functional interface and supports the four functions listed in <INDEXTARGET ID="15-scsi9"><!-- POSTPROCESSDATA: 15-scsi9|SCSI bus:host adapter:functions of --><XREF IDREF="44952" TYPE="TABLE">Table&nbsp;16-1</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="16-1"><PREFIX>Table 16-1 </PREFIX><XREFTARGET ID="44952"> <EMPHASIS>(continued)        </EMPHASIS>Host Adapter Function Summary</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="96"><PARAGRAPH>&lbreak;Function</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="45"><PARAGRAPH>Header 
Files</PARAGRAPH>
</CELL>
<CELL LEFT="155" WIDTH="245"><PARAGRAPH>&lbreak;Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="96"><PARAGRAPH><REFPAGE>scsi_info(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="45"><PARAGRAPH>scsi.h</PARAGRAPH>
</CELL>
<CELL LEFT="155" WIDTH="245"><PARAGRAPH>Issue the SCSI Inquiry command and return the results.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="96"><PARAGRAPH><REFPAGE>scsi_alloc(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="45"><PARAGRAPH>scsi.h</PARAGRAPH>
</CELL>
<CELL LEFT="155" WIDTH="245"><PARAGRAPH>Open a connection between a driver and a target device.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="96"><PARAGRAPH><REFPAGE>scsi_free(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="45"><PARAGRAPH>scsi.h</PARAGRAPH>
</CELL>
<CELL LEFT="155" WIDTH="245"><PARAGRAPH>Release connection to a target device.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="96"><PARAGRAPH><REFPAGE>scsi_command(D3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="45"><PARAGRAPH>scsi.h</PARAGRAPH>
</CELL>
<CELL LEFT="155" WIDTH="245"><PARAGRAPH>Transmit a SCSI command on the bus and return results.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="96"><PARAGRAPH>scsi_abort()</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="45"><PARAGRAPH>scsi.h</PARAGRAPH>
</CELL>
<CELL LEFT="155" WIDTH="245"><PARAGRAPH>Transmit a SCSI ABORT command (no reference page).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="96"><PARAGRAPH>scsi_ioctl() </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="45"><PARAGRAPH>scsi.h </PARAGRAPH>
</CELL>
<CELL LEFT="155" WIDTH="245"><PARAGRAPH>Implement arbitrary control operations.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="96"><PARAGRAPH>scsi_dump() </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="45"><PARAGRAPH>scsi.h </PARAGRAPH>
</CELL>
<CELL LEFT="155" WIDTH="245"><PARAGRAPH>Called by the kernel to notify the host adapter driver that the 
kernel is shutting down for a panic dump, and that 
subsequent operations will be for writing the dump and 
other diagnostic files, and should be performed 
synchronously.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<NOTE><PREFIX>Note</PREFIX>The <FUNCTION>scsi_reset()</FUNCTION> function that formerly existed has been removed. </NOTE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>How the Host Adapter Functions Are Found</TITLE><PARAGRAPH>A SCSI device driver can be asked to manage devices on different adapters. Different adapters may use the same or different hardware, and be managed by the same or different host adapter drivers. How does the driver locate the correct host adapter function for a given device?<INDEXTARGET ID="15-scsi10"><!-- POSTPROCESSDATA: 15-scsi10|SCSI bus:host adapter:vectors to --></PARAGRAPH>
<PARAGRAPH>The answer is that each host adapter driver places a set of vectors to its functions in the hwgraph vertex for the controller. Using macros defined in <FILENAME>sys/scsi.h</FILENAME>, the driver invokes the function it needs indirectly, by way of pointers stored in the controller vertex.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Vertex Information Structures</TITLE><PARAGRAPH>The host adapter driver constructs the arrangement of hwgraph vertexes and data structures illustrated in <XREF IDREF="77645" TYPE="GRAPHIC">Figure&nbsp;16-1</XREF>.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="15-scsi.hwgraph.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="16-1"><PREFIX>Figure 16-1 </PREFIX><XREFTARGET ID="77645">SCSI Vertexes and Data Structures</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>The main features of this arrangement are as follows:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The vertex for the controller anchors a <VARIABLE>scsi_ctlr_info_t</VARIABLE>, which contains the vectors to the host adapter functions.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The vertex for any target anchors a <VARIABLE>scsi_targ_info_t</VARIABLE>, which contains the target number and a pointer to the <VARIABLE>scsi_ctlr_info_t</VARIABLE> for that target's controller.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The vertex for any LUN anchors a <VARIABLE>scsi_lun_info_t</VARIABLE>, which contains the unit number and a pointer to the <VARIABLE>scsi_targ_info_t</VARIABLE> for that LUN's target.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="53006">Using the Function Vector Macros</TITLE><PARAGRAPH>A device driver, given a handle to a vertex for a LUN, a target, or a controller, can always access the vectors to the host adapter functions. These connections are used by macros defined in <FILENAME>sys/scsi.h</FILENAME>, as listed in <XREF IDREF="99706" TYPE="TABLE">Table&nbsp;16-2</XREF>. </PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="16-2"><PREFIX>Table 16-2 </PREFIX><XREFTARGET ID="99706"> <EMPHASIS>(continued)        </EMPHASIS>Macro Access to SCSI Information</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Desired Datum</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="108"><PARAGRAPH>scsi_ctlr_info_t *pci</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="122"><PARAGRAPH>scsi_targ_info_t *pti</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="122"><PARAGRAPH>scsi_lun_info_t *pli</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>adapter number</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="108"><PARAGRAPH>SCI_ADAP(pci)</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="122"><PARAGRAPH>SCI_ADAP(&lbreak;STI_CTLR_INFO(pti))</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="122"><PARAGRAPH>SLI_ADAP(pli)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>adapter vertex</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="108"><PARAGRAPH>SCI_CTLR_VHDL(pci)</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="122"><PARAGRAPH>SCI_CTLR_VHDL(&lbreak;STI_CTLR_INFO(pti))</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="122"><PARAGRAPH>SLI_CTLR_VHDL(pli)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>target number</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="108"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="122"><PARAGRAPH>STI_TARG(pti)</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="122"><PARAGRAPH>SLI_TARG(pli)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>target vertex</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="108"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="122"><PARAGRAPH>STI_TARG_VHDL(pti)</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="122"><PARAGRAPH>STI_TARG_VHDL(&lbreak;SLI_TARG_INFO(pli))</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>unit number</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="108"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="122"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="122"><PARAGRAPH>SLI_LUN(pli)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>LUN vertex</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="108"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="122"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="122"><PARAGRAPH>SLI_LUN_VHDL(pli)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>scsi_abort()</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="108"><PARAGRAPH>SCI_ABORT(pci)</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="122"><PARAGRAPH>SCI_ABORT(&lbreak;STI_CTLR_INFO(pti))</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="122"><PARAGRAPH>SCI_ABORT(&lbreak;SLI_CTLR_INFO(pli))</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>scsi_alloc()</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="108"><PARAGRAPH>SCI_ALLOC(pci)()</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="122"><PARAGRAPH>SCI_ALLOC(&lbreak;STI_CTLR_INFO(pti))</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="122"><PARAGRAPH>SCI_ALLOC(&lbreak;SLI_CTLR_INFO(pli))</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>scsi_command()</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="108"><PARAGRAPH>SCI_COMMAND(pci)()</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="122"><PARAGRAPH>SCI_COMMAND(&lbreak;STI_CTLR_INFO(pti))</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="122"><PARAGRAPH>SCI_COMMAND(&lbreak;SLI_CTLR_INFO(pli))</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>scsi_free()</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="108"><PARAGRAPH>SCI_FREE(pci)()</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="122"><PARAGRAPH>SCI_FREE(&lbreak;STI_CTLR_INFO(pti))</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="122"><PARAGRAPH>SCI_FREE(&lbreak;SLI_CTLR_INFO(pli))</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>scsi_icoctl</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="108"><PARAGRAPH>SCI_IOCTL(pci)</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="122"><PARAGRAPH>SCI_IOCTL(&lbreak;STI_CTLR_INFO(pti))</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="122"><PARAGRAPH>SCI_IOCTL(&lbreak;SLI_CTLR_INFO(pli))</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>scsi_info()</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="108"><PARAGRAPH>SCI_INQ(pci)()</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="122"><PARAGRAPH>SCI_INQ(&lbreak;STI_CTLR_INFO(pti))</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="122"><PARAGRAPH>SCI_INQ(</PARAGRAPH>
<PARAGRAPH>SLI_CTRL_INFO(pli)</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Study the macro definitions in <FILENAME>sys/scsi.h</FILENAME>&mdash;for example, the definition of SLI_ALLOC, with reference to the arrangement shown in <XREF IDREF="77645" TYPE="GRAPHIC">Figure&nbsp;16-1</XREF>&mdash;to see the pattern. Additional macros can be defined using the same pattern.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="86789">Using scsi_info()</TITLE><PARAGRAPH>Before a SCSI driver tries to access a device, it must call the host adapter <INDEXTARGET ID="15-scsi11"><!-- POSTPROCESSDATA: 15-scsi11|SCSI bus:command:Inquiry --><INDEXTARGET ID="15-scsi12"><!-- POSTPROCESSDATA: 15-scsi12|SCSI bus:host adapter:<FUNCTION>scsi_info</FUNCTION>() --><FUNCTION>scsi_info()</FUNCTION> function, passing the vertex handle for the LUN. This function issues an Inquiry command to the adapter, target, and logical unit. If the Inquiry is not successful&mdash;or if the adapter, target, or LUN are not valid&mdash;the return value is NULL. Otherwise, the return value is a pointer to a <VARIABLE>scsi_target_info</VARIABLE> structure.<INDEXTARGET ID="15-scsi13"><!-- POSTPROCESSDATA: 15-scsi13|data types:struct scsi_target_infodata types:scsi_tar --></PARAGRAPH>
<PARAGRAPH>The SCSI driver can learn the following things from a call to <FUNCTION>scsi_info()</FUNCTION>:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>If the return is NULL, there is a serious problem with the device or the information about it. Write a descriptive log message with <FUNCTION>cmn_err()</FUNCTION> and return ENODEV.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The <VARIABLE>si_inq</VARIABLE> field points to the Inquiry bytes returned by the device. Examine them for device-dependent information.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The value in <VARIABLE>si_maxq</VARIABLE> is the default limit on pending SCSI commands that can be queued to this host adapter driver. (You can specify a higher limit to <FUNCTION>scsi_alloc()</FUNCTION>.)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Test the bits in <VARIABLE>si_ha_status</VARIABLE> for information about the capabilities and error status of the host adapter itself. The possible bits are declared in <FILENAME>sys/scsi.h</FILENAME>. For example, SRH_NOADAPSYNC indicates that the specified target, or possibly the host adapter itself, does not support synchronous transfer. Not all bits are supported by all host adapter drivers.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>You can also call <FUNCTION>scsi_info()</FUNCTION> at other times; some of the returned information can be useful in error recovery. However, be aware that <FUNCTION>scsi_info()</FUNCTION> for some host adapters is slow, and can use serialized access to hardware. (See also reference page <REFPAGE>scsi_info(d3x)</REFPAGE>.)</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="42391">Using scsi_alloc()</TITLE><PARAGRAPH>Depending on its particular design, the host adapter driver may need to allocate memory for data structures, DMA maps, or buffers for sense and inquiry data, before it is ready to execute commands to a particular target. The call to <INDEXTARGET ID="15-scsi14"><!-- POSTPROCESSDATA: 15-scsi14|SCSI bus:host adapter:<FUNCTION>scsi_alloc</FUNCTION>() --><FUNCTION>scsi_alloc()</FUNCTION> gives the host adapter driver the opportunity to prepare in these ways. (See also reference page <REFPAGE>scsi_alloc(d3x)</REFPAGE>.)</PARAGRAPH>
<PARAGRAPH>Because the host adapter driver may allocate virtual memory, it may sleep. Some host adapter drivers allocate all the resources they need on the first call to <FUNCTION>scsi_alloc()</FUNCTION> and do little or nothing on subsequent calls.</PARAGRAPH>
<PARAGRAPH>A call to <FUNCTION>scsi_alloc()</FUNCTION> specifies these parameters: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>lun_vhdl </VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="270"><PARAGRAPH>Vertex handle of the LUN, from which the target and 
controller can be identified.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><VARIABLE>option</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="270"><PARAGRAPH>An integer comprising two parameters, a flag, and a count.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><VARIABLE>callback</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="270"><PARAGRAPH>Address of a function to be called whenever sense data is 
gotten from the device.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The option parameter may include the SCSIALLOC_EXCLUSIVE flag to request exclusive use of the target. If another driver has allocated a path to the same device, <FUNCTION>scsi_alloc()</FUNCTION> returns EBUSY. For example, a tape device driver might require exclusive access, while a disk device driver would not.</PARAGRAPH>
<PARAGRAPH>The option parameter may include SCSIALLOC_NOSYNC to specify that this device should not, or cannot, use synchronous transfer mode. That setting can be overridden for single commands by a flag to <FUNCTION>scsi_command()</FUNCTION> (see <XREF IDREF="32345" TYPE="TABLE">Table&nbsp;16-4</XREF>).</PARAGRAPH>
<PARAGRAPH>The option parameter can also include a small integer value indicating the maximum queue depth (the number of SCSI commands the driver would like to start before any have completed). The call to <FUNCTION>scsi_info()</FUNCTION> returns the default queue depth that will be used if you do not pass a nonzero value here (typically the default is 1).</PARAGRAPH>
<PARAGRAPH>The callback function address can be specified as NULL. The specified callback function is called only when sense data is gotten from the allocated device (regardless of which driver initiated the command that resulted in sense data). Only one driver that allocates a path to a device can specify a callback function. If the path is not held exclusively, any other drivers must specify a null address for their callback functions.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="31474">Using scsi_free()</TITLE><PARAGRAPH>A SCSI driver typically calls <INDEXTARGET ID="15-scsi15"><!-- POSTPROCESSDATA: 15-scsi15|SCSI bus:host adapter:<FUNCTION>scsi_free</FUNCTION>() --><FUNCTION>scsi_free()</FUNCTION> from the <VARIABLE>pfx</VARIABLE><FUNCTION>close()</FUNCTION> entry point. That is the time when the driver knows that no processes have the device open, so the host adapter should be allowed to release any resources it is holding just for this device.</PARAGRAPH>
<PARAGRAPH>In addition, <FUNCTION>scsi_free()</FUNCTION> releases the device for use by other drivers, if the driver had allocated it for exclusive use.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="91892">Using scsi_command()</TITLE><PARAGRAPH>A SCSI device driver sends SCSI commands to its device by storing information in a <INDEXTARGET ID="15-scsi16"><!-- POSTPROCESSDATA: 15-scsi16|data types:scsi_request --><INDEXTARGET ID="15-scsi17"><!-- POSTPROCESSDATA: 15-scsi17|SCSI bus:host adapter:<FUNCTION>scsi_command</FUNCTION>() --><VARIABLE>scsi_request</VARIABLE> structure and passing the structure to the <FUNCTION>scsi_command()</FUNCTION> function for the adapter. The host adapter driver schedules the command on the SCSI bus that it manages, and returns to the caller. When the command completes, a notify function is invoked. (See also reference page <REFPAGE>scsi_command(d3x)</REFPAGE>.)</PARAGRAPH>
<TIP><PREFIX>Tip</PREFIX>When debugging a driver using a debugging kernel (see <XREF IDREF="86033" TYPE="TITLE">&ldquo;Preparing the System for Debugging&rdquo;</XREF>), you can display the contents of a <VARIABLE>scsi_request</VARIABLE> structure using <COMMAND>symmon</COMMAND> or <COMMAND>idbg</COMMAND> (see <XREF IDREF="98444" TYPE="TITLE">&ldquo;Commands to Display I/O Status&rdquo;</XREF>).</TIP>
<SECTION3 LBL="" HELPID = ""><TITLE>Input to scsi_command()</TITLE><PARAGRAPH>The device driver prepares the <VARIABLE>scsi_request</VARIABLE> fields shown in <XREF IDREF="44379" TYPE="TABLE">Table&nbsp;16-3</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="16-3"><PREFIX>Table 16-3 </PREFIX><XREFTARGET ID="44379"> <EMPHASIS>(continued)        </EMPHASIS>Input Fields of the scsi_request Structure</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Field Name</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Contents</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>sr_dev_vhdl</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>The vertex handle of the LUN vertex. This field is required.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>sr_ctlr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>The adapter number.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>sr_target</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>The target number.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>sr_lun</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>The logical unit number.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>sr_tag</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>If this target supports the SCSI-2 tagged-queue feature, and this command is 
directed to a queue, this field contains the queue tag message. Constant names 
for queue messages are in <FILENAME>sys/scsi.h</FILENAME>: SC_TAG_SIMPLE and two others.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>sr_command</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Address of the bytes of the SCSI command to issue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>sr_cmdlen</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>The length of the string at <VARIABLE>*sr_command</VARIABLE>. Constants for the common lengths are in 
<FILENAME>sys/scsi.h</FILENAME>: SC_CLASS0_SZ (6), SC_CLASS1_SZ (10), and SC_CLASS2_SZ (12).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>sr_flags</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Flags for data direction and DMA mapping; see <XREF IDREF="32345" TYPE="TABLE">Table&nbsp;16-4</XREF>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>sr_timeout</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Number of ticks (HZ units) to wait for a response before timing out. The host 
adapter driver supplies a minimum value if this field is zero or too small.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>sr_buffer</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Address of first byte of data. Must be zero when <VARIABLE>sr_bp</VARIABLE> is supplied and 
SRF_MAPBP is specified in <VARIABLE>sr_flags</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>sr_buflen</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Length of data or buffer space.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>sr_sense</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Address of space for sense data, in case the command ends in a check condition.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>sr_senselen</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Length of the sense area.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>sr_notify</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Address of the callback function, called when the command is complete. A 
callback address is required on all commands (this is a change in IRIX 6.4).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>sr_bp</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Address of a <VARIABLE>buf_t</VARIABLE> object, when the command is called from a block driver's 
<VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>strategy</FUNCTION><FUNCTION>()</FUNCTION> entry point and buffer mapping is requested in <VARIABLE>sr_flags</VARIABLE>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>sr_dev</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Address of additional information that could be useful in the callback routine 
<VARIABLE>*sr_notify</VARIABLE>.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Although the unit, target, and controller numbers can be discovered from the handle in <VARIABLE>sr_dev_vhdl</VARIABLE>, this would be time-consuming. Therefore the driver is still required to provide all three numbers in addition to the handle.</PARAGRAPH>
<PARAGRAPH>The callback function address in <VARIABLE>sr_notify</VARIABLE> must be specified. (Device drivers for versions of IRIX previous to 6.4 may set a NULL in this field; that is no longer permitted.)</PARAGRAPH>
<PARAGRAPH>The possible flag bits that can be set in <VARIABLE>sr_flags</VARIABLE> are listed in <XREF IDREF="32345" TYPE="TABLE">Table&nbsp;16-4</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="16-4"><PREFIX>Table 16-4 </PREFIX><XREFTARGET ID="32345"> <EMPHASIS>(continued)        </EMPHASIS>Values for the sr_flags Field of a scsi_request</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="122"><PARAGRAPH>Flag Constant</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="266"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="122"><PARAGRAPH>SRF_DIR_IN</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="266"><PARAGRAPH>Data will be received in memory. If this flag is absent, the 
command sends data from memory to the device.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="122"><PARAGRAPH>SRF_FLUSH</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="266"><PARAGRAPH>The data cache for the buffer area should be flushed (for output) 
or marked invalid (for input) prior to the command. This flag 
should be used whenever the buffer is local to the driver, not 
mapped by a <VARIABLE>buf_t</VARIABLE> object. It causes no extra overhead in systems 
that do not require cache flushing.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="122"><PARAGRAPH>SRF_MAPUSER</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="266"><PARAGRAPH>Set this flag when doing I/O based on a <VARIABLE>buf_t</VARIABLE> and B_MAPUSER is 
set in <VARIABLE>b_flags</VARIABLE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="122"><PARAGRAPH>SRF_MAP</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="266"><PARAGRAPH>Set this flag when doing I/O based on a <ITALICS>buf_t</ITALICS> and the 
BP_ISMAPPED macro returns nonzero.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="122"><PARAGRAPH>SRF_MAPBP</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="266"><PARAGRAPH>The <VARIABLE>sr_bp</VARIABLE> field points to a <VARIABLE>buf_t</VARIABLE> in which BP_ISMAPPED returns 
false. The host adapter driver maps in the buffer.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="122"><PARAGRAPH>SRF_CONTINGENT_&lbreak;ALLEGIANCE_CLEAR </PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="266"><PARAGRAPH>Indicates that the driver wishes to clear a contingent allegiance 
condition with the host adapter driver. After a host adapter driver 
has returned sense data to the device driver, all future requests are 
immediately returned with SC_ATTN until this flag is set.</PARAGRAPH>
<PARAGRAPH>SRF_AEN_ACK is a synonym that may appear in older code.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="122"><PARAGRAPH>SRF_NEG_SYNC</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="266"><PARAGRAPH>Attempt to negotiate synchronous transfer mode for this 
command. Ignored by some host adapter drivers. Overrides 
SCSIALLOC_NOSYNC (see <XREF IDREF="42391" TYPE="TITLE">&ldquo;Using scsi_alloc()&rdquo;</XREF>).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="122"><PARAGRAPH>SRF_NEG_ASYNC</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="266"><PARAGRAPH>Attempt to negotiate asynchronous mode for this command. 
Ignored unless the device is currently using synchronous mode.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="122"><PARAGRAPH>SRF_ALENLIST</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="266"><PARAGRAPH>Set this flag and then set <VARIABLE>b_private</VARIABLE> to use the <VARIABLE>alenlist</VARIABLE> created&mdash;use 
<COMMAND>uvaddr_to_alenlist</COMMAND> to create the alenlist (see <REFPAGE>alenlist_ops(D3)</REFPAGE>).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="122"><PARAGRAPH>SRF_PRIORITY_REQUEST </PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="266"><PARAGRAPH>Set this flag for a &ldquo;priority&rdquo; SCSI request (see <FILENAME>scsi.h</FILENAME>).</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>When none of the three flag values beginning SRF_MAP is supplied, the <VARIABLE>sr_buffer</VARIABLE> address must be a physical memory address. The SRF_MAPUSER and SRF_MAPBP flags are normally used when the command is issued from a <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> entry point in order to read or write a buffer controlled from a <VARIABLE>buf_t</VARIABLE> object.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Command Execution</TITLE><PARAGRAPH>The host adapter driver validates the contents of the <VARIABLE>scsi_request</VARIABLE> structure. If the contents are valid, it queues the command for transmission on the adapter and returns. If the contents are invalid, it sets a status flag (see <XREF IDREF="35917" TYPE="TABLE">Table&nbsp;16-6</XREF>), calls the <VARIABLE>sr_notify</VARIABLE> function, and returns.</PARAGRAPH>
<PARAGRAPH>In any event, the <VARIABLE>sr_notify</VARIABLE> function is called when the command is complete. This function can be called from the host adapter interrupt handler, so it can be entered asynchronously and concurrent with any part of the device driver.</PARAGRAPH>
<PARAGRAPH>The device driver should wait for the notify function to be called. The usual way is to share a semaphore (see <XREF IDREF="42679" TYPE="TITLE">&ldquo;Semaphores&rdquo;</XREF>), as follows:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Before calling <FUNCTION>scsi_command()</FUNCTION>, initialize the semaphore to 0 (the semaphore is being used to wait for an event).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Immediately after the call to <FUNCTION>scsi_command()</FUNCTION>, call <FUNCTION>psema()</FUNCTION> for the semaphore.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>In the notify function, call <FUNCTION>vsema()</FUNCTION> for the semaphore.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>If the request is valid, the device driver will sleep in the <FUNCTION>psema()</FUNCTION> call until the command completes. If the request is invalid, the semaphore may already have been posted when the call to <FUNCTION>psema()</FUNCTION> is reached.</PARAGRAPH>
<PARAGRAPH>In the event that the device driver holds an exclusive lock before issuing the command and wants to release the lock while it waits and then regain the lock, a synchronization variable provides the appropriate mechanism (see <XREF IDREF="41132" TYPE="TITLE">&ldquo;Using Synchronization Variables&rdquo;</XREF>).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Values Returned in a scsi_request Structure</TITLE><PARAGRAPH>The host adapter driver sets the results of the request in the <VARIABLE>scsi_request</VARIABLE> structure. The <VARIABLE>sr_notify</VARIABLE> function is the first to inspect the values summarized in <XREF IDREF="92787" TYPE="TABLE">Table&nbsp;16-5</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="16-5"><PREFIX>Table 16-5 </PREFIX><XREFTARGET ID="92787"> <EMPHASIS>(continued)        </EMPHASIS>Values Returned From a SCSI Command</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Field Name</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>sr_status</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Software status flags, see <XREF IDREF="35917" TYPE="TABLE">Table&nbsp;16-6</XREF>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>sr_scsi_status</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>SCSI status byte, see <XREF IDREF="86815" TYPE="TABLE">Table&nbsp;16-7</XREF>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>sr_ha_flags</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Host adapter status flags, see <XREF IDREF="76456" TYPE="TABLE">Table&nbsp;16-8</XREF>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>sr_sensegotten</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>When no sense command was issued, 0. When a sense command was issued 
following an error, the number of bytes of sense data received. When an error 
occurred during a sense command, -1.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>sr_resid</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>The difference between <VARIABLE>sr_buflen</VARIABLE> and the number of bytes actually transferred.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The <VARIABLE>sr_status</VARIABLE> field should be tested first. It contains an integer value; the possible values are summarized in <XREF IDREF="35917" TYPE="TABLE">Table&nbsp;16-6</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="16-6"><PREFIX>Table 16-6 </PREFIX><XREFTARGET ID="35917"> <EMPHASIS>(continued)        </EMPHASIS>Software Status Values From a SCSI Request</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="81"><PARAGRAPH>Constant Name</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Meaning</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>SC_GOOD</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>The request was valid and the command was executed. The command might 
still have failed; see <VARIABLE>sr_scsi_status</VARIABLE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>SC_REQUEST</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>An error was detected in the input values; the command was not attempted. 
The error could be that <FUNCTION>scsi_alloc()</FUNCTION> has not been called, or it could be due to 
missing or incorrect values.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>SC_TIMEOUT</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>The device did not respond to selection within 250 milliseconds.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>SC_HARDERR</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>A hardware error occurred. (You can try inspecting <VARIABLE>sr_senselen</VARIABLE> to see if sense 
data was received, but typically it will not have sense data associated with 
it.)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>SC_PARITY</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>SCSI bus parity error detected.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>SC_MEMERR</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>System memory parity or ECC error detected.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>SC_CMDTIME</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>The device responded to selection but the command did not complete before 
<VARIABLE>sr_timeout</VARIABLE> expired.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>SC_ALIGN</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>The buffer address was not aligned as required by the adapter hardware. 
Most Silicon Graphics adapters require word (4-byte) alignment.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>SC_ATTN</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>The command could not be completed due to circumstances not related to 
the command, and not due to an error in the command.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>SC_ATTN status is returned when a command is aborted by some event not directly related to the command, such as:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>SCSI bus reset, which aborts all outstanding commands.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A contingent allegiance condition when QERR is 1, in which all outstanding commands to a LUN are aborted.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The command follows the return of sense data but SRF_CONTINGENT_ALLEGIANCE_CLEAR is not set in the request (see <XREF IDREF="32345" TYPE="TABLE">Table&nbsp;16-4</XREF>).</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>One or more bits are set in the <VARIABLE>sc_scsi_status</VARIABLE> field. This field represents the status following the requested command, when the requested command executes correctly. When the requested command ends with Check Condition status, a sense command is issued and the SCSI status following the sense is placed in <VARIABLE>sc_scsi_status</VARIABLE>. In other words, the true indication of successful execution of the requested command is a zero in <VARIABLE>sr_sensegotten</VARIABLE>, because this indicates that no sense command was attempted.</PARAGRAPH>
<PARAGRAPH>Possible values of <VARIABLE>sc_scsi_status</VARIABLE> are summarized in <XREF IDREF="86815" TYPE="TABLE">Table&nbsp;16-7</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="16-7"><PREFIX>Table 16-7 </PREFIX><XREFTARGET ID="86815"> <EMPHASIS>(continued)        </EMPHASIS>SCSI Status Bytes</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="99"><PARAGRAPH>Constant Name</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Meaning</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>ST_GOOD</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>The target has successfully completed the SCSI command. If a check 
condition was returned, a sense command was issued. The 
<VARIABLE>sr_sensegotten</VARIABLE> field is nonzero when this was the case.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>ST_CHECK</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>This bit is set only for the special case when a check condition occurred 
on a sense command following a check condition on the requested 
command. The <VARIABLE>sr_sensegotten</VARIABLE> field contains -1.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>ST_COND_MET</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Search condition was met.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>ST_BUSY</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>The target is busy. The driver will normally delay and then request the 
command again.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>ST_INT_GOOD</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>This status is reported for every command in a series of linked 
commands. Linked commands are not supported by Silicon Graphics 
host adapters.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>ST_INT_COND_MET</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>The sum of ST_COND_MET and ST_INT_COND_MET.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>ST_RES_CONF</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>A conflict with a reserved logical unit or reserved extent.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>One or more bits may be set in <VARIABLE>sr_ha_flags</VARIABLE> to document a host adapter state or problem (but not all host adapter drivers do this). These flags are summarized in <XREF IDREF="76456" TYPE="TABLE">Table&nbsp;16-8</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="16-8"><PREFIX>Table 16-8 </PREFIX><XREFTARGET ID="76456"> <EMPHASIS>(continued)        </EMPHASIS>Host Adapter Status After a SCSI Request</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="99"><PARAGRAPH>Constant Name</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Meaning</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>SRH_SYNCXFR</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Synchronous mode was used. If not set, asynchronous mode was used.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>SRH_TRIEDSYNC</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Synchronous mode negotiation was attempted; see the 
SHR_CANTSYNC bit for the result.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>SRH_CANTSYNC</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Unable to negotiate synchronous mode. See also SRH_BADSYNC.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>SRH_BADSYNC</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>When SRH_CANTSYNC is set, indicates that the negotiation failed 
because the device cannot negotiate.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>SRH_NOADAPSYNC</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>When SRH_CANTSYNC is set, this bit indicates that the host adapter 
does not support synchronous negotiation, or that the system has been 
configured not to use synchronous mode for this device.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>SRH_WIDE</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>This adapter supports Wide mode.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>SRH_DISC</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>This adapter supports Disconnect mode and is configured to use it.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>SRH_TAGQ</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>This adapter supports tagged queueing and is configured to use it.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>SRH_MAPUSER</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>This host adapter driver can map user addresses.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>SRH_QERR0, 
SRH_QERR1</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>This host adapter supports one or the other of the queuing error 
recovery policies. The device reports its QERR bit on the Control mode 
page. If the device policy differs from the host adapter policy, the device 
driver should avoid the use of queued commands.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="62692">Using scsi_abort()</TITLE><PARAGRAPH>The purpose of the <INDEXTARGET ID="15-scsi18"><!-- POSTPROCESSDATA: 15-scsi18|SCSI bus:host adapter:<FUNCTION>scsi_abort</FUNCTION>() --><FUNCTION>scsi_abort()</FUNCTION> function is to abort all pending or executing commands on a device. The prototype of the function is:</PARAGRAPH>
<CODE>
SCI_ABORT(SLI_CTLR_INFO(scsi_lun_info_get(lun_vhdl))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(struct scsi_request *req);
</CODE>
<PARAGRAPH>The only fields of the scsi_request that are input to this function are those that identify the device: <VARIABLE>sr_dev_vhdl</VARIABLE> (always!), <VARIABLE>sr_ctlr</VARIABLE>, <VARIABLE>sr_target</VARIABLE>, and <VARIABLE>sr_lun</VARIABLE>. The ABORT command is issued on the bus as soon as possible but there could be a delay if the bus is busy. Status is returned in <VARIABLE>sr_status</VARIABLE>. The function returns a nonzero value when the ABORT command is issued successfully, and a zero when the ABORT command fails (which probably indicates a serious bus problem).</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>Not all devices and not all host adapters support this operation. Error recovery of queued commands is up to the driver.</NOTE>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="76204">Designing a SCSI Driver</TITLE><PARAGRAPH>As of IRIX 6.5, support is provided for you to write your own kernel-level SCSI device driver using the software interfaces and hardware devices supported by Silicon Graphics. A SCSI driver can be loadable or it can be linked with the kernel. In general it is configured into IRIX as described in <INDEXTARGET ID="15-scsi19"><!-- POSTPROCESSDATA: 15-scsi19|PCI bus:driver structure --><XREF IDREF="82892" TYPE="TITLE">Chapter&nbsp;9, &ldquo;Building and Installing a Driver.&rdquo;</XREF> However, a SCSI driver uses additional services, including those of the host adapter driver, and its configuration is slightly different from other drivers.</PARAGRAPH>
<PARAGRAPH>IRIX support for the SCSI bus is designed to allow support for dynamic reconfiguration. A SCSI driver can be designed to allow devices to be attached and detached at any time. The general sequence of operations related to a functioning SCSI driver is as follows:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>The driver is placed for kernel inclusion (or to be loaded later) and all appropriate system support files are properly configured (see <XREF IDREF="82892" TYPE="TITLE">Chapter&nbsp;9, &ldquo;Building and Installing a Driver&rdquo;</XREF>).</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The (optional) <FUNCTION>pfxinit()</FUNCTION> entry point is called early in the boot sequence so the driver can perform initialization procedures.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>In the (required) <INDEXTARGET ID="15-scsi20"><!-- POSTPROCESSDATA: 15-scsi20|entry points:reg --><VARIABLE>pfx</VARIABLE><FUNCTION>reg()</FUNCTION> entry point, the driver registers itself as a SCSI driver, specifying the SCSI device type it supports and the driver prefix. See <XREF IDREF="47946" TYPE="TITLE">&ldquo;About Registration&rdquo;</XREF>.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The host adapter driver discovers attached SCSI devices that return a device type and vendor and product identification strings. The kernel searches a table list for each discovered device for matching vendor ID and product ID strings for that device type. If it discovers a matching entry, it calls the (required) <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> entry point of the registered driver, supplying the hwgraph vertex handle. See <XREF IDREF="23323" TYPE="TITLE">&ldquo;About Attaching a Device&rdquo;</XREF>.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The driver uses the supplied vertex handle to construct the proper hwgraph space for its device(s). See <XREF IDREF="11429" TYPE="TITLE">&ldquo;Building hwgraph Entries&rdquo;</XREF>. The driver may also create convenient aliases for hwgraph entries (see <XREF IDREF="83499" TYPE="TITLE">&ldquo;Creating Device Aliases&rdquo;</XREF>).</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The driver interacts with the device(s) using the SCSI host adapter interface as described under <XREF IDREF="96683" TYPE="TITLE">&ldquo;Host Adapter Facilities&rdquo;</XREF>.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>If the kernel learns that the device is being detached, the kernel calls the driver's <VARIABLE>pfx</VARIABLE><FUNCTION>detach()</FUNCTION> entry point. The driver then undoes the work done in <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION>.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>These steps are described in more detail in the following sections:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="16183" TYPE="TITLE">&ldquo;Configuring a SCSI Driver&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="47946" TYPE="TITLE">&ldquo;About Registration&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="23323" TYPE="TITLE">&ldquo;About Attaching a Device&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="25355" TYPE="TITLE">&ldquo;Opening a SCSI Device&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="79145" TYPE="TITLE">&ldquo;About Detaching a Device&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="11580" TYPE="TITLE">&ldquo;About Unloading a SCSI Driver&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="83499" TYPE="TITLE">&ldquo;Creating Device Aliases&rdquo;</XREF></PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="16183">Configuring a SCSI Driver</TITLE><PARAGRAPH>A SCSI driver can be either a block or a character driver, or it can support both interfaces. When preparing the descriptive file for <FILENAME>/var/sysgen/master.d</FILENAME>, you must use the <COMMAND>s</COMMAND> flag, specifying a software-only driver, and list <COMMAND>scsi</COMMAND> as a dependency in the description line. See <XREF IDREF="71839" TYPE="TITLE">&ldquo;Describing the Driver in /var/sysgen/master.d&rdquo;</XREF>. </PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="47946">About Registration</TITLE><PARAGRAPH>Registration is a step that tells the kernel how to associate a device with a driver. The driver must register with the kernel or it will not be able to access a device.<INDEXTARGET ID="15-scsi21"><!-- POSTPROCESSDATA: 15-scsi21|register a driver:PCI driver --></PARAGRAPH>
<PARAGRAPH>At boot time, the host adapter driver discovers the complement of devices by probing the bus. A SCSI device is identified by its device type, a number defined as shown in <XREF IDREF="37971" TYPE="TABLE">Table&nbsp;16-9</XREF></PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="16-9"><PREFIX>Table 16-9 </PREFIX><XREFTARGET ID="37971">SCSI Device Type Numbers</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="49"><PARAGRAPH>Number</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="238"><PARAGRAPH>Type</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH>0</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="238"><PARAGRAPH>Direct-access device (for example, magnetic disk)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH>1</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="238"><PARAGRAPH>Sequential-access device (for example, magnetic tape)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH>2</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="238"><PARAGRAPH>Printer device</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH>3</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="238"><PARAGRAPH>Processor device</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH>4</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="238"><PARAGRAPH>Write-once device (for example, some optical disks)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH>5</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="238"><PARAGRAPH>CD-ROM device</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH>6</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="238"><PARAGRAPH>Scanner device</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH>7</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="238"><PARAGRAPH>Optical memory device (for example, some optical disks)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH>8</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="238"><PARAGRAPH>Medium changer device (for example, jukeboxes)</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>In addition to the device type, SCSI devices supply vendor ID and product ID strings. When the kernel finds a device, it needs to associate it with a driver. For SCSI devices, the kernel looks through a list of drivers that have registered as supporting SCSI devices of the particular type. If a driver of that type has registered, and the kernel finds an entry for a driver of that type with vendor ID and product ID strings that match the ones found at device discovery, it calls <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> (see <XREF IDREF="23323" TYPE="TITLE">&ldquo;About Attaching a Device&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>Registration tables for driver types are defined in <INDEXTARGET ID="15-scsi22"><!-- POSTPROCESSDATA: 15-scsi22|header files:<FILENAME>sys/PCI/pciio.h</FILENAME> --><FILENAME>master.d/scsi.h</FILENAME>. The entries in <FUNCTION>scsi_drivers[] </FUNCTION>list the device types supported (by default, only the type 1 table is defined, but you may define other types):</PARAGRAPH>
<CODE>
scsi_type_reg_s scsi_drivers[] = {
{ 0, NULL                    },      /* Type 0 driver reg table */
{ 0, scsi_drivers_type1      },      /* Type 1 driver reg table */
{ 0, NULL                    },      /* Type 2 driver reg table */
{ 0, NULL                    },      /* Type 3 driver reg table */
{ 0, NULL                    },      /* Type 4 driver reg table */
{ 0, NULL                    },      /* Type 5 driver reg table */
{ 0, NULL                    },      /* Type 6 driver reg table */
{ 0, NULL                    },      /* Type 7 driver reg table */
{ 0, NULL                    },      /* Type 8 driver reg table */
{ 1, NULL                    },      /* Terminator - don't remove */
};
</CODE>
<PARAGRAPH>A driver is associated with a device type in the <FILENAME>master.d/scsi </FILENAME>file with a four part entry for the specific table type. The four fields are strings that contain the SCSI vendor ID, the SCSI product ID, the driver prefix, and a hwgraph pathname component. </PARAGRAPH>
<PARAGRAPH>For example, consider the following entry for a type 1 (tape) driver:</PARAGRAPH>
<CODE>
scsi_driver_reg_s scsi_drivers_type1[] = {
&space;   // Type 1 - sequential access devices, tapes //
&space;   { &ldquo;Fujitsu&rdquo;, &ldquo;Diana-1&rdquo;, &ldquo;fuj&rdquo;, &ldquo;fujitsu-tape&rdquo; },
&space;   { NULL, NULL, NULL, NULL }
};
</CODE>
<PARAGRAPH>The vendor ID is <SCREENDISPLAY>Fujitsu</SCREENDISPLAY>, the product ID is <SCREENDISPLAY>Diana-1</SCREENDISPLAY>, the prefix is <SCREENDISPLAY>fuj</SCREENDISPLAY>, and the hwgraph pathname component is <SCREENDISPLAY>fujitsu-tape</SCREENDISPLAY>. So, if a SCSI Inquiry on the device at device discovery time returns a type 1, and the vendor and product ID returned are <SCREENDISPLAY>Fujitsu</SCREENDISPLAY> and <SCREENDISPLAY>Diana-1</SCREENDISPLAY>, the kernel will address the driver entry points with the prefix <SCREENDISPLAY>fuj</SCREENDISPLAY>, passing the hwgraph pathname suffix fujitsu-tape.</PARAGRAPH>
<PARAGRAPH>Your driver registers by calling the <INDEXTARGET ID="15-scsi23"><!-- POSTPROCESSDATA: 15-scsi23|PCI bus:vendor ID --><INDEXTARGET ID="15-scsi24"><!-- POSTPROCESSDATA: 15-scsi24|kernel functions:<FUNCTION>pciio_driver_register()</FUNCTION> --><FUNCTION>scsi_driver_register()</FUNCTION> function (see <FILENAME>master.d/scsi</FILENAME>):</PARAGRAPH>
<CODE>
int scsi_driver_register(int unit_type, char *driver_prefix)
</CODE>
<PARAGRAPH>This call specifies the SCSI device type <VARIABLE>int</VARIABLE> (see <XREF IDREF="37971" TYPE="TABLE">Table&nbsp;16-9</XREF>) and the driver's prefix character string that you define. The prefix string is configured in the driver's descriptive file (see <XREF IDREF="71839" TYPE="TITLE">&ldquo;Describing the Driver in /var/sysgen/master.d&rdquo;</XREF>). The kernel uses this string to find the addresses of driver entry points. Note that you may call this function multiple times if your driver supports more than one SCSI device type.</PARAGRAPH>
<PARAGRAPH>You should call <FUNCTION>scsi_driver_register()</FUNCTION> from the <VARIABLE>pfx</VARIABLE><FUNCTION>reg()</FUNCTION> entry point. Be aware that, if there is an available device of the specified type, <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> can be called immediately, before the <FUNCTION>scsi_driver_register()</FUNCTION> function returns.</PARAGRAPH>
<PARAGRAPH>The order in which drivers are called to attach a device is not defined. </PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="23323">About Attaching a Device</TITLE><PARAGRAPH>At device discovery during the boot sequence, the kernel identifies SCSI devices by device type and by the vendor ID and product ID strings. It then searches the device type table for matching strings (see <INDEXTARGET ID="15-scsi25"><!-- POSTPROCESSDATA: 15-scsi25|entry points:attach --><XREF IDREF="47946" TYPE="TITLE">&ldquo;About Registration&rdquo;</XREF>). When it finds a match, it uses the associated prefix string in the table entry to call <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> and passes the hwgraph vertex handle, which represents the &ldquo;connection point&rdquo; of the device&mdash;typically the LUN vertex handle (for example <FILENAME>.../scsi_ctlr/0/target/0/lun/0</FILENAME>). The driver adds more vertexes connected to this one to represent the logical devices. The handle of the connection point is needed in several kernel functions, so you should save it as part of the device information.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Device and Inventory Information</TITLE><PARAGRAPH>You should allocate and initialize a device information structure for each device. You should also put inventory information on one created vertex, for example, /<FILENAME>hw/.../xyz/disk/volume/char</FILENAME>. Refer to <XREF IDREF="53606" TYPE="TITLE">&ldquo;Attaching Information to Vertexes&rdquo;</XREF>. Note that you should create the devices representing your actual hardware configuration, and not all possible devices as used to be the case with the old <FILENAME>/dev</FILENAME> file scheme populated by MKNOD. In this way, the <FILENAME>/hw</FILENAME> structure represents the actual system configuration. (Consequently, when detaching, you should remove any created nodes as described in <XREF IDREF="79145" TYPE="TITLE">&ldquo;About Detaching a Device&rdquo;</XREF>.)</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="11429">Building hwgraph Entries</TITLE><PARAGRAPH>Use <FUNCTION>hwgraph_char_device_add</FUNCTION> or <FUNCTION>hwgraph_block_device_add</FUNCTION> (possibly both, depending on your device), to add vertexes to the hardware graph. You pass the vertex handle received at <VARIABLE>pfx</VARIABLE><FUNCTION>attach</FUNCTION> along with the additional edges or path to describe each logical device. For example, if the vertex handle received was <FILENAME>/hw/.../xyz</FILENAME>, an entry you create with <FUNCTION>hwgraph_block_device_add</FUNCTION> might be /<FILENAME>hw/.../xyz/partition/0/block</FILENAME>. Refer to <XREF IDREF="48208" TYPE="TITLE">&ldquo;SCSI Devices in the hwgraph&rdquo;</XREF> for information on how the SCSI host adapter performs these same functions.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Returning from pfxattach</TITLE><PARAGRAPH>The return code from <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> is tested by the kernel. The driver can reject an attachment. When your driver fails due to some problem, it should:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Use <FUNCTION>cmn_err()</FUNCTION> to document the problem (see <XREF IDREF="49566" TYPE="TITLE">&ldquo;Using cmn_err&rdquo;</XREF>)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Release any space allocated to the device such as a device information structure</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Return an informative return code</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>detach()</FUNCTION> entry point can be called only if the <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> entry point returns success (0).</PARAGRAPH>
<PARAGRAPH>Whenever the new vertex is opened, <VARIABLE>pfx</VARIABLE><FUNCTION>open</FUNCTION> is called.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="25355">Opening a SCSI Device</TITLE><PARAGRAPH>When the <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION> entry point is called, the SCSI driver uses the appropriate <FUNCTION>scsi_info()</FUNCTION> function to verify the device and get hardware dependent Inquiry data from it. If the device is not operational, the driver can return ENODEV. If the device is operational, the driver calls <FUNCTION>scsi_alloc()</FUNCTION> to open a communications path to it. </PARAGRAPH>
<PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>open</FUNCTION> entry point is passed the edge vertex, which you can use with <FUNCTION>device_info_get</FUNCTION> to access the device info pointer (see <XREF IDREF="50960" TYPE="TITLE">&ldquo;Hardware Graph Management&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>Refer to <XREF IDREF="96683" TYPE="TITLE">&ldquo;Host Adapter Facilities&rdquo;</XREF> for information on how your driver can interact with the device.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Accessing a SCSI Device</TITLE><PARAGRAPH>In general, it is simplest to put all access to a device within a <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> entry point, even in a character device driver. When the <VARIABLE>pfx</VARIABLE><FUNCTION>read()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>write()</FUNCTION>, or <VARIABLE>pfx</VARIABLE><FUNCTION>ioctl()</FUNCTION> entry point needs to read or write data, it can prepare a <VARIABLE>uio_t</VARIABLE> to describe the data, and call <FUNCTION>uiophysio()</FUNCTION> to direct the operation through the single <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION> entry point (see <XREF IDREF="31423" TYPE="TITLE">&ldquo;Calling Entry Point strategy() From Entry Point read() or write()&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>The notify routine passed in the <VARIABLE>sr_notify</VARIABLE> field plays the same role as the <VARIABLE>pfx</VARIABLE><FUNCTION>intr()</FUNCTION> entry point in other device drivers. It is called asynchronously, when the SCSI command completes. It may not call a kernel function that can sleep. However, it does not have to be named <VARIABLE>pfx</VARIABLE><FUNCTION>intr()</FUNCTION>, and a SCSI driver does not have to provide a <VARIABLE>pfx</VARIABLE><FUNCTION>intr()</FUNCTION> entry point.<INDEXTARGET ID="15-scsi26"><!-- POSTPROCESSDATA: 15-scsi26|driver:types of:SCSI bus --><INDEXTARGET ID="15-scsi27"><!-- POSTPROCESSDATA: 15-scsi27|SCSI bus:driver --></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="79145">About Detaching a Device</TITLE><PARAGRAPH>Your <VARIABLE>pfx</VARIABLE><FUNCTION>detach</FUNCTION> entry point is where you remove hwgraph vertexes added with <VARIABLE>pfx</VARIABLE><FUNCTION>attach</FUNCTION>. Note that if you create aliases with an ioctl (see <XREF IDREF="83499" TYPE="TITLE">&ldquo;Creating Device Aliases&rdquo;</XREF>), you should remove them in your <VARIABLE>pfx</VARIABLE><FUNCTION>detach</FUNCTION> routine as well. As a result of this practice, the hwgraph will represent the actual available devices.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="11580">About Unloading a SCSI Driver</TITLE><PARAGRAPH>When a loadable SCSI driver is called at its <INDEXTARGET ID="15-scsi28"><!-- POSTPROCESSDATA: 15-scsi28|entry points:unload --><VARIABLE>pfx</VARIABLE><FUNCTION>unload()</FUNCTION> entry point, indicating that the kernel would like to unload it, the driver must take pains not to leave any dangling pointers (as discussed under <XREF IDREF="57773" TYPE="TITLE">&ldquo;Entry Point unload()&rdquo;</XREF>). A driver should not unload when it has any registered interrupt or error handlers.</PARAGRAPH>
<PARAGRAPH>A driver does not have to unregister itself as a SCSI driver before unloading. Nor does it have to detach any devices it has attached. However, if any devices are open or memory mapped, the driver should not unload.</PARAGRAPH>
<PARAGRAPH>If the driver has been autoregistered (see <XREF IDREF="88940" TYPE="TITLE">&ldquo;Registration&rdquo;</XREF>), stub functions are placed in the switch tables for the attach and open functions. When the kernel discovers a new device and wants this driver to attach it, or when a process attempts to open a device for which this driver created the vertex, the kernel reloads the driver. </PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="83499">Creating Device Aliases</TITLE><PARAGRAPH>A device alias is a convenient shorthand path which refers to the same device as the full hwgraph entry. If you want your driver to create aliases for hwgraph entries, create a file in <FILENAME>/var/sysgen/ioconfig</FILENAME>, for example, <FILENAME>/var/sysgen/ioconfig/xyz</FILENAME>. This file allows you to choose a stable controller number for your device alias, and to specify an ioctl number used by <COMMAND>ioconfig</COMMAND> and your driver to create the alias. (See <FILENAME>/var/sysgen/ioconfig/README</FILENAME> and <REFPAGE>ioconfig(1M)</REFPAGE> for details of the file syntax.)</PARAGRAPH>
<PARAGRAPH>Create a <VARIABLE>pfx</VARIABLE><FUNCTION>ioctl</FUNCTION> entry point that is responsible for creating device aliases, for example, a path under <FILENAME>/hw/disk</FILENAME> and <FILENAME>/hw/rdisk</FILENAME> corresponding to the actual hwgraph entry. The <VARIABLE>pfx</VARIABLE><FUNCTION>ioctl</FUNCTION> entry point might be called with XYZ_ALIAS, for example, which is a numerical value specified in the last entry in <FILENAME>/var/sysgen/ioconfig/xyz</FILENAME>.</PARAGRAPH>
<PARAGRAPH>Use <FUNCTION>device_controller_num_get(</FUNCTION><VARIABLE>dev</VARIABLE><FUNCTION>) </FUNCTION>(see <FILENAME>sys/invent.h</FILENAME>), where <VARIABLE>dev</VARIABLE> is the hwgraph vertex on which your driver added inventory information, to get the controller number that has been assigned by <COMMAND>ioconfig</COMMAND>. The controller number supplied will be the starting one claimed in <FILENAME>/var/sysgen/ioconfig</FILENAME>, so your aliases will remain associated with the actual hwgraph entries.</PARAGRAPH>
<PARAGRAPH>For example, if you have specified that controller numbers should start at 10, you can be assured that you will always use 10 as your first controller number and, by picking a relatively high number, your driver should have no effect on ioconfig's default controller number assignments for other controllers of the class.</PARAGRAPH>
<PARAGRAPH>Refer to <XREF IDREF="40257" TYPE="TITLE">&ldquo;Convenience Vertexes&rdquo;</XREF> for information on how the SCSI host adapter driver creates the hwgraph aliases. <INDEXTARGET ID="15-scsi29"><!-- POSTPROCESSDATA: 15-scsi29|example driver --><INDEXTARGET ID="15-scsi30"><!-- POSTPROCESSDATA: 15-scsi30|driver:examples:SCSI bus --><INDEXTARGET ID="15-scsi31"><!-- POSTPROCESSDATA: 15-scsi31|SCSI bus:example driver --></PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="16890">SCSI Reference Data</TITLE><PARAGRAPH>This section contains reference material in the following categories:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="65625" TYPE="TITLE">&ldquo;SCSI Error Messages&rdquo;</XREF> describes the general form of messages written by host adapter drivers into the system log.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="23415" TYPE="TITLE">&ldquo;Adapter Error Codes (Table scsi_adaperrs_tab)&rdquo;</XREF> lists the possible adapter error codes and their message strings.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="78710" TYPE="TITLE">&ldquo;SCSI Sense Codes (Table scsi_key_msgtab)&rdquo;</XREF> lists the primary sense codes and the corresponding message strings.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="72258" TYPE="TITLE">&ldquo;Additional Sense Codes (Table scsi_addit_msgtab)&rdquo;</XREF> lists the possible additional sense codes (ASCs) and their message strings.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="65625">SCSI Error Messages</TITLE><PARAGRAPH>The host adapter drivers send error messages to the system log using the <INDEXTARGET ID="15-scsi32"><!-- POSTPROCESSDATA: 15-scsi32|SCSI bus:error messages --><FUNCTION>cmn_err()</FUNCTION> function (see <XREF IDREF="84574" TYPE="TITLE">&ldquo;Producing Diagnostic Displays&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>These messages almost always contain the adapter number (sometimes called the bus number or controller number). They sometimes contain the number of the target device, and sometimes add the number of the logical unit that was addressed.</PARAGRAPH>
<PARAGRAPH>Messages from the <ITALICS>wd93</ITALICS> driver specify the adapter number as <SCREENDISPLAY>Bus=</SCREENDISPLAY><VARIABLE>n</VARIABLE>. The target device is shown as <SCREENDISPLAY>ID=</SCREENDISPLAY><VARIABLE>n</VARIABLE> and the logical unit as <SCREENDISPLAY>LUN=</SCREENDISPLAY><VARIABLE>n</VARIABLE>.</PARAGRAPH>
<PARAGRAPH>Messages from the <ITALICS>wd95</ITALICS> and <ITALICS>jag</ITALICS> drivers contain one, two, or three or more decimal numbers. In all cases, the first number is the adapter number, the second is the target ID, and the third (when present) is the logical unit number.</PARAGRAPH>
<PARAGRAPH>When error messages list a sense code, refer to <XREF IDREF="78710" TYPE="TITLE">&ldquo;SCSI Sense Codes (Table scsi_key_msgtab)&rdquo;</XREF> and to <XREF IDREF="72258" TYPE="TITLE">&ldquo;Additional Sense Codes (Table scsi_addit_msgtab)&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>When the error message reports an error from the adapter itself, refer to <XREF IDREF="23415" TYPE="TITLE">&ldquo;Adapter Error Codes (Table scsi_adaperrs_tab)&rdquo;</XREF>.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>SCSI Error Message Tables</TITLE><PARAGRAPH>The <INDEXTARGET ID="15-scsi33"><!-- POSTPROCESSDATA: 15-scsi33|SCSI bus:message string tables --><VARIABLE>scsi</VARIABLE> module contains a set of error message tables that you can use to generate error messages based on SCSI sense codes and other data. The contents of these tables is documented here for reference, and to assist in decoding messages from SCSI drivers.</PARAGRAPH>
<PARAGRAPH>Each table is an array of pointers to strings; for example, the definition of the <VARIABLE>scsi_key_msgtab</VARIABLE> table begins as follows:</PARAGRAPH>
<CODE>
char *scsi_key_msgtab[SC_NUMSENSE] = {
&nbsp;&nbsp;&nbsp;"No sense",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* 0x0 */
&nbsp;&nbsp;&nbsp;"Recovered Error",&nbsp;&nbsp;&nbsp;/* 0x1 */
...};
</CODE>
<PARAGRAPH>Each of the tables is declared as extern in <FILENAME>sys/scsi.h</FILENAME>.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="23415">Adapter Error Codes (Table scsi_adaperrs_tab)</TITLE><PARAGRAPH>The table with the external name <INDEXTARGET ID="15-scsi34"><!-- POSTPROCESSDATA: 15-scsi34|SCSI bus:adapter error codes --><VARIABLE>scsi_adaperrs_tab</VARIABLE> contains message strings to document the adapter error codes that can be returned in the <VARIABLE>scsirequest.sr_status</VARIABLE> field (see <XREF IDREF="35917" TYPE="TABLE">Table&nbsp;16-6</XREF>). The <VARIABLE>scsi_adaperrs_tab</VARIABLE> table contains NUM_ADAP_ERRS entries (9, defined in <FILENAME>sys/scsi.h</FILENAME>). The first entry (index 0x0) contains a pointer to a null string. The other entries are documented in <XREF IDREF="63645" TYPE="TABLE">Table&nbsp;16-10</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="16-10"><PREFIX>Table 16-10 </PREFIX><XREFTARGET ID="63645"> <EMPHASIS>(continued)        </EMPHASIS>Adapter Error Codes</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="54"><PARAGRAPH>Adapter 
Error Code</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="72"><PARAGRAPH>Constant Name</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>Message Text</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x1</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="72"><PARAGRAPH>SC_TIMEOUT</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>Device does not respond to selection.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x2</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="72"><PARAGRAPH>SC_HARDERR</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>Controller protocol error or SCSI bus reset.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x3</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="72"><PARAGRAPH>SC_PARITY</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>SCSI bus parity error.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x4</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="72"><PARAGRAPH>SC_MEMERR</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>Parity/ECC error in system memory during DMA.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x5</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="72"><PARAGRAPH>SC_CMDTIME</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>Command timed out.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x6</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="72"><PARAGRAPH>SC_ALIGN</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>Buffer not correctly aligned in memory.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x7</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="72"><PARAGRAPH>SC_ATTN</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>Unit attention received on another command causes retry.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x8</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="72"><PARAGRAPH>SC_REQUEST</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="261"><PARAGRAPH>Driver protocol error.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="78710">SCSI Sense Codes (Table scsi_key_msgtab) </TITLE><PARAGRAPH>The table with the external name <INDEXTARGET ID="15-scsi35"><!-- POSTPROCESSDATA: 15-scsi35|SCSI bus:sense codes --><VARIABLE>scsi_key_msgtab</VARIABLE> is indexed by the primary sense code. Its contents are listed in <XREF IDREF="16949" TYPE="TABLE">Table&nbsp;16-11</XREF>. The table contains SC_NUMADDSENSE entries (16, defined in <FILENAME>sys/scsi.h</FILENAME>), of which the last two should not occur. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="16-11"><PREFIX>Table 16-11 </PREFIX><XREFTARGET ID="16949"> <EMPHASIS>(continued)        </EMPHASIS>Primary Sense Key Error Table</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="56"><PARAGRAPH>Sense Key </PARAGRAPH>
</CELL>
<CELL LEFT="65" WIDTH="122"><PARAGRAPH>Message </PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="162"><PARAGRAPH>Most Common Cause</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="56"><PARAGRAPH>0x0 </PARAGRAPH>
</CELL>
<CELL LEFT="65" WIDTH="122"><PARAGRAPH><SCREENDISPLAY>No sense </SCREENDISPLAY></PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="162"><PARAGRAPH>No error information available.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="56"><PARAGRAPH>0x1 </PARAGRAPH>
</CELL>
<CELL LEFT="65" WIDTH="122"><PARAGRAPH><SCREENDISPLAY>Recovered error </SCREENDISPLAY></PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="162"><PARAGRAPH>The device recovered by itself.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="56"><PARAGRAPH>0x2 </PARAGRAPH>
</CELL>
<CELL LEFT="65" WIDTH="122"><PARAGRAPH><SCREENDISPLAY>Device not ready </SCREENDISPLAY></PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="162"><PARAGRAPH>No media, or drive not spun up.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="56"><PARAGRAPH>0x3 </PARAGRAPH>
</CELL>
<CELL LEFT="65" WIDTH="122"><PARAGRAPH><SCREENDISPLAY>Media error </SCREENDISPLAY></PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="162"><PARAGRAPH>An actual media problem.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="56"><PARAGRAPH>0x4 </PARAGRAPH>
</CELL>
<CELL LEFT="65" WIDTH="122"><PARAGRAPH><SCREENDISPLAY>Device hardware error</SCREENDISPLAY></PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="162"><PARAGRAPH>Usually a device hardware error.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="56"><PARAGRAPH>0x5 </PARAGRAPH>
</CELL>
<CELL LEFT="65" WIDTH="122"><PARAGRAPH><SCREENDISPLAY>Illegal request </SCREENDISPLAY></PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="162"><PARAGRAPH>Invalid command or data issued.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="56"><PARAGRAPH>0x6 </PARAGRAPH>
</CELL>
<CELL LEFT="65" WIDTH="122"><PARAGRAPH><SCREENDISPLAY>Unit attention </SCREENDISPLAY></PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="162"><PARAGRAPH>Device was reset or power-cycled.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="56"><PARAGRAPH>0x7 </PARAGRAPH>
</CELL>
<CELL LEFT="65" WIDTH="122"><PARAGRAPH><SCREENDISPLAY>Data protect error </SCREENDISPLAY></PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="162"><PARAGRAPH>Usually device is write protected.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="56"><PARAGRAPH>0x8 </PARAGRAPH>
</CELL>
<CELL LEFT="65" WIDTH="122"><PARAGRAPH><SCREENDISPLAY>Unexpected blank media</SCREENDISPLAY></PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="162"><PARAGRAPH>Tried to read at end of a tape.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="56"><PARAGRAPH>0x9 </PARAGRAPH>
</CELL>
<CELL LEFT="65" WIDTH="122"><PARAGRAPH><SCREENDISPLAY>Vendor unique error </SCREENDISPLAY></PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="162"><PARAGRAPH>Varies.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="56"><PARAGRAPH>0xA </PARAGRAPH>
</CELL>
<CELL LEFT="65" WIDTH="122"><PARAGRAPH><SCREENDISPLAY>Copy aborted </SCREENDISPLAY></PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="162"><PARAGRAPH>Copy command aborted by host (not 
used).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="56"><PARAGRAPH>0xB </PARAGRAPH>
</CELL>
<CELL LEFT="65" WIDTH="122"><PARAGRAPH><SCREENDISPLAY>Aborted command </SCREENDISPLAY></PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="162"><PARAGRAPH>Target device aborted command.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="56"><PARAGRAPH>0xC </PARAGRAPH>
</CELL>
<CELL LEFT="65" WIDTH="122"><PARAGRAPH><SCREENDISPLAY>Search data successful </SCREENDISPLAY></PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="162"><PARAGRAPH>Search data command OK (not used).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="56"><PARAGRAPH>0xD </PARAGRAPH>
</CELL>
<CELL LEFT="65" WIDTH="122"><PARAGRAPH><SCREENDISPLAY>Volume overflow </SCREENDISPLAY></PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="162"><PARAGRAPH>Tried to write past EOT on tape.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="56"><PARAGRAPH>0xE </PARAGRAPH>
</CELL>
<CELL LEFT="65" WIDTH="122"><PARAGRAPH><SCREENDISPLAY>Reserved (0xE) </SCREENDISPLAY></PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="162"><PARAGRAPH>0xE should not be seen.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="56"><PARAGRAPH>0xF </PARAGRAPH>
</CELL>
<CELL LEFT="65" WIDTH="122"><PARAGRAPH><SCREENDISPLAY>Reserved (0xF)</SCREENDISPLAY></PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="162"><PARAGRAPH>0xF should not be seen.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="72258">Additional Sense Codes (Table scsi_addit_msgtab)</TITLE><PARAGRAPH>The table with the external name <VARIABLE>scsi_addit_msgtab</VARIABLE> is indexed by the Additional Sense Code (ASC) value, when one is present. The table contains SC_NUMADDSENSE entries (0x71, defined in <FILENAME>sys/scsi.h</FILENAME>). Some values have no standard definition; for these, the table contains a NULL value. Therefore you should always test the table value for a valid pointer before using it to format a message. <XREF IDREF="34464" TYPE="TABLE">Table&nbsp;16-12</XREF> lists the contents of this message table. Undefined (NULL) table entries are omitted. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="16-12"><PREFIX>Table 16-12 </PREFIX><XREFTARGET ID="34464"> <EMPHASIS>(continued)        </EMPHASIS>Additional Sense Code Table</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="54"><PARAGRAPH>ASC Value</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH>Corresponding Message String</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x01</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>No index/sector signal</SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x02</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>No seek complete </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x03</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Write fault </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x04</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Not ready to perform command </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x05</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Unit does not respond to selection</SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x06</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>No reference position</SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x07</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Multiple drives selected </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x08</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>LUN communication error </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x09</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Track error </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x0a</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Error log overflow </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x0c</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Write error </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x10</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>ID CRC or ECC error </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x11</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Unrecovered data block read error </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x12</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>No address mark found in ID field </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x13</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>No address mark found in Data field </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x14</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>No record found </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x15</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Seek position error </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x16</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Data sync mark error </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x17</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Read data recovered with retries </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x18</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Read data recovered with ECC </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x19</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Defect list error </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x1a</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Parameter overrun </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x1b</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Synchronous transfer error </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x1c</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Defect list not found </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x1d</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Compare error </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x1e</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Recovered ID with ECC </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x20</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Invalid command code </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x21</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Illegal logical block address </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x22</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Illegal function </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x24</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Illegal field in CDB </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x25</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Invalid LUN </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x26</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Invalid field in parameter list </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x27</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Media write protected </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x28</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Media change </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x29</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Device reset </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x2a</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Log parameters changed </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x2b</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Copy requires disconnect </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x2c</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Command sequence error </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x2d</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Update in place error </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x2f</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Tagged commands cleared </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x30</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Incompatible media </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x31</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Media format corrupted </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x32</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>No defect spare location available </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x33<TABLEXREF IDREF="15-scsiTF13a">a</TABLEXREF></PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Media length error </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x36</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Toner/ink error </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x37</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Parameter rounded </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x39</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Saved parameters not supported </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x3a</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Medium not present </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x3b</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Forms error </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x3d</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Invalid ID msg </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x3e</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Self config in progress </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x3f</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Device config has changed </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x40</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>RAM failure </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x41</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Data path diagnostic failure </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x42</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Power on diagnostic failure </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x43</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Message reject error </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x44</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Internal controller error </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x45</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Select/reselect failed </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x46</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Soft reset failure </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x47</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>SCSI interface parity error </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x48</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Initiator detected error </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x49</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Inappropriate/illegal message </SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x4a</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Command phase error</SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x4b</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Data phase error</SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x4c</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Failed self configuration</SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x4e</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Overlapped commands attempted</SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x53</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Media load/unload failure</SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x57</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Unable to read table of contents</SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x58</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Generation (optical device) bad</SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x59</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Updated block read (optical device)</SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x5a</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Operator request or state change</SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x5b</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Logging exception</SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x5c</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>RPL status change</SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x5d</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Self diagnostics predict unit will fail soon</SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x60</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Lamp failure</SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x61</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Video acquisition error/focus problem</SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x62</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Scan head positioning error</SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x63</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>End of user area on track</SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x64</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Illegal mode for this track</SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>0x70<TABLEXREF IDREF="15-scsiTF13b">b</TABLEXREF></PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="279"><PARAGRAPH><SCREENDISPLAY>Decompression error</SCREENDISPLAY></PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
<TABLEFOOTNOTE LBL="a" ID="15-scsiTF13a">Specified as tape only.</TABLEFOOTNOTE>
<TABLEFOOTNOTE LBL="b" ID="15-scsiTF13b">DAT only; may be in SCSI3.</TABLEFOOTNOTE>
</TABLE>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="78816">A Note on FibreChannel Drivers</TITLE><PARAGRAPH>The FibreChannel adapter is accessed just like a SCSI adapter. It is a peer to drivers such as ql, adp78, and wd95.<INDEXTARGET ID="15-scsi36"><!-- POSTPROCESSDATA: 15-scsi36|FibreChannel --></PARAGRAPH>
<PARAGRAPH>Note that there is one difference in that all commands are tagged, whether or not the <VARIABLE>sr_tag</VARIABLE> member of the <VARIABLE>scsi_request</VARIABLE> structure is set.</PARAGRAPH>
</SECTION1>
</CHAPTER>
