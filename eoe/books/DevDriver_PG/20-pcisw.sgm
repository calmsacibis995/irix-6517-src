<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="21"><TITLE><XREFTARGET ID="15400">Services for PCI Drivers</TITLE><PARAGRAPH>The IRIX 6.5 kernel provides a uniform interface for managing a PCI device. The functions in this interface are covered in this chapter under the following headings:<INDEXTARGET ID="20-pcisw1"><!-- POSTPROCESSDATA: 20-pcisw1|PCI bus:kernel services --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="89246" TYPE="TITLE">&ldquo;IRIX 6.5 PCI Drivers&rdquo;</XREF> summarizes important information comparing previous versions IRIX device drivers with those for IRIX 6.5.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="78783" TYPE="TITLE">&ldquo;About PCI Drivers&rdquo;</XREF> summarizes the entry points and main activities of a PCI driver.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="66259" TYPE="TITLE">&ldquo;Using PIO Maps&rdquo;</XREF> discusses the kernel functions to allocate and use PIO maps.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="83353" TYPE="TITLE">&ldquo;Using DMA Maps&rdquo;</XREF> discusses the kernel functions to allocate and use PIO maps.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="35093" TYPE="TITLE">&ldquo;Registering an Interrupt Handler&rdquo;</XREF> discusses the kernel functions used to register and unregister an interrupt handler for a PCI device.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="97396" TYPE="TITLE">&ldquo;Registering an Error Handler&rdquo;</XREF> summarizes the method of associating an error handler function with a device.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="18244" TYPE="TITLE">&ldquo;Interrogating a PCI Device&rdquo;</XREF> lists the functions you can use to query device status.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="19082" TYPE="TITLE">&ldquo;Example PCI Driver&rdquo;</XREF> displays a simple, skeletal PCI driver.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="89246">IRIX 6.5 PCI Drivers</TITLE><PARAGRAPH>This section discusses changes made to PCI driver support for IRIX 6.5 and refers to the appropriate sections of the manual for more information.<INDEXTARGET ID="20-pcisw2"><!-- POSTPROCESSDATA: 20-pcisw2|IRIX 6.5 and PCI driversPCI drivers and IRIX 6.5 --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>If your driver is to be compiled for the IP32 (O2) platform, refer to <XREF IDREF="57296" TYPE="TITLE">&ldquo;PCI Drivers for the O2 (IP32) Platform&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Values of flags PCIIO_DMA_CMD and PCIIO_DMA_DATA have changed. See <XREF IDREF="34526" TYPE="TITLE">&ldquo;Setting Flag Values&rdquo;</XREF> for details.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>PCIIO_PIOMAP_* defines are being replaced by PCIIO_SPACE_* defines. Refer to <XREF IDREF="94127" TYPE="TITLE">&ldquo;Selecting the Address Space&rdquo;</XREF> for details.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>pciio_config_{get.set} interfaces are defined as described in <XREF IDREF="29676" TYPE="TITLE">&ldquo;Changes In Configuration Interface&rdquo;</XREF>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>pciio_pio_mapsz now returns a <VARIABLE>ulong</VARIABLE>. See <XREF IDREF="49516" TYPE="TITLE">&ldquo;Interrogating PIO Maps&rdquo;</XREF></PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="78783">About PCI Drivers</TITLE><PARAGRAPH>A PCI device driver is a kernel-level device driver that has the general structure described in <INDEXTARGET ID="20-pcisw3"><!-- POSTPROCESSDATA: 20-pcisw3|PCI bus:driver structure --><XREF IDREF="19192" TYPE="TITLE">Chapter&nbsp;7, &ldquo;Structure of a Kernel-Level Driver.&rdquo;</XREF> It uses the driver/kernel interface described in <XREF IDREF="31965" TYPE="TITLE">Chapter&nbsp;8, &ldquo;Device Driver/Kernel Interface.&rdquo;</XREF> A PCI driver can be loadable or it can be linked with the kernel. In general it is configured into IRIX as described in <XREF IDREF="82892" TYPE="TITLE">Chapter&nbsp;9, &ldquo;Building and Installing a Driver.&rdquo;</XREF></PARAGRAPH>
<PARAGRAPH>PCI hardware configuration is more dynamic than the configuration of the VME or EISA buses. With other types of bus, the administrator describes the device configuration using VECTOR statements and the configuration is static. IRIX support for the PCI bus is designed to allow support for dynamic reconfiguration. A PCI driver can be designed to allow devices to be attached and detached at any time.</PARAGRAPH>
<PARAGRAPH>The general sequence of operations of a PCI driver is as follows:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>In the <VARIABLE>pfx</VARIABLE><FUNCTION>init()</FUNCTION> entry point, the driver prepares any global variables.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>In the <INDEXTARGET ID="20-pcisw4"><!-- POSTPROCESSDATA: 20-pcisw4|entry points:reg --><VARIABLE>pfx</VARIABLE><FUNCTION>reg()</FUNCTION> entry point, the driver calls a kernel function to register itself as a PCI driver, specifying the kind of device it supports.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>When the kernel discovers a device of this type, it calls the <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> entry point of the driver. </PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>In the normal upper-half entry points such as <VARIABLE>pfx</VARIABLE><FUNCTION>open()</FUNCTION>, <VARIABLE>pfx</VARIABLE><FUNCTION>read()</FUNCTION>, and <VARIABLE>pfx</VARIABLE><FUNCTION>strategy()</FUNCTION>, the driver operates the device and transfers data.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>If the kernel learns that the device is being detached, the kernel calls the driver's <VARIABLE>pfx</VARIABLE><FUNCTION>detach()</FUNCTION> entry point. The driver undoes the work done in by <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION>.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>A PCI driver uses a number of PCI-related kernel functions that are all declared in the header file <INDEXTARGET ID="20-pcisw5"><!-- POSTPROCESSDATA: 20-pcisw5|header files:<FILENAME>sys/PCI/pciio.h</FILENAME> --><FILENAME>sys/PCI/pciio.h</FILENAME>.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="21706">About Registration</TITLE><PARAGRAPH>Registration is a step that lets the kernel know how to associate a device to a driver.<INDEXTARGET ID="20-pcisw6"><!-- POSTPROCESSDATA: 20-pcisw6|PCI bus:register driver --><INDEXTARGET ID="20-pcisw7"><!-- POSTPROCESSDATA: 20-pcisw7|register a driver:PCI driver --></PARAGRAPH>
<PARAGRAPH>A PCI device identifies itself on the bus by its vendor ID and device ID numbers. The kernel discovers the complement of devices by probing the bus. When it finds a device, the kernel needs to associate it with a driver. With other types of bus, the association between a device and a driver is entered by the system administrator in a static configuration file. For PCI devices, the kernel looks through a list of drivers that have registered as supporting PCI devices of particular types.</PARAGRAPH>
<PARAGRAPH>Your driver registers by calling the <INDEXTARGET ID="20-pcisw8"><!-- POSTPROCESSDATA: 20-pcisw8|PCI bus:device ID --><INDEXTARGET ID="20-pcisw9"><!-- POSTPROCESSDATA: 20-pcisw9|PCI bus:vendor ID --><INDEXTARGET ID="20-pcisw10"><!-- POSTPROCESSDATA: 20-pcisw10|kernel functions:<FUNCTION>pciio_driver_register()</FUNCTION> --><FUNCTION>pciio_driver_register()</FUNCTION> function (see reference page <REFPAGE>pciio(d3)</REFPAGE>).This call specifies the PCI vendor ID and device ID numbers as they appear in the PCI configuration space of any device that this driver can support. The third argument is the driver's prefix string as configured in its descriptive file (see <XREF IDREF="71839" TYPE="TITLE">&ldquo;Describing the Driver in /var/sysgen/master.d&rdquo;</XREF>). The kernel uses this string to find the addresses of the driver's <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> and <VARIABLE>pfx</VARIABLE><FUNCTION>detach()</FUNCTION> entry points.</PARAGRAPH>
<PARAGRAPH><XREF IDREF="68767" TYPE="TEXT">Example&nbsp;21-1</XREF> shows a hypothetical example of driver registration. This fragmentary example also shows how a driver can register multiple times to handle multiple combinations of vendor ID and device ID.</PARAGRAPH>
<CODE><CAPTION LBL="21-1"><PREFIX>Example 21-1 </PREFIX><XREFTARGET ID="68767">Driver Registration</CAPTION>int hypo_reg()
{
&nbsp;&nbsp;&nbsp;ret = pciio_driver_register(HYPO_VENID,HYPO_DEVID1,"hypo_",0);
&nbsp;&nbsp;&nbsp;if (!ret)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmn_err(CE_WARN,"error %d registering devid %d",ret,HYPO_DEVID1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ret;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;ret = pciio_driver_register(HYPO_VENID,HYPO_DEVID2,"hypo_",0);
&nbsp;&nbsp;&nbsp;if (!ret)...
}
</CODE>
<PARAGRAPH>In a loadable driver, you must call <FUNCTION>pciio_driver_register()</FUNCTION> from the <VARIABLE>pfx</VARIABLE><FUNCTION>reg()</FUNCTION> entry point. In a nonloadable driver, you can make the call from <VARIABLE>pfx</VARIABLE><FUNCTION>init()</FUNCTION> if you prefer, but the driver might not then work if someone later tries to make it loadable.</PARAGRAPH>
<PARAGRAPH>Wherever you call the function, be aware that, if there is an available device of the specified type, <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> can be called immediately, before the <FUNCTION>pci_driver_register()</FUNCTION> function returns. In a multiprocessor, <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> can be called concurrently with the return of <FUNCTION>pci_driver_register()</FUNCTION> and following code.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>About Attaching a Device</TITLE><PARAGRAPH>The duties and actions of the <INDEXTARGET ID="20-pcisw11"><!-- POSTPROCESSDATA: 20-pcisw11|entry points:attach --><VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> entry point are discussed in detail in <XREF IDREF="54429" TYPE="TITLE">&ldquo;Entry Point attach()&rdquo;</XREF> and under <XREF IDREF="50960" TYPE="TITLE">&ldquo;Hardware Graph Management&rdquo;</XREF>. In summary, at this time the driver</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Creates hwgraph vertexes to represent the device</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Allocates and initializes a data structure to hold per-device information</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Allocates PIO maps and (optionally) DMA maps to use in addressing the device</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>If necessary, registers an interrupt handler</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>If necessary, registers an error handler</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Initializes the device itself</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The allocation and use of PIO and DMA maps, and the registration of an interrupt handler, are covered in detail in following topics.</PARAGRAPH>
<PARAGRAPH>The argument to <INDEXTARGET ID="20-pcisw12"><!-- POSTPROCESSDATA: 20-pcisw12|hwgraph:and attach entry point --><VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> is a hwgraph vertex handle that represents the &ldquo;connection point&rdquo; of the device&mdash;usually the bus slot. The driver builds more vertexes connected to this one to represent the logical device. However, the handle of the connection point is needed in several kernel functions, and it should be saved as part of the device information.</PARAGRAPH>
<PARAGRAPH>The return code from <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> is tested by the kernel. The driver can reject an attachment. When your driver cannot allocate memory, or fails due to another problem, it should:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Use <FUNCTION>cmn_err()</FUNCTION> to document the problem (see <XREF IDREF="49566" TYPE="TITLE">&ldquo;Using cmn_err&rdquo;</XREF>)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Release any objects such as PIO and DMA maps that were created</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Release any space allocated to the device such as a device information structure</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Return an informative return code</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The <VARIABLE>pfx</VARIABLE><FUNCTION>detach()</FUNCTION> entry point can only be called if the <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> entry point returns success (0).</PARAGRAPH>
<PARAGRAPH>More than one driver can register to support the same vendor ID and device ID. The order in which drivers are called to attach a device is not defined. When the first-called driver fails to complete the attachment, the kernel continues on to test the next, until all have refused or one accepts.<INDEXTARGET ID="20-pcisw13"><!-- POSTPROCESSDATA: 20-pcisw13|PCI bus:device ID --><INDEXTARGET ID="20-pcisw14"><!-- POSTPROCESSDATA: 20-pcisw14|PCI bus:vendor ID --></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>About Unloading</TITLE><PARAGRAPH>When a loadable PCI driver is called at its <INDEXTARGET ID="20-pcisw15"><!-- POSTPROCESSDATA: 20-pcisw15|entry points:unload --><VARIABLE>pfx</VARIABLE><FUNCTION>unload()</FUNCTION> entry point, indicating that the kernel would like to unload it, the driver must take pains not to leave any dangling pointers (as discussed under <XREF IDREF="57773" TYPE="TITLE">&ldquo;Entry Point unload()&rdquo;</XREF>). A driver should not unload when it has any registered interrupt or error handlers.</PARAGRAPH>
<PARAGRAPH>A driver does not have to unregister itself as a PCI driver before unloading. Nor does it have to detach any devices it has attached. However, if any devices are open or memory mapped, the driver should not unload.</PARAGRAPH>
<PARAGRAPH>If the driver has been autoregistered (see <XREF IDREF="88940" TYPE="TITLE">&ldquo;Registration&rdquo;</XREF>), stub functions are placed in the switch tables for the attach and open functions. When the kernel discovers a new device and wants this driver to attach it, or when a process attempts to open a device for which this driver created the vertex, the kernel reloads the driver.&space;</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="66259">Using PIO Maps</TITLE><PARAGRAPH>You use a PIO map to establish a mapping between a kernel virtual address and some portion of PCI bus memory space, configuration space, or I/O space so that the CPU can load and store into the PCI bus. Depending on the machine architecture, the mapping may be a simple, linear translation, or it may require the kernel to program hardware registers in one or more bus adapters. The software interface is the same in all cases.<INDEXTARGET ID="20-pcisw16"><!-- POSTPROCESSDATA: 20-pcisw16|Programmed I/O (PIO):address maps for --></PARAGRAPH>
<PARAGRAPH>You cannot program a PCI device without at least one PIO map and you might allocate several. Typically you store the handles of the allocated maps in the device information structure; and you store the address of the device information structure in turn in the hwgraph vertex for the device.</PARAGRAPH>
<PARAGRAPH>In summary, a PIO map is used as follows:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Allocate it with <FUNCTION>pciio_piomap_alloc()</FUNCTION>. </PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Activate the map and extract a translated address using <FUNCTION>pciio_piomap_addr()</FUNCTION>. Use the translated address to fetch or store.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Deactivate the map using <FUNCTION>pciio_piomap_done()</FUNCTION>, when the map will be kept but will not be used for some time.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Release the map with <FUNCTION>pciio_piomap_free()</FUNCTION>.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<SECTION2 LBL="" HELPID = ""><TITLE>PIO Mapping Functions</TITLE><PARAGRAPH>The functions that are used to create and apply PIO maps are summarized in <XREF IDREF="20185" TYPE="TABLE">Table&nbsp;21-1</XREF>. For syntax details see the reference page <REFPAGE>pciio_pio(d3)</REFPAGE>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="21-1"><PREFIX>Table 21-1 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="20185">Functions for PIO Maps for the PCI Bus</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="110"><PARAGRAPH>Function </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="59"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="180" WIDTH="212"><PARAGRAPH>Purpose and Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_piomap_alloc() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="59"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="180" WIDTH="212"><PARAGRAPH>Create a PIO map object, specifying the bus address 
space, base offset, and length it needs to cover. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_piomap_addr() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="59"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="180" WIDTH="212"><PARAGRAPH>Get a kernel virtual address from a PIO map for a 
specific offset and length. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_piomap_done() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="59"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="180" WIDTH="212"><PARAGRAPH>Make a PIO map inactive until it is next needed (may 
release hardware resources associated to the map). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_piomap_free() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="59"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="180" WIDTH="212"><PARAGRAPH>Release a PIO map object. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_piotrans_addr() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="59"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="180" WIDTH="212"><PARAGRAPH>Request immediate translation of a bus address to a 
kernel virtual address without use of a PIO map. 
Returns NULL unless this system supports fixed 
PIO addressing. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_pio_addr() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="59"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="180" WIDTH="212"><PARAGRAPH>Attempt immediate translation, but allocate a PIO 
map if necessary. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_piospace_alloc() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="59"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="180" WIDTH="212"><PARAGRAPH>Reserve a segment of PCI bus memory or I/O space. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_piospace_free() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="59"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="180" WIDTH="212"><PARAGRAPH>Release a segment of PCI bus memory or I/O space. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Allocating PIO Maps</TITLE><PARAGRAPH>You create a PIO map using <INDEXTARGET ID="20-pcisw17"><!-- POSTPROCESSDATA: 20-pcisw17|kernel functions:<FUNCTION>pciio_piomap_alloc()</FUNCTION> --><FUNCTION>pciio_piomap_alloc()</FUNCTION>. Its arguments are as follows (see also reference page <REFPAGE>pciio_pio(d3)</REFPAGE>):</PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>vhdl</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>The connection-point <VARIABLE>vertex_hdl_t</VARIABLE> received by the <VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>attach()</FUNCTION> routine. This 
handle identifies the device to the kernel by its bus and slot positions. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>dev_desc</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Device descriptor structure (see text following). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>space</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Constant specifying the space to map (see <XREF IDREF="14967" TYPE="TABLE">Table&nbsp;21-2</XREF>&space;and text). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Offset within the selected <VARIABLE>space</VARIABLE> (typically 0). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>size</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Span of the total area in <VARIABLE>space</VARIABLE> over which this map might be applied. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>max</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Maximum size of the area that will be mapped at any one time. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>flags</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Optional usage flags (no-sleep flag, PCIIO_BYTE_STREAM, and so on)</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH><XREF IDREF="22735" TYPE="TEXT">Example&nbsp;21-2</XREF> shows a function that allocates a PIO map. The address space is passed as an argument, as is the size of the space to map. The function assumes the map should start at offset 0 in the selected space.</PARAGRAPH>
<CODE><CAPTION LBL="21-2"><PREFIX>Example 21-2 </PREFIX><XREFTARGET ID="22735">Allocation of PCI PIO Map</CAPTION>#include &lt;sys/PCI/pciio.h>
pciio_piomap_t makeMap(vertex_hdl_t connpt, int space, size_t size)
{
&nbsp;&nbsp;&nbsp;return pciio_piomap_alloc(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connpt,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* connection point vertex handle */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device_desc_default_get(convpt), /* device_desc_t */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;space, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* space, typically _WIN(n) */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* starting offset */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size,size,&nbsp;&nbsp;&nbsp;/* size to map */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* sleeping is OK */
}
</CODE>
<SECTION3 LBL="" HELPID = ""><TITLE>Preparing a device_desc_t</TITLE><PARAGRAPH>The device descriptor structure type <INDEXTARGET ID="20-pcisw18"><!-- POSTPROCESSDATA: 20-pcisw18|data types:<VARIABLE>device_desc_t</VARIABLE> --><VARIABLE>device_desc_t</VARIABLE> is declared in <FILENAME>iobus.h</FILENAME>, which is included by <FILENAME>pciio.h</FILENAME> (see also reference page <REFPAGE>device_desc(d4x)</REFPAGE>). In this release there is little that the device driver needs to know about this structure and its contents. The simplest way to get a device descriptor that can be handed to <FUNCTION>pciio_piomap_alloc()</FUNCTION> is to call <FUNCTION>device_desc_default_get()</FUNCTION> passing the same connection-point vertex handle, as follows:</PARAGRAPH>
<CODE>
ret = pciio_piomap_alloc(convh,device_desc_default_get(convh),...)
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="94127">Selecting the Address Space</TITLE><PARAGRAPH>The space argument of <FUNCTION>pciio_piomap_alloc()</FUNCTION> specifies the address space to which this PIO map can apply. The possible choices are summarized in <XREF IDREF="14967" TYPE="TABLE">Table&nbsp;21-2</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="21-2"><PREFIX>Table 21-2 </PREFIX><XREFTARGET ID="14967">PIO Map Address Space Constants</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="122"><PARAGRAPH>Constant Name</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="266"><PARAGRAPH>Meaning</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="122"><PARAGRAPH>PCIIO_PIOMAP_WIN(<VARIABLE>n</VARIABLE>)</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="266"><PARAGRAPH>The memory space defined by the BAR word <VARIABLE>n</VARIABLE> in configuration 
space. This is the most common type of PIO map base. (See note 
below.)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="122"><PARAGRAPH>PCIIO_SPACE_WIN(n)</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="266"><PARAGRAPH>The memory space defined by the BAR word <VARIABLE>n</VARIABLE> in configuration 
space. This is the most common type of PIO map base. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="122"><PARAGRAPH>PCIIO_SPACE_CFG</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="266"><PARAGRAPH>The Configuration address space. Direct PIO access to 
configuration space is supported only in IRIX 6.4&mdash;see <XREF IDREF="29676" TYPE="TITLE">&ldquo;Changes 
In Configuration Interface&rdquo;</XREF>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="122"><PARAGRAPH>PCIIO_SPACE_IO</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="266"><PARAGRAPH>Map to an absolute <VARIABLE>addr</VARIABLE> in the PCI bus I/O address space.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="122"><PARAGRAPH>PCIIO_SPACE_MEM</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="266"><PARAGRAPH>Map to an absolute <VARIABLE>addr</VARIABLE> in the PCI bus memory address space. PCI 
memory space is usually preallocated by the IRIX kernel; use this 
only when space has been allocated with <FUNCTION>pciio_piospace_alloc()</FUNCTION>; 
see <XREF IDREF="13054" TYPE="TITLE">&ldquo;Allocating PIO Bus Space&rdquo;</XREF>.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<NOTE><PREFIX>Note</PREFIX>PCIIO_MAP_* flags are being replaced by PCIIO_SPACE_* flags. Both are still supported but we recommend you change to using PCIIO_SPACE_* flags if you have not already done so.</NOTE>
<PARAGRAPH>The space selection PCIIO_PIOMAP_WIN(<VARIABLE>n</VARIABLE>) means that this map is to be based on Base Address Register (BAR) <VARIABLE>n</VARIABLE>, from 0 through 5, in the PCI configuration space. If this selects a BAR that decodes I/O space, the map is for I/O space. Typically this selects a BAR that decodes memory space. When the space is defined by a 64-bit base address register, use the lower number that indexes the word that contains the configuration bits.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>The PCI infrastructure verifies that a segment of size <VARIABLE>max</VARIABLE>, starting at <VARIABLE>addr</VARIABLE>, can be mapped in the specified <VARIABLE>space</VARIABLE>, based on the device configuration. If this is not possible, the map is not allocated and NULL is returned.</NOTE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Sizing the Space</TITLE><PARAGRAPH>The <VARIABLE>max</VARIABLE> argument sets a limit on the total span of addresses, from lowest to highest, for which this map can ever be used. When the map is always used for the same area, <VARIABLE>size</VARIABLE> and <VARIABLE>max</VARIABLE> are the same. When the map can be used for smaller segments within a larger area, <VARIABLE>size</VARIABLE> is the limit of any single segment and <VARIABLE>max</VARIABLE> the size of the total extent. The size to be mapped at any one time is specified when you apply <FUNCTION>pciio_piomap_addr()</FUNCTION> to the allocated map.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Specifying the No-Sleep Flag</TITLE><PARAGRAPH>The <FUNCTION>pciio_piomap_alloc()</FUNCTION> function may need to allocate memory. Normally it does so with a function that can sleep if memory is temporarily unavailable. If it is important that the function never sleep, pass PCIIO_NOSLEEP in the <VARIABLE>flags</VARIABLE> argument. When you do this, you must check for a NULL return, indicating that memory was not available.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="13054">Allocating PIO Bus Space</TITLE><PARAGRAPH>When the kernel locates a PCI device on the bus, it allocates the amount of PCI bus Memory and I/O address space that the device requests in its standard configuration registers. You get a PIO map into this preallocated space by allocating a map for space PCIIO_SPACE_WIN(<VARIABLE>n</VARIABLE>), specifying the configuration register for that space.</PARAGRAPH>
<PARAGRAPH>In some cases, a PCI device needs additional memory or I/O space based on device-specific configuration data that is not known to the kernel. You use pciio_piospace_alloc() to allocate additional ranges of memory or I/O space to be used by a device. It is up to your driver to program the device to use the allocated space.</PARAGRAPH>
<PARAGRAPH>When you need to perform PIO to allocated space that is not decoded by the standard BARs, you create a PIO map for space PCIIO_SPACE_MEM or PCIIO_SPACE_IO, and specify the exact base address that was allocated.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Performing PIO With a PIO Map</TITLE><PARAGRAPH>After a map has been allocated, it is inactive. The function <INDEXTARGET ID="20-pcisw19"><!-- POSTPROCESSDATA: 20-pcisw19|kernel functions:<FUNCTION>pciio_piomap_addr()</FUNCTION> --><FUNCTION>pciio_piomap_addr()</FUNCTION> activates a map if it is not active, and uses the map to translate an offset within the mapped space to a kernel virtual address.</PARAGRAPH>
<PARAGRAPH>In some systems, &ldquo;activating a map&rdquo; can be a null operation. In other systems, an active PIO map may represent a commitment of limited hardware resources&mdash;for example, a mapping register in a bus adapter. The function arguments are as follows (see also reference page <REFPAGE>pciio_pio(d3)</REFPAGE>: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>map</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>The allocated map to use. The map specifies the address space. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>The offset in the mapped space. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>size</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>The number of bytes to be mapped. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>If any argument is invalid, or if the map cannot be activated, the returned address is 0. The returned address, when it is not 0, can be used to fetch and store from the PCI bus as if it were memory. An attempt to access beyond the specified <VARIABLE>size</VARIABLE> might cause a kernel panic or might simply return bad data.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Accessing Memory and I/O Space</TITLE><PARAGRAPH>PIO access to memory or I/O space follows the same pattern: extract a translated address using <FUNCTION>pciio_piomap_addr()</FUNCTION>, then use the address as a memory pointer. The function in <XREF IDREF="66328" TYPE="TEXT">Example&nbsp;21-3</XREF> encapsulates the process of reading a word based on a map.</PARAGRAPH>
<CODE><CAPTION LBL="21-3"><PREFIX>Example 21-3 </PREFIX><XREFTARGET ID="66328">Function to Read Using a Map</CAPTION>__uint_32_t mapRefer(pciio_piomap_t map, iopaddr_t offset)
{
&nbsp;&nbsp;&nbsp;volatile __uint32_t *xaddr;&nbsp;&nbsp;&nbsp;/* word in PCI space */
&nbsp;&nbsp;&nbsp;xaddr = pciio_piomap_addr(map,offset,sizeof(*xaddr));
&nbsp;&nbsp;&nbsp;if (xaddr)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return *xaddr;
&nbsp;&nbsp;&nbsp;cmn_err(CE_WARN,"Unable to map PCI PIO address");
&nbsp;&nbsp;&nbsp;return 0xffffffff; /* imitate hardware fault */
}
</CODE>
<PARAGRAPH>Access to quantities smaller than 32 bits needs special handling. When you access a 16-bit or 8-bit value, the least-significant address bits must reflect the PCI byte-lane enable bits. What this means in practice is that the target address of a 16-bit value must be exclusive-ORed with 0x02, and the target address of an 8-bit value must be exclusive-ORed with 0x03. You can do this explicitly, by modifying the word address returned from <FUNCTION>pciio_piomap_addr()</FUNCTION>. Alternatively you can use the PIO address to base a structure, and in the structure you can invert the positions of bytes and halfwords within words, so that the sum of base and offset has the correct PIO address.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Deactivating an Address and Map</TITLE><PARAGRAPH>After you extract an address using <FUNCTION>pciio_piomap_addr()</FUNCTION>, the map is active, supporting the translated address over the span of bytes you specified. The address remains valid only as long as the map supports it.</PARAGRAPH>
<PARAGRAPH>The address becomes inactive when you call <FUNCTION>pciio_piomap_addr()</FUNCTION> for a different address or size based on the same map. If you attempt to use an address after the map has changed, a kernel panic can occur.</PARAGRAPH>
<PARAGRAPH>The map itself remains active until you call either <INDEXTARGET ID="20-pcisw20"><!-- POSTPROCESSDATA: 20-pcisw20|kernel functions:<FUNCTION>pciio_piomap_done()</FUNCTION> --><FUNCTION>pciio_piomap_done()</FUNCTION> or <FUNCTION>pciio_piomap_free()</FUNCTION>. In some systems, it costs nothing to keep a PIO map active. In other systems, an active PIO map may tie up global hardware resources. It is a good idea to call <FUNCTION>pciio_piomap_done()</FUNCTION> when the current address will not be used for some time.&space;</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Using One-Step PIO Translation</TITLE><PARAGRAPH>Some systems also support a one-step translation function, <INDEXTARGET ID="20-pcisw21"><!-- POSTPROCESSDATA: 20-pcisw21|kernel functions:<FUNCTION>pciio_piotrans_addr()</FUNCTION> --><FUNCTION>pciio_piotrans_addr()</FUNCTION>. This function takes a combination of the arguments of <FUNCTION>pciio_piomap_alloc()</FUNCTION> and <FUNCTION>pciio_piomap_addr()</FUNCTION>, and returns a translated address. In effect, it combines creating a map, using the map, and freeing the map, into a single step (see reference page <REFPAGE>pciio_pio(d3)</REFPAGE>).</PARAGRAPH>
<PARAGRAPH>This function can fail in systems that do not use hard-wired bus maps. If you use it, you must test the returned address. If it is 0, the one-step translation failed. The address is invalid, and you must create a PIO map instead.</PARAGRAPH>
<PARAGRAPH>The two-step process of allocating a map and then interrogating it is more general and works in all systems.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Accessing the Device Configuration</TITLE><PARAGRAPH>Typically a PCI driver needs to read the device configuration registers and possibly write to them. These are PIO operations, but the interface for performing them has varied between releases. <INDEXTARGET ID="20-pcisw22"><!-- POSTPROCESSDATA: 20-pcisw22|PCI bus:configuration space --></PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="29676">Changes In Configuration Interface</TITLE><PARAGRAPH>The hardware to generate PCI configuration cycles differs from one system to another. In all systems, access to configuration space is limited to 32-bit words on 32-bit boundaries. For these and other reasons, configuration access methods have varied from release to release.</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>In IRIX 6.3, configuration access was done by obtaining a PIO map address for configuration space and passing it to kernel functions <FUNCTION>pciio_config_get()</FUNCTION> and <FUNCTION>pciio_config_set()</FUNCTION>. This is because, in the O2 workstation, configuration cycles are not generated by normal PIO operations. The functions operate the special hardware.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>In IRIX 6.4, you performed configuration access using PIO through a PIO map. This is because, in the hardware supported by IRIX 6.4 (Origin, Onyx2, and Octane), normal PIO access through a map can generate PCI configuration cycles, although only for 32-bit transfers.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>As of this release, IRIX 6.5, you are required to use functions <FUNCTION>pciio_config_get()</FUNCTION> and <FUNCTION>pciio_config_set()</FUNCTION> for configuration access. This is because that release supports the O2 as well as other platforms. However, the interface to these functions is extended to support 8-byte registers, transfers of 1, 2, and 3 bytes, and access to nonstandard (device-defined) configuration registers.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>In order to bring a degree of uniformity to this picture, the macros in <XREF IDREF="93692" TYPE="TEXT">Example&nbsp;21-4</XREF> are presented.</PARAGRAPH>
<CODE><CAPTION LBL="21-4"><PREFIX>Example 21-4 </PREFIX><XREFTARGET ID="93692">Configuration Access Macros</CAPTION>/* PCI Config Space Access Macros for source compatibility in drivers
** that use the same source for IRIX 6.3, IRIX 6.4, and IRIX 6.5
** Usage:
** &nbsp;&nbsp;&nbsp;PCI_CFG_BASE(conn)
** &nbsp;&nbsp;&nbsp;PCI_CFG_GET(conn,base,offset,type)
** &nbsp;&nbsp;&nbsp;PCI_CFG_SET(conn,base,offset,type,value)
**
** Use caddr_t cfg_base = PCI_CFG_BASE(c) once during attach to get the
** PIO base address for the specific device needed by 6.3 and 6.4.
** Later, use PCI_CFG_GET() to read and PCI_CFG_SET() to write config registers.
**
** NOTE: IRIX 6.4 supports only 32-bit access. IRIX 6.3 determines the size of
** register (1-4 bytes) based on the offset and the standard layout of a Type 00
** PCI Configuration Space Header. If you specify a nonstandard size or offset,
** you get different results in different releases.
*/
#if IRIX6_3
#define&nbsp;PCI_CFG_BASE(c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pciio_piotrans_addr(c,0,PCIIO_SPACE_CFG,0,256,0)
#define&nbsp;PCI_CFG_GET(c,b,o,t)&nbsp;&nbsp;&nbsp;pciio_config_get(b,o)
#define&nbsp;PCI_CFG_SET(c,b,o,t,v)&nbsp;pciio_config_set(b,o,v)
#elif IRIX6_4
#define&nbsp;PCI_CFG_BASE(c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pciio_piotrans_addr(c,0,PCIIO_SPACE_CFG,0,256,0)
#define&nbsp;PCI_CFG_GET(c,b,o,t)&nbsp;&nbsp;&nbsp;((*(t *)((char *)(b)+(o))))
#define&nbsp;PCI_CFG_SET(c,b,o,t,v)&nbsp;((*(t *)((char *)(b)+(o))) = v)
#else&nbsp;/* IRIX 6.5 and onward */
#define&nbsp;PCI_CFG_BASE(c)&nbsp;&nbsp;NULL
#define&nbsp;PCI_CFG_GET(c,b,o,t)&nbsp;&nbsp;&nbsp;pciio_config_get(c,o,sizeof(t))
#define&nbsp;PCI_CFG_SET(c,b,o,t,v)&nbsp;pciio_config_set(c,o,sizeof(t),v)
#endif
</CODE>
<PARAGRAPH>The skeletal code in <XREF IDREF="30677" TYPE="TEXT">Example&nbsp;21-5</XREF> illustrates access to 32-bit words in configuration space using the macros.</PARAGRAPH>
<CODE><CAPTION LBL="21-5"><PREFIX>Example 21-5 </PREFIX><XREFTARGET ID="30677">Reading PCI Configuration Space</CAPTION>int hypo_attach(vertex_hdl_t connpt)
{
...
&nbsp;&nbsp;&nbsp;pDevInfo->conn_vh = connpt;
...
&nbsp;&nbsp;&nbsp;pDevInfo->cfg_base = PCI_CFG_BASE(connpt);
...
}
__uint32_t get_config_word(DevInfo *pDefInfo, int offset)
{
&nbsp;&nbsp;&nbsp;return PCI_CFG_GET(pDevInfo->conn_vh,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pDevInfo->cfg_base,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset, sizeof(__uint32_t));
}
void set_config_word(DevInfo *pDefInfo, int offset, __uint32_t val)
{
&nbsp;&nbsp;&nbsp;PCI_CFG_SET(pDevInfo->conn_vh,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pDevInfo->cfg_base,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offset,sizeof(val),val);
}
</CODE>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="49516">Interrogating PIO Maps</TITLE><PARAGRAPH>The following functions can be used to interrogate a PIO map object (see <REFPAGE>pciio_get(d3)</REFPAGE>): </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="21-3"><PREFIX>Table 21-3 </PREFIX>Functions for Interrogating PIO Maps</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="110"><PARAGRAPH>Function </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="63"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="212"><PARAGRAPH>Purpose and Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_pio_dev_get() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="63"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="212"><PARAGRAPH>Return the connection point handle from a map. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_pio_mapsz_get() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="63"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="212"><PARAGRAPH>Return the maximum size of a map. (Note that this 
returns a <VARIABLE>ulong</VARIABLE> as of IRIX 6.5.) </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_pio_pciaddr_get() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="63"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="212"><PARAGRAPH>Return the bus base address for a map. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_pio_space_get() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="63"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="212"><PARAGRAPH>Return the specified bus address space of a map. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_pio_slot_get() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="63"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="212"><PARAGRAPH>Return the bus slot number of the mapped device. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Most of these functions return values that were supplied to <INDEXTARGET ID="20-pcisw23"><!-- POSTPROCESSDATA: 20-pcisw23|kernel functions:<FUNCTION>pciio_piomap_alloc()</FUNCTION> --><FUNCTION>pciio_piomap_alloc()</FUNCTION>. However, <FUNCTION>pciio_pio_slot_get()</FUNCTION> provides a way to learn the bus slot number of a device. You can also obtain the slot number from a general query function; see <XREF IDREF="18244" TYPE="TITLE">&ldquo;Interrogating a PCI Device&rdquo;</XREF>.&space;</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="57296">PCI Drivers for the O2 (IP32) Platform</TITLE><PARAGRAPH>For IRIX 6.5 drivers on the O2 (IP32) platform, new function prototypes are provided for PIO access. These are defined in <INDEXTARGET ID="20-pcisw24"><!-- POSTPROCESSDATA: 20-pcisw24|PCI drivers for O2O2 PCI driver<ITALICS>pciio_pio_*</ITALICS> routines --><FILENAME>sys/PCI/pciio.h</FILENAME> as follows:</PARAGRAPH>
<CODE>
extern uint8_t     pciio_pio_read8(volatile uint8_t *addr);
extern uint16_t    pciio_pio_read16(volatile uint16_t *addr);
extern uint32_t    pciio_pio_read32(volatile uint32_t *addr);
extern uint64_t    pciio_pio_read64(volatile uint64_t *addr);
extern void   pciio_pio_write8(uint8_t val, volatile uint8_t *addr);
extern void   pciio_pio_write16(uint16_t val, volatile uint16_t *addr);
extern void   pciio_pio_write32(uint32_t val, volatile uint32_t *addr);
extern void   pciio_pio_write64(uint64_t val, volatile uint64_t *addr);
</CODE>
<PARAGRAPH>You must use the <COMMAND>pciio_pio_*</COMMAND> routines for all PIO access to the device, including accesses to the PCI configuration space. PIO access includes accesses to the device registers (<ITALICS>explicit</ITALICS> PIO) as well as any memory space that is mapped (<ITALICS>implicit</ITALICS> PIO). For example, if a device allows access to local memory on the card and the driver maps this memory to the system address space, every access to this address space <ITALICS>must</ITALICS> be done through the <COMMAND>pciio_pio_*</COMMAND> routines.</PARAGRAPH>
<PARAGRAPH>Use the compiler switch <SCREENDISPLAY>-DUSE_PCI_PIO</SCREENDISPLAY> to enable the IP32 PIO read and write routines in the compilation of the IP32 device driver module. Turning this flag on or off lets you use the same source to compile the driver for different target platforms. While the USE_PCI_PIO flag is required for the IP32 architecture, it should not be used when compiling for other architectures. Refer to <XREF IDREF="66363" TYPE="TITLE">&ldquo;Compiling and Linking&rdquo;</XREF> for details on compiling for different targets.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>PCI PIO Code Examples</TITLE><PARAGRAPH>In the following examples, a function receives kernel virtual addresses (mapped with the pciio_piotrans_addr() call) for a control register and on board memory in the PIO address space of a hypothetical PCI device. The 32-bit control register is set to enable reads of data from on-board memory (accessible as 8-bits).</PARAGRAPH>
<PARAGRAPH>The function could look like that shown in <XREF IDREF="31028" TYPE="TEXT">Example&nbsp;21-6</XREF> for a device driver <ITALICS>not</ITALICS> written for the O2 platform.</PARAGRAPH>
<CODE><CAPTION LBL="21-6"><PREFIX>Example 21-6 </PREFIX><XREFTARGET ID="31028">Non-O2 PCI PIO Code Example</CAPTION>#define ENABLE_SOMETHING 0x1
&space;   void
&space;   example(volatile unsigned int *control_reg,
&space;           volatile unsigned char *device_data,
&space;           int len,
&space;           unsigned char *buffer) 
&space;   {
&space;       int i;
&nbsp;
&space;       /*
&space;        * set the enable bit
&space;        */ 
&space;       *control_reg |= ENABLE_SOMETHING;
&nbsp;
&space;       /*
&space;        * copy the data to the caller's buffer
&space;        */
&space;       for (i = 0; i &lt; len; i++)
&space;           *buffer++ = *device_data++;
&nbsp;
&space;       /*
&space;        * reset enable bit
&space;        */
&space;       *control_reg &amp;= ~ENABLE_SOMETHING;
&space;   }
</CODE>
<PARAGRAPH>To work correctly on the O2 platform, the driver code in <XREF IDREF="31028" TYPE="TEXT">Example&nbsp;21-6</XREF> would have to change as shown in <XREF IDREF="33288" TYPE="TEXT">Example&nbsp;21-7</XREF>.</PARAGRAPH>
<CODE><CAPTION LBL="21-7"><PREFIX>Example 21-7 </PREFIX><XREFTARGET ID="33288">O2 PCI PIO Code Example</CAPTION>#define ENABLE_SOMETHING 0x1
&space;   void
&space;   example(volatile unsigned int *control_reg,
&space;           volatile unsigned char *device_data,
&space;           unsigned char *buffer, 
&space;           int len)
&space;   {
&space;       int i;
&space;       unsigned int reg_val;
&nbsp;
&space;       /*
&space;        * NOTE: use of &amp;= and |= for PIO is strongly
&space;        *       discouraged due to the unpredictability
&space;        *       of the actual instructions generated by
&space;        *       the compiler. We recommend breaking
&space;        *       these up into simpler expressions.
&space;        *
&space;        * set the enable bit
&space;        */ 
&space;       reg_val = pciio_pio_read32(control_reg);
&space;       reg_val = reg_val | ENABLE_SOMETHING;
&space;       pciio_pio_write32(reg_val, control_reg);
&nbsp;
&space;       /*
&space;        * copy the data to the caller's buffer
&space;        */
&space;       for (i = 0; i &lt; len; i++)
&space;           *buffer++ = pciio_pio_read8(device_data++);
&space;       /*
&space;        * reset enable bit
&space;        */
&space;       reg_val = pciio_pio_read32(control_reg);
&space;       reg_val = reg_val &amp; ~ENABLE_SOMETHING;
&space;       pciio_pio_write32(reg_val, control_reg);
&space;   }
</CODE>
<PARAGRAPH>If you are writing new code from scratch for multiple platforms, you can use the &ldquo;O2-style&rdquo; described here for all supported platforms and just compile for each target platform as described in <XREF IDREF="66363" TYPE="TITLE">&ldquo;Compiling and Linking&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="83353">Using DMA Maps</TITLE><PARAGRAPH>You use a DMA map to establish a mapping between a buffer in kernel virtual space and some portion of the PCI bus memory space so that a PCI device can read and write to memory. Depending on the machine architecture, the mapping may be a simple translation function, or it may require the kernel to program hardware registers in one or more bus adapters. The software interface is the same in all cases.<INDEXTARGET ID="20-pcisw25"><!-- POSTPROCESSDATA: 20-pcisw25|Direct Memory Access (DMA):mapping --></PARAGRAPH>
<PARAGRAPH>You cannot program a PCI bus master for DMA without at least one DMA map. Often you will allocate two or more. Typically you save the addresses of the allocated maps in the device information structure; and you store the address of the device information structure in turn in the hwgraph vertex for the device.</PARAGRAPH>
<PARAGRAPH>The functions that are used to manage simple DMA maps are summarized in <XREF IDREF="75545" TYPE="TABLE">Table&nbsp;21-4</XREF>. Details are found in reference page <REFPAGE>pciio_dma(d3)</REFPAGE>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="21-4"><PREFIX>Table 21-4 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="75545">Functions for Simple DMA Maps for PCI</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="110"><PARAGRAPH>Function </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="63"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="212"><PARAGRAPH>Purpose and Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_dmamap_alloc() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="63"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="212"><PARAGRAPH>Create a DMA map object, specifying the maximum 
extent of memory the map will have to cover. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_dmamap_addr() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="63"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="212"><PARAGRAPH>Set up mapping from a kernel memory address for a 
specified length, to the PCI bus, returning the bus 
address. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_dmamap_drain() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="63"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="212"><PARAGRAPH>Complete any active DMA on a specified map. May 
flush prefetch and gather buffers in the PCI adapter. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_dmamap_list() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="63"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="212"><PARAGRAPH>Set up a mapping that relates all addresses in an 
<VARIABLE>alenlist</VARIABLE> to the PCI bus, returning a new <VARIABLE>alenlist</VARIABLE> 
containing PCI bus addresses. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_dmalist_drain() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="63"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="212"><PARAGRAPH>Complete any active DMA on a map set up using 
<FUNCTION>pciio_dmamap_list()</FUNCTION>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_dmamap_done() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="63"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="212"><PARAGRAPH>Make a DMA map inactive. Release any hardware 
resources associated to the active mapping. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_dmamap_free() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="63"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="212"><PARAGRAPH>Release a DMA map object. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_dmatrans_list() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="63"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="212"><PARAGRAPH>Request immediate translation of the addresses in an 
<VARIABLE>alenlist</VARIABLE>. Returns NULL unless this system supports 
fixed DMA addressing. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_dmatrans_addr() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="63"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="212"><PARAGRAPH>Request immediate translation of the address of a 
contiguous memory buffer to a bus address. Returns 
NULL unless this system supports fixed DMA 
addressing. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_dmaadr_drain() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="63"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="212"><PARAGRAPH>Complete any active DMA on a mapping 
established using <FUNCTION>pciio_dmatrans_addr()</FUNCTION>. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>In summary, a DMA map is used as follows:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Allocate it with <FUNCTION>pciio_dmamap_alloc()</FUNCTION>. </PARAGRAPH>
</LIST>
<LIST><PARAGRAPH><XREFTARGET ID="83551">Activate the map and extract a PCI bus memory base address using <FUNCTION>pciio_dmamap_addr()</FUNCTION> or <FUNCTION>pciio_dmamap_list()</FUNCTION>. </PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Program the base addresses into the PCI bus master device and start the transfer. To start additional transfers that fall in the same mapped segment, repeat this step.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>When DMA to the mapped segment is complete, deactivate the map using <FUNCTION>pciio_dmamap_done()</FUNCTION>.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>When further DMA is planned, return to step <XREF IDREF="83551" TYPE="TEXT">2</XREF>.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>When the map is no longer needed, release it with <FUNCTION>pciio_dmamap_free()</FUNCTION>.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<SECTION2 LBL="" HELPID = ""><TITLE>Allocating DMA Maps</TITLE><PARAGRAPH>A DMA map is created by <INDEXTARGET ID="20-pcisw26"><!-- POSTPROCESSDATA: 20-pcisw26|kernel functions:<FUNCTION>pciio_dmamap_alloc()</FUNCTION> --><FUNCTION>pciio_dmamap_alloc()</FUNCTION>, which takes arguments are as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><VARIABLE>vhdl</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Connection-point <VARIABLE>vertex_hdl_t</VARIABLE> received by <VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>attach()</FUNCTION>. This handle 
identifies the device to the kernel by its bus and slot positions. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><VARIABLE>dev_desc</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Device descriptor structure (see text following). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><VARIABLE>byte_count_max</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Maximum size of the area that will be mapped at any one time. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><VARIABLE>flags</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Usage flags and optional no-sleep flag. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<SECTION3 LBL="" HELPID = ""><TITLE>Preparing a device_desc_t</TITLE><PARAGRAPH>The device descriptor structure type <INDEXTARGET ID="20-pcisw27"><!-- POSTPROCESSDATA: 20-pcisw27|data types:<VARIABLE>device_desc_t</VARIABLE> --><VARIABLE>device_desc_t</VARIABLE> is declared in <FILENAME>iobus.h</FILENAME>, which is included by <FILENAME>pciio.h</FILENAME> (see also reference page <REFPAGE>device_desc(d4x)</REFPAGE>). In this release there is little that the device driver needs to know about this structure and its contents. The simplest way to get a device descriptor that can be handed to <FUNCTION>pciio_dmamap_alloc()</FUNCTION> is to call <FUNCTION>device_desc_default_get()</FUNCTION> passing the same connection-point vertex handle, as follows:</PARAGRAPH>
<CODE>
ret = pciio_dmamap_alloc(convh,device_desc_default_get(convh),...)
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="34526">Setting Flag Values</TITLE><PARAGRAPH>The following flag values control data transfer: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH>PCIIO_DMA_CMD </PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Configure as a generic &ldquo;command&rdquo; stream. Generally 
this means turn off prefetchers and write gatherers, and 
whatever else might be necessary to make command 
ring DMAs work as expected. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH>PCIIO_DMA_DATA </PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Configure as a generic &ldquo;data&rdquo; stream. Generally, this 
means turning on prefetchers and write gatherers, and 
anything else that might increase DMA throughput 
(short of using &ldquo;high priority&rdquo; or &ldquo;real time&rdquo; resources 
that may lower overall system performance). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH>PCIIO_PREFETCH&lbreak;PCIIO_NOPREFETCH </PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Control the use of prefetch hardware, overriding the 
CMD or DATA selection. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH>PCIIO_WRITE_GATHER&lbreak;PCIIO_NOWRITE_GATHER </PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Control the use of write-gather hardware, overriding the 
CMD or DATA selection. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>(Note that the values for the PCIIO_DMA* flags has changed for IRIX 6.5.) All systems have the ability to gather as much as one cache line of device data before starting a write to memory, but some systems have better write-gather support. All systems have a certain amount of &ldquo;prefetch&rdquo; ability in that they load a full cache line from memory when the device issues a read. However, some systems can prefetch the next cache line while the device is still accepting the first one. The PCI infrastructure notes in the DMA map whether you want these features maximized for the given hardware, or minimized, depending on the flag settings.</PARAGRAPH>
<PARAGRAPH>The following flag values control the use of the PCI bus adapter: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>PCIIO_DMA_A64 </PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="261"><PARAGRAPH>Device and driver are prepared to use 64-bit addressing. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>PCIIO_BYTE_STREAM </PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="261"><PARAGRAPH>Retain the order of a stream of bytes between device and 
memory. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>PCIIO_WORD_VALUES </PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="261"><PARAGRAPH>Byte-swap 32-bit words during transfer as required to 
produce big-endian data order in memory. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>You should specify either PCIIO_BYTE_STREAM or PCIIO_WORD_VALUES; there is no default. (More correctly, the default is &ldquo;whatever the hardware of this system does,&rdquo; and different systems do different things.) When you specify PCIIO_BYTE_STREAM, a block of bytes transferred from the device to memory has the same sequence of bytes in both locations. When you specify PCIIO_WORD_VALUES, the numerical significance of the bytes in each 32-bit word are preserved between the big-endian memory and little-endian device.</PARAGRAPH>
<PARAGRAPH>The following flag values control kernel operations: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>PCIIO_NOSLEEP </PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="261"><PARAGRAPH>Do not sleep on memory allocation. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>PCIIO_INPLACE </PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="261"><PARAGRAPH>Translate <VARIABLE>alenlists</VARIABLE> in place instead of copying them. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Using a DMA Map</TITLE><PARAGRAPH>After a map has been allocated, it is inactive. When you apply a function to a map to get a translated address, the function activates the map if it is not active, and uses the map to set up a correspondence between PCI bus memory addresses and one or more segments of kernel virtual address space.</PARAGRAPH>
<PARAGRAPH>In some systems, &ldquo;activating a map&rdquo; can be a null operation. In other systems, an active DMA map may represent a commitment of limited hardware resources&mdash;for example, mapping registers in a bus adapter.</PARAGRAPH>
<PARAGRAPH>You can use a DMA map to map a specified memory segment, or you can use it to translate all entries in an address/length list (see <XREF IDREF="65822" TYPE="TITLE">&ldquo;Address/Length Lists&rdquo;</XREF>) in a single operation.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="27119">Mapping an Address/Length List</TITLE><PARAGRAPH>You map an <INDEXTARGET ID="20-pcisw28"><!-- POSTPROCESSDATA: 20-pcisw28|kernel functions:<FUNCTION>pciio_dmamap_list()</FUNCTION> --><VARIABLE>alenlist</VARIABLE> using <FUNCTION>pciio_dmamap_list()</FUNCTION>. This function takes an <VARIABLE>alenlist</VARIABLE> that represents a memory buffer, and in one operation produces a new list containing PCI bus addresses and lengths. You read out the translated addresses from the list and program them into the bus master device (see <XREF IDREF="29580" TYPE="TITLE">&ldquo;Using Address/Length Lists&rdquo;</XREF>).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Mapping a Specific Buffer</TITLE><PARAGRAPH>You obtain a DMA map for a single, contiguous span of kernel virtual memory by calling <INDEXTARGET ID="20-pcisw29"><!-- POSTPROCESSDATA: 20-pcisw29|kernel functions:<FUNCTION>pciio_dmamap_addr()</FUNCTION> --><FUNCTION>pciio_dmamap_addr()</FUNCTION>. If the mapping cannot be set up, 0 is returned. (You must check for this possibility, because if you start a DMA transfer to location 0, a bus error results.) Otherwise the value returned is a PCI bus address that you can program into a bus master device. When the device accesses that address, it accesses the specified memory location.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Completing DMA Transfers</TITLE><PARAGRAPH>If it is necessary to establish that a DMA transfer is fully complete&mdash;all input data stored in physical memory, all output data copied from memory&mdash;use the &ldquo;drain&rdquo; function that corresponds to the way the map was activated. For example, if the map was activated using <FUNCTION>pciio_dmamap_list()</FUNCTION>, you call pciio_dmalist_drain() to ensure that current DMA is complete. When the bus adapter uses prefetch buffers or write-gather buffers, they are flushed.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Deactivating Addresses and Maps</TITLE><PARAGRAPH>Once you have created a mapping, the map is active. It remains active until you use the same DMA map object to map a different buffer, or until you call either <INDEXTARGET ID="20-pcisw30"><!-- POSTPROCESSDATA: 20-pcisw30|kernel functions:<FUNCTION>pciio_dmamap_done()</FUNCTION> --><FUNCTION>pciio_dmamap_done()</FUNCTION> or <FUNCTION>pciio_dmamap_free()</FUNCTION>.</PARAGRAPH>
<PARAGRAPH>In some systems, it costs nothing to keep a DMA map active. In other systems, an active map may tie up global hardware resources. It is a good idea to call <FUNCTION>pciio_dmamap_done()</FUNCTION> when the I/O operation is complete.</PARAGRAPH>
<CAUTION><PREFIX>Caution</PREFIX>Never call <FUNCTION>pciio_dmamap_done()</FUNCTION>&space;<ITALICS>before</ITALICS> the device has stopped sending data. Memory corruption could result.</CAUTION>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using One-Step DMA Translation</TITLE><PARAGRAPH>Some systems also support one-step mapping functions <INDEXTARGET ID="20-pcisw31"><!-- POSTPROCESSDATA: 20-pcisw31|kernel functions:<FUNCTION>pciio_dmatrans_list()</FUNCTION> --><INDEXTARGET ID="20-pcisw32"><!-- POSTPROCESSDATA: 20-pcisw32|kernel functions:<FUNCTION>pciio_dmatrans_addr()</FUNCTION> --><FUNCTION>pciio_dmatrans_addr()</FUNCTION> and <FUNCTION>pciio_dmatrans_list()</FUNCTION>. In effect, these functions combine creating a map, using the map, and freeing the map into a single step. They can fail (returning 0) in systems that do not use simple bus maps. If you use them, you must test the returned address. If it is 0, the one-step translation failed and the address is invalid.</PARAGRAPH>
<PARAGRAPH>The two-step process of allocating a map and then interrogating it is more general and works in all systems.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Interrogating DMA Maps</TITLE><PARAGRAPH>The following functions can be used to interrogate a DMA map object (see <REFPAGE>pciio_get(d3)</REFPAGE>):</PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="21-5"><PREFIX>Table 21-5 </PREFIX>Functions for Interrogating DMA Maps</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="110"><PARAGRAPH>Function </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="63"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="212"><PARAGRAPH>Purpose and Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_dma_dev_get() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="63"><PARAGRAPH>ddi.h, pciio.h</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="212"><PARAGRAPH>Return the connection point handle from a map.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_dma_slot_get()</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="63"><PARAGRAPH>ddi.h, pciio.h</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="212"><PARAGRAPH>Return the bus slot number of the mapped device.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="35093">Registering an Interrupt Handler</TITLE><PARAGRAPH>When a device can interrupt, you must register an interrupt handler for it. This is done in a two-step process. First you create an interrupt connection object; then you use that object to specify the interrupt handling function. Prior to unloading the driver or detaching the device, you must unregister the handler (but you can retain the interrupt connection object).<INDEXTARGET ID="20-pcisw33"><!-- POSTPROCESSDATA: 20-pcisw33|PCI bus:interrupt handler --></PARAGRAPH>
<PARAGRAPH>The functions for managing interrupt handlers are summarized in <XREF IDREF="25668" TYPE="TABLE">Table&nbsp;21-6</XREF>. For syntax details see reference page <REFPAGE>pciio_intr(d3)</REFPAGE>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="21-6"><PREFIX>Table 21-6 </PREFIX><XREFTARGET ID="25668">Functions for Managing PCI Interrupt Handlers</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="117"><PARAGRAPH>Function </PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="270"><PARAGRAPH>Purpose and Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH>pciio_intr_alloc() </PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="270"><PARAGRAPH>Create an interrupt object that enables interrupts to flow from a 
specified device. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH>pciio_intr_connect() </PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="270"><PARAGRAPH>Associate an interrupt object with an interrupt handler function. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH>pciio_intr_disconnect() </PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="270"><PARAGRAPH>Remove the association between an interrupt object and a handler 
function. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH>pciio_intr_free() </PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="270"><PARAGRAPH>Release an interrupt object. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<SECTION2 LBL="" HELPID = ""><TITLE>Creating an Interrupt Object</TITLE><PARAGRAPH>A software object that represents an interrupt connection is created with <INDEXTARGET ID="20-pcisw34"><!-- POSTPROCESSDATA: 20-pcisw34|kernel functions:<FUNCTION>pciio_intr_alloc()</FUNCTION> --><FUNCTION>pciio_intr_alloc()</FUNCTION>, which takes the following arguments: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>vhdl</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>The hwgraph vertex for the device attachment point&mdash;the same vertex 
originally passed to the <VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>attach()</FUNCTION> entry point. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>desc</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Device descriptor structure (see text following). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>lines</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>The selection of one or more PCI interrupt lines used by this device, a 
sum of PCIIO_INTR_LINE_A, PCIIO_INTR_LINE_B, ..._C, and ..._D. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>owner</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>The hwgraph vertex to use when reporting errors&mdash;same as <VARIABLE>vhdl</VARIABLE>, or else 
a vertex created by the driver. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The interrupt object is used in establishing a handler, and it is needed later to stop taking interrupts. You should save its address in the device information structure you store in the hwgraph vertex.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Preparing a device_desc_t</TITLE><PARAGRAPH>The device descriptor structure type <INDEXTARGET ID="20-pcisw35"><!-- POSTPROCESSDATA: 20-pcisw35|data types:<VARIABLE>device_desc_t</VARIABLE> --><VARIABLE>device_desc_t</VARIABLE> is declared in <FILENAME>iobus.h</FILENAME>, which is included by <FILENAME>pciio.h</FILENAME> (see also reference page <REFPAGE>device_desc(d4x)</REFPAGE>). In this release there is little that the device driver needs to know about this structure and its contents. The simplest way to get a device descriptor that can be handed to <FUNCTION>pciio_intr_alloc()</FUNCTION> is to call <FUNCTION>device_desc_default_get()</FUNCTION> passing the same connection-point vertex handle, as follows:</PARAGRAPH>
<EXAMPLE>
ret = pciio_intr_alloc(convh,device_desc_default_get(convh),...)
</EXAMPLE>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Connecting the Handler</TITLE><PARAGRAPH>After creating the interrupt object, you establish a handler using <INDEXTARGET ID="20-pcisw36"><!-- POSTPROCESSDATA: 20-pcisw36|kernel functions:<FUNCTION>pciio_intr_connect()</FUNCTION> --><FUNCTION>pciio_intr_connect()</FUNCTION>. Its principal arguments are the interrupt object, a handler address, and a value to be passed to the handler when it is called: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>intr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>The value returned by <FUNCTION>pciio_intr_alloc()</FUNCTION>. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>func</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Address of the function to be called when an interrupt occurs; see 
following text for the prototype. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>arg</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>A pointer-sized value to be passed as the argument to <VARIABLE>func</VARIABLE> each time it is 
called. Typically the address of the device information structure, or the 
handle of the device vertex. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><VARIABLE>thread</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Passed as NULL. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Before calling <FUNCTION>pciio_intr_connect()</FUNCTION>, an interrupt handler should call <FUNCTION>device_desc_dup()</FUNCTION>, <FUNCTION>device_desc_intr_name_set()</FUNCTION>, and <FUNCTION>device_desc_default_set()</FUNCTION> in that order. See the <REFPAGE>device_desc_ops(D3X)</REFPAGE> reference page for more information.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Connecting the Handler</TITLE><PARAGRAPH>The function prototype for the interrupt handler is named intr_func_t and is declared in <FILENAME>sys/iobus.h</FILENAME> (which is included by <FILENAME>sys/PCI/pciio.h</FILENAME>). The function prototype is</PARAGRAPH>
<CODE>
typedef void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*intr_arg_t;
typedef void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intr_func_f(intr_arg_t);
typedef intr_func_f&nbsp;&nbsp;*intr_func_t;
</CODE>
<CAUTION><PREFIX>Caution</PREFIX>This function prototype differs from the same prototype as it was declared in IRIX 6.3. The interrupt handler in 6.3 is declared to receive one additional argument that is not supported in the later releases.</CAUTION>
<PARAGRAPH>If a device will interrupt on line C, interrupt setup could resemble <XREF IDREF="21260" TYPE="TEXT">Example&nbsp;21-8</XREF>.</PARAGRAPH>
<CODE><CAPTION LBL="21-8"><PREFIX>Example 21-8 </PREFIX><XREFTARGET ID="21260">Setting Up a PCI Interrupt Handler</CAPTION>pciio_intr_t intobj;
extern void int_handler(devinfo*);
int retcode;
device_desc_t dev_desc;
intobj = pciio_intr_alloc(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vhdl, /* as received in attach() */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;/* device descriptor is n.a. for pci */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PCIIO_INTR_LINE_C, /* the line it uses */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vhdl);
dev_desc = device_desc_dup(vhdl);
device_desc_intr_name_set(0, "PCI");
device_desc_default_set(vhdl, 0);
retcode = pciio_intr_connect(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intobj, /* the interrupt object */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(intr_func_t) int_handler, /* the handler */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(intr_arg_t) pDevInfo, /* dev info as input */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void*)0 ); /* let kernel pick the thread */
if (!retcode) cmn_err(CE_WARN,"oh fiddlesticks");
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Handler Operation</TITLE><PARAGRAPH>Interrupts from a device are disabled (if possible) and discarded until a handler is connected. However, interrupts in general are enabled when the <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> entry point is called. If the PCI device is in a state that can produce an interrupt, the interrupt handling function can be called before <FUNCTION>pciio_intr_connect()</FUNCTION> returns. Make sure that all global data used by the interrupt handler has been initialized before you connect it.</PARAGRAPH>
<PARAGRAPH>When called, the interrupt handler runs as an independent thread in the kernel. It can run concurrently with any other part of the driver, and concurrently with other interrupt handlers. Although interrupt threads run at a high priority, there are kernel threads with still higher priority that can preempt the interrupt handler. See <XREF IDREF="41192" TYPE="TITLE">&ldquo;Interrupt Entry Point and Handler&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>PCI devices can share the four PCI interrupt lines. As a result, in some cases the kernel cannot tell which device caused an interrupt. When there is any doubt, the kernel calls all the interrupt handlers that are registered to that interrupt line. For this reason, your interrupt handler must not assume that its device did cause the interrupt. It should always test to see if an interrupt is really pending, and exit immediately when one is not.</PARAGRAPH>
<PARAGRAPH>The handler gets information about the device only from the argument that was passed to it. This is presumably the device information structure, containing driver-specific information about the device and its status, PIO maps, and the vertex handle of the connection point as passed to <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION>. This handle can be used to get more information about the device; see <XREF IDREF="18244" TYPE="TITLE">&ldquo;Interrogating a PCI Device&rdquo;</XREF>.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>Lost interrupts can occur. An application must not set the interrupt line if it is already set, because this causes a race condition. Furthermore, an application must wait a small amount of time after the interrupt line transitions from set to unset, to make sure the minimum deassert time is not violated. One a solution has been to modify firmware never to set the interrupt line unless the host has cleared it, and also wait a few clocks.</NOTE>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Disconnecting the Handler</TITLE><PARAGRAPH>The only way to stop receiving interrupts is to disconnect the handler. This is done with a call to <INDEXTARGET ID="20-pcisw37"><!-- POSTPROCESSDATA: 20-pcisw37|kernel functions:<FUNCTION>pciio_intr_disconnect()</FUNCTION> --><FUNCTION>pciio_intr_disconnect()</FUNCTION>. Its only argument is the interrupt object returned by <FUNCTION>pciio_intr_alloc()</FUNCTION>.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Interrogating an Interrupt Handler</TITLE><PARAGRAPH>The following functions can be used to interrogate an interrupt object (see <REFPAGE>pciio_get(d3)</REFPAGE>):</PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="21-7"><PREFIX>Table 21-7 </PREFIX>Functions for Interrogating an Interrupt Object</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="110"><PARAGRAPH>Function </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="63"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="212"><PARAGRAPH>Purpose and Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_intr_dev_get() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="63"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="212"><PARAGRAPH>Return the connection point handle from the object. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>pciio_intr_cpu_get() </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="63"><PARAGRAPH>ddi.h, pciio.h </PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="212"><PARAGRAPH>Return the CPU that receives the hardware 
interrupt. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="97396">Registering an Error Handler</TITLE><PARAGRAPH>You can register a function to be called in case of a bus error related to a specific PCI device. When the kernel detects a bus error, and can isolate the error to the bus address space related to one of your PIO or DMA maps, it calls the error handling function. If the function can correct the error, it returns 0. If it cannot, or if it does not understand the error, it returns 1, and the kernel continues with default error actions. <INDEXTARGET ID="20-pcisw38"><!-- POSTPROCESSDATA: 20-pcisw38|PCI bus:error handler --></PARAGRAPH>
<PARAGRAPH>The declarations used to set up an error handler are summarized in <XREF IDREF="96065" TYPE="TABLE">Table&nbsp;21-8</XREF> (see also reference page <REFPAGE>pciio_error(d3)</REFPAGE>). </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="21-8"><PREFIX>Table 21-8 </PREFIX><XREFTARGET ID="96065">Declaration Used In Setting Up PCI Error Handlers</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="99"><PARAGRAPH>Identifier</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="72"><PARAGRAPH>Header File</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="216"><PARAGRAPH>Purpose or Use</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><VARIABLE>ioerror_mode_t</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="72"><PARAGRAPH><FILENAME>sys/ioerror.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="216"><PARAGRAPH>Enumeration for the kernel mode during which the 
error was found: probing the bus, normal operations, 
user-mode access, or error retry. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><VARIABLE>ioerror_t</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="72"><PARAGRAPH><FILENAME>sys/ioerror.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="216"><PARAGRAPH>Structure giving details of an error. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><VARIABLE>error_handler_arg_t</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="72"><PARAGRAPH><FILENAME>sys/ioerror.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="216"><PARAGRAPH>Name for void*, the opaque value provided by the 
driver to be passed to the error handler to describe 
the device. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><VARIABLE>error_handler_f</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="72"><PARAGRAPH><FILENAME>sys/ioerror.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="216"><PARAGRAPH>Name for the prototype of an error handler function, 
convenient for forward or <KEYWORD>extern</KEYWORD> declaration of the 
handler. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>pciio_error_register() </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="72"><PARAGRAPH><FILENAME>sys/PCI/pciio.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="216"><PARAGRAPH>Function to register or unregister an error handler. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>You code your error handler using the prototype established by <VARIABLE>error_handler_f</VARIABLE>:</PARAGRAPH>
<CODE>
typedef int
error_handler_f(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error_handler_arg_t <VARIABLE>arg</VARIABLE>,&nbsp;/* device info, registered */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int <VARIABLE>error_code</VARIABLE>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* IOEC_* values in sys/ioerror.h */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ioerror_mode_t <VARIABLE>mode</VARIABLE>,&nbsp;&nbsp;&nbsp;&nbsp;/* mode value in sys/ioerror.h */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ioerror_t *<VARIABLE>info</VARIABLE>);
</CODE>
<PARAGRAPH>You register the handler by calling <INDEXTARGET ID="20-pcisw39"><!-- POSTPROCESSDATA: 20-pcisw39|kernel functions:<FUNCTION>pciio_error_register()</FUNCTION> --><FUNCTION>pciio_error_register()</FUNCTION>, passing three values:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The vertex handle of the connection point, as passed to the <VARIABLE>pfx</VARIABLE><FUNCTION>attach()</FUNCTION> entry point).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The address of the error handler function.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>An address to be passed as the first argument of the error handler function, when it is called.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>To unregister the error handler (when the driver is unloading, or when detaching the device), call <FUNCTION>pciio_error_register()</FUNCTION> with the same vertex handle, but with NULL for the address of the handler.&space;</PARAGRAPH>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="18244">Interrogating a PCI Device</TITLE><PARAGRAPH>The following functions can be used to get an information structure that describes a PCI device, and to extract data from it (see <REFPAGE>pciio_get(d3)</REFPAGE>):</PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="21-9"><PREFIX>Table 21-9 </PREFIX>Functions for Interrogating a PCI Device</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="117"><PARAGRAPH>Function </PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="64"><PARAGRAPH>Header Files</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="208"><PARAGRAPH>Purpose and Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH>pciio_info_get()</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="64"><PARAGRAPH>ddi.h, pciio.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="208"><PARAGRAPH>Given the connection point as passed to <VARIABLE>pfx</VARIABLE>
<FUNCTION></FUNCTION><FUNCTION>attach()</FUNCTION>, 
return a read-only object with information about 
the device.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH>pciio_info_dev_get() </PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="64"><PARAGRAPH>ddi.h, pciio.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="208"><PARAGRAPH>Return the connection point handle.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH>pciio_info_bus_get()</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="64"><PARAGRAPH>ddi.h, pciio.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="208"><PARAGRAPH>Return the PCI bus number.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH>pciio_info_slot_get()</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="64"><PARAGRAPH>ddi.h, pciio.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="208"><PARAGRAPH>Return the slot number on the bus.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH>pciio_info_func_get()</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="64"><PARAGRAPH>ddi.h, pciio.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="208"><PARAGRAPH>Return the function number of the device (a PCI 
card can have up to 8 separate functions).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH>pciio_info_vendor_id_get()</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="64"><PARAGRAPH>ddi.h, pciio.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="208"><PARAGRAPH>Return the vendor ID value.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH>pciio_info_device_id_get()</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="64"><PARAGRAPH>ddi.h, pciio.h</PARAGRAPH>
</CELL>
<CELL LEFT="195" WIDTH="208"><PARAGRAPH>Return the device ID value.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="19082">Example PCI Driver</TITLE><CODE>
/**********************************************************************
*              Copyright (C) 1990-1993, Silicon Graphics, Inc.        *
* These coded instructions, statements, and computer programs contain *
* unpublished proprietary information of Silicon Graphics, Inc., and  *
* are protected by Federal copyright law.  They may not be disclosed  *
* to third parties or copied or duplicated in any form, in whole or   *
* in part, without prior written consent of Silicon Graphics, Inc.    *
**********************************************************************/
#ident  "io/sample_pciio.c: $Revision: 1.6 $"
#include &lt;sys/types.h>
#include &lt;sys/cpu.h>
#include &lt;sys/systm.h>
#include &lt;sys/cmn_err.h>
#include &lt;sys/errno.h>
#include &lt;sys/buf.h>
#include &lt;sys/ioctl.h>
#include &lt;sys/cred.h>
#include &lt;ksys/ddmap.h>
#include &lt;sys/poll.h>
#include &lt;sys/invent.h>
#include &lt;sys/debug.h>
#include &lt;sys/sbd.h>
#include &lt;sys/kmem.h>
#include &lt;sys/edt.h>
#include &lt;sys/dmamap.h>
#include &lt;sys/hwgraph.h>
#include &lt;sys/iobus.h>
#include &lt;sys/iograph.h>
#include &lt;sys/param.h>
#include &lt;sys/pio.h>
#include &lt;sys/sema.h>
#include &lt;sys/ddi.h>
#include &lt;sys/atomic_ops.h>
#include &lt;sys/PCI/PCI_defs.h>
#include &lt;sys/PCI/pciio.h>
#define NEW(ptr)        (ptr = kmem_alloc(sizeof (*(ptr)), KM_SLEEP))
#define DEL(ptr)        (kmem_free(ptr, sizeof (*(ptr))))
/*
&space;*    psamp: a generic device driver for a generic PCI device.
&space;*/
int         psamp_devflag = D_MP;
int         psamp_inuse = 0;     /* number of "psamp" devices open */
/* ====================================================================
&space;*          Device-Related Constants and Structures
&space;*/
#define PSAMP_VENDOR_ID_NUM     0x5555
#define PSAMP_DEVICE_ID_NUM     0x555
/*
&space;*    All registers on the Sample PCIIO Client
&space;*      device are 32 bits wide.
&space;*/
typedef __uint32_t      psamp_reg_t;
typedef volatile struct psamp_regs_s *psamp_regs_t; /* dev registers */
typedef struct psamp_soft_s *psamp_soft_t;         /* software state */
/*
&space;*    psamp_regs: layout of device registers
&space;*      Our device config registers are, of course, at
&space;*      the base of our assigned CFG space.
&space;*      Our sample device registers are in the PCI area
&space;*      decoded by the device's first BASE_ADDR window.
&space;*/
struct psamp_regs_s {
&space;   psamp_reg_t             pr_control;
&space;   psamp_reg_t             pr_status;
};
struct psamp_soft_s {
&space;   vertex_hdl_t      ps_conn;    /* connection for pci services */
&space;   vertex_hdl_t      ps_vhdl;    /* backpointer to device vertex */
&space;   vertex_hdl_t      ps_blockv;  /* backpointer to block vertex */
&space;   vertex_hdl_t      ps_charv;   /* backpointer to char vertex */
&space;   volatile uchar_t  ps_cfg;     /* cached ptr to my config regs */
&space;   psamp_regs_t      ps_regs;    /* cached ptr to my regs */
&space;   pciio_piomap_t    ps_cmap;    /* piomap (if any) for ps_cfg */
&space;   pciio_piomap_t    ps_rmap;    /* piomap (if any) for ps_regs */
&space;   unsigned          ps_sst;     /* driver "software state" */
#define PSAMP_SST_RX_READY      (0x0001)
#define PSAMP_SST_TX_READY      (0x0002)
#define PSAMP_SST_ERROR         (0x0004)
#define PSAMP_SST_INUSE         (0x8000)
&space;   pciio_intr_t      ps_intr;       /* pciio intr for INTA and INTB */
&space;   pciio_dmamap_t    ps_ctl_dmamap; /* control channel dma mapping */
&space;   pciio_dmamap_t    ps_str_dmamap; /* stream channel dma mapping */
&space;   struct pollhead   *ps_pollhead;  /* for poll() */
&space;   int               ps_blocks;  /* block dev size in NBPSCTR blocks */
};
#define psamp_soft_set(v,i)     device_info_set((v),(void *)(i))
#define psamp_soft_get(v)       ((psamp_soft_t)device_info_get((v)))
/*=====================================================================
&space;*          FUNCTION TABLE OF CONTENTS
&space;*/
void                  psamp_init(void);
int                   psamp_unload(void);
int                   psamp_reg(void);
int                   psamp_unreg(void);
int                   psamp_attach(vertex_hdl_t conn);
int                   psamp_detach(vertex_hdl_t conn);
static pciio_iter_f   psamp_reloadme;
static pciio_iter_f   psamp_unloadme;
int                   psamp_open(dev_t *devp, int oflag, int otyp,
&space;                                cred_t *crp);
int                   psamp_close(dev_t dev, int oflag, int otyp,
&space;                                 cred_t *crp);
int                   psamp_ioctl(dev_t dev, int cmd, void *arg,
&space;                                 int mode, cred_t *crp, int *rvalp);
int                   psamp_read(dev_t dev, uio_t * uiop, cred_t *crp);
int                   psamp_write(dev_t dev, uio_t * uiop,cred_t *crp);
int                   psamp_strategy(struct buf *bp);
int                   psamp_poll(dev_t dev, short events, int anyyet,
&space;                              short *reventsp, struct pollhead **phpp,
&space;                              unsigned int *genp);
int                   psamp_map(dev_t dev, vhandl_t *vt,
&space;                               off_t off, size_t len, uint_t prot);
int                   psamp_unmap(dev_t dev, vhandl_t *vt);
void                  psamp_dma_intr(intr_arg_t arg);
static error_handler_f psamp_error_handler;
void                  psamp_halt(void);
int                   psamp_size(dev_t dev);
int                   psamp_print(dev_t dev, char *str);
&nbsp;
/*=====================================================================
&space;*                  Driver Initialization
&space;*/
/*
&space;*    psamp_init: called once during system startup or
&space;*      when a loadable driver is loaded.
&space;*/
void
psamp_init(void)
{
&space;   printf("psamp_init()\n");
&space;   /*
&space;    * if we are already registered, note that this is a
&space;    * "reload" and reconnect all the places we attached.
&space;    */
&space;   pciio_iterate("psamp_", psamp_reloadme);
}
/*
&space;*    psamp_unload: if no "psamp" is open, put us to bed
&space;*      and let the driver text get unloaded.
&space;*/
int
psamp_unload(void)
{
&space;   if (psamp_inuse)
&space;       return EBUSY;
&space;   pciio_iterate("psamp_", psamp_unloadme);
&space;   return 0;
}
/*
&space;*    psamp_reg: called once during system startup or
&space;*      when a loadable driver is loaded.
&space;*    NOTE: a bus provider register routine should always be
&space;*      called from _reg, rather than from _init. In the case
&space;*      of a loadable module, the devsw is not hooked up
&space;*      when the _init routines are called.
&space;*/
int
psamp_reg(void)
{
&space;   printf("psamp_reg()\n");
&space;   pciio_driver_register(PSAMP_VENDOR_ID_NUM,
&space;                         PSAMP_DEVICE_ID_NUM,
&space;                         "psamp_",
&space;                         0);
&space;   return 0;
}
/*
&space;*    psamp_unreg: called when a loadable driver is unloaded.
&space;*/
int
psamp_unreg(void)
{
&space;   pciio_driver_unregister("psamp_");
&space;   return 0;
}
/*
&space;*    psamp_attach: called by the pciio infrastructure
&space;*      once for each vertex representing a crosstalk widget.
&space;*      In large configurations, it is possible for a
&space;*      huge number of CPUs to enter this routine all at
&space;*      nearly the same time, for different specific
&space;*      instances of the device. Attempting to give your
&space;*      devices sequence numbers based on the order they
&space;*      are found in the system is not only futile but may be
&space;*      dangerous as the order may differ from run to run.
&space;*/
int
psamp_attach(vertex_hdl_t conn)
{
&space;   vertex_hdl_t            vhdl, blockv, charv;
&space;   volatile uchar_t       *cfg;
&space;   psamp_regs_t            regs;
&space;   psamp_soft_t            soft;
&space;   pciio_piomap_t          cmap = 0;
&space;   pciio_piomap_t          rmap = 0;
&space;   printf("psamp_attach()\n");
&space;   hwgraph_device_add(conn,"psamp","psamp_",&amp;vhdl,&amp;blockv,&amp;charv);
&space;   /*
&space;    * Allocate a place to put per-device information for this vertex.
&space;    * Then associate it with the vertex in the most efficient manner.
&space;    */
&space;   NEW(soft);
&space;   ASSERT(soft != NULL);
&space;   psamp_soft_set(vhdl, soft);
&space;   psamp_soft_set(blockv, soft);
&space;   psamp_soft_set(charv, soft);
&space;   soft->ps_conn = conn;
&space;   soft->ps_vhdl = vhdl;
&space;   soft->ps_blockv = blockv;
&space;   soft->ps_charv = charv;
&space;   /*
&space;    * Find our PCI CONFIG registers.
&space;    */
&space;   cfg = (volatile uchar_t *) pciio_pio_addr
&space;       (conn, 0,               /* device and (override) dev_info */
&space;        PCIIO_SPACE_CFG,       /* select configuration addr space */
&space;        0,                     /* from the start of space, */
&space;        PCI_CFG_VEND_SPECIFIC, /* ... up to vendor specific stuff */
&space;        &amp;cmap,                 /* in case we needed a piomap */
&space;        0);                    /* flag word */
&space;   soft->ps_cfg = cfg;         /* save for later */
&space;   soft->ps_cmap = cmap;
&space;   printf("psamp_attach: I can see my CFG regs at 0x%x\n", cfg);
&space;   /*
&space;    * Get a pointer to our DEVICE registers
&space;    */
&space;   regs = (psamp_regs_t) pciio_pio_addr
&space;       (conn, 0,               /* device and (override) dev_info */
&space;        PCIIO_SPACE_WIN(0),    /* in my primary decode window, */
&space;        0, sizeof(*regs),      /* base and size */
&space;        &amp;rmap,                 /* in case we needed a piomap */
&space;        0);                    /* flag word */
&space;   soft->ps_regs = regs;       /* save for later */
&space;   soft->ps_rmap = rmap;
&space;   printf("psamp_attach: I can see my device regs at 0x%x\n", regs);
&space;   /*
&space;    * Set up our interrupt.
&space;    * We might interrupt on INTA or INTB,
&space;    * but route 'em both to the same function.
&space;    */
&space;   soft->ps_intr = pciio_intr_alloc
&space;       (conn, 0,
&space;        PCIIO_INTR_LINE_A |
&space;        PCIIO_INTR_LINE_B,
&space;        vhdl);
&space;   pciio_intr_connect(soft->ps_intr,
&space;                      psamp_dma_intr, soft,(void *) 0);
&space;   /*
&space;    * set up our error handler.
&space;    */
&space;   pciio_error_register(conn, psamp_error_handler, soft);
&space;   /*
&space;    * For pciio clients, *now* is the time to
&space;    * allocate pollhead structures.
&space;    */
&space;   soft->ps_pollhead = phalloc(0);
&space;   return 0;                      /* attach successsful */
}
/*
&space;*    psamp_detach: called by the pciio infrastructure
&space;*      once for each vertex representing a crosstalk
&space;*      widget when unregistering the driver.
&space;*
&space;*      In large configurations, it is possible for a
&space;*      huge number of CPUs to enter this routine all at
&space;*      nearly the same time, for different specific
&space;*      instances of the device. Attempting to give your
&space;*      devices sequence numbers based on the order they
&space;*      are found in the system is not only futile but may be
&space;*      dangerous as the order may differ from run to run.
&space;*/
int
psamp_detach(vertex_hdl_t conn)
{
&space;   vertex_hdl_t            vhdl, blockv, charv;
&space;   psamp_soft_t            soft;
&space;   printf("psamp_detach()\n");
&space;   if (GRAPH_SUCCESS !=
&space;       hwgraph_traverse(conn, "psamp", &amp;vhdl))
&space;       return -1;
&space;   soft = psamp_soft_get(vhdl);
&space;   pciio_error_register(conn, 0, 0);
&space;   pciio_intr_disconnect(soft->ps_intr);
&space;   pciio_intr_free(soft->ps_intr);
&space;   phfree(soft->ps_pollhead);
&space;   if (soft->ps_ctl_dmamap)
&space;       pciio_dmamap_free(soft->ps_ctl_dmamap);
&space;   if (soft->ps_str_dmamap)
&space;       pciio_dmamap_free(soft->ps_str_dmamap);
&space;   if (soft->ps_cmap)
&space;       pciio_piomap_free(soft->ps_cmap);
&space;   if (soft->ps_rmap)
&space;       pciio_piomap_free(soft->ps_rmap);
&space;   hwgraph_edge_remove(conn, "psamp", &amp;vhdl);
&space;   /*
&space;    * we really need "hwgraph_dev_remove" ...
&space;    */
&space;   if (GRAPH_SUCCESS ==
&space;       hwgraph_edge_remove(vhdl, EDGE_LBL_BLOCK, &amp;blockv)) {
&space;       psamp_soft_set(blockv, 0);
&space;       hwgraph_vertex_destroy(blockv);
&space;   }
&space;   if (GRAPH_SUCCESS ==
&space;       hwgraph_edge_remove(vhdl, EDGE_LBL_CHAR, &amp;charv)) {
&space;       psamp_soft_set(charv, 0);
&space;       hwgraph_vertex_destroy(charv);
&space;   }
&space;   psamp_soft_set(vhdl, 0);
&space;   hwgraph_vertex_destroy(vhdl);
&space;   DEL(soft);
&space;   return 0;
}
/*
&space;*    psamp_reloadme: utility function used indirectly
&space;*      by psamp_init, via pciio_iterate, to "reconnect"
&space;*      each connection point when the driver has been
&space;*      reloaded.
&space;*/
static void
psamp_reloadme(vertex_hdl_t conn)
{
&space;   vertex_hdl_t            vhdl;
&space;   psamp_soft_t            soft;
&space;   if (GRAPH_SUCCESS !=
&space;       hwgraph_traverse(conn, "psamp", &amp;vhdl))
&space;       return;
&space;   soft = psamp_soft_get(vhdl);
&space;   /*
&space;    * Reconnect our error and interrupt handlers
&space;    */
&space;   pciio_error_register(conn, psamp_error_handler, soft);
&space;   pciio_intr_connect(soft->ps_intr, psamp_dma_intr, soft, 0);
}
/*
&space;*    psamp_unloadme: utility function used indirectly by
&space;*      psamp_unload, via pciio_iterate, to "disconnect" each
&space;*      connection point before the driver becomes unloaded.
&space;*/
static void
psamp_unloadme(vertex_hdl_t pconn)
{
&space;   vertex_hdl_t            vhdl;
&space;   psamp_soft_t            soft;
&space;   if (GRAPH_SUCCESS !=
&space;       hwgraph_traverse(pconn, "psamp", &amp;vhdl))
&space;       return;
&space;   soft = psamp_soft_get(vhdl);
&space;   /*
&space;    * Disconnect our error and interrupt handlers
&space;    */
&space;   pciio_error_register(pconn, 0, 0);
&space;   pciio_intr_disconnect(soft->ps_intr);
}
/* ====================================================================
&space;*          DRIVER OPEN/CLOSE
&space;*/
/*
&space;*    psamp_open: called when a device special file is
&space;*      opened or when a block device is mounted.
&space;*/
/* ARGSUSED */
int
psamp_open(dev_t *devp, int oflag, int otyp, cred_t *crp)
{
&space;   vertex_hdl_t            vhdl = dev_to_vhdl(*devp);
&space;   psamp_soft_t            soft = psamp_soft_get(vhdl);
&space;   psamp_regs_t            regs = soft->ps_regs;
&space;   printf("psamp_open() regs=%x\n", regs);
&space;   /*
&space;    * BLOCK DEVICES: now would be a good time to
&space;    * calculate the size of the device and stash it
&space;    * away for use by psamp_size.
&space;    */
&space;   /*
&space;    * USER ABI (64-bit): chances are, you are being
&space;    * compiled for use in a 64-bit IRIX kernel; if
&space;    * you use the _ioctl or _poll entry points, now
&space;    * would be a good time to test and save the
&space;    * user process' model so you know how to
&space;    * interpret the user ioctl and poll requests.
&space;    */
&space;   if (!(PSAMP_SST_INUSE &amp; atomicSetUint(&amp;soft->ps_sst, PSAMP_SST_INUSE)))
&space;       atomicAddInt(&amp;psamp_inuse, 1);
&space;   return 0;
}
/*
&space;*    psamp_close: called when a device special file
&space;*      is closed by a process and no other processes
&space;*      still have it open ("last close").
&space;*/
/* ARGSUSED */
int
psamp_close(dev_t dev, int oflag, int otyp, cred_t *crp)
{
&space;   vertex_hdl_t            vhdl = dev_to_vhdl(dev);
&space;   psamp_soft_t            soft = psamp_soft_get(vhdl);
&space;   psamp_regs_t            regs = soft->ps_regs;
&space;   printf("psamp_close() regs=%x\n", regs);
&space;   atomicClearUint(&amp;soft->ps_sst, PSAMP_SST_INUSE);
&space;   atomicAddInt(&amp;psamp_inuse, -1);
&space;   return 0;
}
/* ====================================================================
&space;*          CONTROL ENTRY POINT
&space;*/
/*
&space;*    psamp_ioctl: a user has made an ioctl request
&space;*      for an open character device.
&space;*      Arguments cmd and arg are as specified by the user;
&space;*      arg is probably a pointer to something in the user's
&space;*      address space, so you need to use copyin() to
&space;*      read through it and copyout() to write through it.
&space;*/
/* ARGSUSED */
int
psamp_ioctl(dev_t dev, int cmd, void *arg,
&space;           int mode, cred_t *crp, int *rvalp)
{
&space;   vertex_hdl_t            vhdl = dev_to_vhdl(dev);
&space;   psamp_soft_t            soft = psamp_soft_get(vhdl);
&space;   psamp_regs_t            regs = soft->ps_regs;
&space;   printf("psamp_ioctl() regs=%x\n", regs);
&space;   *rvalp = -1;
&space;   return ENOTTY;          /* TeleType&reg; is a registered trademark */
}
/* ====================================================================
&space;*          DATA TRANSFER ENTRY POINTS
&space;*      Since I'm trying to provide an example for both
&space;*      character and block devices, I'm routing read
&space;*      and write back through strategy as described in
&space;*      the IRIX Device Driver Programming Guide.
&space;*      This limits our character driver to reading and
&space;*      writing in multiples of the standard sector length.
&space;*/
/* ARGSUSED */
int
psamp_read(dev_t dev, uio_t * uiop, cred_t *crp)
{
&space;   return physiock(psamp_strategy,
&space;                   0,          /* alocate temp buffer &amp; buf_t */
&space;                   dev,        /* dev_t arg for strategy */
&space;                   B_READ,     /* direction flag for buf_t */
&space;                   psamp_size(dev),
&space;                   uiop);
}
/* ARGSUSED */
int
psamp_write(dev_t dev, uio_t * uiop, cred_t *crp)
{
&space;   return physiock(psamp_strategy,
&space;                   0,          /* alocate temp buffer &amp; buf_t */
&space;                   dev,        /* dev_t arg for strategy */
&space;                   B_WRITE,    /* direction flag for buf_t */
&space;                   psamp_size(dev),
&space;                   uiop);
}
/* ARGSUSED */
int
psamp_strategy(struct buf *bp)
{
&space;   /*
&space;    * XXX - create strategy code here.
&space;    */
&space;   return 0;
}
/* ====================================================================
&space;*          POLL ENTRY POINT
&space;*/
int
psamp_poll(dev_t dev, short events, int anyyet,
&space;          short *reventsp, struct pollhead **phpp, unsigned int *genp)
{
&space;   vertex_hdl_t            vhdl = dev_to_vhdl(dev);
&space;   psamp_soft_t            soft = psamp_soft_get(vhdl);
&space;   psamp_regs_t            regs = soft->ps_regs;
&space;   short                   happened = 0;
&space;   unsigned int            gen;
&space;   printf("psamp_poll() regs=%x\n", regs);
&space;   /*
&space;    * Need to snapshot the pollhead generation number before we check
&space;    * device state.  In many drivers a lock is used to interlock the
&space;    * "high" and "low" portions of the driver.  In those cases we can
&space;    * wait to do this snapshot till we're in the critical region.
&space;    * Snapshotting it early isn't a problem since that makes the
&space;    * snapshotted generation number a more conservative estimate of
&space;    * what generation of  pollhead our event state report indicates.
&space;    */
&space;   gen = POLLGEN(soft->ps_pollhead);
&space;   if (events &amp; (POLLIN | POLLRDNORM))
&space;       if (soft->ps_sst &amp; PSAMP_SST_RX_READY)
&space;           happened |= POLLIN | POLLRDNORM;
&space;   if (events &amp; POLLOUT)
&space;       if (soft->ps_sst &amp; PSAMP_SST_TX_READY)
&space;           happened |= POLLOUT;
&space;   if (soft->ps_sst &amp; PSAMP_SST_ERROR)
&space;       happened |= POLLERR;
&space;   *reventsp = happened;
&space;   if (!happened &amp;&amp; anyyet) {
&space;       *phpp = soft->ps_pollhead;
&space;       *genp = gen;
&space;   }
&space;   return 0;
}
/* ====================================================================
&space;*          MEMORY MAP ENTRY POINTS
&space;*/
/* ARGSUSED */
int
psamp_map(dev_t dev, vhandl_t *vt,
&space;         off_t off, size_t len, uint_t prot)
{
&space;   vertex_hdl_t            vhdl = dev_to_vhdl(dev);
&space;   psamp_soft_t            soft = psamp_soft_get(vhdl);
&space;   vertex_hdl_t            conn = soft->ps_conn;
&space;   psamp_regs_t            regs = soft->ps_regs;
&space;   pciio_piomap_t          amap = 0;
&space;   caddr_t                 kaddr;
&space;   printf("psamp_map() regs=%x\n", regs);
&space;   /*
&space;    * Stuff we want users to mmap is in our second BASE_ADDR window.
&space;    */
&space;   kaddr = (caddr_t) pciio_pio_addr
&space;       (conn, 0,
&space;        PCIIO_SPACE_WIN(1),
&space;        off, len, &amp;amap, 0);
&space;   if (kaddr == NULL)
&space;       return EINVAL;
&space;   /*
&space;    * XXX - must stash amap somewhere so we can pciio_piomap_free it
&space;    * when the mapping goes away.
&space;    */
&space;   v_mapphys(vt, kaddr, len);
&space;   return 0;
}
/* ARGSUSED2 */
int
psamp_unmap(dev_t dev, vhandl_t *vt)
{
&space;   /*
&space;    * XXX - need to find "amap" that we used in psamp_map() above,
&space;    * and if (amap) pciio_piomap_free(amap);
&space;    */
&space;   return (0);
}
/* ====================================================================
&space;*          INTERRUPT ENTRY POINTS
&space;*  We avoid using the standard name, since our prototype has changed.
&space;*/
void
psamp_dma_intr(intr_arg_t arg)
{
&space;   psamp_soft_t            soft = (psamp_soft_t) arg;
&space;   vertex_hdl_t            vhdl = soft->ps_vhdl;
&space;   psamp_regs_t            regs = soft->ps_regs;
&space;   cmn_err(CE_CONT, "psamp %v: dma done, regs at 0x%X\n", vhdl, regs);
&space;   /*
&space;    * for each buf our hardware has processed,
&space;    *      set buf->b_resid,
&space;    *      call pciio_dmamap_done,
&space;    *      call bioerror() or biodone().
&space;    *
&space;    * XXX - would it be better for buf->b_iodone
&space;    * to be used to get to pciio_dmamap_done?
&space;    */
&space;   /*
&space;    * may want to call pollwakeup.
&space;    */
}
/* ====================================================================
&space;*          ERROR HANDLING ENTRY POINTS
&space;*/
static int
psamp_error_handler(void *einfo,
&space;                   int error_code,
&space;                   ioerror_mode_t mode,
&space;                   ioerror_t *ioerror)
{
&space;   psamp_soft_t            soft = (psamp_soft_t) einfo;
&space;   vertex_hdl_t            vhdl = soft->ps_vhdl;
#if DEBUG &amp;&amp; ERROR_DEBUG
&space;   cmn_err(CE_CONT, "%v: psamp_error_handler\n", vhdl);
#else
&space;   vhdl = vhdl;
#endif
&space;   /*
&space;    * XXX- there is probably a lot more to do
&space;    * to recover from an error on a real device;
&space;    * experts on this are encouraged to add common
&space;    * things that need to be done into this function.
&space;    */
&space;   ioerror_dump("sample_pciio", error_code, mode, ioerror);
&space;   return IOERROR_HANDLED;
}
/* ====================================================================
&space;*          SUPPORT ENTRY POINTS
&space;*/
/*
&space;*    psamp_halt: called during orderly system
&space;*      shutdown; no other device driver call will be
&space;*      made after this one.
&space;*/
void
psamp_halt(void)
{
&space;   printf("psamp_halt()\n");
}
/*
&space;*    psamp_size: return the size of the device in
&space;*      "sector" units (multiples of NBPSCTR).
&space;*/
int
psamp_size(dev_t dev)
{
&space;   vertex_hdl_t            vhdl = dev_to_vhdl(dev);
&space;   psamp_soft_t            soft = psamp_soft_get(vhdl);
&space;   return soft->ps_blocks;
}
/*
&space;*    psamp_print: used by the kernel to report an
&space;*      error detected on a block device.
&space;*/
int
psamp_print(dev_t dev, char *str)
{
&space;   cmn_err(CE_NOTE, "%V: %s\n", dev, str);
&space;   return 0;
}
</CODE>
<SECTION2 LBL="" HELPID = ""><TITLE>Other Code Examples</TITLE><PARAGRAPH>The Developer's Toolkit CD-ROM contains a sample PCI device driver for the Barco Chameleon Color Converter. Look in the <FILENAME>toolbox/hardware/PCI/barco</FILENAME> directory.</PARAGRAPH>
</SECTION2>
</SECTION1>
</CHAPTER>
