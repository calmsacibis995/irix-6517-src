<!-- Produced by version 4.3 (11/99) of SGI Frame/SGIDOCBK SGML translator -->
<CHAPTER ID="LE46919-PARENT"><TITLE ID="LE46919-TITLE">Maintaining Filesystems</TITLE><PARA>This chapter describes administration procedures for maintaining XFS filesystems that you perform on a routine or as-needed basis. It is extremely important to maintain filesystems properly, in addition to backing up the data they contain. Failure to do so might result in loss of valuable system and user information.</PARA>
<PARA>The major sections in this chapter are:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA><XREF LINKEND="LE30642-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE21898-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE63342-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE22948-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE92347-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE28728-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE35305-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE31685-PARENT"></PARA></LISTITEM>
</ITEMIZEDLIST>
<SECTION  ID="LE30642-PARENT"><TITLE  ID="LE30642-TITLE">Routine Filesystem Administration Tasks</TITLE><PARA><INDEXTERM ID="ITch7-0"><PRIMARY>filesystems</PRIMARY>
<SECONDARY>routine administration tasks</SECONDARY>
</INDEXTERM>
To administer filesystems, you need to do the following:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA>Monitor the amount of free space and free inodes available. </PARA>
</LISTITEM>
<LISTITEM><PARA>If a filesystem is chronically short of free space, take steps to alleviate the problem, such as removing old files and imposing disk usage quotas. </PARA>
</LISTITEM>
<LISTITEM><PARA>Back up filesystems.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>Many routine administration jobs can be performed by shell scripts. Here are a few ideas:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA>Use a shell script to investigate free blocks and free inodes, and report on filesystems whose free space dips below a given threshold. </PARA>
</LISTITEM>
<LISTITEM><PARA>Use a shell script to automatically &ldquo;clean up&rdquo; files that grow (such as log files). </PARA>
</LISTITEM>
<LISTITEM><PARA>Use a shell script to highlight cases of excessive disk use.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>These scripts can be run automatically with the <COMMAND>cron</COMMAND> command and the output can be sent to you using electronic mail. Typically, these scripts use some combination of the <COMMAND>find</COMMAND>, <COMMAND>du</COMMAND>, <COMMAND>mail</COMMAND>, and shell commands.</PARA>
<PARA>The process accounting system performs many similar functions. If the process accounting system does not meet your needs, examine the scripts in <FILENAME>/usr/lib/acct</FILENAME>, such as <COMMAND>ckpacct</COMMAND> and <COMMAND>remove</COMMAND>, for ideas about how to build your own administration scripts.</PARA>
</SECTION>
<SECTION  ID="LE21898-PARENT"><TITLE  ID="LE21898-TITLE">Mounting and Unmounting Filesystems</TITLE><PARA><INDEXTERM ID="ITch7-1"><PRIMARY>filesystems</PRIMARY>
<SECONDARY>mounting</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-2"><PRIMARY>XFS filesystems</PRIMARY>
<SECONDARY>mounting</SECONDARY>
</INDEXTERM>
As explained in <XREF LINKEND="LE97590-TITLE">, in order to be accessed by IRIX, filesystems must be mounted. The following subsections explain the use of the <COMMAND>mount</COMMAND> and <COMMAND>umount</COMMAND> commands and the file <FILENAME>/etc/fstab</FILENAME> to mount and unmount filesystems.</PARA>
<TIP><PARA><INDEXTERM ID="ITch7-3"><PRIMARY><COMMAND>xfsm</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>mounting and unmounting filesystems</COMMAND>
</SECONDARY>
</INDEXTERM>
You can mount and unmount XFS filesystems using the graphical user interface of the <COMMAND>xfsm</COMMAND> command. For information, see its online help.</PARA>
</TIP>
<SECTION  ID="LE73128-PARENT"><TITLE  ID="LE73128-TITLE">Manually Mounting Filesystems</TITLE><PARA><INDEXTERM ID="ITch7-4"><PRIMARY><COMMAND>mount</COMMAND>
 command</PRIMARY>
</INDEXTERM>
The <COMMAND>mount</COMMAND> command is used to mount filesystems manually. The basic forms of the <COMMAND>mount</COMMAND> command are:</PARA>
<PROGRAMLISTING>
mount <REPLACEABLE>device_file</REPLACEABLE>&ensp;<REPLACEABLE>mount_point_directory</REPLACEABLE>
mount <REPLACEABLE>host</REPLACEABLE><USERINPUT>:</USERINPUT><REPLACEABLE>directory</REPLACEABLE>&ensp;<REPLACEABLE>mount_point_directory</REPLACEABLE>&ensp;
</PROGRAMLISTING>
<PARA><REPLACEABLE>device_file</REPLACEABLE> is a block device file. <REPLACEABLE>host</REPLACEABLE>:<REPLACEABLE>directory</REPLACEABLE> is the hostname and pathname of a remote directory that has been exported on the remote host by using the <COMMAND>exportfs</COMMAND> command on the remote host (it requires NFS). <REPLACEABLE>mount_point_directory</REPLACEABLE> is the mount point directory. The mount point must already exist (you can create it with the <COMMAND>mkdir</COMMAND> command). </PARA>
<PARA>If you omit either the <REPLACEABLE>device_file</REPLACEABLE> or the <REPLACEABLE>mount_point_directory</REPLACEABLE> from the <COMMAND>mount</COMMAND> command line, <COMMAND>mount</COMMAND> checks the file <FILENAME>/etc/fstab</FILENAME> to find the missing argument. See <XREF LINKEND="LE47138-PARENT"> for more information about <FILENAME>/etc/fstab</FILENAME>.</PARA>
<PARA>For example, to mount a filesystem manually, use this command:</PARA>
<PARA><COMMAND>mount /dev/dsk/dks0d1s6 /usr </COMMAND></PARA>
<PARA>Another example, which uses a mnemonic device file name, is:</PARA>
<PARA><COMMAND>mount /dev/usr /usr </COMMAND></PARA>
<PARA>An example of a <COMMAND>mount</COMMAND> command for a filesystem that is listed in <FILENAME>/etc/fstab</FILENAME> is:</PARA>
<PARA><COMMAND>mount /d2 </COMMAND></PARA>
<PARA>Other useful <COMMAND>mount</COMMAND> commands are:</PARA>
<DEFLIST><DEFLISTENTRY><TERM><COMMAND>mount -a</COMMAND> </TERM>
<LISTITEM><PARA>Mount all filesystems listed in <FILENAME>/etc/fstab</FILENAME>.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM><COMMAND>mount -h </COMMAND><REPLACEABLE>host</REPLACEABLE> </TERM>
<LISTITEM><PARA>Mount all filesystems listed in <FILENAME>/etc/fstab</FILENAME> that are remote-mounted from the system named <REPLACEABLE>host</REPLACEABLE>.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM><COMMAND>mount -o quota </COMMAND><REPLACEABLE>device_file</REPLACEABLE>&ensp;<REPLACEABLE>mount_point_directory</REPLACEABLE> </TERM>
<LISTITEM><PARA><INDEXTERM ID="ITch7-5"><PRIMARY>disk quotas</PRIMARY>
<SECONDARY>and <COMMAND>mount</COMMAND>
 command</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-6"><PRIMARY>mounting filesystems</PRIMARY>
<SECONDARY>and disk quotas</SECONDARY>
</INDEXTERM>
Mount the filesystem <REPLACEABLE>device_file</REPLACEABLE> at <REPLACEABLE>mount_point_directory</REPLACEABLE> with disk quota tracking turned on. See <XREF LINKEND="LE51526-PARENT"> for more information.</PARA></LISTITEM>
</DEFLISTENTRY>
</DEFLIST>
<PARA>You can use the <COMMAND>-t</COMMAND>&ensp;<REPLACEABLE>type</REPLACEABLE> option of the mount command to specify what type of filesystem you are mounting. For a description of the filesystem types that the IRIX operating system supports, see the <COMMAND>filesystems</COMMAND>(4) reference page.</PARA>
<PARA>See the <COMMAND>mount</COMMAND>(1M) reference page for more information about the <COMMAND>mount</COMMAND> command.</PARA>
</SECTION>
<SECTION  ID="LE47138-PARENT"><TITLE  ID="LE47138-TITLE">Mounting Filesystems Automatically With the /etc/fstab File</TITLE><PARA><INDEXTERM ID="ITch7-7"><PRIMARY><FILENAME>/etc/fstab</FILENAME>
 file</PRIMARY>
<SECONDARY><FILENAME>entries for filesystems</FILENAME>
</SECONDARY>
</INDEXTERM>
The <FILENAME>/etc/fstab</FILENAME> file contains information about every filesystem and swap partition that is to be mounted automatically when the system is booted into multi-user mode. In addition, the <FILENAME>/etc/fstab</FILENAME> file is used by the <COMMAND>mount</COMMAND> command when only the device block file or the mount point is given to the <COMMAND>mount</COMMAND> command. Filesystems that are not mounted with the <COMMAND>mount</COMMAND> command, such as the <FILENAME>/proc</FILENAME> filesystem, are not listed in <FILENAME>/etc/fstab</FILENAME>.</PARA>
<PARA>The procedure in this section explains how to add an entry for a filesystem to <FILENAME>/etc/fstab</FILENAME>.</PARA>
<PARA>For each filesystem that is to be mounted every time the system is booted, a line similar to this appears in the file <FILENAME>/etc/fstab</FILENAME>:</PARA>
<PROGRAMLISTING>
/dev/dsk/dks0d2s7 /test xfs rw,raw=/dev/rdsk/dks0d2s7 0 0
</PROGRAMLISTING>
<PARA>The fields in this line are defined as follows:</PARA>
<DEFLIST><DEFLISTENTRY><TERM><KEYCAP>/dev/dsk/dks0d2s7</KEYCAP></TERM>
<LISTITEM><PARA>The block device file of the partition where the filesystem is located.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM><LITERAL>/test</LITERAL></TERM>
<LISTITEM><PARA>The name of the directory where the filesystem will be mounted (the mount point).</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM><LITERAL>xfs</LITERAL></TERM>
<LISTITEM><PARA>The type of filesystem. In this case, the filesystem is an XFS filesystem.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM><LITERAL>rw, raw=</LITERAL></TERM>
<LISTITEM><PARA>These are some of many options available when mounting a filesystem (see the <COMMAND>fstab(4)</COMMAND> reference page for a complete list). In this instance, the filesystem is to be mounted read-write, so that <FIRSTTERM>root</FIRSTTERM> and other users can write to it. The raw= option gives the filesystem's raw device filename. It should be the last option in the options list. </PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM><LITERAL>0 0</LITERAL></TERM>
<LISTITEM><PARA>These two numbers represent the frequency of dump cycles and the <COMMAND>fsck</COMMAND> pass priority. These two numbers must be added after the last option in the options list (raw =). The <COMMAND>fstab(4)</COMMAND> reference page contains additional information. </PARA>
</LISTITEM>
</DEFLISTENTRY>
</DEFLIST>
<PARA>If you have already mounted the filesystem as described in the section <XREF LINKEND="LE73128-PARENT">, you can use the mount command to determine the appropriate /etc/fstab entry. For example:</PARA><PARA><COMMAND>mount -p </COMMAND></PARA>
<PARA>This command displays all currently mounted filesystems, including the new filesystem in <FILENAME>/etc/fstab</FILENAME> format. Copy the line that describes the new filesystem to <FILENAME>/etc/fstab</FILENAME>.</PARA>
<PARA>The <COMMAND>mount</COMMAND> command reads <FILENAME>/etc/fstab</FILENAME> sequentially; therefore, filesystems that are mounted beneath other filesystems must follow their parent partitions in <FILENAME>/etc/fstab</FILENAME> in order for their mount points to exist.</PARA>
<PARA><INDEXTERM ID="ITch7-8"><PRIMARY>swap partition</PRIMARY>
</INDEXTERM>
The swap partition on the system disk (partition 1) is not listed in <FILENAME>/etc/fstab</FILENAME>. However, additional swap partitions added to the system are listed. For swap partitions, the mount point field is not used. See the guide <LINK BOOK="IA_ConfigOps" EXTREF="97829">IRIX Admin: System Configuration and Operation</LINK>
 and the <COMMAND>swap</COMMAND>(1M) reference page for more information. </PARA>
<PARA>See the <COMMAND>fstab</COMMAND>(4) reference page for more information about <FILENAME>/etc/fstab</FILENAME> entries.</PARA>
</SECTION>
<SECTION  ID="LE81003-PARENT"><TITLE  ID="LE81003-TITLE">Mounting a Remote Filesystem Automatically </TITLE><PARA><INDEXTERM ID="ITch7-9"><PRIMARY>NFS filesystems</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-10"><PRIMARY>remote filesystems</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-11"><PRIMARY>filesystems</PRIMARY>
<SECONDARY>remote</SECONDARY>
</INDEXTERM>
If you have the optional NFS software, you can automatically mount any remote filesystem whenever it is accessed (for example, by changing directories to the filesystem with <COMMAND>cd</COMMAND>). The remote filesystem must be exported with the <COMMAND>exportfs</COMMAND> command.</PARA>
<PARA>For complete information about setting up automounting, including all the available options, see the <COMMAND>automount</COMMAND>(1M) and <COMMAND>exportfs</COMMAND>(1M) reference pages. These commands are discussed more completely in the <LINK BOOK="ONC3NFS_AG" EXTREF="25730">ONC3/NFS Administrator's Guide</LINK>
.</PARA>
</SECTION>
<SECTION  ID="LE61716-PARENT"><TITLE  ID="LE61716-TITLE">Unmounting Filesystems</TITLE><PARA><INDEXTERM ID="ITch7-12"><PRIMARY>filesystems</PRIMARY>
<SECONDARY>unmounting</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-13"><PRIMARY>XFS filesystems</PRIMARY>
<SECONDARY>unmounting</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-14"><PRIMARY><COMMAND>umount</COMMAND>
 command</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-15"><PRIMARY>unmounting filesystems</PRIMARY>
<SECONDARY><COMMAND>umount</COMMAND>
 command</SECONDARY>
</INDEXTERM>
Filesystems are automatically unmounted when the system is shut down. To manually unmount filesystems, use the <COMMAND>umount</COMMAND> command. The three basic forms of the command are shown in <XREF LINKEND="LE88860-TITLE">. Local filesystems can be unmounted with either of the first two forms shown in the table; they are equivalent. Similarly, the first and third forms are equivalent for remote filesystems.</PARA><PARA>.</PARA>
<TABLE FRAME="topbot"><TBLTITLE  ID="LE88860-TITLE">Forms of the umount Command</TBLTITLE>
<TGROUP COLS="2">
<COLSPEC COLWIDTH="286*">
<COLSPEC COLWIDTH="498*">
<THEAD><ROW><ENTRY><PARA>Command</PARA></ENTRY>
<ENTRY><PARA>Comments</PARA></ENTRY>
</ROW>
</THEAD>
<TBODY><ROW><ENTRY><PARA><COMMAND>umount </COMMAND>
<REPLACEABLE></REPLACEABLE><REPLACEABLE>mount_point_directory </REPLACEABLE></PARA></ENTRY>
<ENTRY><PARA><REPLACEABLE>mount_point_directory</REPLACEABLE> is a directory pathname that is the 
mount point for the filesystem. This form can be used for 
local or remote filesystems. </PARA></ENTRY>
</ROW>
<ROW><ENTRY><PARA><COMMAND>umount </COMMAND>
<REPLACEABLE></REPLACEABLE><REPLACEABLE>device_file</REPLACEABLE>&ensp;</PARA></ENTRY>
<ENTRY><PARA><REPLACEABLE>device_file</REPLACEABLE> is a block device file name. This form is only for 
local filesystems. </PARA></ENTRY>
</ROW>
<ROW><ENTRY><PARA><COMMAND>umount </COMMAND>
<REPLACEABLE></REPLACEABLE><REPLACEABLE>host</REPLACEABLE>
<USERINPUT></USERINPUT><USERINPUT>:<REPLACEABLE></REPLACEABLE><REPLACEABLE>directory</REPLACEABLE>&ensp;</USERINPUT></PARA></ENTRY>
<ENTRY><PARA><REPLACEABLE>host</REPLACEABLE>:<REPLACEABLE>directory</REPLACEABLE> is a remote directory. This form is only for 
remote filesystems. </PARA></ENTRY>
</ROW>
<ROW><ENTRY><PARA><COMMAND>umount -a </COMMAND></PARA></ENTRY>
<ENTRY><PARA>Attempt to unmount all the filesystems currently mounted 
(listed in <FILENAME>/etc/mtab</FILENAME>) except <FILENAME>/</FILENAME> and <FILENAME>/usr</FILENAME>. This command 
is not the complement of the<COMMAND> mount -a </COMMAND>command, which 
mounts all filesystems listed in <FILENAME>/etc/fstab</FILENAME>. </PARA></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>For example, to unmount a local or remote filesystem mounted at <FILENAME>/d2</FILENAME>, give this command:</PARA>
<PARA><COMMAND>umount /d2 </COMMAND></PARA>
<PARA>To unmount the filesystem on the partition <FILENAME>/dev/dsk/dks0d1s7</FILENAME>, give this command:</PARA>
<PARA><COMMAND>umount /dev/dsk/dks0d1s7 </COMMAND></PARA>
<PARA>To unmount the remote-mounted (NFS) filesystem <FILENAME>depot:/usr/spool/news</FILENAME>, give this command:</PARA>
<PARA><COMMAND>umount depot:/usr/spool/news </COMMAND></PARA>
<PARA>To be unmounted, a filesystem must not be in use. If it is in use and you try to unmount it, you get a <LITERAL>Resource busy</LITERAL> message. Error messages and their solutions are explained in the <COMMAND>umount</COMMAND>(1M) reference page.</PARA>
</SECTION>
</SECTION>
<SECTION  ID="LE63342-PARENT"><TITLE  ID="LE63342-TITLE">Managing Disk Space</TITLE><PARA><INDEXTERM ID="ITch7-16"><PRIMARY>disk space</PRIMARY>
<SECONDARY>unused files</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-17"><PRIMARY>files</PRIMARY>
<SECONDARY>possible unused files</SECONDARY>
</INDEXTERM>
At some point, you are likely to find yourself short on disk space. In addition to using disk space intentionally for new files, you and other users may be creating and retaining files that you do not need.</PARA>
<ITEMIZEDLIST><LISTITEM><PARA>People tend to forget about files they no longer use. Outdated files often stay on the system much longer than necessary. </PARA>
</LISTITEM>
<LISTITEM><PARA>Some files, particularly log files such as <FILENAME>/var/adm/SYSLOG</FILENAME>, grow as a result of normal system operations. Normally, <COMMAND>cron</COMMAND> rotates this file once per week so that it does not grow excessively large. (See <FILENAME>/var/spool/cron/crontabs/root</FILENAME>.) However, you should check this file periodically to make sure it is being rotated properly, or when the amount of free disk space has grown small.</PARA>
</LISTITEM>
<LISTITEM><PARA>Some directories, notably <FILENAME>/tmp</FILENAME>, <FILENAME>/usr/tmp</FILENAME>, and <FILENAME>/var/tmp</FILENAME>, accumulate files. These are often copies of files being manipulated by text editors and other programs. Sometimes these temporary files are not removed by the programs that created them. </PARA>
</LISTITEM>
<LISTITEM><PARA>The directories <FILENAME>/usr/tmp</FILENAME>, <FILENAME>/var/tmp</FILENAME>, and <FILENAME>/var/spool/uucppublic</FILENAME> are public directories; people often use them to store temporary copies of files they are transferring to and from other systems and sites. Unlike <FILENAME>/tmp</FILENAME>, they are not cleaned out when the system is rebooted. The site administrator should be even more conscientious about monitoring disk use in these directories.</PARA>
</LISTITEM>
<LISTITEM><PARA>Users move old files to the dumpster without realizing that such files are not fully deleted from the system.</PARA>
</LISTITEM>
<LISTITEM><PARA><FILENAME>vmcore</FILENAME> and <FILENAME>unix</FILENAME> files in <FILENAME>/var/adm/crash</FILENAME> are accumulating without being removed.</PARA>
</LISTITEM>
<LISTITEM><PARA>Binary core dumps, <FILENAME>core</FILENAME> files, from crashed application programs are not being removed.</PARA>
<TIP><PARA>The section <LINK BOOK="PerSysAdmin" EXTREF="11608">&ldquo;Freeing Disk Space&rdquo; in Chapter&nbsp;6</LINK>
 of the <CITETITLE>Personal System Administration Guide</CITETITLE> provides additional ideas for identifying unnecessary files.</PARA>
</TIP>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>The following subsections describe various techniques for monitoring disk space usage, locating unneeded files, and limiting disk usage by individual users.</PARA>
<SECTION><TITLE>Monitoring Free Space and Free Inodes</TITLE><PARA><INDEXTERM ID="ITch7-18"><PRIMARY>disk space</PRIMARY>
<SECONDARY>monitoring free space</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-19"><PRIMARY>disk space</PRIMARY>
<SECONDARY>monitoring free inodes</SECONDARY>
</INDEXTERM>
You can quickly check the amount of free space and free inodes with the <COMMAND>df</COMMAND> command. For example,</PARA>
<PROGRAMLISTING>
%  <USERINPUT>df</USERINPUT>
Filesystem                 Type  blocks     use   avail %use  Mounted on
/dev/root                   xfs 1939714 1326891  612823  68%  /
</PROGRAMLISTING>
<PARA>The avail column shows the amount of free space in blocks.</PARA>
<PARA><INDEXTERM ID="ITch7-20"><PRIMARY>inodes</PRIMARY>
<SECONDARY>monitoring free inodes</SECONDARY>
</INDEXTERM>
To determine the number of free inodes, use this command:</PARA>
<PROGRAMLISTING>
% <USERINPUT>df -i</USERINPUT>&ensp;
Filesystem      Type  blocks     use   avail %use    iuse  ifree %iuse  Mounted
/dev/root        xfs 1939714 1326891  612823  68%   14491 195031    7%  /
</PROGRAMLISTING>
<PARA>You see a listing similar to the first <COMMAND>df</COMMAND> listing, except that it also lists the number of inodes in use, the number of inodes that are free (available), and the percentage of inodes in use. For XFS filesystems, the number of free inodes is the maximum number that could be allocated if needed. XFS allocates inodes as needed. On XFS filesystems inode usage is very high only on very full filesystems. XFS filesystem performance does not degrade when XFS filesystems are very full.</PARA>
</SECTION>
<SECTION><TITLE>Monitoring Key Files and Directories </TITLE><PARA><INDEXTERM ID="ITch7-21"><PRIMARY>disk space</PRIMARY>
<SECONDARY>files that grow</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-22"><PRIMARY>files</PRIMARY>
<SECONDARY>files that grow</SECONDARY>
</INDEXTERM>
Almost any system that is used daily has several key files and directories that grow through normal use. Some examples are shown in <XREF LINKEND="LE30275-TITLE">.</PARA><TABLE FRAME="topbot"><TBLTITLE  ID="LE30275-TITLE">Files and Directories That Tend to Grow</TBLTITLE>
<TGROUP COLS="2">
<COLSPEC COLWIDTH="278*">
<COLSPEC COLWIDTH="504*">
<THEAD><ROW><ENTRY><PARA>File</PARA></ENTRY>
<ENTRY><PARA>Use </PARA></ENTRY>
</ROW>
</THEAD>
<TBODY><ROW><ENTRY><PARA><FILENAME>/etc/wtmp</FILENAME></PARA></ENTRY>
<ENTRY><PARA>History of system logins</PARA></ENTRY>
</ROW>
<ROW><ENTRY><PARA><FILENAME>/tmp</FILENAME>&ensp;</PARA></ENTRY>
<ENTRY><PARA>Directory for temporary files (root filesystem) </PARA></ENTRY>
</ROW>
<ROW><ENTRY><PARA><FILENAME>/var/adm/avail/availlog </FILENAME></PARA></ENTRY>
<ENTRY><PARA>Log file for the availability monitor (see the <COMMAND>availmon</COMMAND>(5) 
reference page) </PARA></ENTRY>
</ROW>
<ROW><ENTRY><PARA><FILENAME>/var/adm/avail/notifylog</FILENAME>&ensp;</PARA></ENTRY>
<ENTRY><PARA>Log file for the availability monitor (see the <COMMAND>availmon</COMMAND>(5) 
reference page) </PARA></ENTRY>
</ROW>
<ROW><ENTRY><PARA><FILENAME>/var/adm/sulog</FILENAME>&ensp;</PARA></ENTRY>
<ENTRY><PARA>History of <COMMAND>su</COMMAND> commands</PARA></ENTRY>
</ROW>
<ROW><ENTRY><PARA><FILENAME>/var/cron/log</FILENAME>&ensp;</PARA></ENTRY>
<ENTRY><PARA>History of actions of <COMMAND>cron</COMMAND></PARA></ENTRY>
</ROW>
<ROW><ENTRY><PARA><FILENAME>/var/spool/lp/log </FILENAME></PARA></ENTRY>
<ENTRY><PARA>History of actions of <COMMAND>lp</COMMAND>&ensp;</PARA></ENTRY>
</ROW>
<ROW><ENTRY><PARA><FILENAME>/</FILENAME><FILENAME>var/spool/uucp</FILENAME>&ensp;</PARA></ENTRY>
<ENTRY><PARA>Directory for <COMMAND>uucp</COMMAND> log files </PARA></ENTRY>
</ROW>
<ROW><ENTRY><PARA><FILENAME>/</FILENAME><FILENAME>var/tmp </FILENAME></PARA></ENTRY>
<ENTRY><PARA>Directory for temporary files </PARA></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
<PARA>The frequency with which you should check growing files depends on how active your system is and how critical the disk space problem is. A good technique for keeping them down to a reasonable size uses a combination of the <COMMAND>tail</COMMAND> and <COMMAND>mv</COMMAND> commands:</PARA>
<PROGRAMLISTING>
# <USERINPUT>tail -50 /var/adm/sulog &gt; /var/tmp/sulog</USERINPUT>&ensp;
# <USERINPUT>mv /var/tmp/sulog /var/adm/sulog</USERINPUT>&ensp;
</PROGRAMLISTING>
<PARA>This sequence puts the last 50 lines of <FILENAME>/var/adm/sulog</FILENAME> into a temporary file, then moves the temporary file to <FILENAME>/var/adm/sulog</FILENAME>. This reduces the file to the 50 most recent entries. It is often useful to have these commands performed automatically every week using <COMMAND>cron</COMMAND>. For more information on using <COMMAND>cron</COMMAND> to automate your regular tasks, see the <COMMAND>cron(1M)</COMMAND> reference page.</PARA>
</SECTION>
<SECTION><TITLE>Cleaning Out Temporary Directories </TITLE><PARA><INDEXTERM ID="ITch7-23"><PRIMARY>temporary directories</PRIMARY>
<SECONDARY>cleaning</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-24"><PRIMARY>directories</PRIMARY>
<SECONDARY>cleaning temporary</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-25"><PRIMARY><COMMAND>chkconfig</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>nocleantmp</COMMAND>
 option</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-26"><PRIMARY>directories</PRIMARY>
<SECONDARY><FILENAME>/tmp</FILENAME>
 and <FILENAME></FILENAME>
<FILENAME>/var/tmp</FILENAME>
</SECONDARY>
</INDEXTERM>
The directory <FILENAME>/tmp</FILENAME> and all of its subdirectories are automatically cleaned out every time the system is rebooted. You can control whether or not this happens with the <COMMAND>chkconfig</COMMAND> option <COMMAND>nocleantmp</COMMAND>. By default, <COMMAND>nocleantmp</COMMAND> is off, and thus <FILENAME>/tmp</FILENAME> is cleaned.</PARA>
<PARA>The directory <FILENAME>/var/tmp</FILENAME> is not automatically cleaned out when the system is rebooted. This is a fairly standard practice on IRIX systems. If you wish, you can configure IRIX to clean out <FILENAME>/var/tmp</FILENAME> automatically whenever the system is rebooted. Changing this standard policy is a fairly extreme measure, and many people expect that files left in <FILENAME>/var/tmp</FILENAME> are not removed when the system is rebooted. Do not make this change without warning users well in advance. </PARA>
<PARA>To configure IRIX to clean out <FILENAME>/var/tmp</FILENAME> automatically at system reboot, follow these steps:</PARA>
<ORDEREDLIST><LISTITEM><PARA>Notify everyone who uses the system that you are changing the standard policy regarding <FILENAME>/var/tmp</FILENAME>, and that all files left in <FILENAME>/var/tmp</FILENAME> will be removed when the system is rebooted. Send electronic mail and post a message in the <FILENAME>/etc/motd</FILENAME> file.</PARA>
<PARA>Give the users at least one week's notice, longer if possible. </PARA>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch7-27"><PRIMARY><FILENAME>/etc/init.d/rmtmpfiles</FILENAME>
 file</PRIMARY>
</INDEXTERM>
Copy the file <FILENAME>/etc/init.d/rmtmpfiles</FILENAME> to a new file in the same directory, for example, <FILENAME>/etc/init.d/rmtmpfiles2</FILENAME>:</PARA>
<PROGRAMLISTING>
# <USERINPUT>cd /etc/init.d</USERINPUT>
# <USERINPUT>cp rmtmpfiles rmptmpfiles2</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Open <FILENAME>rmtmpfiles2</FILENAME> for editing, for example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>vi rmtmpfiles2</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Find a block of commands in the file that looks something like this:</PARA>
<PROGRAMLISTING>
# make /var/tmp exist
if [ ! -d /var/tmp ]
then
&ensp;       rm -f /var/tmp # remove the directory
&ensp;       mkdir /var/tmp
fi
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Before the <LITERAL>fi</LITERAL> statement add the following lines:</PARA>
<PROGRAMLISTING>
else 
&ensp;       # clean out /var/tmp 
&ensp;       rm -f /var/tmp/* 
</PROGRAMLISTING>
<PARA>The complete block of commands should look something like this:</PARA>
<PROGRAMLISTING>
# make /var/tmp exist
if [ ! -d /var/tmp ]
then
&ensp;       rm -f /var/tmp # remove the directory
&ensp;       mkdir /var/tmp
else
&ensp;       # clean out /var/tmp
&ensp;       rm -f /var/tmp/*
fi
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Save the file and exit the editor.</PARA>
</LISTITEM>
<LISTITEM><PARA>Create a link to the new file in the directory <FILENAME>/etc/rc2.d</FILENAME>, following the naming conventions described in <FILENAME>/etc/init.d/README</FILENAME>. For example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>cd ../rc2.d</USERINPUT>
# <USERINPUT>ln -s ../init.d/rmtmpfiles S59rmtmpfiles2</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
</ORDEREDLIST>
</SECTION>
<SECTION><TITLE>Locating Unused Files</TITLE><PARA><INDEXTERM ID="ITch7-28"><PRIMARY>files</PRIMARY>
<SECONDARY>locating unused</SECONDARY>
</INDEXTERM>
Part of the job of cleaning up filesystems is locating and removing files that have not been used recently. The <COMMAND>find</COMMAND> command can locate files that have not been accessed recently.</PARA>
<PARA>The <COMMAND>find</COMMAND> command searches for files, starting at a directory named on the command line. It looks for files that match whatever criteria you wish, for example all regular files, all files that end in <FILENAME>.trash</FILENAME>, or any file older than a particular date. When it finds a file that matches the criteria, it performs whatever task you specify, such as removing the file, printing the name of the file, changing the file's permissions, and so forth.</PARA>
<PARA>For example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>find /usr -local -type f -mtime +60 -print &gt; /usr/tmp/deadfiles &amp;</USERINPUT>&ensp;
</PROGRAMLISTING>
<PARA>In the above example:</PARA>
<DEFLIST><DEFLISTENTRY><TERM><LITERAL>/usr</LITERAL></TERM>
<LISTITEM><PARA>specifies the pathname where <COMMAND>find</COMMAND> is to start.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM><LITERAL>-local</LITERAL></TERM>
<LISTITEM><PARA>restricts the search to files on the local system.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM><LITERAL>-type f</LITERAL></TERM>
<LISTITEM><PARA>tells <COMMAND>find</COMMAND> to look only for regular files and to ignore special files, directories, and pipes.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM><LITERAL>-mtime +60</LITERAL></TERM>
<LISTITEM><PARA>says you are interested only in files that have not been modified in 60 days.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM><LITERAL>-print</LITERAL></TERM>
<LISTITEM><PARA>means that when a file is found that matches the <LITERAL>-type</LITERAL> and <LITERAL>-mtime</LITERAL> expressions, you want the pathname to be printed.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM><LITERAL>&gt; /usr/tmp/deadfiles &amp;</LITERAL>
</TERM>
<LISTITEM><PARA><LITERAL></LITERAL>directs the output to the temporary file <LITERAL>/usr/tmp/deadfiles</LITERAL> and runs in the background. Redirecting the results of the search in a file is a good idea if you expect a large amount of output.</PARA>
</LISTITEM>
</DEFLISTENTRY>
</DEFLIST>
<PARA>As another example, you can use the <COMMAND>find</COMMAND> command to find files over 7 days old in the temporary directories and remove them. Use the following commands:</PARA>
<PROGRAMLISTING>
# <USERINPUT>find /var/tmp -local -type f -atime 7 -exec rm {} \;</USERINPUT>&ensp;
# <USERINPUT>find /tmp -local -type f -atime 7 -exec rm {} \;</USERINPUT>&ensp;
</PROGRAMLISTING>
<PARA>This example shows how to use <COMMAND>find</COMMAND> to locate and remove all core files over a week old:</PARA>
<PROGRAMLISTING>
# <USERINPUT>find  / -local -type f -name core -atime +7 -exec rm {} \;</USERINPUT>&ensp;
</PROGRAMLISTING>
<PARA>See the <COMMAND>cron</COMMAND>(1M) reference page for information on using the <COMMAND>cron</COMMAND> command to automate the process of locating and possibly removing. </PARA>
</SECTION>
<SECTION  ID="LE22022-PARENT"><TITLE  ID="LE22022-TITLE">Identifying Accounts That Use Large Amounts of Disk Space</TITLE><PARA><INDEXTERM ID="ITch7-29"><PRIMARY>disk space</PRIMARY>
<SECONDARY>identifying large users</SECONDARY>
</INDEXTERM>
A number of commands are useful for tracking down accounts that use large amounts of space: <COMMAND>du</COMMAND>, <COMMAND>find</COMMAND>, quota commands, and <COMMAND>diskusg</COMMAND>. Their use is described in the following subsections.</PARA>
<SECTION><TITLE>Checking Disk Space Usage With du</TITLE><PARA><INDEXTERM ID="ITch7-30"><PRIMARY><COMMAND>du</COMMAND>
 command</PRIMARY>
</INDEXTERM>
<COMMAND>du</COMMAND> displays disk use, in blocks, for files and directories. For example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>du /usr/share/catman/u_man</USERINPUT>&ensp;
5       /usr/share/catman/u_man/cat1/audio
266     /usr/share/catman/u_man/cat1/Xm
1956    /usr/share/catman/u_man/cat1/X11
72      /usr/share/catman/u_man/cat1/Inventor
413     /usr/share/catman/u_man/cat1/dmedia
752     /usr/share/catman/u_man/cat1/explorer
12714   /usr/share/catman/u_man/cat1
1       /usr/share/catman/u_man/cat3/audio
63      /usr/share/catman/u_man/cat3
12      /usr/share/catman/u_man/cat6/video
1077    /usr/share/catman/u_man/cat6
92      /usr/share/catman/u_man/cat2
425     /usr/share/catman/u_man/cat4
170     /usr/share/catman/u_man/cat5
13      /usr/share/catman/u_man/cat1m
14557   /usr/share/catman/u_man
</PROGRAMLISTING>
<PARA>This displays the block count for all directories in the directory <FILENAME>/usr/share/catman/u_man</FILENAME>. By default the <COMMAND>du</COMMAND> command displays disk use in 512-byte blocks. To display disk use in 1024-byte blocks, use the <COMMAND>-k</COMMAND> option. For example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>du -k /usr/people/ralph</USERINPUT>&ensp;
</PROGRAMLISTING>
<PARA>The <EMPHASIS>-s</EMPHASIS> option produces a summary of the disk use in a particular directory. For example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>du -s /usr/people/alice</USERINPUT>&ensp;
</PROGRAMLISTING>
<PARA>For a complete description of <COMMAND>du</COMMAND> and its options, see the <COMMAND>du</COMMAND>(1M) reference page.</PARA>
</SECTION>
<SECTION><TITLE>Checking Disk Space Usage With find</TITLE><PARA>Use <COMMAND>find</COMMAND> to locate specific files that exceed a given size limit. For example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>find /usr -local -type f -size +10000 -print</USERINPUT>&ensp;
</PROGRAMLISTING>
<PARA>This example produces a display of the pathnames of all files (and directories) in the <FILENAME>usr</FILENAME> filesystem that are larger than 10,000 512-byte blocks. </PARA>
</SECTION>
<SECTION  ID="LE31313-PARENT"><TITLE  ID="LE31313-TITLE">Checking Disk Space Usage on XFS Filesystems With Quota Commands </TITLE><PARA>The disk quotas system, described in the section <XREF LINKEND="LE27105-TITLE">, can be used to monitor disk space usage without enforcing disk usage limits. On XFS filesystems, use these commands to turn on disk usage accounting without enforcement, stop disk usage accounting, and report disk space usage:</PARA><ITEMIZEDLIST><LISTITEM><PARA>To turn on disk usage accounting automatically on a filesystem, include the option <COMMAND>qnoenforce</COMMAND> in the <FILENAME>/etc/fstab</FILENAME> entry, for example:</PARA>
<PROGRAMLISTING>
/dev/root / xfs rw,qnoenforce,raw=/dev/rroot 0 0
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch7-31"><PRIMARY>disk quotas</PRIMARY>
<SECONDARY>and <COMMAND>mount</COMMAND>
 command</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-32"><PRIMARY>mounting filesystems</PRIMARY>
<SECONDARY>and disk quotas</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-33"><PRIMARY><COMMAND>mount</COMMAND>
 command</PRIMARY>
</INDEXTERM>
To turn on disk usage accounting manually on a non-root filesystem when mounting the filesystem, use this <COMMAND>mount</COMMAND> command:</PARA>
<PROGRAMLISTING>
# <USERINPUT>mount -o qnoenforce</USERINPUT>&ensp;<REPLACEABLE>fsname</REPLACEABLE>&ensp;<REPLACEABLE>rootdir</REPLACEABLE>&ensp;
</PROGRAMLISTING>
<PARA><REPLACEABLE>fsname</REPLACEABLE> is the device name of the filesystem. <REPLACEABLE>rootdir</REPLACEABLE> is the directory where the filesystem is mounted.</PARA>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch7-34"><PRIMARY><COMMAND>quotaon</COMMAND>
 command</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-35"><PRIMARY>disk quotas</PRIMARY>
<SECONDARY><COMMAND>quotaon</COMMAND>
 command</SECONDARY>
</INDEXTERM>
To turn on disk usage accounting manually on the root filesystem, give these commands:</PARA>
<PROGRAMLISTING>
# <USERINPUT>/usr/etc/quotaon -v /</USERINPUT>&ensp;
# <USERINPUT>reboot</USERINPUT>&ensp;
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch7-36"><PRIMARY><COMMAND>quotaoff</COMMAND>
 command</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-37"><PRIMARY>disk quotas</PRIMARY>
<SECONDARY><COMMAND>quotaoff</COMMAND>
 command</SECONDARY>
</INDEXTERM>
To stop disk usage accounting on a filesystem, give this command:</PARA>
<PROGRAMLISTING>
# <USERINPUT>/usr/etc/quotaoff</USERINPUT>&ensp;<REPLACEABLE>rootdir</REPLACEABLE>&ensp;
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>To get information about disk usage, use the commands described in <XREF LINKEND="LE26863-PARENT"> and <XREF LINKEND="LE31313-PARENT">.</PARA></LISTITEM>
</ITEMIZEDLIST>
</SECTION>
<SECTION  ID="LE26863-PARENT"><TITLE  ID="LE26863-TITLE">Checking Disk Space Usage With quot </TITLE><PARA><INDEXTERM ID="ITch7-38"><PRIMARY>disk quotas</PRIMARY>
<SECONDARY><COMMAND>quot</COMMAND>
 command</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-39"><PRIMARY><COMMAND>quot</COMMAND>
 command</PRIMARY>
</INDEXTERM>
The <COMMAND>quot</COMMAND> command reports the amount of disk usage per user on a filesystem. It is part of the disk quotas system, although you need not use quotas to use this command. (On XFS filesystems, you must turn on quotas without enforcement; for instructions see <XREF LINKEND="LE31313-PARENT">.) </PARA><PARA>Y<INDEXTERM ID="ITch7-40"><PRIMARY><COMMAND>quot</COMMAND>
 command</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-41"><PRIMARY>disk quotas</PRIMARY>
<SECONDARY><COMMAND>quot</COMMAND>
 command</SECONDARY>
</INDEXTERM>
ou can use the output of the <COMMAND>quot</COMMAND> command to inform your users of their disk space usage. An example of the command that displays disk space usage (on the root filesystem in this example), is:</PARA>
<PROGRAMLISTING>
# <USERINPUT>/usr/etc/quot /</USERINPUT>
/dev/root (/):
&ensp; 371179    root    
&ensp; 265712    ellis   
&ensp;  12606    aevans  
&ensp;   7927    demos   
&ensp;   5526    bin     
&ensp;   2744    lp      
&ensp;    682    uucp    
&ensp;    379    guest   
&ensp;    207    adm     
&ensp;      7    sys     
</PROGRAMLISTING>
</SECTION>
<SECTION><TITLE>Checking Disk Space Usage With diskusg</TITLE><PARA>The <COMMAND>diskusg</COMMAND> command is part of the process accounting subsystem and serves the same purpose as <COMMAND>quot</COMMAND>. <COMMAND>diskusg</COMMAND>, however, is typically used as part of general system accounting. This command generates disk usage information on a per-user basis. For example,</PARA>
<PROGRAMLISTING>
# <USERINPUT>/usr/lib/acct/diskusg /dev/root</USERINPUT>&ensp;
0       root    736795
2       bin     11035
3       uucp    1342
4       sys     9
5       adm     1011
9       lp      5418
126     ellis   528263
993     demos   15737
998     guest   740
5315    aevans  24836
</PROGRAMLISTING>
<PARA><COMMAND>diskusg</COMMAND> prints one line for each user identified in the <FILENAME>/etc/passwd</FILENAME> file. Each line contains the user's UID number and login name, and the total number of 512-byte blocks of disk space currently being used by the account. </PARA>
<PARA>The output of <COMMAND>diskusg</COMMAND> is normally the input to <COMMAND>acctdisk</COMMAND> (see the <COMMAND>acct</COMMAND>(1M) reference page), which generates total disk accounting records that can be merged with other accounting records. For more information on the accounting subsystem, consult <LINK BOOK="IA_BakSecAcc" EXTREF="70848">IRIX Admin: Backup, Security, and Accounting</LINK>
 and the <COMMAND>acct</COMMAND>(4) reference page.</PARA>
</SECTION>
</SECTION>
<SECTION  ID="LE54772-PARENT"><TITLE  ID="LE54772-TITLE">Running Out of Space in the Root Filesystem </TITLE><PARA><INDEXTERM ID="ITch7-42"><PRIMARY>root filesystem</PRIMARY>
<SECONDARY>running out of space</SECONDARY>
</INDEXTERM>
For systems that have separate root and <FILENAME>usr</FILENAME> filesystems, running out of disk space on the root filesystem can occur for several reasons:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA>New software options that place files in the root filesystem have been installed.</PARA>
</LISTITEM>
<LISTITEM><PARA>A new IRIX release that requires more disk space in the root filesystem has been installed.</PARA>
</LISTITEM>
<LISTITEM><PARA>Files created while filesystems were unmounted have been unintentionally placed in the root filesystem instead of their intended filesystem. For example, suppose that the <FILENAME>usr</FILENAME> filesystem is unmounted and the file <FILENAME>/usr/tempfile</FILENAME> is created. When the <FILENAME>usr</FILENAME> filesystem is mounted at <FILENAME>/usr</FILENAME>, the file <FILENAME>/usr/tempfile</FILENAME> is not accessible, but it is still using disk space.</PARA>
</LISTITEM>
<LISTITEM><PARA>Applications that create files in <FILENAME>/tmp</FILENAME> are creating many files or very large files that fill up the root filesystem.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>You can pursue several possible courses of action when the root filesystem is too full:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA>Check for hidden files. Unmount filesystems other than the root filesystem (you may find this easiest to do from the miniroot) and list the contents of each of the mount point directories.</PARA>
</LISTITEM>
<LISTITEM><PARA>Check the <FILENAME>/lost+found</FILENAME> directory. You may find that large files have accumulated there. </PARA>
</LISTITEM>
<LISTITEM><PARA>Increase the size of the root filesystem by combining the root and <FILENAME>usr</FILENAME> filesystems or by making the root filesystem larger by taking disk space from the <FILENAME>usr</FILENAME> filesystem.</PARA>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch7-43"><PRIMARY>directories</PRIMARY>
<SECONDARY>temporary</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-44"><PRIMARY>temporary directories</PRIMARY>
<SECONDARY>setting <LITERAL>TMPDIR</LITERAL>
</SECONDARY>
</INDEXTERM>
Identify applications that are creating files in <FILENAME>/tmp</FILENAME> and cause the most problems, and configure them to use <FILENAME>/usr/tmp</FILENAME> instead of <FILENAME>/tmp</FILENAME> for temporary files. Most applications recognize the <LITERAL>TMPDIR</LITERAL> environment variable, which specifies the directory to use instead of the default. For example, with <COMMAND>csh</COMMAND>:</PARA>
<PROGRAMLISTING>
% <USERINPUT>setenv TMPDIR /usr/tmp</USERINPUT>&ensp;
</PROGRAMLISTING>
<PARA>With <COMMAND>sh</COMMAND>:</PARA>
<PROGRAMLISTING>
% <USERINPUT>TMPDIR=/usr/tmp ; export TMPDIR</USERINPUT>&ensp;
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Make <FILENAME>/tmp</FILENAME> a mounted filesystem. (See <XREF LINKEND="LE31477-TITLE">.) You can &ldquo;carve&rdquo; a <FILENAME>/tmp</FILENAME> filesystem out of other filesystems if necessary. </PARA>
</LISTITEM>
</ITEMIZEDLIST>
</SECTION>
<SECTION  ID="LE51526-PARENT"><TITLE  ID="LE51526-TITLE">Using Disk Quotas on XFS Filesystems</TITLE><PARA><INDEXTERM ID="ITch7-45"><PRIMARY>disk quotas</PRIMARY>
<SECONDARY>imposing on XFS filesystems</SECONDARY>
</INDEXTERM>
This section describes basic commands for administering disk quotas on XFS filesystems. Additional commands are described on the <COMMAND>quota</COMMAND>(1), <COMMAND>edquota</COMMAND>(1M), <COMMAND>quot</COMMAND>(1M), and<COMMAND>&ensp;repquota</COMMAND>(1M) reference pages.</PARA>
<SECTION><TITLE>Turning on Disk Quotas on XFS Filesystems</TITLE><PARA>For XFS filesystems, you must first turn on disk quotas on a filesystem, then set quotas on that filesystem for users. You can turn on quotas in these ways:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA>To turn on disk quotas automatically on a filesystem, include the option <COMMAND>quota</COMMAND> in the <FILENAME>/etc/fstab</FILENAME> entry, for example:</PARA>
<PROGRAMLISTING>
/dev/root / xfs rw,quota,raw=/dev/rroot 0 0
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch7-46"><PRIMARY>disk quotas</PRIMARY>
<SECONDARY>and <COMMAND>mount</COMMAND>
 command</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-47"><PRIMARY>mounting filesystems</PRIMARY>
<SECONDARY>and disk quotas</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-48"><PRIMARY><COMMAND>mount</COMMAND>
 command</PRIMARY>
</INDEXTERM>
To turn on disk quotas manually on a non-root filesystem, mount the filesystem with this command:</PARA>
<PROGRAMLISTING>
# <USERINPUT>mount -o quota</USERINPUT>&ensp;<REPLACEABLE>fsname</REPLACEABLE>&ensp;<REPLACEABLE>rootdir</REPLACEABLE>&ensp;
</PROGRAMLISTING>
<PARA><REPLACEABLE>fsname</REPLACEABLE> is the device name of the filesystem. <REPLACEABLE>rootdir</REPLACEABLE> is the directory where the filesystem is mounted.</PARA>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch7-49"><PRIMARY><COMMAND>quotaon</COMMAND>
 command</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-50"><PRIMARY>disk quotas</PRIMARY>
<SECONDARY><COMMAND>quotaon</COMMAND>
 command</SECONDARY>
</INDEXTERM>
To turn on disk quotas manually on the root filesystem, give these commands:</PARA>
<PROGRAMLISTING>
# <USERINPUT>/usr/etc/quotaon -v /</USERINPUT>&ensp;
# <USERINPUT>reboot</USERINPUT>&ensp;
</PROGRAMLISTING>
</LISTITEM>
</ITEMIZEDLIST>
</SECTION>
<SECTION><TITLE>Setting Disk Quota Limits on XFS Filesystems</TITLE><PARA>After turning on disk quotas on a filesystem, you can set limits for users on that filesystem using the commands below. You can preview the results of each of these commands by adding a <COMMAND>-n</COMMAND> option, which is the dry-run option.</PARA>
<ITEMIZEDLIST><LISTITEM><PARA><INDEXTERM ID="ITch7-51"><PRIMARY><COMMAND>edquota</COMMAND>
 command</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-52"><PRIMARY>disk quotas</PRIMARY>
<SECONDARY><COMMAND>edquota</COMMAND>
 command</SECONDARY>
</INDEXTERM>
To specify limits for users interactively, give this command:</PARA>
<PROGRAMLISTING>
# <USERINPUT>/usr/etc/edquota</USERINPUT>&ensp;<REPLACEABLE>user</REPLACEABLE> ... 
</PROGRAMLISTING>
<PARA><REPLACEABLE>user</REPLACEABLE> is a user ID. The screen clears, and you are placed in the editor specified by the EDITOR environment variable (<COMMAND>vi</COMMAND> if <LITERAL>$EDITOR</LITERAL> is not set) to edit the disk quotas for the filesystem mounted at <REPLACEABLE>rootdir</REPLACEABLE> for the first <REPLACEABLE>user</REPLACEABLE> listed on the command line. You see:</PARA>
<PROGRAMLISTING>
fs <REPLACEABLE>rootdir</REPLACEABLE> kbytes (soft = 0, hard = 0) inodes (soft = 0, hard = 0)
</PROGRAMLISTING>
<PARA>The first pair of soft and hard numbers are the soft and hard limits for disk usage in kilobytes in the filesystem at <REPLACEABLE>rootdir</REPLACEABLE>. The second pair of soft and hard numbers are the soft and hard limits for the number of file that <REPLACEABLE>user</REPLACEABLE> can own in the filesystem.</PARA>
<PARA>Edit the zeros to set the limits to sizes you choose. A limit of zero is not enforced. After you set the limits, save the file and quit the editor. If you specified more than one <REPLACEABLE>user</REPLACEABLE> on the command line, another instance of the editor appears with the line above. Edit this line to enter the limits for the second <REPLACEABLE>user</REPLACEABLE>. Continue until lines have been edited for all <REPLACEABLE>user</REPLACEABLE>s.</PARA>
</LISTITEM>
<LISTITEM><PARA>To specify that users are to have the same limits as another user (<REPLACEABLE>proto_user</REPLACEABLE>), enter this command:</PARA>
<PROGRAMLISTING>
# <USERINPUT>/usr/etc/edquota -p</USERINPUT>&ensp;<REPLACEABLE>proto_user</REPLACEABLE>&ensp;<REPLACEABLE>user</REPLACEABLE> ...
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>To specify limits for a user non-interactively, enter this command:</PARA>
<PROGRAMLISTING>
# <USERINPUT>/usr/etc/edquota -f</USERINPUT>&ensp;<REPLACEABLE>rootdir</REPLACEABLE>&ensp;<USERINPUT>-l \</USERINPUT>
<USERINPUT>uid=</USERINPUT><REPLACEABLE>userid</REPLACEABLE><USERINPUT>,bsoft=</USERINPUT><REPLACEABLE>value</REPLACEABLE><USERINPUT>,bhard=</USERINPUT><REPLACEABLE>value</REPLACEABLE><USERINPUT>,isoft=</USERINPUT><REPLACEABLE>value</REPLACEABLE><USERINPUT>,ihard=</USERINPUT><REPLACEABLE>value</REPLACEABLE>&ensp;
</PROGRAMLISTING>
<PARA><REPLACEABLE>userid</REPLACEABLE> is a numeric user ID. Each <REPLACEABLE>value</REPLACEABLE> is a soft or hard limit in kilobytes.</PARA>
</LISTITEM>
<LISTITEM><PARA>To use the file (<REPLACEABLE>quotafile</REPLACEABLE>) created by command <COMMAND>repquota -e</COMMAND> (see the section <XREF LINKEND="LE79359-PARENT"> as input to the <COMMAND>edquota</COMMAND> command, enter this command:</PARA>
<PROGRAMLISTING>
# <USERINPUT>/usr/etc/edquota -i</USERINPUT>&ensp;<REPLACEABLE>quotafile</REPLACEABLE>&ensp;
</PROGRAMLISTING>
</LISTITEM>
</ITEMIZEDLIST>
</SECTION>
<SECTION><TITLE>Displaying Disk Quota Information on XFS Filesystems</TITLE><PARA>Some commands that display information about disk quotas are as follows:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA><INDEXTERM ID="ITch7-53"><PRIMARY><COMMAND>repquota</COMMAND>
 command</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-54"><PRIMARY>disk quotas</PRIMARY>
<SECONDARY><COMMAND>repquota</COMMAND>
 command</SECONDARY>
</INDEXTERM>
To display a report that shows whether disk quotas are on or off for each filesystem, give this command as superuser:</PARA>
<PROGRAMLISTING>
# <USERINPUT>/usr/etc/repquota -sa</USERINPUT>&ensp;
/dev/xlv/g (/g):
--------------------
Status
&ensp;       user quota accounting       : on
&ensp;       user quota limit enforcement: on
Quota Storage
&ensp;       user quota inum 1862997, blocks 37, extents 36
Default Limits
&ensp;       blocks time limit: 1.0 week
&ensp;       files  time limit: 1.0 week
Cache
&ensp;       dquots currently cached in memory: 8
</PROGRAMLISTING>
<PARA>The sections of the output are as follows:</PARA>
<DEFLIST><DEFLISTENTRY><TERM>Status </TERM>
<LISTITEM><PARA>Lists the status of disk space accounting (on or off) and enforcement of disk quotas (on or off) for this filesystem.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM>Quota Storage </TERM>
<LISTITEM><PARA>Blocks and extents are the number of filesystem blocks and extents used to store disk quota information. The <LITERAL>inum</LITERAL> value is the inode number at which quota information is stored and is for internal use only.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM>Default Limits </TERM>
<LISTITEM><PARA>The blocks and files time limits are the default lengths of time for this filesystem that users have to reduce their disk space usage or number of files below their soft limits. These time limits can be set on a per-user basis by the command <COMMAND>edquota -t</COMMAND>.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM>Cache </TERM>
<LISTITEM><PARA>This section is for internal use only.</PARA>
</LISTITEM>
</DEFLISTENTRY>
</DEFLIST>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch7-55"><PRIMARY><COMMAND>quota</COMMAND>
 command</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-56"><PRIMARY>disk quotas</PRIMARY>
<SECONDARY><COMMAND>quota</COMMAND>
 command</SECONDARY>
</INDEXTERM>
To get information about your disk quotas, enter this command:</PARA>
<PROGRAMLISTING>
# <USERINPUT>quota -v</USERINPUT>&ensp;
Disk quotas for margo (uid 1606):
Filesystem    usage   quota   limit    timeleft  files   quota   limit   timeleft
/            138360       0       0              14971       0       0
/e          4156360   41200       0    1.6 days 222264       0       0
</PROGRAMLISTING>
<PARA>The columns in this output are:</PARA>
<DEFLIST><DEFLISTENTRY><TERM><LITERAL>Filesystem</LITERAL> </TERM>
<LISTITEM><PARA>Lists each of the filesystems that have quotas turned on.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM><LITERAL>usage</LITERAL></TERM>
<LISTITEM><PARA>Lists the user's disk usage on each filesystem. </PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM><LITERAL>quota</LITERAL></TERM>
<LISTITEM><PARA>The user's soft limit for disk usage or files on each filesystem.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM><LITERAL>limit</LITERAL> </TERM>
<LISTITEM><PARA>The user's hard limit for disk usage or files on each filesystem.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM><LITERAL>timeleft</LITERAL> </TERM>
<LISTITEM><PARA>For filesystems where the user's soft limit for disk usage or files is exceeded, gives the number of days until the user is prohibited from using additional disk space or creating more files.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM><LITERAL>files</LITERAL> </TERM>
<LISTITEM><PARA>The number of files owned by the user on each filesystem.</PARA>
</LISTITEM>
</DEFLISTENTRY>
</DEFLIST>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch7-57"><PRIMARY><COMMAND>quot</COMMAND>
 command</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-58"><PRIMARY>disk quotas</PRIMARY>
<SECONDARY><COMMAND>quot</COMMAND>
 command</SECONDARY>
</INDEXTERM>
To get information about the disk usage and quotas of all users, enter this command:</PARA>
<PROGRAMLISTING>
# <USERINPUT>/usr/etc/quot -a</USERINPUT>&ensp;
</PROGRAMLISTING>
</LISTITEM>
</ITEMIZEDLIST>
</SECTION>
<SECTION  ID="LE79359-PARENT"><TITLE  ID="LE79359-TITLE">Administering Disk Quotas on XFS Filesystems</TITLE><PARA>Backups created by <COMMAND>xfsdump</COMMAND> do not record quota limit information, so an important task for system administrators is to record this information in a file whenever quota limits are changed. Also, if the inode that holds quota information is damaged, using <COMMAND>xfs_repair</COMMAND> clears the inode, which deletes the quota information. Thus, having a record of the quota limits in a file ensures that it will be available if you need to recover a filesystem. </PARA>
<PARA>To create a file that lists the current quota limits of all the filesystems, enter this command as superuser:</PARA>
<PROGRAMLISTING>
# <USERINPUT>/usr/etc/repquota -a -e</USERINPUT>&ensp;<REPLACEABLE>quotafile</REPLACEABLE>&ensp;
</PROGRAMLISTING>
<PARA>If you are familiar with using disk quotas on EFS filesystems, note that some quota commands that are used on EFS filesystems are not used on XFS filesystems. These commands are:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA><COMMAND>quotacheck</COMMAND>. There is no need to run <COMMAND>quotacheck</COMMAND> manually.</PARA>
</LISTITEM>
<LISTITEM><PARA><COMMAND>chkconfig quota on</COMMAND> and <COMMAND>chkconfig quota off</COMMAND>. Disk quotas are turned on during mounting, so <COMMAND>mount</COMMAND> options control whether disk quotas are on or off, not <COMMAND>chkconfig</COMMAND>.</PARA>
</LISTITEM>
<LISTITEM><PARA><COMMAND>chkconfig quotacheck on</COMMAND> and <COMMAND>chkconfig quotacheck off</COMMAND>. quotacheck is not used on XFS filesystems so these <COMMAND>chkconfig</COMMAND> commands have no effect.</PARA>
</LISTITEM>
<LISTITEM><PARA><COMMAND>/etc/init.d/quotas start</COMMAND>. This command has no effect on disk quota tracking on XFS systems. </PARA>
</LISTITEM>
<LISTITEM><PARA><COMMAND>touch quotas</COMMAND>. There is no need to create files called <FILENAME>quotas</FILENAME> in the root directory of each filesystem. Quota information is hidden in the XFS filesystem structure.</PARA>
</LISTITEM>
<LISTITEM><PARA><COMMAND>repquota</COMMAND> by non-superusers. Only the superuser can use the <COMMAND>repquota</COMMAND> command on XFS filesystems.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</SECTION>
</SECTION>
</SECTION>
<SECTION  ID="LE22948-PARENT"><TITLE  ID="LE22948-TITLE">Copying XFS Filesystems With xfs_copy</TITLE><PARA><INDEXTERM ID="ITch7-59"><PRIMARY><COMMAND>xfs_copy</COMMAND>
 command</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-60"><PRIMARY>XFS filesystems</PRIMARY>
<SECONDARY>copying with <COMMAND>xfs_copy</COMMAND>
</SECONDARY>
</INDEXTERM>
The <COMMAND>xfs_copy</COMMAND> command can be used to copy an XFS filesystem with an internal log (XFS filesystems with external logs or real-time subvolumes cannot be copied with <COMMAND>xfs_copy</COMMAND>). One or more copies can be created on disk partitions, logical volumes, or files. Each copy has a unique filesystem identifier, which enables them to be run as separate filesystems on the same system. (Programs that do block-by-block copying, such as <COMMAND>dd</COMMAND>, do not create unique filesystem identifiers.) Multiple copies are created in parallel. For more information, see the <COMMAND>xfs_copy</COMMAND>(1M) reference page.</PARA>
<PARA>An example of the <COMMAND>xfs_copy</COMMAND> command is:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xfs_copy /dev/dsk/dks0d3s7 /dev/dsk/dks5d2s7</USERINPUT>
... 10%  ... 20%  ... 30%  ... 40%  ... 50%  ... 60%  ... 70%  ... 80%  ... 90%  ... 100%
Done.
All copies completed.
</PROGRAMLISTING>
</SECTION>
<SECTION  ID="LE92347-PARENT"><TITLE  ID="LE92347-TITLE">Checking XFS Filesystem Consistency With xfs_check and xfs_repair </TITLE><PARA>XFS filesystem consistency checking can be done using the <COMMAND>xfs_check</COMMAND> command and the dry-run mode of the <COMMAND>xfs_repair</COMMAND> command. The <COMMAND>xfs_repair</COMMAND> command is sometimes able to repair filesystem inconsistencies. </PARA>
<SECTION><TITLE>Checking Filesystem Consistency</TITLE><PARA><INDEXTERM ID="ITch7-61"><PRIMARY><COMMAND>xfs_check</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>how to use</COMMAND>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-62"><PRIMARY>XFS filesystems</PRIMARY>
<SECONDARY>checking for consistency</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-63"><PRIMARY>filesystems</PRIMARY>
<SECONDARY>checking for consistency</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-64"><PRIMARY>filesystems</PRIMARY>
<SECONDARY>corruption</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-65"><PRIMARY>XFS filesystems</PRIMARY>
<SECONDARY>corruption</SECONDARY>
</INDEXTERM>
The filesystem consistency checking commands for XFS filesystems are <COMMAND>xfs_check</COMMAND> and <COMMAND>xfs_repair -n</COMMAND>. (<COMMAND>fsck</COMMAND> is used only for EFS filesystems.) Unlike <COMMAND>fsck</COMMAND>, neither <COMMAND>xfs_check</COMMAND> nor <COMMAND>xfs_repair</COMMAND> are invoked automatically on system startup. They should be used only if you suspect a filesystem consistency problem.</PARA>
<PARA>Before running <COMMAND>xfs_check</COMMAND> or <COMMAND>xfs_repair -n</COMMAND>, the filesystem to be checked must be unmounted cleanly using normal system administration procedures (the <COMMAND>umount</COMMAND> command or system shutdown), not as a result of a crash or system reset. If the filesystem has not been unmounted cleanly, mount it and unmount it cleanly before running <COMMAND>xfs_check</COMMAND> or <COMMAND>xfs_repair -n</COMMAND>.</PARA>
<PARA><INDEXTERM ID="ITch7-66"><PRIMARY><COMMAND>xfs_repair</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>using to check filesystems</COMMAND>
</SECONDARY>
</INDEXTERM>
<COMMAND>xfs_repair -n</COMMAND> checks XFS filesystem consistency. <COMMAND>xfs_repair -n</COMMAND> performs a more complete check than <COMMAND>xfs_check</COMMAND>, but cannot be used to check filesystems with extended attributes or filesystems on XLV real-time subvolumes. The command line for <COMMAND>xfs_repair -n</COMMAND> is:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xfs_repair -n</USERINPUT>&ensp;<REPLACEABLE>device</REPLACEABLE>
</PROGRAMLISTING>
<PARA><REPLACEABLE>device</REPLACEABLE> is the device file for a disk partition or logical volume that contains an XFS filesystem, for example <FILENAME>/dev/xlv/xlv0</FILENAME>. </PARA>
<PARA>The following example shows output with no consistency problems found:</PARA>
<PROGRAMLISTING>
Phase 1 - find and verify superblock...
Phase 2 - scan filesystem freespace and inode maps...
&ensp;       - found root inode chunk
Phase 3 - for each AG...
&ensp;       - scan (but don't clear) agi unlinked lists...
&ensp;       - process known inodes and perform inode discovery...
&ensp;       - process newly discovered inodes...
&ensp;       - agno = 0
&ensp;       - agno = 1
&ensp;       ...
Phase 4 - check for duplicate blocks...
&ensp;       - setting up duplicate extent list...
&ensp;       - check for inodes claiming duplicate blocks...
&ensp;       - agno = 0
&ensp;       - agno = 1
&ensp;       ...
No modify flag set, skipping phase 5
Phase 6 - check inode connectivity...
&ensp;       - traversing filesystem starting at / ... 
&ensp;       - traversal finished ... 
&ensp;       - traversing all unattached subtrees ... 
&ensp;       - traversals finished ... 
&ensp;       - moving disconnected inodes to lost+found ... 
Phase 7 - verify link counts...
No modify flag set, skipping filesystem flush and exiting.
</PROGRAMLISTING>
<PARA><COMMAND>xfs_check</COMMAND> also checks XFS filesystem consistency. It can be used on filesystems with Extended Attributes (see the <COMMAND>attr</COMMAND>(1) reference page). (<COMMAND>xfs_repair</COMMAND> performs only limited checking of Extended Attributes.) The command line for <COMMAND>xfs_check</COMMAND> is:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xfs_check</USERINPUT>&ensp;<REPLACEABLE>device</REPLACEABLE>
</PROGRAMLISTING>
<PARA>If no consistency problems were found, <COMMAND>xfs_check</COMMAND> returns without displaying any messages.</PARA>
</SECTION>
<SECTION><TITLE>Repairing Inconsistent Filesystems</TITLE><PARA><INDEXTERM ID="ITch7-67"><PRIMARY><COMMAND>xfs_repair</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>using to repair filesystems</COMMAND>
</SECONDARY>
</INDEXTERM>
<COMMAND>xfs_repair</COMMAND> (without the <COMMAND>-n</COMMAND> option) checks XFS filesystem consistency and, if problems are detected, corrects them if possible. The filesystem to be checked and repaired must have been unmounted cleanly using normal system administration procedures (the <COMMAND>umount</COMMAND> command or system shutdown), not as a result of a crash or system reset. If the filesystem has not been unmounted cleanly, mount it and unmount it cleanly before running <COMMAND>xfs_repair</COMMAND>.</PARA>
<PARA>The command line for <COMMAND>xfs_repair</COMMAND> when you want it to repair any inconsistencies it finds is:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xfs_repair</USERINPUT>&ensp;<REPLACEABLE>device</REPLACEABLE>
</PROGRAMLISTING>
<PARA><REPLACEABLE>device</REPLACEABLE> is the device file for a disk partition or logical volume that contains an XFS filesystem, for example <FILENAME>/dev/xlv/xlv0</FILENAME>. It must not be mounted. </PARA>
<PARA>An example of the output you see from running <COMMAND>xfs_repair</COMMAND> on a clean filesystem is:</PARA>
<PROGRAMLISTING>
Phase 1 - find and verify superblock...
Phase 2 - zero log...
&ensp;       - scan filesystem freespace and inode maps...
&ensp;       - found root inode chunk
Phase 3 - for each AG...
&ensp;       - scan and clear agi unlinked lists...
&ensp;       - process known inodes and perform inode discovery...
&ensp;       - agno = 0
&ensp;       - agno = 1
&ensp;       ...
&ensp;       - process newly discovered inodes...
Phase 4 - check for duplicate blocks...
&ensp;       - setting up duplicate extent list...
&ensp;       - clear lost+found (if it exists) ...
&ensp;       - check for inodes claiming duplicate blocks...
&ensp;       - agno = 0
&ensp;       - agno = 1
&ensp;       ...
Phase 5 - rebuild AG headers and trees...
&ensp;       - reset superblock counters...
Phase 6 - check inode connectivity...
&ensp;       - ensuring existence of lost+found directory
&ensp;       - traversing filesystem starting at / ... 
&ensp;       - traversal finished ... 
&ensp;       - traversing all unattached subtrees ... 
&ensp;       - traversals finished ... 
&ensp;       - moving disconnected inodes to lost+found ... 
Phase 7 - verify and correct link counts...
done
</PROGRAMLISTING>
<PARA>For information about using <COMMAND>xfs_repair</COMMAND> on an inconsistent filesystem, see <XREF LINKEND="LE35305-PARENT">.</PARA></SECTION>
</SECTION>
<SECTION  ID="LE28728-PARENT"><TITLE  ID="LE28728-TITLE">Checking Foreign Filesystem<INDEXTERM ID="ITch7-68"><PRIMARY>foreign filesystems</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-69"><PRIMARY>filesystems</PRIMARY>
<SECONDARY>foreign filesystems</SECONDARY>
</INDEXTERM>
 Consistency With fpck</TITLE><PARA>&ensp;The IRIX operating system provides the <COMMAND>fpck</COMMAND> command to check and repair <FILENAME>hfs</FILENAME> (<FILENAME>mac</FILENAME>) and <FILENAME>dos</FILENAME> (<FILENAME>fat</FILENAME>) filesystems. When the <COMMAND>fpck</COMMAND> utility locates major filesystem structure destruction, such as critical sector damage or an unrecoverable error, it gives an error message. For less severe filesystem inconsistencies, it gives a warning message</PARA>
<NOTE><PARA>For repair of foreign filesystems, it can be more constructive to use the filesystem repair tools of the foreign operating system.</PARA>
</NOTE>
<PARA>For information on using the <COMMAND>fpck</COMMAND> utility, see the <COMMAND>fpck</COMMAND>(1M) reference page. For further information on foreign filesystem types, see the <COMMAND>filesystems</COMMAND>(4) reference page. For information on creating foreign filesystems, see the <COMMAND>mkfp</COMMAND>(1M) reference page.</PARA>
</SECTION>
<SECTION  ID="LE35305-PARENT"><TITLE  ID="LE35305-TITLE">Repairing XFS Filesystem Problems</TITLE><PARA><INDEXTERM ID="ITch7-70"><PRIMARY><COMMAND>xfs_repair</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>repairing filesystems</COMMAND>
</SECONDARY>
</INDEXTERM>
The <COMMAND>xfs_repair</COMMAND> command checks XFS filesystem consistency and sometimes repairs problems that are found. This section describes the messages that you may see from <COMMAND>xfs_repair</COMMAND> and what to do if <COMMAND>xfs_repair</COMMAND> is not able to repair a filesystem.</PARA>
<SECTION><TITLE>Common Error Messages</TITLE><PARA>Some common error messages from <COMMAND>xfs_repair</COMMAND> and the repairs that it performs are the following:</PARA>
<DEFLIST><DEFLISTENTRY><TERM><LITERAL>disconnected inode 242002, moving to lost+found</LITERAL></TERM>
<LISTITEM><PARA><COMMAND>xfs_repair</COMMAND> found an inode that is in use, but is not connected to the filesystem. The inode is moved to the filesystem's <FILENAME>lost+found</FILENAME> directory. Its name is its inode number, in this example 242002. If the disconnected inode is a directory, the directory's subtree is preserved&mdash;all its child inodes are automatically moved with it, so the entire directory subtree moves to <FILENAME>lost+found</FILENAME>.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM><LITERAL>imap claims in-use inode 2444941 is free, correcting imap</LITERAL></TERM>
<LISTITEM><PARA>The inode allocation map in the filesystem behaves as if inode 2444941 is free, but the inode itself looks like it is still in use. <COMMAND>xfs_repair</COMMAND> corrects the inode map to say that the inode is in use.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM><LITERAL>entry references free inode 2444940 in shortform directory 2444922 junking entry &ldquo;fb&rdquo; in directory inode 2444922</LITERAL> </TERM>
<LISTITEM><PARA>A directory entry points to an inode that <COMMAND>xfs_repair</COMMAND> has determined is actually free. <COMMAND>xfs_repair</COMMAND> junks the directory entry. The term <FIRSTTERM>shortform</FIRSTTERM> means a small directory. In larger directories, the entry deletion is usually a two-pass process. In this case, the second part of the message reads something like <LITERAL>marking bad entry</LITERAL>, <LITERAL>marking entry to be deleted</LITERAL>, or <LITERAL>will clear entry</LITERAL>.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM><LITERAL>resetting inode 241996 nlinks from 5 to 3</LITERAL> </TERM>
<LISTITEM><PARA><COMMAND>xfs_repair</COMMAND> detected a mismatch between the number of directory entries pointing to the inode (links) and the number of links recorded in the inode. It corrected the number (from 5 to 3 in this case).</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM><LITERAL>cleared inode 2444926</LITERAL> </TERM>
<LISTITEM><PARA>There was something wrong with the inode that was not correctable, so <COMMAND>xfs_repair</COMMAND> turned it into a zero-length free inode. This usually happens because the inode claims blocks that are used by something else or the inode itself is badly corrupted. Typically, the <LITERAL>cleared inode</LITERAL> message is preceded by one or more messages indicating why the inode needs to be cleared.</PARA>
</LISTITEM>
</DEFLISTENTRY>
</DEFLIST>
</SECTION>
<SECTION  ID="LE55901-PARENT"><TITLE  ID="LE55901-TITLE">Error Messages When Files Are in lost+found</TITLE><PARA>If <COMMAND>xfs_repair</COMMAND> has put files and directories in a filesystem's <FILENAME>lost+found</FILENAME> directory and you do not remove them, the next time you run <COMMAND>xfs_repair</COMMAND> it temporarily disconnects the inodes for those files and directories. They are reconnected before <COMMAND>xfs_repair</COMMAND> terminates. As a result of the disconnected inodes in <FILENAME>lost+found</FILENAME>, you see output like this:</PARA>
<PROGRAMLISTING>
Phase 1 - find and verify superblock...
Phase 2 - zero log...
&ensp;       - scan filesystem freespace and inode maps...
&ensp;       - found root inode chunk
Phase 3 - for each AG...
&ensp;       - scan and clear agi unlinked lists...
&ensp;       - process known inodes and perform inode discovery...
&ensp;       - agno = 0
&ensp;       - agno = 1
&ensp;       ...
&ensp;       - process newly discovered inodes...
Phase 4 - check for duplicate blocks...
&ensp;       - setting up duplicate extent list...
&ensp;       - clear lost+found (if it exists) ...
&ensp;       - clearing existing &ldquo;lost+found&rdquo; inode
&ensp;       - deleting existing &ldquo;lost+found&rdquo; entry
&ensp;       - check for inodes claiming duplicate blocks...
&ensp;       - agno = 0
imap claims in-use inode 242000 is free, correcting imap
&ensp;       - agno = 1
&ensp;       - agno = 2
&ensp;       ...
Phase 5 - rebuild AG headers and trees...
&ensp;       - reset superblock counters...
Phase 6 - check inode connectivity...
&ensp;       - ensuring existence of lost+found directory
&ensp;       - traversing filesystem starting at / ... 
&ensp;       - traversal finished ... 
&ensp;       - traversing all unattached subtrees ... 
&ensp;       - traversals finished ... 
&ensp;       - moving disconnected inodes to lost+found ... 
disconnected inode 242000, moving to lost+found	
Phase 7 - verify and correct link counts...
done
</PROGRAMLISTING>
<PARA>In this example, inode 242000 was an inode that was moved to <FILENAME>lost+found</FILENAME> during a previous <COMMAND>xfs_repair</COMMAND> run. This run of <COMMAND>xfs_repair</COMMAND> found that the filesystem is consistent. If the <FILENAME>lost+found</FILENAME> directory had been empty, in phase 4 only the messages about clearing and deleting the <FILENAME>lost+found</FILENAME> directory would have appeared. The left-justified <LITERAL>imap claims</LITERAL> and <LITERAL>disconnected inode</LITERAL> messages appear (one pair of messages per inode) if there are inodes in the <FILENAME>lost+found</FILENAME> directory.</PARA>
</SECTION>
<SECTION  ID="LE42852-PARENT"><TITLE  ID="LE42852-TITLE">What to Do If xfs_repair Cannot Repair a Filesystem</TITLE><PARA>If <COMMAND>xfs_repair</COMMAND> fails to repair the filesystem successfully, try giving the same <COMMAND>xfs_repair</COMMAND> command twice more; <COMMAND>xfs_repair</COMMAND> may be able to make more repairs on successive runs. If <COMMAND>xfs_repair</COMMAND> fails to fix the consistency problems in three tries, your next step depends upon where it failed:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA>If <COMMAND>xfs_repair</COMMAND> failed in phase 1, you must restore lost files from backups.</PARA>
</LISTITEM>
<LISTITEM><PARA>If <COMMAND>xfs_repair</COMMAND> failed in phase 2 or later, you may be able to restore files from the disk by backing up and restoring the files on the filesystem.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If <COMMAND>xfs_repair</COMMAND> failed in phase 2 or later, follow these steps: </PARA>
<ORDEREDLIST><LISTITEM><PARA>Mount the filesystem using <COMMAND>mount &ndash;r</COMMAND> (read-only).</PARA>
</LISTITEM>
<LISTITEM><PARA>Make a filesystem backup with <COMMAND>xfsdump</COMMAND>. </PARA>
</LISTITEM>
<LISTITEM><PARA>Use <COMMAND>mkfs</COMMAND> to a make new filesystem on the same disk partition or XLV logical volume.</PARA>
</LISTITEM>
<LISTITEM><PARA>Restore the files from the backup with <COMMAND>xfsrestore</COMMAND>.</PARA>
</LISTITEM>
</ORDEREDLIST>
<PARA>See <LINK BOOK="IA_BakSecAcc" EXTREF="70848">IRIX Admin: Backup, Security, and Accounting</LINK>
 for information about <COMMAND>xfsdump</COMMAND> and <COMMAND>xfsrestore</COMMAND>.</PARA>
</SECTION>
<SECTION><TITLE>Mounting A Filesystem Without Log Recovery</TITLE><PARA>If a filesystem is damaged to the extent that you are unable to mount the filesystem successfully in the standard fashion, you may be able to recover some of its data by mounting the filesystem with the <COMMAND>-o norecover</COMMAND> option of the <COMMAND>mount</COMMAND> command. This option mounts the filesystem without running log recovery. You must mount the filesystem as read-only when you use this option. </PARA>
<PARA>When you mount the filesystem in norecovery mode when it was not unmounted cleanly, the filesystem is likely to be inconsistent, and you will be unable to read all of its data.   However, you may be able to recover data that you can cannot otherwise access.</PARA>
<PARA>For information on the mount command and its options, see the <COMMAND>mount</COMMAND>(1M) and the <COMMAND>fstab</COMMAND>(4) reference pages.</PARA>
</SECTION>
</SECTION>
<SECTION  ID="LE31685-PARENT"><TITLE  ID="LE31685-TITLE">Running xfs_repair on the Root Filesystem</TITLE><PARA><INDEXTERM ID="ITch7-71"><PRIMARY>root filesystem</PRIMARY>
<SECONDARY> repairing</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch7-72"><PRIMARY><COMMAND>xfs_repair</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>repairing root filesystem</COMMAND>
</SECONDARY>
</INDEXTERM>
If you find that your root filesystem is corrupted, you can run <COMMAND>xfs_repair</COMMAND> on the root filesystem itself. In order to do this, you run the <COMMAND>xfs_repair</COMMAND> command from the miniroot using the following procedure:</PARA>
<ORDEREDLIST><LISTITEM><PARA>Boot the miniroot. The procedure for performing a miniroot installation is provided in <CITETITLE>IRIX Admin: Software Installation and Licensing.</CITETITLE></PARA>
</LISTITEM>
<LISTITEM><PARA>From the miniroot <INTERFACE>Main Menu</INTERFACE>, select the <INTERFACE>Administrative Commands</INTERFACE> menu.</PARA>
</LISTITEM>
<LISTITEM><PARA>Get a single-user shell by selecting <COMMAND>sh</COMMAND>.</PARA>
</LISTITEM>
<LISTITEM><PARA>Run <COMMAND>xfs_repair</COMMAND> on the root filesystem, which in most cases will be <FILENAME>/dev/dsk/dks0d1s0</FILENAME>.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECTION>
</CHAPTER>
