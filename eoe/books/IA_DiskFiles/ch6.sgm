<!-- Produced by version 4.3 (11/99) of SGI Frame/SGIDOCBK SGML translator -->
<CHAPTER ID="LE35942-PARENT"><TITLE ID="LE35942-TITLE">Creating and Growing Filesystems</TITLE><PARA>This chapter describes the procedures you must perform to create or grow (increase the size of) an XFS filesystem or to convert from an EFS filesystem to an XFS filesystem.</PARA>
<PARA>The major sections in this chapter are:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA><XREF LINKEND="LE82948-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE72328-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE67358-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE12464-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE49326-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE72401-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE96722-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE37018-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE28665-PARENT"></PARA></LISTITEM>
</ITEMIZEDLIST>
<SECTION  ID="LE82948-PARENT"><TITLE  ID="LE82948-TITLE">Planning an XFS Filesystem</TITLE><PARA><INDEXTERM ID="ITch6-0"><PRIMARY>XFS filesystems</PRIMARY>
<SECONDARY>preparing to make filesystems</SECONDARY>
</INDEXTERM>
The following subsections discuss preparation for and choices you must make when creating an XFS filesystem. Each time you plan to make an XFS filesystem or convert a filesystem from EFS to XFS, review each section and make any necessary preparations.</PARA>
<SECTION><TITLE>Prerequisite Software</TITLE><PARA>If you are converting the root and <FILENAME>usr</FILENAME> filesystems to XFS, you must have software distribution CDs or access to a remote distribution directory for IRIX system software.</PARA>
</SECTION>
<SECTION  ID="LE45044-PARENT"><TITLE  ID="LE45044-TITLE">Choosing the Filesystem Block Size and Extent Size</TITLE><PARA><INDEXTERM ID="ITch6-1"><PRIMARY>XFS filesystems</PRIMARY>
<SECONDARY>block sizes</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-2"><PRIMARY>block sizes</PRIMARY>
<SECONDARY>range of sizes</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-3"><PRIMARY>block sizes</PRIMARY>
<SECONDARY>guidelines</SECONDARY>
</INDEXTERM>
XFS allows you to choose the logical block size for each filesystem. (Physical disk blocks remain 512 bytes.) If you use a real-time subvolume on an XLV logical volume, you must also choose the extent size. The extent size is the amount of space that is allocated to a file each time it needs more space.</PARA>
<PARA>For XFS filesystems on disk partitions and logical volumes and for the data subvolume of filesystems on XLV volumes, the block size guidelines are as follows:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA>The minimum block size is 512 bytes. Small block sizes increase allocation overhead which decreases filesystem performance, but in general, the recommended block size for filesystems under 100 MB and for filesystems with many small files is 512 bytes. The filesystem block size must be a power of two.</PARA>
</LISTITEM>
<LISTITEM><PARA>The default block size is 4096 bytes (4K). This is the recommended block size for filesystems over 100 MB.</PARA>
</LISTITEM>
<LISTITEM><PARA>The maximum block size is 65536 bytes (64K). Because large block sizes can waste space and lead to fragmentation, in general block sizes should not be larger than 4096 bytes (4K).</PARA>
</LISTITEM>
<LISTITEM><PARA>For the root filesystem on systems with separate root and <FILENAME>usr</FILENAME> filesystems, the recommended block size is 512 bytes. For systems where root and <FILENAME>usr</FILENAME> are not separate filesystems, the recommended block size is 4096 bytes, the default block size.</PARA>
</LISTITEM>
<LISTITEM><PARA>For news servers, it is recommended that you use a version 2 directory format with a filesystem block size of 512 bytes and a directory block size of 4096 bytes. For information on using version 2 directories see <XREF LINKEND="LE30568-PARENT">.</PARA></LISTITEM>
</ITEMIZEDLIST>
<PARA><INDEXTERM ID="ITch6-4"><PRIMARY>block sizes</PRIMARY>
<SECONDARY>syntax</SECONDARY>
</INDEXTERM>
Block sizes are specified in bytes in decimal (default), octal (prefixed by 0), or hexadecimal (prefixed by 0x or 0X). If the number has the suffix &ldquo;k,&rdquo; it is multiplied by 1024. If the number has the suffix &ldquo;m,&rdquo; it is multiplied by 1048576 (1024 * 1024).</PARA>
<PARA><INDEXTERM ID="ITch6-5"><PRIMARY>extent size</PRIMARY>
</INDEXTERM>
The guidelines for the extent size are as follows:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA>The extent size must be a multiple of the block size of the data subvolume.</PARA>
</LISTITEM>
<LISTITEM><PARA>The minimum extent size is 4 KB.</PARA>
</LISTITEM>
<LISTITEM><PARA>The maximum extent size is 1 GB.</PARA>
</LISTITEM>
<LISTITEM><PARA>The default extent size is 64 KB.</PARA>
</LISTITEM>
<LISTITEM><PARA>The extent size should be matched to the application and the stripe unit of the volume elements used in the real-time subvolume.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA><INDEXTERM ID="ITch6-6"><PRIMARY>unwritten extents</PRIMARY>
</INDEXTERM>
A filesystem extent is considered <FIRSTTERM>unwritten</FIRSTTERM> if it is allocated to a file and has never been written by anyone after the allocation. This can occur when you use <FILENAME>F_RESVSP</FILENAME> parameter of the <COMMAND>fcntl(2)</COMMAND> system call to preallocate space. If you preallocate space and then read the data when the extent is unwritten, you could see the old contents of the data. This could have been written by another user, and may break security.</PARA>
<PARA>When you define an XFS filesystem, you can specify whether unwritten extent tracking is on. This causes XFS to keep track of unwritten extents and does not allow a read to return old data. When unwritten extent tracking is on, a read on an unwritten extent returns a value of 0. Unwritten extent tracking is on by default in IRIX 6.5 systems and later.</PARA>
</SECTION>
<SECTION  ID="LE30568-PARENT"><TITLE  ID="LE30568-TITLE">Choosing the Filesystem Directory Format and Directory Block Size</TITLE><PARA><INDEXTERM ID="ITch6-7"><PRIMARY>XFS filesystem</PRIMARY>
<SECONDARY>directory format</SECONDARY>
</INDEXTERM>
XFS supports two on-disk directory formats, referred to as <FIRSTTERM>version 1</FIRSTTERM> and <FIRSTTERM>version 2</FIRSTTERM> in <COMMAND>mkfs</COMMAND> output. The version you choose when you create a filesystem applies to all the directories in a filesystem. <INDEXTERM ID="ITch6-8"><PRIMARY>filesystem directory format</PRIMARY>
</INDEXTERM>
Version 1 is the original IRIX filesystem directory format and is the default; version 2 was added with the 6.5.5 release of IRIX.You choose the directory format with the <COMMAND>-n</COMMAND> parameter of the <COMMAND>mkfs</COMMAND> command.</PARA>
<PARA>An XFS file system with version 2 directory format allows you to select a logical block size for the filesystem directory that is greater than the logical block size of the filesystem. This allows you to choose a filesystem block size to match the distribution of data file sizes without adversely affecting directory operation performance. Using this option could improve performance for a filesystem with many small files, such as a news or mail filesystem. In this case, the filesystem logical block size could be small (512, 1K, or 2K bytes) and the logical block size for the filesystem directory could be large (4K or 8K bytes); this can improve the performance of directory lookups because the tree storing the index information has larger blocks and less depth.</PARA>
<PARA>You should consider setting a logical block size for a filesystem directory that is greater than the logical block size for the filesystem if you are supporting an application that reads directories (with the <COMMAND>readdir</COMMAND>(3C) or <COMMAND>getdents</COMMAND>(2) system calls) many times in relation to how much it creates and removes files. Using a small filesystem block size saves on disk space and on I/O throughput for the small files.</PARA>
<PARA>In an XFS file system with version 2 directory format, the data needed to perform a <COMMAND>readdir</COMMAND> operation is segregated from the index information. Directory data blocks can be &ldquo;read-ahead&rdquo; in a <COMMAND>readdir</COMMAND> on a version 2 directory block; this is not possible with a version 1 directory block. Performing read-ahead improves the <COMMAND>readdir</COMMAND> performance dramatically.</PARA>
<PARA>Because the data needed for a <COMMAND>readdir</COMMAND> operation and index information are separate in a version 2 directory block, the offset in a directory is limited to 32 bits. In a version 1 directory block, a 64-bit offset is used. A 64-bit offset can cause some interoperability problems for 32-bit clients such as NFS V2, DFS and 32-bit (O32) applications.</PARA>
<PARA>For information on using the <COMMAND>-n</COMMAND> option of <COMMAND>mkfs</COMMAND> to select a version 2 directory format, see the <COMMAND>mkfs_xfs</COMMAND>(1M) man page.</PARA>
</SECTION>
<SECTION  ID="LE93345-PARENT"><TITLE  ID="LE93345-TITLE">Choosing the Log Type and Size</TITLE><PARA><INDEXTERM ID="ITch6-9"><PRIMARY>XFS filesystems</PRIMARY>
<SECONDARY>logs. <EMPHASIS>See</EMPHASIS>
 logs.</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-10"><PRIMARY>logs</PRIMARY>
<SECONDARY>description</SECONDARY>
</INDEXTERM>
Each XFS filesystem has a log that contains filesystem journaling records. This log requires dedicated disk space. This disk space doesn't show up in listings from the <COMMAND>df</COMMAND> command, nor can you access it with a filename.</PARA>
<PARA>The location of the disk space depends on the type of log you choose. The two types of logs are:</PARA>
<DEFLIST><DEFLISTENTRY><TERM>External</TERM>
<LISTITEM><PARA><INDEXTERM ID="ITch6-11"><PRIMARY>logs</PRIMARY>
<SECONDARY>external, definition</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-12"><PRIMARY>external logs</PRIMARY>
<SECONDARY>definition</SECONDARY>
</INDEXTERM>
When an XFS filesystem is created on an XLV logical volume and log records are put into a log subvolume, the log is called an <FIRSTTERM>external</FIRSTTERM> log. The log subvolume is one or more disk partitions dedicated to the log exclusively.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM>Internal</TERM>
<LISTITEM><PARA><INDEXTERM ID="ITch6-13"><PRIMARY>logs</PRIMARY>
<SECONDARY>internal, definition</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-14"><PRIMARY>internal logs</PRIMARY>
<SECONDARY>definition</SECONDARY>
</INDEXTERM>
When an XFS filesystem is created on a disk partition or XLV logical volume, or when it is created on an XLV logical volume that does not have a log subvolume, log records are put into a dedicated portion of the disk partition (or data subvolume) that contains user files. This type of log is called an <FIRSTTERM>internal</FIRSTTERM> log.</PARA>
</LISTITEM>
</DEFLISTENTRY>
</DEFLIST>
<PARA><INDEXTERM ID="ITch6-15"><PRIMARY>logs</PRIMARY>
<SECONDARY>choosing type</SECONDARY>
</INDEXTERM>
The guidelines for choosing the log type are as follows:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA>If you want the log and the data subvolume to be on different partitions or to use different subvolume configurations for them, use an external log.</PARA>
</LISTITEM>
<LISTITEM><PARA>If you want the log subvolume to be striped independently from the data subvolume (see <XREF LINKEND="LE99992-TITLE"> for an explanation of striping), you must use an external log.</PARA></LISTITEM>
<LISTITEM><PARA>If you are making the XFS filesystem on a disk partition (rather than on an XLV logical volume), you must use an internal log. </PARA>
</LISTITEM>
<LISTITEM><PARA>If you are making the XFS filesystem on an XLV logical volume that has no log subvolume, you must use an internal log.</PARA>
</LISTITEM>
<LISTITEM><PARA>If you are making the XFS filesystem on an XLV logical volume that has a log subvolume, you must use an external log.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>For more information about XLV and log subvolumes, see <XREF LINKEND="LE37920-TITLE">.</PARA><PARA><INDEXTERM ID="ITch6-16"><PRIMARY>logs</PRIMARY>
<SECONDARY>choosing size</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-17"><PRIMARY>disk space</PRIMARY>
<SECONDARY>for logs</SECONDARY>
</INDEXTERM>
The amount of disk space needed for the log is a function of how the filesystem is used. The amount of disk space required for log records is proportional to the transaction rate and the size of transactions on the filesystem, not the size of the filesystem. Larger&nbsp;block&nbsp;sizes result in larger transactions. Transactions from directory updates (for example, the <COMMAND>mkdir</COMMAND> and <COMMAND>rmdir</COMMAND> commands and the <COMMAND>create()</COMMAND> and <COMMAND>unlink()</COMMAND> system calls) cause more log data to be generated. </PARA>
<PARA><INDEXTERM ID="ITch6-18"><PRIMARY>log size</PRIMARY>
</INDEXTERM>
You can choose the amount of disk space to dedicate to the log (called the log size).The minimum log size for a filesystem will depend on the combination of filesystem block size and directory block size. The default log size that the <COMMAND>mkfs </COMMAND>command yields, which is larger than the minimum log size, also depends on the filesystem block size and the directory block size.</PARA>
<PARA>For filesystems with a very high transaction activity, a large log size is recommended.</PARA>
<PARA>For a filesystem which is contained in a XLV striped logical volume, the default internal log size is rounded up to a multiple of the stripe unit size. In this case, the user-specified size value must be a multiple of the stripe unit size. </PARA>
<PARA><INDEXTERM ID="ITch6-19"><PRIMARY>logs</PRIMARY>
<SECONDARY>external, specifying size</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-20"><PRIMARY>external logs</PRIMARY>
<SECONDARY>size</SECONDARY>
</INDEXTERM>
For external logs, the size of the log is the same as the size of the log subvolume. The log subvolume is one or more disk partitions. You may find that you need to repartition a disk to create a properly sized log subvolume (see the section <XREF LINKEND="LE69866-PARENT">). For external logs, the size of the log is set when you create the log subvolume with the <COMMAND>xlv_make</COMMAND> command.</PARA>
<PARA><INDEXTERM ID="ITch6-21"><PRIMARY>logs</PRIMARY>
<SECONDARY>internal, specifying size</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-22"><PRIMARY>internal logs</PRIMARY>
<SECONDARY>size</SECONDARY>
</INDEXTERM>
For internal logs, the size of the log is specified when you create the filesystem with the <COMMAND>mkfs</COMMAND> command.</PARA>
<PARA>The maximum log size is 64k blocks or 128 MB, whichever is smaller (this will depend on the block size). You should avoid making your log too large, since a large log can increase filesystem mount time after a crash.</PARA>
<PARA><INDEXTERM ID="ITch6-23"><PRIMARY>logs</PRIMARY>
<SECONDARY>size syntax</SECONDARY>
</INDEXTERM>
The log size is specified in bytes as described in <XREF LINKEND="LE45044-PARENT">, or as a multiple of the filesystem block size by using the suffix&nbsp;&ldquo;b.&rdquo;</PARA></SECTION>
<SECTION  ID="LE38053-PARENT"><TITLE  ID="LE38053-TITLE">Choosing Allocation Groups and Stripe Units</TITLE><PARA><INDEXTERM ID="ITch6-24"><PRIMARY>allocation groups</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-25"><PRIMARY>XFS filesystem</PRIMARY>
<SECONDARY>allocation groups</SECONDARY>
</INDEXTERM>
The data section of an XFS filesystem is divided into allocation groups. You can select the number of allocation groups when you create an XFS filesystem. The larger the number of allocation groups, the more parallelism can be achieved when allocating blocks and inodes. You should avoid selecting a very large number of allocation groups, however, since this causes an unreasonable amount of CPU time to be used when the filesystem is close to full.</PARA>
<PARA>The minimum allocation group size is 16MB; the maximum size is just under 4 GB.</PARA>
<PARA>The default number of allocation groups is 8, unless the filesystem is smaller than 128 MB or larger than 8 GB. When the filesystem is smaller than 128 MB, the default number of allocation groups is less than 8, since the minimum allocation group size is 16MB. In this case, the data section, by default, will be divided into as many allocation groups as possible that are at least 16MB. When the filesystem is larger than 8GB, the default number of allocation groups is greater than 8, with each allocation group approximately 1 GB in size. </PARA>
<PARA><INDEXTERM ID="ITch6-26"><PRIMARY>stripe unit</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-27"><PRIMARY>XFS filesystem</PRIMARY>
<SECONDARY>stripe unit</SECONDARY>
</INDEXTERM>
XFS allows you to select the stripe unit for a RAID device or xlv stripe volume. This ensures that data allocations, inode allocations, and the internal log will be aligned along stripe units when the end of file is extended and the file size is larger than 512KB. You specify stripe units in 512-byte block units.</PARA>
<PARA>When you specify a stripe unit, you also specify a stripe width. You specify a stripe width in 512-byte block units. The stripe width must be a multiple of the stripe unit. The stripe width will be the preferred I/O size returned in the <COMMAND>stat()</COMMAND> system call. For a RAID device, the default stripe unit is 0, indicating that the feature is disabled. For a striped XLV volume, the stripe unit that was specified when the XLV volume was created is provided by default.</PARA>
<PARA>For information on what to consider when choosing a stripe unit size, see <XREF LINKEND="LE37069-TITLE"> in <XREF LINKEND="LE37920-TITLE">.</PARA></SECTION>
<SECTION  ID="LE69866-PARENT"><TITLE  ID="LE69866-TITLE">Disk Repartitioning</TITLE><PARA><INDEXTERM ID="ITch6-28"><PRIMARY>disk partitions</PRIMARY>
<SECONDARY>planning</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-29"><PRIMARY>disk partitions</PRIMARY>
<SECONDARY>repartitioning</SECONDARY>
</INDEXTERM>
Many system administrators may find that they want or need to repartition disks when they switch to XFS filesystems and/or XLV logical volumes. Some of the reasons to consider repartitioning are:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA>If the system disk has separate partitions for root and <FILENAME>usr</FILENAME> filesystems, the root filesystem may be running out of space. Repartitioning is a way to increase the space in root (at the expense of the size of <FILENAME>usr</FILENAME>) or to solve the problem by combining root and <FILENAME>usr</FILENAME> into a single partition.</PARA>
</LISTITEM>
<LISTITEM><PARA>System administration is a little easier on systems with combined root and <FILENAME>usr</FILENAME> filesystems.</PARA>
</LISTITEM>
<LISTITEM><PARA>If you plan to use XLV logical volumes, you may want to put the XFS log into a small subvolume. This requires disk repartitioning to create a small partition for the log subvolume.</PARA>
</LISTITEM>
<LISTITEM><PARA>If you plan to use XLV logical volumes, you may want to repartition to create disk partitions of equal size that can be striped or plexed.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>Disk partitions are discussed in <XREF LINKEND="LE50945-TITLE">. Using <COMMAND>fx</COMMAND> to repartition disks is explained in <XREF LINKEND="LE38803-PARENT">.</PARA></SECTION>
</SECTION>
<SECTION  ID="LE72328-PARENT"><TITLE  ID="LE72328-TITLE">Making an XFS Filesystem</TITLE><PARA><INDEXTERM ID="ITch6-30"><PRIMARY>XFS filesystems</PRIMARY>
<SECONDARY>filesystem on a new disk partition</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-31"><PRIMARY>XFS filesystems</PRIMARY>
<SECONDARY>making filesystems</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-32"><PRIMARY>disk partitions</PRIMARY>
<SECONDARY>making an XFS filesystem</SECONDARY>
</INDEXTERM>
This section explains how to create an XFS filesystem on an empty disk partition or XLV logical volume. (For information about creating XLV logical volumes, see <XREF LINKEND="LE38992-TITLE">.)</PARA><TIP><PARA><INDEXTERM ID="ITch6-33"><PRIMARY><COMMAND>xfsm</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>creating an XFS filesystem</COMMAND>
</SECONDARY>
</INDEXTERM>
You can make an XFS filesystem on a disk partition or a logical volume using the graphical user interface of the <COMMAND>xfsm</COMMAND> command. For information, see its online help.</PARA>
</TIP>
<CAUTION><PARA>When you create a filesystem, all files already on the disk partition or logical volume are destroyed.</PARA>
</CAUTION>
<ORDEREDLIST><LISTITEM><PARA>Review <XREF LINKEND="LE82948-PARENT"> to verify that you are ready to begin this procedure. </PARA></LISTITEM>
<LISTITEM><PARA>Identify the device name of the partition or logical volume where you plan to create the filesystem. This is the value of <REPLACEABLE>partition</REPLACEABLE> in the examples below. For example, if you plan to use partition 7 (the entire disk) of a SCSI option disk on controller 0 and drive address 2, <REPLACEABLE>partition</REPLACEABLE> is <FILENAME>/dev/dsk/dks0d2s7</FILENAME>. For more information on determining <REPLACEABLE>partition</REPLACEABLE>, see <XREF LINKEND="LE99643-TITLE">, <XREF LINKEND="LE22348-PARENT">, and the <COMMAND>dks</COMMAND>(7M) reference page.</PARA>
</LISTITEM>
<LISTITEM><PARA>If the disk partition is already mounted, unmount it:</PARA>
<PROGRAMLISTING>
# <USERINPUT>umount </USERINPUT><REPLACEABLE>partition</REPLACEABLE>
</PROGRAMLISTING>
<PARA>Any data that is on the disk partition is destroyed. To convert the data rather than destroy it, use the procedure in <XREF LINKEND="LE96722-PARENT"> instead.</PARA></LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch6-34"><PRIMARY><COMMAND>mkfs</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>command line syntax</COMMAND>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-35"><PRIMARY>block sizes</PRIMARY>
<SECONDARY>and <COMMAND>mkfs</COMMAND>
</SECONDARY>
</INDEXTERM>
If you are making a filesystem on a disk partition or on an XLV logical volume that does not have a log subvolume and want to use the default values for block size and log size, use this <COMMAND>mkfs</COMMAND> command to create the new XFS filesystem:</PARA>
<PROGRAMLISTING>
# <USERINPUT>mkfs</USERINPUT>&ensp;<REPLACEABLE>partition</REPLACEABLE>
</PROGRAMLISTING>
<PARA><XREF LINKEND="LE49308-TITLE"> shows the command line to create an XFS filesystem using the defaults and system output.</PARA><EXAMPLE  ID="LE49308-PARENT"><TITLE  ID="LE49308-TITLE">mkfs Command for an XFS Filesystem Using Defaults<INDEXTERM ID="ITch6-36"><PRIMARY><COMMAND>mkfs</COMMAND> command</PRIMARY><SECONDARY><COMMAND>example output</COMMAND></SECONDARY></INDEXTERM></TITLE><PROGRAMLISTING WIDTH="wide">
# <USERINPUT>mkfs /dev/dsk/dks1d2s7</USERINPUT>
meta-data=/dev/dsk/dks1d2s7      isize=256    agcount=8, agsize=138692 blks
data     =                       bsize=4096   blocks=1109531, imaxpct=25
&ensp;        =                       sunit=0      swidth=0 blks, unwritten=1
naming   =version 1              bsize=4096
log      =internal log           bsize=4096   blocks=1168
realtime =none                   extsz=65536  blocks=0, rtextents=0
</PROGRAMLISTING>
</EXAMPLE>
</LISTITEM>
<LISTITEM><PARA>If you are making a filesystem on a disk partition or on an XLV logical volume that does not have a log subvolume and want to specify the block size and log size, use this <COMMAND>mkfs</COMMAND> command to create the new XFS filesystem:</PARA>
<PROGRAMLISTING>
# <USERINPUT>mkfs -b size=</USERINPUT><REPLACEABLE>blocksize</REPLACEABLE><USERINPUT>&ensp;-l size=</USERINPUT><REPLACEABLE>logsize</REPLACEABLE><REPLACEABLE>&ensp;partition</REPLACEABLE>&ensp;
</PROGRAMLISTING>
<PARA><REPLACEABLE>blocksize</REPLACEABLE> is the filesystem block size (see <XREF LINKEND="LE45044-PARENT">) and <REPLACEABLE>logsize</REPLACEABLE> is the size of the area dedicated to log records (see <XREF LINKEND="LE93345-PARENT">). The default values are 4 KB blocks and a 1000-block log.</PARA><PARA><INDEXTERM ID="ITch6-37"><PRIMARY>internal logs</PRIMARY>
<SECONDARY>creating with <COMMAND>mkfs</COMMAND>
, example</SECONDARY>
</INDEXTERM>
<XREF LINKEND="LE29798-TITLE"> shows the command line used to create an XFS filesystem and the system output. The filesystem has a 10 MB internal log and a block size of 1 KB and is on the partition <FILENAME>/dev/dsk/dks1d2s7</FILENAME>.</PARA>
<EXAMPLE  ID="LE29798-PARENT"><TITLE  ID="LE29798-TITLE">mkfs Command for an XFS Filesystem With an Internal Log</TITLE><PROGRAMLISTING WIDTH="wide">
# <USERINPUT>mkfs -b size=1k -l size=10m /dev/dsk/dks1d2s7</USERINPUT>&ensp;
meta-data=/dev/dsk/dks1d2s7      isize=256    agcount=8, agsize=554766 blks
data     =                       bsize=1024   blocks=4438127, imaxpct=25
&ensp;        =                       sunit=0      swidth=0 blks, unwritten=1
naming   =version 1              bsize=1024		
log      =internal log           bsize=1024   blocks=10240
realtime =none                   extsz=65536  blocks=0, rtextents=0
</PROGRAMLISTING>
</EXAMPLE>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch6-38"><PRIMARY><COMMAND>mkfs</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>command line syntax</COMMAND>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-39"><PRIMARY>external logs</PRIMARY>
<SECONDARY>creating with <COMMAND>mkfs</COMMAND>
, example</SECONDARY>
</INDEXTERM>
If you are making a filesystem on an XLV logical volume that has a log subvolume (for an external log), use this <COMMAND>mkfs</COMMAND> command to make the new XFS filesystem:</PARA>
<PROGRAMLISTING>
# <USERINPUT>mkfs -b size=</USERINPUT><REPLACEABLE>blocksize</REPLACEABLE>&ensp;<REPLACEABLE>volume</REPLACEABLE>&ensp;
</PROGRAMLISTING>
<PARA><REPLACEABLE>blocksize</REPLACEABLE> is the block size for filesystem (see <XREF LINKEND="LE45044-PARENT">), and <REPLACEABLE>volume</REPLACEABLE> is the device name for the volume.</PARA>
<PARA><XREF LINKEND="LE25637-TITLE"> shows the command line used to create an XFS filesystem on a logical volume <FILENAME>/dev/xlv/a</FILENAME> with a block size of 1K bytes and the system output.</PARA>
<EXAMPLE  ID="LE25637-PARENT"><TITLE  ID="LE25637-TITLE">mkfs Command for an XFS Filesystem With an External Log<INDEXTERM ID="ITch6-40"><PRIMARY><COMMAND>mkfs</COMMAND> command</PRIMARY><SECONDARY><COMMAND>example output</COMMAND></SECONDARY></INDEXTERM></TITLE><PROGRAMLISTING WIDTH="wide">
# <USERINPUT>mkfs -b size=1k /dev/xlv/a</USERINPUT>&ensp;
meta-data=/dev/xlv/a             isize=256    agcount=8, agsize=550521 blks
data     =                       bsize=1024   blocks=4404163, imaxpct=25
&ensp;        =                       sunit=0      swidth=0 blks, unwritten=1
naming   =version 1              bsize=1024		
log      =volume log             bsize=1024   blocks=1000
realtime =none                   extsz=65536  blocks=0, rtextents=0
</PROGRAMLISTING>
</EXAMPLE>
<PARA><XREF LINKEND="LE35441-TITLE"> shows the command line used to create an XFS filesystem on a logical volume <FILENAME>/dev/xlv/xlv_data1</FILENAME> that includes a log, data, and real-time subvolumes and the system output. The default block size of 4096 bytes is used and the real-time extent size is set to 128 KB.</PARA>
<EXAMPLE  ID="LE35441-PARENT"><TITLE  ID="LE35441-TITLE">mkfs Command for an XFS Filesystem With a Real-Time Subvolume</TITLE><PROGRAMLISTING WIDTH="wide">
# <USERINPUT>mkfs -r extsize=128k /dev/rxlv/xlv_data1</USERINPUT>&ensp;
meta-data=/dev/rxlv/xlv_data1    isize=256    agcount=8, agsize=137536 blks
data     =                       bsize=4096   blocks=1100256, imaxpct=25
&ensp;        =                       sunit=16     swidth=32blks, unwritten=1
naming   =version 1              bsize=4096		
log      =volume log             bsize=4096   blocks=2560
realtime =volume rt              extsz=131072 blocks=1101824, rtextents=34432
</PROGRAMLISTING>
</EXAMPLE>
</LISTITEM>
<LISTITEM><PARA>If you are making a filesystem with a version 2 directory format with a directory block size that is larger than the filesystem block size, use this <COMMAND>mkfs</COMMAND> command to create the new XFS filesystem:</PARA>
<PROGRAMLISTING>
# <USERINPUT>mkfs -b size=</USERINPUT><REPLACEABLE>blocksize</REPLACEABLE><USERINPUT>&ensp;-n size=</USERINPUT><REPLACEABLE>dirblocksize</REPLACEABLE><REPLACEABLE>&ensp;partition</REPLACEABLE>&ensp;
</PROGRAMLISTING>
<PARA><REPLACEABLE>blocksize</REPLACEABLE> is the filesystem block size (see <XREF LINKEND="LE45044-PARENT">) and <REPLACEABLE>dirblocksize</REPLACEABLE> is the directory block size (see <XREF LINKEND="LE30568-PARENT">).</PARA><PARA><XREF LINKEND="LE13176-TITLE"> shows the command line used to create an XFS filesystem and the system output. The filesystem has a 512-byte filesystem block and a 4K directory block and is on the partition <FILENAME>/dev/dsk/dks1d2s7</FILENAME>. You might use this filesystem to store mail or news files.</PARA>
<EXAMPLE  ID="LE13176-PARENT"><TITLE  ID="LE13176-TITLE">mkfs Command for an XFS Filesystem Specifying Directory Block Size</TITLE><PROGRAMLISTING WIDTH="wide">
# <USERINPUT>mkfs -b size=512 -n version=2 size=4k /dev/dsk/dks1d2s7</USERINPUT>
meta-data=/dev/dsk/dks1d2s7      isize=256    agcount=8, agsize=1109532 blks
data     =                       bsize=512    blocks=8876255, imaxpct=25
&ensp;        =                       sunit=0      swidth=0 blks, unwritten=1
naming   =version 2              bsize=4096
log      =internal log           bsize=512    blocks=5440
realtime =none                   extsz=65536  blocks=0, rtextents=0
</PROGRAMLISTING>
</EXAMPLE>
</LISTITEM>
<LISTITEM><PARA>To use the filesystem, you must mount it. For example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>mkdir </USERINPUT><REPLACEABLE>mountdir</REPLACEABLE>&ensp;
# <USERINPUT>mount </USERINPUT><REPLACEABLE>partition</REPLACEABLE>&ensp;<REPLACEABLE>mountdir</REPLACEABLE>&ensp;
</PROGRAMLISTING>
<PARA>For more information about mounting filesystems, see <XREF LINKEND="LE73128-TITLE">.</PARA></LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch6-41"><PRIMARY><FILENAME>/etc/fstab</FILENAME>
 file</PRIMARY>
<SECONDARY><FILENAME>entries for filesystems</FILENAME>
</SECONDARY>
</INDEXTERM>
To configure the system so that the new filesystem is automatically mounted when the system is booted, add this line to the file <FILENAME>/etc/fstab</FILENAME>:</PARA>
<PROGRAMLISTING>
<REPLACEABLE>partition</REPLACEABLE>&ensp;<REPLACEABLE>mountdir</REPLACEABLE> xfs rw,raw<USERINPUT>=</USERINPUT><REPLACEABLE>rawpartition</REPLACEABLE> 0 0
</PROGRAMLISTING>
<PARA>where <REPLACEABLE>rawpartition</REPLACEABLE> is the raw version of <REPLACEABLE>partition</REPLACEABLE>. For example, if <REPLACEABLE>partition</REPLACEABLE> is <FILENAME>/dev/dsk/dks0d2s7</FILENAME>, <REPLACEABLE>rawpartition</REPLACEABLE> is <FILENAME>/dev/rdsk/dks0d2s7</FILENAME>.</PARA>
<PARA>For more information about automatically mounting filesystems, see the section <XREF LINKEND="LE47138-TITLE">.</PARA></LISTITEM>
</ORDEREDLIST>
</SECTION>
<SECTION  ID="LE67358-PARENT"><TITLE  ID="LE67358-TITLE">Making a Filesystem From inst</TITLE><CAUTION><PARA>When you create a filesystem, all files already on the disk partition or logical volume are destroyed.</PARA>
</CAUTION>
<PARA><COMMAND>mkfs</COMMAND> can be used from within the <COMMAND>inst</COMMAND> command to make filesystems. To make the root or <FILENAME>usr</FILENAME> filesystem on a system disk, you must use <COMMAND>inst</COMMAND> from the miniroot. There are two ways to use <COMMAND>mkfs</COMMAND>:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA>The <COMMAND>mkfs</COMMAND> command on the Administrative Command Menu. The <COMMAND>mkfs</COMMAND> command makes an XFS filesystem and uses default values for the <COMMAND>mkfs</COMMAND> command options. With no argument, the <COMMAND>mkfs</COMMAND> command makes the root filesystem, and if a <FILENAME>usr</FILENAME> partition is present, a <FILENAME>usr</FILENAME> filesystem. Other filesystems can be made by giving a device file argument to <COMMAND>mkfs</COMMAND>.</PARA>
</LISTITEM>
<LISTITEM><PARA>From a shell. Giving the <COMMAND>mkfs</COMMAND> command from a shell (give the command <COMMAND>sh</COMMAND>, not <COMMAND>shroot</COMMAND>) enables you to specify the <COMMAND>mkfs</COMMAND> command line, including options.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>For more information about making filesystems from <COMMAND>inst</COMMAND>, see <LINK BOOK="IA_InstLicns" EXTREF="29804">IRIX Admin: Software Installation and Licensing</LINK>
.</PARA>
</SECTION>
<SECTION  ID="LE12464-PARENT"><TITLE  ID="LE12464-TITLE">Making a Foreign Filesystem</TITLE><PARA><INDEXTERM ID="ITch6-42"><PRIMARY>foreign filesystems</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-43"><PRIMARY>filesystems</PRIMARY>
<SECONDARY>foreign filesystems</SECONDARY>
</INDEXTERM>
Under the IRIX operating system, you can use the <COMMAND>mkfp</COMMAND> command to create <FILENAME>hfs</FILENAME> (<FILENAME>mac</FILENAME>) and <FILENAME>dos</FILENAME> (<FILENAME>fat</FILENAME>) filesystems on devices such as floppies, floptical disks, SyQuest, Jaz, PC Cards, Zip, magneto-optical and hard drives.</PARA>
<PARA>The <COMMAND>mkfp</COMMAND> utility can create single <FILENAME>dos</FILENAME> partitions on floppies and floptical disks as well as multiple <FILENAME>dos</FILENAME> partitions on other forms of media. However, the <COMMAND>mkfp</COMMAND> utility can create only single <FILENAME>hfs</FILENAME> partitions spanning entire disks. You cannot use the <COMMAND>mkfp</COMMAND> utility to manipulate existing partitions on disk.</PARA>
<PARA>For information on using the <COMMAND>mkfp</COMMAND> utility, see the <COMMAND>mkfp</COMMAND>(1M) reference page. For further information on foreign filesystem types, see the <COMMAND>filesystems</COMMAND>(4) reference page. For information on checking and repairing foreign filesystems, see the <COMMAND>fpck</COMMAND>(1M) reference page.</PARA>
<NOTE><PARA>If you have trouble creating a filesystem with <COMMAND>mkfp</COMMAND> on your system, you may need to use the filesystem creation utilities of the filesystem's native platform. </PARA>
</NOTE>
</SECTION>
<SECTION  ID="LE49326-PARENT"><TITLE  ID="LE49326-TITLE">Growing an XFS Filesystem Onto Another Disk</TITLE><PARA>The procedure in this section explains how to grow an XFS filesystem onto another disk. <INDEXTERM ID="ITch6-44"><PRIMARY>XLV logical volumes</PRIMARY>
<SECONDARY>creating out of old and new disks</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-45"><PRIMARY><FILENAME>xlv_make</FILENAME>
 command</PRIMARY>
<SECONDARY><FILENAME>using to create a logical volume for an existing filesystem</FILENAME>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-46"><PRIMARY><COMMAND>xfs_growfs</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>extending a filesystem onto a logical volume</COMMAND>
</SECONDARY>
</INDEXTERM>
When growing an XFS filesystem onto another disk, there are two possibilities:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA>The XFS filesystem is on a disk partition.</PARA>
</LISTITEM>
<LISTITEM><PARA>The XFS filesystem is on an XLV logical volume.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>If the XFS filesystem is on an XLV logical volume, the additional disk can be added to the logical volume as an additional volume element. Instructions for doing this are in the section <XREF LINKEND="LE10328-TITLE">.</PARA><PARA>The following steps show how to grow a filesystem mounted at <FILENAME>/disk2</FILENAME> onto an XLV logical volume created out of the <FILENAME>/disk2</FILENAME> disk partition and a new disk. The procedure assumes that the new disk is installed on the system and partitioned.</PARA>
<CAUTION><PARA>All files on the additional disk are destroyed by this procedure.</PARA>
</CAUTION>
<ORDEREDLIST><LISTITEM><PARA>Make a backup of the filesystem you are going to extend. </PARA>
</LISTITEM>
<LISTITEM><PARA>Unmount the <FILENAME>/disk2</FILENAME> filesystem:</PARA>
<PROGRAMLISTING>
# <USERINPUT>umount /disk2</USERINPUT>&ensp;
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Use <COMMAND>xlv_make</COMMAND> to create an XLV logical volume out of the <FILENAME>/disk2</FILENAME> partition and the new disk. The <FILENAME>/disk2</FILENAME> partition must be the first volume element in the data subvolume. For example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_make</USERINPUT>
xlv_make&gt; <USERINPUT>vol xlv0</USERINPUT>
xlv0
xlv_make&gt; <USERINPUT>data</USERINPUT>
xlv0.data
xlv_make&gt; <USERINPUT>plex</USERINPUT>
xlv0.data.0
xlv_make&gt; <USERINPUT>ve dks0d2s7</USERINPUT>
xlv0.data.0.0
xlv_make&gt; <USERINPUT>ve dks0d3s7</USERINPUT>
xlv0.data.0.1
xlv_make&gt; <USERINPUT>end</USERINPUT>
Object specification completed
xlv_make&gt; <USERINPUT>exit</USERINPUT>
Newly created objects will be written to disk.
Is this what you want?(yes) <USERINPUT>yes</USERINPUT>
Invoking xlv_assemble
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Mount the <FILENAME>/disk2</FILENAME> filesystem:</PARA>
<PROGRAMLISTING>
# <USERINPUT>mount /dev/xlv/xlv0 /disk2</USERINPUT>&ensp;
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Grow the XFS filesystem into the logical volume with the <COMMAND>xfs_growfs</COMMAND> command:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xfs_growfs /disk2</USERINPUT>&ensp;
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Change the entry for <FILENAME>/disk2</FILENAME> in the file <FILENAME>/etc/fstab</FILENAME> to mount the logical volume rather than the disk partition:</PARA>
<PROGRAMLISTING>
/dev/xlv/xlv0 /disk2 xfs rw,raw=/dev/rxlv/xlv0 0 0 
</PROGRAMLISTING>
<PARA>Growing the filesystem is complete.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECTION>
<SECTION  ID="LE72401-PARENT"><TITLE  ID="LE72401-TITLE">Converting Filesystems on the System Disk From EFS to XFS</TITLE><CAUTION><PARA>The procedure in this section can result in the loss of data if it is not performed properly. It is recommended only for experienced IRIX system administrators.</PARA>
</CAUTION>
<PARA><INDEXTERM ID="ITch6-47"><PRIMARY>XFS filesystems</PRIMARY>
<SECONDARY>on system disk</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-48"><PRIMARY>root filesystem</PRIMARY>
<SECONDARY>converting to XFS</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-49"><PRIMARY><FILENAME>usr</FILENAME>
 filesystem</PRIMARY>
<SECONDARY><FILENAME>converting to XFS</FILENAME>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-50"><PRIMARY>XFS filesystems</PRIMARY>
<SECONDARY>converting a system disk</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-51"><PRIMARY>root partition</PRIMARY>
<SECONDARY>converting to XFS</SECONDARY>
</INDEXTERM>
This section explains the procedure for converting filesystems on the system disk from EFS to XFS. Some systems have two filesystems on the system disk, the root filesystem (mounted at <FILENAME>/</FILENAME>) and the <FILENAME>usr</FILENAME> filesystem (mounted at <FILENAME>/usr</FILENAME>). Other systems have a single, combined root and <FILENAME>usr</FILENAME> filesystem mounted at <FILENAME>/</FILENAME>. This procedure covers both cases but assumes that XLV logical volumes are not used on the system disk. The basic procedure for converting a system disk is as follows:</PARA>
<ORDEREDLIST><LISTITEM><PARA>Load the miniroot.</PARA>
</LISTITEM>
<LISTITEM><PARA>Do a complete dump of filesystems on the system disk.</PARA>
</LISTITEM>
<LISTITEM><PARA>Repartition the system disk if necessary.</PARA>
</LISTITEM>
<LISTITEM><PARA>Create one or two new, empty XFS filesystems.</PARA>
</LISTITEM>
<LISTITEM><PARA>Restore the files from the filesystem dumps.</PARA>
</LISTITEM>
<LISTITEM><PARA>Reboot the system.</PARA>
</LISTITEM>
</ORDEREDLIST>
<PARA>During this procedure, you can repartition the system disk if necessary. For example, you can convert from separate root and <FILENAME>usr</FILENAME> filesystems to a single, combined filesystem, or you can resize partitions to make the root partition larger and the <FILENAME>usr</FILENAME> partition smaller. See <XREF LINKEND="LE69866-PARENT"> for more information.</PARA><PARA>The early steps of this procedure ask you to identify the values of various variables, which are used later in the procedure. You may find it helpful to make a list of the variables and values for later reference. Be sure to perform only the steps that apply to your situation. Perform all steps as superuser.</PARA>
<CAUTION><PARA>It is very important to follow this procedure as documented without giving additional <COMMAND>inst</COMMAND> or shell commands. Unfortunately, deviations from this procedure, even changing to a different directory or going from the <COMMAND>inst</COMMAND> shell to an <COMMAND>inst</COMMAND> menu when not directed to do so, can have very severe consequences from which recovery is difficult.</PARA>
</CAUTION>
<ORDEREDLIST><LISTITEM><PARA>Review <XREF LINKEND="LE82948-PARENT"> to verify that you are ready to begin this procedure.</PARA></LISTITEM>
<LISTITEM><PARA>Verify that your backups are up to date. Because this procedure temporarily removes all files from your system disk, it is important that you have a complete set of backups that have been prepared using your normal backup procedures. You will make a complete dump of the system disk starting at step 11<!-- This hardcoded numeric reference should be updated. -->, but you should have your usual backups in addition to the backup made during this procedure.</PARA>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch6-52"><PRIMARY>disk partitions</PRIMARY>
<SECONDARY>device names</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-53"><PRIMARY><COMMAND>devnm</COMMAND>
 command</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-54"><PRIMARY>device names</PRIMARY>
<SECONDARY>identifying with <COMMAND>devnm</COMMAND>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-55"><PRIMARY>root partition</PRIMARY>
<SECONDARY>device name</SECONDARY>
</INDEXTERM>
Use <COMMAND>devnm</COMMAND> to get the device name of the root disk partition, <REPLACEABLE>rootpartition</REPLACEABLE>. For example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>devnm /</USERINPUT>
/dev/dsk/dks0d1s0 /
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch6-56"><PRIMARY><FILENAME>usr</FILENAME>
 partition</PRIMARY>
<SECONDARY><FILENAME>device name</FILENAME>
</SECONDARY>
</INDEXTERM>
If the system disk has separate root and <FILENAME>usr</FILENAME> filesystems, use <COMMAND>devnm</COMMAND> to figure out the device name of the <FILENAME>usr</FILENAME> partition, <REPLACEABLE>usrpartition</REPLACEABLE>:</PARA>
<PROGRAMLISTING>
# <USERINPUT>devnm /usr</USERINPUT>
/dev/dsk/dks0d1s6 /usr
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch6-57"><PRIMARY>device names</PRIMARY>
<SECONDARY>tape drive</SECONDARY>
</INDEXTERM>
If you are using a tape drive as the backup device, use <COMMAND>hinv</COMMAND> to get the controller and unit numbers (<REPLACEABLE>tapecntlr</REPLACEABLE> and <REPLACEABLE>tapeunit</REPLACEABLE>) of the tape drive. For example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>hinv -c tape</USERINPUT>
Tape drive: unit 2 on SCSI controller 0: DAT
</PROGRAMLISTING>
<PARA>In this example, <REPLACEABLE>tapecntlr</REPLACEABLE> is 0 and <REPLACEABLE>tapeunit</REPLACEABLE> is 2.</PARA>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch6-58"><PRIMARY>device names</PRIMARY>
<SECONDARY>disk for <COMMAND>dump</COMMAND>
 file</SECONDARY>
</INDEXTERM>
If you are using a disk drive as your backup device, use <COMMAND>df </COMMAND>to get the device name (<REPLACEABLE>backupdevice</REPLACEABLE>) and mount point (<REPLACEABLE>backupfs</REPLACEABLE>) of the partition that contains the filesystem where you plan to put the backup. For example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>df</USERINPUT>
Filesystem             Type  blocks     use   avail %use  Mounted on
/dev/root               efs 1992630  538378 1454252  27%  /
/dev/dsk/dks0d3s7       efs 3826812 1559740 2267072  41%  /disk3
/dev/dsk/dks0d2s7       efs 2004550      23 2004527   0%  /disk2
</PROGRAMLISTING>
<PARA>The filesystem mounted at <FILENAME>/disk2</FILENAME> has plenty of disk space for a backup of the system disk (/ uses 538,378 blocks, and <FILENAME>/disk2</FILENAME> has 2,004,527 blocks available). The <REPLACEABLE>backupdevice</REPLACEABLE> for <FILENAME>/disk2</FILENAME> is <FILENAME>/dev/dsk/dks0d2s7</FILENAME> and the <REPLACEABLE>backupfs</REPLACEABLE> is <FILENAME>/disk2</FILENAME>.</PARA>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch6-59"><PRIMARY><FILENAME>/etc/fstab</FILENAME>
 file</PRIMARY>
<SECONDARY><FILENAME>entries for system disk</FILENAME>
</SECONDARY>
</INDEXTERM>
Create a temporary copy of <FILENAME>/etc/fstab</FILENAME> called <FILENAME>/etc/fstab.xfs </FILENAME>and edit it with your favorite editor. For example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>cp /etc/fstab /etc/fstab.xfs</USERINPUT>
# <USERINPUT>vi /etc/fstab.xfs</USERINPUT>
</PROGRAMLISTING>
<PARA>Make these changes in <FILENAME>/etc/fstab.xfs</FILENAME>:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA>Replace <LITERAL>efs</LITERAL> with <LITERAL>xfs</LITERAL> in the line for the root filesystem, /, if there is a line for the root filesystem.</PARA>
</LISTITEM>
<LISTITEM><PARA>If there is no line for the root filesystem, add this line:</PARA>
<PROGRAMLISTING>
/dev/root   /   xfs rw,raw=/dev/rroot 0 0
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>If root and <FILENAME>usr</FILENAME> are separate filesystems and will remain so, replace <LITERAL>efs</LITERAL> with <LITERAL>xfs</LITERAL> in the line for the <FILENAME>usr</FILENAME> filesystem.</PARA>
</LISTITEM>
<LISTITEM><PARA>If root and <FILENAME>usr</FILENAME> have been separate filesystems, but the disk will be repartitioned during the conversion procedure so that they are combined, remove the line for the <FILENAME>usr</FILENAME> filesystem.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</LISTITEM>
<LISTITEM><PARA>Shut down your workstation using the <COMMAND>shutdown</COMMAND> command or the System Shutdown item from the System Toolchest. Answer prompts as appropriate to get to the five-item System Maintenance Menu.</PARA>
</LISTITEM>
<LISTITEM><PARA>Bring up the miniroot from system software CDs or a software distribution directory.</PARA>
</LISTITEM>
<LISTITEM><PARA>Switch to the shell prompt in <COMMAND>inst</COMMAND>:</PARA>
<PROGRAMLISTING>
Inst&gt; <USERINPUT>sh</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch6-60"><PRIMARY><COMMAND>dump</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>commands used during conversion to XFS</COMMAND>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-61"><PRIMARY>root filesystem</PRIMARY>
<SECONDARY>dumping</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-62"><PRIMARY><FILENAME>usr</FILENAME>
 filesystem</PRIMARY>
<SECONDARY><FILENAME>dumping</FILENAME>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-63"><PRIMARY>backup and restore</PRIMARY>
<SECONDARY>during conversion to XFS</SECONDARY>
</INDEXTERM>
Create a full backup of the root filesystem by giving this command:</PARA>
<PROGRAMLISTING>
# <USERINPUT>/root/sbin/dump 0uCf</USERINPUT>&ensp;<REPLACEABLE>tapesize</REPLACEABLE>&ensp;<REPLACEABLE>dumpdevice</REPLACEABLE>&ensp;<REPLACEABLE>rootpartition</REPLACEABLE>&ensp;
</PROGRAMLISTING>
<PARA><REPLACEABLE>tapesize</REPLACEABLE> is the tape capacity (also used for backup to disks) and <REPLACEABLE>dumpdevice</REPLACEABLE> is the appropriate device name for the tape drive or the name of the file that will contain the dump image. <XREF LINKEND="LE53571-TITLE"> gives the values of <REPLACEABLE>tapesize</REPLACEABLE> and <REPLACEABLE>dumpdevice</REPLACEABLE> for different tape drives and disk. <REPLACEABLE>tapecntlr</REPLACEABLE> and <REPLACEABLE>tapeunit</REPLACEABLE> in <XREF LINKEND="LE53571-TITLE"> are <REPLACEABLE>tapecntlr</REPLACEABLE> and <REPLACEABLE>tapeunit</REPLACEABLE> from step 5<!-- This hardcoded numeric reference should be updated. --> in this section.</PARA>
<PARA>&ensp;</PARA>
<TABLE FRAME="topbot"><TBLTITLE  ID="LE53571-TITLE">dump Arguments for Filesystem Backup</TBLTITLE>
<TGROUP COLS="3">
<COLSPEC COLWIDTH="192*">
<COLSPEC COLWIDTH="86*">
<COLSPEC COLWIDTH="512*">
<THEAD><ROW><ENTRY><PARA>Backup Device</PARA></ENTRY>
<ENTRY><PARA><REPLACEABLE>tapesize</REPLACEABLE>&ensp;</PARA></ENTRY>
<ENTRY><PARA><REPLACEABLE>dumpdevice</REPLACEABLE>&ensp;</PARA></ENTRY>
</ROW>
</THEAD>
<TBODY><ROW><ENTRY><PARA>Disk</PARA></ENTRY>
<ENTRY><PARA>2m</PARA></ENTRY>
<ENTRY><PARA>Use <FILENAME>/root/<REPLACEABLE></REPLACEABLE><REPLACEABLE>backupfs</REPLACEABLE>
</FILENAME>
<FILENAME></FILENAME><FILENAME>/root.dump</FILENAME> for the root filesystem and 
<FILENAME>/root/<REPLACEABLE></REPLACEABLE><REPLACEABLE>backupfs</REPLACEABLE>
</FILENAME>
<FILENAME></FILENAME><FILENAME>/usr.dump</FILENAME> for the <FILENAME>usr</FILENAME> filesystem</PARA></ENTRY>
</ROW>
<ROW><ENTRY><PARA>DAT tape</PARA></ENTRY>
<ENTRY><PARA>2m</PARA></ENTRY>
<ENTRY><PARA><FILENAME>/dev/rmt/tps<REPLACEABLE></REPLACEABLE><REPLACEABLE>tapecntlr</REPLACEABLE>
</FILENAME>
<FILENAME></FILENAME><FILENAME>d<REPLACEABLE></REPLACEABLE><REPLACEABLE>tapeunit</REPLACEABLE>
</FILENAME>
<FILENAME></FILENAME><FILENAME>nsv</FILENAME>&ensp;</PARA></ENTRY>
</ROW>
<ROW><ENTRY><PARA>DLT tape</PARA></ENTRY>
<ENTRY><PARA>10m</PARA></ENTRY>
<ENTRY><PARA><FILENAME>/dev/rmt/tps<REPLACEABLE></REPLACEABLE><REPLACEABLE>tapecntlr</REPLACEABLE>
</FILENAME>
<FILENAME></FILENAME><FILENAME>d<REPLACEABLE></REPLACEABLE><REPLACEABLE>tapeunit</REPLACEABLE>
</FILENAME>
<FILENAME></FILENAME><FILENAME>nsv</FILENAME>&ensp;</PARA></ENTRY>
</ROW>
<ROW><ENTRY><PARA>EXABYTE 8mm 
model 8200 tape</PARA></ENTRY>
<ENTRY><PARA>2m</PARA></ENTRY>
<ENTRY><PARA><FILENAME>/dev/rmt/tps<REPLACEABLE></REPLACEABLE><REPLACEABLE>tapecntlr</REPLACEABLE>
</FILENAME>
<FILENAME></FILENAME><FILENAME>d<REPLACEABLE></REPLACEABLE><REPLACEABLE>tapeunit</REPLACEABLE>
</FILENAME>
<FILENAME></FILENAME><FILENAME>nsv</FILENAME>&ensp;</PARA></ENTRY>
</ROW>
<ROW><ENTRY><PARA>EXABYTE 8mm 
model 8500 tape</PARA></ENTRY>
<ENTRY><PARA>4m</PARA></ENTRY>
<ENTRY><PARA><FILENAME>/dev/rmt/tps<REPLACEABLE></REPLACEABLE><REPLACEABLE>tapecntlr</REPLACEABLE>
</FILENAME>
<FILENAME></FILENAME><FILENAME>d<REPLACEABLE></REPLACEABLE><REPLACEABLE>tapeunit</REPLACEABLE>
</FILENAME>
<FILENAME></FILENAME><FILENAME>nsv</FILENAME>&ensp;</PARA></ENTRY>
</ROW>
<ROW><ENTRY><PARA>QIC cartridge tape</PARA></ENTRY>
<ENTRY><PARA>150k</PARA></ENTRY>
<ENTRY><PARA><FILENAME>/dev/rmt/tps<REPLACEABLE></REPLACEABLE><REPLACEABLE>tapecntlr</REPLACEABLE>
</FILENAME>
<FILENAME></FILENAME><FILENAME>d<REPLACEABLE></REPLACEABLE><REPLACEABLE>tapeunit</REPLACEABLE>
</FILENAME>
<FILENAME></FILENAME><FILENAME>ns</FILENAME>&ensp;</PARA></ENTRY>
</ROW>
</TBODY>
</TGROUP>
</TABLE>
</LISTITEM>
<LISTITEM><PARA>If <FILENAME>usr</FILENAME> is a separate filesystem, insert a new tape (if you are using tape), and create a full backup of the <FILENAME>usr</FILENAME> filesystem by giving this command:</PARA>
<PROGRAMLISTING>
# <USERINPUT>/root/sbin/dump 0uCf</USERINPUT>&ensp;<REPLACEABLE>tapesize</REPLACEABLE>&ensp;<REPLACEABLE>dumpdevice</REPLACEABLE>&ensp;<REPLACEABLE>usrpartition</REPLACEABLE>&ensp;
</PROGRAMLISTING>
<PARA><REPLACEABLE>tapesize</REPLACEABLE> is the tape capacity (also used for backup to disks) and <REPLACEABLE>dumpdevice</REPLACEABLE> is the appropriate device name for the tape drive or the name of the file that will contain the dump image. <XREF LINKEND="LE53571-TITLE"> gives the values of <REPLACEABLE>tapesize</REPLACEABLE> and <REPLACEABLE>dumpdevice</REPLACEABLE> for different tape drives and disk.</PARA>
</LISTITEM>
<LISTITEM><PARA>Exit out of the shell:</PARA>
<PROGRAMLISTING>
# <USERINPUT>exit</USERINPUT>
...
Inst&gt;
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>If you do not need to repartition the system disk, skip to step 18<!-- This hardcoded numeric reference should be updated. -->.</PARA>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch6-64"><PRIMARY>disk partitions</PRIMARY>
<SECONDARY>repartitioning during conversion</SECONDARY>
</INDEXTERM>
To repartition the system disk, use the standalone version of <COMMAND>fx</COMMAND>. This version of <COMMAND>fx</COMMAND> is invoked from the Command Monitor, so you must bring up the Command Monitor. To do this, quit out of <COMMAND>inst</COMMAND>, reboot the system, shut down the system, then request the Command Monitor. An example of this procedure is:</PARA>
<PROGRAMLISTING WIDTH="wide">
Inst&gt; <USERINPUT>quit</USERINPUT>
...
Ready to restart the system.  Restart? { (y)es, (n)o, (sh)ell, (h)elp }: <USERINPUT>yes</USERINPUT>
...
login: <USERINPUT>root</USERINPUT>
# <USERINPUT>halt</USERINPUT>
...
System Maintenance Menu
...
Option? <USERINPUT>5</USERINPUT>
Command Monitor.  Type "exit" to return to the menu.
&gt;&gt;
</PROGRAMLISTING>
<PARA>On systems with a graphical System Maintenance Menu, choose the last option, Enter Command Monitor, instead of choosing option 5.</PARA>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch6-65"><PRIMARY><COMMAND>fx</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>using the standalone version</COMMAND>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-66"><PRIMARY>root partition</PRIMARY>
<SECONDARY>combining with <FILENAME>usr</FILENAME>
 partition</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-67"><PRIMARY><FILENAME>usr</FILENAME>
 partition</PRIMARY>
<SECONDARY><FILENAME>combining with root partition</FILENAME>
</SECONDARY>
</INDEXTERM>
Boot <COMMAND>fx</COMMAND> and repartition the system disk so that it meets your needs. The following example shows how to use <COMMAND>fx</COMMAND> to switch from separate root and <FILENAME>usr</FILENAME> partitions to a single root partition.</PARA>
<PROGRAMLISTING WIDTH="wide">
&gt;&gt; <USERINPUT>boot stand/fx</USERINPUT>
84032+11488+3024+331696+26176d+4088+6240 entry: 0x89f97610
114208+29264+19536+2817088+60880d+7192+11056 entry: 0x89cd31c0
Currently in safe read-only mode.
Do you require extended mode with all options available? (no) <USERINPUT>Enter</USERINPUT>
SGI Version 6.4 ARCS   Sep 29, 1996
fx: "device-name" = (dksc) <USERINPUT>Enter</USERINPUT>&ensp;
fx: ctlr# = (0) <USERINPUT>Enter</USERINPUT>
fx: drive# = (1) <USERINPUT>Enter</USERINPUT>
fx: lun# = (0)<USERINPUT>&ensp;Enter</USERINPUT>
...opening dksc(0,1,0)
...drive selftest...OK
Scsi drive type == SGI     SEAGATE ST31200N8640

----- please choose one (? for help, .. to quit this menu)-----
[exi]t             [d]ebug/           [l]abel/           [a]uto
[b]adblock/        [exe]rcise/        [r]epartition/     [f]ormat
fx&gt; <USERINPUT>repartition/rootdrive</USERINPUT>

fx/repartition/rootdrive: type of data partition = (xfs) <USERINPUT>Enter</USERINPUT>
Warning: you will need to re-install all software and restore user data
from backups after changing the partition layout.  Changing partitions
will cause all data on the drive to be lost.  Be sure you have the drive
backed up if it contains any user data.  Continue? <USERINPUT>yes</USERINPUT>

----- please choose one (? for help, .. to quit this menu)-----
[exi]t             [d]ebug/           [l]abel/           [a]uto
[b]adblock/        [exe]rcise/        [r]epartition/     [f]ormat
fx&gt; <USERINPUT>exit</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Load the miniroot again, using the same procedure you used in step 9<!-- This hardcoded numeric reference should be updated. -->.</PARA>
</LISTITEM>
<LISTITEM><PARA>Make an XFS filesystem for root:</PARA>
<PROGRAMLISTING WIDTH="wide">
Inst&gt; <USERINPUT>admin mkfs /dev/dsk/dks0d1s0</USERINPUT>
Unmounting device &ldquo;/dev/dsk/dks0d1s0&rdquo; from directory &ldquo;/root&rdquo;.

Make new file system on /dev/dsk/dks0d1s0 [yes/no/sh/help]: <USERINPUT>yes</USERINPUT>

About to remake (mkfs) file system on: /dev/dsk/dks0d1s0
This will destroy all data on disk partition: /dev/dsk/dks0d1s0.

&ensp;       Are you sure? [y/n] (n): <USERINPUT>y</USERINPUT>

&ensp;       Block size of filesystem 512 or 4096 bytes? <USERINPUT>4096</USERINPUT>

Doing: mkfs -b size=4096 /dev/dsk/dks0d1s0
meta-data=/dev/rdsk/dks0d1s0     isize=256    agcount=8, agsize=31021 blks
data     =                       bsize=4096   blocks=248165, imaxpact=25
&ensp;        =                       sunit=0      swidth=0 blks, unwritten=1
naming   =version 1              bsize=4096		
log      =internal log           bsize=4096   blocks=1168
realtime =none                   extsz=65536  blocks=0, rtextents=0
Mounting file systems:

NOTICE: Start mounting filesystem: /root
NOTICE: Ending clean XFS mount for filesystem: /root
&ensp;   /dev/miniroot            on  /
&ensp;   /dev/dsk/dks0d1s0        on  /root


Re-initializing installation history database
Reading installation history .. 100% Done.
Checking dependencies .. 100% Done.
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Switch to the shell prompt in <COMMAND>inst</COMMAND>:</PARA>
<PROGRAMLISTING>
Inst&gt; <USERINPUT>sh</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>If you made the backup on disk, create a mount point for the filesystem that contains the backup and mount it:</PARA>
<PROGRAMLISTING>
# <USERINPUT>mkdir</USERINPUT>&ensp;<USERINPUT>/</USERINPUT><REPLACEABLE>backupfs</REPLACEABLE>
#<USERINPUT>&ensp;mount</USERINPUT>&ensp;<REPLACEABLE>backupdevice</REPLACEABLE>&ensp;<USERINPUT>/</USERINPUT><REPLACEABLE>backupfs</REPLACEABLE>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch6-68"><PRIMARY><COMMAND>restore</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>commands used during conversion to XFS</COMMAND>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-69"><PRIMARY>root filesystem</PRIMARY>
<SECONDARY>restoring all files</SECONDARY>
</INDEXTERM>
If you made the backup on tape, restore all files on the root filesystem from the backup you made in step 11<!-- This hardcoded numeric reference should be updated. --> by putting the correct tape in the tape drive and giving these commands:</PARA>
<PROGRAMLISTING>
# <USERINPUT>cd /root</USERINPUT>&ensp;
# <USERINPUT>mt -t /dev/rmt/tps</USERINPUT><REPLACEABLE>tapecntlr</REPLACEABLE><USERINPUT>d</USERINPUT><REPLACEABLE>tapeunit</REPLACEABLE>&ensp;<USERINPUT>rewind</USERINPUT>&ensp;
# <USERINPUT>restore rf </USERINPUT><REPLACEABLE>dumpdevice</REPLACEABLE>&ensp;
</PROGRAMLISTING>
<PARA>You may need to be patient while the restore is taking place; it normally does not generate any output and it can take a while.</PARA>
</LISTITEM>
<LISTITEM><PARA>If you made the backup on disk, restore all files on the root filesystem from the backup you made in step 11<!-- This hardcoded numeric reference should be updated. --> by giving these commands:</PARA>
<PROGRAMLISTING>
# <USERINPUT>cd /root</USERINPUT>&ensp;
# <USERINPUT>restore rf /</USERINPUT><REPLACEABLE>backupfs</REPLACEABLE><USERINPUT>/root.dump </USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch6-70"><PRIMARY><FILENAME>usr</FILENAME>
 filesystem</PRIMARY>
<SECONDARY><FILENAME>restoring all files</FILENAME>
</SECONDARY>
</INDEXTERM>
If you made a backup of the <FILENAME>usr</FILENAME> filesystem in step 12<!-- This hardcoded numeric reference should be updated. --> on tape, restore all files in the backup by putting the correct tape in the tape drive and giving these commands:</PARA>
<PROGRAMLISTING>
# <USERINPUT>cd /root/usr</USERINPUT>
# <USERINPUT>mt -t /dev/rmt/tps</USERINPUT><REPLACEABLE>tapecntlr</REPLACEABLE><USERINPUT>d</USERINPUT><REPLACEABLE>tapeunit</REPLACEABLE>&ensp;<USERINPUT>rewind</USERINPUT>&ensp;
# <USERINPUT>restore rf </USERINPUT><REPLACEABLE>dumpdevice</REPLACEABLE>&ensp;
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>If you made a backup of the <FILENAME>usr</FILENAME> filesystem in step 12<!-- This hardcoded numeric reference should be updated. --> on disk, restore all files in the backup by giving these commands:</PARA>
<PROGRAMLISTING>
# <USERINPUT>cd /root/usr</USERINPUT>
# <USERINPUT>restore rf /</USERINPUT><REPLACEABLE>backupfs</REPLACEABLE><USERINPUT>/usr.dump</USERINPUT>&ensp;
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Move the new version of <FILENAME>/etc/fstab</FILENAME> that you created in step 7<!-- This hardcoded numeric reference should be updated. --> into place (the first command, which is optional, saves the old version of <FILENAME>/etc/fstab</FILENAME>):</PARA>
<PROGRAMLISTING>
# <USERINPUT>mv /root/etc/fstab /root/etc/fstab.old</USERINPUT>
# <USERINPUT>mv /root/etc/fstab.xfs /root/etc/fstab</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Exit from the shell and <COMMAND>inst</COMMAND> and restart the system:</PARA>
<PROGRAMLISTING WIDTH="wide">
# <USERINPUT>exit</USERINPUT>
# 
Calculating sizes .. 100% Done.

Inst&gt; <USERINPUT>quit</USERINPUT>
...
Ready to restart the system.  Restart? { (y)es, (n)o, (sh)ell, (h)elp }: <USERINPUT>yes</USERINPUT>
Preparing to restart system ...

The system is being restarted.
</PROGRAMLISTING>
</LISTITEM>
</ORDEREDLIST>
</SECTION>
<SECTION  ID="LE96722-PARENT"><TITLE  ID="LE96722-TITLE">Converting a Filesystem on an Option Disk From EFS to XFS</TITLE><CAUTION><PARA>The procedure in this section can result in the loss of data if it is not performed properly. It is recommended only for experienced IRIX system administrators.</PARA>
</CAUTION>
<PARA><INDEXTERM ID="ITch6-71"><PRIMARY>XFS filesystems</PRIMARY>
<SECONDARY>converting an option disk</SECONDARY>
</INDEXTERM>
This section explains how to convert an EFS filesystem on an option disk (a disk other than the system disk) to XFS. It assumes that XLV logical volumes are not used. You must be superuser to perform this procedure.</PARA>
<ORDEREDLIST><LISTITEM><PARA>Review <XREF LINKEND="LE82948-PARENT"> to verify that you are ready to begin this procedure.</PARA></LISTITEM>
<LISTITEM><PARA>Verify that your backups are up to date. Because this procedure temporarily removes all files from the filesystem you convert, it is important that you have a complete set of backups that have been prepared using your normal backup procedures. You will make a complete backup of the system disk in step 4<!-- This hardcoded numeric reference should be updated. -->, but you should have your usual backups in addition to the backup made during this procedure.</PARA>
</LISTITEM>
<LISTITEM><PARA>Identify the device name of the partition, which is the variable <REPLACEABLE>partition</REPLACEABLE>, where you plan to create the filesystem. For example, if you plan to use partition 7 (the entire disk) of an option disk on controller 0 and drive address 2, <REPLACEABLE>partition</REPLACEABLE> is <FILENAME>/dev/dsk/dks0d2s7</FILENAME>. For more information on determining <REPLACEABLE>partition</REPLACEABLE> (also known as a <FIRSTTERM>special</FIRSTTERM> file), see the <COMMAND>dks(7M)</COMMAND> reference page.</PARA>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch6-72"><PRIMARY><COMMAND>dump</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>commands used during conversion to XFS</COMMAND>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-73"><PRIMARY>backup and restore</PRIMARY>
<SECONDARY>during conversion to XFS</SECONDARY>
</INDEXTERM>
Back up all files on the disk partition to tape or disk because they will be destroyed by the conversion process. You can use any backup command (<COMMAND>Backup</COMMAND>, <COMMAND>bru</COMMAND>, <COMMAND>cpio</COMMAND>, <COMMAND>tar</COMMAND>, and so on) and back up to a local or remote tape drive or a local or remote disk. For example, the command for <COMMAND>dump</COMMAND> for local tape is:</PARA>
<PROGRAMLISTING>
# <USERINPUT>dump 0uCf</USERINPUT>&ensp;<REPLACEABLE>tapesize</REPLACEABLE>&ensp;<REPLACEABLE>dumpdevice</REPLACEABLE>&ensp;<REPLACEABLE>partition</REPLACEABLE>&ensp;
</PROGRAMLISTING>
<PARA><REPLACEABLE>tapesize</REPLACEABLE> is the tape capacity (also used for backup to disks) and <REPLACEABLE>dumpdevice</REPLACEABLE> is the device name for the tape drive. <XREF LINKEND="LE53571-TITLE"> gives the values of <REPLACEABLE>tapesize</REPLACEABLE> and <REPLACEABLE>dumpdevice</REPLACEABLE> for different local tape drives and disk. You can get the values of <REPLACEABLE>tapecntlr</REPLACEABLE> and <REPLACEABLE>tapeunit</REPLACEABLE> used in the table from the output of the command <COMMAND>hinv &ndash;c tape</COMMAND>.</PARA>
</LISTITEM>
<LISTITEM><PARA>Unmount the partition:</PARA>
<PROGRAMLISTING>
# <USERINPUT>umount </USERINPUT><REPLACEABLE>partition</REPLACEABLE>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch6-74"><PRIMARY><COMMAND>mkfs</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>command line syntax</COMMAND>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-75"><PRIMARY>block sizes</PRIMARY>
<SECONDARY>and <COMMAND>mkfs</COMMAND>
</SECONDARY>
</INDEXTERM>
Use the <COMMAND>mkfs</COMMAND> command to create the new XFS filesystem:</PARA>
<PROGRAMLISTING>
# <USERINPUT>mkfs -b size=</USERINPUT><REPLACEABLE>blocksize</REPLACEABLE><USERINPUT>&ensp;-l size=</USERINPUT><REPLACEABLE>l</REPLACEABLE><REPLACEABLE>ogsize</REPLACEABLE><REPLACEABLE>&ensp;partition</REPLACEABLE>
</PROGRAMLISTING>
<PARA><REPLACEABLE>blocksize</REPLACEABLE> is the filesystem block size (see <XREF LINKEND="LE45044-PARENT">), and <REPLACEABLE>logsize</REPLACEABLE> is the size of the area dedicated to log records (see <XREF LINKEND="LE93345-PARENT">). <XREF LINKEND="LE29798-TITLE"> shows an example of this command line and its output.</PARA></LISTITEM>
<LISTITEM><PARA>Mount the new filesystem with this command:</PARA>
<PROGRAMLISTING>
# <USERINPUT>mount </USERINPUT><REPLACEABLE>partition</REPLACEABLE>&ensp;<REPLACEABLE>mountdir</REPLACEABLE>&ensp;
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>In the file <FILENAME>/etc/fstab</FILENAME>, in the entry for <REPLACEABLE>partition</REPLACEABLE>, replace efs with xfs. For example:</PARA>
<PROGRAMLISTING>
<REPLACEABLE>partition</REPLACEABLE>&ensp;<REPLACEABLE>mountdir</REPLACEABLE> xfs rw,raw=<REPLACEABLE>rawpartition</REPLACEABLE> 0 0
</PROGRAMLISTING>
<PARA><REPLACEABLE>rawpartition</REPLACEABLE> is the raw version of <REPLACEABLE>partition</REPLACEABLE>.</PARA>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch6-76"><PRIMARY><COMMAND>restore</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>commands used during conversion to XFS</COMMAND>
</SECONDARY>
</INDEXTERM>
Restore the files to the filesystem from the backup you made in step 4<!-- This hardcoded numeric reference should be updated. -->. For example, if you gave the <COMMAND>dump</COMMAND> command in step 4<!-- This hardcoded numeric reference should be updated. -->, the commands to restore the files from tape are:</PARA>
<PROGRAMLISTING>
# <USERINPUT>cd </USERINPUT><REPLACEABLE>mountdir</REPLACEABLE>&ensp;
# <USERINPUT>mt -t </USERINPUT><REPLACEABLE>device</REPLACEABLE>&ensp;<USERINPUT>rewind</USERINPUT>&ensp;
# <USERINPUT>restore rf </USERINPUT><REPLACEABLE>dumpdevice</REPLACEABLE>&ensp;
</PROGRAMLISTING>
<PARA>The value of <REPLACEABLE>device</REPLACEABLE> is the same as <REPLACEABLE>dumpdevice</REPLACEABLE> without <LITERAL>nsv</LITERAL> or other letters at the end.</PARA>
</LISTITEM>
</ORDEREDLIST>
<PARA>You may need to be patient while the restore is taking place; it does not generate any output and it can take a while.</PARA>
</SECTION>
<SECTION  ID="LE37018-PARENT"><TITLE  ID="LE37018-TITLE">Checking for Adequate Free Disk Space When Converting to XFS Filesystems</TITLE><PARA><INDEXTERM ID="ITch6-77"><PRIMARY>disk space</PRIMARY>
<SECONDARY>increasing for XFS</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-78"><PRIMARY>disk space</PRIMARY>
<SECONDARY>estimating with <COMMAND>xfs_estimate</COMMAND>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-79"><PRIMARY><COMMAND>xfs_estimate</COMMAND>
 command</PRIMARY>
</INDEXTERM>
XFS filesystems may require more disk space than EFS filesystems for the same files. This extra disk space is required to accommodate the XFS log and as a result of block sizes larger than EFS's 512 bytes. However, XFS represents free space more compactly, on average, and the inodes are allocated dynamically by XFS, which can result in less disk space usage. </PARA>
<PARA>Use the following procedure to get a rough idea of how much free disk space will remain after a filesystem is converted to XFS:</PARA>
<ORDEREDLIST><LISTITEM><PARA>Get the size in kilobytes of the filesystem to be converted and round the result to the next megabyte. For example:</PARA>
<PROGRAMLISTING>
<USERINPUT>df -k</USERINPUT>&ensp;
Filesystem           Type  kbytes     use   avail %use  Mounted on
/dev/root             efs  969857  663306  306551  68%  /
</PROGRAMLISTING>
<PARA>This filesystem is 969857 KB, which rounds up to 970 MB.</PARA>
</LISTITEM>
<LISTITEM><PARA>If you plan to use an internal log (see <XREF LINKEND="LE93345-PARENT">), enter this command to get an estimate of the disk space required for the files in the filesystem after conversion:</PARA><PROGRAMLISTING>
% <USERINPUT>xfs_estimate -i </USERINPUT><REPLACEABLE>logsize</REPLACEABLE><USERINPUT>&ensp;-b</USERINPUT>&ensp;<REPLACEABLE>blocksize</REPLACEABLE>&ensp;<REPLACEABLE>mountpoint</REPLACEABLE>&ensp;
</PROGRAMLISTING>
<PARA><REPLACEABLE>logsize</REPLACEABLE> is the size of the log. <REPLACEABLE>blocksize</REPLACEABLE> is the block size you chose for user files in <XREF LINKEND="LE45044-PARENT">. <REPLACEABLE>mountpoint</REPLACEABLE> is the directory that is the mount point for the filesystem. For example:</PARA>
<PROGRAMLISTING>
% <USERINPUT>xfs_estimate -i 1m -b 4096 /</USERINPUT>
/ will take about 747 megabytes
</PROGRAMLISTING>
<PARA>The output of this command tells you how much disk space the files in the filesystem (with a <REPLACEABLE>blocksize</REPLACEABLE> of 4096 bytes) and an internal log of size <REPLACEABLE>logsize</REPLACEABLE> will take after conversion to XFS.</PARA>
</LISTITEM>
<LISTITEM><PARA>If you plan to use an external log, give this command to get an estimate of the disk space required for the files in the filesystem after conversion:</PARA>
<PROGRAMLISTING>
% <USERINPUT>xfs_estimate -e 0 -b</USERINPUT>&ensp;<REPLACEABLE>blocksize</REPLACEABLE>&ensp;<REPLACEABLE>mountpoint</REPLACEABLE>&ensp;
</PROGRAMLISTING>
<PARA><REPLACEABLE>blocksize</REPLACEABLE> is the block size you chose for user files in the section <XREF LINKEND="LE45044-PARENT">. <REPLACEABLE>mountpoint</REPLACEABLE> is the directory that is the mount point for the filesystem. For example,</PARA>
<PROGRAMLISTING>
% <USERINPUT>xfs_estimate -e 0 -b 4096 /</USERINPUT>
/ will take about 746 megabytes
&ensp;       with the external log using 0 blocks or about 1 megabytes
</PROGRAMLISTING>
<PARA>The first line of output from <COMMAND>xfs_estimate</COMMAND> tells you how much disk space the files in the filesystem will take after conversion to XFS. In addition to this, you need disk space on a different disk partition for the external log. Ignore the second line of output.</PARA>
</LISTITEM>
<LISTITEM><PARA>Compare the size of the filesystem from step 1 with the size of the files from step 2 or step 3. For example:</PARA>
<PROGRAMLISTING>
970 MB - 747 MB = 223 MB free disk space
747 MB / 970 MB = 77% full
</PROGRAMLISTING>
<PARA>Use this information to decide if there will be an adequate amount of free disk space if this filesystem is converted to XFS.</PARA>
</LISTITEM>
</ORDEREDLIST>
<PARA><INDEXTERM ID="ITch6-80"><PRIMARY>disk space</PRIMARY>
<SECONDARY>getting more</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-81"><PRIMARY>root filesystem</PRIMARY>
<SECONDARY>combining with <FILENAME>usr</FILENAME>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch6-82"><PRIMARY><FILENAME>usr</FILENAME>
 filesystem</PRIMARY>
<SECONDARY><FILENAME>combining with root filesystem</FILENAME>
</SECONDARY>
</INDEXTERM>
If the amount of free disk space after conversion is not adequate, consider these option:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA>Implement the usual solutions for inadequate disk space: remove unnecessary files, archive files to tape, move files to another filesystem, add another disk, and so on.</PARA>
</LISTITEM>
<LISTITEM><PARA>Repartition the disk to increase size of the disk partition for the filesystem.</PARA>
</LISTITEM>
<LISTITEM><PARA>If there is not sufficient disk space in the root filesystem and you have separate root and <FILENAME>usr</FILENAME> filesystems, switch to combined root and <FILENAME>usr</FILENAME> filesystems on a single disk partition.</PARA>
</LISTITEM>
<LISTITEM><PARA>If the filesystem is on an XLV logical volume, increase the size of the volume.</PARA>
</LISTITEM>
<LISTITEM><PARA>Create an XLV logical volume with a log subvolume elsewhere, so that all of the disk space can be allocated for user files.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</SECTION>
<SECTION  ID="LE28665-PARENT"><TITLE  ID="LE28665-TITLE">Dump and Restore Requirements When Converting to XFS Filesystems</TITLE><PARA><INDEXTERM ID="ITch6-83"><PRIMARY>backup and restore</PRIMARY>
<SECONDARY>during conversion to XFS</SECONDARY>
</INDEXTERM>
The filesystem conversion procedures in <XREF LINKEND="LE72401-PARENT"> and <XREF LINKEND="LE96722-PARENT"> require that you dump the filesystems you plan to convert to tape or to another disk with sufficient free disk space to contain the dump image. Dumping to disk is substantially faster than dumping to tape.</PARA><PARA><INDEXTERM ID="ITch6-84"><PRIMARY><COMMAND>dump</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>requirements for conversion to XFS</COMMAND>
</SECONDARY>
</INDEXTERM>
When you convert a system disk, you must use the <COMMAND>dump</COMMAND> and <COMMAND>restore</COMMAND> commands. When you convert a filesystem on an option disk, you can use any backup and restore commands. </PARA>
<PARA>If you dump to a tape drive, follow these guidelines:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA>Have sufficient tapes available for dumping the filesystems to be converted.</PARA>
</LISTITEM>
<LISTITEM><PARA>If you are converting filesystems on a system disk, the tape drive must be local.</PARA>
</LISTITEM>
<LISTITEM><PARA>If you are converting filesystems on option disks, the tape drive can be local or remote.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>The requirements for dumping to a different filesystem are:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA>The filesystem being converted must have 2 GB or less in use (the maximum size of the dump image file on an EFS filesystem) unless it is being dumped to an XFS filesystem.</PARA>
</LISTITEM>
<LISTITEM><PARA>The filesystem that will contain the dump must have sufficient disk space available to hold the filesystems to be converted.</PARA>
</LISTITEM>
<LISTITEM><PARA>If you are converting filesystems on a system disk, the filesystem where you place the dump must be local to the system.</PARA>
</LISTITEM>
<LISTITEM><PARA>If you are converting filesystems on option disks, the filesystem you dump to can be local or remote.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</SECTION>
</CHAPTER>
