<!-- Produced by version 3.13 (01/04/96) of SGI Frame/SGML translator -->
<APPENDIX LBL="B"><TITLE><XREFTARGET ID="81344">Repairing EFS Filesystem Problems<COMMAND></COMMAND></TITLE><PARAGRAPH>The <INDEXTARGET ID="app21"><!-- POSTPROCESSDATA: app21|<ITALICS>fsck</ITALICS> command:using --><COMMAND>fsck</COMMAND> command checks EFS filesystem consistency and sometimes repairs problems that are found. It is not used on XFS filesystems. This appendix describes the messages that are produced by each phase of <COMMAND>fsck</COMMAND>, what they mean, and what you should do about each one. </PARAGRAPH>
<PARAGRAPH>The sections in this appendix are:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="12495" TYPE="TITLE">&ldquo;General Errors&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="90754" TYPE="TITLE">&ldquo;Initialization Phase&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="29196" TYPE="TITLE">&ldquo;Phase 1 Check Blocks and Sizes&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="68954" TYPE="TITLE">&ldquo;Phase 2 Check Pathnames&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="94868" TYPE="TITLE">&ldquo;Phase 3 Check Connectivity&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="54770" TYPE="TITLE">&ldquo;Phase 4 Check Reference Counts&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="19686" TYPE="TITLE">&ldquo;Phase 5 Check Free List&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="19700" TYPE="TITLE">&ldquo;Phase 6 Salvage Free List&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="42973" TYPE="TITLE">&ldquo;Cleanup Phase&rdquo;</XREF></PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="12495">General Errors</TITLE><PARAGRAPH>The following abbreviations are used in <COMMAND>fsck</COMMAND> error messages:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>BLK </HANGITEM>
<HANGBODY><PARAGRAPH>block number </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>DUP </HANGITEM>
<HANGBODY><PARAGRAPH>duplicate block number </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>DIR </HANGITEM>
<HANGBODY><PARAGRAPH>directory name </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>MTIME </HANGITEM>
<HANGBODY><PARAGRAPH>time file was last modified </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>UNREF </HANGITEM>
<HANGBODY><PARAGRAPH>unreferenced</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>The following sections use these single-letter abbreviations:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><VARIABLE>B</VARIABLE> </HANGITEM>
<HANGBODY><PARAGRAPH>block number </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>F</VARIABLE> </HANGITEM>
<HANGBODY><PARAGRAPH>file (or directory) name </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>I</VARIABLE> </HANGITEM>
<HANGBODY><PARAGRAPH>inode number </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>M</VARIABLE> </HANGITEM>
<HANGBODY><PARAGRAPH>file mode </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>O</VARIABLE> </HANGITEM>
<HANGBODY><PARAGRAPH>user ID of a file's owner </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>S</VARIABLE> </HANGITEM>
<HANGBODY><PARAGRAPH>file size </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>T</VARIABLE> </HANGITEM>
<HANGBODY><PARAGRAPH>time file was last modified </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>X</VARIABLE> </HANGITEM>
<HANGBODY><PARAGRAPH>link count, or number of BAD, DUP, or MISSING blocks, or number of files (depending on context) </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>Y</VARIABLE> </HANGITEM>
<HANGBODY><PARAGRAPH>corrected link count number, or number of blocks in filesystem (depending on context)</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>Z</VARIABLE> </HANGITEM>
<HANGBODY><PARAGRAPH>number of free blocks</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>In actual <COMMAND>fsck</COMMAND> output, these abbreviations are replaced by the appropriate numbers.</PARAGRAPH>
<PARAGRAPH>Two error messages may appear in any phase. Although <COMMAND>fsck</COMMAND> prompts for you to continue checking the filesystem, it is generally best to regard these errors as fatal. Stop the command and investigate what may have caused the problem.</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><SCREENDISPLAY>CAN NOT READ: BLK </SCREENDISPLAY><VARIABLE>B</VARIABLE><SCREENDISPLAY>&space;(CONTINUE?)</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The request to read a specified block number B in the filesystem failed. This error indicates a serious problem, probably a hardware failure or an error that causes <COMMAND>fsck</COMMAND> to try to read a block that is not in the filesystem. Press <USERINPUT>n</USERINPUT> to stop <COMMAND>fsck</COMMAND>. Shut down the system to the System Maintenance Menu and run hardware diagnostics on the disk drive and controller.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>CAN NOT WRITE: BLK </SCREENDISPLAY><VARIABLE>B</VARIABLE><SCREENDISPLAY>&space;(CONTINUE?)</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The request for writing a specified block number B in the filesystem failed. The disk may be write-protected or there may be a hardware problem. Press <USERINPUT>n</USERINPUT> to stop <COMMAND>fsck</COMMAND>. Check to make sure the disk is not set to &ldquo;read only.&rdquo; (Some, though not all, disks have this feature.) If the disk is not write-protected, shut down the system to the System Maintenance Menu and run hardware diagnostics on the disk drive and controller.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="90754">Initialization Phase </TITLE><PARAGRAPH>The command line syntax is checked. Before the filesystem check can be performed, <COMMAND>fsck</COMMAND> sets up some tables and opens some files. The <COMMAND>fsck</COMMAND> command terminates if there are initialization errors.</PARAGRAPH>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="29196">Phase 1 Check Blocks and Sizes </TITLE><PARAGRAPH>This phase checks the inode list. It reports error conditions resulting from:<INDEXTARGET ID="app22"><!-- POSTPROCESSDATA: app22|inodes:checking by <ITALICS>fsck</ITALICS> --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>checking inode types </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>setting up the zero-link-count table </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>examining inode block numbers for bad or duplicate blocks </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>checking inode size </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>checking inode format</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE>Phase 1 Error Messages </TITLE><PARAGRAPH>Phase 1 has three types of error messages: information messages, messages with a CONTINUE? prompt, and messages with a CLEAR? prompt. The responses that you give to phase 1 prompts affect <COMMAND>fsck</COMMAND> functions. The possible responses are discussed in the next section, <XREF IDREF="49607" TYPE="TITLE">&ldquo;Phase 1 Responses.&rdquo;</XREF> Typically, the right answer is yes, except as noted.</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><SCREENDISPLAY>UNKNOWN FILE TYPE I=</SCREENDISPLAY><VARIABLE>I</VARIABLE><SCREENDISPLAY>&space;(CLEAR?</SCREENDISPLAY>)</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The mode word of the inode I suggests that the inode is not a pipe, special character inode, regular inode, directory inode, symbolic link, or socket.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>LINK COUNT TABLE OVERFLOW (CONTINUE?)</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;There is no more room in an internal table for <COMMAND>fsck</COMMAND> containing allocated inodes with a link count of zero.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>B</VARIABLE><SCREENDISPLAY>&space;BAD I=</SCREENDISPLAY><VARIABLE>I</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>Inode I contains block number B with a number lower than the number of the first data block in the filesystem or greater than the number of the last block in the filesystem. This error condition may invoke the EXCESSIVE BAD BLKS error condition in Phase 1 if inode I has too many block numbers outside the filesystem range. This error condition invokes the BAD/DUP error condition in Phase 2 and Phase 4.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>EXCESSIVE BAD BLOCKS I=</SCREENDISPLAY><VARIABLE>I</VARIABLE><SCREENDISPLAY>&space;(CONTINUE?)</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;There is more than a tolerable number (usually 50) of blocks with a number lower than the number of the first data block in the filesystem or greater than the number of the last block in the filesystem associated with inode I.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>B</VARIABLE><SCREENDISPLAY>&space;DUP I=</SCREENDISPLAY><VARIABLE>I</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>Inode I contains block number B, which is already claimed by another inode. This error condition may invoke the EXCESSIVE DUP BLKS error condition in Phase 1 if inode I has too many block numbers claimed by other inodes. This error condition invokes Phase 1B and the BAD/DUP error condition in Phase 2 and Phase 4. Typically, you should answer no the first time this error appears and yes the second time if you know the files claimed by the other inode.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>EXCESSIVE DUP BLKS I=</SCREENDISPLAY><VARIABLE>I</VARIABLE><SCREENDISPLAY>&space;(CONTINUE?)</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;There is more than a tolerable number (usually 50) of blocks claimed by other inodes.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>DUP TABLE OVERFLOW (CONTINUE?)</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;There is no more room in an internal table in fsck containing duplicate block numbers.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>PARTIALLY ALLOCATED INODE I=</SCREENDISPLAY><VARIABLE>I</VARIABLE><SCREENDISPLAY>&space;(CLEAR?)</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Inode I is neither allocated nor unallocated.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>RIDICULOUS NUMBER OF EXTENTS (</SCREENDISPLAY><VARIABLE>n</VARIABLE><SCREENDISPLAY>) (max allowed </SCREENDISPLAY><VARIABLE>n</VARIABLE>) </HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The number of extents is larger than the maximum the system can set and is therefore ridiculous.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>ILLEGAL NUMBER OF INDIRECT EXTENTS (</SCREENDISPLAY><VARIABLE>n</VARIABLE><SCREENDISPLAY>)</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The number of extents or pointers to extents (indirect extents) exceeds the number of slots in the inode for describing extents.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>BAD MAGIC IN EXTENT</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The pointer to an extent contains a &ldquo;magic number.&rdquo; If this number is invalid, the pointer to the extent is probably corrupt.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>EXTENT OUT OF ORDER</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;An extent's idea of where it is in the file is inconsistent with the extent pointer in relation to other extent pointers.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>ZERO LENGTH EXTENT</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;An extent is zero length.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>ZERO SIZE DIRECTORY</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;It is erroneous for a directory inode to claim a size of zero. The corresponding inode is cleared.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>DIRECTORY SIZE ERROR</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;A directory's size must be an integer number of blocks. The size is recomputed based on its extents.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>DIRECTORY EXTENTS CORRUPTED</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;If the computation of size (above) fails, <COMMAND>fsck</COMMAND> prints this message and asks to clear the inode.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>NUMBER OF EXTENTS TOO LARGE</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The number of extents or pointers to extents (indirect extents) exceeds the number of slots in the inode for describing extents.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>POSSIBLE DIRECTORY SIZE ERROR</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The number of blocks in the directory computed from extent pointer lengths is inconsistent with the number computed from the inode size field.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>POSSIBLE FILE SIZE ERROR</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The number of blocks in the file computed from extent pointer lengths is inconsistent with the number computed from the inode size field. <COMMAND>fsck</COMMAND> gives the option of clearing the inode in this case.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="49607">Phase 1 Responses</TITLE><PARAGRAPH><XREF IDREF="88866" TYPE="TABLE">Table&nbsp;B-1</XREF> explains the significance of responses to Phase 1 prompts:</PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="B-1"><PREFIX>Table B-1 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="88866">Meaning of <COMMAND>fsck</COMMAND> Phase 1 Responses</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="68"><PARAGRAPH>Prompt</PARAGRAPH>
</CELL>
<CELL LEFT="75" WIDTH="45"><PARAGRAPH>Response</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="273"><PARAGRAPH>Meaning</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="68"><PARAGRAPH>CONTINUE?</PARAGRAPH>
</CELL>
<CELL LEFT="75" WIDTH="45"><PARAGRAPH>n</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="273"><PARAGRAPH>Terminate the command.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="68"><PARAGRAPH>CONTINUE?</PARAGRAPH>
</CELL>
<CELL LEFT="75" WIDTH="45"><PARAGRAPH>y</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="273"><PARAGRAPH>Continue with the command. This error condition means that a 
complete check of the filesystem is not possible. A second run of <COMMAND>fsck</COMMAND> 
should be made to recheck this filesystem.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="68"><PARAGRAPH>CLEAR?</PARAGRAPH>
</CELL>
<CELL LEFT="75" WIDTH="45"><PARAGRAPH>n</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="273"><PARAGRAPH>Ignore the error condition. A &ldquo;no&rdquo; response is appropriate only if the 
user intends to take other measures to fix the problem.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="68"><PARAGRAPH>CLEAR?</PARAGRAPH>
</CELL>
<CELL LEFT="75" WIDTH="45"><PARAGRAPH>y</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="273"><PARAGRAPH>Deallocate inode <VARIABLE>I</VARIABLE> by zeroing its contents. This may invoke the 
UNALLOCATED error condition in Phase 2 for each directory entry 
pointing to this inode. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Phase 1B Rescan for More Bad Dups</TITLE><PARAGRAPH>When a duplicate block is found in the filesystem, the filesystem is rescanned to find the inode that previously claimed that block. When the duplicate block is found, the following information message is printed:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><VARIABLE>B</VARIABLE><SCREENDISPLAY>&space;DUP I=</SCREENDISPLAY><VARIABLE>I</VARIABLE> </HANGITEM>
<HANGBODY><PARAGRAPH>Inode I contains block number B, which is already claimed by another inode. This error condition invokes the BAD/DUP error condition in Phase 2. Inodes with overlapping blocks may be determined by examining this error condition and the DUP error condition in Phase 1.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="68954">Phase 2 Check Pathnames </TITLE><PARAGRAPH>This phase traverses the pathname tree, starting at the root directory. <COMMAND>fsck</COMMAND> examines each inode that is being used by a file in a directory of the filesystem being checked.</PARAGRAPH>
<PARAGRAPH>Referenced files are marked in order to detect unreferenced files later on. The command also accumulates a count of all links, which it checks against the link counts found in Phase 4.</PARAGRAPH>
<PARAGRAPH>Phase 2 reports error conditions resulting from the following:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>root inode mode and status incorrect </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>directory inode pointers out of range </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>directory entries pointing to bad inodes</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH><COMMAND>fsck</COMMAND> examines the root directory inode first, since this directory is where the search for all pathnames must start.</PARAGRAPH>
<PARAGRAPH>If the root directory inode is corrupted, or if its type is not <ITALICS>directory</ITALICS>,<COMMAND>&space;fsck</COMMAND> prints error messages. Generally, if a severe problem exists with the root directory it is impossible to salvage the filesystem. <COMMAND>fsck</COMMAND> allows attempts to continue under some circumstances.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Phase 2 Error Messages</TITLE><PARAGRAPH>Possible error messages caused by problems with the root directory inode are shown below. The possible responses are discussed in the next section, <XREF IDREF="96263" TYPE="TITLE">&ldquo;Phase 2 Responses.&rdquo;</XREF></PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><SCREENDISPLAY>ROOT INODE UNALLOCATED. TERMINATING</SCREENDISPLAY> </HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The root inode points to incorrect information. There is no way to fix this problem, so the command stops.</PARAGRAPH>
<PARAGRAPH>If this problem occurs on the Root filesystem, you must reinstall IRIX. If it occurs on another filesystem, you must recreate the filesystem using <COMMAND>mkfs</COMMAND> and recover files and data from backups.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>ROOT INODE NOT A DIRECTORY. FIX?</SCREENDISPLAY> </HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The root directory inode does not seem to describe a directory. This error is usually fatal. The typical answer is yes.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>DUPS/BAD IN ROOT INODE. CONTINUE?</SCREENDISPLAY> </HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Something is wrong with the block addressing information of the root directory. The typical answer is yes.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>Other Phase 2 messages have a REMOVE? prompt. These messages are:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><VARIABLE>I</VARIABLE><SCREENDISPLAY>&space;OUT OF RANGE I=</SCREENDISPLAY><VARIABLE>I</VARIABLE><SCREENDISPLAY>&space;NAME=</SCREENDISPLAY><VARIABLE>F</VARIABLE><SCREENDISPLAY>&space;(REMOVE?)</SCREENDISPLAY> </HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;A directory entry F has an inode number I that is greater than the end of the inode list. The typical answer is yes.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>UNALLOCATED I=</SCREENDISPLAY><VARIABLE>I</VARIABLE><SCREENDISPLAY>&space;OWNER=</SCREENDISPLAY><VARIABLE>O</VARIABLE><SCREENDISPLAY>&space;MODE=</SCREENDISPLAY><VARIABLE>M</VARIABLE><SCREENDISPLAY>&space;SIZE=</SCREENDISPLAY><VARIABLE>S</VARIABLE><SCREENDISPLAY>&space;MTIME=</SCREENDISPLAY><VARIABLE>T</VARIABLE><SCREENDISPLAY>&space;NAME=</SCREENDISPLAY><VARIABLE>F</VARIABLE><SCREENDISPLAY>(REMOVE?)</SCREENDISPLAY> </HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;A directory entry F has an inode I that is not marked as allocated. The owner O, mode M, size S, modify time T, and filename F are printed. If the filesystem is not mounted and the <BOLD>-n</BOLD> option is not specified, and if the inode that the entry points to is size 0, the entry is removed automatically.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>DUP/BAD I=</SCREENDISPLAY><VARIABLE>I</VARIABLE><SCREENDISPLAY>&space;OWNER=</SCREENDISPLAY><VARIABLE>O</VARIABLE><SCREENDISPLAY>&space;MODE=</SCREENDISPLAY><VARIABLE>M</VARIABLE><SCREENDISPLAY>&space;SIZE=</SCREENDISPLAY><VARIABLE>S</VARIABLE><SCREENDISPLAY>&space;MTIME=</SCREENDISPLAY><VARIABLE>T</VARIABLE><SCREENDISPLAY>&space;DIR=</SCREENDISPLAY><VARIABLE>F</VARIABLE><SCREENDISPLAY>&space;(REMOVE?)</SCREENDISPLAY> </HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Phase 1 or Phase 1B found duplicate blocks or bad blocks associated with directory entry F, directory inode I. The owner O, mode M, size S, modify time T, and directory name F are printed. Typically, you should answer no the first time this error appears and yes the second time if you know the files claimed by the other inode.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>DUP/BAD I=</SCREENDISPLAY><VARIABLE>I</VARIABLE><SCREENDISPLAY>&space;OWNER=</SCREENDISPLAY><VARIABLE>O</VARIABLE><SCREENDISPLAY>&space;MODE=</SCREENDISPLAY><VARIABLE>M</VARIABLE><SCREENDISPLAY>&space;SIZE=</SCREENDISPLAY><VARIABLE>S</VARIABLE><SCREENDISPLAY>&space;MTIME=</SCREENDISPLAY><VARIABLE>T</VARIABLE><SCREENDISPLAY>&space;FILE=</SCREENDISPLAY><VARIABLE>F</VARIABLE><SCREENDISPLAY>&space;(REMOVE?)</SCREENDISPLAY> </HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Phase 1 or Phase 1B found duplicate blocks or bad blocks associated with file entry F, inode I. The owner O, mode M, size S, modify time T, and filename F are printed. Typically, you should answer no the first time this error appears and yes the second time if you know the files claimed by the other inode.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="96263">Phase 2 Responses</TITLE><PARAGRAPH><XREF IDREF="91277" TYPE="TABLE">Table&nbsp;B-2</XREF> describes the significance of responses to Phase 2 prompts:</PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="B-2"><PREFIX>Table B-2 </PREFIX><XREFTARGET ID="91277"> <EMPHASIS>(continued)        </EMPHASIS>Meaning of Phase 2 <COMMAND>fsck</COMMAND> Responses</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="69"><PARAGRAPH>Prompt</PARAGRAPH>
</CELL>
<CELL LEFT="75" WIDTH="46"><PARAGRAPH>Response</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="272"><PARAGRAPH>Meaning</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="69"><PARAGRAPH>FIX?</PARAGRAPH>
</CELL>
<CELL LEFT="75" WIDTH="46"><PARAGRAPH>n</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="272"><PARAGRAPH><COMMAND>fsck</COMMAND> terminates.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="69"><PARAGRAPH>FIX?</PARAGRAPH>
</CELL>
<CELL LEFT="75" WIDTH="46"><PARAGRAPH>y</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="272"><PARAGRAPH><COMMAND>fsck</COMMAND> treats the contents of the inode as a directory, even though the 
inode mode indicates otherwise. If the directory is actually intact, 
and only the inode mode is incorrectly set, this may recover the 
directory. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="69"><PARAGRAPH>CONTINUE?</PARAGRAPH>
</CELL>
<CELL LEFT="75" WIDTH="46"><PARAGRAPH>n</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="272"><PARAGRAPH><COMMAND>fsck</COMMAND> terminates.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="69"><PARAGRAPH>CONTINUE?</PARAGRAPH>
</CELL>
<CELL LEFT="75" WIDTH="46"><PARAGRAPH>y</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="272"><PARAGRAPH><COMMAND>fsck</COMMAND> attempts to continue with the check. If some of the root 
directory is still readable, pieces of the files system may be salvaged.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="69"><PARAGRAPH>REMOVE?</PARAGRAPH>
</CELL>
<CELL LEFT="75" WIDTH="46"><PARAGRAPH>n</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="272"><PARAGRAPH>Ignore the error condition. A &ldquo;no&rdquo; response is appropriate only if 
the user intends to take other action to fix the problem.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="69"><PARAGRAPH>REMOVE?</PARAGRAPH>
</CELL>
<CELL LEFT="75" WIDTH="46"><PARAGRAPH>y</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="272"><PARAGRAPH>Remove a bad directory entry.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="94868">Phase 3 Check Connectivity </TITLE><PARAGRAPH>Phase 3 of <COMMAND>fsck</COMMAND> locates any unreferenced directories detected in Phase 2 and attempts to reconnect them. It reports error conditions resulting from:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>unreferenced directories </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>missing or full <FILENAME>lost+found</FILENAME> directories</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE>Phase 3 Error Messages </TITLE><PARAGRAPH>Phase 3 has two types of error messages: information messages and messages with a RECONNECT? prompt. The possible responses are discussed in the next section, <XREF IDREF="50973" TYPE="TITLE">&ldquo;Phase 3 Responses.&rdquo;</XREF></PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><SCREENDISPLAY>UNREF DIR I=</SCREENDISPLAY><VARIABLE>I</VARIABLE><SCREENDISPLAY>&space;OWNER=</SCREENDISPLAY><VARIABLE>O</VARIABLE><SCREENDISPLAY>&space;MODE=</SCREENDISPLAY><VARIABLE>M</VARIABLE><SCREENDISPLAY>&space;SIZE=</SCREENDISPLAY><VARIABLE>S</VARIABLE><SCREENDISPLAY>&space;MTIME=</SCREENDISPLAY><VARIABLE>T</VARIABLE><SCREENDISPLAY>&space;(RECONNECT?)</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The directory inode I was not connected to a directory entry when the filesystem was traversed. The owner O, mode M, size S, and modify time T of directory inode I are printed. The <COMMAND>fsck</COMMAND> command forces the reconnection of a nonempty directory. The typical answer is yes.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>SORRY. NO lost+found DIRECTORY</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;No <FILENAME>lost+found</FILENAME> directory is in the root directory of the filesystem; <COMMAND>fsck</COMMAND> ignores the request to link a directory in <FILENAME>lost+found</FILENAME>. The unreferenced file is removed.</PARAGRAPH>
<PARAGRAPH>Use <COMMAND>fsck</COMMAND>&space;<CMDLINEOPT>-l</CMDLINEOPT> to recover and remake the <FILENAME>lost+found</FILENAME> directory as soon as possible. </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>SORRY. NO SPACE IN lost+found DIRECTORY</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;There is no space to add another entry to the <FILENAME>lost+found</FILENAME> directory in the root directory of the filesystem; <COMMAND>fsck</COMMAND> ignores the request to link a directory in <FILENAME>lost+found</FILENAME>. The unreferenced file is removed.</PARAGRAPH>
<PARAGRAPH>Use <COMMAND>fsck</COMMAND>&space;<CMDLINEOPT>-l</CMDLINEOPT> to recover and clean out the <FILENAME>lost+found</FILENAME> directory as soon as possible.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>DIR I=</SCREENDISPLAY><VARIABLE>I1</VARIABLE><SCREENDISPLAY>&space;CONNECTED. PARENT WAS I=</SCREENDISPLAY><VARIABLE>I2</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;This is an advisory message indicating that a directory inode I1 was successfully connected to the <FILENAME>lost+found</FILENAME> directory. The parent inode I2 of the directory inode I1 is replaced by the inode number of the <FILENAME>lost+found</FILENAME> directory.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="50973">Phase 3 Responses</TITLE><PARAGRAPH><XREF IDREF="32401" TYPE="TABLE">Table&nbsp;B-3</XREF> explains the significance of responses to Phase 3 prompts:</PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="B-3"><PREFIX>Table B-3 </PREFIX><XREFTARGET ID="32401">Meaning of <COMMAND>fsck</COMMAND> Phase 3 Responses</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="73"><PARAGRAPH>Prompt</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="48"><PARAGRAPH>Response</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="267"><PARAGRAPH>Meaning</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="73"><PARAGRAPH>RECONNECT?</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="48"><PARAGRAPH>n</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="267"><PARAGRAPH>Ignore the error condition. This invokes the UNREF error 
condition in Phase 4. A &ldquo;no&rdquo; response is appropriate only if the 
user intends to take other action to fix the problem.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="73"><PARAGRAPH>RECONNECT?</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="48"><PARAGRAPH>&space;y</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="267"><PARAGRAPH>Reconnect directory inode <VARIABLE>I</VARIABLE> to the filesystem in the directory for 
lost files (<FILENAME>lost+found</FILENAME>). This may invoke a lost+found error 
condition if there are problems connecting directory inode <VARIABLE>I</VARIABLE> to 
<FILENAME>lost+found</FILENAME>. If the link was successful, this invokes a CONNECTED 
information message.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="54770">Phase 4 Check Reference Counts </TITLE><PARAGRAPH>This phase checks the link count information seen in Phases 2 and 3 and locates any unreferenced regular files. It reports error conditions resulting from:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>unreferenced files </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>a missing or full <FILENAME>lost+found</FILENAME> directory </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>incorrect link counts for files, directories, or special files </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>unreferenced files and directories </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>bad and duplicate blocks in files and directories </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>incorrect counts of total free inodes</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE>Phase 4 Error Messages </TITLE><PARAGRAPH>Phase 4 has five types of error messages:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>information messages </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>messages with a RECONNECT? prompt </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>messages with a CLEAR? prompt </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>messages with an ADJUST? prompt </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>messages with a FIX? prompt</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The possible responses are discussed in the next section, <XREF IDREF="21558" TYPE="TITLE">&ldquo;Phase 4 Responses.&rdquo;</XREF> The typical answer is yes, except as noted.</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><SCREENDISPLAY>UNREF FILE I=</SCREENDISPLAY><VARIABLE>I</VARIABLE><SCREENDISPLAY>&space;OWNER=</SCREENDISPLAY><VARIABLE>O</VARIABLE><SCREENDISPLAY>&space;MODE=</SCREENDISPLAY><VARIABLE>M</VARIABLE><SCREENDISPLAY>&space;SIZE=</SCREENDISPLAY><VARIABLE>S</VARIABLE><SCREENDISPLAY>&space;MTIME=</SCREENDISPLAY><VARIABLE>T</VARIABLE><SCREENDISPLAY>&space;(RECONNECT?)</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Inode I was not connected to a directory entry when the filesystem was traversed. The owner O, mode M, size S, and modify time T of inode I are printed. If the <BOLD>-n</BOLD> option is omitted and the filesystem is not mounted, empty files are cleared automatically. Nonempty files are not cleared.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>SORRY. NO lost+found DIRECTORY</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;There is no <FILENAME>lost+found</FILENAME> directory in the root directory of the filesystem; <COMMAND>fsck</COMMAND> ignores the request to link a file in <FILENAME>lost+found</FILENAME>.</PARAGRAPH>
<PARAGRAPH>Use <COMMAND>fsck</COMMAND>&space;<CMDLINEOPT>-l</CMDLINEOPT> to recover and create the <FILENAME>lost+found</FILENAME> directory as soon as possible.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>SORRY. NO SPACE IN lost+found DIRECTORY</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;There is no space to add another entry to the <FILENAME>lost+found</FILENAME> directory in the root directory of the filesystem; <COMMAND>fsck</COMMAND> ignores the request to link a file in <FILENAME>lost+found</FILENAME>.</PARAGRAPH>
<PARAGRAPH>Use <COMMAND>fsck</COMMAND>&space;<CMDLINEOPT>-l</CMDLINEOPT> to recover and clean out the <FILENAME>lost+found</FILENAME> directory as soon as possible.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>(CLEAR)</SCREENDISPLAY>
</HANGITEM>
<HANGBODY><PARAGRAPH><SCREENDISPLAY></SCREENDISPLAY>The inode mentioned in the immediately previous UNREF error condition cannot be reconnected, so it is cleared.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>LINK COUNT FILE I=</SCREENDISPLAY><VARIABLE>I</VARIABLE><SCREENDISPLAY>&space;OWNER=</SCREENDISPLAY><VARIABLE>O</VARIABLE><SCREENDISPLAY>&space;MODE=</SCREENDISPLAY><VARIABLE>M</VARIABLE><SCREENDISPLAY>&space;SIZE=</SCREENDISPLAY><VARIABLE>S</VARIABLE><SCREENDISPLAY>&space;MTIME=</SCREENDISPLAY><VARIABLE>T</VARIABLE><SCREENDISPLAY>&space;COUNT=</SCREENDISPLAY><VARIABLE>X</VARIABLE><SCREENDISPLAY>&space;SHOULD BE </SCREENDISPLAY><VARIABLE>Y</VARIABLE><SCREENDISPLAY>&space;(ADJUST?)</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The link count for inode I, which is a file, is X but should be Y. The owner O, mode M, size S, and modify time T are printed.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>LINK COUNT DIR I=</SCREENDISPLAY><VARIABLE>I</VARIABLE><SCREENDISPLAY>&space;OWNER=</SCREENDISPLAY><VARIABLE>O</VARIABLE><SCREENDISPLAY>&space;MODE=</SCREENDISPLAY><VARIABLE>M</VARIABLE><SCREENDISPLAY>&space;SIZE=</SCREENDISPLAY><VARIABLE>S</VARIABLE><SCREENDISPLAY>&space;MTIME=</SCREENDISPLAY><VARIABLE>T</VARIABLE><SCREENDISPLAY>&space;COUNT=</SCREENDISPLAY><VARIABLE>X</VARIABLE><SCREENDISPLAY>&space;SHOULD BE </SCREENDISPLAY><VARIABLE>Y</VARIABLE><SCREENDISPLAY>&space;(ADJUST?)</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The link count for inode I, which is a directory, is X but should be Y. The owner O, mode M, size S, and modify time T of directory inode I are printed.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>LINK COUNT </SCREENDISPLAY><VARIABLE>F</VARIABLE><SCREENDISPLAY>&space;I=</SCREENDISPLAY><VARIABLE>I</VARIABLE><SCREENDISPLAY>&space;OWNER=</SCREENDISPLAY><VARIABLE>O</VARIABLE><SCREENDISPLAY>&space;MODE=</SCREENDISPLAY><VARIABLE>M</VARIABLE><SCREENDISPLAY>&space;SIZE=</SCREENDISPLAY><VARIABLE>S</VARIABLE><SCREENDISPLAY>&space;MTIME=</SCREENDISPLAY><VARIABLE>T</VARIABLE><SCREENDISPLAY>&space;COUNT=</SCREENDISPLAY><VARIABLE>X</VARIABLE><SCREENDISPLAY>&space;SHOULD BE </SCREENDISPLAY><VARIABLE>Y</VARIABLE><SCREENDISPLAY>&space;(ADJUST?)</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The link count for F inode I is X but should be Y. The filename F, owner O, mode M, size S, and modify time T are printed.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>UNREF FILE I=</SCREENDISPLAY><VARIABLE>I</VARIABLE><SCREENDISPLAY>&space;OWNER=</SCREENDISPLAY><VARIABLE>O</VARIABLE><SCREENDISPLAY>&space;MODE=</SCREENDISPLAY><VARIABLE>M</VARIABLE><SCREENDISPLAY>&space;SIZE=</SCREENDISPLAY><VARIABLE>S</VARIABLE><SCREENDISPLAY>&space;MTIME=</SCREENDISPLAY><VARIABLE>T</VARIABLE><SCREENDISPLAY>&space;(CLEAR?)</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Inode I, which is a file, was not connected to a directory entry when the filesystem was traversed. The owner O, mode M, size S, and modify time T of inode I are printed. If the <BOLD>-n</BOLD> option is omitted and the filesystem is not mounted, empty files are cleared automatically. Nonempty directories are not cleared. Typically, you should answer no the first time this error appears and yes the second time if you know the files claimed by the other inode.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>UNREF DIR I=</SCREENDISPLAY><VARIABLE>I</VARIABLE><SCREENDISPLAY>&space;OWNER=</SCREENDISPLAY><VARIABLE>O</VARIABLE><SCREENDISPLAY>&space;MODE=</SCREENDISPLAY><VARIABLE>M</VARIABLE><SCREENDISPLAY>&space;SIZE=</SCREENDISPLAY><VARIABLE>S</VARIABLE><SCREENDISPLAY>&space;MTIME=</SCREENDISPLAY><VARIABLE>T</VARIABLE><SCREENDISPLAY>&space;(CLEAR?)</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Inode I, which is a directory, was not connected to a directory entry when the filesystem was traversed. The owner O, mode M, size S, and modify time T of inode I are printed. If the <BOLD>-n</BOLD> option is omitted and the filesystem is not mounted, empty directories are cleared automatically. Nonempty directories are not cleared. Typically, you should answer no the first time this error appears and yes the second time if you know the files claimed by the other inode.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>BAD/DUP FILE I=</SCREENDISPLAY><VARIABLE>I</VARIABLE><SCREENDISPLAY>&space;OWNER=</SCREENDISPLAY><VARIABLE>O</VARIABLE><SCREENDISPLAY>&space;MODE=</SCREENDISPLAY><VARIABLE>M</VARIABLE><SCREENDISPLAY>&space;SIZE=</SCREENDISPLAY><VARIABLE>S</VARIABLE><SCREENDISPLAY>&space;MTIME=</SCREENDISPLAY><VARIABLE>T</VARIABLE><SCREENDISPLAY>&space;(CLEAR?)</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Phase 1 or Phase 1B found duplicate blocks or bad blocks associated with file inode I. The owner O, mode M, size S, and modify time T of inode I are printed. Typically, you should answer no the first time this error appears and yes the second time if you know the files claimed by the other inode.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>BAD/DUP DIR I=</SCREENDISPLAY><VARIABLE>I</VARIABLE><SCREENDISPLAY>&space;OWNER=</SCREENDISPLAY><VARIABLE>O</VARIABLE><SCREENDISPLAY>&space;MODE=</SCREENDISPLAY><VARIABLE>M</VARIABLE><SCREENDISPLAY>&space;SIZE=</SCREENDISPLAY><VARIABLE>S</VARIABLE><SCREENDISPLAY>&space;MTIME=</SCREENDISPLAY><VARIABLE>T</VARIABLE><SCREENDISPLAY>&space;(CLEAR?)</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Phase 1 or Phase 1B found duplicate blocks or bad blocks associated with directory inode I. The owner O, mode M, size S, and modify time T of inode I are printed. Typically, you should answer no the first time this error appears and yes the second time if you know the files claimed by the other inode.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>FREE INODE COUNT WRONG IN SUPERBLK (FIX?)</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The actual count of the free inodes does not match the count in the superblock of the filesystem.<INDEXTARGET ID="app23"><!-- POSTPROCESSDATA: app23|super-blocks --></PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="21558">Phase 4 Responses</TITLE><PARAGRAPH><XREF IDREF="48937" TYPE="TABLE">Table&nbsp;B-4</XREF> describes the significance of responses to Phase 4 prompts:</PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="B-4"><PREFIX>Table B-4 </PREFIX><XREFTARGET ID="48937">Meaning of <COMMAND>fsck</COMMAND> Phase 4 Responses</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="73"><PARAGRAPH>Prompt</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="44"><PARAGRAPH>Response</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="269"><PARAGRAPH>Meaning</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="73"><PARAGRAPH>RECONNECT?</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="44"><PARAGRAPH>n</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="269"><PARAGRAPH>Ignore this error condition. This invokes a CLEAR error condition 
later in Phase 4.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="73"><PARAGRAPH>RECONNECT?</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="44"><PARAGRAPH>y</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="269"><PARAGRAPH>Reconnect inode <VARIABLE>I</VARIABLE> to filesystem in the directory for lost files 
(lost+found). This can cause a lost+found error condition in this 
phase if there are problems connecting inode I to lost+found. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="73"><PARAGRAPH>CLEAR? </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="44"><PARAGRAPH>n</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="269"><PARAGRAPH>Ignore the error condition. A &ldquo;no&rdquo; response is appropriate only if 
the user intends to take other action to fix the problem.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="73"><PARAGRAPH>CLEAR?</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="44"><PARAGRAPH>y</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="269"><PARAGRAPH>Deallocate the inode by zeroing its contents.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="73"><PARAGRAPH>ADJUST?</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="44"><PARAGRAPH>n</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="269"><PARAGRAPH>Ignore the error condition. A &rdquo;no&rdquo; response is appropriate only if 
the user intends to take other action to fix the problem.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="73"><PARAGRAPH>ADJUST?</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="44"><PARAGRAPH>y</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="269"><PARAGRAPH>Replace link count of file inode I with the link counted computed 
in Phase 2.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="73"><PARAGRAPH>FIX?</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="44"><PARAGRAPH>n</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="269"><PARAGRAPH>Ignore the error condition. A &ldquo;no&rdquo; response is appropriate only if 
the user intends to take other action to fix the problem.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="73"><PARAGRAPH>FIX?</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="44"><PARAGRAPH>y</PARAGRAPH>
</CELL>
<CELL LEFT="130" WIDTH="269"><PARAGRAPH>Fix the problem.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="19686">Phase 5 Check Free List </TITLE><PARAGRAPH>Phase 5 checks the free-block list. It reports error conditions resulting from:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>bad blocks in the free-block list </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>bad free-block count </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>duplicate blocks in the free-block list </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>unused blocks from the filesystem not in the free-block list </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>total free-block count incorrect</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE>Phase 5 Error Messages </TITLE><PARAGRAPH>Phase 5 has four types of error messages:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>information messages </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>messages that have a CONTINUE? prompt </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>messages that have a FIX? prompt </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>messages that have a SALVAGE? prompt</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The possible responses are discussed in the next section, <XREF IDREF="78389" TYPE="TITLE">&ldquo;Phase 5 Responses.&rdquo;</XREF> The typical answer is yes.</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><SCREENDISPLAY>FREE BLK COUNT WRONG IN SUPERBLOCK (FIX?</SCREENDISPLAY>)</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The actual count of free blocks does not match the count in the superblock of the filesystem.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>BAD FREE LIST (SALVAGE?)</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;This message is always preceded by one or more of the Phase 5 information messages.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="78389">Phase 5 Responses</TITLE><PARAGRAPH><XREF IDREF="29407" TYPE="TABLE">Table&nbsp;B-5</XREF> describes the significance of responses to Phase 5 prompts:</PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="B-5"><PREFIX>Table B-5 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="29407">Meanings of Phase 5 <COMMAND>fsck</COMMAND> Responses</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="65"><PARAGRAPH>Prompt</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="49"><PARAGRAPH>Response</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="272"><PARAGRAPH>Meaning</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="65"><PARAGRAPH>CONTINUE?</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="49"><PARAGRAPH>n</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="272"><PARAGRAPH>Terminate the command.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="65"><PARAGRAPH>CONTINUE?</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="49"><PARAGRAPH>y</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="272"><PARAGRAPH>Ignore the rest of the free-block list and continue execution of fsck. 
This error condition always invokes a BAD BLKS IN FREE LIST 
error condition later in Phase 5.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="65"><PARAGRAPH>FIX?</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="49"><PARAGRAPH>n</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="272"><PARAGRAPH>Ignore the error condition. A &ldquo;no&rdquo; response is appropriate only if 
the user intends to take other action to fix the problem.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="65"><PARAGRAPH>FIX?</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="49"><PARAGRAPH>y</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="272"><PARAGRAPH>Replace count in superblock by actual count.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="65"><PARAGRAPH>SALVAGE?</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="49"><PARAGRAPH>n</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="272"><PARAGRAPH>Ignore the error condition. A &ldquo;no&rdquo; response is appropriate only if 
the user intends to take other action to fix the problem.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="65"><PARAGRAPH>SALVAGE?</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="49"><PARAGRAPH>y</PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="272"><PARAGRAPH>Replace actual free-block bitmap with a new free-block bitmap.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="19700">Phase 6 Salvage Free List </TITLE><PARAGRAPH>This phase reconstructs the free-block bitmap. There are no error messages that can be generated in this phase and no responses are required.</PARAGRAPH>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="42973">Cleanup Phase </TITLE><PARAGRAPH>Once a filesystem has been checked, a few cleanup functions are performed. The cleanup phase displays advisory messages about the filesystem and status of the filesystem.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Cleanup Phase Messages </TITLE><HANGLIST><HANGPAIR><HANGITEM><VARIABLE>X</VARIABLE><SCREENDISPLAY>&space;files </SCREENDISPLAY><VARIABLE>Y</VARIABLE><SCREENDISPLAY>&space;blocks </SCREENDISPLAY><VARIABLE>Z</VARIABLE><SCREENDISPLAY>&space;free</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;This is an advisory message indicating that the filesystem checked contained X files using Y blocks leaving Z blocks free in the filesystem.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>SUPERBLOCK MARKED DIRTY</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;A field in the superblock is queried by system commands to decide if <COMMAND>fsck</COMMAND> must be run before mounting a filesystem. If this field is not &ldquo;clean,&rdquo;<COMMAND>&space;fsck </COMMAND>reports and asks if it should be cleaned. </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>PRIMARY SUPERBLOCK WAS INVALID</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;If the primary superblock is too corrupt to use, and <COMMAND>fsck</COMMAND> can locate a secondary superblock, it asks to replace the primary superblock with the backup. </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>SECONDARY SUPERBLOCK MISSING</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;If there is no secondary superblock, and <COMMAND>fsck</COMMAND> finds space for one, it asks to create a secondary superblock.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>CHECKSUM WRONG IN SUPERBLOCK</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;An incorrect checksum makes a filesystem unmountable. </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>***** FILE SYSTEM WAS MODIFIED *****</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;This is an advisory message indicating that the current filesystem was modified by <COMMAND>fsck</COMMAND>.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><SCREENDISPLAY>***** REMOUNTING ROOT... *****</SCREENDISPLAY></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;This is an advisory message indicating that <COMMAND>fsck</COMMAND> made changes to a mounted Root filesystem. The automatic remount ensures that in-core data structures and the filesystem are consistent.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION2>
</SECTION1>
</APPENDIX>
