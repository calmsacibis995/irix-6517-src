<!-- Produced by version 4.3 (11/99) of SGI Frame/SGIDOCBK SGML translator -->
<CHAPTER ID="LE38992-PARENT"><TITLE ID="LE38992-TITLE">Creating and Administering XLV Logical Volumes</TITLE><PARA><INDEXTERM ID="ITch4-0"><PRIMARY><COMMAND>xlvm</COMMAND>
 command</PRIMARY>
</INDEXTERM>
This chapter describes the procedures for creating and administering XLV logical volumes using command-line utilities. A graphical user interface for performing many of these procedures is available from the <COMMAND>xlvm</COMMAND> command. See its online help for more information about <COMMAND>xlvm</COMMAND>.</PARA>
<NOTE><PARA>For information on XVM logical volume management, see the<CITETITLE>&ensp;XVM Volume Manager Administrator's Guide</CITETITLE>.</PARA>
</NOTE>
<PARA>The major sections in this chapter are:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA><XREF LINKEND="LE52724-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE25568-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE64975-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE10328-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE17347-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE57181-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE70695-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE74045-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE26208-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE27814-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE96082-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE44185-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE45331-PARENT"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE80348-PARENT"></PARA></LISTITEM>
</ITEMIZEDLIST>
<SECTION  ID="LE52724-PARENT"><TITLE  ID="LE52724-TITLE">Verifying That Plexing Is Supported</TITLE><PARA><INDEXTERM ID="ITch4-1"><PRIMARY>plexes</PRIMARY>
<SECONDARY>checking for required software</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-2"><PRIMARY><FILENAME>/etc/nodelock</FILENAME>
 file</PRIMARY>
</INDEXTERM>
As discussed in <XREF LINKEND="LE37920-TITLE">, the plexing feature of XLV, which enables the use of multiple plexes, is available only when you purchase the Disk Plexing Option software option and install a FLEXlm license.</PARA><PARA><INDEXTERM ID="ITch4-3"><PRIMARY><COMMAND>xlv_mgr</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>checking that plexing software is installed</COMMAND>
</SECONDARY>
</INDEXTERM>
You can use the <COMMAND>xlv_mgr</COMMAND> command to verify that the plexing software and a valid license are installed. Follow these steps:</PARA>
<ORDEREDLIST><LISTITEM><PARA>Invoke <COMMAND>xlv_mgr</COMMAND>:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_mgr</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Use the <COMMAND>show config</COMMAND> command:</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>show config</USERINPUT>
Allocated subvol locks: 30      locks in use: 6
Plexing license: present
Plexing support: present
Maximum subvol block number: 0x7fffffffffffffff
</PROGRAMLISTING>
<PARA>The second and third lines of output, &ldquo;Plexing license: present&rdquo; and &ldquo;Plexing support: present,&rdquo; indicate that plexing software is installed with a valid license.</PARA>
</LISTITEM>
<LISTITEM><PARA>Quit out of <COMMAND>xlv_mgr</COMMAND>:</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>quit</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
</ORDEREDLIST>
</SECTION>
<SECTION  ID="LE25568-PARENT"><TITLE  ID="LE25568-TITLE">Creating Volume Objects With xlv_make</TITLE><PARA><INDEXTERM ID="ITch4-4"><PRIMARY>logical volume labels</PRIMARY>
<SECONDARY>written by <COMMAND>xlv_make</COMMAND>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-5"><PRIMARY><COMMAND>xlv_make</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>using to create volume objects</COMMAND>
</SECONDARY>
</INDEXTERM>
The <COMMAND>xlv_make</COMMAND> command creates volumes, subvolumes, plexes, and volume elements from unused disk partitions. It writes the XLV logical volume labels in the disk volume headers only; data on the disk partitions is untouched. </PARA>
<PARA>After you create a volume, make a filesystem on it if necessary, and mount the filesystem so that you can use the XLV logical volume.</PARA>
<CAUTION><PARA>When you make the filesystem using <COMMAND>mkfs</COMMAND>, all data already on the disk partitions is destroyed.</PARA>
</CAUTION>
<PARA><COMMAND>xlv_make</COMMAND> can be run interactively or it can take commands from an input file. The remainder of this section gives two examples of using <COMMAND>xlv_make</COMMAND>; the first one is interactive and the second is noninteractive.</PARA>
<SECTION><TITLE>Example 1: Creating A Simple XLV Logical Volume</TITLE><PARA><INDEXTERM ID="ITch4-6"><PRIMARY>logical volumes</PRIMARY>
<SECONDARY>creating, examples</SECONDARY>
</INDEXTERM>
This example creates a simple XLV logical volume composed of a data subvolume created from two entire option disks. The disks are on controller 0, drive addresses 2 and 3. An XFS filesystem is created and mounted at <FILENAME>/vol1</FILENAME>.</PARA>
<ORDEREDLIST><LISTITEM><PARA>Unmount the disks that will be used in the volume if they are mounted. For example:</PARA>
<PROGRAMLISTING WIDTH="wide">
# <USERINPUT>df</USERINPUT>
Filesystem                 Type  blocks     use   avail %use  Mounted on
/dev/root                   efs 1939714  430115 1509599  22%  /
/dev/dsk/dks0d2s7           efs 2004550      22 2004528   0%  /d2
/dev/dsk/dks0d3s7           efs 3826812      22 3826790   0%  /d3
# <USERINPUT>umount /d2</USERINPUT>
# <USERINPUT>umount /d3</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Start <COMMAND>xlv_make</COMMAND>:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_make</USERINPUT>
xlv_make&gt;
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Start creating the volume by specifying its name, for example xlv0:</PARA>
<PROGRAMLISTING>
xlv_make&gt; <USERINPUT>vol xlv0</USERINPUT>
xlv0
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Begin creating the data subvolume:</PARA>
<PROGRAMLISTING>
xlv_make&gt; <USERINPUT>data</USERINPUT>
xlv0.data
</PROGRAMLISTING>
<PARA><COMMAND>xlv_make</COMMAND> echoes the name of each object (volume, subvolume, plex, or volume element) you create.</PARA>
</LISTITEM>
<LISTITEM><PARA>Continue to move down through the hierarchy of the volume by specifying the plex:</PARA>
<PROGRAMLISTING>
xlv_make&gt; <USERINPUT>plex</USERINPUT>
xlv0.data.0
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Specify the volume elements (disk partitions) to be included in the volume, for example <FILENAME>/dev/dsk/dks0d2s7</FILENAME> and <FILENAME>/dev/dsk/dks0d3s7</FILENAME>:</PARA>
<PROGRAMLISTING>
xlv_make&gt; <USERINPUT>ve dks0d2s7</USERINPUT>
xlv0.data.0.0
xlv_make&gt; <USERINPUT>ve dks0d3s7</USERINPUT>
xlv0.data.0.1
</PROGRAMLISTING>
<PARA><INDEXTERM ID="ITch4-7"><PRIMARY><COMMAND>xlv_make</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>and disk partition types</COMMAND>
</SECONDARY>
</INDEXTERM>
You can specify the last portion of the disk partition pathname (as shown) or the full pathname. <COMMAND>xlv_make</COMMAND> accepts disk partitions that are of types <FILENAME>xlv</FILENAME>, <FILENAME>sfx</FILENAME>, and <FILENAME>efs</FILENAME>. You can use other partition types, such as <FILENAME>lvol</FILENAME>, by specifying the <COMMAND>-force</COMMAND> option; for example, <COMMAND>ve &ndash;force dks0d2s7</COMMAND>. <COMMAND>xlv_make</COMMAND> automatically changes the partition type to <FILENAME>xlv</FILENAME>.</PARA>
</LISTITEM>
<LISTITEM><PARA>Indicate that you are finished specifying the objects:</PARA>
<PROGRAMLISTING>
xlv_make&gt; <USERINPUT>end</USERINPUT>
Object specification completed
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Review the objects that you specified:</PARA>
<PROGRAMLISTING>
xlv_make&gt; <USERINPUT>show</USERINPUT>

&ensp;       Completed Objects
(1)  VOL xlv0
VE xlv0.data.0.0 [empty]
&ensp;       start=0, end=2004549, (cat)grp_size=1
&ensp;       /dev/dsk/dks0d2s7 (2004550 blks)
VE xlv0.data.0.1 [empty]
&ensp;       start=2004550, end=5831361, (cat)grp_size=1
&ensp;       /dev/dsk/dks0d3s7 (3826812 blks)
</PROGRAMLISTING>
<PARA>This output shows one volume with two volume elements. The size of each partition used is shown, for example, 2004550 blocks. These blocks are disk blocks and are 512 bytes.</PARA>
</LISTITEM>
<LISTITEM><PARA>Write the volume information to the logical volume labels by exiting <COMMAND>xlv_make</COMMAND>:</PARA>
<PROGRAMLISTING>
xlv_make&gt; <USERINPUT>exit</USERINPUT>
Newly created objects will be written to disk.
Is this what you want?(yes)  <USERINPUT>yes</USERINPUT>
Invoking xlv_assemble
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Make an XFS filesystem using <COMMAND>mkfs</COMMAND>. For example:</PARA>
<PROGRAMLISTING WIDTH="wide">
# <USERINPUT>mkfs /dev/xlv/xlv0</USERINPUT>
meta-data=/dev/xlv/xlv0          isize=256    agcount=8, agsize=16094 blks
data     =                       bsize=4096   blocks=2482901
log      =internal log           bsize=4096   blocks=1000
realtime =none                   bsize=4096   blocks=0, rtextents=0
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Mount the filesystem, for example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>mkdir /vol1</USERINPUT>&ensp;
# <USERINPUT>mount /dev/xlv/xlv0 /vol1</USERINPUT>&ensp;
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch4-8"><PRIMARY><FILENAME>/etc/fstab</FILENAME>
 file</PRIMARY>
<SECONDARY><FILENAME>entries for XLV logical volumes</FILENAME>
</SECONDARY>
</INDEXTERM>
To have the logical volume mounted automatically at system startup, add an entry for the volume to <FILENAME>/etc/fstab</FILENAME>. For example:</PARA>
<PROGRAMLISTING>
/dev/xlv/xlv0 /vol1 xfs rw,raw=/dev/rxlv/xlv0 0 0 
</PROGRAMLISTING>
</LISTITEM>
</ORDEREDLIST>
</SECTION>
<SECTION  ID="LE36733-PARENT"><TITLE  ID="LE36733-TITLE">Example 2: Creating A Striped, Plexed XLV Logical Volume</TITLE><PARA><INDEXTERM ID="ITch4-9"><PRIMARY>plexes</PRIMARY>
<SECONDARY>example of creating</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-10"><PRIMARY>volume elements</PRIMARY>
<SECONDARY>striped, example of creating</SECONDARY>
</INDEXTERM>
This example shows the noninteractive creation of an XLV logical volume from four equal-sized option disks (controller 0, units 2 through 5). Two plexes will be created with the data striped across the two disks in each plex. The stripe unit will be 128 KB. An XFS filesystem is created and mounted at <FILENAME>/vol1</FILENAME>.</PARA>
<ORDEREDLIST><LISTITEM><PARA>As in the previous example, unmount filesystems on the disks to be used, if necessary.</PARA>
</LISTITEM>
<LISTITEM><PARA>Create a file called <FILENAME>xlv0.specs</FILENAME> that contains input for <COMMAND>xlv_make</COMMAND>. For this example and a volume named xlv0, the file contains:</PARA>
<PROGRAMLISTING>
vol xlv0
data
plex
ve -stripe -stripe_unit 256 dks0d2s7 dks0d3s7
plex
ve -stripe -stripe_unit 256 dks0d4s7 dks0d5s7
end
show
exit
</PROGRAMLISTING>
<PARA>This script specifies the volume hierarchically: volume, subvolume (data), first plex with a striped volume element, then second plex with a striped volume element. The <COMMAND>ve</COMMAND> commands have a stripe unit argument of 256. This argument is the number of 512-byte disk blocks (sectors), so 128 KB/512 = 256. The <COMMAND>end</COMMAND> command signifies that the specification is complete and the (optional) <COMMAND>show</COMMAND> command causes the specification to be displayed. The logical volume label is created by the <COMMAND>exit</COMMAND> command.</PARA>
</LISTITEM>
<LISTITEM><PARA>Run <COMMAND>xlv_make</COMMAND> to create the volume. For example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_make xlv0.specs</USERINPUT>&ensp;
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Make an XFS filesystem with an internal 10 MB log and 1 KB block size:</PARA>
<PROGRAMLISTING>
# <USERINPUT>mkfs -b size=1k -l size=10m /dev/xlv/xlv0</USERINPUT>&ensp;
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Mount the filesystem, for example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>mkdir /vol1</USERINPUT>&ensp;
# <USERINPUT>mount /dev/xlv/xlv0 /vol1</USERINPUT>&ensp;
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>To have the logical volume mounted automatically at system startup, add an entry for the volume to <FILENAME>/etc/fstab</FILENAME>, for example:</PARA>
<PROGRAMLISTING>
/dev/xlv/xlv0 /vol1 xfs rw,raw=/dev/rxlv/xlv0 0 0 
</PROGRAMLISTING>
</LISTITEM>
</ORDEREDLIST>
</SECTION>
<SECTION  ID="LE63965-PARENT"><TITLE  ID="LE63965-TITLE">Example 3: Creating A Plexed XLV Logical Volume for an XFS Filesystem With an External Log</TITLE><PARA><INDEXTERM ID="ITch4-11"><PRIMARY>logs</PRIMARY>
<SECONDARY>example of external</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-12"><PRIMARY>external logs</PRIMARY>
<SECONDARY>example</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-13"><PRIMARY>plexes</PRIMARY>
<SECONDARY>example of creating</SECONDARY>
</INDEXTERM>
The following example shows how to create an XLV logical volume with a log subvolume that is plexed and a data subvolume that is concatenated and plexed. The volume will be used to hold an XFS filesystem with an external log.</PARA>
<PARA>This example uses four disks on controller 1 at drive addresses 2 through 5. The disks at drive addresses 2 and 3 are partitioned as option drives with xfslog partitions. The disks at drive addresses 4 and 5 are partitioned as option drives without xfslog partitions.</PARA>
<ORDEREDLIST><LISTITEM><PARA>Invoke <COMMAND>xlv_make</COMMAND> and begin to create the volume, called <FILENAME>xfs-mp5</FILENAME>, by creating the log subvolume with two plexes:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_make</USERINPUT>
xlv_make&gt; <USERINPUT>vol xfs-mp5</USERINPUT>
xfs-mp5
xlv_make&gt; <USERINPUT>log</USERINPUT>
xfs-mp5.log
xlv_make&gt; <USERINPUT>plex</USERINPUT>
xfs-mp5.log.0
xlv_make&gt; <USERINPUT>ve dks1d2s15</USERINPUT>
xfs-mp5.log.0.0
xlv_make&gt; <USERINPUT>plex</USERINPUT>
xfs-mp5.log.1
xlv_make&gt; <USERINPUT>ve dks1d3s15</USERINPUT>
xfs-mp5.log.1.0
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Create the data subvolume with two plexes, each of which has two volume elements:</PARA>
<PROGRAMLISTING>
xlv_make&gt; <USERINPUT>data</USERINPUT>
xfs-mp5.data
xlv_make&gt; <USERINPUT>plex</USERINPUT>
xfs-mp5.data.0
xlv_make&gt; <USERINPUT>ve dks1d2s7</USERINPUT>
xfs-mp5.data.0.0
xlv_make&gt; <USERINPUT>ve dks1d4s7</USERINPUT>
xfs-mp5.data.0.1
xlv_make&gt; <USERINPUT>plex</USERINPUT>
xfs-mp5.data.1
xlv_make&gt; <USERINPUT>ve dks1d3s7</USERINPUT>
xfs-mp5.data.1.0
xlv_make&gt; <USERINPUT>ve dks1d5s7</USERINPUT>
xfs-mp5.data.1.1
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Indicate that you have completed the volume, display it, and exit <COMMAND>xlv_make</COMMAND>:</PARA>
<PROGRAMLISTING>
xlv_make&gt; <USERINPUT>end</USERINPUT>
Object specification completed
xlv_make&gt; <USERINPUT>show</USERINPUT>

&ensp;       Completed Objects
(1)  VOL xfs-mp5
VE xfs-mp5.log.0.0 [empty]
&ensp;       start=0, end=8255, (cat)grp_size=1
&ensp;       /dev/dsk/dks1d2s15 (8256 blks)
VE xfs-mp5.log.1.0 [empty]
&ensp;       start=0, end=8255, (cat)grp_size=1
&ensp;       /dev/dsk/dks1d3s15 (8256 blks)
VE xfs-mp5.data.0.0 [empty]
&ensp;       start=0, end=3920223, (cat)grp_size=1
&ensp;       /dev/dsk/dks1d2s7 (3920224 blks)
VE xfs-mp5.data.0.1 [empty]
&ensp;       start=3920224, end=7848703, (cat)grp_size=1
&ensp;       /dev/dsk/dks1d4s7 (3928480 blks)
VE xfs-mp5.data.1.0 [empty]
&ensp;       start=0, end=3920223, (cat)grp_size=1
&ensp;       /dev/dsk/dks1d3s7 (3920224 blks)
VE xfs-mp5.data.1.1 [empty]
&ensp;       start=3920224, end=7848703, (cat)grp_size=1
&ensp;       /dev/dsk/dks1d5s7 (3928480 blks)

xlv_make&gt; <USERINPUT>exit</USERINPUT>
Newly created objects will be written to disk.
Is this what you want?(yes)  <USERINPUT>y</USERINPUT>
Invoking xlv_assemble
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Make an XFS filesystem by running <COMMAND>mkfs</COMMAND>. Note how <COMMAND>mkfs</COMMAND> automatically uses an external log when one is present.</PARA>
<PROGRAMLISTING WIDTH="wide">
# <USERINPUT>mkfs /dev/xlv/xfs-mp5</USERINPUT>
meta-data=/dev/xlv/xfs-mp5   isize=256    agcount=8, agsize=122636 blks
data     =                       bsize=4096   blocks=981088
log      =volume log             bsize=4096   blocks=1032
realtime =none                   bsize=65536  blocks=0, rtextents=0
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Mount the filesystem, for example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>mkdir /v1</USERINPUT>&ensp;
# <USERINPUT>mount /dev/xlv/xfs-mp5 /v1</USERINPUT>&ensp;
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>To have the logical volume mounted automatically at system startup, add an entry for the volume to <FILENAME>/etc/fstab</FILENAME>, for example:</PARA>
<PROGRAMLISTING>
<USERINPUT>/dev/xlv/xfs-mp5 /v1 xfs rw,raw=/dev/rxlv/xfs-mp5 0 0</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
</ORDEREDLIST>
</SECTION>
</SECTION>
<SECTION  ID="LE64975-PARENT"><TITLE  ID="LE64975-TITLE">Displaying XLV Logical Volume Objects</TITLE><PARA><INDEXTERM ID="ITch4-14"><PRIMARY><COMMAND>xlv_mgr</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>displaying objects</COMMAND>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-15"><PRIMARY>logical volumes</PRIMARY>
<SECONDARY>displaying objects</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-16"><PRIMARY>plexes</PRIMARY>
<SECONDARY>displaying</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-17"><PRIMARY>subvolumes</PRIMARY>
<SECONDARY>displaying</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-18"><PRIMARY>volume elements</PRIMARY>
<SECONDARY>displaying</SECONDARY>
</INDEXTERM>
To get a list of the top level XLV objects on a system (volumes, unattached plexes, and unattached volume elements), invoke <COMMAND>xlv_mgr</COMMAND> and invoke the command <COMMAND>show all</COMMAND>, for example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_mgr</USERINPUT>
xlv_mgr&gt; <USERINPUT>show all</USERINPUT>
Volume Element: SPARE_VE
Volume:         BIG_VOLUME (complete)
</PROGRAMLISTING>
<PARA>In this example, there are two top level objects, a volume element named <FILENAME>SPARE_VE</FILENAME> and an XLV logical volume named <FILENAME>BIG_VOLUME</FILENAME>. The volume element is a top level object because it is not part of (attached to) any plex. Volume elements can be attached to a plex at a later time.</PARA>
<PARA>To display the complete hierarchy of a top level object, invoke the <COMMAND>xlv_mgr</COMMAND> command <COMMAND>show object</COMMAND> with the name of the object, for example:</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>show object BIG_VOLUME</USERINPUT>
VOL BIG_VOLUME (complete)
VE BIG_VOLUME.log.0.0   [active]
&ensp;       start=0, end=8255, (cat)grp_size=1
&ensp;       /dev/dsk/dks1d2s15 (8256 blks)
VE BIG_VOLUME.log.1.0   [active]
&ensp;       start=0, end=8255, (cat)grp_size=1
&ensp;       /dev/dsk/dks1d3s15 (8256 blks)
VE BIG_VOLUME.log.2.0   [active]
&ensp;       start=0, end=8255, (cat)grp_size=1
&ensp;       /dev/dsk/dks1d4s15 (8256 blks)
VE BIG_VOLUME.data.0.0  [active]
&ensp;       start=0, end=3920223, (cat)grp_size=1
&ensp;       /dev/dsk/dks1d2s7 (3920224 blks)
VE BIG_VOLUME.data.1.0  [active]
&ensp;       start=0, end=3920223, (cat)grp_size=1
&ensp;       /dev/dsk/dks1d3s7 (3920224 blks)
VE BIG_VOLUME.data.2.0  [active]
&ensp;       start=0, end=3920223, (cat)grp_size=1
&ensp;       /dev/dsk/dks1d4s7 (3920224 blks)
</PROGRAMLISTING>
<PARA>This output shows that <FILENAME>BIG_VOLUME</FILENAME> contains log and data subvolumes. Each subvolume has three plexes that have one volume element each.</PARA>
</SECTION>
<SECTION  ID="LE10328-PARENT"><TITLE  ID="LE10328-TITLE">Adding a Volume Element to a Plex (Growing an XLV Logical Volume)</TITLE><PARA><INDEXTERM ID="ITch4-19"><PRIMARY><COMMAND>xlv_mgr</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>growing a volume</COMMAND>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-20"><PRIMARY>logical volumes</PRIMARY>
<SECONDARY>growing</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-21"><PRIMARY>logical volumes</PRIMARY>
<SECONDARY>increasing size</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-22"><PRIMARY>disk space</PRIMARY>
<SECONDARY>growing a logical volume</SECONDARY>
</INDEXTERM>
Growing an XLV logical volume (increasing its size) can be done by adding one or more volume elements to the end of one or more of its plexes. (If you do not add volume elements to all plexes, data stored in the added volume elements won't be replicated in all plexes.)</PARA>
<PARA>The following procedure assumes that you are starting with an XLV logical volume. If you are starting with a filesystem on a single disk partition that you want to turn into a logical volume and grow onto an additional disk partition, use the procedure in <XREF LINKEND="LE49326-TITLE"> instead.</PARA><ORDEREDLIST><LISTITEM><PARA><INDEXTERM ID="ITch4-23"><PRIMARY>XLV logical volumes</PRIMARY>
<SECONDARY>creating spare objects</SECONDARY>
</INDEXTERM>
If any of the volume elements you plan to add to the volume don't exist yet, create them with <COMMAND>xlv_make</COMMAND>. For example, follow this procedure to create a volume element out of a new disk, <FILENAME>/dev/dsk/dks0d4s7</FILENAME>:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_make</USERINPUT>&ensp;
xlv_make&gt; <USERINPUT>ve spare_ve dks0d4s7</USERINPUT>
new_ve
xlv_make&gt; <USERINPUT>end</USERINPUT>
Object specification completed
xlv_make&gt; <USERINPUT>exit</USERINPUT>
Newly created objects will be written to disk.
Is this what you want?(yes)  <USERINPUT>yes</USERINPUT>
Invoking xlv_assemble
</PROGRAMLISTING>
<PARA>The <COMMAND>ve</COMMAND> command creates a volume element name, <FILENAME>spare_ve</FILENAME>. The name is required because the volume element is not part of a larger hierarchy; it is the top level object in this case.</PARA>
</LISTITEM>
<LISTITEM><PARA>Use the <COMMAND>attach</COMMAND> command of the <COMMAND>xlv_mgr</COMMAND> command to add each volume element. For example, to add the volume element from step 1<!-- This hardcoded numeric reference should be updated. --> to plex 0 of the data subvolume of the volume xlv0, use this procedure:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_mgr</USERINPUT>&ensp;
xlv_mgr&gt; <USERINPUT>attach ve spare_ve xlv0.data.0</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Quit out of <COMMAND>xlv_mgr</COMMAND>:</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>quit</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>If you are growing an XFS filesystem, mount the filesystem if it is not already mounted:</PARA>
<PROGRAMLISTING>
# <USERINPUT>mount</USERINPUT>&ensp;<REPLACEABLE>volume</REPLACEABLE>&ensp;<REPLACEABLE>mountpoint</REPLACEABLE>&ensp;
</PROGRAMLISTING>
<PARA><REPLACEABLE>volume</REPLACEABLE> is the device name of the logical volume, for example <FILENAME>/dev/xlv/xlv0</FILENAME>, and <REPLACEABLE>mountpoint</REPLACEABLE> is the mount point directory for the logical volume.</PARA>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch4-24"><PRIMARY><COMMAND>xfs_growfs</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>example</COMMAND>
</SECONDARY>
</INDEXTERM>
If you are growing an XFS filesystem, use <COMMAND>xfs_growfs</COMMAND> to grow the filesystem:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xfs_growfs -d</USERINPUT>&ensp;<REPLACEABLE>mountpoint</REPLACEABLE>
</PROGRAMLISTING>
<PARA><REPLACEABLE>mountpoint</REPLACEABLE> is the mount point directory for the logical volume.</PARA>
</LISTITEM>
<LISTITEM><PARA>If you are growing an EFS filesystem, unmount the filesystem if it is mounted, and use <COMMAND>growfs</COMMAND> to grow the filesystem:</PARA>
<PROGRAMLISTING>
# <USERINPUT>umount</USERINPUT>&ensp;<REPLACEABLE>mountpoint</REPLACEABLE>&ensp;
# <USERINPUT>growfs</USERINPUT>&ensp;<REPLACEABLE>volume</REPLACEABLE>&ensp;
</PROGRAMLISTING>
<PARA><REPLACEABLE>mountpoint</REPLACEABLE> is the mount point directory for the filesystem. <REPLACEABLE>volume</REPLACEABLE> is the device name of the logical volume, for example, <FILENAME>/dev/xlv/xlv0</FILENAME>.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECTION>
<SECTION  ID="LE17347-PARENT"><TITLE  ID="LE17347-TITLE">Adding a Plex to an XLV Logical Volume</TITLE><PARA><INDEXTERM ID="ITch4-25"><PRIMARY><COMMAND>xlv_mgr</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>adding a plex</COMMAND>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-26"><PRIMARY>plexes</PRIMARY>
<SECONDARY>adding to volumes</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-27"><PRIMARY>logical volumes</PRIMARY>
<SECONDARY>adding plexes</SECONDARY>
</INDEXTERM>
If you have purchased the Disk Plexing Option software option and have installed a FLEXlm license for it, you can add a plex to an existing subvolume for improved reliability in case of disk failures. The procedure to add a plex to a subvolume is described below. To add more than one plex to a subvolume or to add a plex to each of the subvolumes in a volume, repeat the procedure as necessary.</PARA>
<ORDEREDLIST><LISTITEM><PARA>If the plex that you want to add to the subvolume does not exist yet, create it with <COMMAND>xlv_make</COMMAND>. For example, to create a plex called <FILENAME>plex1</FILENAME> to add to the data subvolume of a volume called <FILENAME>root_vol</FILENAME>, enter these commands:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_make</USERINPUT>&ensp;
xlv_make&gt; <USERINPUT>plex plex1</USERINPUT>
plex1
xlv_make&gt; <USERINPUT>ve /dev/dsk/dks0d3s7</USERINPUT>
plex1.0
xlv_make&gt; <USERINPUT>end</USERINPUT>
Object specification completed
xlv_make&gt; <USERINPUT>exit</USERINPUT>
Newly created objects will be written to disk.
Is this what you want?(yes)  <USERINPUT>yes</USERINPUT>
Invoking xlv_assemble
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Use the <COMMAND>xlv_mgr</COMMAND> command to add the plex to the volume. For example, to add the standalone plex <FILENAME>plex1</FILENAME> to <FILENAME>root_vol</FILENAME>, use this procedure:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_mgr </USERINPUT>
xlv_mgr&gt; <USERINPUT>attach plex plex1 root_vol.data</USERINPUT>&ensp;
</PROGRAMLISTING>
<PARA><COMMAND>xlv_mgr</COMMAND> automatically initiates a plex revive operation to copy the contents of the original plex, <FILENAME>root_vol.data.0</FILENAME>, to the newly added plex.</PARA>
</LISTITEM>
<LISTITEM><PARA>You can confirm that <FILENAME>root_vol</FILENAME> now has two plexes by displaying the object hierarchy:</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>show object root_vol</USERINPUT>
VOL root_vol (complete)
VE root_vol.data.0.0    [active]
&ensp;       start=0, end=988091, (cat)grp_size=1
&ensp;       /dev/dsk/dks0d2s7 (988092 blks)
VE root_vol.data.1.0    [empty]
&ensp;       start=0, end=988091, (cat)grp_size=1
&ensp;       /dev/dsk/dks0d3s7 (988092 blks)
</PROGRAMLISTING>
<PARA>The newly added plex, <FILENAME>root_vol.data.1</FILENAME>, is initially in the &ldquo;empty&rdquo; state. This is because it is newly created.</PARA>
</LISTITEM>
<LISTITEM><PARA>Exit <COMMAND>xlv_mgr</COMMAND>:</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>quit</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
</ORDEREDLIST>
<PARA><INDEXTERM ID="ITch4-28"><PRIMARY>plexes</PRIMARY>
<SECONDARY>monitoring plex revives</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-29"><PRIMARY>plex revives</PRIMARY>
</INDEXTERM>
The plex revive completes and the new plex switches to &ldquo;active&rdquo; state automatically, but if you want to check its progress and verify that the plex has become active, follow this procedure:</PARA>
<ORDEREDLIST><LISTITEM><PARA>List the XLV daemons running, for example:</PARA>
<PROGRAMLISTING WIDTH="wide">
# <USERINPUT>ps -ef | grep xlv</USERINPUT>
&ensp;   root    27     1  0 10:49:27 ?        0:00 /sbin/xlv_plexd -m 4
&ensp;   root    35     1  0 10:49:28 ?        0:00 /sbin/xlv_labd
&ensp;   root    31     1  0 10:49:27 ?        0:00 xlvd
&ensp;   root   407    27  1 11:01:01 ?        0:00 xlv_plexd -v 2 -n root_vol.data
-d 50331648 -b 128 -w 0 0 1992629
&ensp;   root   410   397  2 11:01:11 pts/0    0:00 grep xlv
</PROGRAMLISTING>
<PARA>One instance of the <COMMAND>xlv_plexd</COMMAND> daemon is currently reviving <FILENAME>root_vol.data</FILENAME>. This daemon exits when the plex has been fully revived.</PARA>
</LISTITEM>
<LISTITEM><PARA>Later, check the XLV daemons again, for example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>ps -ef | grep xlv</USERINPUT>
&ensp;   root    27     1  0 10:49:27 ?        0:00 /sbin/xlv_plexd -m 4
&ensp;   root    35     1  0 10:49:28 ?        0:00 /sbin/xlv_labd
&ensp;   root    31     1  0 10:49:27 ?        0:03 xlvd
&ensp;   root   459   397  2 11:21:10 pts/0    0:00 grep xlv
</PROGRAMLISTING>
<PARA>The instance of <COMMAND>xlv_plexd</COMMAND> that was reviving <FILENAME>root_vol.data</FILENAME> is no longer running; it has completed the plex revive. </PARA>
</LISTITEM>
<LISTITEM><PARA>Check the state of the plex using <COMMAND>xlv_mgr</COMMAND>:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_mgr</USERINPUT>
xlv_mgr&gt; <USERINPUT>show object root_vol</USERINPUT>
VOL root_vol (complete)
VE root_vol.data.0.0    [active]
&ensp;       start=0, end=988091, (cat)grp_size=1
&ensp;       /dev/dsk/dks0d2s7 (988092 blks)
VE root_vol.data.1.0    [active]
&ensp;       start=0, end=988091, (cat)grp_size=1
&ensp;       /dev/dsk/dks0d2s0 (988092 blks)
xlv_mgr&gt; <USERINPUT>quit</USERINPUT>
</PROGRAMLISTING>
<PARA>Both plexes are now in the &ldquo;active&rdquo; state.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECTION>
<SECTION  ID="LE57181-PARENT"><TITLE  ID="LE57181-TITLE">Detaching a Plex From an XLV Logical Volume</TITLE><PARA><INDEXTERM ID="ITch4-30"><PRIMARY><COMMAND>xlv_mgr</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>detaching a plex</COMMAND>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-31"><PRIMARY>plexes</PRIMARY>
<SECONDARY>detaching</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-32"><PRIMARY>logical volumes</PRIMARY>
<SECONDARY>detaching plexes</SECONDARY>
</INDEXTERM>
Detaching a plex from a volume, perhaps because you want to swap disk drives, can be done while the volume is active. However, the entire address range of the subvolume must still be covered by active volume elements in the remaining plex or plexes. <COMMAND>xlv_mgr</COMMAND> does not allow you to detach the only active plex in a volume if the other plexes are not yet active. To detach a plex, follow these steps:</PARA>
<ORDEREDLIST><LISTITEM><PARA>Start <COMMAND>xlv_mgr</COMMAND> and display the volume that has the plex that you plan to detach, for example, root_vol:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_mgr</USERINPUT>
xlv_mgr&gt; <USERINPUT>show object root</USERINPUT>
VOL root (complete)
VE root.data.0.0        [active]
&ensp;       start=0, end=1843199, (cat)grp_size=1
&ensp;       /dev/dsk/dks1d3s0 (1843200 blks)
VE root.data.1.0        [active]
&ensp;       start=0, end=1843199, (cat)grp_size=1
&ensp;       /dev/dsk/dks1d4s0 (1843200 blks)
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Detach plex 1 and give it the name <FILENAME>plex1</FILENAME> by issuing these commands:</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>detach plex root.1 rplex1</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>To examine the volume and the detached plex, issue these commands:</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>show -long all</USERINPUT>
PLEX rplex1
VE rplex1.0     [stale]
&ensp;       start=0, end=1843199, (cat)grp_size=1
&ensp;       /dev/dsk/dks1d4s0 (1843200 blks)

VOL root (complete)
VE root.data.0.0        [active]
&ensp;       start=0, end=1843199, (cat)grp_size=1
&ensp;       /dev/dsk/dks1d3s0 (1843200 blks)
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Exit <COMMAND>xlv_mgr</COMMAND>:</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>quit</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
</ORDEREDLIST>
</SECTION>
<SECTION  ID="LE70695-PARENT"><TITLE  ID="LE70695-TITLE">Deleting an XLV Object</TITLE><CAUTION><PARA>The procedures in this section can result in the loss of data if they are not performed properly. It is recommended for experienced IRIX system administrators only.</PARA>
</CAUTION>
<PARA><INDEXTERM ID="ITch4-33"><PRIMARY><COMMAND>xlv_mgr</COMMAND>
 command</PRIMARY>
<SECONDARY><COMMAND>deleting volume objects</COMMAND>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-34"><PRIMARY>logical volumes</PRIMARY>
<SECONDARY>deleting objects</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-35"><PRIMARY>plexes</PRIMARY>
<SECONDARY>deleting</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-36"><PRIMARY>volume elements</PRIMARY>
<SECONDARY>deleting</SECONDARY>
</INDEXTERM>
To delete a volume or any other XLV object, follow these steps:</PARA>
<ORDEREDLIST><LISTITEM><PARA>If you are deleting a volume, you must unmount it first. For example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>umount /vol1</USERINPUT>&ensp;
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Start <COMMAND>xlv_mgr</COMMAND> and list each object on the system:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_mgr</USERINPUT>
xlv_mgr&gt; <USERINPUT>show -long all</USERINPUT>
VOL root_vol (complete)
VE root_vol.data.0.0    [active]
&ensp;       start=0, end=988091, (cat)grp_size=1
&ensp;       /dev/dsk/dks0d2s0 (988092 blks)
VE root_vol.data.1.0    [active]
&ensp;       start=0, end=988091, (cat)grp_size=1
&ensp;       /dev/dsk/dks0d2s7 (988092 blks)
</PROGRAMLISTING>
<PARA>This example shows one high-level object, a volume with two plexes in a data subvolume (<FILENAME>root_vol.data.0</FILENAME> and <FILENAME>root_vol.data.1</FILENAME>). Each plex has one volume element.</PARA>
</LISTITEM>
<LISTITEM><PARA>If the element you want to delete is not a high-level object, you must first detach it from its high-level object. For example, to delete one of the plexes in the example, it must first be detached:</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>detach plex root_vol.data.1 plex_to_be_deleted</USERINPUT>
</PROGRAMLISTING>
<PARA>Detached objects must be given a name, in this case <FILENAME>plex_to_be_deleted</FILENAME>.</PARA>
</LISTITEM>
<LISTITEM><PARA>Delete the object, in this example the plex <FILENAME>plex_to_be_deleted</FILENAME>:</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>delete object plex_to_be_deleted</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Confirm that the object is gone:</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>show -long all</USERINPUT>
VOL root_vol (complete)
VE root_vol.data.0.0    [active]
&ensp;       start=0, end=988091, (cat)grp_size=1
&ensp;       /dev/dsk/dks0d2s0 (988092 blks)
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Exit <COMMAND>xlv_mgr</COMMAND>:</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>quit</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
</ORDEREDLIST>
</SECTION>
<SECTION  ID="LE74045-PARENT"><TITLE  ID="LE74045-TITLE">Removing and Mounting a Plex</TITLE><CAUTION><PARA>The procedure in this section can result in the loss of data if it is not performed properly. It is recommended only for experienced IRIX system administrators.</PARA>
</CAUTION>
<PARA><INDEXTERM ID="ITch4-37"><PRIMARY>plexes</PRIMARY>
<SECONDARY>removing</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-38"><PRIMARY>plexes</PRIMARY>
<SECONDARY>mounting</SECONDARY>
</INDEXTERM>
You can get a snapshot of a filesystem by removing a plex from a plexed volume and mounting that plex separately. Because you can only mount volumes, you must convert the plex into a volume. The following procedure shows you how to remove the plex from its original volume and make it into a separate volume:</PARA>
<ORDEREDLIST><LISTITEM><PARA><INDEXTERM ID="ITch4-39"><PRIMARY><COMMAND>xlv_plexd</COMMAND>
 daemon</PRIMARY>
</INDEXTERM>
Verify that the volume is currently not being revived. If there is a revive in progress, wait until the revive is done because the data among the plexes is not identical until after the plex revive is done.</PARA>
<PROGRAMLISTING>
# <USERINPUT>ps -ef | grep xlv_plexd</USERINPUT>
&ensp;   root    35     1  0   Dec 13 ?        0:00 /sbin/xlv_plexd -m 4 
</PROGRAMLISTING>
<PARA>The output shows that just one copy of <COMMAND>xlv_plexd</COMMAND>, the master process, is running. If more than one copy is running, a plex revive is in progress.</PARA>
</LISTITEM>
<LISTITEM><PARA>Unmount the filesystem mounted on the logical volume, <FILENAME>/projvol5</FILENAME> in this example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>umount /projvol5</USERINPUT>&ensp;
</PROGRAMLISTING>
<PARA>Unmounting the filesystem puts it into a clean state.</PARA>
</LISTITEM>
<LISTITEM><PARA>Start <COMMAND>xlv_mgr</COMMAND> and display the logical volume, <FILENAME>xfs-mp5</FILENAME> in this example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_mgr</USERINPUT>
xlv_mgr&gt; <USERINPUT>show object xfs-mp5</USERINPUT>
VOL xfs-mp5 (complete)
VE xfs-mp5.log.0.0 [active]
&ensp;       start=0, end=8255, (cat)grp_size=1
&ensp;       /dev/dsk/dks1d2s15 (8256 blks)
VE xfs-mp5.log.1.0 [active]
&ensp;       start=0, end=8255, (cat)grp_size=1
&ensp;       /dev/dsk/dks1d3s15 (8256 blks)
VE xfs-mp5.data.0.0 [active]
&ensp;       start=0, end=3920223, (cat)grp_size=1
&ensp;       /dev/dsk/dks1d2s7 (3920224 blks)
VE xfs-mp5.data.0.1 [active]
&ensp;       start=3920224, end=7848703, (cat)grp_size=1
&ensp;       /dev/dsk/dks1d4s7 (3928480 blks)
VE xfs-mp5.data.1.0 [active]
&ensp;       start=0, end=3920223, (cat)grp_size=1
&ensp;       /dev/dsk/dks1d3s7 (3920224 blks)
VE xfs-mp5.data.1.1 [active]
&ensp;       start=3920224, end=7848703, (cat)grp_size=1
&ensp;       /dev/dsk/dks1d5s7 (3928480 blks)
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Detach the second plex from the log subvolume and call it <FILENAME>log_copy</FILENAME>:</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>detach plex xfs-mp5.log.1 log_copy</USERINPUT>
</PROGRAMLISTING>
<PARA>One of the plexes from the log subvolume must be detached because the volume that will be created with one of the data plexes must have a log subvolume to go with it.</PARA>
</LISTITEM>
<LISTITEM><PARA>Detach the second plex from the data subvolume and call it <FILENAME>data_copy</FILENAME>:</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>detach plex xfs-mp5.data.1 data_copy</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Display all of the high-level objects to verify that there are now one volume and two plexes:</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>show all</USERINPUT>
Volume:         xfs-mp5 (complete)
Plex:           log_copy
Plex:           data_copy
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Invoke the <COMMAND>delete</COMMAND> command for each detached plex:</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>delete object log_copy</USERINPUT>
Object log_copy deleted.

xlv_mgr&gt; <USERINPUT>delete object data_copy</USERINPUT>
Object data_copy deleted.
</PROGRAMLISTING>
<PARA>The <COMMAND>delete</COMMAND> command changes the XLV logical volume information in the volume headers, but does not touch the data in the partitions.</PARA>
</LISTITEM>
<LISTITEM><PARA>Exit <COMMAND>xlv_mgr</COMMAND>:</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>quit</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Make the partitions from the detached plexes into a volume:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_make</USERINPUT>
xlv_make&gt; <USERINPUT>vol copy</USERINPUT>
copy
xlv_make&gt; <USERINPUT>log</USERINPUT>
copy.log
xlv_make&gt; <USERINPUT>ve dks1d3s15</USERINPUT>
copy.log.0.0
xlv_make&gt; <USERINPUT>data</USERINPUT>
copy.data
xlv_make&gt; <USERINPUT>ve dks1d3s7</USERINPUT>
copy.data.0.0
xlv_make&gt; <USERINPUT>ve dks1d5s7</USERINPUT>
copy.data.0.1
xlv_make&gt; <USERINPUT>end</USERINPUT>
Object specification completed
xlv_make&gt; <USERINPUT>exit</USERINPUT>
Newly created objects will be written to disk.
Is this what you want?(yes) <USERINPUT>&ensp;yes</USERINPUT>&ensp;
Invoking xlv_assemble
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Mount the new volume. The filesystem is still intact, so <COMMAND>mkfs</COMMAND> is not used (using <COMMAND>mkfs</COMMAND> would erase the data). </PARA>
<PROGRAMLISTING>
# <USERINPUT>mkdir /copy</USERINPUT>
# <USERINPUT>mount /dev/xlv/copy /copy</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Remount the original filesystem:</PARA>
<PROGRAMLISTING>
# <USERINPUT>mount /dev/xlv/xfs-mp5 /projvol5</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Use the <COMMAND>ls</COMMAND> command to confirm that the files on the original volume also appear on the new volume that you created from the removed plex.</PARA>
<PROGRAMLISTING>
# <USERINPUT>ls /copy</USERINPUT>
autoconfig  chroot      config      cron.d
chkconfig   clri        cron        fstab
# <USERINPUT>ls /projvol5</USERINPUT>
autoconfig  chroot      config      cron.d
chkconfig   clri        cron        fstab
</PROGRAMLISTING>
</LISTITEM>
</ORDEREDLIST>
</SECTION>
<SECTION  ID="LE26208-PARENT"><TITLE  ID="LE26208-TITLE"><INDEXTERM ID="ITch4-40"><PRIMARY>disk drives</PRIMARY>
<SECONDARY>replacing for a plexed volume</SECONDARY>
</INDEXTERM>
Replacing a Disk For a Plexed Volume</TITLE><PARA>The procedure described in this section outlines the steps you must take when you find you need to replace a disk that contains a part of a plexed volume element. The example used is for a disk in an Origin Vault enclosure that is used for a plexed volume element. If you have a different disk setup, the XLV commands will be the same, although the specific procedures for physically replacing a disk will differ.</PARA>
<PARA>In summary, to replace a disk for a plexed volume, perform the following steps:</PARA>
<ORDEREDLIST><LISTITEM><PARA>Remove the volume element with the broken disk from XLV</PARA>
</LISTITEM>
<LISTITEM><PARA>Physically replace the disk drive</PARA>
</LISTITEM>
<LISTITEM><PARA>Remake the XLV volume element using the new drive</PARA>
</LISTITEM>
</ORDEREDLIST>
<PARA>These steps are detailed in the following sections.</PARA>
<SECTION><TITLE>Remove the Volume Element From XLV</TITLE><PARA>This example assumes an Origin Vault enclosure. In this example, the failed disk is drive ID 6 in Origin Vault 1 (dks2d6s7), which is in vol2 (plex 0). This example also assumes that there are two plexes, and that each plex has only a single volume element. The sample commands provided are for this specific disk failure example.</PARA>
<ORDEREDLIST><LISTITEM><PARA>Delete the plex (or volume element) containing the broken disk from the volume (in this case <FILENAME>vol2</FILENAME>). This command sequence detaches the plex and renames it <FILENAME>badplex</FILENAME>.</PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_mgr</USERINPUT>
xlv_mgr&gt; <USERINPUT>detach plex vol2.data.0 badplex</USERINPUT>
</PROGRAMLISTING>
<PARA>If the deletion is successful, go to <XREF LINKEND="LE29512-PARENT"> and continue with the procedure described there. If the failed disk is unresponsive and the detachment fails, continue with step 2.</PARA></LISTITEM>
<LISTITEM><PARA>Execute the following commands. The <COMMAND>-force</COMMAND> option performs a detach operation when the parent object is missing any pieces.</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>detach -force plex vol2.data.0 badplex</USERINPUT>
xlv_mgr&gt; <USERINPUT>delete object badplex</USERINPUT>
</PROGRAMLISTING>
<PARA>If the deletion is successful at this point, go to <XREF LINKEND="LE29512-PARENT"> and continue with the procedure described there. If the failed disk is unresponsive and the detachment fails, continue with step 3.</PARA></LISTITEM>
<LISTITEM><PARA>Unmount the filesystem, killing processes that have open files.</PARA>
<PROGRAMLISTING>
# <USERINPUT>unmount -k /fs2</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Save the volume configuration, using the <COMMAND>-write</COMMAND> option of the <COMMAND>xlv_mgr script</COMMAND> command. You will need this information when you remake your volume, as described in step 6.</PARA>
<PARA>The <COMMAND>xlv_mgr script</COMMAND> command displays the <COMMAND>xlv_make(1M)</COMMAND> commands you need to create the volume. See the <COMMAND>xlv_mgr(1M)</COMMAND> man page for further information. The <COMMAND>-write</COMMAND> option saves the commands into the specified file location; you do not need to use this option if you record the command output yourself. </PARA>
<PARA>If <COMMAND>xlv_mgr</COMMAND> cannot read the XLV label off of the disk, the <COMMAND>script</COMMAND> command may not work. In this case, you will need to use the volume configuration information you saved as part of regular system backup and maintenance.</PARA>
</LISTITEM>
<LISTITEM><PARA>Delete the volume object:</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>delete object vol2</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Remake the volume without the broken disk.</PARA>
<PARA>In this example, the volume <FILENAME>v2</FILENAME> was created with the following command sequence:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_make</USERINPUT>
xlv_make&gt; <USERINPUT>vol2</USERINPUT>
xlv_make&gt; <USERINPUT>data</USERINPUT>
xlv_make&gt; <USERINPUT>plex</USERINPUT>
xlv_make&gt; <USERINPUT>ve dks2d6s7</USERINPUT>
xlv_make&gt; <USERINPUT>plex</USERINPUT>
xlv_make&gt; <USERINPUT>ve dks3d6s7</USERINPUT>
xlv_make&gt; <USERINPUT>end</USERINPUT>
xlv_make&gt; <USERINPUT>exit</USERINPUT>
To remake the volume without the broken disk, execute the following command sequence:
# <USERINPUT>xlv_make</USERINPUT>
xlv_make&gt; <USERINPUT>vol2</USERINPUT>
xlv_make&gt; <USERINPUT>data</USERINPUT>
xlv_make&gt; <USERINPUT>plex</USERINPUT>
xlv_make&gt; <USERINPUT>ve dks3d6s7</USERINPUT>
xlv_make&gt; <USERINPUT>end</USERINPUT>
xlv_make&gt; <USERINPUT>exit</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
</ORDEREDLIST>
</SECTION>
<SECTION  ID="LE29512-PARENT"><TITLE  ID="LE29512-TITLE">Physically Replace the Disk Drive</TITLE><PARA>Use the following procedure to replace the disk drive in an Origin Vault enclosure. You must turn the power off to be sure that the bus is quiet while you are replacing the disk. Inserting a disk while there is bus traffic can cause data corruption.</PARA>
<ORDEREDLIST><LISTITEM><PARA>Identify the enclosure with the failed drive (Origin Vault 1 in this example).</PARA>
</LISTITEM>
<LISTITEM><PARA>Turn off power to Origin Vault 1.</PARA>
</LISTITEM>
<LISTITEM><PARA>Wait 10 seconds. This wait time is important, as it ensures the failed drive does not receive additional damage.</PARA>
</LISTITEM>
<LISTITEM><PARA>Physically remove the failed disk drive and install the replacement disk.</PARA>
</LISTITEM>
<LISTITEM><PARA>Power the Origin Vault 1 back on.</PARA>
</LISTITEM>
</ORDEREDLIST>
<PARA>If I/O writes occur to <FILENAME>vol1</FILENAME> in Origin Vault 2 during the time that Origin Vault 1 is powered off, then <FILENAME>vol1</FILENAME> will need to be updated. Use <COMMAND>xlv_mgr</COMMAND> to determine if part of <FILENAME>vol1</FILENAME> is outdated or [<FILENAME>offline</FILENAME>] by entering the following command:</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>show kernel</USERINPUT>
</PROGRAMLISTING>
<PARA>If the output shows [<FILENAME>offline</FILENAME>], the disk ID5 in Origin Vault 1 contains outdated data. If part of <FILENAME>vol1</FILENAME> is [<FILENAME>offline</FILENAME>], use <COMMAND>xlv_mgr</COMMAND> to put the affected volume element back on line.</PARA>
<PARA>In this example, drive dks2d5s7 would have been [<FILENAME>offline</FILENAME>] due to the power outage. This drive is plex 0 of volume 1. Enter the command:</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>change online vol1.data.0.0</USERINPUT>
</PROGRAMLISTING>
<PARA>You may also be able to use the warm-plug feature to replace the disk drive. For information on this feature, see the <COMMAND>scsiadminswap</COMMAND>(1M), <COMMAND>scsihotswap</COMMAND>(1M), and the <COMMAND>scsiquiesce</COMMAND>(1M) man pages.</PARA>
</SECTION>
<SECTION><TITLE>Remake the XLV Volume Element Using the New Drive</TITLE><PARA>Perform the following steps to provide the replacement drive with the XLV volume elements you are restoring.</PARA>
<ORDEREDLIST><LISTITEM><PARA>Use the <COMMAND>fx</COMMAND>(1M) command to partition the new drive. It is essential that the new drive be repartitioned exactly as the failed drive.</PARA>
</LISTITEM>
<LISTITEM><PARA>Create a plex (volume element) on the new disk drive.</PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_make</USERINPUT>
xlv_make&gt; <USERINPUT>plex newplexname</USERINPUT>
xlv_make&gt; <USERINPUT>ve dks2d6s7</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Attach the plex (or attach/insert the ve) back to the volume.</PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_mgr</USERINPUT>
xlv_mgr&gt; <USERINPUT>attach plex newplexname vol2.data</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
</ORDEREDLIST>
</SECTION>
</SECTION>
<SECTION  ID="LE27814-PARENT"><TITLE  ID="LE27814-TITLE">Creating a Plexed XLV Logical Volume for Root</TITLE><CAUTION><PARA>The procedure in this section can result in the loss of data if it is not performed properly. It is recommended only for experienced IRIX system administrators.</PARA>
</CAUTION>
<PARA><INDEXTERM ID="ITch4-41"><PRIMARY>plexes</PRIMARY>
<SECONDARY>for root filesystem</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-42"><PRIMARY>root filesystem</PRIMARY>
<SECONDARY>on plexed logical volume</SECONDARY>
</INDEXTERM>
You can put your root filesystem on a plexed volume for greater reliability. A plexed root volume allows your system to continue running even if one of the root disks fails. If there is a separate <FILENAME>usr</FILENAME> filesystem on the system disk, it should be plexed, too. Because the swap partition may be unavailable if the root disk fails, a spare swap partition should be available on a different disk. Administering the plexes of the root and, if present, <FILENAME>usr</FILENAME> volumes and the swap partitions, is easiest if each disk used in the volumes is identical and is partitioned identically.</PARA>
<PARA>The root volume can contain only a data subvolume. Each plex of the data subvolume can contain only a single volume element. The volume element must contain a single disk partition.</PARA>
<PARA>The root filesystem can be either an EFS filesystem or an XFS filesystem with an internal log.</PARA>
<PARA>Use the following procedure to create a plexed root volume. It assumes that you are starting with a working system (not a system with an empty system disk).</PARA>
<ORDEREDLIST><LISTITEM><PARA>Make the root partition into an XLV volume. In this example, the XLV volume is called <FILENAME>xlv_root</FILENAME>:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_make</USERINPUT>
xlv_make&gt; <USERINPUT>vol xlv_root</USERINPUT>
xlv_root
xlv_make&gt; <USERINPUT>data</USERINPUT>
xlv_root.data
xlv_make&gt; <USERINPUT>ve -force /dev/dsk/dks0d1s0</USERINPUT>
xlv_root.data.0.0
xlv_make&gt; <USERINPUT>end</USERINPUT>
Object specification completed
xlv_make&gt; <USERINPUT>exit</USERINPUT>
Newly created objects will be written to disk.
Is this what you want?(yes)  <USERINPUT>yes</USERINPUT>
Invoking xlv_assemble
</PROGRAMLISTING>
<PARA>The result is an XLV volume named <FILENAME>xlv_root</FILENAME> that contains the root partition. Because XLV preserves the data in partitions, the contents of the root partition are preserved. The <COMMAND>-force</COMMAND> option to the <COMMAND>ve</COMMAND> command was used because a mounted partition was included in the volume.</PARA>
</LISTITEM>
<LISTITEM><PARA>Reboot the system so that the system switches from running off the root partition at <FILENAME>/dev/dsk/dks0d1s0</FILENAME> to running off the logical volume <FILENAME>/dev/xlv/xlv_root</FILENAME>:</PARA>
<PROGRAMLISTING>
# <USERINPUT>reboot</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>You can confirm that the root volume is being used by comparing the major and minor device numbers of <FILENAME>/dev/root</FILENAME> and <FILENAME>/dev/xlv/xlv_root</FILENAME>:</PARA>
<PROGRAMLISTING WIDTH="wide">
# <USERINPUT>ls -l /dev/root /dev/xlv/xlv_root</USERINPUT>
brw-------    2 root     sys      192,  0 Oct 31 17:58 /dev/root
brw-------    2 root     sys      192,  0 Dec 12 17:58 /dev/xlv/xlv_root
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Create the second plex, for example, out of <FILENAME>/dev/dsk/dks0d2s0</FILENAME>, and call the plex <FILENAME>root_plex1</FILENAME>: </PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_make</USERINPUT>
xlv_make&gt; <USERINPUT>plex root_plex1</USERINPUT>
root_plex1
xlv_make&gt; <USERINPUT>ve /dev/dsk/dks0d2s0</USERINPUT>
root_plex1.0
xlv_make&gt; <USERINPUT>end</USERINPUT>
Object specification completed
xlv_make&gt; <USERINPUT>exit</USERINPUT>
Newly created objects will be written to disk.
Is this what you want?(yes)  <USERINPUT>yes</USERINPUT>
Invoking xlv_assemble
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Add <COMMAND>sash</COMMAND> to the volume header of the disk used for the second plex. It enables booting off of the alternate plex if the primary plex fails.</PARA>
<PROGRAMLISTING>
# <USERINPUT>dvhtool -v get sash /tmp/sash /dev/rdsk/dks0d1vh</USERINPUT>
# <USERINPUT>dvhtool -v add /tmp/sash sash /dev/rdsk/dks0d2vh</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Attach the second plex to the volume using <COMMAND>xlv_mgr</COMMAND> and quit out of <COMMAND>xlv_mgr</COMMAND>: </PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_mgr</USERINPUT>
xlv_mgr&gt; <USERINPUT>attach plex root_plex1 xlv_root.data</USERINPUT>
xlv_mgr&gt; <USERINPUT>quit</USERINPUT>
</PROGRAMLISTING>
<PARA>When the shell prompt returns, the system automatically begins a plex revive so that the two plexes contain the same data. </PARA>
</LISTITEM>
</ORDEREDLIST>
</SECTION>
<SECTION  ID="LE96082-PARENT"><TITLE  ID="LE96082-TITLE">Booting the System Off an Alternate Plex</TITLE><PARA><INDEXTERM ID="ITch4-43"><PRIMARY>root filesystem</PRIMARY>
<SECONDARY>booting off an alternate plex</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-44"><PRIMARY>plexes</PRIMARY>
<SECONDARY>booting off alternate root</SECONDARY>
</INDEXTERM>
Once you plex the root volumes, you can boot off a secondary plex if the primary plex becomes unavailable. Because the boot PROM does not understand XLV logical volumes, you must manually reconfigure the system to boot the system from the disk that contains the alternate plex. The procedure for booting the system off a secondary plex depends on the model of workstation or server. The following subsection, <XREF LINKEND="LE81400-TITLE"> applies to those systems. For all other workstations and servers, including the Origin2000 server, follow the procedure in the subsection, <XREF LINKEND="LE92509-PARENT">.</PARA><SECTION  ID="LE81400-PARENT"><TITLE  ID="LE81400-TITLE">CHALLENGE L, CHALLENGE XL, and CHALLENGE DM</TITLE><PARA>With CHALLENGE L, XL, and DM systems, it is possible to change the drive addresses of disks using a dial or switch. If the system disk and the alternate disk are both internal disks on the same channel and are partitioned identically, you can swap the drive addresses of the two disks. (If the system does not meet these requirements, use the procedure in <XREF LINKEND="LE92509-PARENT"> instead.) By exchanging the drive addresses for the system disk and the alternate disk, the system automatically boots off the alternate disk, which has become the new system disk. Follow this procedure:</PARA><ORDEREDLIST><LISTITEM><PARA>Shut down the system. For example, use this command:</PARA>
<PROGRAMLISTING>
# <USERINPUT>shutdown</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Power off the system.</PARA>
</LISTITEM>
<LISTITEM><PARA>By manipulating the switches or dials on the system disk and the alternate disk, change each disk's drive address to the other's drive address.</PARA>
</LISTITEM>
<LISTITEM><PARA>Power up the system.</PARA>
</LISTITEM>
</ORDEREDLIST>
</SECTION>
<SECTION  ID="LE92509-PARENT"><TITLE  ID="LE92509-TITLE">All Other Models</TITLE><PARA>The following procedure describes how to boot the system off the alternate root plex and can be used on all system. In the example used in this procedure, the system is reconfigured to boot off the partition <FILENAME>/dev/dsk/dks0d2s0</FILENAME> and use partition <FILENAME>/dev/dsk/dks0d2s1</FILENAME> as swap. Substitute the correct partitions for your system.</PARA>
<ORDEREDLIST><LISTITEM><PARA>On the <INTERFACE>System Maintenance</INTERFACE> menu, choose <LITERAL>Enter Command Monitor</LITERAL>:</PARA>
<PROGRAMLISTING>
...
5) Enter Command Monitor

Option? <USERINPUT>5</USERINPUT>
Command Monitor.  Type &ldquo;exit&rdquo; to return to the menu.
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Display the PROM environment variables:</PARA>
<PROGRAMLISTING>
&gt;&gt; <USERINPUT>printenv</USERINPUT>
SystemPartition=dksc(0,1,8)
OSLoadPartition=dksc(0,1,0)
root=dks0d1s0 
...
</PROGRAMLISTING>
<PARA>The swap PROM environment variable (which is set below) is not displayed because it is not saved in NVRAM.</PARA>
</LISTITEM>
<LISTITEM><PARA>Reset the <LITERAL>SystemPartition</LITERAL>, <LITERAL>OSLoadPartition</LITERAL>, and <LITERAL>root</LITERAL> environment variables to have the values of the disk partition that contains the alternate plex and the swap environment variable to have the value of the alternate swap partition:</PARA>
<PROGRAMLISTING>
&gt;&gt; <USERINPUT>setenv SystemPartition dksc(0,2,8)</USERINPUT>
&gt;&gt; <USERINPUT>setenv OSLoadPartition dksc(0,2,0)</USERINPUT>
&gt;&gt; <USERINPUT>setenv root dks0d2s0</USERINPUT>
&gt;&gt; <USERINPUT>setenv swap /dev/dsk/dks0d2s1</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Exit the <INTERFACE>Command Monitor</INTERFACE> and restart the system:</PARA>
<PROGRAMLISTING>
&gt;&gt; <USERINPUT>exit</USERINPUT>
...
Option? <USERINPUT>1</USERINPUT>
&ensp;             Starting up the system...
...
</PROGRAMLISTING>
</LISTITEM>
</ORDEREDLIST>
</SECTION>
</SECTION>
<SECTION  ID="LE44185-PARENT"><TITLE  ID="LE44185-TITLE">Configuring the System for More Than Ten XLV Logical Volumes</TITLE><PARA><INDEXTERM ID="ITch4-45"><PRIMARY>XLV logical volumes</PRIMARY>
<SECONDARY>configuring system for more than ten</SECONDARY>
</INDEXTERM>
By default, a system can have up to ten XLV logical volumes. To increase the number of XLV logical volumes supported, you modify the file <FILENAME>/var/sysgen/master.d/xlv</FILENAME>. The procedure is:</PARA>
<ORDEREDLIST><LISTITEM><PARA>Using any editor, open the file <FILENAME>/var/sysgen/master.d/xlv</FILENAME>, for example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>vi /var/sysgen/master.d/xlv</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Find this line in the file:</PARA>
<PROGRAMLISTING>
#define XLV_MAXVOLS 10
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Change the <LITERAL>10</LITERAL> in this line to a higher number of your choice, for example:</PARA>
<PROGRAMLISTING>
#define XLV_MAXVOLS 20
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Write the file and quit the editor.</PARA>
</LISTITEM>
<LISTITEM><PARA>Generate a new kernel:</PARA>
<PROGRAMLISTING>
# <USERINPUT>/etc/autoconfig</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Reboot the system to make the change take effect:</PARA>
<PROGRAMLISTING>
# <USERINPUT>reboot</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
</ORDEREDLIST>
</SECTION>
<SECTION  ID="LE45331-PARENT"><TITLE  ID="LE45331-TITLE">Converting lv Logical Volumes to XLV Logical Volumes</TITLE><PARA><INDEXTERM ID="ITch4-46"><PRIMARY><COMMAND>lv</COMMAND>
 logical volumes</PRIMARY>
<SECONDARY><COMMAND>converting to XLV</COMMAND>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-47"><PRIMARY>XLV logical volumes</PRIMARY>
<SECONDARY>converting <COMMAND>lv</COMMAND>
 logical volumes</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch4-48"><PRIMARY><COMMAND>lv_to_xlv</COMMAND>
 command</PRIMARY>
</INDEXTERM>
This section explains the procedure for converting <COMMAND>lv</COMMAND> logical volumes to XLV logical volumes. The files on the logical volumes are not modified or dumped during the conversion. You must be superuser to perform this procedure.</PARA>
<ORDEREDLIST><LISTITEM><PARA>Choose new names for the logical volumes, if desired. XLV, unlike <COMMAND>lv</COMMAND>, only requires names to be valid filenames (except periods are not allowed in XLV names), so you can choose more meaningful names. For example, you can make the volume names the same as the mount points you use. If you mount logical volumes at <FILENAME>/a</FILENAME>, <FILENAME>/b</FILENAME>, and <FILENAME>/c</FILENAME>, you can name the XLV volumes <LITERAL>a</LITERAL>, <LITERAL>b</LITERAL>, and <LITERAL>c</LITERAL>. </PARA>
</LISTITEM>
<LISTITEM><PARA>Unmount all <COMMAND>lv</COMMAND> logical volumes that you plan to convert to XLV logical volumes. For example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>umount /a</USERINPUT>&ensp;
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Create an input script for <COMMAND>xlv_make</COMMAND> by using <COMMAND>lv_to_xlv</COMMAND>:</PARA>
<PROGRAMLISTING>
# <USERINPUT>lv_to_xlv -o </USERINPUT><REPLACEABLE>scriptfile</REPLACEABLE>&ensp;
</PROGRAMLISTING>
<PARA><REPLACEABLE>scriptfile</REPLACEABLE> is the name of a temporary file that<COMMAND>&ensp;lv_to_xlv</COMMAND> creates, for example <FILENAME>/usr/tmp/xlv.script</FILENAME>. It contains a series of <COMMAND>xlv_make</COMMAND> commands that can be used to create XLV volumes that are equivalent to the <COMMAND>lv</COMMAND> logical volumes listed in <FILENAME>/etc/lvtab</FILENAME>.</PARA>
</LISTITEM>
<LISTITEM><PARA>If you want to change the volume names, edit <REPLACEABLE>scriptfile</REPLACEABLE> and replace the names on the lines that begin with <LITERAL>vol</LITERAL> with the new names. For example, change:</PARA>
<PROGRAMLISTING>
vol lv0 
</PROGRAMLISTING>
<PARA>to:</PARA>
<PROGRAMLISTING>
<LITERAL>vol a </LITERAL>
</PROGRAMLISTING>
<PARA>The volume name can be any name that is a valid filename.</PARA>
</LISTITEM>
<LISTITEM><PARA>By default, all <COMMAND>lv</COMMAND> logical volumes on the system are converted to XLV. If you do not want all <COMMAND>lv</COMMAND> logical volumes converted to XLV, edit <REPLACEABLE>scriptfile</REPLACEABLE> and remove the <COMMAND>xlv_make</COMMAND> commands for the volumes that you do not want to change. See <XREF LINKEND="LE25568-PARENT"> and the <COMMAND>xlv_make(1M)</COMMAND> reference page for more information.</PARA>
</LISTITEM>
<LISTITEM><PARA>Create the XLV volumes by running <COMMAND>xlv_make</COMMAND> with <REPLACEABLE>scriptfile</REPLACEABLE> as input:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_make</USERINPUT>&ensp;<REPLACEABLE>scriptfile</REPLACEABLE>&ensp;
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>If you converted all <COMMAND>lv</COMMAND> logical volumes to XLV, remove <FILENAME>/etc/lvtab</FILENAME>:</PARA>
<PROGRAMLISTING>
# <USERINPUT>rm /etc/lvtab</USERINPUT>&ensp;
</PROGRAMLISTING>
<PARA>If you converted only some of the <COMMAND>lv</COMMAND> logical volumes to XLV, open <FILENAME>/etc/lvtab</FILENAME> for editing to begin removing the entries for the logical volumes you converted.</PARA>
<PROGRAMLISTING>
# <USERINPUT>vi /etc/lvtab</USERINPUT>&ensp;
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA><INDEXTERM ID="ITch4-49"><PRIMARY><FILENAME>/etc/fstab</FILENAME>
 file</PRIMARY>
<SECONDARY><FILENAME>entries for XLV logical volumes</FILENAME>
</SECONDARY>
</INDEXTERM>
Edit <FILENAME>/etc/fstab</FILENAME> so that it automatically mounts the XLV logical volumes at startup. These changes to <FILENAME>/etc/fstab</FILENAME> are required for each XLV logical volume:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA>In the first field, insert the subdirectory <FILENAME>xlv</FILENAME> after <FILENAME>/dev/dsk</FILENAME>.</PARA>
</LISTITEM>
<LISTITEM><PARA>If you changed the name of the volume, for example from<FILENAME>&ensp;lv0</FILENAME> to <FILENAME>a</FILENAME>, make the change in the first field.</PARA>
</LISTITEM>
<LISTITEM><PARA>Insert the subdirectory <FILENAME>xlv</FILENAME> into the raw device name.</PARA>
</LISTITEM>
<LISTITEM><PARA>If you changed the name of the volume, for example from <FILENAME>lv0</FILENAME> to <FILENAME>a</FILENAME>, make the change in the raw device.</PARA>
<PARA>For example, if an original line is:</PARA>
<PROGRAMLISTING>
/dev/dsk/lv0   /a efs rw,raw=/dev/rdsk/lv0 0 0
</PROGRAMLISTING>
<PARA>the changed line, including the name change, is:</PARA>
<PROGRAMLISTING>
/dev/xlv/a /a efs rw,raw=/dev/rxlv/a 0 0 
</PROGRAMLISTING>
</LISTITEM>
</ITEMIZEDLIST>
</LISTITEM>
<LISTITEM><PARA>Mount the XLV logical volume, for example:</PARA>
<PROGRAMLISTING>
# <USERINPUT>mount /a</USERINPUT>&ensp;
</PROGRAMLISTING>
</LISTITEM>
</ORDEREDLIST>
</SECTION>
<SECTION  ID="LE80348-PARENT"><TITLE  ID="LE80348-TITLE">Creating a Record of XLV Logical Volume Configurations</TITLE><PARA><INDEXTERM ID="ITch4-50"><PRIMARY>XLV logical volumes</PRIMARY>
<SECONDARY>recording configuration</SECONDARY>
</INDEXTERM>
Information about XLV objects, volumes, subvolumes, plexes, and volume elements, is stored in logical volume labels in the volume header of each disk that contains an XLV object (see <XREF LINKEND="LE18926-TITLE"> for more information). If an XLV logical volume label is removed, the system is unable to assemble the logical volume that includes that logical volume label, although the data in the object described in the logical volume label is still present. You can recreate the logical volume label with <COMMAND>xlv_make</COMMAND>, but only if you remember the exact configuration of the affected logical volume. The <COMMAND>xlv_mgr</COMMAND> command can be used to create a script that records the exact configuration of each logical volume on the system. This script can be given to <COMMAND>xlv_make</COMMAND> as input at a later time if it is ever necessary to recreate any XLV logical volumes on the system.</PARA>
<PARA><INDEXTERM ID="ITch4-51"><PRIMARY>scripting XLV configurations</PRIMARY>
</INDEXTERM>
To create a record of the exact configuration of each XLV logical volume on the system, follow this procedure:</PARA>
<ORDEREDLIST><LISTITEM><PARA>Start the <COMMAND>script</COMMAND> command, which begins capturing text on the screen, and put the captured text in the file <FILENAME>/var/config/XLV.configuration</FILENAME>:</PARA>
<PROGRAMLISTING>
# <USERINPUT>script /var/config/XLV.configuration</USERINPUT>
Script started, file is XLV.configuration
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Start <COMMAND>xlv_mgr</COMMAND>:</PARA>
<PROGRAMLISTING>
# <USERINPUT>xlv_mgr</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Give the <COMMAND>script -write</COMMAND> command to <COMMAND>xlv_mgr</COMMAND> with the name of a file that will contain the configuration information, for example <FILENAME>/var/config/XLV.configuration</FILENAME>:</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>script -write /var/config/XLV.configuration</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Exit <COMMAND>xlv_mgr</COMMAND>:</PARA>
<PROGRAMLISTING>
xlv_mgr&gt; <USERINPUT>quit</USERINPUT>
</PROGRAMLISTING>
</LISTITEM>
<LISTITEM><PARA>Check the contents of the file that contains the configuration:</PARA>
<PROGRAMLISTING>
# <USERINPUT>cat /var/config/XLV.confguration</USERINPUT>
#
# Create Volume proj_vol
#
vol proj_vol
data
plex
ve   -force -start 0 /dev/dsk/dks1d3s11 /dev/dsk/dks1d3s12
plex
ve   -force -start 0 /dev/dsk/dks1d6s2 /dev/dsk/dks1d6s3
end
exit
</PROGRAMLISTING>
</LISTITEM>
</ORDEREDLIST>
</SECTION>
</CHAPTER>
