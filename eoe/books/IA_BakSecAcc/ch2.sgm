<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="2"><TITLE><XREFTARGET ID="97003">Backup and Recovery Procedures</TITLE><PARAGRAPH>This chapter provides examples of how to use the various backup and recover tools described in <XREF IDREF="80826" TYPE="TITLE">Chapter&nbsp;1</XREF>.</PARAGRAPH>
<PARAGRAPH>All of the utilities discussed in this chapter support more options than can be shown here, but the examples combined with the discussions in <XREF IDREF="80826" TYPE="TITLE">Chapter&nbsp;1</XREF> should provide enough information for you to choose and begin to use the tools best suited for your environment.</PARAGRAPH>
<PARAGRAPH>For a complete description of the options available with a particular tool, refer to the reference page for that tool (for example, see <REFPAGE>tar(1)</REFPAGE> for the <COMMAND>tar</COMMAND> command).</PARAGRAPH>
<PARAGRAPH>This chapter is divided into the following sections:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="48598" TYPE="TITLE">&ldquo;General Backup Procedure&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="80227" TYPE="TITLE">&ldquo;Recovering Data After System Corruption&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="65576" TYPE="TITLE">&ldquo;Changing the Default Backup Device&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="99601" TYPE="TITLE">&ldquo;Saving Files Using Data Compression&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="24574" TYPE="TITLE">&ldquo;Backup and Restore Utilities&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="37829" TYPE="TITLE">&ldquo;About dump and restore&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="65445" TYPE="TITLE">&ldquo;About xfsdump and xfsrestore&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="53826" TYPE="TITLE">&ldquo;About tar&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="85662" TYPE="TITLE">&ldquo;About cpio&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="90789" TYPE="TITLE">&ldquo;About dd&rdquo;</XREF></PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="48598">General Backup Procedure</TITLE><PARAGRAPH>Follow these steps when making a backup, no matter which backup utility you use:&space;<INDEXTARGET ID="ch21"><!-- POSTPROCESSDATA: ch21|backups:making --></PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Make sure the tape drive is clean. The hardware manual that came with your drive should state how, and how often, to clean the drive.</PARAGRAPH>
<PARAGRAPH>Dirty tape heads can cause read and write errors. New tapes shed more oxide than older tapes, so you should clean your drive more frequently if you use a lot of new tapes. </PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Make sure you have enough backup media on hand. You can use utilities such as <REFPAGE>du(1M)</REFPAGE> and <REFPAGE>df(1)</REFPAGE> to determine the size of directories and filesystems, respectively. </PARAGRAPH>
<PARAGRAPH>Also, use good-quality media. Considering the value of your data, use the best quality media you can afford. </PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Run <REFPAGE>fsck(1M)</REFPAGE> first on EFS filesystems (if you are backing up an entire filesystem) to make sure you do not create a tape of a damaged filesystem. You must unmount a filesystem before checking it with <COMMAND>fsck</COMMAND>, so plan your backup schedule accordingly.</PARAGRAPH>
<PARAGRAPH>This step is not necessary if you are backing up only a few files (for example, with <COMMAND>tar</COMMAND>). </PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The default tape device for any drives you may have is <INDEXTARGET ID="ch22"><!-- POSTPROCESSDATA: ch22|tape device, default --><FILENAME>/dev/tape</FILENAME>. If you do not use the default device, you must specify a device in your backup command line.<INDEXTARGET ID="ch23"><!-- POSTPROCESSDATA: ch23|<ITALICS>/dev/tape</ITALICS> --></PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Label your backups. If you plan to reuse the media, use pencil. Include the date, time, name of the system, the name of the utility, the exact command line used to make the backup (so you'll remember how to extract the files later), and a general indication of the contents. If more than one administrator performs backups at your site, include your name.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Verify the backup when you are finished. Some utilities provide explicit options (such as <COMMAND>xfsdump -C</COMMAND>) to verify a backup. With other programs, you can simply list the contents of the archive&mdash;this is usually sufficient to catch errors in the backup.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Write-protect your media after you make the backup.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Note the number of times you use each tape. It's sufficient to keep a running tally on the tape label.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>See <XREF IDREF="44253" TYPE="TITLE">&ldquo;Storage of Backups&rdquo;</XREF> for information on safely storing your backups.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="75293">System Backup Tools</TITLE><PARAGRAPH>To make a backup of your system on any system with a graphical user interface, bring up the System menu on the System Toolchest and choose Backup &amp; Restore. Follow the prompts to perform your backup. A complete set of instructions for this procedure is available in the <INDEXTARGET ID="ch24"><!-- POSTPROCESSDATA: ch24|system backups --><INDEXTARGET ID="ch25"><!-- POSTPROCESSDATA: ch25|Backup and Restore window --><DOCTITLE></DOCTITLE>
<EXTREF IDREF="96534" BOOK="PerSysAdmin" FILE="" HDG="96534" INFO="">Personal System Administration Guide</EXTREF>
<DOCTITLE></DOCTITLE>. </PARAGRAPH>
<PARAGRAPH>Backups made with the Backup &amp; Restore window are the easiest to make and use, and (if they are full system backups) are accessible from the Recover System option on the System Maintenance Menu. When you make a full system backup, the command also makes a backup of the files in the disk volume header and saves the information in a file that is stored on tape. This file is used during system recovery to restore a damaged volume header.</PARAGRAPH>
<PARAGRAPH>To make a backup of your system using an IRIX command, use the <REFPAGE>Backup(1)</REFPAGE> command. Although it is a front-end interface to the <REFPAGE>cpio(1)</REFPAGE> command, <COMMAND>Backup</COMMAND> also writes the disk volume header on the tape so that the Recover System option can reconstruct the boot blocks, which are not written to the tape using other backup commands. For more information, see the section <XREF IDREF="24574" TYPE="TITLE">&ldquo;Backup and Restore Utilities&rdquo;</XREF>.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="80227">Recovering Data After System Corruption<INDEXTARGET ID="ch26"><!-- POSTPROCESSDATA: ch26|recovery:after system corruption --></TITLE><PARAGRAPH>If your root filesystem is damaged and your system cannot boot, you can restore your system from the Recover System option on the System Maintenance Menu. This is the menu that appears when you interrupt the boot sequence before the operating system takes over the system. To perform this recovery, you need two things:<INDEXTARGET ID="ch27"><!-- POSTPROCESSDATA: ch27|system recoveryRecover System --><INDEXTARGET ID="ch28"><!-- POSTPROCESSDATA: ch28|System Maintenance Menu --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Access to a CD that contains the IRIX release on your system.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A full system backup tape (beginning in the root directory (/) and containing all the files and directories on your system) created using the Backup and Restore Manager as described in the section <XREF IDREF="75293" TYPE="TITLE">&ldquo;System Backup Tools&rdquo;</XREF>.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>If you do not have a full system backup made with the <COMMAND>Backup</COMMAND> command or Backup and Restore window&mdash;and your <FILENAME>root</FILENAME> or <FILENAME>usr</FILENAME> filesystems are so badly damaged that the operating system cannot boot&mdash;you have to reinstall your system software and then read your backup tapes (made with any backup tool you prefer) over the freshly installed software. </PARAGRAPH>
<PARAGRAPH>You may also be able to restore filesystems from the miniroot. For example, if your root filesystem has been corrupted, you may be able to boot the miniroot, unmount the root filesystem, and then use the miniroot versions of <COMMAND>restore</COMMAND>, <COMMAND>xfs_restore</COMMAND>, <COMMAND>Restore</COMMAND>, <COMMAND>cpio</COMMAND>, or <COMMAND>tar</COMMAND> to restore your root filesystem. Refer to the following discussions of these commands for details on how to use them.</PARAGRAPH>
<PARAGRAPH>To recover from system corruption using the Recover System option on the System Maintenance Menu, follow these steps:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>When you first start up your machine or press the Reset button on the system, this message appears:</PARAGRAPH>
<CODE>
Starting up the system...
</CODE>
<PARAGRAPH>Click the <BUTTON>Stop for Maintenance</BUTTON> button or press <USERINPUT>Esc</USERINPUT> to bring up the System Maintenance menu.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Click the Recover System icon in the System Maintenance menu, or type:</PARAGRAPH>
<PARAGRAPH><USERINPUT>4</USERINPUT></PARAGRAPH>
<PARAGRAPH>This System Recovery menu appears or you see a graphical equivalent:</PARAGRAPH>
<CODE>
&space;                        System Recovery...

&space;                Press Esc to return to the menu.

1) Remote Tape  2) Remote Directory  3) Local CD-ROM  4) Local Tape  

Enter 1-4 to select source type, Esc to quit,
or Enter to start: 
</CODE>
</LIST>
<LIST><PARAGRAPH>Enter the menu item number or click the appropriate drive icon for the IRIX release CD or software distribution directory you plan to use.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>As of IRIX 6.2, the Remote Tape and Local Tape options on the System Recovery window are no longer usable because bootable (miniroot) software distribution tapes are no longer supported.</NOTE>
<BULLETLISTIND><BULLETSQUAREIND><PARAGRAPH>If you have a CD-ROM drive connected to your system, enter <USERINPUT>3</USERINPUT> or click the <ITALICS>Local CD-ROM</ITALICS> icon, then click <BUTTON>Accept</BUTTON> to start.</PARAGRAPH>
<PARAGRAPH>You then see a notifier prompting you to insert the media into the drive. Insert the IRIX CD that came with your system, then click <BUTTON>Continue</BUTTON>.</PARAGRAPH>
</BULLETSQUAREIND>
<BULLETSQUAREIND><PARAGRAPH>If you don't have a CD-ROM drive, you can use a drive that is connected to another system on the network. At the System Recovery menu, enter <USERINPUT>2</USERINPUT> or click the <ITALICS>Remote Directory</ITALICS> icon. </PARAGRAPH>
<PARAGRAPH>When a notifier appears asking you for the remote hostname, type the system's name, a colon (<USERINPUT>:</USERINPUT>), and the full pathname of the CD-ROM drive, followed by <USERINPUT>/dist</USERINPUT>. For example, to access a CD-ROM drive on the system <ITALICS>mars</ITALICS>, you would type:</PARAGRAPH>
<CODE>
<USERINPUT>mars:/CDROM/dist</USERINPUT>&space;
</CODE>
<PARAGRAPH>Click <BUTTON>Accept</BUTTON> on the notifier window, then click <BUTTON>Accept</BUTTON> on the System Recovery window.</PARAGRAPH>
<PARAGRAPH>On systems without graphics, you are prompted for the host as above, then you see this menu:</PARAGRAPH>
<CODE>
1) Remote Tape 2)[Remote Directory] 3) Local CD-ROM 4) Local Tape  
&space;     *a) Remote directory /CDROM/dist from server mars.

Enter 1-4 to select source type, a to select source, Esc to quit,
or Enter to start: 
</CODE>
<PARAGRAPH>Press <USERINPUT>Enter</USERINPUT>.</PARAGRAPH>
</BULLETSQUAREIND>
<BULLETSQUAREIND><PARAGRAPH>If you are using a remote software distribution directory, enter <USERINPUT>2</USERINPUT> or click the <BUTTON>Remote Directory</BUTTON> icon.</PARAGRAPH>
<PARAGRAPH>When a notifier appears that asks you to enter the name of the remote host, type the system's name, a colon (<USERINPUT>:</USERINPUT>), and the full pathname of the software distribution directory. For example:</PARAGRAPH>
<CODE>
<USERINPUT>mars:/dist/6.2</USERINPUT>&space;
</CODE>
<PARAGRAPH>Click <BUTTON>Accept</BUTTON> on the notifier window, then click <BUTTON>Accept</BUTTON> on the System Recovery window.</PARAGRAPH>
<PARAGRAPH>On systems without graphics, you are prompted for the host as above, then you see this menu:</PARAGRAPH>
<CODE>
1) Remote Tape 2)[Remote Directory] 3) Local CD-ROM 4) Local Tape  
&space;     *a) Remote directory /dist/6.2 from server mars.

Enter 1-4 to select source type, a to select source, Esc to quit,
or Enter to start: 
</CODE>
<PARAGRAPH>Press <USERINPUT>Enter</USERINPUT>.</PARAGRAPH>
</BULLETSQUAREIND>
</BULLETLISTIND>
</LIST>
<LIST><PARAGRAPH>&space;The system begins reading recovery and installation from the CD. It takes approximately five minutes to copy the information that it needs. After everything is copied from the CD or remote directory to the system disk you see messages including:</PARAGRAPH>
<CODE>
************************************************************
*                                                          *
<SCREENDISPLAY>*                    CRASH    RECOVERY                     *</SCREENDISPLAY>
*                                                          *
************************************************************
You may type  sh  to get a shell prompt at most questions
Checking for tape devices
</CODE>
<PARAGRAPH>The next message asks for the location of the tape drive that you will use to read a system backup tape created before the system crash using the Backup &amp; Restore tool or using the <REFPAGE>Backup(1)</REFPAGE> command.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>If you have a local tape device, you see this message:</PARAGRAPH>
<EXAMPLE>
Restore will be from tapename. OK? ([y]es, [n]o): [y]
</EXAMPLE>
<PARAGRAPH><ITALICS>tapename</ITALICS> is the name of the local tape device. Answer <USERINPUT>y</USERINPUT> if this is the correct tape drive and <USERINPUT>n</USERINPUT> if is not. </PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>If you have a remote (network) tape device, no tape device was found, or you answered &ldquo;no&rdquo; to the question in the previous step, you see this message:</PARAGRAPH>
<EXAMPLE>
<SCREENDISPLAY>Remote or local restore ([r]emote, [l]ocal): [l]</SCREENDISPLAY>
</EXAMPLE>
<BULLETLISTIND><BULLETSQUAREIND><PARAGRAPH>If you answer &ldquo;remote,&rdquo; you have chosen to restore from the network, and you are then asked to enter the following information: the hostname of the remote system, the name of the tape device on the remote system, the IP address of the remote system, and the IP address of your system. The IP address must consist of two to four numbers, separated by periods, such as 192.0.2.1</PARAGRAPH>
</BULLETSQUAREIND>
<BULLETSQUAREIND><PARAGRAPH>If you answer &ldquo;local,&rdquo; you have chosen a tape device that is connected to your system, and you are then asked to enter the name of the tape device.</PARAGRAPH>
</BULLETSQUAREIND>
</BULLETLISTIND>
</LIST>
<LIST><PARAGRAPH>When you see the following message, insert your most recent full backup tape, then press <USERINPUT>Enter</USERINPUT>.</PARAGRAPH>
<PARAGRAPH><SCREENDISPLAY>Insert the first Backup tape in the drive, then &lbreak;press (Enter, [q]uit (from recovery), [r]estart):</SCREENDISPLAY></PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>There is a pause while the program identifies the filesystems on the tape and attempts to mount those filesystems under <FILENAME>/root</FILENAME>. Then you see this message:</PARAGRAPH>
<PARAGRAPH><SCREENDISPLAY>Erase all old filesystems and make new ones (y, n, sh): [n]</SCREENDISPLAY></PARAGRAPH>
<PARAGRAPH>You have three choices:</PARAGRAPH>
<BULLETLISTIND><BULLETSQUAREIND><PARAGRAPH>Answer <USERINPUT>n</USERINPUT> for no. After additional prompts confirming the filesystems to be read, the files on the tape are extracted. The version of each file on the tape replaces the version, if any, on the disk even if the version on the disk is newer.</PARAGRAPH>
</BULLETSQUAREIND>
<BULLETSQUAREIND><PARAGRAPH>Answer <USERINPUT>y</USERINPUT> for yes. After additional confirming prompts and prompts about filesystem types, the system erases all of the filesystems and copies everything from your backup tape to the disk.</PARAGRAPH>
</BULLETSQUAREIND>
<BULLETSQUAREIND><PARAGRAPH>Answer <USERINPUT>sh</USERINPUT> to escape to a shell. You are now in the miniroot environment and can investigate the damage to the system or attempt to save files that have been created or modified since the backup tape was created. After exiting the shell, you have the opportunity to remake filesystems and/or read the backup tape.</PARAGRAPH>
</BULLETSQUAREIND>
</BULLETLISTIND>
</LIST>
<LIST><PARAGRAPH>After reading the full backup tape, this prompt gives you the opportunity to read incremental backup tapes:</PARAGRAPH>
<CODE>
Do you have incremental backup tapes to restore ([y]es, [n]o (none)): [n] 
</CODE>
<PARAGRAPH>Insert another tape and answer <USERINPUT>y</USERINPUT> if you have additional tape, answer <USERINPUT>n</USERINPUT> otherwise.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>This prompt gives you the opportunity to reboot your system if recovery is complete, begin the crash recovery process again at the beginning, or re-read your first backup tape:</PARAGRAPH>
<CODE>
Reboot, start over, or first tape again? ([r]eboot, [s]tart, [f]irst) [r] 
</CODE>
<PARAGRAPH>If you are ready to reboot, answer <USERINPUT>r</USERINPUT>, otherwise choose <USERINPUT>start</USERINPUT> or <USERINPUT>first</USERINPUT>.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="65576">Changing the Default Backup Device</TITLE><PARAGRAPH>At some point in the life of your workstation, you may choose to add a new storage media device. If you wish to change the default backup device to use your new hardware, the following instructions provide complete information. You can also use the graphical System Manager; it is the preferred tool for this operation and is described completely in the <DOCTITLE></DOCTITLE>
<EXTREF IDREF="96534" BOOK="PerSysAdmin" FILE="" HDG="96534" INFO="">Personal System Administration Guide</EXTREF>
<DOCTITLE></DOCTITLE>. Note, however, that no matter which method you use to select your preferred device, installing new system software or using the <REFPAGE>MAKEDEV(1M)</REFPAGE> command may reset the default Backup device. For more information on adding a storage media device, see <DOCTITLE></DOCTITLE>
<EXTREF IDREF="80575" BOOK="IA_Periphrls" FILE="" HDG="80575" INFO="">IRIX Admin: Peripheral Devices</EXTREF>
<DOCTITLE></DOCTITLE>.</PARAGRAPH>
<PARAGRAPH>The method of changing the system default tape device is to relink both <INDEXTARGET ID="ch29"><!-- POSTPROCESSDATA: ch29|default backup device:changing --><FILENAME>/dev/tape</FILENAME> and <FILENAME>/dev/nrtape</FILENAME> to the desired device. Use the following procedure:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Enter the commands:</PARAGRAPH>
<CODE>
<USERINPUT>ls -l /dev/tape</USERINPUT>&space;
lrwxr-xr-x    1 root    sys       10 Sep 30 11:23 tape -> rmt/tps0d5
<USERINPUT>ls -l /dev/rmt/tps0d5</USERINPUT>&space;
crw-rw-rw-    1 root    sys   0,1416 Jan 29 18:21 /dev/rmt/tps0d5
</CODE>
<PARAGRAPH>Since <FILENAME>rmt</FILENAME> is a symbolic link to <FILENAME>/hw/tape</FILENAME>, <FILENAME>/dev/tape</FILENAME> actually refers to <FILENAME>/hw/tape/tps0d5</FILENAME>.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Examine the device numbers of all tape devices by entering the command:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>ls -l /hw/tape</USERINPUT>
</EXAMPLE>
<PARAGRAPH>You see something similar to this:</PARAGRAPH>
<CODE>
crw-rw-rw-    1 root    sys    0,1416 Jan 29 18:14 tps0d5
crw-rw-rw-    1 root    sys    0,1424 Jan 29 18:14 tps0d5c
crw-rw-rw-    1 root    sys    0,1417 Jan 29 18:14 tps0d5nr
crw-rw-rw-    1 root    sys    0,1425 Jan 29 18:14 tps0d5nrc
crw-rw-rw-    1 root    sys    0,1417 Jan 29 18:14 tps0d5nrns
crw-rw-rw-    1 root    sys    0,1425 Jan 29 18:14 tps0d5nrnsc
crw-rw-rw-    1 root    sys    0,1421 Jan 29 18:14 tps0d5nrnsv
crw-rw-rw-    1 root    sys    0,1429 Jan 29 18:14 tps0d5nrnsvc
crw-rw-rw-    1 root    sys    0,1419 Jan 29 18:14 tps0d5nrs
crw-rw-rw-    1 root    sys    0,1427 Jan 29 18:14 tps0d5nrsc
crw-rw-rw-    1 root    sys    0,1423 Jan 29 18:14 tps0d5nrsv
crw-rw-rw-    1 root    sys    0,1431 Jan 29 18:14 tps0d5nrsvc
crw-rw-rw-    1 root    sys    0,1421 Jan 29 18:14 tps0d5nrv
crw-rw-rw-    1 root    sys    0,1429 Jan 29 18:14 tps0d5nrvc
crw-rw-rw-    1 root    sys    0,1416 Jan 29 18:14 tps0d5ns
crw-rw-rw-    1 root    sys    0,1424 Jan 29 18:14 tps0d5nsc
crw-rw-rw-    1 root    sys    0,1420 Jan 29 18:14 tps0d5nsv
crw-rw-rw-    1 root    sys    0,1428 Jan 29 18:14 tps0d5nsvc
crw-rw-rw-    1 root    sys    0,1418 Jan 29 18:14 tps0d5s
crw-rw-rw-    1 root    sys    0,1426 Jan 29 18:14 tps0d5sc
crw-rw-rw-    1 root    sys    0,1399 Jan 29 12:08 tps0d5stat
crw-rw-rw-    1 root    sys    0,1422 Jan 29 18:14 tps0d5sv
crw-rw-rw-    1 root    sys    0,1430 Jan 29 18:14 tps0d5svc
crw-rw-rw-    1 root    sys    0,1420 Jan 29 18:14 tps0d5v
crw-rw-rw-    1 root    sys    0,1428 Jan 29 18:14 tps0d5vc
</CODE>
<PARAGRAPH>The device at the top of this listing is the current <FILENAME>/dev/tape</FILENAME>, although <FILENAME>tps0d5ns</FILENAME> is the same device. The &ldquo;c&rdquo; suffix indicates compression, &ldquo;nr&rdquo; indicates no-rewind, &ldquo;ns&rdquo; indicates non-swapping, &ldquo;s&rdquo; byte swapping, and &ldquo;v&rdquo; variable block size.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Remove the <FILENAME>/dev/tape</FILENAME> link and create the new link to a new name. For example, to make variable block size the default, use the following commands:</PARAGRAPH>
<CODE>
<USERINPUT>rm /dev/tape</USERINPUT>&space;
<USERINPUT>ln -s rmt/tps0d5v /dev/tape</USERINPUT>&space;
<USERINPUT>rm /dev/nrtape</USERINPUT>&space;
<USERINPUT>ln -s rmt/tps0d5nrv /dev/nrtape</USERINPUT>&space;
</CODE>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>Most programs use <FILENAME>/dev/tape</FILENAME> or <FILENAME>/dev/nrtape</FILENAME> as the default tape device. If a program does not seem to be working correctly, first ensure that it is using the correct tape device.</PARAGRAPH>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="99601">Saving Files Using Data Compression</TITLE><PARAGRAPH>For tape drives that perform hardware compression, such as DLT, the IRIX tape interface provides the option letter &ldquo;c&rdquo; to indicate a compression device. For example, to save files using hardware compression, make <FILENAME>/dev/tape</FILENAME> and <FILENAME>/dev/nrtape</FILENAME> links to the devices ending with a &ldquo;c&rdquo; in <FILENAME>/dev/rmt</FILENAME>:</PARAGRAPH>
<CODE>
<USERINPUT>ln -s rmt/tps0d5vc /dev/tape</USERINPUT>&space;
<USERINPUT>ln -s rmt/tps0d5nrvc /dev/nrtape</USERINPUT>&space;
</CODE>
<PARAGRAPH>It is also possible to compress data using software before saving to tape; see <REFPAGE>compress(1)</REFPAGE> and <REFPAGE>pack(1)</REFPAGE> for two possible choices.</PARAGRAPH>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="24574">Backup and Restore Utilities</TITLE><PARAGRAPH>The <COMMAND>Backup</COMMAND> and <COMMAND>Restore</COMMAND> utilities are front-end interfaces to <COMMAND>cpio</COMMAND>. They support remote hostname and tape device options, and <COMMAND>Backup</COMMAND> creates a volume header file listing that <COMMAND>Restore</COMMAND> uses for recovering the files and directories. For complete information, consult the <REFPAGE>Backup(1)</REFPAGE> and <REFPAGE>Restore(1)</REFPAGE> reference pages. </PARAGRAPH>
<PARAGRAPH>If you are planning to use the System Maintenance menu <BUTTON>Recovery</BUTTON> option, use <VARIABLE>Backup</VARIABLE> or the backup facility of the graphical System Manager, as those are the only formats accepted by the System Maintenance Menu. The System Manager is described in detail in the <DOCTITLE></DOCTITLE>
<EXTREF IDREF="96534" BOOK="PerSysAdmin" FILE="" HDG="96534" INFO="">Personal System Administration Guide</EXTREF>
<DOCTITLE></DOCTITLE>.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Saving Data with Backup</TITLE><PARAGRAPH>Before you begin backup, use the <INDEXTARGET ID="ch210"><!-- POSTPROCESSDATA: ch210|backups:estimate space with <ITALICS>bru</ITALICS> --><COMMAND>df</COMMAND> command to estimate how much space is required for a complete archive. This command, for example, shows the number of KB required to back up the <FILENAME>root</FILENAME> partition:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>df -k /</USERINPUT>&space;
</EXAMPLE>
<PARAGRAPH>With <COMMAND>Backup</COMMAND>, you can back up files, directories, whole filesystems, and full systems on local or remote devices. Full system backups include the ability to recover a damaged volume header and also to back up only those files modified since a previous backup. The syntax for the <COMMAND>Backup</COMMAND> command is:</PARAGRAPH>
<PARAGRAPH><USERINPUT>Backup </USERINPUT><VARIABLE>[</VARIABLE><USERINPUT>-h</USERINPUT><VARIABLE>&space;hostname] [</VARIABLE><USERINPUT>-t</USERINPUT><VARIABLE>&space;device] [</VARIABLE><USERINPUT>-i</USERINPUT><VARIABLE>] directory_name | filename</VARIABLE></PARAGRAPH>
<PARAGRAPH>To back up an entire disk to the default tape device, enter:<INDEXTARGET ID="ch211"><!-- POSTPROCESSDATA: ch211|<ITALICS>Backup</ITALICS> --></PARAGRAPH>
<PARAGRAPH><USERINPUT>Backup /</USERINPUT></PARAGRAPH>
<PARAGRAPH>This <COMMAND>Backup</COMMAND> command archives the entire system. The current date is saved in the file <FILENAME>/etc/lastbackup</FILENAME>.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>In order to use a <COMMAND>Backup</COMMAND> tape to restore your system from the System Maintenance Menu, you must make a full system backup. When you make a full system backup, the command also makes a backup of the names of the files in the disk volume header and saves the information in a file that is stored on tape. This file is used during system recovery to restore a damaged volume header.</NOTE>
<PARAGRAPH>You can make a backup relative to the last full system backup by entering:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>Backup -i /</USERINPUT>
</EXAMPLE>
<PARAGRAPH>To back up a specific directory and its subdirectories, enter the top-level directory name. For example, to back up the <FILENAME>usr</FILENAME> hierarchy, enter the following:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>Backup /usr</USERINPUT>
</EXAMPLE>
<PARAGRAPH>To use a remote tape drive, use the <CMDLINEOPT>-h </CMDLINEOPT><VARIABLE>hostname</VARIABLE> option:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>Backup -h guest@alice.cbs.tv.com:/dev/tape /usr/people/ralph</USERINPUT>&space;
</EXAMPLE>
<PARAGRAPH>This would back up the directory <FILENAME>/usr/people/ralph</FILENAME> on the <FILENAME>/dev/tape</FILENAME> device on the host alice.cbs.tv.com. You must have at least <ITALICS>guest</ITALICS> login privileges on the remote system in order to use a remote tape drive. </PARAGRAPH>
<PARAGRAPH>To back up a file, enter the filename. For example:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>Backup people.tar.Z</USERINPUT>
</EXAMPLE>
<PARAGRAPH>Files (and directories) are stored relative to the current directory if the backup is made with a relative pathname as shown in this example. Relative pathnames are those that do not begin with a slash (/) character. Pathnames that begin with a slash are known as <ITALICS>absolute</ITALICS> pathnames. For example, <FILENAME>/usr/bin/vi</FILENAME> is an absolute pathname. The leading slash indicates that the pathname begins at the root directory of the system. In contrast, <FILENAME>work/special.project/chapter1</FILENAME> is a relative pathname since the lack of a leading slash indicates that the path begins with a directory name in the current directory.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Restoring Data with Restore</TITLE><PARAGRAPH>The <INDEXTARGET ID="ch212"><!-- POSTPROCESSDATA: ch212|restoring data:<ITALICS>Restore</ITALICS> --><INDEXTARGET ID="ch213"><!-- POSTPROCESSDATA: ch213|<ITALICS>Restore</ITALICS>:restoring data --><COMMAND>Restore</COMMAND> command is a shell script that uses <COMMAND>tar </COMMAND>to extract files from a backup (see <XREF IDREF="53826" TYPE="TITLE">&ldquo;About tar&rdquo;</XREF>). You can also use <COMMAND>Restore</COMMAND> to read tapes made using the graphical System Manager (see the <DOCTITLE></DOCTITLE>
<EXTREF IDREF="96534" BOOK="PerSysAdmin" FILE="" HDG="96534" INFO="">Personal System Administration Guide</EXTREF>
<DOCTITLE></DOCTITLE>).</PARAGRAPH>
<PARAGRAPH>You can recover multivolume backups with <COMMAND>Restore</COMMAND>. Enter:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>Restore</USERINPUT>&space;
</EXAMPLE>
<PARAGRAPH>and you are prompted to insert the tape into the drive. </PARAGRAPH>
<PARAGRAPH>To extract a single file, use this command:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>Restore </USERINPUT><VARIABLE>file1</VARIABLE>&space;
</EXAMPLE>
<PARAGRAPH>With the <CMDLINEOPT>-h</CMDLINEOPT> option, you can specify the tape drive on a different host workstation. You must have guest login privileges in order to extract data from a remote drive.</PARAGRAPH>
<EXAMPLE>
<USERINPUT>Restore -h guest@alice.cbs.tv.com </USERINPUT><VARIABLE>file1</VARIABLE>&space;
</EXAMPLE>
<PARAGRAPH>Files are restored into the current directory if the backup was made with relative pathnames. Relative pathnames are those that do not begin with a slash (/) character. Pathnames that begin with a slash are known as <ITALICS>absolute</ITALICS> pathnames. For example, <FILENAME>/usr/bin/vi</FILENAME> is an absolute pathname. The leading slash indicates that the pathname begins at the root directory of the system. In contrast, <FILENAME>work/special.project/chapter1</FILENAME> is a relative pathname since the lack of a leading slash indicates that the path begins with a directory name in the current directory. </PARAGRAPH>
<PARAGRAPH>Existing files of the same pathname on the disk are overwritten during a restore operation even if they are more recent than the files on tape. You must be especially careful, then, if you are restoring files with absolute pathnames, because regardless of your current working directory, the file is restored where the pathname indicates.</PARAGRAPH>
<PARAGRAPH>For example, if the file you are restoring was backed up as <FILENAME>/etc/passwd </FILENAME>and you are in the directory <FILENAME>/tmp</FILENAME>, the file you restore overwrites the <FILENAME>/etc/passwd</FILENAME> file. If the file you are restoring was backed-up as <FILENAME>passwd</FILENAME>, then restore the <FILENAME>passwd</FILENAME> file into <FILENAME>/tmp</FILENAME>.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="37829">About dump and restore</TITLE><PARAGRAPH>The <COMMAND>dump</COMMAND> and <COMMAND>restore</COMMAND> programs are standard filesystem backup utilities used on many UNIX systems. These commands are only used with EFS filesystems. Refer to <XREF IDREF="65445" TYPE="TITLE">&ldquo;About xfsdump and xfsrestore&rdquo;</XREF> to dump and restore XFS filesystems. The <COMMAND>dump</COMMAND> program makes incremental backups of entire filesystems.</PARAGRAPH>
<PARAGRAPH>Use <COMMAND>restore</COMMAND> to retrieve files from a <COMMAND>dump</COMMAND> archive. With <COMMAND>restore</COMMAND>, you can restore an entire filesystem or specific files. It also has an interactive mode that lets you browse the contents of an archive, select specific files, and restore them.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Backing Up a Filesystem with dump </TITLE><PARAGRAPH>The <INDEXTARGET ID="ch214"><!-- POSTPROCESSDATA: ch214|<ITALICS>dump</ITALICS>:making backups --><COMMAND>dump</COMMAND> utility archives not only regular files, but also device files and special files such as links and named pipes. To recover files from an archive, you use the <COMMAND>restore</COMMAND> command. The date on which you last ran the <COMMAND>dump</COMMAND> program is stored in the file <FILENAME>/etc/dumpdates</FILENAME> when you specify the <CMDLINEOPT>u</CMDLINEOPT> option to indicate an update.</PARAGRAPH>
<PARAGRAPH>This command backs up all files on the <INDEXTARGET ID="ch215"><!-- POSTPROCESSDATA: ch215|<ITALICS>/etc/dumpdates</ITALICS> --><INDEXTARGET ID="ch216"><!-- POSTPROCESSDATA: ch216|<ITALICS>dump</ITALICS>:<ITALICS>/etc/dumpdates</ITALICS> --><FILENAME>/usr</FILENAME> filesystem:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>dump 0 /dev/usr</USERINPUT>&space;
</EXAMPLE>
<NOTE><PREFIX>Note</PREFIX>The 0 in the example specifies the increment level. Refer to the next section for an explanation of level numbers.</NOTE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="66444">Performing Incremental Backups</TITLE><PARAGRAPH>The <INDEXTARGET ID="ch217"><!-- POSTPROCESSDATA: ch217|backups:incremental with <ITALICS>dump</ITALICS> --><INDEXTARGET ID="ch218"><!-- POSTPROCESSDATA: ch218|<ITALICS>dump</ITALICS>:incremental backups --><COMMAND>dump</COMMAND> utility is designed for incremental backups, and it archives not only regular files and directories, but also special files, links, and pipes.</PARAGRAPH>
<PARAGRAPH>To create an incremental backup, specify an increment number when you use <COMMAND>dump</COMMAND>. The <COMMAND>dump</COMMAND> program archives all files (including special files, links, and named pipes) that have changed since the last appropriate increment. To recover files from an archive, use the <COMMAND>restore</COMMAND> command.</PARAGRAPH>
<PARAGRAPH>The <COMMAND>dump</COMMAND> program is designed specifically to create incremental backups. It refers to the increments as <ITALICS>levels</ITALICS>, and each level is assigned a number:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>A level 0 backup archives all files in a filesystem.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Backup levels 1&ndash;9 archive all files that have changed since the previous backup of the same or lesser level.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>For example, this command backs up all files on the <FILENAME>/usr</FILENAME> filesystem:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>dump 0 /dev/usr</USERINPUT>&space;
</EXAMPLE>
<PARAGRAPH>This command backs up those files that have changed since the previous level 0 dump:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>dump 1 /dev/usr</USERINPUT>&space;
</EXAMPLE>
<PARAGRAPH>This command archives those files that have changed since the previous level 1 dump:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>dump 2 /dev/usr</USERINPUT>&space;
</EXAMPLE>
<PARAGRAPH>If the next <COMMAND>dump</COMMAND> command you give specifies level 1, the <COMMAND>dump</COMMAND> utility backs up the files that have changed since the last level 0, but not those that have changed since the last level 2. This numbering system gives you enormous flexibility so you can create a backup schedule to fit your specific needs.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="13343">Recovering a Filesystem with restore </TITLE><PARAGRAPH>Use <INDEXTARGET ID="ch219"><!-- POSTPROCESSDATA: ch219|restoring data:<ITALICS>restore</ITALICS> --><INDEXTARGET ID="ch220"><!-- POSTPROCESSDATA: ch220|<ITALICS>restore</ITALICS>:restoring filesystems --><COMMAND>restore</COMMAND> to recover files and filesystems made with the <COMMAND>dump</COMMAND> program. There are two ways to use <COMMAND>restore</COMMAND>: interactively and non-interactively.</PARAGRAPH>
<PARAGRAPH>Use the interactive option to recover moderate numbers of files from a <COMMAND>dump</COMMAND> archive. With the interactive feature of <COMMAND>restore</COMMAND>, you can browse the contents of a tape to locate and extract specific files.</PARAGRAPH>
<PARAGRAPH>Use the non-interactive mode to recover an entire backup. For example, place the backup in the drive and enter:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>restore -x</USERINPUT>&space;
</EXAMPLE>
<PARAGRAPH>If your <BOLD>root</BOLD> filesystem is damaged and needs to be completely restored, see <XREF IDREF="80227" TYPE="TITLE">&ldquo;Recovering Data After System Corruption&rdquo;</XREF>. This section explains how to restore a damaged root filesystem when the system cannot boot. It also describes how to safely restore system files on the root filesystem.</PARAGRAPH>
<CAUTION><PREFIX>Caution</PREFIX>Restoring IRIX system files on an active root filesystem disk may cause damage to the filesystem and system failure.</CAUTION>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Recovering Individual Files with restore </TITLE><PARAGRAPH>To recover individual files from an archive created by the <INDEXTARGET ID="ch221"><!-- POSTPROCESSDATA: ch221|<ITALICS>restore</ITALICS>:restoring individual files --><INDEXTARGET ID="ch222"><!-- POSTPROCESSDATA: ch222|<ITALICS>restore</ITALICS>:interactive mode --><COMMAND>dump</COMMAND> utility, follow these steps:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Place the tape in the tape drive. Make sure it is write-protected. Enter:</PARAGRAPH>
<CODE>
# <USERINPUT>restore vi</USERINPUT>&space;
Verify tape and initialize maps
Tape block size is 32
Dump  date: Wed Feb 13 10:18:59 1991
Dumped from: the epoch
Level 0 dump of an unlisted filesystem on ralph:/dev/rusr
Label: none
Extract directories from tape
Initialize symbol table.
restore >>
</CODE>
</LIST>
<LIST><PARAGRAPH>You are now at the <ITALICS>restore>></ITALICS> prompt. You can browse the tape with <COMMAND>cd</COMMAND> and <COMMAND>ls</COMMAND>:</PARAGRAPH>
<EXAMPLE>
restore > <USERINPUT>ls</USERINPUT>&space;
</EXAMPLE>
<CODE>
2      *./          973     source        1502  net/
2      *../         149     d2/           1445  os/
10     .cshrc       155016  debug/        1437  proto3.5/
1463   .gamma       69899   dev/          1494  revE
1464   .gamtables   696     etc/          2122  stand/
160    .kshrc       137     bin/          3     tmp/
1540   .lastlogin   1311412 jake/         128   unix
819    .login       424     lib/          128   unix.debug
820    .profile     9       lost+found/   4     usr/
</CODE>
<PARAGRAPH>To continue browsing, enter the following commands to the <ITALICS>restore>></ITALICS> prompt:</PARAGRAPH>
<CODE>
restore >> <USERINPUT>cd etc</USERINPUT>&space;
restore >> <USERINPUT>pwd</USERINPUT>&space;
/etc
</CODE>
</LIST>
<LIST><PARAGRAPH>Start building a list of files that you want to extract. Use the <COMMAND>add</COMMAND> command to add the names of the files you want to the extract list:</PARAGRAPH>
<CODE>
restore >> <USERINPUT>add fstab</USERINPUT>&space;
restore >> <USERINPUT>add fsck</USERINPUT>&space;
</CODE>
<PARAGRAPH>If you enter <COMMAND>ls</COMMAND> at this point, you see a list of files, and <COMMAND>fsck</COMMAND> and <COMMAND>fstab</COMMAND> are marked with an asterisk to show they will be extracted. If you want to remove a file from the list of those to be extracted, use the <COMMAND>delete</COMMAND> command:</PARAGRAPH>
<EXAMPLE>
restore > <USERINPUT>delete fstab</USERINPUT>&space;
</EXAMPLE>
</LIST>
<LIST><PARAGRAPH>To restore the specified files, use the <COMMAND>extract</COMMAND> command:</PARAGRAPH>
<CODE>
restore > <USERINPUT>extract</USERINPUT>&space;
Extract requested files
You have not read any tapes yet.
Unless you know which volume your file(s) are on you should
start with the last volume and work towards the first.
Specify next volume #: <USERINPUT>1</USERINPUT>&space;
Mount tape volume 1
then enter tape name (default: /dev/tape) <USERINPUT>&lt;Return></USERINPUT>&space;
extract file ./etc/fsck
Add links
Set directory mode, owner, and times.
set owner/mode for '.'? [yn] <USERINPUT>n</USERINPUT>&space;
restore > <USERINPUT>q</USERINPUT>&space;
</CODE>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>To recover only a few files, you may wish to use the non-interactive options of <COMMAND>restore</COMMAND>. For example, enter:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>restore -x ./usr/people/ralph/bus.schedule ./etc/passwd</USERINPUT>&space;
</EXAMPLE>
<PARAGRAPH>This recovers the files <FILENAME>bus.schedule</FILENAME> and <FILENAME>passwd</FILENAME> from the archive.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="65445">About xfsdump and xfsrestore</TITLE><PARAGRAPH>This section describes how the <INDEXTARGET ID="ch223"><!-- POSTPROCESSDATA: ch223|backup and restore:using <ITALICS>xfsdump</ITALICS> and <ITALICS>xfsrestore</ITALICS> --><COMMAND>xfsdump</COMMAND> and <COMMAND>xfsrestore</COMMAND> utilities work and how to use them to back up and recover data on XFS filesystems. (The <REFPAGE>xfsdump(1M)</REFPAGE> and <REFPAGE>xfsrestore(1M)</REFPAGE> reference pages provide online information on these utilities.) <INDEXTARGET ID="ch224"><!-- POSTPROCESSDATA: ch224|<ITALICS>dump</ITALICS>:vs. <ITALICS>xfsdump</ITALICS> --><INDEXTARGET ID="ch225"><!-- POSTPROCESSDATA: ch225|<ITALICS>restore</ITALICS>:vs. <ITALICS>xfsrestore</ITALICS> --><XREF IDREF="98007" TYPE="TABLE">Table&nbsp;2-1</XREF> summarizes when to use <COMMAND>xfsdump</COMMAND> and when to use its EFS counterpart, <REFPAGE>dump(1M)</REFPAGE></PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="2-1"><PREFIX>Table 2-1 </PREFIX><XREFTARGET ID="98007"> <EMPHASIS>(continued)        </EMPHASIS>Filesystems and Dump Utilities</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="111"><PARAGRAPH>For a Filesystem of Type</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="111"><PARAGRAPH>Dump It Using</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="111"><PARAGRAPH>EFS</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="111"><PARAGRAPH><COMMAND>dump</COMMAND>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="111"><PARAGRAPH>XFS</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="111"><PARAGRAPH><COMMAND>xfsdump</COMMAND>&space;</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH><XREF IDREF="17753" TYPE="TABLE">Table&nbsp;2-2</XREF> summarizes when to use <COMMAND>xfsrestore</COMMAND> and when to use its EFS counterpart, <REFPAGE>restore(1M)</REFPAGE>.</PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="2-2"><PREFIX>Table 2-2 </PREFIX><XREFTARGET ID="17753"> <EMPHASIS>(continued)        </EMPHASIS>Filesystems and Restore Utilities</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="110"><PARAGRAPH>For a Dump Made Using</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="110"><PARAGRAPH>Restore It Using</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="110"><PARAGRAPH>On a Filesystem of Type</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH><COMMAND>dump</COMMAND>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="110"><PARAGRAPH><COMMAND>restore</COMMAND>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="110"><PARAGRAPH>EFS or XFS</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH><COMMAND>xfsdump</COMMAND>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="110"><PARAGRAPH><COMMAND>xfsrestore</COMMAND>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="110"><PARAGRAPH>EFS or XFS</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Note than you can restore data in either EFS or XFS filesystems, but must use the restore utility that corresponds with the dump utility used to make the backup.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Features of xfsdump and xfsrestore</TITLE><PARAGRAPH>The <COMMAND>xfsdump</COMMAND> and <COMMAND>xfsrestore</COMMAND> utilities fully support XFS filesystems. With <COMMAND>xfsdump</COMMAND> and <COMMAND>xfsrestore</COMMAND>, you can back up and restore data using local or remote drives. You can back up filesystems, directories, and/or individual files, and then restore filesystems, directories, and files independently of how they were backed up. <COMMAND>xfsdump</COMMAND> also allows you to back up &ldquo;live&rdquo; (mounted, in-use) filesystems.</PARAGRAPH>
<PARAGRAPH>With <COMMAND>xfsdump</COMMAND> and <COMMAND>xfsrestore</COMMAND>, you can recover from intentional or accidental interruptions&mdash;this means you can interrupt a dump or restore at any time, and then resume it whenever desired. With <COMMAND>xfsrestore</COMMAND>, you can restore <COMMAND>xfsdump</COMMAND> data onto EFS filesystems. <COMMAND>(xfsdump</COMMAND> backs up mounted XFS filesystems only.) <COMMAND>xfsdump</COMMAND> and <COMMAND>xfsrestore</COMMAND> support incremental dumps, and multiple dumps can be placed on a single media object. The utilities can automatically divide a dump among multiple drives, and can restore a dump from multiple drives. This allows you to perform faster dumps and restores.</PARAGRAPH>
<PARAGRAPH><COMMAND>xfsdump</COMMAND> and <COMMAND>xfsrestore</COMMAND> support XFS features including 64-bit inode numbers, file lengths, holes, and user-selectable extent sizes. They support multiple media types, all IRIX-supported file types (regular, directory, symbolic link, block and character special, FIFO, and socket), and retain hard links.<COMMAND>&space;xfsdump</COMMAND> does not affect the state of the filesystem being dumped (for example, access times are retained).<COMMAND>&space;xfsrestore</COMMAND> detects and bypasses media errors and recovers rapidly after encountering them.<COMMAND>&space;xfsdump</COMMAND> does not cross mount points, local or remote.</PARAGRAPH>
<PARAGRAPH><COMMAND>xfsdump</COMMAND> optionally prompts for additional media when the end of the current media is reached. Operator estimates of media capacity are not required and <COMMAND>xfsdump</COMMAND> also supports automated backups. <COMMAND>xfsdump</COMMAND> maintains an extensive online inventory of all dumps performed. Inventory contents can be viewed through various filters to quickly locate specific dump information. <COMMAND>xfsrestore</COMMAND> supports interactive operation, allowing selection of individual files or directories for recovery. It also permits selection from among backups performed at different times when multiple dumps are available. Dump contents may also be viewed noninteractively.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>If you are using disk quotas on XFS filesystems, refer to &ldquo;Administering Disk Quotas on XFS Filesystems&rdquo; in <DOCTITLE></DOCTITLE>
<EXTREF IDREF="88526" BOOK="IA_DiskFiles" FILE="" HDG="88526" INFO="">IRIX Admin: Disks and Filesystems</EXTREF>
<DOCTITLE></DOCTITLE> for more information.</NOTE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Media Layout for xfsdump</TITLE><PARAGRAPH>The following section introduces some terminology and then describes the way <INDEXTARGET ID="ch226"><!-- POSTPROCESSDATA: ch226|<ITALICS>xfsdump</ITALICS>:media layout --><INDEXTARGET ID="ch227"><!-- POSTPROCESSDATA: ch227|media:layout, <ITALICS>xfsdump</ITALICS> --><COMMAND>xfsdump</COMMAND> formats data on the storage media for use by <COMMAND>xfsrestore</COMMAND>.</PARAGRAPH>
<PARAGRAPH>While <INDEXTARGET ID="ch228"><!-- POSTPROCESSDATA: ch228|media:object, <ITALICS>xfsdump</ITALICS> --><INDEXTARGET ID="ch229"><!-- POSTPROCESSDATA: ch229|dump session, <ITALICS>xfsdump</ITALICS> --><COMMAND>xfsdump</COMMAND> and <COMMAND>xfsrestore</COMMAND> are often used with tape media, the utilities actually support multiple kinds of media, so in the following discussions, the term <ITALICS>media object</ITALICS> is used to refer to the media in a generic fashion. The term <ITALICS>dump</ITALICS> refers to the result of a single use of the <COMMAND>xfsdump</COMMAND> command to output data files to the selected media object(s). An instance of the use of <COMMAND>xfsdump</COMMAND> is referred to as a <ITALICS>dump session</ITALICS>.</PARAGRAPH>
<PARAGRAPH>The dump session sends a single <INDEXTARGET ID="ch230"><!-- POSTPROCESSDATA: ch230|dump stream, <ITALICS>xfsdump</ITALICS> --><INDEXTARGET ID="ch231"><!-- POSTPROCESSDATA: ch231|data segments, <ITALICS>xfsdump</ITALICS> --><INDEXTARGET ID="ch232"><!-- POSTPROCESSDATA: ch232|dump inventory, <ITALICS>xfsdump</ITALICS> --><INDEXTARGET ID="ch233"><!-- POSTPROCESSDATA: ch233|inventory, <ITALICS>xfsdump</ITALICS> --><INDEXTARGET ID="ch234"><!-- POSTPROCESSDATA: ch234|stream terminator, <ITALICS>xfsdump</ITALICS> --><INDEXTARGET ID="ch235"><!-- POSTPROCESSDATA: ch235|terminator, <ITALICS>xfsdump</ITALICS> --><ITALICS>dump stream</ITALICS> to the media object(s). The dump stream may contain as little as a single file or as much as an entire filesystem. The dump stream is composed of <ITALICS>dump objects</ITALICS>, which are: </PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>one or more <ITALICS>data segments</ITALICS></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>an optional <ITALICS>dump inventory</ITALICS></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>a<ITALICS>&space;stream terminator</ITALICS>&space;</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The data segment(s) contains the actual data, the dump inventory contains a list of the dump objects in the dump, and the stream terminator marks the end of the dump stream. When a dump stream is composed of multiple dump objects, each object is contained in a <ITALICS>media file</ITALICS>. Some output devices, for example standard output, do not support the concept of media files&mdash;the dump stream is only the data.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Possible xfsdump Layouts</TITLE><PARAGRAPH>The simplest dump, for example the dump of a small amount of data to a single tape, produces a data segment and a stream terminator as the only dump objects. If the optional inventory object is added, you have a dump like that illustrated in <XREF IDREF="77113" TYPE="GRAPHIC">Figure&nbsp;2-1</XREF>. (In the data layout diagrams in this section, the optional inventory object is always included.)</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="XFSFig3-1.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="2-1"><PREFIX>Figure 2-1 </PREFIX><XREFTARGET ID="77113">Single Dump on Single Media Object</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>You can also dump data streams that are larger than a single media object. The data stream can be broken between any two media files including data segment boundaries. (The inventory is never broken into segments.) In addition, if you specify multiple drives, the dump is automatically broken into multiple streams. The <COMMAND>xfsdump</COMMAND> utility prompts for a new media object when the end of the current media object is reached.</PARAGRAPH>
<PARAGRAPH><XREF IDREF="76727" TYPE="GRAPHIC">Figure&nbsp;2-2</XREF> illustrates the data layout of a single dump session that requires two media objects on each of two devices.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="XFSFig3-2.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="2-2"><PREFIX>Figure 2-2 </PREFIX><XREFTARGET ID="76727">Single Dump on Multiple Media Objects</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>The <COMMAND>xfsdump</COMMAND> utility also accommodates multiple dumps on a single media object. When dumping to tape, for example, the tape is automatically advanced past the existing dump session(s) and the existing stream terminator is erased. The new dump data is then written, followed by the new stream terminator<FTNOTE>For drives that do not permit termination to operate in this way, other means are used to achieve the same effective result.</FTNOTE>
.</PARAGRAPH>
<PARAGRAPH><XREF IDREF="88987" TYPE="GRAPHIC">Figure&nbsp;2-3</XREF> illustrates the layout of media files for two dumps on a single media object.</PARAGRAPH>
<PARAGRAPH><XREF IDREF="41284" TYPE="GRAPHIC">Figure&nbsp;2-4</XREF> illustrates a case in which multiple dumps use multiple media objects. If media files already exist on the additional media object(s), the <COMMAND>xfsdump</COMMAND> utility finds the existing stream terminator, erases it, and begins writing the new dump data stream.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="XFSFig3-3.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="2-3"><PREFIX>Figure 2-3 </PREFIX><XREFTARGET ID="88987">Multiple Dumps on Single Media Object</CAPTION>
</FIGURE>
<FIGURE><GRAPHIC FILE="XFSFig3-4.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="2-4"><PREFIX>Figure 2-4 </PREFIX><XREFTARGET ID="41284">Multiple Dumps on Multiple Media Objects</CAPTION>
</FIGURE>
</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Saving Data with xfsdump</TITLE><PARAGRAPH>This section discusses how to use the <INDEXTARGET ID="ch236"><!-- POSTPROCESSDATA: ch236|<ITALICS>xfsdump</ITALICS>:using --><COMMAND>xfsdump</COMMAND> command to back up data to local and remote devices. You can get a summary of <COMMAND>xfsdump</COMMAND> syntax with the<CMDLINEOPT>&space;&ndash;h</CMDLINEOPT> option:</PARAGRAPH>
<CODE>
# <USERINPUT>xfsdump -h</USERINPUT>&space;
xfsdump: version <VARIABLE>X.X</VARIABLE>&space;
xfsdump: usage: xfsdump [ -b &lt;blocksize> (with minimal rmt option) ]
&space;                       [ -c &lt;media change alert program> ]
&space;                       [ -f &lt;destination> ... ]
&space;                       [ -h (help) ]
&space;                       [ -l &lt;level> ]
&space;                       [ -m &lt;force usage of minimal rmt> ]
&space;                       [ -o &lt;overwrite tape > ]
&space;                       [ -p &lt;seconds between progress reports> ]
&space;                       [ -s &lt;subtree> ... ]
&space;                       [ -v &lt;verbosity {silent, verbose, trace}> ]
&space;                       [ -A (don't dump extended file attributes) ]
&space;                       [ -B &lt;base dump session id> ]
&space;                       [ -E (pre-erase media) ]
&space;                       [ -F (don't prompt) ]
&space;                       [ -I (display dump inventory) ]
&space;                       [ -J (inhibit inventory update) ]
&space;                       [ -L &lt;session label> ]
&space;                       [ -M &lt;media label> ... ]
&space;                       [ -O &lt;options file> ]
&space;                       [ -R (resume) ]
&space;                       [ -T (don't timeout dialogs) ]
&space;                       [ -Y &lt;I/O buffer ring length> ]
&space;                       [ - (stdout) ]
&space;                       [ &lt;source (mntpnt|device)> ]
</CODE>
<PARAGRAPH>You must be the superuser to use <COMMAND>xfsdump</COMMAND>. Refer to the<REFPAGE>&space;xfsdump(1M)</REFPAGE> reference page for details.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Specifying Local Media with xfsdump</TITLE><PARAGRAPH>You can use <INDEXTARGET ID="ch237"><!-- POSTPROCESSDATA: ch237|<ITALICS>xfsdump</ITALICS>:specifying media --><COMMAND>xfsdump</COMMAND> to back up data to various media. For example, you can dump data to a tape or hard disk. The drive containing the media object may be connected to the local system or accessible over the network.</PARAGRAPH>
<PARAGRAPH>Following is an example of a level 0 dump to a local tape drive. Note that dump level does not need to be specified for a level 0 dump. (Refer to <XREF IDREF="66444" TYPE="TITLE">&ldquo;Performing Incremental Backups&rdquo;</XREF> for a discussion of dump levels.)</PARAGRAPH>
<CODE>
# <USERINPUT>xfsdump -f /dev/tape -L testers_11_21_94 -M test_1 /disk2</USERINPUT>
xfsdump: version 2.0 - type ^C for status and control
xfsdump: level 0 dump of cumulus:/disk2
xfsdump: dump date: Wed Oct 25 16:19:13 1995
xfsdump: session id: d2a6123b-b21d-1001-8938-08006906dc5c
xfsdump: session label: &ldquo;testers_11_21_94&rdquo;
xfsdump: ino map phase 1: skipping (no subtrees specified)
xfsdump: ino map phase 2: constructing initial dump list
xfsdump: ino map phase 3: skipping (no pruning necessary)
xfsdump: ino map phase 4: skipping (size estimated in phase 2)
xfsdump: ino map phase 5: skipping (only one dump stream)
xfsdump: ino map construction complete
xfsdump: preparing drive
xfsdump: creating dump session media file 0 (media 0, file 0)
xfsdump: dumping ino map
xfsdump: dumping directories
xfsdump: dumping non-directory files
xfsdump: ending media file
xfsdump: media file size 16777216 bytes
xfsdump: dumping session inventory
xfsdump: beginning inventory media file
xfsdump: media file 1 (media 0, file 1)
xfsdump: ending inventory media file
xfsdump: inventory media file size 4194304 bytes
xfsdump: writing stream terminator
xfsdump: beginning media stream terminator
xfsdump: media file 2 (media 0, file 2)
xfsdump: ending media stream terminator
xfsdump: media stream terminator size 2097152 bytes
xfsdump: I/O metrics: 3 by 2MB ring; 14/22 (64%) records streamed; 145889B/s
xfsdump: dump complete: 141 seconds elapsed
</CODE>
<PARAGRAPH>In this case, a session label (<CMDLINEOPT>&ndash;L</CMDLINEOPT> option) and a media label (<CMDLINEOPT>&ndash;M </CMDLINEOPT>option) are supplied, and the entire filesystem is dumped. Since no verbosity option is supplied, the default of <COMMAND>verbose</COMMAND> is used, resulting in the detailed screen output. The dump inventory is updated with the record of this backup because the <CMDLINEOPT>-J</CMDLINEOPT> option is not specified.</PARAGRAPH>
<PARAGRAPH>Following is an example of a backup of a subdirectory of a filesystem. In this example, the verbosity is set to <COMMAND>silent</COMMAND>, and the dump inventory is not updated (<CMDLINEOPT>&ndash;J </CMDLINEOPT>option):</PARAGRAPH>
<CODE>
# <USERINPUT>xfsdump -f /dev/tape -v silent -J -s people/fred /usr</USERINPUT>
</CODE>
<PARAGRAPH>Note that the subdirectory backed up (<FILENAME>/usr/people/fred</FILENAME>) was specified relative to the filesystem, so the specification did not include the name of the filesystem (in this case, <FILENAME>/usr</FILENAME>). Since <FILENAME>/usr</FILENAME> may be a very large filesystem and the <CMDLINEOPT>-v silent</CMDLINEOPT> option was used, this could take a long time during which there would be no screen output.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Specifying a Remote Tape Drive with xfsdump</TITLE><PARAGRAPH>To back up data to a remote tape drive, use the standard remote system syntax, specifying the system (by hostname if supported by a name server or IP address if not) followed by a colon (:), then the pathname of the special file. </PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>For remote backups, use the variable block size tape device if the device supports variable block size operation; otherwise, use the fixed block size device (see <REFPAGE>intro(7)</REFPAGE>).</NOTE>
<PARAGRAPH>The following example shows a subtree backup to a remote tape device:</PARAGRAPH>
<CODE>
# <USERINPUT>xfsdump -f magnolia:/dev/tape -L mag_10-95 -s engr /disk2</USERINPUT>
xfsdump: version 2.0 - type ^C for status and control
xfsdump: level 0 dump of cumulus:/disk2
xfsdump: dump date: Wed Oct 25 16:27:39 1995
xfsdump: session id: d2a6124b-b21d-1001-8938-08006906dc5c
xfsdump: session label: &ldquo;mag_10-95&rdquo;
xfsdump: ino map phase 1: parsing subtree selections
xfsdump: ino map phase 2: constructing initial dump list
xfsdump: ino map phase 3: pruning unneeded subtrees
xfsdump: ino map phase 4: estimating dump size
xfsdump: ino map phase 5: skipping (only one dump stream)
xfsdump: ino map construction complete
xfsdump: preparing drive
xfsdump: positioned at media file 0: dump 0, stream 0
xfsdump: positioned at media file 1: dump 0, stream 0
xfsdump: positioned at media file 2: dump 0, stream 0
xfsdump: stream terminator found
xfsdump: creating dump session media file 0 (media 0, file 2)
xfsdump: dumping ino map
xfsdump: dumping directories
xfsdump: dumping non-directory files
xfsdump: ending media file
xfsdump: media file size 6291456 bytes
xfsdump: dumping session inventory
xfsdump: beginning inventory media file
xfsdump: media file 1 (media 0, file 3)
xfsdump: ending inventory media file
xfsdump: inventory media file size 4194304 bytes
xfsdump: writing stream terminator
xfsdump: beginning media stream terminator
xfsdump: media file 2 (media 0, file 4)
xfsdump: ending media stream terminator
xfsdump: media stream terminator size 2097152 bytes
xfsdump: I/O metrics: 3 by 2MB ring; 12/22 (55%) records streamed; 99864B/s
xfsdump: dump complete: 149 seconds elapsed
</CODE>
<PARAGRAPH>In this case, <FILENAME>/disk2/engr </FILENAME>is backed up to the variable block size tape device on the remote system <ITALICS>magnolia</ITALICS>. Existing dumps on the tape mounted on magnolia were skipped before recording the new data.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>The superuser account on the local system must be able to <COMMAND>rsh</COMMAND> to the remote system without a password. For more information, see <REFPAGE>hosts.equiv(4)</REFPAGE>.</NOTE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Backing Up to a File with xfsdump</TITLE><PARAGRAPH>You can back up data to a file instead of a device. In the following example, a file (<FILENAME>Makefile</FILENAME>) and a directory (<FILENAME>Source</FILENAME>) are backed up to a dump file (<FILENAME>monday_backup</FILENAME>) in <FILENAME>/usr/tmp</FILENAME> on the local system:</PARAGRAPH>
<CODE>
# <USERINPUT>xfsdump -f /usr/tmp/monday_backup -v silent -J -s \</USERINPUT>
<USERINPUT>people/fred/Makefile -s people/fred/Source /usr</USERINPUT>
</CODE>
<PARAGRAPH>You may also dump to a file on a remote system, but note that the file must be in the remote system's <FILENAME>/dev</FILENAME> directory. For example, the following command backs up the <FILENAME>/usr/people/fred</FILENAME> subdirectory on the local system to the regular file<FILENAME>&space;/dev/fred_mon_12-2</FILENAME> on the remote system <ITALICS>theduke</ITALICS>:</PARAGRAPH>
<CODE>
# <USERINPUT>xfsdump -f theduke:/dev/fred_mon_12-2 -s people/fred /usr</USERINPUT>
</CODE>
<PARAGRAPH>Alternatively, you could dump to any remote file if that file is on an NFS-mounted filesystem. In any case, permission settings on the remote system must allow you to write to the file.</PARAGRAPH>
<PARAGRAPH>Refer to the section <XREF IDREF="61361" TYPE="TITLE">&ldquo;Using xfsdump and xfsrestore to Copy Filesystems&rdquo;</XREF> for information on using the standard input and standard output capabilities of <COMMAND>xfsdump</COMMAND> and <COMMAND>xfsrestore</COMMAND> to pipe data between filesystems or across the network.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Reusing Tapes with xfsdump</TITLE><PARAGRAPH>When you use a new tape as the media object of a dump session, <INDEXTARGET ID="ch238"><!-- POSTPROCESSDATA: ch238|<ITALICS>xfsdump</ITALICS>:reusing media --><INDEXTARGET ID="ch239"><!-- POSTPROCESSDATA: ch239|tapes, reusing with <ITALICS>xfsdump</ITALICS> --><COMMAND>xfsdump</COMMAND> begins writing dump data at the beginning of the tape without prompting. If the tape already has dump data on it, <COMMAND>xfsdump</COMMAND> begins writing data after the last dump stream, again without prompting.</PARAGRAPH>
<PARAGRAPH>If, however, the tape contains data that is not from a dump session, <COMMAND>xfsdump</COMMAND> prompts you before continuing:</PARAGRAPH>
<CODE>
# <USERINPUT>xfsdump -f /dev/tape /test </USERINPUT>
xfsdump: version <VARIABLE>X.X</VARIABLE> - type ^C for status and control
xfsdump: dump date: Fri Dec 2 11:25:19 1994
xfsdump: level 0 dump
xfsdump: session id: d23cc072-b21d-1001-8f97-080069068eeb
xfsdump: preparing tape drive
xfsdump: this tape contains data that is not part of an XFS dump
xfsdump: do you want to overwrite this tape?
type y to overwrite, n to change tapes or abort (y/n):
</CODE>
<PARAGRAPH>You must answer <USERINPUT>y</USERINPUT> if you want to continue with the dump session, or <USERINPUT>n</USERINPUT> to quit. If you answer <USERINPUT>y</USERINPUT>, the dump session resumes and the tape is overwritten. If you do not respond to the prompt, the session eventually times out. Note that this means that an automatic backup, for example one initiated by a <COMMAND>crontab</COMMAND> entry, will not succeed&mdash;unless you specified the <CMDLINEOPT>-F</CMDLINEOPT> option with the <COMMAND>xfsdump</COMMAND> command, which forces it to overwrite the tape rather than prompt for approval.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Erasing Used Tapes</TITLE><PARAGRAPH>Erase preexisting data on tapes with the <COMMAND>mt erase</COMMAND> command. Make sure the tape is not write-protected.</PARAGRAPH>
<PARAGRAPH>For example, to prepare a used tape in the local default tape drive, enter:</PARAGRAPH>
<CODE>
# <USERINPUT>mt -f /dev/tape erase</USERINPUT>
</CODE>
<CAUTION><PREFIX>Caution</PREFIX>This erases all data on the tape, including any dump sessions.</CAUTION>
<PARAGRAPH>The tape can now be used by <COMMAND>xfsdump</COMMAND> without prompting for approval.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>About Incremental and Resumed Dumps</TITLE><PARAGRAPH>Incremental dumps are a way of backing up less data at a time but still preserving current versions of all your backed-up files, directories, and so on. Incremental backups are organized numerically by levels from 0 through 9. A level 0 dump always backs up the complete filesystem. A dump level of any other number backs up all files that have changed since a dump with a lower dump level number.<INDEXTARGET ID="ch240"><!-- POSTPROCESSDATA: ch240|incremental dumps, <ITALICS>xfsdump</ITALICS> --><INDEXTARGET ID="ch241"><!-- POSTPROCESSDATA: ch241|<ITALICS>xfsdump</ITALICS>:incremental dumps --><INDEXTARGET ID="ch242"><!-- POSTPROCESSDATA: ch242|<ITALICS>xfsdump</ITALICS>:resumed dumps --></PARAGRAPH>
<PARAGRAPH>For example, if you perform a level 2 backup on a filesystem one day and your next dump is a level 3 backup, only those files that have changed since the level 2 backup are dumped with the level 3 backup. In this case, the level 2 backup is called the <ITALICS>base dump</ITALICS> for the level 3 backup. The base dump is the most recent backup of that filesystem with a lower dump level number.</PARAGRAPH>
<PARAGRAPH>Resumed dumps work in much the same way. When a dump is resumed after it has been interrupted, the remaining files that had been scheduled to be backed up during the interrupted dump session are backed up, and any files that changed during the interruption are also backed up. Note that you must restore an interrupted dump as if it is an incremental dump (see <XREF IDREF="56687" TYPE="TITLE">&ldquo;Performing Cumulative Restores with xfsrestore&rdquo;</XREF>).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Performing an Incremental xfsdump</TITLE><PARAGRAPH>In the following example, a level 0 dump is the first backup written to a new tape:</PARAGRAPH>
<CODE>
# <USERINPUT>xfsdump -f /dev/tape -l 0 -M Jun_94 -L week_1 -v silent /usr</USERINPUT>
</CODE>
<PARAGRAPH>A week later, a level 1 dump of the filesystem is performed on the same tape:</PARAGRAPH>
<CODE>
# <USERINPUT>xfsdump -f /dev/tape -l 1 -L week_2 /usr</USERINPUT>
</CODE>
<PARAGRAPH>The tape is forwarded past the existing dump data and the new data from the level 1 dump is written after it. (Note that it is not necessary to specify the media label for each successive dump on a media object.)</PARAGRAPH>
<PARAGRAPH>A week later, a level 2 dump is taken and so on, for the four weeks of a month in this example, the fourth week being a level 3 dump (up to nine dump levels are supported):</PARAGRAPH>
<CODE>
# <USERINPUT>xfsdump -f /dev/tape -l 2 -L week_3 /usr</USERINPUT>
</CODE>
<PARAGRAPH>Refer to <XREF IDREF="56687" TYPE="TITLE">&ldquo;Performing Cumulative Restores with xfsrestore&rdquo;</XREF> for information on the proper procedure for restoring incremental dumps.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Performing a Resumed xfsdump</TITLE><PARAGRAPH>You can interrupt a dump session and resume it later. To interrupt a dump session, type the interrupt character (typically <USERINPUT>&lt;CTRL-C></USERINPUT>). You receive a list of options which allow you to interrupt the session, change verbosity level, or resume the session. </PARAGRAPH>
<PARAGRAPH>In the following example, <COMMAND>xfsdump</COMMAND> is interrupted after dumping approximately 37% of a filesystem:</PARAGRAPH>
<CODE>
# <USERINPUT>xfsdump -f /dev/tape -M march95 -L week_1 -v silent /disk2</USERINPUT>
========================= status and control dialog ==========================
status at 16:49:16: 378/910 files dumped, 37.8% complete, 32 seconds elapsed
please select one of the following operations
1: interrupt this session
2: change verbosity
3: display metrics
4: other controls
5: continue (default) (timeout in 60 sec)
&space;-> 1
please confirm
1: interrupt this session
2: continue (default) (timeout in 60 sec)
&space;-> 1
interrupt request accepted
--------------------------------- end dialog ---------------------------------
xfsdump: initiating session interrupt
xfsdump: dump interrupted prior to ino 1053172 offset 0
</CODE>
<PARAGRAPH>You can later continue the dump by including the<CMDLINEOPT>&space;&ndash;R</CMDLINEOPT> option and a different session label:</PARAGRAPH>
<CODE>
# <USERINPUT>xfsdum -f /dev/tape -R -L week_1.contd -v silent /disk2p</USERINPUT>
</CODE>
<PARAGRAPH>Any files that were not backed up before the interruption, and any file changes that were made during the interruption, are backed up after the dump is resumed.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>Use of the <CMDLINEOPT>&ndash;R</CMDLINEOPT> option requires that the dump was made with a dump inventory taken, that is, the <CMDLINEOPT>&ndash;J</CMDLINEOPT> option was not used with <COMMAND>xfsdump</COMMAND>.</NOTE>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="68879">Examining xfsdump Archives</TITLE><PARAGRAPH>This section describes how to use the <COMMAND>xfsdump</COMMAND> command to view an <COMMAND>xfsdump</COMMAND> inventory.</PARAGRAPH>
<PARAGRAPH>The <INDEXTARGET ID="ch243"><!-- POSTPROCESSDATA: ch243|<ITALICS>xfsdump</ITALICS>:dump inventory --><INDEXTARGET ID="ch244"><!-- POSTPROCESSDATA: ch244|inventory, <ITALICS>xfsdump</ITALICS> --><COMMAND>xfsdump</COMMAND> inventory is maintained in the directory <FILENAME>/var/xfsdump </FILENAME>created by <COMMAND>xfsdump</COMMAND>. You can view the dump inventory at any time with the <COMMAND>xfsdump &ndash;I</COMMAND> command. With no other arguments, <COMMAND>xfsdump &ndash;I</COMMAND> displays the entire dump inventory. (The <COMMAND>xfsdump -I</COMMAND> command does not require root privileges.)</PARAGRAPH>
<PARAGRAPH>The following output presents a section of a dump inventory.</PARAGRAPH>
<CODE>
# <USERINPUT>xfsdump -I | more</USERINPUT>
file system 0:
&space;       fs id:          d23cb450-b21d-1001-8f97-080069068eeb
&space;       session 0:
&space;               mount point:    magnolia.abc.xyz.com:/test
&space;               device:         magnolia.abc.xyz.com:/dev/rdsk/dks0d3s2
&space;               time:           Mon Nov 28 11:44:04 1994
&space;               session label:  ""
&space;               session id:     d23cbf44-b21d-1001-8f97-080069068eeb
&space;               level:          0
&space;               resumed:        NO
&space;               subtree:        NO
&space;               streams:        1
&space;               stream 0:
&space;                       pathname:       /dev/tape
&space;                       start:          ino 4121 offset 0
&space;                       end:            ino 0 offset 0
&space;                       interrupted:    YES
&space;                       media files:    2
&space;                       media file 0:
&space;                               mfile index:    0
---more---
</CODE>
<PARAGRAPH>Notice that the dump inventory records are presented sequentially and are indented to illustrate the hierarchical order of the dump information. </PARAGRAPH>
<PARAGRAPH>You can view a subset of the dump inventory by specifying the level of depth (1, 2, or 3) that you want to view. For example, specifying depth=2 filters out a lot of the specific dump information as you can see by comparing the previous output with this:</PARAGRAPH>
<CODE>
# <USERINPUT>xfsdump -I depth=2</USERINPUT>
file system 0:
&space;       fs id:          d23cb450-b21d-1001-8f97-080069068eeb
&space;       session 0:
&space;               mount point:    magnolia.abc.xyz.com:/test
&space;               device:         magnolia.abc.xyz.com:/dev/rdsk/dks0d3s2
&space;               time:           Mon Nov 28 11:44:04 1994
&space;               session label:  ""
&space;               session id:     d23cbf44-b21d-1001-8f97-080069068eeb
&space;               level:          0
&space;               resumed:        NO
&space;               subtree:        NO
&space;               streams:        1
&space;       session 1:
&space;               mount point:    magnolia.abc.xyz.com:/test
&space;               device:         magnolia.abc.xyz.com:/dev/rdsk/dks0d3s2
&space;              .
&space;              .
&space;              .
</CODE>
<PARAGRAPH>You can also view a filesystem-specific inventory by specifying the filesystem mount point with the <COMMAND>mnt</COMMAND> option. The following output shows an example of a dump inventory display in which the <COMMAND>depth</COMMAND> is set to <COMMAND>1</COMMAND>, and only a single filesystem is displayed:</PARAGRAPH>
<CODE>
# <USERINPUT>xfsdump -I depth=1,mnt=magnolia.abc.xyz.com:/test</USERINPUT>
filesystem 0:
&space;       fs id:          d23cb450-b21d-1001-8f97-080069068eeb
</CODE>
<PARAGRAPH>Note that you can also look at a list of contents on the dump media itself by using the<CMDLINEOPT>&space;&ndash;t</CMDLINEOPT> option with <COMMAND>xfsrestore</COMMAND>. (The <COMMAND>xfsrestore</COMMAND> utility is discussed in detail in the following section.) For example, to list the contents of the dump tape currently in the local tape drive, type:</PARAGRAPH>
<CODE>
# <USERINPUT>xfsrestore -f /dev/tape -t -v silent | more</USERINPUT>
xfsrestore: dump session found
xfsrestore: session label: "week_1"
xfsrestore: session id: d23cbcb4-b21d-1001-8f97-080069068eeb
xfsrestore: no media label
xfsrestore: media id: d23cbcb5-b21d-1001-8f97-080069068eeb
do you want to select this dump? (y/n): <USERINPUT>y</USERINPUT>
selected
one
A/five
people/fred/TOC
people/fred/ch3.doc
people/fred/ch3TOC.doc
people/fred/questions
A/four
people/fred/script_0
people/fred/script_1
people/fred/script_2
people/fred/script_3
people/fred/sub1/TOC
people/fred/sub1/ch3.doc
people/fred/sub1/ch3TOC.doc
people/fred/sub1/questions
people/fred/sub1/script_0
people/fred/sub1/script_1
people/fred/sub1/script_2
people/fred/sub1/script_3
people/fred/sub1/xdump1.doc
people/fred/sub1/xdump1.doc.backup
people/fred/sub1/xfsdump.doc
people/fred/sub1/xfsdump.doc.auto
people/fred/sub1/sub2/TOC
---more---
</CODE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>About xfsrestore</TITLE><PARAGRAPH>This section discusses the <INDEXTARGET ID="ch245"><!-- POSTPROCESSDATA: ch245|<ITALICS>xfsrestore</ITALICS>:using --><COMMAND>xfsrestore</COMMAND> command, which you must use to view and extract data from the dump data created by <COMMAND>xfsdump</COMMAND>. You can get a summary of <COMMAND>xfsrestore</COMMAND> syntax with the <CMDLINEOPT>&ndash;h</CMDLINEOPT> option:</PARAGRAPH>
<CODE>
# <USERINPUT>xfsrestore -h</USERINPUT>
xfsrestore: version <VARIABLE>X.X</VARIABLE>
xfsrestore: usage: xfsrestore [ -a &lt;alt. workspace dir> ... ]
&space;                    [ -e (don't overwrite existing files) ]
&space;                    [ -f &lt;source> ... ]
&space;                    [ -h (help) ]
&space;                    [ -i (interactive) ]
&space;                    [ -n &lt;file> (restore only if newer than) ]
&space;                    [ -o (restore owner/group even if not root) ]
&space;                    [ -p &lt;seconds between progress reports> ]
&space;                    [ -r (cumulative restore) ]
&space;                    [ -s &lt;subtree> ... ]
&space;                    [ -t (contents only) ]
&space;                    [ -v &lt;verbosity {silent, verbose, trace}> ]
&space;                    [ -A (don't restore extended file attributes) ]
&space;                    [ -C (check tape record checksums) ]
&space;                    [ -D (restore DMAPI event settings) ]
&space;                    [ -E (don't overwrite if changed) ]
&space;                    [ -F (don't prompt) ]
&space;                    [ -I (display dump inventory) ]
&space;                    [ -J (inhibit inventory update) ]
&space;                    [ -L &lt;session label> ]
&space;                    [ -N (timestamp messages) ]
&space;                    [ -O &lt;options file> ]
&space;                    [ -P (pin down I/O buffers) ]
&space;                    [ -Q (force interrupted session completion) ]
&space;                    [ -R (resume) ]
&space;                    [ -S &lt;session id> ]
&space;                    [ -T (don't timeout dialogs) ]
&space;                    [ -U (unload media when change needed) ]
&space;                    [ -V (show subsystem in messages) ]
&space;                    [ -W (show verbosity in messages) ]
&space;                    [ -X &lt;excluded subtree> ... ]
&space;                    [ -Y &lt;I/O buffer ring length> ]
&space;                    [ -Z (miniroot restrictions) ]
&space;                    [ - (stdin) ]
&space;                    [ &lt;destination> ]
</CODE>
<PARAGRAPH>Use <COMMAND>xfsrestore</COMMAND> to restore data backed up with <COMMAND>xfsdump</COMMAND>. You can restore files, subdirectories, and filesystems&mdash;regardless of the way they were backed up. For example, if you back up an entire filesystem in a single dump, you can select individual files and subdirectories from within that filesystem to restore.</PARAGRAPH>
<PARAGRAPH>You can use <COMMAND>xfsrestore</COMMAND> interactively or noninteractively. With interactive mode, you can peruse the filesystem or files backed up, selecting those you want to restore. In noninteractive operation, a single command line can restore selected files and subdirectories, or an entire filesystem. You can restore data to its original filesystem location or any other location in an EFS or XFS filesystem.</PARAGRAPH>
<PARAGRAPH>By using successive invocations of <COMMAND>xfsrestore</COMMAND>, you can restore incremental dumps on a base dump. This restores data in the same sequence it was dumped.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Performing Simple Restores with xfsrestore</TITLE><PARAGRAPH>A simple restore is a non-cumulative restore (for information on restoring incremental dumps, refer to <INDEXTARGET ID="ch246"><!-- POSTPROCESSDATA: ch246|<ITALICS>xfsrestore</ITALICS>:simple restores --><INDEXTARGET ID="ch247"><!-- POSTPROCESSDATA: ch247|<ITALICS>xfsrestore</ITALICS>:session label --><INDEXTARGET ID="ch248"><!-- POSTPROCESSDATA: ch248|<ITALICS>xfsrestore</ITALICS>:session ID --><XREF IDREF="56687" TYPE="TITLE">&ldquo;Performing Cumulative Restores with xfsrestore&rdquo;</XREF>). An example of a simple, noninteractive use of <COMMAND>xfsrestore</COMMAND> is:</PARAGRAPH>
<CODE>
# <USERINPUT>xfsrestore -f /dev/tape /disk2</USERINPUT>
xfsrestore: version 2.0 - type ^C for status and control
xfsrestore: searching media for dump
xfsrestore: preparing drive
xfsrestore: examining media file 0

&space;=========================== dump selection dialog ============================

the following dump has been found on drive 0

hostname: cumulus
mount point: /disk2
volume: /dev/rdsk/dks0d2s0
session time: Wed Oct 25 16:59:00 1995
level: 0
session label: &ldquo;tape1&rdquo;
media label: &ldquo;media1&rdquo;
file system id: d2a602fc-b21d-1001-8938-08006906dc5c
session id: d2a61284-b21d-1001-8938-08006906dc5c
media id: d2a61285-b21d-1001-8938-08006906dc5c

restore this dump?
1: skip
2: restore (default)
&space;-> <USERINPUT>2</USERINPUT>
this dump selected for restoral

&space;--------------------------------- end dialog ---------------------------------

xfsrestore: using online session inventory
xfsrestore: searching media for directory dump
xfsrestore: reading directories
xfsrestore: directory post-processing
xfsrestore: restoring non-directory files
xfsrestore: I/O metrics: 3 by 2MB ring; 9/13 (69%) records streamed; 204600B/s
xfsrestore: restore complete: 104 seconds elapsed
</CODE>
<PARAGRAPH>In this case, <COMMAND>xfsrestore</COMMAND> went to the first dump on the tape and asked if this was the dump to restore. If you had entered <USERINPUT>1</USERINPUT> for &ldquo;skip,&rdquo; <COMMAND>xfsrestore</COMMAND> would have proceeded to the next dump on the tape (if there was one) and asked if this was the dump you wanted to restore.</PARAGRAPH>
<PARAGRAPH>You can request a specific dump if you used <COMMAND>xfsdump</COMMAND> with a session label. For example:</PARAGRAPH>
<CODE>
# <USERINPUT>xfsrestore -f /dev/tape -L Wed_11_23 /usr</USERINPUT>
xfsrestore: version <VARIABLE>X.X</VARIABLE> - type ^C for status and control
xfsrestore: preparing tape drive
xfsrestore: dump session found
xfsrestore: advancing tape to next media file
xfsrestore: dump session found
xfsrestore: restore of level 0 dump of magnolia.abc.xyz.com:/usr created Wed Nov 23 11:17:54 1994
xfsrestore: beginning media file
xfsrestore: reading ino map
xfsrestore: initializing the map tree
xfsrestore: reading the directory hierarchy
xfsrestore: restoring non-directory files
xfsrestore: ending media file
xfsrestore: restoring directory attributes
xfsrestore: restore complete: 200 seconds elapsed
</CODE>
<PARAGRAPH>In this way you recover a dump with a single command line and do not have to answer <USERINPUT>y</USERINPUT> or <USERINPUT>n</USERINPUT> to the prompt(s) asking you if the dump session found is the correct one. To be even more exact, use the <CMDLINEOPT>-S</CMDLINEOPT> option and specify the unique session ID of the particular dump session:</PARAGRAPH>
<CODE>
# <USERINPUT>xfsrestore -f /dev/tape -S \</USERINPUT>
<USERINPUT>d23cbf47-b21d-1001-8f97-080069068eeb /usr2/tmp</USERINPUT>
xfsrestore: version <VARIABLE>X.X</VARIABLE> - type ^C for status and control
xfsrestore: preparing tape drive
xfsrestore: dump session found
xfsrestore: advancing tape to next media file
xfsrestore: advancing tape to next media file
xfsrestore: dump session found
xfsrestore: restore of level 0 dump of magnolia.abc.xyz.com:/test resumed Mon Nov 28 11:50:41 1994
xfsrestore: beginning media file
xfsrestore: media file 0 (media 0, file 2)
xfsrestore: reading ino map
xfsrestore: initializing the map tree
xfsrestore: reading the directory hierarchy
xfsrestore: restoring non-directory files
xfsrestore: ending media file
xfsrestore: restoring directory attributes
xfsrestore: restore complete: 229 seconds elapsed
</CODE>
<PARAGRAPH>You can find the session ID by viewing the dump inventory (see <XREF IDREF="68879" TYPE="TITLE">&ldquo;Examining xfsdump Archives&rdquo;</XREF>). Session labels might be duplicated, but session IDs never are.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Restoring Individual Files with xfsrestore</TITLE><PARAGRAPH>On the <INDEXTARGET ID="ch249"><!-- POSTPROCESSDATA: ch249|<ITALICS>xfsrestore</ITALICS>:restoring files --><COMMAND>xfsrestore</COMMAND> command line, you can specify an individual file or subdirectory to restore. In this example, the file <FILENAME>people/fred/notes</FILENAME> is restored and placed in the <FILENAME>/usr/tmp</FILENAME> directory (that is, the file is restored in <FILENAME>/usr/tmp/people/fred/notes</FILENAME>):</PARAGRAPH>
<CODE>
# <USERINPUT>xfsrestore -f /dev/tape -L week_1 -s people/fred/notes /usr/tmp</USERINPUT>
</CODE>
<PARAGRAPH>You can also restore a file &ldquo;in place&rdquo; that is, restore it directly to where it came from in the original backup. Note, however, that if you do not use a <CMDLINEOPT>-e</CMDLINEOPT>, <CMDLINEOPT>-E</CMDLINEOPT>, or <CMDLINEOPT>-n</CMDLINEOPT> option, you overwrite any existing file(s) of the same name. </PARAGRAPH>
<PARAGRAPH>In the following example, the subdirectory <FILENAME>people/fred</FILENAME> is restored in the destination <FILENAME>/usr</FILENAME>&mdash; this overwrites any files and subdirectories in <FILENAME>/usr/people/fred</FILENAME> with the data on the dump tape:</PARAGRAPH>
<CODE>
# <USERINPUT>xfsrestore -f /dev/tape -L week_1 -s people/fred /usr</USERINPUT>
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Performing Network Restores with xfsrestore</TITLE><PARAGRAPH>You can use standard network references to specify devices and files on the network. For example, to use the tape drive on a network host named <INDEXTARGET ID="ch250"><!-- POSTPROCESSDATA: ch250|<ITALICS>xfsrestore</ITALICS>:network usage --><ITALICS>magnolia</ITALICS> as the source for a restore, you can use the command:</PARAGRAPH>
<CODE>
# <USERINPUT>xfsrestore -f magnolia:/dev/tape -L 120694u2 /usr2</USERINPUT>
xfsrestore: version <VARIABLE>X.X</VARIABLE> - type ^C for status and control
xfsrestore: preparing tape drive
xfsrestore: dump session found
xfsrestore: advancing tape to next media file
xfsrestore: dump session found
xfsrestore: restore of level 0 dump of magnolia.abc.xyz.com:/usr2 created Tue Dec 6 10:55:17 1994
xfsrestore: beginning media file
xfsrestore: media file 0 (media 0, file 1)
xfsrestore: reading ino map
xfsrestore: initializing the map tree
xfsrestore: reading the directory hierarchy
xfsrestore: restoring non-directory files
xfsrestore: ending media file
xfsrestore: restoring directory attributes
xfsrestore: restore complete: 203 seconds elapsed
</CODE>
<PARAGRAPH>In this case, the dump data is extracted from the tape on <ITALICS>magnolia</ITALICS>, and the destination is the directory <FILENAME>/usr2</FILENAME> on the local system. Refer to the section <XREF IDREF="61361" TYPE="TITLE">&ldquo;Using xfsdump and xfsrestore to Copy Filesystems&rdquo;</XREF> for an example of using the standard input option of <COMMAND>xfsrestore</COMMAND>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Performing Interactive Restores with xfsrestore</TITLE><PARAGRAPH>Use the <INDEXTARGET ID="ch251"><!-- POSTPROCESSDATA: ch251|<ITALICS>xfsrestore</ITALICS>:interactive restore --><INDEXTARGET ID="ch252"><!-- POSTPROCESSDATA: ch252|interactive restore, <ITALICS>xfsrestore</ITALICS> --><CMDLINEOPT>&ndash;i</CMDLINEOPT> option of <COMMAND>xfsrestore</COMMAND> to perform interactive file restoration. With interactive restoration, you can use the commands <COMMAND>ls</COMMAND>, <COMMAND>pwd</COMMAND>, and <COMMAND>cd</COMMAND> to peruse the filesystem, and the <COMMAND>add</COMMAND> and <COMMAND>delete</COMMAND> commands to create a list of files and subdirectories you want to restore. Then you can enter the <COMMAND>extract</COMMAND> command to restore the files, or <COMMAND>quit</COMMAND> to exit the interactive restore session without restoring files. (The use of &ldquo;wildcards&rdquo; is not allowed with these commands.)</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>Interactive restore is not allowed when the <COMMAND>xfsrestore</COMMAND> source is standard input (STDIN).</NOTE>
<PARAGRAPH>The following screen output shows an example of a simple interactive restoration.</PARAGRAPH>
<CODE>
# <USERINPUT>xfsrestore -f /dev/tape -i -v silent .</USERINPUT>
xfsrestore: dump session found
xfsrestore: no session label
xfsrestore: session id:    d23cbeda-b21d-1001-8f97-080069068eeb
xfsrestore: no media label
xfsrestore: media id:      d23cbedb-b21d-1001-8f97-080069068eeb
do you want to select this dump? (y/n): <USERINPUT>y</USERINPUT>
selected

&space;--- interactive subtree selection dialog ---

the following commands are available:
&space;       pwd 
&space;       ls [ { &lt;name>, ".." } ]
&space;       cd [ { &lt;name>, ".." } ]
&space;       add [ &lt;name> ]
&space;       delete [ &lt;name> ]
&space;       extract 
&space;       quit 
&space;       help 
&space;-> <USERINPUT>ls</USERINPUT>
&space;           4122 people/
&space;           4130 two 
&space;           4126 A/
&space;           4121 one 
&space;-> <USERINPUT>add two</USERINPUT>
&space;-> <USERINPUT>cd people</USERINPUT>
&space;-> <USERINPUT>ls</USERINPUT>
&space;           4124 fred/
&space;-> <USERINPUT>add fred</USERINPUT>
&space;-> <USERINPUT>ls</USERINPUT>
&space;   *       4124 fred/
&space;-> <USERINPUT>extract</USERINPUT>

&space;---------------- end dialog ----------------
</CODE>
<PARAGRAPH>In the interactive restore session above, the subdirectory <FILENAME>people/fred</FILENAME> and the file <FILENAME>two</FILENAME> were restored relative to the current working directory (&ldquo;.&rdquo;). Note that an asterisk (*) in your <COMMAND>ls</COMMAND> output indicates your selections.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="56687">Performing Cumulative Restores with xfsrestore</TITLE><PARAGRAPH>Cumulative restores sequentially restore incremental dumps to re-create filesystems and are also used to restore interrupted dumps. To perform a cumulative restore of a filesystem, begin with the media object that contains the base level dump and recover it first, then recover the incremental dump with the next higher dump level number, then the next, and so on. Use the <INDEXTARGET ID="ch253"><!-- POSTPROCESSDATA: ch253|<ITALICS>xfsrestore</ITALICS>:cumulative restores --><INDEXTARGET ID="ch254"><!-- POSTPROCESSDATA: ch254|cumulative restores, <ITALICS>xfsrestore</ITALICS> --><CMDLINEOPT>&ndash;r</CMDLINEOPT> option to inform <COMMAND>xfsrestore</COMMAND> that you are performing a cumulative recovery. </PARAGRAPH>
<PARAGRAPH>In the following example, the level 0 base dump and succeeding higher level dumps are on <FILENAME>/dev/tape</FILENAME>. First the level 0 dump is restored, then each higher level dump in succession:</PARAGRAPH>
<CODE>
# <USERINPUT>/usr/tmp/xfsrestore -f /dev/tape -r -v silent .</USERINPUT>

&space;=========================== dump selection dialog ============================

the following dump has been found on drive 0

hostname: cumulus
mount point: /disk2
volume: /dev/rdsk/dks0d2s0
session time: Wed Oct 25 14:37:47 1995
level: 0
session label: &ldquo;week_1&rdquo;
media label: &ldquo;Jun_94&rdquo;
file system id: d2a602fc-b21d-1001-8938-08006906dc5c
session id: d2a60b26-b21d-1001-8938-08006906dc5c
media id: d2a60b27-b21d-1001-8938-08006906dc5c

restore this dump?
1: skip
2: restore (default)
&space;-> <USERINPUT>Enter</USERINPUT>
this dump selected for restoral

&space;--------------------------------- end dialog ---------------------------------

#
</CODE>
<PARAGRAPH>Next, enter the same command again. The program goes to the next dump and again you select the default:</PARAGRAPH>
<CODE>
# <USERINPUT>xfsrestore -f /dev/tape -r -v silent .</USERINPUT>

&space;=========================== dump selection dialog ============================

the following dump has been found on drive 0

hostname: cumulus
mount point: /disk2
volume: /dev/rdsk/dks0d2s0
session time: Wed Oct 25 14:40:54 1995
level: 1
session label: &ldquo;week_2&rdquo;
media label: &ldquo;Jun_94&rdquo;
file system id: d2a602fc-b21d-1001-8938-08006906dc5c
session id: d2a60b2b-b21d-1001-8938-08006906dc5c
media id: d2a60b27-b21d-1001-8938-08006906dc5c

restore this dump?
1: skip
2: restore (default)
&space;-> <USERINPUT>Enter</USERINPUT>
this dump selected for restoral

&space;--------------------------------- end dialog ---------------------------------
#
</CODE>
<PARAGRAPH>You then repeat this process until you have recovered the entire sequence of incremental dumps. The full and latest copy of the filesystem will then have been restored. In this case, it is restored relative to &ldquo;.&rdquo;, that is, in the directory you are in when the sequence of <COMMAND>xfsrestore</COMMAND> commands is issued.</PARAGRAPH>
<PARAGRAPH>Restore an interrupted dump just as if it were an incremental dump. Use the <INDEXTARGET ID="ch255"><!-- POSTPROCESSDATA: ch255|restoring interrupted dumps, <ITALICS>xfsrestore</ITALICS> --><INDEXTARGET ID="ch256"><!-- POSTPROCESSDATA: ch256|<ITALICS>xfsrestore</ITALICS>:restoring interrupted dumps --><CMDLINEOPT>-r</CMDLINEOPT> option to inform <COMMAND>xfsrestore</COMMAND> that you are performing an incremental restore, and answer <USERINPUT>y</USERINPUT> and <USERINPUT>n</USERINPUT> appropriately to select the proper &ldquo;increments&rdquo; to restore (see <XREF IDREF="56687" TYPE="TITLE">&ldquo;Performing Cumulative Restores with xfsrestore&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>Note that if you try to restore an interrupted dump as if it were a non-interrupted, non-incremental dump, the portion of the dump that occurred before the interruption is restored, but not the remainder of the dump. You can determine if a dump is an interrupted dump by looking in the online inventory.</PARAGRAPH>
<PARAGRAPH>Here is an example of a dump inventory showing an interrupted dump session (the crucial fields are in bold type):</PARAGRAPH>
<CODE>
# <USERINPUT>xfsdump -I depth=3,mobjlabel=AugTape,mnt=indy4.xyz.com:/usr</USERINPUT>
file system 0:
&space;       fs id:          d23cb450-b21d-1001-8f97-080069068eeb
&space;       session 0:
&space;               mount point:    indy4.xyz.com.com:/usr
&space;               device:         indy4.xyz.com.com:/dev/rdsk/dks0d3s2
&space;               time:           Tue Dec  6 15:01:26 1994
&space;               session label:  "180894usr"
&space;               session id:     d23cc0c3-b21d-1001-8f97-080069068eeb
&space;               level:          0
&space;               resumed:        NO
&space;               subtree:        NO
&space;               streams:        1
&space;               stream 0:
&space;                       pathname:       /dev/tape
&space;                       start:          ino 4121 offset 0
&space;                       end:            ino 0 offset 0
&space;                       <BOLD>interrupted:    YES</BOLD>
&space;                       media files:    2
&space;       session 1:
&space;               mount point:    indy4.xyz.com.com:/usr
&space;               device:         indy4.xyz.com.com:/dev/rdsk/dks0d3s2
&space;               time:           Tue Dec  6 15:48:37 1994
&space;               session label:  "Resumed180894usr"
&space;               session id:     d23cc0cc-b21d-1001-8f97-080069068eeb
&space;               level:          0
&space;               <BOLD>resumed:        YES</BOLD>
&space;               subtree:        NO
&space;               streams:        1
&space;               stream 0:
&space;                       pathname:       /dev/tape
&space;                       start:          ino 4121 offset 0
&space;                       end:            ino 0 offset 0
&space;                       <BOLD>interrupted:    NO</BOLD>
&space;                       media files:    2
.
.
.
</CODE>
<PARAGRAPH>From this it can be determined that session 0 was interrupted and then resumed and completed in session 1.</PARAGRAPH>
<PARAGRAPH>To restore the interrupted dump session in the example above, use the following sequence of commands:</PARAGRAPH>
<CODE>
# <USERINPUT>xfsrestore -f /dev/tape -r -L 180894usr .</USERINPUT>
# <USERINPUT>xfsrestore -f /dev/tape -r -L Resumed180894usr .</USERINPUT>
</CODE>
<PARAGRAPH>This restores the entire <FILENAME>/usr</FILENAME> backup relative to the current directory. (You should remove the <FILENAME>housekeeping</FILENAME> directory from the destination directory when you are finished.)</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Interrupting xfsrestore</TITLE><PARAGRAPH>In a manner similar to <INDEXTARGET ID="ch257"><!-- POSTPROCESSDATA: ch257|<ITALICS>xfsrestore</ITALICS>:interrupted restores --><INDEXTARGET ID="ch258"><!-- POSTPROCESSDATA: ch258|interrupted restores, <ITALICS>xfsrestore</ITALICS> --><COMMAND>xfsdump</COMMAND> interruptions, you can interrupt an <COMMAND>xfsrestore</COMMAND> session. This allows you to interrupt a restore session and then resume it later. To interrupt a restore session, type the interrupt character (typically <USERINPUT>&lt;CTRL-C></USERINPUT>). You receive a list of options, which include interrupting the session or continuing.</PARAGRAPH>
<CODE>
# <USERINPUT>xfsrestore -f /dev/tape -v silent /disk2</USERINPUT>

&space;=========================== dump selection dialog ============================

the following dump has been found on drive 0

hostname: cumulus
mount point: /disk2
volume: /dev/rdsk/dks0d2s0
session time: Wed Oct 25 17:20:16 1995
level: 0
session label: &ldquo;week1&rdquo;
media label: &ldquo;newtape&rdquo;
file system id: d2a602fc-b21d-1001-8938-08006906dc5c
session id: d2a6129e-b21d-1001-8938-08006906dc5c
media id: d2a6129f-b21d-1001-8938-08006906dc5c

restore this dump?
1: skip
2: restore (default)
&space;-> <USERINPUT>2</USERINPUT>
this dump selected for restoral

&space;--------------------------------- end dialog ---------------------------------


&space;========================= status and control dialog ==========================

status at 17:23:52: 131/910 files restored, 14.4% complete, 42 seconds elapsed

please select one of the following operations
1: interrupt this session
2: change verbosity
3: display metrics
4: other controls
5: continue (default) (timeout in 60 sec)
&space;-> <USERINPUT>1</USERINPUT>

please confirm
1: interrupt this session
2: continue (default) (timeout in 60 sec)
&space;-> <USERINPUT>1</USERINPUT>
interrupt request accepted

&space;--------------------------------- end dialog ---------------------------------

xfsrestore: initiating session interrupt

</CODE>
<PARAGRAPH>Resume the <COMMAND>xfsrestore</COMMAND> session with the <CMDLINEOPT>&ndash;R</CMDLINEOPT> option:</PARAGRAPH>
<CODE>
#<USERINPUT>&space;xfsrestore -f /dev/tape -R -v silent /disk2</USERINPUT>
</CODE>
<PARAGRAPH>Data recovery continues from the point of the interruption.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>About the housekeeping and orphanage Directories</TITLE><PARAGRAPH>The <INDEXTARGET ID="ch259"><!-- POSTPROCESSDATA: ch259|<ITALICS>housekeeping</ITALICS> directory --><INDEXTARGET ID="ch260"><!-- POSTPROCESSDATA: ch260|<ITALICS>orphanage</ITALICS> directory --><COMMAND>xfsrestore</COMMAND> utility can create two subdirectories in the destination called <FILENAME>housekeeping</FILENAME> and <FILENAME>orphanage</FILENAME>. </PARAGRAPH>
<PARAGRAPH>The <FILENAME>housekeeping</FILENAME> directory is a temporary directory used during cumulative recovery to pass information from one invocation of <COMMAND>xfsrestore</COMMAND> to the next. It must not be removed during the process of performing the cumulative recovery but should be removed after the cumulative recovery is completed.</PARAGRAPH>
<PARAGRAPH>The <FILENAME>orphanage</FILENAME> directory is created if a file or subdirectory is restored that is not referenced in the filesystem structure of the dump. For example, if you dump a very active filesystem, it is possible for new files to be in the non-directory portion of the dump, yet none of the directories dumped reference that file. A warning message is displayed, and the file is placed in the <FILENAME>orphanage</FILENAME> directory, named with its original inode number and generation count (for example, 123479.14.).</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="61361">Using xfsdump and xfsrestore to Copy Filesystems</TITLE><PARAGRAPH>You can use <INDEXTARGET ID="ch261"><!-- POSTPROCESSDATA: ch261|<ITALICS>xfsdump</ITALICS>:network usage --><INDEXTARGET ID="ch262"><!-- POSTPROCESSDATA: ch262|<ITALICS>xfsrestore</ITALICS>:network usage --><INDEXTARGET ID="ch263"><!-- POSTPROCESSDATA: ch263|<ITALICS>xfsdump</ITALICS>:STDOUT --><INDEXTARGET ID="ch264"><!-- POSTPROCESSDATA: ch264|<ITALICS>xfsrestore</ITALICS>:STDIN --><COMMAND>xfsdump</COMMAND> and <COMMAND>xfsrestore</COMMAND> to pipe data across filesystems or across the network with a single command line. By piping <COMMAND>xfsdump</COMMAND> standard output to <COMMAND>xfsrestore</COMMAND> standard input you create an exact copy of a filesystem.</PARAGRAPH>
<PARAGRAPH>For example, to make a copy of <FILENAME>/usr/people/fred</FILENAME> in the <FILENAME>/usr2</FILENAME> directory, enter:</PARAGRAPH>
<CODE>
# <USERINPUT>xfsdump -J -s people/fred - /usr | xfsrestore - /usr2</USERINPUT>
</CODE>
<PARAGRAPH>To copy <FILENAME>/usr/people/fred</FILENAME> to the network host <ITALICS>magnolia</ITALICS>'s <FILENAME>/usr/tmp </FILENAME>directory:</PARAGRAPH>
<CODE>
#<USERINPUT>&space;xfsdump -J -s people/fred - /usr | rsh magnolia \</USERINPUT>
<USERINPUT>xfsrestore - /usr/tmp</USERINPUT>
</CODE>
<PARAGRAPH>This creates the directory <FILENAME>/usr/tmp/people/fred</FILENAME> on <ITALICS>magnolia</ITALICS>.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>The superuser account on the local system must be able to <COMMAND>rsh</COMMAND> to the remote system without a password. For more information, see<REFPAGE>&space;hosts.equiv(4)</REFPAGE>.</NOTE>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="53826">About tar</TITLE><PARAGRAPH>The <INDEXTARGET ID="ch265"><!-- POSTPROCESSDATA: ch265|<ITALICS>tar</ITALICS>:capabilities --><COMMAND>tar</COMMAND> (tape archive) utility backs up files and directories. You can copy files to tape, create <COMMAND>tar</COMMAND> files, compare files on tape to files on disk, read standard input, and pipe the output of<COMMAND>&space;tar</COMMAND> to other processes. This command is widely used on UNIX systems worldwide. See <REFPAGE>tar(1)</REFPAGE> for more details.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>The <CMDLINEOPT>-K</CMDLINEOPT> option of <COMMAND>tar</COMMAND> is for files larger than 2 GB. Without the <CMDLINEOPT>-K</CMDLINEOPT> option, <COMMAND>tar</COMMAND> skips any files larger than 2 GB and issues a warning. Note that use of this option can create <COMMAND>tar</COMMAND> archives that are unusable except on XFS systems. The <CMDLINEOPT>-K</CMDLINEOPT> option is incompatible with the <CMDLINEOPT>-O</CMDLINEOPT> option, which creates an old (pre-POSIX) <COMMAND>tar</COMMAND> archive format.</NOTE>
<SECTION2 LBL="" HELPID = ""><TITLE>Backing Up Files with tar</TITLE><PARAGRAPH>To back up individual files with <COMMAND>tar</COMMAND>, use the command:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>tar c </USERINPUT><VARIABLE>file</VARIABLE>
</EXAMPLE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Using tar to Back Up Files by Modification Date </TITLE><PARAGRAPH>The <COMMAND>tar</COMMAND> command does not have the capability of saving files by modification date built in. However, you can use the <COMMAND>find</COMMAND> command to archive files that have not been modified in a particular number of days:&space;<INDEXTARGET ID="ch266"><!-- POSTPROCESSDATA: ch266|<ITALICS>tar</ITALICS>:making backups --></PARAGRAPH>
<EXAMPLE>
<USERINPUT>find /usr -mtime 5 -local -type f -o -type </USERINPUT><VARIABLE>othertypes</VARIABLE><USERINPUT>&space;-print | tar cv -</USERINPUT>
</EXAMPLE>
<PARAGRAPH>The <COMMAND>find</COMMAND> command locates regular, local (non-NFS) files that have not been modified in five days. The <COMMAND>find</COMMAND> command sends its output to the <COMMAND>tar</COMMAND> command. </PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Performing Incremental Backups with tar</TITLE><PARAGRAPH>Although <INDEXTARGET ID="ch267"><!-- POSTPROCESSDATA: ch267|backups:incremental with <ITALICS>tar</ITALICS> --><INDEXTARGET ID="ch268"><!-- POSTPROCESSDATA: ch268|backups:incremental with <ITALICS>cpio</ITALICS> --><COMMAND>tar</COMMAND> does not have a built-in mechanisms for incremental backups, you can use other system commands to accomplish this task.</PARAGRAPH>
<PARAGRAPH>The following example uses the same incremental scheme presented in the preceding section to back up the <FILENAME>/usr</FILENAME> filesystem. It uses the <COMMAND>find</COMMAND> command to determine which files to archive:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Go to the top of the filesystem that you want to back up. For example:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>cd /usr</USERINPUT>&space;
</EXAMPLE>
</LIST>
<LIST><PARAGRAPH>Create a complete backup of the filesystem:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>tar cv .</USERINPUT>&space;
</EXAMPLE>
</LIST>
<LIST><PARAGRAPH>Each day, back up the files that have changed since the previous daily backup:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>find /usr -mtime 1 -local -print | tar cvf -</USERINPUT>&space;
</EXAMPLE>
</LIST>
<LIST><PARAGRAPH>Every week, back up the files that have changed since the last weekly backup:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>find /usr -mtime 7 -local -type f -print | tar cvf -</USERINPUT>&space;
</EXAMPLE>
</LIST>
<LIST><PARAGRAPH>At the end of four weeks, perform a complete backup and start the process over.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Improving tar Performance</TITLE><PARAGRAPH>In general, increasing block size improves tape write and read performance. The IRIX <COMMAND>tar</COMMAND> command automatically queries tape devices to determine the optimum block size. Very large block sizes could cause portability problems; see <REFPAGE>tar(1)</REFPAGE> for details (<CMDLINEOPT>b</CMDLINEOPT> option).</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Examining tar Archives</TITLE><PARAGRAPH>For <COMMAND>tar</COMMAND> archives, use the<CMDLINEOPT>&space;v</CMDLINEOPT> keyword for verbose listing of the archive contents:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>tar tv</USERINPUT>&space;
</EXAMPLE>
<PARAGRAPH>You can compare files that are archived with the original files using <COMMAND>tar</COMMAND>:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>tar C</USERINPUT>&space;
</EXAMPLE>
<PARAGRAPH>You see messages about the status of the files. Each message begins with a key character (a letter or symbol) that signifies the status of the file in the archive versus the original file. These characters are shown in <INDEXTARGET ID="ch269"><!-- POSTPROCESSDATA: ch269|<ITALICS>tar</ITALICS>:comparison key characters --><XREF IDREF="88702" TYPE="TABLE">Table&nbsp;2-3</XREF>.</PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="2-3"><PREFIX>Table 2-3 </PREFIX><XREFTARGET ID="88702"> <EMPHASIS>(continued)        </EMPHASIS>tar File Comparison Key Characters</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="61"><PARAGRAPH>Key</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="171"><PARAGRAPH>Meaning</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="61"><PARAGRAPH>=</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="171"><PARAGRAPH>The files compare</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="61"><PARAGRAPH>!</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="171"><PARAGRAPH>The files don't compare</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="61"><PARAGRAPH>?</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="171"><PARAGRAPH>Can't read the disk file</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="61"><PARAGRAPH>></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="171"><PARAGRAPH>Disk file doesn't exist</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="61"><PARAGRAPH>L</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="171"><PARAGRAPH>Linked to an earlier file on the tape</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="61"><PARAGRAPH>S</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="171"><PARAGRAPH>Symbolic link</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="61"><PARAGRAPH>B</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="171"><PARAGRAPH>Block special file</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="61"><PARAGRAPH>C </PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="171"><PARAGRAPH>Character special file</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="61"><PARAGRAPH>P</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="171"><PARAGRAPH>Named pipe</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Restoring tar Archives</TITLE><PARAGRAPH>To recover individual files from a <INDEXTARGET ID="ch270"><!-- POSTPROCESSDATA: ch270|restoring data:<ITALICS>tar</ITALICS> --><INDEXTARGET ID="ch271"><!-- POSTPROCESSDATA: ch271|restoring data:<ITALICS>cpio</ITALICS> --><INDEXTARGET ID="ch272"><!-- POSTPROCESSDATA: ch272|<ITALICS>tar</ITALICS>:restoring files --><INDEXTARGET ID="ch273"><!-- POSTPROCESSDATA: ch273|<ITALICS>cpio</ITALICS>:restoring files --><COMMAND>tar</COMMAND> archive, specify the name of the files on the command line:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>tar xv </USERINPUT><VARIABLE>file1 file2 directory/file3</VARIABLE>&space;
</EXAMPLE>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="85662">About cpio</TITLE><PARAGRAPH>Like <INDEXTARGET ID="ch274"><!-- POSTPROCESSDATA: ch274|<ITALICS>cpio</ITALICS>:capabilities --><COMMAND>tar</COMMAND>, <COMMAND>cpio</COMMAND> archives files and directories. With <COMMAND>cpio</COMMAND>, you can copy files to tape or disk, archive empty directories, swap byte order, create portable ASCII archives, and read from and write to standard output. The <COMMAND>cpio</COMMAND> utility is also useful for copying files and directories when the <REFPAGE>cp(1)</REFPAGE> command is unable to do so. For example, you cannot use <COMMAND>cp</COMMAND> to copy a directory to a different filesystem.</PARAGRAPH>
<PARAGRAPH>The <INDEXTARGET ID="ch275"><!-- POSTPROCESSDATA: ch275|<ITALICS>cpio</ITALICS>:and System Manager --><COMMAND>cpio</COMMAND> command is also the command used by the System Manager to create backups. If you are using a server and do not have access to the graphical System Manager, you may use <COMMAND>cpio</COMMAND> instead. Backups made with <COMMAND>cpio</COMMAND> are readable by the System Maintenance Menu and Command Monitor. </PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>XFS and <COMMAND>cpio</COMMAND>: Use the <CMDLINEOPT>-K</CMDLINEOPT> option with the <REFPAGE>cpio(1)</REFPAGE> command for files larger than 2 GB. If the <CMDLINEOPT>-K</CMDLINEOPT> option is not used, <COMMAND>cpio</COMMAND> skips any files larger than 2 GB and issues a warning. Note that use of this option can create <COMMAND>cpio</COMMAND> archives that are not usable on non-XFS systems. The <CMDLINEOPT>-K</CMDLINEOPT> option can be used only with the <CMDLINEOPT>-o</CMDLINEOPT> (output) option. The <CMDLINEOPT>-K</CMDLINEOPT> option cannot be used the <CMDLINEOPT>-c</CMDLINEOPT> option (which creates <COMMAND>cpio</COMMAND> archives with ASCII headers), or with the <CMDLINEOPT>-H </CMDLINEOPT>option (used to specify various header formats).</NOTE>
<SECTION2 LBL="" HELPID = ""><TITLE>Backing Up Files with cpio</TITLE><PARAGRAPH>To back up files with <COMMAND>cpio</COMMAND>, use the command:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>cat </USERINPUT><VARIABLE>filelist</VARIABLE><USERINPUT>&space;| cpio -o > /dev/tape</USERINPUT>&space;
</EXAMPLE>
<TIP><PREFIX>Tip</PREFIX>For portability to other systems, especially non-IRIX systems, use the <CMDLINEOPT>-H odc</CMDLINEOPT> option to create textual header information with small device numbers, and perhaps the <CMDLINEOPT>-B</CMDLINEOPT> option to set block size to 5120 bytes per record. Without the <CMDLINEOPT>-B</CMDLINEOPT> option, <COMMAND>cpio</COMMAND> queries the device to determine its recommended block size.</TIP>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Using cpio to Back Up Files by Modification Date</TITLE><PARAGRAPH>The <COMMAND>cpio</COMMAND> command does not have the capability of saving files by modification date built in. However, you can use the <COMMAND>find</COMMAND> command to archive files that have not been modified in a particular number of days:&space;<INDEXTARGET ID="ch276"><!-- POSTPROCESSDATA: ch276|<ITALICS>cpio</ITALICS>:making backups --></PARAGRAPH>
<EXAMPLE>
<USERINPUT>find /usr -depth -mtime 5 -print | cpio -ocvO /dev/tape</USERINPUT>&space;
</EXAMPLE>
<PARAGRAPH>The <VARIABLE>-depth</VARIABLE> argument causes <COMMAND>find</COMMAND> to print the name of the directory after printing the files in that directory. This ensures that <COMMAND>cpio</COMMAND> has permission to place the files in the directory in case the directory is read-only. The <CMDLINEOPT>-O</CMDLINEOPT> option designates the output file.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Performing Incremental Backups with cpio</TITLE><PARAGRAPH>Although <INDEXTARGET ID="ch277"><!-- POSTPROCESSDATA: ch277|backups:incremental with <ITALICS>tar</ITALICS> --><INDEXTARGET ID="ch278"><!-- POSTPROCESSDATA: ch278|backups:incremental with <ITALICS>cpio</ITALICS> --><COMMAND>tar</COMMAND> and <COMMAND>cpio</COMMAND> do not have built-in mechanisms for incremental backups, you can use other system commands to accomplish this task.</PARAGRAPH>
<PARAGRAPH>The following example uses the same incremental scheme presented in the preceding section to back up the <FILENAME>/usr</FILENAME> filesystem. It uses the <COMMAND>find</COMMAND> command to determine which files to archive:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Go to the top of the filesystem that you want to back up, and create a complete backup of the filesystem:</PARAGRAPH>
<CODE>
<USERINPUT>cd /usr</USERINPUT>&space;
<USERINPUT>find . -depth -print | cpio -ocLO /dev/tape</USERINPUT>&space;
</CODE>
</LIST>
<LIST><PARAGRAPH>Each day, back up the files that have changed since the previous daily backup:</PARAGRAPH>
<CODE>
<USERINPUT>cd /usr</USERINPUT>&space;
<USERINPUT>find . -depth -mtime 1 -print | cpio -ocLO /dev/tape</USERINPUT>&space;
</CODE>
</LIST>
<LIST><PARAGRAPH>Every week, back up the files that have changed since the last weekly backup:</PARAGRAPH>
<CODE>
<USERINPUT>cd /usr</USERINPUT>&space;
<USERINPUT>find . -depth -mtime 7 -print | cpio -ocLO /dev/tape</USERINPUT>&space;
</CODE>
</LIST>
<LIST><PARAGRAPH>At the end of four weeks, perform a complete backup and start the process over.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Examining cpio Archives</TITLE><PARAGRAPH>For <COMMAND>cpio</COMMAND> archives, use the following command to obtain a verbose listing:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>cpio -itvI /dev/tape</USERINPUT>&space;
</EXAMPLE>
<PARAGRAPH>The <CMDLINEOPT>-t</CMDLINEOPT> option prints a table of contents, the <CMDLINEOPT>-v</CMDLINEOPT> option means verbose, and the <CMDLINEOPT>-I</CMDLINEOPT> option designates the input file.</PARAGRAPH>
<PARAGRAPH>The <COMMAND>cpio</COMMAND> program does not have a built-in option to compare files. To compare the files on a <COMMAND>cpio</COMMAND> archive, you must extract the archive onto disk, then use a comparison program, such as <REFPAGE>diff(1)</REFPAGE>, <REFPAGE>cmp(1)</REFPAGE>, or <REFPAGE>dircmp(1)</REFPAGE>, or compare the checksum of the extracted file with that of the original using <REFPAGE>sum(1)</REFPAGE>.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Restoring cpio Archives</TITLE><PARAGRAPH>To recover individual files from a <INDEXTARGET ID="ch279"><!-- POSTPROCESSDATA: ch279|restoring data:<ITALICS>tar</ITALICS> --><INDEXTARGET ID="ch280"><!-- POSTPROCESSDATA: ch280|restoring data:<ITALICS>cpio</ITALICS> --><INDEXTARGET ID="ch281"><!-- POSTPROCESSDATA: ch281|<ITALICS>tar</ITALICS>:restoring files --><INDEXTARGET ID="ch282"><!-- POSTPROCESSDATA: ch282|<ITALICS>cpio</ITALICS>:restoring files --><COMMAND>cpio </COMMAND>archive, specify the name of the file(s) on the command line:</PARAGRAPH>
<EXAMPLE>
<USERINPUT>cpio -id </USERINPUT><VARIABLE>file1 directory/file2</VARIABLE><USERINPUT>&space;&lt; /dev/tape</USERINPUT>&space;
</EXAMPLE>
<PARAGRAPH>The <CMDLINEOPT>-i</CMDLINEOPT> option causes <COMMAND>cpio</COMMAND> to read input from the tape drive, and the <CMDLINEOPT>-d</CMDLINEOPT> option causes it to create the directory it is extracting, if it does not already exist.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="90789">About dd</TITLE><PARAGRAPH>The <INDEXTARGET ID="ch283"><!-- POSTPROCESSDATA: ch283|<ITALICS>dd</ITALICS>:capabilities --><COMMAND>dd</COMMAND> program reads from a specified input file (<VARIABLE>stdin</VARIABLE> is the default), performs whatever conversions you specify, and writes the result to a specified output file (<VARIABLE>stdout</VARIABLE> is the default). It is not specifically a backup tool, but has many extremely useful features, including the ability to:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>skip specific blocks in an archive </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>skip blocks of output </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>specify input and output block size </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>copy a specific number of blocks </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>perform various data conversions such as byte swapping</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Refer to the <REFPAGE>dd(1M)</REFPAGE> reference page for details on the use of the <COMMAND>dd</COMMAND> command.</PARAGRAPH>
</SECTION1>
</CHAPTER>
