<HTML>
<HEAD>
<TITLE>IRIX Admin: Backup, Security, and Accounting
</TITLE></HEAD>
<BODY BGCOLOR="#F9F9F9">
<!-- dtlbook2html START -->
<HR noshade>
<FONT SIZE="-1"><A HREF="index.html"><B>IRIX Admin: Backup, Security, and Accounting</B></A><P><A HREF="IA_BakSecAcc-7.html"><IMG SRC="images/b_prev.gif" ALT="Prev" WIDTH=17 HEIGHT=17 BORDER=0 ALIGN=TOP></A>&nbsp; <A HREF="IA_BakSecAcc-9.html"><IMG SRC="images/b_next.gif" ALT="Next" WIDTH=17 HEIGHT=17 BORDER=0 ALIGN=TOP></A>&nbsp;&nbsp;&nbsp;&nbsp;Table of Contents:&nbsp;&nbsp;<A HREF="index.html">Basic</A>&nbsp;&nbsp;|&nbsp;&nbsp;<A HREF="fulltoc.html">Expanded</A></P></FONT>
<!-- dtlbook2html END -->

<A NAME=X></A><A NAME="SGI1"></A>
<H1 class="SGITPL-head">PART THREE<BR>Accounting</h1><p>Part III, <i>Accounting</i>, contains the following chapters:<p><b></b><A HREF="IA_BakSecAcc-8.html#SGI2" TARGET=_top>Chapter 6</A><b><br></b>Administering the System Audit Trail    <p><b></b><A HREF="IA_BakSecAcc-8.html#SGI39" TARGET=_top>Chapter 7</A><b><br></b>System Accounting    <HR noshade><A NAME="SGI2"></A>
<H1 class="SGITPL-head">Chapter 6<BR> Administering the System Audit Trail</h1><p>The System Audit Trail features allow administrators to review a record of all system activity. The ongoing record of system activity shows general trends in system usage and also violations of your system use policy. For example, any unsuccessful attempts to use system resources can be recorded in the audit trail. If a user consistently attempts to access files owned by other users, or attempts to guess the root password, this can be recorded also. The site administrators can monitor all system activity through the audit trail. Sections of this chapter include:<ul><li><A HREF="IA_BakSecAcc-8.html#SGI3" TARGET=_top>"About MACs and DACs"</A><br><br><li><A HREF="IA_BakSecAcc-8.html#SGI4" TARGET=_top>"Enabling Auditing"</A><br><br><li><A HREF="IA_BakSecAcc-8.html#SGI5" TARGET=_top>"Default Auditing"</A><br><br><li><A HREF="IA_BakSecAcc-8.html#SGI6" TARGET=_top>"Customizing Auditing"</A><br><br><li><A HREF="IA_BakSecAcc-8.html#SGI20" TARGET=_top>"About the Audit Data"</A><br><br><li><A HREF="IA_BakSecAcc-8.html#SGI21" TARGET=_top>"About Security Violations"</A><br><br><li><A HREF="IA_BakSecAcc-8.html#SGI35" TARGET=_top>"Archiving Audit Data"</A></ul><HR noshade><A NAME="SGI3"></A>
<h2 class="SGITPL-head">About MACs and DACs</h2><p>References are made in this chapter to auditable "Mandatory Access Control" and "MAC" events, such as an event generated when an attempt is made to access a file protected by a higher MAC clearance. The audit system provides facilities to audit all events on all IRIX operating systems. Mandatory Access Control (MAC) is available only in the optional Trusted IRIX/B operating system. No MAC audit events are generated by standard IRIX. If you have installed Trusted IRIX/B, you will have received additional documentation describing the special security features in that product. Users of standard IRIX can safely ignore all references to MAC, labels, and the <i>dbedit</i>, <i>chlabel</i> and <i>newlabel</i> commands. To find out if a system is running Trusted IRIX/B, use the <i>versions</i> command to see if the <i>trix_eoe</i> product image is installed.<p>You can also determine if a system is running Trusted IRIX/B by using the <i>sysconf</i> command to see if MAC is configured (1 indicates it is):<PRE><B>sysconf MAC</B> 
1 </PRE><p>Both standard IRIX and Trusted IRIX/B systems give a similar <i>uname</i>-a response:<pre>IRIX64 <var>SystemName</var> 6.5 10301649 IP27</pre><p>Discretionary Access Control (DAC) is the term used by the auditing subsystem for the standard UNIX system of file permissions. IRIX uses the standard permissions system common to all UNIX based operating systems.<HR noshade><A NAME="SGI4"></A>
<h2 class="SGITPL-head">Enabling Auditing</h2><p>The audit subsystem is distributed with your IRIX operating system media, but is not installed by default. To enable auditing, you must use Inst to install the <var>eoe.sw.audit</var> software package from your distribution media. Inst is described in detail in <i></i>IRIX Admin: Software Installation and Licensing    <i></i>. Once this package has been installed, reboot your system and use the <i>chkconfig</i> utility to enable auditing. The chkconfig(1M) reference page provides complete information on the use of <i>chkconfig</i> but, simply described, you will see a list of configurable options and a notation of <var>off</var> or <var>on</var> for each option. The list is in alphabetical order. <p>For example, here is a partial <i>chkconfig</i> listing that includes the audit option:<PRE>Flag                 State
====                 =====
audit                off
automount            on
windowsystem         on
xdm                  off</PRE><p>The following command enables auditing on your system:<pre><B>chkconfig audit on</B></pre><p>The system immediately begins collecting audit data on the default set of audit events. The default audit events are listed and described below.<HR noshade><A NAME="SGI5"></A>
<h2 class="SGITPL-head">Default Auditing</h2><p>The default auditing environment is already set up when you install IRIX. You need not take any action to maintain the default auditing environment. Within your default IRIX distribution, there is a file called <i>/etc/init.d/audit</i>. This file contains the default audit trail initialization. The default auditing selections produce a full record of system activity with a minimum of disk-space usage. <A HREF="IA_BakSecAcc-8.html#SGITF1" TARGET=_top>Table 6-1</A> contains all event types audited by default. The individual event types are not described in this list, but a description for all event types is given in <A HREF="IA_BakSecAcc-8.html#SGI8" TARGET=_top>"Auditable Events"</A>. <TABLE BORDER CELLPADDING=10><p><A NAME="SGITF1"></A><CAPTION ALIGN=TOP><B>Table 6-1 :  </B>Events Audited by Default</CAPTION><TR VALIGN=TOP ALIGN=LEFT><TH>Default Audited Events</TH><TH><br><br></TH><TH><br><br></TH><TR ALIGN=LEFT VALIGN=TOP><TD><p>sat_access_denied</TD><TD><p>sat_domainname_set</TD><TD><p>sat_mount</TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p>sat_ae_custom</TD><TD><p>sat_exec</TD><TD><p>sat_open</TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p>sat_ae_dbedit</TD><TD><p>sat_exit</TD><TD><p>sat_proc_attr_write</TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p>sat_ae_identity</TD><TD><p>sat_fchdir</TD><TD><p>sat_proc_attr_write</TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p>sat_ae_mount</TD><TD><p>sat_fd_attr_write</TD><TD><p>sat_proc_attr_write2</TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p>sat_bsdipc_create</TD><TD><p>sat_file_attr_write</TD><TD><p>sat_proc_read</TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p>sat_bsdipc_create_pair</TD><TD><p>sat_file_crt_del</TD><TD><p>sat_proc_write</TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p>sat_bsdipc_expl_addr</TD><TD><p>sat_file_crt_del2</TD><TD><p>sat_svipc_change</TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p>sat_bsdipc_mac_change</TD><TD><p>sat_file_write</TD><TD><p>sat_svipc_create</TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p>sat_bsdipc_shutdown</TD><TD><p>sat_fork</TD><TD><p>sat_svipc_remove</TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p>sat_chdir</TD><TD><p>sat_hostid_set</TD><TD><p>sat_sysacct</TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p>sat_chroot</TD><TD><p>sat_hostname_set</TD><TD><p>sat_tty_setlabel</TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p>sat_clock_set</TD><TD><p><br><br></TD><TD><p><br><br></TD></TR></TABLE> <br><br><HR noshade><A NAME="SGI6"></A>
<h2 class="SGITPL-head">Customizing Auditing</h2><p>When you have installed your system, you can select the level and type of auditing that you wish to use. The default auditing environment described above is created for you at installation time. For most purposes this auditing environment is satisfactory. However, remember that the System Audit Trail is completely configurable at any time through the <i>sat_select</i> and <i>satconfig</i> utilities.<p>The <i>satconfig</i> utility is the preferred tool for use on graphics systems, since it provides a convenient graphical interface for switching each auditable event type on or off. The <i>sat_select</i> command is useful for server users and others who do not wish to use the <i>satconfig</i> utility. These utilities are discussed in detail in <A HREF="IA_BakSecAcc-8.html#SGI9" TARGET=_top>"About satconfig"</A> and <A HREF="IA_BakSecAcc-8.html#SGI11" TARGET=_top>"About sat_select"</A>.<A NAME="SGI7"></A>
<h3 class="SGITPL-head">Auditable Actions</h3><p>You can audit all system activity or certain types of activity, such as file removal or access denial. Users are tracked through the audit trail by User ID (UID) numbers. Any audited activity is associated with the UID of the person who performed that action. It is a central feature of the System Audit Trail that though the effective UID changes with the use of the <i>su</i> command, the SAT ID does not. All of a user's actions after logging in are audited at the original login UID.<p>When you select the type of activities to audit, there are still several options for auditing. For example, if you wish to monitor the removal of files, you can generate an audit record under two conditions:<ul><li>when the action fails (sat_access_denied, sat_access_failed) <br><br><li>when the action succeeds (sat_file_crt_del, sat_file_crt_del2)</ul><p>Many different types of activities take place on your trusted computer system. There are login attempts, file manipulations, use of devices (such as printers and tape drives), and administrative activity. Within this list of general activities, you may choose to audit many specific kinds of actions.<p>Below is a list of auditable actions with a short definition of each action and one or more of the appropriate event types that can be audited. Important actions contain a note that they should always be audited:<ul><li>login and logout (sat_ae_identity)<p>Any login attempt, whether successful or not, should be audited. Also, an audit record should be generated when the user logs out of the system.<br><br><li>su (sat_check_priv, sat_ae_identity)<p>Whenever a user invokes the <i>su</i> command, whether to super-use some administrative account, such as root or another user account, the event should be audited. This is especially true for unsuccessful attempts, as they may indicate attempts at unauthorized access.<br><br><li>chlabel and newlabel (file_attr_write, sat_proc_own_attr_write)<p>Any time a user changes a MAC label on a Trusted IRIX/B system, it is wise to make an audit record of the event. (This does not happen under standard IRIX.)<br><br><li>password change (sat_ae_identity)<p>Whenever a user changes his or her password, it is wise to make an audit record of the event.<br><br><li>administrative activity (sat_ae_mount, sat_clock_set, sat_hostid_set, etc)<p>Any activity related to system administration should be carefully audited; for example, editing the <i>/etc/fstab</i> file.<br><br><li>DAC permissions change (sat_fd_attr_write, sat_file_attr_write)<p>When a user invokes the <i>chmod</i> command to change the DAC permissions on a file or the <i>chown</i> command to change the ownership of a file.<br><br><li>file creation (sat_file_crt_del, sat_file_crt_del2)<p>Whenever a new link, file, or directory is created.<br><br><li>file deletion (sat_file_crt_del, sat_file_crt_del2)<p>Whenever a link, file, or directory is removed.<br><br><li>process activity (sat_exec, sat_exit, sat_fork)<p>When a new process is created, forked, exited, or killed.<p>The audit administrator (auditor) can change the audited events by entering a new <i>sat_select</i> command. It is possible to change the selected event types at different times of day, by using the <i>cron</i> utility to execute <i>sat_select</i> periodically.<p>To tailor your auditing for your specific needs, use the <i>sat_select</i> or <i>satconfig</i> utilities. </ul><A NAME="SGI8"></A>
<h3 class="SGITPL-head">Auditable Events</h3><p>The following is a complete list of auditable event types: <dl><dt>sat_access_denied <dd><br>Access to the file or some element of the path was denied due to enforcement of MAC or DAC permissions. <dt><br>sat_access_failed <dd><br>Access to a file was denied because the path specified does not exist. <dt><br>sat_chdir <dd><br>Current working directory was changed with <i>chdir</i>. <dt><br>sat_chroot <dd><br>Current root directory was changed with <i>chroot</i>. <dt><br>sat_open <dd><br>A file was opened with write permission.<dt><br>sat_open_ro <dd><br>A file was opened read-only. <dt><br>sat_read_symlink <dd><br>The contents of a symbolic link were read with <i>readlink</i>. Note that the file the link "points" to is not accessed in any way.<dt><br>sat_file_crt_del <dd><br>A file was added or removed from a directory. <dt><br>sat_file_crt_del2 <dd><br>This is the same as sat_file_crt_del, but reports that two files (perhaps a link) were removed. <dt><br>sat_file_write <dd><br>The data in a file was modified by <i>truncate</i>. <dt><br>sat_mount <dd><br>A filesystem was mounted or unmounted. <dt><br>sat_file_attr_read <dd><br>The attributes of a file were read by <i>stat</i>. <dt><br>sat_file_attr_write <dd><br>The attributes of a file were written by <i>chmod</i>. <dt><br>sat_exec <dd><br>A new process has been introduced by <i>exec</i>. <dt><br>sat_sysacct <dd><br>System accounting has been turned on or off.<dt><br>sat_fchdir <dd><br>The user changed from the current working directory to the directory "pointed" to by the given open descriptor. <dt><br>sat_fd_read <dd><br>Information was read from a file descriptor using <i>read</i>. <dt><br>sat_fd_read2 <dd><br>The same event as sat_fd_read, but with multiple file descriptors.<dt><br>sat_tty_setlabel <dd><br>The user set the label of a port via <i>ioctl</i>. <dt><br>sat_fd_write <dd><br>The user finalized a change to a file descriptor. <dt><br>sat_fd_attr_write <dd><br>The user changed the attributes of the file "pointed" to by the given file descriptor using<i> fchmod</i>. <dt><br>sat_pipe <dd><br>The user created an unnamed pipe. <dt><br>sat_dup <dd><br>The user duplicated a file descriptor. <dt><br>sat_close <dd><br>The user closed a file descriptor. <dt><br>sat_proc_read <dd><br>The user read from a process's address space using <i>ptrace</i>.<dt><br>sat_proc_write <dd><br>The user finalized a changes to a process's address space using <i>ptrace</i>.<dt><br>sat_proc_attr_read <dd><br>The user read a process's attributes.<dt><br>sat_proc_attr_write <dd><br>The user finalized a change to a process's attributes.<dt><br>sat_fork <dd><br>The user duplicated the current process (thereby creating a new process). <dt><br>sat_exit <dd><br>The user ended the current process. <dt><br>sat_proc_own_attr_write <dd><br>Process attributes were changed.<dt><br>sat_clock_set <dd><br>The system clock was set.<dt><br>sat_hostname_set <dd><br>The hostname was set. <dt><br>sat_domainname_set <dd><br>The domain name was set. <dt><br>sat_hostid_set <dd><br>The host ID was set. <dt><br>sat_check_priv <dd><br>Action requiring superuser privilege was performed.<dt><br>sat_control <dd><br>The <i>sat_select</i> command was used. <dt><br>sat_svipc_access <dd><br>The user accessed a System V IPC data structure. <dt><br>sat_svipc_create <dd><br>The user created a System V IPC data structure. <dt><br>sat_svipc_remove <dd><br>The user removed a System V IPC data structure. <dt><br>sat_svipc_change <dd><br>The user set some attribute of a System V IPC data structure. <dt><br>sat_bsdipc_create <dd><br>The user created a socket. <dt><br>sat_bsdipc_create_pair <dd><br>The user created a socket pair. <dt><br>sat_bsdipc_shutdown <dd><br>The user shut down a socket.<dt><br>sat_bsdipc_mac_change <dd><br>The user changed the MAC label on a socket.<dt><br>sat_bsdipc_address <dd><br>A network address was used explicitly via the <i>accept</i>, <i>bind</i>, or <i>connect</i> system calls. <dt><br>sat_bsdipc_resvport <dd><br>A reserved port was successfully bound.<dt><br>sat_bsdipc_deliver <dd><br>A packet was delivered to a socket. <dt><br>sat_bsdipc_cantfind <dd><br>A packet was not delivered because the socket could not be found. <dt><br>sat_bsdipc_snoop_ok <dd><br>A packet was delivered to a raw (snoop) socket.<dt><br>sat_bsdipc_snoop_fail<dd><br>A packet was not delivered to a raw socket because it was prevented by MAC policy. <dt><br>sat_bsdipc_rx_ok<dd><br>A packet was received on an interface. <dt><br>sat_bsdipc_rx_range<dd><br>A packet was not received, due to MAC violation outside the allowed label range on that interface.<dt><br>sat_bsdipc_rx_missing<dd><br>A packet was received on an interface with a missing or damaged MAC label. <dt><br>sat_bsdipc_tx_ok<dd><br>A packet was sent on the interface. <dt><br>sat_bsdipc_tx_range<dd><br>A packet was not sent, due to a MAC violation.<dt><br> sat_bsdipc_tx_toobig<dd><br>A packet was not sent, because the MAC label was too large for the IP header to contain. <dt><br>sat_bsdipc_if_config<dd><br>An interface structure's attributes were changed.<dt><br> sat_bsdipc_if_invalid<dd><br>Attempt to change MAC labels was disallowed for lack of MAC privilege. <dt><br>sat_bsdipc_if_setlabel<dd><br>The MAC labels on an interface structure were changed.</dl><p>All <i>sat_ae</i> events are used for application auditing, which means that a privileged program generated the record, rather than the kernel.<dl><dt>sat_ae_identity<dd><br>A login- or logout- related event occurred. <dt><br>sat_ae_dbedit <dd><br>A file was modified using the <i>dbedit</i> utility. (This utility is available only with the Trusted IRIX/B optional product.) <dt><br>sat_ae_mount <dd><br>An NFS filesystem was mounted. <dt><br>sat_ae_custom<dd><br>An application-defined event occurred. Application developers can engineer their applications to generate this event.</dl><A NAME="SGI9"></A>
<h3 class="SGITPL-head">About satconfig</h3><p><i>satconfig</i> is a graphical utility that you use to configure exactly which events will be audited on your system. Any user can invoke <i>satconfig</i>, but only the superuser may actually change the auditing environment. <p>When you first begin using the audit trail, there is a default set of audited events. You can modify that selection using <i>satconfig</i>, but the <i>satconfig</i> window contains a pulldown menu labeled "edit" that you can use at any time to set the auditing environment to a few preset environments. These include the original SGI default audit selections, your local default selections, all event types selected, no event types selected, and a current events selection. The current events selection restores the auditing environment that was last saved on your machine. The local default environment can be any combination of event types that you choose. You create a local default environment by following the instructions in <A HREF="IA_BakSecAcc-8.html#SGI13" TARGET=_top>"Saving and Retrieving Your Auditing Environment"</A>. <A NAME="SGI10"></A>
<h4 class="SGITPL-head">Using satconfig</h4><p>When you invoke <i>satconfig</i>, a new window opens on your screen. The main body of the window has a list of all the available event types. Next to each event type name is a button. At any time, each button is either up or down. If the button is down, the event type is selected for auditing. If the button is up, the event type is not audited. Use your mouse and the left mouse button to select whether you want the event type in question to be on or off. <p>At the bottom of the <i>satconfig </i>screen there are three buttons. These buttons are labeled <i>Apply</i>, <i>Revert</i>, and <i>Quit</i>. When you have made your auditing selections, use the left mouse button to press the <i>Apply </i>button on the screen to activate the auditing selections. If you change your mind while making audit selections, you can use the <i>Revert </i>button to reset the individual event type buttons to the selections currently in use. The third button is labeled <i>Quit </i>and closes the <i>satconfig</i> window. If you have made selections that have not been applied, <i>satconfig</i> asks you if you really want to quit and discard the changes you have made without applying them.<A NAME="SGI11"></A>
<h3 class="SGITPL-head">About sat_select</h3><p>The <i>sat_select</i> utility is a character-based program that modifies your audit event type selections. Additionally, you can use the <i>sat_select</i> utility to change your local default auditing environment or to read in a preselected set of event type choices from a file. In this way, you can have several preset auditing environments ready in files for various situations and switch between them conveniently. If you have a graphical system, <i>satconfig</i> is the suggested utility for administering your auditing event type selections. <i>sat_select</i> exists for non-graphics systems and for making large-scale, file-oriented changes. <A NAME="SGI12"></A>
<h4 class="SGITPL-head">Using sat_select</h4><p>For complete information on using <i>sat_select</i>, consult the sat_select(1M) reference page, but in general, the syntax most often used is<pre>sat_select -on event </pre><p>and <pre>sat_select -off event </pre><p><i>sat_sel</i><var>ect -on event</var> directs the system audit trail to collect records describing the given event. If "all" is given as the <var>event</var> string, all event types are collected.<p><i>sat_select </i><var>-off event</var> directs the system to stop collecting information on that event type. If "all" is given as the <var>event</var> string, all event types are ignored. <p>With no arguments,<i> sat_select</i> lists the audit events currently being collected. The effect of subsequent <i>sat_select</i> programs is cumulative. Help is available with the -h option.<A NAME="SGI13"></A>
<h3 class="SGITPL-head">Saving and Retrieving Your Auditing Environment</h3><p>From time to time you may wish to change your auditing environment. You do this with the <i>sat_select</i> command. If you are making a temporary change, you may wish to save your current auditing environment for easy replacement. To do so, use this command: <pre><B>sat_select -out > /etc/config/sat_select.options </B></pre><p>Then, to restore auditing to the saved state, use this command:<pre><B>sat_select 'cat /etc/config/sat_select.options'</B> </pre><p>The single quotation marks in the above example are crucial and must not be omitted.<p>You may save as many different audit states as you wish, in different filenames. Simply insert the filename of the state you wish to use in the above example. The <i>/etc/config/sat_select.options</i> file is the default audit state file that is read at boot time. The <i>/etc/config/sat_select.options</i> file must be labeled <i>dblow</i> if you are running Trusted IRIX/B, and you should restrict DAC file permissions to root only regardless of your operating system type.<A NAME="SGI14"></A>
<h3 class="SGITPL-head">Placing the Audit Files</h3><p>The location of your audit record files is also configurable. You can direct your audit records to be saved to any location you desire, including magnetic tape. <i>satd</i> saves its input data in the directories or files named in its <var>path</var> arguments.<p>The -f option to <i>satd</i> specifies an output path, which may be a directory or a file. If the output path is a specific filename, <i>satd</i> writes to that file. If the output path is a directory, <i>satd</i> creates and fills uniquely named files under that directory; files are named for their creation time. For instance, <i>sat_9101231636</i> was created in 1991 on January 23 at 4:36 pm. You can specify several output paths in the <i>satd</i> command line. To do so, you must precede each path with a -f or put commas (but no blank space) between each pathname. Taken together, all of the output paths specified in the command line are known as the path list. Here are a pair of examples of command lines that contain path lists:<pre><B>satd -f /sat1 -f /sat2 -f /sat3 -f /dev/null</B> 
<B>satd -f /sat1,/sat2,/sat3,/dev/null</B></pre><p>If no output paths are specified after the -f flag, the audit trail records are not saved anywhere, and the system halts. If a path given as a command-line parameter is invalid for any reason, a warning is printed, that path is omitted from the path list, and <i>satd</i> continues operating with whatever specified paths are valid. If the specified path does not already exist, <i>satd</i> creates a file with that name.<p>A file or directory is full when the filesystem on which it resides has no more available space. If a directory is specified as an output path, an audit file is constructed under that directory. When the audit file is filled to an internally specified maximum size, it is closed and a new audit file is created under that directory.<p>When one output path becomes full, <i>satd</i> replaces the current output path with a path that is not full. The method of replacement is configurable with the -r option. The output path is also replaced if <i>satd</i> receives a SIGHUP signal, for instance one sent with a <i>kill</i> command.<p>If an output path becomes nearly full, warnings are displayed to the system console to notify the administrator to move the audit trail to tape. If all of the output paths become completely full, the system state moves to single-user mode with a very short grace period.<p>In order to protect against the loss of data due to sudden system state changes, when satd begins operations, it creates a file called <i>/satd.reserve</i>, which is exactly 250,000 bytes long. If <i>satd</i> runs out of space, it immediately removes the <i>satd.reserve</i> file to free the 250,000 bytes for use to store audit records while the system moves to single-user mode. While the system is coming down, <i>satd</i> stores audit records in a series of files named <i>/satd.reserve-n</i>, where <var>n</var> starts as 0. While <i>satd</i> is doing this, it issues a warning via <i>wall </i>to all users that they have ten seconds before system shutdown. <p>If the file <i>/satd.emergency-0</i> already exists, <i>satd </i>immediately moves to the first available filename, typically <i>/satd.emergency-1</i>. To guard against this happening, a warning is issued at boot time if any <i>/satd.emergency</i> files exist.<p>For complete information on the audit daemon, see the audit(1M), satd(1M), and audit_filters(5) reference pages and the comments in <i>/etc/init.d/audit</i>. <A NAME="SGI15"></A>
<h3 class="SGITPL-head">Auditing a Specific User</h3><p>At times, you may wish to examine the audit record of a particular user. For example, the user may have a history of violations of system security or may simply be leaving the project and an accounting of activity may be required.<A NAME="SGI16"></A>
<h4 class="SGITPL-head">Auditing to Determine Security Violations</h4><p>If the user in question is being audited to determine if attempted security violations are taking place, use the command line: <p><TT><B>sat_reduce -P </B></TT><var>satfile</var><TT><B> | sat_summarize -u </B></TT><var>user_name</var><p>This command line selects only the audit records that represent attempted violations. The -P flag to <i>sat_reduce</i> selects for attempted violations. The -u flag to the <i>sat_summarize</i> command lists the number of records generated by the user.<p>It is vitally important to remember that not every record of an attempted violation really represents malicious intent on the part of the user! Most of these records are generated in the course of normal work. The auditor should be looking for a trend, such as repeated attempts to access information unnecessary in the course of normal work (for example, a programmer attempting to access salary or hiring information).<A NAME="SGI17"></A>
<h4 class="SGITPL-head">Auditing a User's Activities</h4><p>In the second scenario, where the employee is leaving the project, the auditor is looking for a comprehensive list of files used by that employee so that the correct files and directories may be assigned a new owner who is remaining on the project.<p>The above listed command line provides a basic look at the user's activity. Next, to more closely examine the user's activities, issue the following command:<p><TT><B>sat_reduce -u </B></TT><var>user_name</var><var> satfile</var><TT><B> | sat_interpret | more</B></TT><p>The <i>sat_reduce</i> command selects all of the audit records generated by the user. Then, the <i>sat_interpret</i> command puts the records into human readable form. The output of <i>sat_interpret</i> is very large. If it is impractical to direct this output to a file, you should direct the output to your screen and view it with a screen paging program such as <i>more</i>.<p>Using these two command lines, you should be able to view a user's activities and come to a reasonable knowledge of the types of actions the user is taking on the system. You can also generate a specific record, in human-readable form, of all security violations or files and resources accessed.<A NAME="SGI18"></A>
<h3 class="SGITPL-head">Auditing a File</h3><p>At times, you may wish to examine all audit records pertaining to an individual file. Perhaps some changes have been made to an important file and the user who made those changes must be identified. Or perhaps an accounting of all access to a sensitive file is needed. To obtain a record for each time the file was opened, you must first make certain that the audit daemon is recording <i>sat_open</i> and <i>sat_open_ro</i> events. Use the <i>sat_select</i> command to ensure that these events are logged. To search the audit log for these events, use the following command line:<pre><B>sat_reduce -e sat_open -e sat_open_ro </B><var>satfile</var><B> |<br>sat_interpret | grep </B><var>filename</var></pre><A NAME="SGI19"></A>
<h3 class="SGITPL-head">Auditing a Label Under Trusted IRIX/B</h3><p>If you are using Trusted IRIX/B, your system supports Mandatory Access Control (MAC) labels on all files and processes. This section explains how to check the audit trail of a given security label. <p>If you are using standard IRIX, your system does not support MAC labels, and attempts to read the audit trail for events relating to such labels will be futile.<p>Since the number of configurable labels in Trusted IRIX/B is great enough for each project or portion of a project at your site to have its own label, you may sometimes need to audit a specific label to generate a record of activity on that label. Use the following command to generate a log of activity on a label: <p><TT><B>sat_reduce -l </B></TT><var>label</var><i> satfile</i><p>The above command chooses only audit records that pertain to the given label. The following command syntax allows you to select more than one label for your report:<p><TT><B>sat_reduce -l </B></TT><var>label</var><TT><B> -l </B></TT><var>label2 satfile</var><p>Once you have obtained output from <i>sat_reduce</i>, use the other auditing utilities, such as <i>sat_interpret</i> or <i>sat_summarize</i>, to view it according to your needs.<HR noshade><A NAME="SGI20"></A>
<h2 class="SGITPL-head">About the Audit Data</h2><p>The audit trail for an active system with full auditing can be too large for a single person to read and understand, and the entries in the trail that alert you to trouble are small and rare. If you were to read the raw audit trail to find an instance of policy violation, it would be like trying to find a needle in a haystack. Therefore, several utilities exist to help you reduce and interpret the raw audit data. The <i>sat_reduce</i>, <i>sat_interpret</i>, and <i>sat_summarize</i> commands can be used to remove superfluous information and format the audit history in succinct packages. See the reference pages for these commands for specific information on their usage.<p>After your raw data has been reduced and interpreted, an individual record looks something like this: <PRE>Event type = sat_ae_identity 
Outcome = Failure 
Sequence number = 5
Time of event = Mon Mar 11 12:46:13.33 PST 1991 
System call = syssgi,SGI_SATWRITE 
Error status = 0 (No error) 
SAT ID = anamaria
Identity event = LOGIN|-|/dev/ttyq4|anamaria|That user gave an invalid label.</PRE><p>The <i>sat_summarize</i> command provides a short listing of what types of records are in the audit trail and how many there are of each type. It's a useful tool for scanning the records quickly and identifying trends in system usage or consistent problems.<p>Remember that file pathnames within audit records are not the same as those in common usage through the shell on your system. Since the audit record is an exact log for security purposes, many attributes of the pathname that are designed to be transparent in normal usage are explicit in the audit log. For example, the double slash (//) means a directory level crossing (ordinarily represented through the shell with a single slash (/)). A slash followed by an exclamation point (/!) indicates crossing a filesystem mount point. The slash and ampersand construction (/@) indicates that the path is following a symbolic link. If you are running Trusted IRIX/B, you may also see a slash followed by a right angle bracket (/>), which indicates that the directory level being crossed into is a multilevel directory. The <i>egrep </i>utility supports this notation, so it is possible to specify this form of pathname notation in regular expression searches. Below are two examples of audit record pathnames:<pre>/usr/!orange2/@/fri//usr//src//lib//libmls//libmls.a
/usr/!tmp/>L_e//sat//sat_9012280805</pre><p>The system places the audit data in files on your system. Each file begins with the starting date and time of the file, the machine name, and the host ID, and ends with the stopping date and time. If your system is interrupted (for example, by a power failure), the audit file being used at that time will have no ending entry. The audit daemon automatically closes a file when it reaches a certain manageable size and opens another. A new file is always started when the system is brought up. For information on these files and their format, see the satd(1M) reference page.<HR noshade><A NAME="SGI21"></A>
<h2 class="SGITPL-head">About Security Violations</h2><p>The overwhelming majority of records in an audit trail are the result of the normal actions of users doing their jobs. No automated tool exists to locate records that signify the actions of abusers trying to violate system security. Nonetheless, an administrator can apply some general rules to detect abuse or violation of security policy. This list of tips is neither complete nor universal. Each administrator must customize the list to meet the particular needs of each site.<A NAME="SGI22"></A>
<h3 class="SGITPL-head">System Use and Abuse by Outside Users</h3><p>Intrusion by outsiders is among the most feared of abuses. Fortunately, this kind of abuse produces distinctive audit record patterns and is easily detected. Below, are descriptions of several different subcategories of outsider abuse that can be detected by the audit system. Note though, that these kinds of patterns can also be generated by an authorized user who makes a mistake or is misinformed. Patterns of this type are described below.<A NAME="SGI23"></A>
<h4 class="SGITPL-head">Attempts at Unauthorized System Entry</h4><p>All attempts at unauthorized entry generate audit records of the <i>sat_ae_identity</i> event type. (Use <i>sat_select</i>, <i>sat_reduce</i>, and <i>sat_interpret</i> to collect and view these records.) The interpreted output of these events contains a text string that describes the attempt at entry. Intruders from outside your organization have a much higher instance of failed login attempts than your authorized users.<p>Three interesting text strings reveal attempts at unauthorized entry: <ul><li>unsuccessful login attempt <br><br><li>that user gave an invalid label <br><br><li>could not set the label connection for device</ul><p>Here is an example of an interpreted audit record of an unsuccessful login attempt:<PRE>Event type = sat_ae_identity 
Outcome = Failure 
Sequence number = 1 
Time of event = Mon Mar 11 12:45:40.34 PST 1991 
System call = syssgi,SGI_SATWRITE 
Error status = 0 (No error) 
SAT ID = anamaria 
Identity event = LOGIN|-|/dev/ttyq4|guest|Unsuccessful login attempt.</PRE><A NAME="SGI24"></A>
<h4 class="SGITPL-head">System Use at Unusual Hours or from Unusual Locations </h4><p>Usage of your system outside of normal working hours or, if your system maintains physical security of terminals, from unusual locations, is a matter of interest. In most cases, the usage of the system is legitimate, but each instance certainly bears notation and examination. Many potential violations of security from outside your user community happen during nonpeak hours, and rarely from within your physical site.<p>To observe activity at odd hours, enter the following commands in order:<ol><li><TT><B>sat_reduce -a </B></TT><var>start_time</var><TT><B> satfile > /usr/tmp/early+late </B></TT><br><br><li><TT><B>sat_reduce -A </B></TT><var>end_time</var><TT><B> satfile >> /usr/tmp/early+late </B></TT><br><br><li><TT><B>sat_reduce -U root -U sys -U daemon -U adm -U lp /usr/tmp/early+late > /usr/tmp/e+l_ordusers</B></TT><br><br><li><TT><B>sat_interpret /usr/tmp/e+l_ordusers | more </B></TT></ol><p>If your site assigns a terminal to each user and maintains reasonable physical security for each terminal, you can monitor logins from unusual locations. For example, if a user normally working in a group computer lab makes a login attempt from a private office, this event may be cause for interest. To get a list of login events, enter the following command: <p><TT><B>sat_reduce -e sat_ae_identity sat_file | sat_interpret | grep LOGIN</B></TT><p>Bear in mind that it does not necessarily represent a violation of security if a user is working at an unusual terminal or even if a user is logged on at two or more terminals at once. For instance, the user may be correcting a mistake and may have logged in elsewhere explicitly for the purpose of terminating unwanted processes. You should be looking for instances where the user is not genuinely logged in twice, but where one instance of the login is an intruder.<A NAME="SGI25"></A>
<h4 class="SGITPL-head">Connections with Machines Outside the Local Network </h4><p>Whenever a user connects to a machine outside your trusted local network, an audit record should be generated. A connection to a host outside of the local network is worthy of notice but not necessarily a violation of security. You should be on the lookout for trojan horse programs that cause your system to make an outward connection at a later time. You can identify outward connections with the following command sequence:<ol><li><TT><B>sat_reduce -e sat_bsdipc_addr </B></TT><var>satfile</var><TT><B> > </B></TT><i>/usr/tmp/connect</i><br><br><li><TT><B>sat_interpret </B></TT><i>/usr/tmp/connect</i><TT><B> > </B></TT><i>/usr/tmp/connect.int</i><br><br><li><TT><B>grep -n "Remote host" </B></TT><i>/usr/tmp/connect.int</i></ol><p>The above command sequence is dependent on the specific implementation of your networking software. You may need to modify commands to reflect your networking situation. For example, if the software you are using does not generate the <i>sat_bsdipc_addr</i> auditing event type, you should search for another event type that is generated.<A NAME="SGI26"></A>
<h3 class="SGITPL-head">System Use and Abuse by Inside Users</h3><p>Beyond use and abuse by intruders, unfortunately, the possibility arises of abuse from within your organization. The following types of events are the most common instances of security violations. It is extremely counterproductive to assume that a security violation on the part of an authorized user indicates that the user is not trustworthy or is involved in some attempt to break security for malicious purposes. Most violations of system security by users involve a failure on the part of the Administrator to adequately prepare the working environment. Users are most concerned with accomplishing their work tasks, not with fixing the computer system to provide themselves with the correct tools. Therefore, you should not be suspicious of the user who violates security unless a clear pattern of a specific and unnecessary security violation is apparent.<A NAME="SGI27"></A>
<h4 class="SGITPL-head">File Permission Violations by Inside Users</h4><p>Although the system records each instance where access to a file or resource is denied, the information contained in these audit records is rarely indicative of a security violation. Many applications and utilities operate on a principle of access denial as part of normal operation. These events are always logged, but only in rare cases do they indicate a violation. For example, the library function <b>getutent </b>always tries to open <i>/etc/utmp</i> for read-write access. If this action fails, <b>getutent</b> immediately tries again, but requesting read-only access. Permissions on <i>/etc/utmp</i> prohibit all users except root from opening this file for reading and writing. When an unprivileged user runs a program that calls <i>getutent</i>(), a <i>sat_access_denied</i> record is generated, and it is immediately followed in the audit trail by a <i>sat_open_ro</i> record, indicating that access was granted. The lesson in this example is that access denial is usually not indicative of a security violation.<p>The <i>sat_access_failed</i> event is often confused with the denial event. The event type is completely different and is even more rarely a cause for concern than access denial. When a user enters a command to an interactive shell (such as <i>/bin/csh</i>), the shell tries to execute the command in each directory in the user's search path, failing at each attempt until it finds a directory that actually contains the command. Suppose a user enters <i>xterm</i> and his or her path variable contains<pre>/bin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/bin/X11:~/bin</pre><p>A <i>sat_access_failed</i> record is generated for each directory in the path until the command is found and executed. In this scenario, a record of failed access is generated for each of the following nonexistent programs: <i>/bin/xterm</i>, <i>/usr/bin/xterm</i>, <i>/usr/sbin/xterm</i>, <i>/usr/local/bin/xterm</i> and a successful <i>sat_file_exec</i> record for the real program: <i>/usr/bin/X11/xterm</i>. <A NAME="SGI28"></A>
<h4 class="SGITPL-head">Unexpected Use of Root Privilege by Inside Users</h4><p>Every interpreted audit record contains a line beginning with the keyword<b> Outcome</b>. The field following this keyword can be equal to one of <b>Success</b>, <b>Failure</b>, or <b>Success due to privilege</b>. The last case indicates that the user made a system call that would have failed except that superuser privilege was invoked to assure its successful completion. This is not necessarily a security violation or an unexpected use of root privilege. It is perfectly normal to see these outcomes. Any time an ordinary user runs a program that contains code that uses root privilege, <b>Success due to privilege</b> outcomes are generated. A good example of this kind of program is <i>passwd</i>. An ordinary user generates a record of this type simply by changing the password on his or her account.<p>What you should be looking for is an instance where the SAT ID or Effective ID field is different from the "User ID" field. This occurs when a user executes <i>/bin/su</i> to gain root privileges or otherwise promotes the privilege level of a session. In most cases, this is not a security violation, since the root password is necessary to successfully complete the <i>/bin/su</i> command.<p>An instance of using superuser privilege, though, is always worth examination in the audit trail. When you encounter an instance where a user has promoted his or her login session to root, you should check to see that the user is authorized to know the root password. If not, check whether the user indeed executed the <i>/bin/su</i> command, or if he or she promoted the privilege of the session by some other means, such as a Trojan horse <i>setuid</i> shell command.<p>Whenever a user runs <i>/bin/su</i> and thereby promotes the privilege of his or her login session, the auditor should also make a routine check of what actions the user took while the privilege was promoted.<A NAME="SGI29"></A>
<h4 class="SGITPL-head">Activity by Particular Inside Users </h4><p>Sometimes a particular user is under official scrutiny by the management of a site. He or she may be on probation or may have just left employment under less than ideal circumstances. The auditor can choose to look at the records describing that user's behavior just by directing the audit trail through the <i>sat_reduce</i> command as follows:<ol><li><TT><B>sat_reduce -u </B></TT><var>jeff</var><TT><B> &lt; satfile > </B></TT><i>/tmp/sat.jeff</i><br><br><li><TT><B>sat_interpret </B></TT><i>/tmp/sat.jeff</i><TT><B> | more</B></TT></ol><p>Rarely should any user be subjected to this kind of accounting, and this feature should be used carefully and with consideration of the individuals involved.<A NAME="SGI30"></A>
<h4 class="SGITPL-head">Access to Particular Files or Resources</h4><p>Sometimes a particular file or resource is of special interest. An information leak may have occurred and an investigation is proceeding into how the leak took place. Or a special file or resource may have been created as bait to trap browsing intruders. In either case, the file or resource should be closely accounted by the auditor.<p><TT><B>sat_reduce -n </B></TT><i>interesting_file</i><TT><B> -e sat_open -e sat_open_ro </B></TT><i>sat_filename</i><TT><B> | sat_interpret</B></TT><A NAME="SGI31"></A>
<h3 class="SGITPL-head">About Proper and Improper System Management</h3><p>Frequently, actions taken by the Administrator or root result in unusual audit records. With the enhanced privilege of these accounts, it is not unusual for more audit records of potential concern to be generated. Again, it is rare for a record to be generated that cannot be explained by the normal usage of the system or by simple human error.<A NAME="SGI32"></A>
<h4 class="SGITPL-head">Modifications of System Data Files</h4><p>Every modification of system data files is of interest to the auditor. Since these data files are not only under system security but in fact define system security, any unauthorized access can result in a total breach of security.<p>Each site has individual policies on how users are added to or removed from the system, how access control of files and hardware is administered, how network connectivity is maintained and administered, and a host of other issues. It is the responsibility of the auditor at each site to enforce the policies of the site and to use the auditing tool effectively to exercise that responsibility.<p>If you are running Trusted IRIX/B, system data files should be modified only with the dedicated editing tool, <i>dbedit</i>, and never with general-purpose text editors. Only privileged users can use the <i>dbedit</i> tool, and only privileged users have permission to alter the contents of the system data files. Any use of any other editor on a system data file is a violation of security policy and should be noticed by the auditor. If your interpreted audit trail contains <i>sat_open</i> records where the Actual name field contains the string "/secadm," check that the Process ID field (which gives both the PID and the name of the program being executed) does not contain "vi," "ex," "emacs" or any other commonly available text editor. This field should contain only the name "dbedit."<A NAME="SGI33"></A>
<h4 class="SGITPL-head">Modifications of System Program Attributes</h4><p>The Administrator should never modify permissions, ownership, or labels of system programs. If your audit trail contains evidence that the administrator has attempted to change attributes of system programs, you should investigate and find the reason for the change. Again, the explanation given is likely to be valid, and this is not good cause to suspect your Administrator of subterfuge; however, you may want to examine your system's security policies and make certain that neither the users nor the administrators take a cavalier attitude toward the security policies.<p>The following command searches your audit trail for the type of records that can indicate this problem:<p><TT><B>sat_reduce -e sat_file_attr_write -e sat_fd_attr_write &lt; satfile</B></TT><p>In the interpreted output, look for lines with the Actual name field. Any audit record showing modified attributes for resources in <i>/bin</i>, <i>/sbin</i>, <i>/etc</i>, <i>/lib</i>, <i>/var</i>, <i>/usr/bin</i>, <i>/usr/lib</i>,<i> /usr/share</i>, <i>/usr/bsd</i>, /usr/sbin, or /usr/bin/X11 is an audit record deserving follow-up.<A NAME="SGI34"></A>
<h4 class="SGITPL-head">Manipulation of the Audit Trail </h4><p>The auditor should be the only person to access the audit trail. No other users should read from it, write to it, remove files, or modify file attributes. Look at all records generated by people other than the one who knows the auditor account password, and check that none of those records refer to files in <i>/var/adm/sat</i> or in any other directory you use to store audit trail information.<HR noshade><A NAME="SGI35"></A>
<h2 class="SGITPL-head">Archiving Audit Data</h2><p>Since the audit trail is stored in ordinary system files, archiving your audit data is as easy as making a backup tape. Archive your audit data to conserve disk space but do keep copies of your audit trail; evidence of intrusion and damage to your system may not always be apparent immediately, and the ability to research your audit trail over time can be very valuable in tracking down a security breach. You can use the <i>compress</i> utility to reduce the size of your old audit files by up to 80 percent.<A NAME="SGI36"></A>
<h3 class="SGITPL-head">Removing Audit Data</h3><p>Since the audit trail is stored in ordinary system files, once it has been archived, audit trail files can be safely removed. If you enter the <i>df</i> command (disk free) and determine that the filesystem containing your audit trail is more than 90 percent full, you should remove old audit files. If your audit files are kept in <i>/var/adm/sat</i>, enter the command<pre><B>df -k /var/adm/sat</B> </pre><p>The output should be similar to this:<PRE>Filesystem  Type blocks  use   avail %use Mounted on
/dev/root   efs  245916 218694 27222  89%    /</PRE><p>In this example, the file system is 89 percent full, and the auditor should archive and remove audit trail files.<A NAME="SGI37"></A>
<h3 class="SGITPL-head">About Audit File Overflow</h3><p>Do not allow your audit files to grow too large. Oversized audit files can use up your available disk space and cause the system to refuse new records and immediately cease operations. This can result in lost work and lost audit records. Maintain at least 10 percent free space in your audit filesystem at all times.<p>The audit daemon, satd(1M), must always be running on your system. The daemon eventually becomes unable to write to the audit file if free disk space drops to 0 percent. When it can no longer write to the audit file, the daemon exits with an error, and the system changes the run level to single-user mode. You must then archive and remove the audit files to free disk space before bringing the system back to multi-user mode. If the <i>satd</i> daemon is somehow killed or interrupted on your system, the system changes the run level to single user mode immediately. The daemon is respawned when the system is brought back up.<A NAME="SGI38"></A>
<h4 class="SGITPL-head">Recovering from Audit File Overflow</h4><p>To make space on the disk for your audit trail, first boot the system into single-user mode. No audit records are generated in this mode. Once in single-user mode, archive your audit files and remove them from the disk. Once at least 10 percent of the filesystem is free, you may boot into multiuser mode without difficulty.<p>If your auditing system directs the audit files to the <i>/</i> (root) filesystem or the <i>/usr</i> file system and either filesystem becomes full, you will not be able to bring the system to single-user mode to archive and remove your old audit files. If you find yourself in this situation, perform the following procedures to remove old audit files:<ol><li>Boot the system from the original distribution media, and allow the <i>inst</i> utility to start up. <br><br><li>At the Inst main menu, select the Admin menu, and then select the <i>shell</i> option from the Admin menu. You see a shell prompt. <p>From the shell, you must archive and remove the old audit files. Remember that when your system is running the Inst (also called <i>miniroot</i>) shell, your system's root directory appears as<pre>/root/</pre><p>rather than<pre>/</pre><p>and your <i>/usr</i> file system appears as<pre>/root/usr</pre><p>because your system's filesystems are mounted on the Inst filesystem. <br><br><li>Once you have created free disk space on your <i>/</i> (root) and <i>/usr</i> filesystems, you should be able to boot your system normally. If this is a recurring problem, you should refer to the satd(1M) reference page for information on changing the location of your audit files.</ol><HR noshade><A NAME="SGI39"></A>
<H1 class="SGITPL-head">Chapter 7<BR> System Accounting</h1><p>IRIX provides utilities to log certain types of system activity. These utilities perform process accounting and system accounting. This chapter contains the following sections:<ul><li><A HREF="IA_BakSecAcc-8.html#SGI40" TARGET=_top>"About the Process Accounting System"</A> discusses the accounting subsystem that keeps track of system usage.<br><br><li><A HREF="IA_BakSecAcc-8.html#SGI44" TARGET=_top>"Accounting Files and Directories"</A> talks about where accounting information is stored.<br><br><li><A HREF="IA_BakSecAcc-8.html#SGI50" TARGET=_top>"About Daily System Accounting"</A> defines daily system accounting and gives setup procedures.<br><br><li><A HREF="IA_BakSecAcc-8.html#SGI52" TARGET=_top>"Daily System Accounting with runacct"</A> describes how to operate the <i>runacct</i> program.</ul><p>The four initial sections describe the standard UNIX System V accounting procedures. IRIX also implements an extended accounting facility, discussed in the following section:<ul><li><A HREF="IA_BakSecAcc-8.html#SGI64" TARGET=_top>"IRIX Extended Accounting"</A> describes an accounting subsystem useful for large computer sites.</ul><p>Ask your Silicon Graphics sales representative for information on additional tools available. For example, SHARE II for IRIX is an optional product allowing additional administrative control of system resources including disk space, CPU entitlement, memory (real or virtual), number of processes, printer pages, terminal and modem connect-time, network packets, and more.<HR noshade><A NAME="SGI40"></A>
<h2 class="SGITPL-head">About the Process Accounting System</h2><p>The IRIX process accounting system can provide the following information:<ul><li>the number of programs a user runs <br><br><li>the size and duration of user programs <br><br><li>data throughput (I/O) </ul><p>Using this information, you can: <ul><li>Determine how system resources are used and if a particular user is using more than a reasonable share.<br><br><li>Trace significant system events, such as security breaches, by examining the list of all processes invoked by a particular user at a particular time.<br><br><li>Set up billing systems to charge login accounts for using system resources. </ul><p>The next sections describe the parts of process accounting, how to turn on and off process accounting, and how to look at the various log files.<A NAME="SGI41"></A>
<h3 class="SGITPL-head">Parts of the Process Accounting System</h3><p>The IRIX process accounting system has several parts: <ul><li>The IRIX kernel writes a record of each process on the system that terminates into the file <i>/var/adm/pacct</i>. The file contains one record per terminated process, organized according to the format defined in <i>/usr/include/sys/acct.h.</i><p>You must specifically turn on this function. See <A HREF="IA_BakSecAcc-8.html#SGI42" TARGET=_top>"Turning On Process Accounting"</A>. <br><br><li>Once process accounting is turned on, the cron program executes several accounting commands, as specified in <i>/var/spool/cron/crontabs/adm</i> and <i>/var/spool/crontabs/root.</i> The commands in <i>adm</i> perform monthly accounting (<i>monacct</i>), check the size of the <i>pacct</i> file (<i>ckpacct</i>), and provide a daily accounting of processes and connect time (runacct). The root crontab file runs the dodisk program, which provides a report on current disk usage. These commands run automatically when process accounting is turned on. <br><br><li>The <i>login</i> and <i>init</i> programs record connect sessions by writing records into <i>/etc/wtmp</i>. This happens by default, as long as the <i>wtmp</i> file exists. <br><br><li>Records of date changes, reboots, and shutdowns are copied from <i>/etc/utmp</i> to <i>/etc/wtmp</i> by the <i>acctwtmp</i> command. <br><br><li>The <i>acctwtmp</i> utility is automatically called by <i>runacct</i>, /usr/lib/acct/startacct, and <i>/usr/lib/shutacct</i>, once process accounting is turned on. <br><br><li>The disk utilization programs <i>acctdusg</i> and <i>diskusg</i> break down disk usage by login and prepare reports. These programs are run by the <i>dodisk</i> script. For details, see the acct(1M), acctsh(1M), and diskusg(1M) reference pages.</ul><p>Note that for XFS filesystems, disk quotas (installed with the subsystem eoe.sw.quotas) can be used as an efficient accounting tool to keep track of disk usage. Refer to <i></i>IRIX Admin: Disks and Filesystems    <i></i> for more information.<A NAME="SGI42"></A>
<h3 class="SGITPL-head">Turning On Process Accounting</h3><p>To turn on process accounting: <ol><li>Log in to the system as <i>root</i>. <br><br><li>Make sure the <i>eoe.sw.acct</i> subsystem is installed. If not, install it.<br><br><li>Enter this command: <PRE><B>chkconfig acct on</B> </PRE><li>Enter this command: <PRE><B>/usr/lib/acct/startup</B> </PRE><p>This starts the kernel writing information into the file <i>/var/adm/pacct</i>. </ol><p>Process accounting is started every time you boot the system, and every time the system boots, you should see a message similar to this: <PRE>System accounting started </PRE><p>Note that process accounting files, especially <i>/var/adm/pacct</i>, can grow very large. If you turn on process accounting, especially on a server, you should watch the amount of free disk space carefully. See <A HREF="IA_BakSecAcc-8.html#SGI45" TARGET=_top>"Accounting File Size Control"</A>.<A NAME="SGI43"></A>
<h3 class="SGITPL-head">Turning Off Process Accounting</h3><p>To turn off process accounting, follow these steps:<ol><li>Log in as <i>root</i>. <br><br><li>Enter this command: <PRE><B>chkconfig acct off</B> </PRE><li>Enter this command: <PRE><B>/usr/lib/acct/shutacct</B> </PRE><p>This stops the kernel from writing accounting data into the file <i>/var/adm/pacct.</i> Process accounting is now turned off.</ol><HR noshade><A NAME="SGI44"></A>
<h2 class="SGITPL-head">Accounting Files and Directories</h2><p>The directory <i>/usr/lib/acct</i> contains the programs and shell scripts necessary to run the accounting system. Process accounting uses a login (<i>/var/adm</i>) to perform certain tasks. <i>/var/adm</i> contains active data collection files used by the process accounting. Here is a description of the primary subdirectories in <i>/var/adm</i>:<ul><li><i>/var/adm/acct/nite</i> contains files that are reused daily by <i>runacct</i>. <br><br><li><i>/var/adm/acct/sum</i> contains the cumulative summary files updated by <i>runacct</i>.<br><br><li><i>/var/adm/acct/fiscal</i> contains periodic summary files created by <i>monacct</i>.</ul><A NAME="SGI45"></A>
<h3 class="SGITPL-head">Accounting File Size Control</h3><p>Process and disk accounting files can grow very large. On a busy system, they can grow quite rapidly. <p>To help keep the size of the file <i>/var/adm/pacct</i> under control, the <i>cron</i> command runs <i>/usr/lib/acct/ckpacct</i> to check the size of the file and the available disk space on the file system.<p>If the size of the <i>pacct</i> file exceeds 1000 blocks (by default), it runs the <i>turnacct</i> command with argument "switch." The "switch" argument causes <i>turnacct</i> to back up the <i>pacct</i> file (removing any existing backup copy) and start a new, empty <i>pacct</i> file. This means that at any time, no more than 2000 blocks of disk space are taken by <i>pacct</i> file information.<p>If the amount of free space in the file system falls below 500 blocks, <i>ckpacct</i> automatically turns off process accounting by running the <i>turnacct</i> command with the "off" argument. When at least 500 blocks of disk space are free, accounting is activated again the next time <i>cron</i> runs <i>ckpacct</i>.<A NAME="SGI46"></A>
<h3 class="SGITPL-head">Files in the /var/adm Directory</h3><p>The files listed here are located in the <i>/var/adm</i> directory:<dl><dt><i>diskdiag</i> <dd><br>diagnostic output during the execution of disk accounting programs <dt><br><i>dtmp</i> <dd><br>output from the acctdusg program <dt><br><i>fee</i> <dd><br>output from the chargefee program, ASCII <i>tacct</i> records <dt><br><i>pacct</i> <dd><br>active process accounting file <dt><br><i>pacct</i>? <dd><br>process accounting files switched by <i>turnacct</i><dt><br><i>Spact?.MMDD</i> <dd><br>process accounting files for MMDD during execution of runacct</dl><A NAME="SGI47"></A>
<h3 class="SGITPL-head">Files in the /var/adm/acct/nite Directory</h3><p>The following files are located in the <i>/var/adm/acct/nite</i> directory:<dl><dt><i>active</i> <dd><br>used by <i>runacct</i> to record progress and print warning and error messages. <i>activeMMDD</i> is the same as <i>active</i> after <i>runacct</i> detects an error <dt><br><i>cms</i> <dd><br>ASCII total command summary used by <i>prdaily</i><dt><br><i>ctacct.MMDD</i> <dd><br>connect accounting records in <i>tawcct.h</i> format <dt><br><i>ctmp</i> <dd><br>output of acctcon1 program, connect session records in<i> ctmp.h</i> format <dt><br><i>daycms</i> <dd><br>ASCII daily command summary used by <i>prdaily</i><dt><br><i>daytacct</i> <dd><br>total accounting records for one day in <i>tacct.h</i> format <dt><br><i>disktacct</i> <dd><br>disk accounting records in <i>tacct.h</i> format, created by <i>dodisk</i> procedure<dt><br> <i>fd2log</i> <dd><br>diagnostic output during execution of <i>runacct</i> (see cron entry) <dt><br><i>lastdate</i> <dd><br>last day runacct executed in date <var>+%m%d</var> format <dt><br><i>lock lock1</i> <dd><br>used to control serial use of <i>runacct</i><dt><br><i>lineuse</i> <dd><br>tty line usage report used by <i>prdaily</i><dt><br><i>log</i> <dd><br>diagnostic output from <i>acctcon1</i><dt><br><i>logMMDD</i> <dd><br>same as log after <i>runacct</i> detects an error <dt><br><i>reboots</i> <dd><br>contains beginning and ending dates from <i>wtmp</i> and contains a listing of reboots <dt><br><i>statefile</i> <dd><br>used to record current state during execution of <i>runacct</i><dt><br><i>tmpwtmp</i> <dd><br><i>wtmp</i> file corrected by <i>wtmpfix</i><dt><br><i>wtmperror</i> <dd><br>place for <i>wtmpfix</i> error messages <dt><br><i>wtmperrorMMDD </i><dd><br>same as <i>wtmperror</i> after <i>runacct</i> detects an error <dt><br><i>wtmp.MMDD</i> <dd><br>previous day's <i>wtmp</i> file</dl><A NAME="SGI48"></A>
<h3 class="SGITPL-head">Files in the /var/adm/acct/sum Directory</h3><p>The following files are located in the <i>/var/adm/acct/sum</i> directory:<dl><dt><i>cms</i> <dd><br>total command summary file for current fiscal period in internal summary format<dt><br><i>cmsprev</i> <dd><br>command summary file without latest update <dt><br><i>daycms</i> <dd><br>command summary file for yesterday in internal summary format <dt><br><i>loginlog</i> <dd><br>created by <i>lastlogin</i><dt><br><i>pact.MMDD</i> <dd><br>concatenated version of all <i>pacct</i> files for <var>MMDD</var>, removed by remove procedure after reboot <dt><br><i>rprtMMDD</i> <dd><br>saved output of <i>prdaily</i> programs <dt><br><i>tacct</i> <dd><br>cumulative total accounting file for current fiscal period<dt><br><i>tacctprev</i> <dd><br>same as <i>tacct</i> without latest update <dt><br><i>tacctMMDD</i> <dd><br>total accounting file for <var>MMDD</var><dt><br><i>wtmp.MMDD</i> <dd><br>saved copy of <i>wtmp</i> file for <var>MMDD</var>, removed by remove procedure after reboot</dl><A NAME="SGI49"></A>
<h3 class="SGITPL-head">Files in the /var/adm/acct/fiscal Directory</h3><p>The following files are located in the <i>/var/adm/acct/fiscal</i> directory:<dl><dt><i>cms?</i> <dd><br>total command summary file for <var>fiscal? </var>in internal summary format<dt><br><i>fiscrpt?</i> <dd><br>report similar to <i>prdaily</i> for <var>fiscal?</var><dt><br><i>tacct?</i> <dd><br>total accounting file for <var>fiscal?</var></dl><HR noshade><A NAME="SGI50"></A>
<h2 class="SGITPL-head">About Daily System Accounting</h2><p>When IRIX enters multiuser mode, <i>/usr/lib/acct/startup</i> is executed as follows: <ul><li>The <i>acctwtmp</i> program adds a "boot" record to <i>/etc/wtmp</i>. This record is signified by using the system name as the login name in the <i>wtmp</i> record.<br><br><li>Process accounting is started by <i>turnacct</i>, which in turn executes <i>acct </i>on<i> /var/adm/pacct</i>. <br><br><li><i>remove</i> is executed to clean up the saved <i>pacct</i> and <i>wtmp</i> files left in the <i>sum</i> directory by <i>runacct</i>. </ul><p>The <i>ckpacct</i> procedure is run through <i>cron</i> every hour of the day to check the size of <i>/var/adm/pacct</i>. If the file grows past 1000 blocks (default), the <i>turnacct</i> switch is executed. The advantage of having several smaller <i>pacct</i> files becomes apparent when you try to restart <i>runacct</i> after a failure processing these records.<p>The <i>chargefee</i> program can be used to bill users for file restores, and so on. It adds records to<i> /var/adm/fee </i>that are picked up and processed by the next execution of <i>runacct</i> and merged into the total accounting records. <i>runacct</i> is executed through <i>cron</i> each night. It processes the active accounting files, <i>/var/adm/pacct</i>, <i>/etc/wtmp</i>, <i>/var/adm/acct/nite/disktacct</i>, and <i>/var/adm/fee</i>. It produces command summaries and usage summaries by login name. <p>When the system is shut down using <i>shutdown</i>, the <i>shutacct</i> shell procedure is executed. It writes a shutdown reason record into <i>/etc/wtmp</i> and turns process accounting off. <p>After the first reboot each morning, the administrator should execute <i>/usr/lib/acct/prdaily</i> to print the previous day's accounting report.<A NAME="SGI51"></A>
<h3 class="SGITPL-head">Setting Up the Accounting System</h3><p>If you have installed the system accounting option, all the files and command lines for implementation have been set up properly. You may wish to verify that the entries in the system configuration files are correct. In order to automate the operation of the accounting system, you should check that the following have been done: <ol><li>The file <i>/etc/init.d/acct</i> should contain the following lines (among others):<PRE>/usr/lib/acct/startup
/usr/lib/acct/shutacct</PRE><p>The first line starts process accounting during the system startup process; the second stops it before the system is brought down.<br><br><li>For most installations, the following entries should be in    <i>/var/spool/cron/crontabs/adm</i> so that <i>cron</i> automatically runs the daily accounting. These lines should already exist:<pre>0 4 * * 1-6 if /etc/chkconfig acct; then /usr/lib/acct/runacct 2> /var/adm/acct/nite/fd2log; fi
5 * * * 1-6 if /etc/chkconfig acct; then /usr/lib/acct/ckpacct; fi</pre><p>Note that the above <i>cron</i> commands must constitute only one line in the <i>crontabs</i> file. The following command, which also constitutes only one line in the <i>crontabs</i> file, should be in <i>/var/spool/cron/crontabs/root</i>:<pre>0 2 * * 4 if /etc/chkconfig acct; then /usr/lib/acct/dodisk > /var/adm/acct/nite/disklog; fi</pre><li>To facilitate monthly merging of accounting data, the following entry in <i>/var/spool/cron/crontabs/adm</i> allows <i>monacct</i> to clean up all daily reports   and daily total accounting files, and deposit one monthly total report and one monthly total accounting file in the fiscal directory: <pre>0 5 1 * * if /etc/chkconfig acct; then /usr/lib/acct/monacct; fi</pre><p>The above command is all on one line in the source file, and takes advantage of the default action of <i>monacct</i> that uses the current month's date as the suffix for the file names. Notice that the entry is executed when <i>runacct</i> has sufficient time to complete. This will, on the first day of each month, create monthly accounting files with the entire month's data. <br><br><li>You may wish to verify that an account exists for <i>adm</i>. Also, verify that the PATH shell variable is set in <i>/var/adm/.profile</i> to:<PRE>PATH=/usr/lib/acct:/bin:/usr/bin </PRE><li>To start up system accounting, simply type the commands<p><TT><B>chkconfig acct on </B></TT><p>and <p><TT><B>/usr/lib/acct/startup </B></TT></ol><p>The next time the system is booted, accounting starts.<HR noshade><A NAME="SGI52"></A>
<h2 class="SGITPL-head">Daily System Accounting with runacct</h2><p>The <i>runacct</i> command is the main daily accounting shell procedure. It is normally initiated by <i>cron</i> during nonpeak hours. <i>runacct</i> processes connect, fee, disk, and process accounting files. It also prepares daily and cumulative summary files for use by <i>prdaily</i> or for billing purposes.<A NAME="SGI53"></A>
<h3 class="SGITPL-head">runacct Summary Files</h3><p>The following files produced by <i>runacct</i> are of particular interest: <dl><dt><i>nite/lineuse</i> <dd><br>Produced by <i>acctcon</i>, reads the <i>wtmp</i> file and produces usage statistics for each terminal line on the system. This report is especially useful for detecting bad lines. If the ratio between the number of logoffs to logins exceeds about 3:1, it is quite possible that the line is failing. <dt><br><i>nite/daytacct</i> <dd><br>The total accounting file for the previous day in <i>tacct.h </i>format. <dt><br><i>sum/tacct</i> <dd><br>The accumulation of each day's <i>nite/daytacct</i> can be used for billing purposes. It is restarted each month or fiscal period by the <i>monacct</i> procedure. <dt><br><i>sum/daycms</i> <dd><br>Produced by the <i>acctcms</i> program. It contains the daily command summary. The ASCII version of this file is <i>nite/daycms</i>. <dt><br><i>sum/cms</i> <dd><br>The accumulation of each day's command summaries. It is restarted by the execution of <i>monacct</i>. The ASCII version is <i>nite/cms</i>.<dt><br><i>sum/loginlog</i> <dd><br>Produced by the last login shell procedure. It maintains a record of the last time each <i>login</i> name was used. <dt><br><i>sum/rprtMMDD </i><dd><br>Each execution of <i>runacct</i> saves a copy of the daily report that can be printed by <i>prdaily</i>. </dl><p><i>runacct</i> takes care not to damage files in the event of errors. A series of protection mechanisms are used that attempt to recognize an error, provide intelligent diagnostics, and terminate processing in such a way that <i>runacct</i> can be restarted with minimal intervention. It records its progress by writing descriptive messages into the file <i>active</i>. (Files used by <i>runacct</i> are assumed to be in the <i>nite</i> directory unless otherwise noted.) All diagnostics output during the execution of <i>runacct</i> are written into <i>fd2log. runacct</i> complains if the files <i>lock</i> and <i>lockl</i> exist when invoked. The <i>lastdate</i> file contains the month and day <i>runacct</i> was last invoked and is used to prevent more than one execution per day. If <i>runacct</i> detects an error, a message is written to <i>/dev/console</i>, mail is sent to <i>root</i> and <i>adm</i>, locks are removed, diagnostic files are saved, and execution is terminated.<A NAME="SGI54"></A>
<h3 class="SGITPL-head">runacct Reentrant States</h3><p>To allow runacct to be restartable, processing is broken down into separate reentrant states. A file is used to remember the last state completed. When each state completes, <i>statefile</i> is updated to reflect the next state. After processing for the state is complete, <i>statefile</i> is read and the next state is processed. When <i>runacct</i> reaches the CLEANUP state, it removes the locks and terminates. States are executed as follows: <dl><dt>SETUP <dd><br>The command <i>turnacct</i> switch is executed. The process accounting files, <i>/var/adm/pacct?</i>, are moved to <i>/var/adm/Spacct?.MMDD</i>. The <i>/etc/wtmp</i> file is moved to <i>/var/adm/acct/nite/wtmp.MMDD</i> with the current time added on the end. <dt><br>WTMPFIX <dd><br>The <i>wtmpfix</i> program checks the <i>wtmp</i> file in the <i>nite</i> directory for correctness. Some date changes cause <i>acctcon1</i> to fail, so <i>wtmpfix</i> attempts to adjust the time stamps in the <i>wtmp</i> file if a date change record appears.<dt><br>CONNECT1 <dd><br>Connect session records are written to <i>ctmp</i> in the form of <i>ctmp.h. T</i>he lineuse file is created, and the reboots file is created showing all of the boot records found in the <i>wtmp</i> file.<dd><br><i>ctmp</i> is converted to <i>ctacct.MMDD</i>, which are connect accounting records. (Accounting records are in <i>tacct.h </i>format.)<dd><br>The <i>acctprc1</i> and <i>acctprc2</i> programs are used to convert the process accounting files, <i>/var/adm/Spacct?.MMDD</i>, into total accounting records in<i> ptacct?.MMDD</i>. The <i>Spacct</i> and <i>ptacct</i> files are correlated by number so that if <i>runacct</i> fails, the unnecessary reprocessing of <i>Spacct</i> files will not occur. One precaution should be noted: when restarting <i>runacct</i> in this state, remove the last <i>ptacct</i> file, because it will not be complete. <dt><br>MERGE <dd><br>Merge the process accounting records with the connect accounting records to form <i>daytacct</i>.<dt><br>FEES <dd><br>Merge in any ASCII <i>tacct</i> records from the file <i>fee</i> into <i>daytacct</i>.<dt><br>DISK <dd><br>On the day after the <i>dodisk</i> procedure runs, merge <i>disktacct</i> with <i>daytacct</i>.<dt><br>MERGETACCT <dd><br>Merge <i>daytacct</i> with <i>sum/tacct</i>, the cumulative total accounting file. Each day, <i>daytacct</i> is saved in<i> sum/tacctMMDD</i>, so that <i>sum/tacct</i> can be recreated in case it is corrupted or lost. <dt><br>CMS <dd><br>Merge in today's command summary with the cumulative command summary file <i>sum/cms</i>. Produce ASCII and internal format command summary files. <dt><br>USEREXIT <dd><br>Any installation-dependent (local) accounting programs can be included here.<dt><br>CLEANUP <dd><br>Clean up temporary files, run <i>prdaily</i> and save its output in <i>sum/rprtMMDD</i>, remove the locks, then exit.</dl><A NAME="SGI55"></A>
<h3 class="SGITPL-head">Recovering from runacct Failures</h3><p>The <i>runacct</i> procedure can fail for a variety of reasons   -       usually due to a system crash, <i>/usr</i> running out of space, or a corrupted wtmp file. If the <i>activeMMDD</i> file exists, check it first for error messages. If the <i>active</i> file and lock files exist, check <i>fd2log</i> for any mysterious messages. The following are error messages produced by runacct and the recommended recovery actions: <dl><dt><pre><TT>ERROR: locks found, run aborted </TT></pre></dt><dd><p>The files <i>/var/adm/acct/nite/lock</i> and <i>/var/adm/acct/nite/lock1</i> were found. These files must be removed before runacct can restart. </dd></dl><dl><dt><pre><TT>ERROR: acctg already run for date: check /var/adm/acct/nite/lastdate </TT></pre></dt><dd><p>The date in <i>lastdate</i> and today's date are the same. Remove <i>lastdate</i>. </dd></dl><dl><dt><pre><TT>ERROR: turnacct switch returned rc=? </TT></pre></dt><dd><p>Check the integrity of <i>turnacct</i> and <i>accton</i>. The <i>accton</i> program must be owned by root and have the <i>setuid</i> bit set. </dd></dl><dl><dt><pre><TT>ERROR: Spacct?.MMDD already exists </TT></pre></dt><dd><p>File setups probably already run. Check status of files, then run setups manually. </dd></dl><dl><dt><pre><TT>ERROR: /var/adm/acct/nite/wtmp.MMDD already exists, run setup manually </TT></pre></dt><dd><p>Self-explanatory. </dd></dl><dl><dt><pre><TT>ERROR: wtmpfix detected a corrupted wtmp file. Use fwtmp to correct the corrupted file. </TT></pre></dt><dd><p>Self-explanatory.</dd></dl><dl><dt><pre><TT>ERROR: connect acctg failed: check /var/adm/acct/nite/log </TT></pre></dt><dd><p>The <i>acctcon1</i> program encountered a bad <i>wtmp</i> file. Use <i>fwtmp</i> to correct the bad file. </dd></dl><dl><dt><pre><TT>ERROR: Invalid state, check /var/adm/acct/nite/active </TT></pre></dt><dd><p>The file <i>statefile</i> is probably corrupted. Check <i>statefile</i> for irregularities and read <i>active</i> before restarting.</dd></dl><A NAME="SGI56"></A>
<h3 class="SGITPL-head">Restarting runacct</h3><p>The <i>runacct</i> program, called without arguments, assumes that this is the first invocation of the day. The argument MMDD is necessary if <i>runacct</i> is being restarted and specifies the month and day for which <i>runacct</i> will rerun the accounting. The entry point for processing is based on the contents of <i>statefile</i>. To override <i>statefile</i>, include the desired state on the command line. For example, to start <i>runacct</i>, use the command: <p><TT><B>nohup runacct 2 /var/adm/acct/nite/fd2log &</B></TT><p>To restart <i>runacct</i>: <p><TT><B>nohup runacct 0601 2 /var/adm/acct/nite/fd2log &</B></TT><p>To restart runacct at a specific state: <p><TT><B>nohup runacct 0601 WTMPFIX 2 /var/adm/acct/nite/fd2log &</B></TT><A NAME="SGI57"></A>
<h3 class="SGITPL-head">Fixing Corrupted Accounting Files</h3><p>Sometimes, errors occur in the accounting system, and a file is corrupted or lost. You can ignore some of these errors, or simply restore lost or corrupted files from a backup. However, certain files must be fixed in order to maintain the integrity of the accounting system.<A NAME="SGI58"></A>
<h4 class="SGITPL-head">Fixing wtmp Errors</h4><p>The <i>wtmp</i> files are the most delicate part of the accounting system. When the date is changed and the IRIX system is in multiuser mode, a set of date change records is written into <i>/etc/wtmp</i>. The <i>wtmpfix</i> program is designed to adjust the time stamps in the <i>wtmp</i> records when a date change is encountered. However, some combinations of date changes and reboots will slip through <i>wtmpfix</i> and cause <i>acctcon1</i> to fail. <p>The following steps show how to fix a <i>wtmp</i> file: <ol><li><TT><B>cd /var/adm/acct/nite</B></TT><br><br><li><TT><B>fwtmp &lt; wtmp.MMDD > xwtmp</B></TT><br><br><li><TT><B>ed xwtmp</B></TT><br><br><li>Delete any corrupted records or delete all records from beginning up to the date change.<br><br><li><TT><B>fwtmp -ic &lt;wtmp> wtmp.MMDD</B></TT></ol><p> If the wtmp file is beyond repair, remove the file and create an empty wtmp file:<ol><li><TT><B>rm /etc/wtmp</B></TT><br><br><li><TT><B>touch /etc/wtmp</B></TT></ol><p>This prevents any charging of connect time. <i>acctprc1</i> cannot determine which login owned a particular process, but it is charged to the login that is first in the password file for that user ID.<A NAME="SGI59"></A>
<h4 class="SGITPL-head">Fixing tacct Errors</h4><p>If the installation is using the accounting system to charge users for system resources, the integrity of <i>sum/tacct</i> is quite important. Occasionally, mysterious <i>tacct</i> records appear with negative numbers, duplicate user IDs, or a user ID of 65,535. First check <i>sum/tacctprev </i>with <i>prtacct</i>. If it looks all right, the latest <i>sum/tacct.MMDD</i> should be patched up, then <i>sum/tacct</i> recreated. A simple patchup procedure would be: <ol><li>Enter the command:<PRE><B>cd /var/adm/acct/sum</B> </PRE><li>Enter the command:<PRE><B>acctmerg -v &lt; tacct.MMDD > xtacct</B> </PRE><li>Enter the command:<PRE><B>ed xtacct </B></PRE><li>Remove the bad records. <br><br><li>Write duplicate UID records to another file. <br><br><li>Enter the command: <PRE><B>acctmerg -i &lt; xtacc t > tacct.MMDD </B></PRE><li>Enter the command:<PRE><B>acctmerg tacctprev &lt;tacct.MMDD> tacct </B></PRE></ol><p>Remember that the <i>monacct</i> procedure removes all the <i>tacct.MMDD </i>files; therefore, you can recreate <i>sum/tacct</i> by merging these files.<A NAME="SGI60"></A>
<h3 class="SGITPL-head">Updating Holidays for Accounting</h3><p>The file <i>/usr/lib/acct/holidays</i> contains the prime/nonprime table for the accounting system. The table should be edited to reflect your location's holiday schedule for the year. The format is composed of three types of entries:<ul><li>Comment Lines, which may appear anywhere in the file as long as the first character in the line is an asterisk. <br><br><li>Year Designation Line, which should be the first data line (noncomment line) in the file and must appear only once. The line consists of three fields of four digits each (leading white space is ignored). For example, to specify the year as 1992, prime time at 9:00 a.m., and nonprime time at 4:30 p.m., the following entry is appropriate: <PRE>1992 0900 1630 </PRE><p>A special condition allowed for in the time field is that the time 2400 is automatically converted to 0000. <br><br><li>Company Holidays Lines, which follow the year designation line and have the following general format: <PRE>day-of-year Month Day Description of Holiday </PRE><p>The day-of-year field is a number in the range of 1 through 366, indicating the day for the corresponding holiday (leading white space is ignored). The other three fields are actually commentary and are not currently used by other programs.</ul><A NAME="SGI61"></A>
<h3 class="SGITPL-head">Daily runacct Reports</h3><p><i>runacct</i> generates five basic reports upon each invocation. They cover the areas of connect accounting, usage by person on a daily basis, command usage reported by daily and monthly totals, and a report of the last time users were logged in. The following paragraphs describe the reports and the meanings of their tabulated data. <p>In the first part of the report, the from/to banner should alert the administrator to the period reported on. This period runs from the time the last accounting report was generated until the time the current accounting report was generated. It is followed by a log of system reboots, shutdowns, power fail recoveries, and any other record dumped into <i>/etc/wtmp</i> by the <i>acctwtmp</i> program. See the acct(1M) reference page for more information.<p>The second part of the report is a breakdown of line utilization. The TOTAL DURATION field tells how long the system was in multiuser state (able to be accessed through the terminal lines). The columns are: <dl><dt>LINE <dd><br>The terminal line or access port. <dt><br>MINUTES <dd><br>The total number of minutes the line was in use during the accounting period.<dt><br>PERCENT <dd><br>The total number of minutes the line was in use divided into the total duration of the accounting period. <dt><br># SESS <dd><br>The number of times this port was accessed for a <i>login</i> session. <dt><br># ON <dd><br>This column has little significance. It previously gave the number of times that the port was used to log a user on; but since <i>login</i> can no longer be executed explicitly to log in a new user, this column should be identical with SESS.<dt><br># OFF <dd><br>The number of times a user logged off and also any interrupts that occur on that line. Generally, interrupts occur on a port when the <i>getty</i> is first invoked after the system is brought to multiuser state. This column comes into play when the # OFF exceeds the # ON by a large factor. This usually indicates that the multiplexer, modem, or cable is going bad, or that there is a bad connection somewhere. The most common cause of this is an unconnected cable dangling from the multiplexer. </dl><p>During real time, <i>/etc/wtmp</i> should be monitored, since this is the file from which connect accounting is geared. If it grows rapidly, execute <i>acctcon1</i> to see which line is the noisiest. If the interrupting is occurring at a furious rate, general system performance will be affected.<A NAME="SGI62"></A>
<h4 class="SGITPL-head">Daily Usage Report</h4><p>The daily usage report gives a by-user breakdown of system resource utilization. Its data consists of: <dl><dt>UID <dd><br>The user ID. <dt><br>LOGIN NAME <dd><br>The login name of the user; more than one login name can exist for a single user ID, and this entry identifies which login name used the resource. <dt><br>CPU (MINS) <dd><br>The amount of time the user's process used the central processing unit. This category is broken down into PRIME and NPRIME (nonprime) utilization. The accounting system's idea of this breakdown is located in the <i>/usr/lib/acct/holidays</i> file. As delivered, prime time is defined to be 0900 through 1700 hours. <dt><br>KCORE-MINS <dd><br>A cumulative measure of the amount of memory a process uses while running. The amount shown reflects kilobyte segments of memory used per minute. This measurement is also broken down into PRIME and NPRIME amounts. <dt><br>CONNECT (MINS) <dd><br>The amount of time that a user was logged into the system. If this time is high and # OF PROCS is low, this indicates that the user was logged in for a long period of time without actually using the system. This column is also subdivided into PRIME and NPRIME utilization. <dt><br>DISK BLOCKS <dd><br>When the disk accounting programs have been run, the output is merged into the total accounting record (<i>tacct.h</i>) and shows up in this column. This disk accounting is accomplished by the program <i>acctdusg</i>. <dt><br># OF PROCS <dd><br>The number of processes invoked by the user. Large numbers in this column indicate that a user may have had a shell running out of control. <dt><br># O SESS <dd><br>Number of times the user logged onto the system. <dt><br># DISK SAMPLES <dd><br>Number of times disk accounting was run to obtain the average number of DISK BLOCKS listed earlier. <dt><br>FEE <dd><br>An often unused field in the total accounting record, the FEE field represents the total accumulation of widgets charged against the user by the <i>chargefee</i> shell procedure. See acctsh(1M). The <i>chargefee</i> procedure is used to levy charges against a user for special services performed such as file restores, and so on.</dl><A NAME="SGI63"></A>
<h4 class="SGITPL-head">Daily Command and Monthly Total Command Summaries</h4><p>These two reports are virtually the same except that Daily Command Summary reports only on the current accounting period, while Monthly Total Command Summary tells the story for the start of the fiscal period to the current date. In other words, the monthly report reflects the data accumulated since the last invocation of <i>monacct</i>. <p>The data included in these reports tell an administrator which commands are used most heavily. Based on those commands' characteristics of system resource utilization, the administrator can decide what to weigh more heavily when system tuning. These reports are sorted by TOTAL KCOREMIN, which is an arbitrary yardstick but often a good one for calculating "drain" on a system. <dl><dt>COMMAND NAME <dd><br>The name of the command. Unfortunately, all shell procedures are lumped together under the name<i> sh</i> since only object modules are reported by the process accounting system. The administrator should monitor the frequency of programs called <i>a.out</i> or <i>core</i> or any other name that does not seem quite right. Often people like to work on their favorite version of a personal program, but they do not want everyone to know about it. <i>acctcom</i> is also a good tool for determining who executed a suspiciously named command and also to see if superuser privileges were abused. <dt><br>NUMBER CMDS <dd><br>The total number of invocations of this particular command. <dt><br>TOTAL KCOREMIN <dd><br>The total cumulative measurement of the amount of kilobyte segments of memory used by a process per minute of run time. <dt><br>TOTAL CPU-MIN <dd><br>The total processing time this program has accumulated. <dt><br>TOTAL REAL-MIN <dd><br>The total real-time (wall-clock) minutes this program has accumulated. This total is the actual "waited for" time as opposed to kicking off a process in the background. <dt><br>MEAN SIZE-K <dd><br>The mean of the TOTAL KCOREMIN over the number of invocations reflected by NUMBER CMDS. <dt><br>MEAN CPU-MIN <dd><br>The mean derived between NUMBER CMDS and TOTAL CPU-MIN. <dt><br>HOG FACTOR <dd><br>This gives a relative measure of the total available CPU time consumed by the process during its execution. It is a measurement of the ratio of system availability to system utilization. It is computed by the formula:<dd><br><i>total CPU time</i> / <i>elapsed time</i><dt><br>CHARS TRNSFD <dd><br>This column, which may contain a negative value, is a total count of the number of characters pushed around by the <b>read</b> and <b>write</b> system calls.<dt><br>BLOCKS READ <dd><br>A total count of the physical block reads and writes that a process performed.</dl><HR noshade><A NAME="SGI64"></A>
<h2 class="SGITPL-head">IRIX Extended Accounting</h2><p>Large computing sites often have many unrelated users and must be able to charge them separately for resource usage. Although there are IRIX mechanisms to provide usage information, these mechanisms are inadequate for many sites. Standard IRIX accounting lacks some important metrics, uses lots of disk space, and provides little flexibility for usage billing. Third-party accounting software addresses some of these issues, but is still limited by data provided IRIX. Array clusters and hypercubes compound these problems by allowing a single user's resource usage to be spread over multiple systems.<p>IRIX provides three features to assist large computing sites with accounting needs: extended accounting, array sessions, and project IDs.<A NAME="SGI65"></A>
<h3 class="SGITPL-head">About Extended Accounting</h3><p>The original IRIX mechanism for resource accounting was based on standard System V accounting. Whenever a process exits, the kernel writes a record containing resource usage information to a file. Because the kernel itself does this file I/O, process accounting can become a minor bottleneck on heavily loaded systems. Another problem is with the format of data written by System V accounting: usage information is stored using an awkward compressed format that amounts to a 16-bit floating point number. Values quickly lose a significant amount of accuracy, and have a maximum value that is not difficult to exceed on modern systems (around 2<sup>34</sup>, or 16 GB). Finally, there is no room for expansion in the accounting records. Metrics provided are fairly limited, and many customers need additional data. However, with no room for expansion, additional fields would require increasing the record size, which would break virtually all the existing software that uses accounting data.<p>In IRIX release 6.1 and later, extended accounting is available, while System V accounting remains in place, essentially unchanged.<p>One significant change in extended accounting is the delivery mechanism: records are written using the system audit trail (SAT) facility, which uses a daemon to collect audit records from the kernel using special system calls. SAT writes records out to destinations chosen by the system administrator; see satd(1M). This gets the kernel out of the file I/O business, and gives system administrators flexibility in the handling of accounting data.<p>The <i>sat_select</i> command can be used to select accounting events for the audit subsystem to monitor; see sat_select(1M) for details.<p>Housekeeping tasks such as rotating audit files and handling file-system-full conditions are handled by the <i>satd</i> program. Third party software can either read the audit files in their entirety (files may contain records for non-accounting events if a site has elected to audit them) or use the existing <i>sat_reduce</i> program to filter out only relevant accounting records; see sat_reduce(1M). Contents of individual records can be dumped in ASCII format using the <i>sat_interpret</i> program; see sat_interpret(1M).<p>Resource data contained in extended accounting records is stored as uncompressed 64-bit values, which should be sufficient for most metrics into the near future. Records contain spare fields to allow for future expansion, and a version code to allow software to handle future format changes gracefully. In addition to all of the metrics reported by System V accounting, these new metrics have been added:<ul><li>number of swaps<br><br><li>number of bytes read or written<br><br><li>number of read or write requests<br><br><li>time spent waiting<ul><br><li>for block I/O<br><br><li>for physical I/O<br><br><li>on the run queue</ul></ul><A NAME="SGI66"></A>
<h3 class="SGITPL-head">Using Extended Accounting</h3><p>To begin using extended accounting on a system, follow these steps:<ol><li>Enable session accounting in the kernel by using the <i>systune</i> command to set the <var>do_sessacct</var> or <var>do_extpacct</var> parameters to non-zero values; see systune(1M).<br><br><li>Install the <i>eoe.sw.audit</i> subsystem from IRIX distribution media.<br><br><li>Enable the audit facility with the following command:<pre><B>chkconfig audit on</B> </pre><li>Use the <i>satconfig</i> command to enable the <var>sat_proc_acct</var> or <var>sat_session_acct</var> audit events; see satconfig(1M). If you are using the audit facility for accounting purposes only, you may turn off all other events to conserve disk space.</ol><p>For more information, see the extacct(1M) reference page. Appendix A of <i></i>IRIX Admin: System Configuration and Operation    <i></i>, lists kernel parameters for extended accounting.<A NAME="SGI67"></A>
<h3 class="SGITPL-head">Array Sessions</h3><p>To reduce disk space consumption and processing time for accounting records, IRIX can accumulate and report accounting information by array session. Process accounting is separately controlled   -        sites can use either accounting style, or both. Session accounting records contains data similar to process accounting records, except that counters and values reflect the accumulated total of all processes that were members of the session.<p>An array session is a set of processes all related to each other by a single unique identifier, the array session handle (ASH). A child process ordinarily inherits the ASH of its parent when created, thus becoming a member of its parent's array session. However, a system call is provided to allow a process to leave its parent's array session and start a new one. Programs like <i>login</i> and <i>rshd</i> use these system calls so that logging into the system effectively starts a new session. Programs like <i>cron</i>, <i>su</i>, and several batch queuing systems use these system calls so that work done on behalf of another user can have its own session. When the last process with a given ASH exits, the array sessions ends, and a session accounting record is written.<p>The ASH is a 64-bit value. A unique, increasing value (similar to a process ID) is assigned by default to each new array session as its handle. However, a system call is provided to change an array session's handle if desired. This can be used to synchronize the handles of array sessions on several systems in an array, thus allowing a distributed job to be considered a single entity for accounting purposes.<p>For more information, see the array_sessions(5) reference page.<p>The range of handles that ths system assigns may be configurable, so it is possible to ensure that automatically assigned handles never conflict with process-specified ones. The system ensures that a particular ASH is never in use by more than one array session on that local system at one time.<p>In addition to accumulated totals of various process accounting data, session accounting records contain a 64-byte field intended for "service provider information." In particular, batch queuing systems can use this field to record data about the queue name, initiator, and so forth. By default, the service provider information for a new array session is inherited from the array session of its parent process.<p>The standard <i>init</i> program always has its service provider information set to all zeroes, and standard login utilities (<i>login</i>, <i>su</i>, <i>rshd</i>) never change service provider information. Batch queuing systems, on the other hand, are always expected to set service provider information to some non-zero value. Thus, it is possible to distinguish batch jobs from interactive sessions by checking if the service provider information is all zeroes or not.<A NAME="SGI68"></A>
<h3 class="SGITPL-head">Project IDs</h3><p>Many sites must be able to charge individual departments separately for their usage of a given system. Typically, this was done by billing total usage for each system user ID to the appropriate department. However, some sites have users that work for more than one department, so billing all usage to a single department is not appropriate. <p>To solve this accounting conundrum, the project ID feature was introduced into IRIX. A project ID is similar to a group ID, except that: <ul><li>the current project ID is associated with an array session, not an individual process <br><br><li>the project ID does not affect access permissions; its only purpose is for accounting</ul><p>A default project ID is associated with every user ID. Whenever it is necessary for a user to do work that should be billed to a different project, the <i>newproj</i> command may be used to change project ID; see newproj(1) for details. This command starts a new shell and array session; background processes under the old shell continue being accounted for under the original project ID. Furthermore, the user ID and group ID remain unchanged, so access permissions are unaffected. To prevent users from specifying a project ID for which they are not authorized, the <i>newproj</i> command consults a file listing valid project IDs for each user. The system calls that set project ID require superuser privileges.<p>The file that contains user IDs and their authorized projects, <i>/etc/project</i>, is similar in style to <i>/etc/passwd</i> or <i>/etc/group</i>; see project(4) for details. This file also specifies the default project for each user, in order to avoid modifying <i>/etc/passwd</i>. Because the project ID is a simple number, an additional file, <i>/etc/projid</i>, associates mnemonic ASCII names with numeric project IDs; see projid(4) for details. The system administrator can configure a standard default project ID using the <var>dfltprid</var> variable of <i>systune</i>.<p>By default, an array session inherits the project ID of the session that spawned it. The standard login utilities (<i>login</i>, <i>su</i>, <i>rshd</i>) that start new array sessions have been updated to change project ID to the default project ID of the new user.<p>Library routines for reading project ID files is also provided, comparable to library routines for reading password file data. See projid(3C) for more information.
      

<!-- dtlbook2html START -->
<HR noshade>
<FONT SIZE="-1"><A HREF="index.html"><B>IRIX Admin: Backup, Security, and Accounting</B></A><P><A HREF="IA_BakSecAcc-7.html"><IMG SRC="images/b_prev.gif" ALT="Prev" WIDTH=17 HEIGHT=17 BORDER=0 ALIGN=TOP></A>&nbsp; <A HREF="IA_BakSecAcc-9.html"><IMG SRC="images/b_next.gif" ALT="Next" WIDTH=17 HEIGHT=17 BORDER=0 ALIGN=TOP></A>&nbsp;&nbsp;&nbsp;&nbsp;Table of Contents:&nbsp;&nbsp;<A HREF="index.html">Basic</A>&nbsp;&nbsp;|&nbsp;&nbsp;<A HREF="fulltoc.html">Expanded</A></P></FONT>
<!-- dtlbook2html END -->

<HR noshade>
</BODY>
</HTML>
