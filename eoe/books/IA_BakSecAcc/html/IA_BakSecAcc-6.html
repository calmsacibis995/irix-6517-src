<HTML>
<HEAD>
<TITLE>IRIX Admin: Backup, Security, and Accounting
</TITLE></HEAD>
<BODY BGCOLOR="#F9F9F9">
<!-- dtlbook2html START -->
<HR noshade>
<FONT SIZE="-1"><A HREF="index.html"><B>IRIX Admin: Backup, Security, and Accounting</B></A><P><A HREF="IA_BakSecAcc-5.html"><IMG SRC="images/b_prev.gif" ALT="Prev" WIDTH=17 HEIGHT=17 BORDER=0 ALIGN=TOP></A>&nbsp; <A HREF="IA_BakSecAcc-7.html"><IMG SRC="images/b_next.gif" ALT="Next" WIDTH=17 HEIGHT=17 BORDER=0 ALIGN=TOP></A>&nbsp;&nbsp;&nbsp;&nbsp;Table of Contents:&nbsp;&nbsp;<A HREF="index.html">Basic</A>&nbsp;&nbsp;|&nbsp;&nbsp;<A HREF="fulltoc.html">Expanded</A></P></FONT>
<!-- dtlbook2html END -->

<A NAME=X></A><A NAME="SGI1"></A>
<H1 class="SGITPL-head">PART ONE<BR>Backup</h1><p>Part I,<i> Backup</i>, contains the following chapters:<p><b></b><A HREF="IA_BakSecAcc-6.html#SGI2" TARGET=_top>Chapter 1</A><b><br></b>Planning a Backup Strategy    <p><b></b><A HREF="IA_BakSecAcc-6.html#SGI16" TARGET=_top>Chapter 2</A><b><br></b>Backup and Recovery Procedures    <p><b></b><A HREF="IA_BakSecAcc-6.html#SGI67" TARGET=_top>Chapter 3</A><b><br></b>Troubleshooting Backup and Recovery    <HR noshade><A NAME="SGI2"></A>
<H1 class="SGITPL-head">Chapter 1<BR> Planning a Backup Strategy</h1><p><b></b>As a site administrator, you must make sure there are backups of the files at your site. Users depend on you to recover files that have been accidentally erased, or lost due to hardware problems.<p>This chapter contains the following sections:<ul><li><A HREF="IA_BakSecAcc-6.html#SGI3" TARGET=_top>"Types of Backup Media"</A><br><br><li><A HREF="IA_BakSecAcc-6.html#SGI4" TARGET=_top>"IRIX Backup Tools"</A><br><br><li><A HREF="IA_BakSecAcc-6.html#SGI6" TARGET=_top>"Backup Strategies"</A></ul><p>When you are familiar with backup and have addressed the needs of your site, refer to <A HREF="IA_BakSecAcc-6.html#SGI16" TARGET=_top>Chapter 2</A> for detailed information on the backup utilities that you plan to use. <HR noshade><A NAME="SGI3"></A>
<h2 class="SGITPL-head">Types of Backup Media </h2><p>Some of the common types of backup media supported on Silicon Graphics, Inc., systems include:<ul><li>1/4" cartridge tape, 4-track<br><br><li>8 mm cartridge tape<br><br><li>4 mm DAT<br><br><li>DLT (digital linear tape)</ul><p>In addition to backup devices attached to any particular system, backup devices of various types and capacities may be accessible through network connections. Refer to your owner's guide for information on locally accessible devices, and the appropriate vendor documentation for network-accessible device information.<p>Certain limitations or conditions described in this chapter might not apply to your specific media. For example, if you back up a 350 MB filesystem with an 8 mm cartridge drive (which can hold up to 1.2 GB), using more than one tape is not a concern. (For more information on tape capacities, see <i></i>IRIX Admin: Peripheral Devices    <i></i>.)<p>Robotic media changers, also called autochangers or jukeboxes, have become popular recently. In sequential mode, they can be used with standard IRIX utilities, treating a series of tapes as one long tape. This helps increase aggregate capacity. However, taking full advantage of a media changer requires specialized software such as OpenVault, which enables random access to all volumes in a media library. For updated information, search for "OpenVault" on the Silicon Graphics Web site (<A HREF="http://www.sgi.com" __me__=605" TARGET="_blank"> <A HREF="http://www.sgi.com">http://www.sgi.com</A></A>
).<HR noshade><A NAME="SGI4"></A>
<h2 class="SGITPL-head">IRIX Backup Tools</h2><p>The IRIX system provides a variety of backup tools, and you should use whichever ones work best for you. If many users at your site are already familiar with one backup program, you may wish to use that program consistently. If there are workstations at your site from other manufacturers, you may wish to use a backup utility that is common to all the workstations.<p>IRIX provides the following utilities for backing up your data: <ul><li>System Manager, Backup & Restore<br><br><li>Backup(1) and Restore(1), which use <i>cpio</i><br><br><li>dump(1M) and restore(1M)<br><br><li>xfsdump(1M) and xfsrestore(1M) for XFS filesystems<br><br><li>cpio(1)<br><br><li>dd(1M)<br><br><li>tar(1)</ul><p>Optional products for Silicon Graphics systems are also available. IRIX NetWorker is a scalable, full-featured data management tool for data backup and recovery. You can use IRIX NetWorker to back up data on high-end servers, or centrally manage backups for all your network workstations and file servers. Refer to <A HREF="IA_BakSecAcc-6.html#SGI5" TARGET=_top>"IRIX NetWorker"</A> for more information.<p>Backup tools can be classified as filesystem-oriented (<i>Backup</i> and <i>dump) </i>or as file- and directory-oriented (<i>tar</i> and <i>cpio). </i>While backup tool are not limited to either orientation, they are most convenient when used this way. In addition, you can use the <i>dd</i> command to read images exactly as they are written, with or without conversions. You would not normally use <i>dd</i> to create backups, but <i>dd</i> can be useful to read data that is written in a format incompatible with the other backup utilities.<p><A HREF="IA_BakSecAcc-6.html#SGITF1" TARGET=_top>Table 1-1</A> summarizes the backup utilities available with IRIX.<TABLE BORDER CELLPADDING=10><p><A NAME="SGITF1"></A><CAPTION ALIGN=TOP><B>Table 1-1 :  </B>Backup Utilities Summary</CAPTION><TR VALIGN=TOP ALIGN=LEFT><TH>Utility</TH><TH>Summary Description</TH><TH>Reference</TH><TR ALIGN=LEFT VALIGN=TOP><TD><p>System Manager<br>Backup & Restore</TD><TD><p>Graphical interface to the <i>cpio</i> utility. 
Probably best and most convenient tool 
if you back up only your own system.</TD><TD><p><i></i>    <i></i><i>Personal System 
Administration Guide</i></TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p><i>Backup</i> and <i>Restore</i></TD><TD><p>A command line "front end" to the <i>cpio</i> 
utility.</TD><TD><p>Backup(1) and Restore(1) 
reference pages, and "Backup 
and Restore Utilities"    </TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p><i>dump</i> and <i>restore</i></TD><TD><p>Supports incremental backups and 
interactive restores. Standard UNIX 
backup utilities good in heterogeneous 
environments (but cannot back up XFS 
filesystems). </TD><TD><p>dump(1M) and restore(1M) 
reference pages and "About 
dump and restore"    </TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p><i>xfsdump</i> and <i>xfsrestore</i></TD><TD><p>Supports incremental backups, 
interactive restores, and interrupt 
recovery. Use instead of <i>dump</i> and <i>restore</i> 
on XFS filesystems.</TD><TD><p>xfsdump(1M) and 
xfsrestore(1M) reference 
pages, and "About xfsdump 
and xfsrestore"    </TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p><i>tar</i></TD><TD><p>Most common UNIX backup utility 
historically and in current distribution, 
making it portable and thus widely used 
in very heterogeneous computer 
environments. </TD><TD><p>tar(1) reference page and 
<A HREF="IA_BakSecAcc-6.html#SGI53" TARGET=_top>"About tar"</A></TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p><i>cpio</i></TD><TD><p>Flexible and standard UNIX command 
generally combined in command line 
pipes with other commands.</TD><TD><p>cpio(1) reference page and 
<A HREF="IA_BakSecAcc-6.html#SGI60" TARGET=_top>"About cpio"</A></TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p><i>dd</i></TD><TD><p>Standard UNIX command to read input 
and write output with optional 
conversions.</TD><TD><p>dd(1M) reference page and 
<A HREF="IA_BakSecAcc-6.html#SGI66" TARGET=_top>"About dd"</A></TD></TR></TABLE> <br><br><A NAME="SGI5"></A>
<h3 class="SGITPL-head">IRIX NetWorker</h3><p>IRIX NetWorker, an extra-cost option, provides backup and archive storage management services for networks of heterogeneous systems. It completely and reliably protects all network data, including extended file attributes such as security information, user profiles, and access control lists. <p>Use IRIX NetWorker to back up data on Silicon Graphics servers, or use their enormous I/O capabilities to centrally manage backups for all your network workstations and file servers. NetWorker provides network backup support for all major UNIX systems, plus PC, NetWare, and Macintosh systems. IRIX NetWorker provides the following:<ul><li>With its graphical user interface, NetWorker is easy to use and administer. The administrator interface provides a uniform view of data management operations from any network node.<br><br><li>With optional support for a wide range of robotic autochangers, NetWorker provides fully unattended backup and automated tape management. Bar code support for autochangers dramatically reduces the need for operator intervention and time for media inventory.<br><br><li>A save set cloning feature creates and tracks multiple copies of backup data for redundancy and security.<br><br><li>Parallel backup and recovery allow multiple data streams to be written to and read from media simultaneously. Concurrent device support permits simultaneous data streams to and from multiple storage devices. Data compression reduces backup time and network traffic.<br><br><li>A client/server architecture allows easy integration of new systems and advanced data management applications, such as Archive and Hierarchial Storage Management (HSM).<br><br><li>An intuitive on-screen index browser and scheduler provide desktop users with the ability to initiate recovery and backup quickly and easily, saving administrator time.</ul><p>See your Silicon Graphics sales representative for complete information on optional backup solutions.<HR noshade><A NAME="SGI6"></A>
<h2 class="SGITPL-head">Backup Strategies</h2><p>You should develop a regimen for backing up the system or systems at your site and follow it closely. That way, you can accurately assess which data you can and cannot recover in the event of a mishap.<p>Exactly how you perform backups depends upon your workstation configuration and other factors. Regardless of the strategy you choose, though, you should always keep at least two full sets of reasonably current backups. You should also encourage users to make their own backups, particularly of critical, rapidly changing files. Users' needs can change overnight, and they know best the value of their data.<p>Workstation users can back up important files using the System Manager, found in the "System" toolchest on your screen. The System Manager is described in detail in the <i></i>Personal System Administration Guide    <i></i>. Make sure users have access to an adequate supply of media (for example, cartridge tapes), whether new or used.<p>If your media can handle your largest filesystem with a single volume, you don't have to use an incremental backup scheme, though such a system reduces the amount of time you spend making backups. However, if you must regularly use multiple volumes to back up your filesystems, then an incremental backup system reduces the number of tapes you use.<p>The following sections discuss the different aspects of backing up data.<A NAME="SGI7"></A>
<h3 class="SGITPL-head">When to Back Up Data and What to Back Up</h3><p>How often you back up your data depends upon how busy a system is and how critical the data is.<p>A simple rule of thumb is to back up any data on the system that is irreplaceable or that someone does not want to reenter.<A NAME="SGI8"></A>
<h4 class="SGITPL-head">Root Filesystem Backup</h4><p>On systems with separate root and user filesystems, the root filesystem is fairly static. You do not need to back it up as frequently as the <i>/usr</i> filesystem.<p>Changes may occur when you add software, reconfigure hardware, change the site-networking (and the system is a server or network information service [NIS] master workstation), or change some aspect of the workstation configuration. In some cases, you can maintain backups only of the individual files that change, for example, <i>/unix</i>, <i>/etc/passwd</i>, and so forth.<p>This process of backing up single files is not always simple. Even a minor system change such as adding a user affects files all over the system, and if you use the graphical System Manager, you may tend to forget all the files that may have changed. Also, if you are not the only administrator at the site, you may not be aware of changes made by your coworkers. Using complete filesystem backup utilities, such as the System Manager or <i>Backup</i>, on a regular schedule avoids these problems.<p>A reasonable approach is to back up the root partition once a month. In addition to regular backups, here are some specific times to back up a root filesystem:<ul><li>whenever you add users to the system, especially if the workstation is an NIS master workstation <br><br><li>just before installing new software <br><br><li>after installing new software and when you are certain the software is working properly</ul><p>If your system is very active, or if you are not the only administrator, back up the root filesystem regularly.<A NAME="SGI9"></A>
<h4 class="SGITPL-head">User Filesystem Backup</h4><p>The <i>/usr</i> filesystem <A NAME="SGITF5">    <IMG SRC="images/footnote.gif" WIDTH=25 HEIGHT=15 ALT="footnote" BORDER=0 ALIGN=absmiddle></A>
, which often contains both system programs (such as in <i>/usr/bin</i>) and user accounts, is usually more active than a root filesystem. Therefore, you should back it up more frequently.<p>At a typical multiuser installation, backing up once per day, using an incremental scheme, should be sufficient.<p>Treat the<i> /var</i> filesystem similarly   -       it contains data such as the contents of users' mailboxes.<A NAME="SGI10"></A>
<h3 class="SGITPL-head">Incremental Backup Schedule</h3><p>Incremental backups can use fewer tapes to provide the same level of protection as repeatedly backing up the entire filesystem. They are also faster than backing up every file on the system.<p>An incremental scheme for a particular filesystem looks something like this:<ol><li>On the first day, back up the entire filesystem. This is a monthly backup.<br><br><li>On the second through seventh days, back up only the files that changed from the previous day. These are daily backups.<br><br><li>On the eighth day, back up all the files that changed the previous week. This is a weekly backup. <br><br><li>Repeat steps 2 and 3 for four weeks (about one month). <br><br><li>After four weeks (about a month), start over, repeating steps 1 through 4.</ol><p>You can recycle daily tapes every month, or whenever you feel safe about doing so. You can keep the weekly tapes for a few months. You should keep the monthly tapes for about one year before recycling them.<A NAME="SGI11"></A>
<h3 class="SGITPL-head">File Backup Across a Network</h3><p>If you are managing a site with many networked workstations, you may wish to save backups on a device located on a central workstation.<p>To back up across a network, use the same basic backup commands, but with a slight change. Enter:<pre><var>system_name</var><B>:/dev/tape</B> </pre><p>If required, specify an account on the remote device:<pre><var>user</var><B>@</B><var>system_name</var><B>:/dev/tape</B> </pre><p>Users can use a central tape drive from their workstations with this method. Note that if you are backing up to a remote tape drive on a workstation that is not made by Silicon Graphics, the device name <i>/dev/tape</i> may not be the correct name for the tape drive. Always learn the pathname of the tape device before executing the backup commands.<p>For example:<pre><B>tar cvf guest@alice:/dev/tape ./bus.schedule</B> </pre><p>or<pre><B>echo "./bus.schedule" | cpio -ovcO guest@alice:/dev/tape</B></pre><A NAME="SGI12"></A>
<h3 class="SGITPL-head">Automatic Backups with cron</h3><p>You can use the <i>cron</i> utility to automatically back up filesystems at predetermined times. The backup media must be already mounted in the drive, and, if you want this to be truly automatic, it should have enough capacity to store all the data being backed up on a single piece of media. If all the data doesn't fit, then someone must manually change backup media.<p>Here is an example <i>cron</i> command to back up the <i>/usr/src</i> hierarchy to <i>/dev/tape</i> (tape drive) every morning at 03:00 using <i>Backup</i>:<pre><B>0 3 * * * /usr/sbin/Backup -t /dev/tape /usr/src</B> </pre><p>Place this line in a <i>crontabs</i> file, such as <i>/var/spool/cron/crontabs/root</i>.<p>This sort of command is useful as a safety net, but you should not rely on automatic backups. There is no substitute for having a person monitor the backup process from start to finish and properly archive and label the media when the backup is finished. For more information on using <i>cron</i> to perform jobs automatically, see <i></i>IRIX Admin: System Configuration and Operation    <i></i>.<A NAME="SGI13"></A>
<h3 class="SGITPL-head">Storage of Backups</h3><p>Store your backup tapes carefully. Even if you create backups on more durable media, such as optical disks, take care not to abuse them. Set the write protect switch on tapes you plan to store as soon as a tape is written, but remember to unset it when you are ready to overwrite a previously-used tape.<p>Do not subject backups to extremes of temperature and humidity, and keep tapes away from strong electromagnetic fields. If there are a large number of workstations at your site, you may wish to devote a special room to storing backups.<p>Store magnetic tapes, including 1/4 in. and 8 mm cartridges, upright. Do not store tapes on their sides, as this can deform the tape material and cause the tapes to read incorrectly.<p>Make sure the media is clearly labeled and, if applicable, write-protected. Choose a label-color scheme to identify such aspects of the backup as what system it is from, what level of backup (complete versus partial), what filesystem, and so forth.<p>To minimize the impact of a disaster at your site, such as a fire, you may want to store main copies of backups in a different building from the actual workstations. You have to balance this practice, though, with the need to have backups handy for recovering files.<p>If backups contain sensitive data, take the appropriate security precautions, such as placing them in a locked, secure room. Anyone can read a backup tape on a system that has the appropriate utilities. <A NAME="SGI14"></A>
<h3 class="SGITPL-head">How Long to Keep Backups</h3><p>You can keep backups as long as you think you need to. In practice, few sites keep system backup tapes longer than about a year before recycling the tape for new backups. Usually, data for specific purposes and projects is backed up at specific project milestones (for example, when a project is started or finished).<p>As site administrator, you should consult with your users to determine how long to keep filesystem backups.<p>With magnetic tapes, however, there are certain physical limitations. Tape gradually loses its flux (magnetism) over time. After about two years, tape can start to lose data.<p>For long-term storage, re-copy magnetic tapes every year to year-and-a-half to prevent data loss through deterioration. When possible, use checksum programs, such as the sum(1) utility, to make sure data hasn't deteriorated or altered in the copying process. If you want to reliably store data for several years, consider using optical disk.<A NAME="SGI15"></A>
<h3 class="SGITPL-head">Guidelines for Tape Reuse</h3><p>You can reuse tapes, but with wear, the quality of a tape degrades. The more important the data, the more precautions you should take, including using new tapes.<p>If a tape goes bad, mark it as "bad" and discard it. Write "bad" on the tape case before you throw it out so that someone doesn't accidentally try to use it. Never try to reuse an obviously bad tape. The cost of a new tape is minimal compared to the value of the data you are storing on it. <HR noshade><A NAME="SGI16"></A>
<H1 class="SGITPL-head">Chapter 2<BR> Backup and Recovery Procedures</h1><p>This chapter provides examples of how to use the various backup and recover tools described in <A HREF="IA_BakSecAcc-6.html#SGI2" TARGET=_top>Chapter 1</A>.<p>All of the utilities discussed in this chapter support more options than can be shown here, but the examples combined with the discussions in <A HREF="IA_BakSecAcc-6.html#SGI2" TARGET=_top>Chapter 1</A> should provide enough information for you to choose and begin to use the tools best suited for your environment.<p>For a complete description of the options available with a particular tool, refer to the reference page for that tool (for example, see tar(1) for the <i>tar</i> command).<p>This chapter is divided into the following sections:<ul><li><A HREF="IA_BakSecAcc-6.html#SGI17" TARGET=_top>"General Backup Procedure"</A><br><br><li><A HREF="IA_BakSecAcc-6.html#SGI19" TARGET=_top>"Recovering Data After System Corruption"</A><br><br><li><A HREF="IA_BakSecAcc-6.html#SGI20" TARGET=_top>"Changing the Default Backup Device"</A><br><br><li><A HREF="IA_BakSecAcc-6.html#SGI21" TARGET=_top>"Saving Files Using Data Compression"</A><br><br><li><A HREF="IA_BakSecAcc-6.html#SGI22" TARGET=_top>"Backup and Restore Utilities"</A><br><br><li><A HREF="IA_BakSecAcc-6.html#SGI25" TARGET=_top>"About dump and restore"</A><br><br><li><A HREF="IA_BakSecAcc-6.html#SGI30" TARGET=_top>"About xfsdump and xfsrestore"</A><br><br><li><A HREF="IA_BakSecAcc-6.html#SGI53" TARGET=_top>"About tar"</A><br><br><li><A HREF="IA_BakSecAcc-6.html#SGI60" TARGET=_top>"About cpio"</A><br><br><li><A HREF="IA_BakSecAcc-6.html#SGI66" TARGET=_top>"About dd"</A></ul><HR noshade><A NAME="SGI17"></A>
<h2 class="SGITPL-head">General Backup Procedure</h2><p>Follow these steps when making a backup, no matter which backup utility you use: <ol><li>Make sure the tape drive is clean. The hardware manual that came with your drive should state how, and how often, to clean the drive.<p>Dirty tape heads can cause read and write errors. New tapes shed more oxide than older tapes, so you should clean your drive more frequently if you use a lot of new tapes. <br><br><li>Make sure you have enough backup media on hand. You can use utilities such as du(1M) and df(1) to determine the size of directories and filesystems, respectively. <p>Also, use good-quality media. Considering the value of your data, use the best quality media you can afford. <br><br><li>Run fsck(1M) first on EFS filesystems (if you are backing up an entire filesystem) to make sure you do not create a tape of a damaged filesystem. You must unmount a filesystem before checking it with <i>fsck</i>, so plan your backup schedule accordingly.<p>This step is not necessary if you are backing up only a few files (for example, with <i>tar</i>). <br><br><li>The default tape device for any drives you may have is <i>/dev/tape</i>. If you do not use the default device, you must specify a device in your backup command line.<br><br><li>Label your backups. If you plan to reuse the media, use pencil. Include the date, time, name of the system, the name of the utility, the exact command line used to make the backup (so you'll remember how to extract the files later), and a general indication of the contents. If more than one administrator performs backups at your site, include your name.<br><br><li>Verify the backup when you are finished. Some utilities provide explicit options (such as <i>xfsdump -C</i>) to verify a backup. With other programs, you can simply list the contents of the archive   -       this is usually sufficient to catch errors in the backup.<br><br><li>Write-protect your media after you make the backup.<br><br><li>Note the number of times you use each tape. It's sufficient to keep a running tally on the tape label.</ol><p>See <A HREF="IA_BakSecAcc-6.html#SGI13" TARGET=_top>"Storage of Backups"</A> for information on safely storing your backups.<A NAME="SGI18"></A>
<h3 class="SGITPL-head">System Backup Tools</h3><p>To make a backup of your system on any system with a graphical user interface, bring up the System menu on the System Toolchest and choose Backup & Restore. Follow the prompts to perform your backup. A complete set of instructions for this procedure is available in the <i></i>Personal System Administration Guide    <i></i>. <p>Backups made with the Backup & Restore window are the easiest to make and use, and (if they are full system backups) are accessible from the Recover System option on the System Maintenance Menu. When you make a full system backup, the command also makes a backup of the files in the disk volume header and saves the information in a file that is stored on tape. This file is used during system recovery to restore a damaged volume header.<p>To make a backup of your system using an IRIX command, use the Backup(1) command. Although it is a front-end interface to the cpio(1) command, <i>Backup</i> also writes the disk volume header on the tape so that the Recover System option can reconstruct the boot blocks, which are not written to the tape using other backup commands. For more information, see the section <A HREF="IA_BakSecAcc-6.html#SGI22" TARGET=_top>"Backup and Restore Utilities"</A>.<HR noshade><A NAME="SGI19"></A>
<h2 class="SGITPL-head">Recovering Data After System Corruption</h2><p>If your root filesystem is damaged and your system cannot boot, you can restore your system from the Recover System option on the System Maintenance Menu. This is the menu that appears when you interrupt the boot sequence before the operating system takes over the system. To perform this recovery, you need two things:<ul><li>Access to a CD that contains the IRIX release on your system.<br><br><li>A full system backup tape (beginning in the root directory (/) and containing all the files and directories on your system) created using the Backup and Restore Manager as described in the section <A HREF="IA_BakSecAcc-6.html#SGI18" TARGET=_top>"System Backup Tools"</A>.</ul><p>If you do not have a full system backup made with the <i>Backup</i> command or Backup and Restore window   -       and your <i>root</i> or <i>usr</i> filesystems are so badly damaged that the operating system cannot boot   -       you have to reinstall your system software and then read your backup tapes (made with any backup tool you prefer) over the freshly installed software. <p>You may also be able to restore filesystems from the miniroot. For example, if your root filesystem has been corrupted, you may be able to boot the miniroot, unmount the root filesystem, and then use the miniroot versions of <i>restore</i>, <i>xfs_restore</i>, <i>Restore</i>, <i>cpio</i>, or <i>tar</i> to restore your root filesystem. Refer to the following discussions of these commands for details on how to use them.<p>To recover from system corruption using the Recover System option on the System Maintenance Menu, follow these steps:<ol><li>When you first start up your machine or press the Reset button on the system, this message appears:<PRE>Starting up the system...</PRE><p>Click the <i>Stop for Maintenance</i> button or press <TT><B>Esc</B></TT> to bring up the System Maintenance menu.<br><br><li>Click the Recover System icon in the System Maintenance menu, or type:<p><TT><B>4</B></TT><p>This System Recovery menu appears or you see a graphical equivalent:<PRE>                         System Recovery...

                 Press Esc to return to the menu.

1) Remote Tape  2) Remote Directory  3) Local CD-ROM  4) Local Tape  

Enter 1-4 to select source type, Esc to quit,
or Enter to start: </PRE><li>Enter the menu item number or click the appropriate drive icon for the IRIX release CD or software distribution directory you plan to use.<P><B>Note: </B>As of IRIX 6.2, the Remote Tape and Local Tape options on the System Recovery window are no longer usable because bootable (miniroot) software distribution tapes are no longer supported.<ul><br><li>If you have a CD-ROM drive connected to your system, enter <TT><B>3</B></TT> or click the <i>Local CD-ROM</i> icon, then click <i>Accept</i> to start.<p>You then see a notifier prompting you to insert the media into the drive. Insert the IRIX CD that came with your system, then click <i>Continue</i>.<br><br><li>If you don't have a CD-ROM drive, you can use a drive that is connected to another system on the network. At the System Recovery menu, enter <TT><B>2</B></TT> or click the <i>Remote Directory</i> icon. <p>When a notifier appears asking you for the remote hostname, type the system's name, a colon (<TT><B>:</B></TT>), and the full pathname of the CD-ROM drive, followed by <TT><B>/dist</B></TT>. For example, to access a CD-ROM drive on the system <i>mars</i>, you would type:<B>mars:/CDROM/dist</B> <p>Click <i>Accept</i> on the notifier window, then click <i>Accept</i> on the System Recovery window.<p>On systems without graphics, you are prompted for the host as above, then you see this menu:1) Remote Tape 2)[Remote Directory] 3) Local CD-ROM 4) Local Tape  
      *a) Remote directory /CDROM/dist from server mars.

Enter 1-4 to select source type, a to select source, Esc to quit,
or Enter to start: <p>Press <TT><B>Enter</B></TT>.<br><br><li>If you are using a remote software distribution directory, enter <TT><B>2</B></TT> or click the <i>Remote Directory</i> icon.<p>When a notifier appears that asks you to enter the name of the remote host, type the system's name, a colon (<TT><B>:</B></TT>), and the full pathname of the software distribution directory. For example:<B>mars:/dist/6.2</B> <p>Click <i>Accept</i> on the notifier window, then click <i>Accept</i> on the System Recovery window.<p>On systems without graphics, you are prompted for the host as above, then you see this menu:1) Remote Tape 2)[Remote Directory] 3) Local CD-ROM 4) Local Tape  
      *a) Remote directory /dist/6.2 from server mars.

Enter 1-4 to select source type, a to select source, Esc to quit,
or Enter to start: <p>Press <TT><B>Enter</B></TT>.</ul><br><li> The system begins reading recovery and installation from the CD. It takes approximately five minutes to copy the information that it needs. After everything is copied from the CD or remote directory to the system disk you see messages including:<PRE>************************************************************
*                                                          *
*                    CRASH    RECOVERY                     *
*                                                          *
************************************************************
You may type  sh  to get a shell prompt at most questions
Checking for tape devices</PRE><p>The next message asks for the location of the tape drive that you will use to read a system backup tape created before the system crash using the Backup & Restore tool or using the Backup(1) command.<br><br><li>If you have a local tape device, you see this message:<pre>Restore will be from tapename. OK? ([y]es, [n]o): [y]</pre><p><i>tapename</i> is the name of the local tape device. Answer <TT><B>y</B></TT> if this is the correct tape drive and <TT><B>n</B></TT> if is not. <br><br><li>If you have a remote (network) tape device, no tape device was found, or you answered "no" to the question in the previous step, you see this message:<pre>Remote or local restore ([r]emote, [l]ocal): [l]</pre><ul><br><li>If you answer "remote," you have chosen to restore from the network, and you are then asked to enter the following information: the hostname of the remote system, the name of the tape device on the remote system, the IP address of the remote system, and the IP address of your system. The IP address must consist of two to four numbers, separated by periods, such as 192.0.2.1<br><br><li>If you answer "local," you have chosen a tape device that is connected to your system, and you are then asked to enter the name of the tape device.</ul><br><li>When you see the following message, insert your most recent full backup tape, then press <TT><B>Enter</B></TT>.<p><TT>Insert the first Backup tape in the drive, then <br>press (Enter, [q]uit (from recovery), [r]estart):</TT><br><br><li>There is a pause while the program identifies the filesystems on the tape and attempts to mount those filesystems under <i>/root</i>. Then you see this message:<p><TT>Erase all old filesystems and make new ones (y, n, sh): [n]</TT><p>You have three choices:<ul><br><li>Answer <TT><B>n</B></TT> for no. After additional prompts confirming the filesystems to be read, the files on the tape are extracted. The version of each file on the tape replaces the version, if any, on the disk even if the version on the disk is newer.<br><br><li>Answer <TT><B>y</B></TT> for yes. After additional confirming prompts and prompts about filesystem types, the system erases all of the filesystems and copies everything from your backup tape to the disk.<br><br><li>Answer <TT><B>sh</B></TT> to escape to a shell. You are now in the miniroot environment and can investigate the damage to the system or attempt to save files that have been created or modified since the backup tape was created. After exiting the shell, you have the opportunity to remake filesystems and/or read the backup tape.</ul><br><li>After reading the full backup tape, this prompt gives you the opportunity to read incremental backup tapes:<PRE>Do you have incremental backup tapes to restore ([y]es, [n]o (none)): [n] </PRE><p>Insert another tape and answer <TT><B>y</B></TT> if you have additional tape, answer <TT><B>n</B></TT> otherwise.<br><br><li>This prompt gives you the opportunity to reboot your system if recovery is complete, begin the crash recovery process again at the beginning, or re-read your first backup tape:<PRE>Reboot, start over, or first tape again? ([r]eboot, [s]tart, [f]irst) [r] </PRE><p>If you are ready to reboot, answer <TT><B>r</B></TT>, otherwise choose <TT><B>start</B></TT> or <TT><B>first</B></TT>.</ol><HR noshade><A NAME="SGI20"></A>
<h2 class="SGITPL-head">Changing the Default Backup Device</h2><p>At some point in the life of your workstation, you may choose to add a new storage media device. If you wish to change the default backup device to use your new hardware, the following instructions provide complete information. You can also use the graphical System Manager; it is the preferred tool for this operation and is described completely in the <i></i>Personal System Administration Guide    <i></i>. Note, however, that no matter which method you use to select your preferred device, installing new system software or using the MAKEDEV(1M) command may reset the default Backup device. For more information on adding a storage media device, see <i></i>IRIX Admin: Peripheral Devices    <i></i>.<p>The method of changing the system default tape device is to relink both <i>/dev/tape</i> and <i>/dev/nrtape</i> to the desired device. Use the following procedure:<ol><li>Enter the commands:<PRE><B>ls -l /dev/tape</B> 
lrwxr-xr-x    1 root    sys       10 Sep 30 11:23 tape -> rmt/tps0d5
<B>ls -l /dev/rmt/tps0d5</B> 
crw-rw-rw-    1 root    sys   0,1416 Jan 29 18:21 /dev/rmt/tps0d5</PRE><p>Since <i>rmt</i> is a symbolic link to <i>/hw/tape</i>, <i>/dev/tape</i> actually refers to <i>/hw/tape/tps0d5</i>.<br><br><li>Examine the device numbers of all tape devices by entering the command:<pre><B>ls -l /hw/tape</B></pre><p>You see something similar to this:<PRE>crw-rw-rw-    1 root    sys    0,1416 Jan 29 18:14 tps0d5
crw-rw-rw-    1 root    sys    0,1424 Jan 29 18:14 tps0d5c
crw-rw-rw-    1 root    sys    0,1417 Jan 29 18:14 tps0d5nr
crw-rw-rw-    1 root    sys    0,1425 Jan 29 18:14 tps0d5nrc
crw-rw-rw-    1 root    sys    0,1417 Jan 29 18:14 tps0d5nrns
crw-rw-rw-    1 root    sys    0,1425 Jan 29 18:14 tps0d5nrnsc
crw-rw-rw-    1 root    sys    0,1421 Jan 29 18:14 tps0d5nrnsv
crw-rw-rw-    1 root    sys    0,1429 Jan 29 18:14 tps0d5nrnsvc
crw-rw-rw-    1 root    sys    0,1419 Jan 29 18:14 tps0d5nrs
crw-rw-rw-    1 root    sys    0,1427 Jan 29 18:14 tps0d5nrsc
crw-rw-rw-    1 root    sys    0,1423 Jan 29 18:14 tps0d5nrsv
crw-rw-rw-    1 root    sys    0,1431 Jan 29 18:14 tps0d5nrsvc
crw-rw-rw-    1 root    sys    0,1421 Jan 29 18:14 tps0d5nrv
crw-rw-rw-    1 root    sys    0,1429 Jan 29 18:14 tps0d5nrvc
crw-rw-rw-    1 root    sys    0,1416 Jan 29 18:14 tps0d5ns
crw-rw-rw-    1 root    sys    0,1424 Jan 29 18:14 tps0d5nsc
crw-rw-rw-    1 root    sys    0,1420 Jan 29 18:14 tps0d5nsv
crw-rw-rw-    1 root    sys    0,1428 Jan 29 18:14 tps0d5nsvc
crw-rw-rw-    1 root    sys    0,1418 Jan 29 18:14 tps0d5s
crw-rw-rw-    1 root    sys    0,1426 Jan 29 18:14 tps0d5sc
crw-rw-rw-    1 root    sys    0,1399 Jan 29 12:08 tps0d5stat
crw-rw-rw-    1 root    sys    0,1422 Jan 29 18:14 tps0d5sv
crw-rw-rw-    1 root    sys    0,1430 Jan 29 18:14 tps0d5svc
crw-rw-rw-    1 root    sys    0,1420 Jan 29 18:14 tps0d5v
crw-rw-rw-    1 root    sys    0,1428 Jan 29 18:14 tps0d5vc</PRE><p>The device at the top of this listing is the current <i>/dev/tape</i>, although <i>tps0d5ns</i> is the same device. The "c" suffix indicates compression, "nr" indicates no-rewind, "ns" indicates non-swapping, "s" byte swapping, and "v" variable block size.<br><br><li>Remove the <i>/dev/tape</i> link and create the new link to a new name. For example, to make variable block size the default, use the following commands:<PRE><B>rm /dev/tape</B> 
<B>ln -s rmt/tps0d5v /dev/tape</B> 
<B>rm /dev/nrtape</B> 
<B>ln -s rmt/tps0d5nrv /dev/nrtape</B> </PRE></ol><p>Most programs use <i>/dev/tape</i> or <i>/dev/nrtape</i> as the default tape device. If a program does not seem to be working correctly, first ensure that it is using the correct tape device.<HR noshade><A NAME="SGI21"></A>
<h2 class="SGITPL-head">Saving Files Using Data Compression</h2><p>For tape drives that perform hardware compression, such as DLT, the IRIX tape interface provides the option letter "c" to indicate a compression device. For example, to save files using hardware compression, make <i>/dev/tape</i> and <i>/dev/nrtape</i> links to the devices ending with a "c" in <i>/dev/rmt</i>:<PRE><B>ln -s rmt/tps0d5vc /dev/tape</B> 
<B>ln -s rmt/tps0d5nrvc /dev/nrtape</B> </PRE><p>It is also possible to compress data using software before saving to tape; see compress(1) and pack(1) for two possible choices.<HR noshade><A NAME="SGI22"></A>
<h2 class="SGITPL-head">Backup and Restore Utilities</h2><p>The <i>Backup</i> and <i>Restore</i> utilities are front-end interfaces to <i>cpio</i>. They support remote hostname and tape device options, and <i>Backup</i> creates a volume header file listing that <i>Restore</i> uses for recovering the files and directories. For complete information, consult the Backup(1) and Restore(1) reference pages. <p>If you are planning to use the System Maintenance menu <i>Recovery</i> option, use <var>Backup</var> or the backup facility of the graphical System Manager, as those are the only formats accepted by the System Maintenance Menu. The System Manager is described in detail in the <i></i>Personal System Administration Guide    <i></i>.<A NAME="SGI23"></A>
<h3 class="SGITPL-head">Saving Data with Backup</h3><p>Before you begin backup, use the <i>df</i> command to estimate how much space is required for a complete archive. This command, for example, shows the number of KB required to back up the <i>root</i> partition:<pre><B>df -k /</B> </pre><p>With <i>Backup</i>, you can back up files, directories, whole filesystems, and full systems on local or remote devices. Full system backups include the ability to recover a damaged volume header and also to back up only those files modified since a previous backup. The syntax for the <i>Backup</i> command is:<p><TT><B>Backup </B></TT><var>[</var><TT><B>-h</B></TT><var> hostname] [</var><TT><B>-t</B></TT><var> device] [</var><TT><B>-i</B></TT><var>] directory_name | filename</var><p>To back up an entire disk to the default tape device, enter:<p><TT><B>Backup /</B></TT><p>This <i>Backup</i> command archives the entire system. The current date is saved in the file <i>/etc/lastbackup</i>.<P><B>Note: </B>In order to use a <i>Backup</i> tape to restore your system from the System Maintenance Menu, you must make a full system backup. When you make a full system backup, the command also makes a backup of the names of the files in the disk volume header and saves the information in a file that is stored on tape. This file is used during system recovery to restore a damaged volume header.<p>You can make a backup relative to the last full system backup by entering:<pre><B>Backup -i /</B></pre><p>To back up a specific directory and its subdirectories, enter the top-level directory name. For example, to back up the <i>usr</i> hierarchy, enter the following:<pre><B>Backup /usr</B></pre><p>To use a remote tape drive, use the -h <var>hostname</var> option:<pre><B>Backup -h guest@alice.cbs.tv.com:/dev/tape /usr/people/ralph</B> </pre><p>This would back up the directory <i>/usr/people/ralph</i> on the <i>/dev/tape</i> device on the host alice.cbs.tv.com. You must have at least <i>guest</i> login privileges on the remote system in order to use a remote tape drive. <p>To back up a file, enter the filename. For example:<pre><B>Backup people.tar.Z</B></pre><p>Files (and directories) are stored relative to the current directory if the backup is made with a relative pathname as shown in this example. Relative pathnames are those that do not begin with a slash (/) character. Pathnames that begin with a slash are known as <i>absolute</i> pathnames. For example, <i>/usr/bin/vi</i> is an absolute pathname. The leading slash indicates that the pathname begins at the root directory of the system. In contrast, <i>work/special.project/chapter1</i> is a relative pathname since the lack of a leading slash indicates that the path begins with a directory name in the current directory.<A NAME="SGI24"></A>
<h3 class="SGITPL-head">Restoring Data with Restore</h3><p>The <i>Restore</i> command is a shell script that uses <i>tar </i>to extract files from a backup (see <A HREF="IA_BakSecAcc-6.html#SGI53" TARGET=_top>"About tar"</A>). You can also use <i>Restore</i> to read tapes made using the graphical System Manager (see the <i></i>Personal System Administration Guide    <i></i>).<p>You can recover multivolume backups with <i>Restore</i>. Enter:<pre><B>Restore</B> </pre><p>and you are prompted to insert the tape into the drive. <p>To extract a single file, use this command:<pre><B>Restore </B><var>file1</var> </pre><p>With the -h option, you can specify the tape drive on a different host workstation. You must have guest login privileges in order to extract data from a remote drive.<pre><B>Restore -h guest@alice.cbs.tv.com </B><var>file1</var> </pre><p>Files are restored into the current directory if the backup was made with relative pathnames. Relative pathnames are those that do not begin with a slash (/) character. Pathnames that begin with a slash are known as <i>absolute</i> pathnames. For example, <i>/usr/bin/vi</i> is an absolute pathname. The leading slash indicates that the pathname begins at the root directory of the system. In contrast, <i>work/special.project/chapter1</i> is a relative pathname since the lack of a leading slash indicates that the path begins with a directory name in the current directory. <p>Existing files of the same pathname on the disk are overwritten during a restore operation even if they are more recent than the files on tape. You must be especially careful, then, if you are restoring files with absolute pathnames, because regardless of your current working directory, the file is restored where the pathname indicates.<p>For example, if the file you are restoring was backed up as <i>/etc/passwd </i>and you are in the directory <i>/tmp</i>, the file you restore overwrites the <i>/etc/passwd</i> file. If the file you are restoring was backed-up as <i>passwd</i>, then restore the <i>passwd</i> file into <i>/tmp</i>.<HR noshade><A NAME="SGI25"></A>
<h2 class="SGITPL-head">About dump and restore</h2><p>The <i>dump</i> and <i>restore</i> programs are standard filesystem backup utilities used on many UNIX systems. These commands are only used with EFS filesystems. Refer to <A HREF="IA_BakSecAcc-6.html#SGI30" TARGET=_top>"About xfsdump and xfsrestore"</A> to dump and restore XFS filesystems. The <i>dump</i> program makes incremental backups of entire filesystems.<p>Use <i>restore</i> to retrieve files from a <i>dump</i> archive. With <i>restore</i>, you can restore an entire filesystem or specific files. It also has an interactive mode that lets you browse the contents of an archive, select specific files, and restore them.<A NAME="SGI26"></A>
<h3 class="SGITPL-head">Backing Up a Filesystem with dump </h3><p>The <i>dump</i> utility archives not only regular files, but also device files and special files such as links and named pipes. To recover files from an archive, you use the <i>restore</i> command. The date on which you last ran the <i>dump</i> program is stored in the file <i>/etc/dumpdates</i> when you specify the u option to indicate an update.<p>This command backs up all files on the <i>/usr</i> filesystem:<pre><B>dump 0 /dev/usr</B> </pre><P><B>Note: </B>The 0 in the example specifies the increment level. Refer to the next section for an explanation of level numbers.<A NAME="SGI27"></A>
<h3 class="SGITPL-head">Performing Incremental Backups</h3><p>The <i>dump</i> utility is designed for incremental backups, and it archives not only regular files and directories, but also special files, links, and pipes.<p>To create an incremental backup, specify an increment number when you use <i>dump</i>. The <i>dump</i> program archives all files (including special files, links, and named pipes) that have changed since the last appropriate increment. To recover files from an archive, use the <i>restore</i> command.<p>The <i>dump</i> program is designed specifically to create incremental backups. It refers to the increments as <i>levels</i>, and each level is assigned a number:<ul><li>A level 0 backup archives all files in a filesystem.<br><br><li>Backup levels 1­9 archive all files that have changed since the previous backup of the same or lesser level.</ul><p>For example, this command backs up all files on the <i>/usr</i> filesystem:<pre><B>dump 0 /dev/usr</B> </pre><p>This command backs up those files that have changed since the previous level 0 dump:<pre><B>dump 1 /dev/usr</B> </pre><p>This command archives those files that have changed since the previous level 1 dump:<pre><B>dump 2 /dev/usr</B> </pre><p>If the next <i>dump</i> command you give specifies level 1, the <i>dump</i> utility backs up the files that have changed since the last level 0, but not those that have changed since the last level 2. This numbering system gives you enormous flexibility so you can create a backup schedule to fit your specific needs.<A NAME="SGI28"></A>
<h3 class="SGITPL-head">Recovering a Filesystem with restore </h3><p>Use <i>restore</i> to recover files and filesystems made with the <i>dump</i> program. There are two ways to use <i>restore</i>: interactively and non-interactively.<p>Use the interactive option to recover moderate numbers of files from a <i>dump</i> archive. With the interactive feature of <i>restore</i>, you can browse the contents of a tape to locate and extract specific files.<p>Use the non-interactive mode to recover an entire backup. For example, place the backup in the drive and enter:<pre><B>restore -x</B> </pre><p>If your <b>root</b> filesystem is damaged and needs to be completely restored, see <A HREF="IA_BakSecAcc-6.html#SGI19" TARGET=_top>"Recovering Data After System Corruption"</A>. This section explains how to restore a damaged root filesystem when the system cannot boot. It also describes how to safely restore system files on the root filesystem.<P><B>Caution: </B>Restoring IRIX system files on an active root filesystem disk may cause damage to the filesystem and system failure.<A NAME="SGI29"></A>
<h3 class="SGITPL-head">Recovering Individual Files with restore </h3><p>To recover individual files from an archive created by the <i>dump</i> utility, follow these steps:<ol><li>Place the tape in the tape drive. Make sure it is write-protected. Enter:<PRE># <B>restore vi</B> 
Verify tape and initialize maps
Tape block size is 32
Dump  date: Wed Feb 13 10:18:59 1991
Dumped from: the epoch
Level 0 dump of an unlisted filesystem on ralph:/dev/rusr
Label: none
Extract directories from tape
Initialize symbol table.
restore >></PRE><li>You are now at the <i>restore>></i> prompt. You can browse the tape with <i>cd</i> and <i>ls</i>:<pre>restore > <B>ls</B> </pre><PRE>2      *./          973     source        1502  net/
2      *../         149     d2/           1445  os/
10     .cshrc       155016  debug/        1437  proto3.5/
1463   .gamma       69899   dev/          1494  revE
1464   .gamtables   696     etc/          2122  stand/
160    .kshrc       137     bin/          3     tmp/
1540   .lastlogin   1311412 jake/         128   unix
819    .login       424     lib/          128   unix.debug
820    .profile     9       lost+found/   4     usr/</PRE><p>To continue browsing, enter the following commands to the <i>restore>></i> prompt:<PRE>restore >> <B>cd etc</B> 
restore >> <B>pwd</B> 
/etc</PRE><li>Start building a list of files that you want to extract. Use the <i>add</i> command to add the names of the files you want to the extract list:<PRE>restore >> <B>add fstab</B> 
restore >> <B>add fsck</B> </PRE><p>If you enter <i>ls</i> at this point, you see a list of files, and <i>fsck</i> and <i>fstab</i> are marked with an asterisk to show they will be extracted. If you want to remove a file from the list of those to be extracted, use the <i>delete</i> command:<pre>restore > <B>delete fstab</B> </pre><li>To restore the specified files, use the <i>extract</i> command:<PRE>restore > <B>extract</B> 
Extract requested files
You have not read any tapes yet.
Unless you know which volume your file(s) are on you should
start with the last volume and work towards the first.
Specify next volume #: <B>1</B> 
Mount tape volume 1
then enter tape name (default: /dev/tape) <B>&lt;Return></B> 
extract file ./etc/fsck
Add links
Set directory mode, owner, and times.
set owner/mode for '.'? [yn] <B>n</B> 
restore > <B>q</B> </PRE></ol><p>To recover only a few files, you may wish to use the non-interactive options of <i>restore</i>. For example, enter:<pre><B>restore -x ./usr/people/ralph/bus.schedule ./etc/passwd</B> </pre><p>This recovers the files <i>bus.schedule</i> and <i>passwd</i> from the archive.<HR noshade><A NAME="SGI30"></A>
<h2 class="SGITPL-head">About xfsdump and xfsrestore</h2><p>This section describes how the <i>xfsdump</i> and <i>xfsrestore</i> utilities work and how to use them to back up and recover data on XFS filesystems. (The xfsdump(1M) and xfsrestore(1M) reference pages provide online information on these utilities.) <A HREF="IA_BakSecAcc-6.html#SGITF2" TARGET=_top>Table 2-1</A> summarizes when to use <i>xfsdump</i> and when to use its EFS counterpart, dump(1M)<TABLE BORDER CELLPADDING=10><p><A NAME="SGITF2"></A><CAPTION ALIGN=TOP><B>Table 2-1 :  </B>Filesystems and Dump Utilities</CAPTION><TR VALIGN=TOP ALIGN=LEFT><TH>For a Filesystem of Type</TH><TH>Dump It Using</TH><TR ALIGN=LEFT VALIGN=TOP><TD><p>EFS</TD><TD><p><i>dump</i></TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p>XFS</TD><TD><p><i>xfsdump</i></TD></TR></TABLE> <br><br><p><A HREF="IA_BakSecAcc-6.html#SGITF3" TARGET=_top>Table 2-2</A> summarizes when to use <i>xfsrestore</i> and when to use its EFS counterpart, restore(1M).<TABLE BORDER CELLPADDING=10><p><A NAME="SGITF3"></A><CAPTION ALIGN=TOP><B>Table 2-2 :  </B>Filesystems and Restore Utilities</CAPTION><TR VALIGN=TOP ALIGN=LEFT><TH>For a Dump Made Using</TH><TH>Restore It Using</TH><TH>On a Filesystem of Type</TH><TR ALIGN=LEFT VALIGN=TOP><TD><p><i>dump</i></TD><TD><p><i>restore</i></TD><TD><p>EFS or XFS</TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p><i>xfsdump</i></TD><TD><p><i>xfsrestore</i></TD><TD><p>EFS or XFS</TD></TR></TABLE> <br><br><p>Note than you can restore data in either EFS or XFS filesystems, but must use the restore utility that corresponds with the dump utility used to make the backup.<A NAME="SGI31"></A>
<h3 class="SGITPL-head">Features of xfsdump and xfsrestore</h3><p>The <i>xfsdump</i> and <i>xfsrestore</i> utilities fully support XFS filesystems. With <i>xfsdump</i> and <i>xfsrestore</i>, you can back up and restore data using local or remote drives. You can back up filesystems, directories, and/or individual files, and then restore filesystems, directories, and files independently of how they were backed up. <i>xfsdump</i> also allows you to back up "live" (mounted, in-use) filesystems.<p>With <i>xfsdump</i> and <i>xfsrestore</i>, you can recover from intentional or accidental interruptions   -       this means you can interrupt a dump or restore at any time, and then resume it whenever desired. With <i>xfsrestore</i>, you can restore <i>xfsdump</i> data onto EFS filesystems. <i>(xfsdump</i> backs up mounted XFS filesystems only.) <i>xfsdump</i> and <i>xfsrestore</i> support incremental dumps, and multiple dumps can be placed on a single media object. The utilities can automatically divide a dump among multiple drives, and can restore a dump from multiple drives. This allows you to perform faster dumps and restores.<p><i>xfsdump</i> and <i>xfsrestore</i> support XFS features including 64-bit inode numbers, file lengths, holes, and user-selectable extent sizes. They support multiple media types, all IRIX-supported file types (regular, directory, symbolic link, block and character special, FIFO, and socket), and retain hard links.<i> xfsdump</i> does not affect the state of the filesystem being dumped (for example, access times are retained).<i> xfsrestore</i> detects and bypasses media errors and recovers rapidly after encountering them.<i> xfsdump</i> does not cross mount points, local or remote.<p><i>xfsdump</i> optionally prompts for additional media when the end of the current media is reached. Operator estimates of media capacity are not required and <i>xfsdump</i> also supports automated backups. <i>xfsdump</i> maintains an extensive online inventory of all dumps performed. Inventory contents can be viewed through various filters to quickly locate specific dump information. <i>xfsrestore</i> supports interactive operation, allowing selection of individual files or directories for recovery. It also permits selection from among backups performed at different times when multiple dumps are available. Dump contents may also be viewed noninteractively.<P><B>Note: </B>If you are using disk quotas on XFS filesystems, refer to "Administering Disk Quotas on XFS Filesystems" in <i></i>IRIX Admin: Disks and Filesystems    <i></i> for more information.<A NAME="SGI32"></A>
<h3 class="SGITPL-head">Media Layout for xfsdump</h3><p>The following section introduces some terminology and then describes the way <i>xfsdump</i> formats data on the storage media for use by <i>xfsrestore</i>.<p>While <i>xfsdump</i> and <i>xfsrestore</i> are often used with tape media, the utilities actually support multiple kinds of media, so in the following discussions, the term <i>media object</i> is used to refer to the media in a generic fashion. The term <i>dump</i> refers to the result of a single use of the <i>xfsdump</i> command to output data files to the selected media object(s). An instance of the use of <i>xfsdump</i> is referred to as a <i>dump session</i>.<p>The dump session sends a single <i>dump stream</i> to the media object(s). The dump stream may contain as little as a single file or as much as an entire filesystem. The dump stream is composed of <i>dump objects</i>, which are: <ul><li>one or more <i>data segments</i><br><br><li>an optional <i>dump inventory</i><br><br><li>a<i> stream terminator</i></ul><p>The data segment(s) contains the actual data, the dump inventory contains a list of the dump objects in the dump, and the stream terminator marks the end of the dump stream. When a dump stream is composed of multiple dump objects, each object is contained in a <i>media file</i>. Some output devices, for example standard output, do not support the concept of media files   -       the dump stream is only the data.<A NAME="SGI33"></A>
<h4 class="SGITPL-head">Possible xfsdump Layouts</h4><p>The simplest dump, for example the dump of a small amount of data to a single tape, produces a data segment and a stream terminator as the only dump objects. If the optional inventory object is added, you have a dump like that illustrated in <A HREF="IA_BakSecAcc-6.html#SGITF5" TARGET=_top>Figure 2-1</A>. (In the data layout diagrams in this section, the optional inventory object is always included.)<p><p> <IMG SRC="images/XFSFig3-1.gif" WIDTH=403 HEIGHT=345 ALT="XFSFig3-1.gif" BORDER=0 ALIGN=absmiddle><p><B>Figure 2-1 :  </B>Single Dump on Single Media Object<p><br><p>You can also dump data streams that are larger than a single media object. The data stream can be broken between any two media files including data segment boundaries. (The inventory is never broken into segments.) In addition, if you specify multiple drives, the dump is automatically broken into multiple streams. The <i>xfsdump</i> utility prompts for a new media object when the end of the current media object is reached.<p><A HREF="IA_BakSecAcc-6.html#SGITF6" TARGET=_top>Figure 2-2</A> illustrates the data layout of a single dump session that requires two media objects on each of two devices.<p><p> <A NAME="SGITF6"></A><IMG SRC="images/XFSFig3-2.gif" WIDTH=450 HEIGHT=684 ALT="XFSFig3-2.gif" BORDER=0 ALIGN=absmiddle><p><B>Figure 2-2 :  </B>Single Dump on Multiple Media Objects<p><br><p>The <i>xfsdump</i> utility also accommodates multiple dumps on a single media object. When dumping to tape, for example, the tape is automatically advanced past the existing dump session(s) and the existing stream terminator is erased. The new dump data is then written, followed by the new stream terminator <A NAME="SGITF7">    <IMG SRC="images/footnote.gif" WIDTH=25 HEIGHT=15 ALT="footnote" BORDER=0 ALIGN=absmiddle></A>
.<p><A HREF="IA_BakSecAcc-6.html#SGITF7" TARGET=_top>Figure 2-3</A> illustrates the layout of media files for two dumps on a single media object.<p><A HREF="IA_BakSecAcc-6.html#SGITF8" TARGET=_top>Figure 2-4</A> illustrates a case in which multiple dumps use multiple media objects. If media files already exist on the additional media object(s), the <i>xfsdump</i> utility finds the existing stream terminator, erases it, and begins writing the new dump data stream.<p><p> <IMG SRC="images/XFSFig3-3.gif" WIDTH=520 HEIGHT=706 ALT="XFSFig3-3.gif" BORDER=0 ALIGN=absmiddle><p><B>Figure 2-3 :  </B>Multiple Dumps on Single Media Object<p><br><p> <A NAME="SGITF8"></A><IMG SRC="images/XFSFig3-4.gif" WIDTH=476 HEIGHT=711 ALT="XFSFig3-4.gif" BORDER=0 ALIGN=absmiddle><p><B>Figure 2-4 :  </B>Multiple Dumps on Multiple Media Objects<p><br><A NAME="SGI34"></A>
<h3 class="SGITPL-head">Saving Data with xfsdump</h3><p>This section discusses how to use the <i>xfsdump</i> command to back up data to local and remote devices. You can get a summary of <i>xfsdump</i> syntax with the ­h option:<PRE># <B>xfsdump -h</B> 
xfsdump: version <var>X.X</var> 
xfsdump: usage: xfsdump [ -b &lt;blocksize> (with minimal rmt option) ]
                        [ -c &lt;media change alert program> ]
                        [ -f &lt;destination> ... ]
                        [ -h (help) ]
                        [ -l &lt;level> ]
                        [ -m &lt;force usage of minimal rmt> ]
                        [ -o &lt;overwrite tape > ]
                        [ -p &lt;seconds between progress reports> ]
                        [ -s &lt;subtree> ... ]
                        [ -v &lt;verbosity {silent, verbose, trace}> ]
                        [ -A (don't dump extended file attributes) ]
                        [ -B &lt;base dump session id> ]
                        [ -E (pre-erase media) ]
                        [ -F (don't prompt) ]
                        [ -I (display dump inventory) ]
                        [ -J (inhibit inventory update) ]
                        [ -L &lt;session label> ]
                        [ -M &lt;media label> ... ]
                        [ -O &lt;options file> ]
                        [ -R (resume) ]
                        [ -T (don't timeout dialogs) ]
                        [ -Y &lt;I/O buffer ring length> ]
                        [ - (stdout) ]
                        [ &lt;source (mntpnt|device)> ]</PRE><p>You must be the superuser to use <i>xfsdump</i>. Refer to the xfsdump(1M) reference page for details.<A NAME="SGI35"></A>
<h4 class="SGITPL-head">Specifying Local Media with xfsdump</h4><p>You can use <i>xfsdump</i> to back up data to various media. For example, you can dump data to a tape or hard disk. The drive containing the media object may be connected to the local system or accessible over the network.<p>Following is an example of a level 0 dump to a local tape drive. Note that dump level does not need to be specified for a level 0 dump. (Refer to <A HREF="IA_BakSecAcc-6.html#SGI27" TARGET=_top>"Performing Incremental Backups"</A> for a discussion of dump levels.)<PRE># <B>xfsdump -f /dev/tape -L testers_11_21_94 -M test_1 /disk2</B>
xfsdump: version 2.0 - type ^C for status and control
xfsdump: level 0 dump of cumulus:/disk2
xfsdump: dump date: Wed Oct 25 16:19:13 1995
xfsdump: session id: d2a6123b-b21d-1001-8938-08006906dc5c
xfsdump: session label: "testers_11_21_94"
xfsdump: ino map phase 1: skipping (no subtrees specified)
xfsdump: ino map phase 2: constructing initial dump list
xfsdump: ino map phase 3: skipping (no pruning necessary)
xfsdump: ino map phase 4: skipping (size estimated in phase 2)
xfsdump: ino map phase 5: skipping (only one dump stream)
xfsdump: ino map construction complete
xfsdump: preparing drive
xfsdump: creating dump session media file 0 (media 0, file 0)
xfsdump: dumping ino map
xfsdump: dumping directories
xfsdump: dumping non-directory files
xfsdump: ending media file
xfsdump: media file size 16777216 bytes
xfsdump: dumping session inventory
xfsdump: beginning inventory media file
xfsdump: media file 1 (media 0, file 1)
xfsdump: ending inventory media file
xfsdump: inventory media file size 4194304 bytes
xfsdump: writing stream terminator
xfsdump: beginning media stream terminator
xfsdump: media file 2 (media 0, file 2)
xfsdump: ending media stream terminator
xfsdump: media stream terminator size 2097152 bytes
xfsdump: I/O metrics: 3 by 2MB ring; 14/22 (64%) records streamed; 145889B/s
xfsdump: dump complete: 141 seconds elapsed</PRE><p>In this case, a session label (­L option) and a media label (­M option) are supplied, and the entire filesystem is dumped. Since no verbosity option is supplied, the default of <i>verbose</i> is used, resulting in the detailed screen output. The dump inventory is updated with the record of this backup because the -J option is not specified.<p>Following is an example of a backup of a subdirectory of a filesystem. In this example, the verbosity is set to <i>silent</i>, and the dump inventory is not updated (­J option):<PRE># <B>xfsdump -f /dev/tape -v silent -J -s people/fred /usr</B></PRE><p>Note that the subdirectory backed up (<i>/usr/people/fred</i>) was specified relative to the filesystem, so the specification did not include the name of the filesystem (in this case, <i>/usr</i>). Since <i>/usr</i> may be a very large filesystem and the -v silent option was used, this could take a long time during which there would be no screen output.<A NAME="SGI36"></A>
<h4 class="SGITPL-head">Specifying a Remote Tape Drive with xfsdump</h4><p>To back up data to a remote tape drive, use the standard remote system syntax, specifying the system (by hostname if supported by a name server or IP address if not) followed by a colon (:), then the pathname of the special file. <P><B>Note: </B>For remote backups, use the variable block size tape device if the device supports variable block size operation; otherwise, use the fixed block size device (see intro(7)).<p>The following example shows a subtree backup to a remote tape device:<PRE># <B>xfsdump -f magnolia:/dev/tape -L mag_10-95 -s engr /disk2</B>
xfsdump: version 2.0 - type ^C for status and control
xfsdump: level 0 dump of cumulus:/disk2
xfsdump: dump date: Wed Oct 25 16:27:39 1995
xfsdump: session id: d2a6124b-b21d-1001-8938-08006906dc5c
xfsdump: session label: "mag_10-95"
xfsdump: ino map phase 1: parsing subtree selections
xfsdump: ino map phase 2: constructing initial dump list
xfsdump: ino map phase 3: pruning unneeded subtrees
xfsdump: ino map phase 4: estimating dump size
xfsdump: ino map phase 5: skipping (only one dump stream)
xfsdump: ino map construction complete
xfsdump: preparing drive
xfsdump: positioned at media file 0: dump 0, stream 0
xfsdump: positioned at media file 1: dump 0, stream 0
xfsdump: positioned at media file 2: dump 0, stream 0
xfsdump: stream terminator found
xfsdump: creating dump session media file 0 (media 0, file 2)
xfsdump: dumping ino map
xfsdump: dumping directories
xfsdump: dumping non-directory files
xfsdump: ending media file
xfsdump: media file size 6291456 bytes
xfsdump: dumping session inventory
xfsdump: beginning inventory media file
xfsdump: media file 1 (media 0, file 3)
xfsdump: ending inventory media file
xfsdump: inventory media file size 4194304 bytes
xfsdump: writing stream terminator
xfsdump: beginning media stream terminator
xfsdump: media file 2 (media 0, file 4)
xfsdump: ending media stream terminator
xfsdump: media stream terminator size 2097152 bytes
xfsdump: I/O metrics: 3 by 2MB ring; 12/22 (55%) records streamed; 99864B/s
xfsdump: dump complete: 149 seconds elapsed</PRE><p>In this case, <i>/disk2/engr </i>is backed up to the variable block size tape device on the remote system <i>magnolia</i>. Existing dumps on the tape mounted on magnolia were skipped before recording the new data.<P><B>Note: </B>The superuser account on the local system must be able to <i>rsh</i> to the remote system without a password. For more information, see hosts.equiv(4).<A NAME="SGI37"></A>
<h4 class="SGITPL-head">Backing Up to a File with xfsdump</h4><p>You can back up data to a file instead of a device. In the following example, a file (<i>Makefile</i>) and a directory (<i>Source</i>) are backed up to a dump file (<i>monday_backup</i>) in <i>/usr/tmp</i> on the local system:<PRE># <B>xfsdump -f /usr/tmp/monday_backup -v silent -J -s \</B>
<B>people/fred/Makefile -s people/fred/Source /usr</B></PRE><p>You may also dump to a file on a remote system, but note that the file must be in the remote system's <i>/dev</i> directory. For example, the following command backs up the <i>/usr/people/fred</i> subdirectory on the local system to the regular file<i> /dev/fred_mon_12-2</i> on the remote system <i>theduke</i>:<PRE># <B>xfsdump -f theduke:/dev/fred_mon_12-2 -s people/fred /usr</B></PRE><p>Alternatively, you could dump to any remote file if that file is on an NFS-mounted filesystem. In any case, permission settings on the remote system must allow you to write to the file.<p>Refer to the section <A HREF="IA_BakSecAcc-6.html#SGI52" TARGET=_top>"Using xfsdump and xfsrestore to Copy Filesystems"</A> for information on using the standard input and standard output capabilities of <i>xfsdump</i> and <i>xfsrestore</i> to pipe data between filesystems or across the network.<A NAME="SGI38"></A>
<h4 class="SGITPL-head">Reusing Tapes with xfsdump</h4><p>When you use a new tape as the media object of a dump session, <i>xfsdump</i> begins writing dump data at the beginning of the tape without prompting. If the tape already has dump data on it, <i>xfsdump</i> begins writing data after the last dump stream, again without prompting.<p>If, however, the tape contains data that is not from a dump session, <i>xfsdump</i> prompts you before continuing:<PRE># <B>xfsdump -f /dev/tape /test </B>
xfsdump: version <var>X.X</var> - type ^C for status and control
xfsdump: dump date: Fri Dec 2 11:25:19 1994
xfsdump: level 0 dump
xfsdump: session id: d23cc072-b21d-1001-8f97-080069068eeb
xfsdump: preparing tape drive
xfsdump: this tape contains data that is not part of an XFS dump
xfsdump: do you want to overwrite this tape?
type y to overwrite, n to change tapes or abort (y/n):</PRE><p>You must answer <TT><B>y</B></TT> if you want to continue with the dump session, or <TT><B>n</B></TT> to quit. If you answer <TT><B>y</B></TT>, the dump session resumes and the tape is overwritten. If you do not respond to the prompt, the session eventually times out. Note that this means that an automatic backup, for example one initiated by a <i>crontab</i> entry, will not succeed   -       unless you specified the -F option with the <i>xfsdump</i> command, which forces it to overwrite the tape rather than prompt for approval.<A NAME="SGI39"></A>
<h4 class="SGITPL-head">Erasing Used Tapes</h4><p>Erase preexisting data on tapes with the <i>mt erase</i> command. Make sure the tape is not write-protected.<p>For example, to prepare a used tape in the local default tape drive, enter:<PRE># <B>mt -f /dev/tape erase</B></PRE><P><B>Caution: </B>This erases all data on the tape, including any dump sessions.<p>The tape can now be used by <i>xfsdump</i> without prompting for approval.<A NAME="SGI40"></A>
<h4 class="SGITPL-head">About Incremental and Resumed Dumps</h4><p>Incremental dumps are a way of backing up less data at a time but still preserving current versions of all your backed-up files, directories, and so on. Incremental backups are organized numerically by levels from 0 through 9. A level 0 dump always backs up the complete filesystem. A dump level of any other number backs up all files that have changed since a dump with a lower dump level number.<p>For example, if you perform a level 2 backup on a filesystem one day and your next dump is a level 3 backup, only those files that have changed since the level 2 backup are dumped with the level 3 backup. In this case, the level 2 backup is called the <i>base dump</i> for the level 3 backup. The base dump is the most recent backup of that filesystem with a lower dump level number.<p>Resumed dumps work in much the same way. When a dump is resumed after it has been interrupted, the remaining files that had been scheduled to be backed up during the interrupted dump session are backed up, and any files that changed during the interruption are also backed up. Note that you must restore an interrupted dump as if it is an incremental dump (see <A HREF="IA_BakSecAcc-6.html#SGI49" TARGET=_top>"Performing Cumulative Restores with xfsrestore"</A>).<A NAME="SGI41"></A>
<h4 class="SGITPL-head">Performing an Incremental xfsdump</h4><p>In the following example, a level 0 dump is the first backup written to a new tape:<PRE># <B>xfsdump -f /dev/tape -l 0 -M Jun_94 -L week_1 -v silent /usr</B></PRE><p>A week later, a level 1 dump of the filesystem is performed on the same tape:<PRE># <B>xfsdump -f /dev/tape -l 1 -L week_2 /usr</B></PRE><p>The tape is forwarded past the existing dump data and the new data from the level 1 dump is written after it. (Note that it is not necessary to specify the media label for each successive dump on a media object.)<p>A week later, a level 2 dump is taken and so on, for the four weeks of a month in this example, the fourth week being a level 3 dump (up to nine dump levels are supported):<PRE># <B>xfsdump -f /dev/tape -l 2 -L week_3 /usr</B></PRE><p>Refer to <A HREF="IA_BakSecAcc-6.html#SGI49" TARGET=_top>"Performing Cumulative Restores with xfsrestore"</A> for information on the proper procedure for restoring incremental dumps.<A NAME="SGI42"></A>
<h4 class="SGITPL-head">Performing a Resumed xfsdump</h4><p>You can interrupt a dump session and resume it later. To interrupt a dump session, type the interrupt character (typically <TT><B>&lt;CTRL-C></B></TT>). You receive a list of options which allow you to interrupt the session, change verbosity level, or resume the session. <p>In the following example, <i>xfsdump</i> is interrupted after dumping approximately 37% of a filesystem:<PRE># <B>xfsdump -f /dev/tape -M march95 -L week_1 -v silent /disk2</B>
========================= status and control dialog ==========================
status at 16:49:16: 378/910 files dumped, 37.8% complete, 32 seconds elapsed
please select one of the following operations
1: interrupt this session
2: change verbosity
3: display metrics
4: other controls
5: continue (default) (timeout in 60 sec)
 -> 1
please confirm
1: interrupt this session
2: continue (default) (timeout in 60 sec)
 -> 1
interrupt request accepted
--------------------------------- end dialog ---------------------------------
xfsdump: initiating session interrupt
xfsdump: dump interrupted prior to ino 1053172 offset 0</PRE><p>You can later continue the dump by including the ­R option and a different session label:<PRE># <B>xfsdum -f /dev/tape -R -L week_1.contd -v silent /disk2p</B></PRE><p>Any files that were not backed up before the interruption, and any file changes that were made during the interruption, are backed up after the dump is resumed.<P><B>Note: </B>Use of the ­R option requires that the dump was made with a dump inventory taken, that is, the ­J option was not used with <i>xfsdump</i>.<A NAME="SGI43"></A>
<h3 class="SGITPL-head">Examining xfsdump Archives</h3><p>This section describes how to use the <i>xfsdump</i> command to view an <i>xfsdump</i> inventory.<p>The <i>xfsdump</i> inventory is maintained in the directory <i>/var/xfsdump </i>created by <i>xfsdump</i>. You can view the dump inventory at any time with the <i>xfsdump ­I</i> command. With no other arguments, <i>xfsdump ­I</i> displays the entire dump inventory. (The <i>xfsdump -I</i> command does not require root privileges.)<p>The following output presents a section of a dump inventory.<PRE># <B>xfsdump -I | more</B>
file system 0:
        fs id:          d23cb450-b21d-1001-8f97-080069068eeb
        session 0:
                mount point:    magnolia.abc.xyz.com:/test
                device:         magnolia.abc.xyz.com:/dev/rdsk/dks0d3s2
                time:           Mon Nov 28 11:44:04 1994
                session label:  ""
                session id:     d23cbf44-b21d-1001-8f97-080069068eeb
                level:          0
                resumed:        NO
                subtree:        NO
                streams:        1
                stream 0:
                        pathname:       /dev/tape
                        start:          ino 4121 offset 0
                        end:            ino 0 offset 0
                        interrupted:    YES
                        media files:    2
                        media file 0:
                                mfile index:    0
---more---</PRE><p>Notice that the dump inventory records are presented sequentially and are indented to illustrate the hierarchical order of the dump information. <p>You can view a subset of the dump inventory by specifying the level of depth (1, 2, or 3) that you want to view. For example, specifying depth=2 filters out a lot of the specific dump information as you can see by comparing the previous output with this:<PRE># <B>xfsdump -I depth=2</B>
file system 0:
        fs id:          d23cb450-b21d-1001-8f97-080069068eeb
        session 0:
                mount point:    magnolia.abc.xyz.com:/test
                device:         magnolia.abc.xyz.com:/dev/rdsk/dks0d3s2
                time:           Mon Nov 28 11:44:04 1994
                session label:  ""
                session id:     d23cbf44-b21d-1001-8f97-080069068eeb
                level:          0
                resumed:        NO
                subtree:        NO
                streams:        1
        session 1:
                mount point:    magnolia.abc.xyz.com:/test
                device:         magnolia.abc.xyz.com:/dev/rdsk/dks0d3s2
               .
               .
               .</PRE><p>You can also view a filesystem-specific inventory by specifying the filesystem mount point with the <i>mnt</i> option. The following output shows an example of a dump inventory display in which the <i>depth</i> is set to <i>1</i>, and only a single filesystem is displayed:<PRE># <B>xfsdump -I depth=1,mnt=magnolia.abc.xyz.com:/test</B>
filesystem 0:
        fs id:          d23cb450-b21d-1001-8f97-080069068eeb</PRE><p>Note that you can also look at a list of contents on the dump media itself by using the ­t option with <i>xfsrestore</i>. (The <i>xfsrestore</i> utility is discussed in detail in the following section.) For example, to list the contents of the dump tape currently in the local tape drive, type:<PRE># <B>xfsrestore -f /dev/tape -t -v silent | more</B>
xfsrestore: dump session found
xfsrestore: session label: "week_1"
xfsrestore: session id: d23cbcb4-b21d-1001-8f97-080069068eeb
xfsrestore: no media label
xfsrestore: media id: d23cbcb5-b21d-1001-8f97-080069068eeb
do you want to select this dump? (y/n): <B>y</B>
selected
one
A/five
people/fred/TOC
people/fred/ch3.doc
people/fred/ch3TOC.doc
people/fred/questions
A/four
people/fred/script_0
people/fred/script_1
people/fred/script_2
people/fred/script_3
people/fred/sub1/TOC
people/fred/sub1/ch3.doc
people/fred/sub1/ch3TOC.doc
people/fred/sub1/questions
people/fred/sub1/script_0
people/fred/sub1/script_1
people/fred/sub1/script_2
people/fred/sub1/script_3
people/fred/sub1/xdump1.doc
people/fred/sub1/xdump1.doc.backup
people/fred/sub1/xfsdump.doc
people/fred/sub1/xfsdump.doc.auto
people/fred/sub1/sub2/TOC
---more---</PRE><A NAME="SGI44"></A>
<h3 class="SGITPL-head">About xfsrestore</h3><p>This section discusses the <i>xfsrestore</i> command, which you must use to view and extract data from the dump data created by <i>xfsdump</i>. You can get a summary of <i>xfsrestore</i> syntax with the ­h option:<PRE># <B>xfsrestore -h</B>
xfsrestore: version <var>X.X</var>
xfsrestore: usage: xfsrestore [ -a &lt;alt. workspace dir> ... ]
                     [ -e (don't overwrite existing files) ]
                     [ -f &lt;source> ... ]
                     [ -h (help) ]
                     [ -i (interactive) ]
                     [ -n &lt;file> (restore only if newer than) ]
                     [ -o (restore owner/group even if not root) ]
                     [ -p &lt;seconds between progress reports> ]
                     [ -r (cumulative restore) ]
                     [ -s &lt;subtree> ... ]
                     [ -t (contents only) ]
                     [ -v &lt;verbosity {silent, verbose, trace}> ]
                     [ -A (don't restore extended file attributes) ]
                     [ -C (check tape record checksums) ]
                     [ -D (restore DMAPI event settings) ]
                     [ -E (don't overwrite if changed) ]
                     [ -F (don't prompt) ]
                     [ -I (display dump inventory) ]
                     [ -J (inhibit inventory update) ]
                     [ -L &lt;session label> ]
                     [ -N (timestamp messages) ]
                     [ -O &lt;options file> ]
                     [ -P (pin down I/O buffers) ]
                     [ -Q (force interrupted session completion) ]
                     [ -R (resume) ]
                     [ -S &lt;session id> ]
                     [ -T (don't timeout dialogs) ]
                     [ -U (unload media when change needed) ]
                     [ -V (show subsystem in messages) ]
                     [ -W (show verbosity in messages) ]
                     [ -X &lt;excluded subtree> ... ]
                     [ -Y &lt;I/O buffer ring length> ]
                     [ -Z (miniroot restrictions) ]
                     [ - (stdin) ]
                     [ &lt;destination> ]</PRE><p>Use <i>xfsrestore</i> to restore data backed up with <i>xfsdump</i>. You can restore files, subdirectories, and filesystems   -       regardless of the way they were backed up. For example, if you back up an entire filesystem in a single dump, you can select individual files and subdirectories from within that filesystem to restore.<p>You can use <i>xfsrestore</i> interactively or noninteractively. With interactive mode, you can peruse the filesystem or files backed up, selecting those you want to restore. In noninteractive operation, a single command line can restore selected files and subdirectories, or an entire filesystem. You can restore data to its original filesystem location or any other location in an EFS or XFS filesystem.<p>By using successive invocations of <i>xfsrestore</i>, you can restore incremental dumps on a base dump. This restores data in the same sequence it was dumped.<A NAME="SGI45"></A>
<h4 class="SGITPL-head">Performing Simple Restores with xfsrestore</h4><p>A simple restore is a non-cumulative restore (for information on restoring incremental dumps, refer to <A HREF="IA_BakSecAcc-6.html#SGI49" TARGET=_top>"Performing Cumulative Restores with xfsrestore"</A>). An example of a simple, noninteractive use of <i>xfsrestore</i> is:<PRE># <B>xfsrestore -f /dev/tape /disk2</B>
xfsrestore: version 2.0 - type ^C for status and control
xfsrestore: searching media for dump
xfsrestore: preparing drive
xfsrestore: examining media file 0

 =========================== dump selection dialog ============================

the following dump has been found on drive 0

hostname: cumulus
mount point: /disk2
volume: /dev/rdsk/dks0d2s0
session time: Wed Oct 25 16:59:00 1995
level: 0
session label: "tape1"
media label: "media1"
file system id: d2a602fc-b21d-1001-8938-08006906dc5c
session id: d2a61284-b21d-1001-8938-08006906dc5c
media id: d2a61285-b21d-1001-8938-08006906dc5c

restore this dump?
1: skip
2: restore (default)
 -> <B>2</B>
this dump selected for restoral

 --------------------------------- end dialog ---------------------------------

xfsrestore: using online session inventory
xfsrestore: searching media for directory dump
xfsrestore: reading directories
xfsrestore: directory post-processing
xfsrestore: restoring non-directory files
xfsrestore: I/O metrics: 3 by 2MB ring; 9/13 (69%) records streamed; 204600B/s
xfsrestore: restore complete: 104 seconds elapsed</PRE><p>In this case, <i>xfsrestore</i> went to the first dump on the tape and asked if this was the dump to restore. If you had entered <TT><B>1</B></TT> for "skip," <i>xfsrestore</i> would have proceeded to the next dump on the tape (if there was one) and asked if this was the dump you wanted to restore.<p>You can request a specific dump if you used <i>xfsdump</i> with a session label. For example:<PRE># <B>xfsrestore -f /dev/tape -L Wed_11_23 /usr</B>
xfsrestore: version <var>X.X</var> - type ^C for status and control
xfsrestore: preparing tape drive
xfsrestore: dump session found
xfsrestore: advancing tape to next media file
xfsrestore: dump session found
xfsrestore: restore of level 0 dump of magnolia.abc.xyz.com:/usr created Wed Nov 23 11:17:54 1994
xfsrestore: beginning media file
xfsrestore: reading ino map
xfsrestore: initializing the map tree
xfsrestore: reading the directory hierarchy
xfsrestore: restoring non-directory files
xfsrestore: ending media file
xfsrestore: restoring directory attributes
xfsrestore: restore complete: 200 seconds elapsed</PRE><p>In this way you recover a dump with a single command line and do not have to answer <TT><B>y</B></TT> or <TT><B>n</B></TT> to the prompt(s) asking you if the dump session found is the correct one. To be even more exact, use the -S option and specify the unique session ID of the particular dump session:<PRE># <B>xfsrestore -f /dev/tape -S \</B>
<B>d23cbf47-b21d-1001-8f97-080069068eeb /usr2/tmp</B>
xfsrestore: version <var>X.X</var> - type ^C for status and control
xfsrestore: preparing tape drive
xfsrestore: dump session found
xfsrestore: advancing tape to next media file
xfsrestore: advancing tape to next media file
xfsrestore: dump session found
xfsrestore: restore of level 0 dump of magnolia.abc.xyz.com:/test resumed Mon Nov 28 11:50:41 1994
xfsrestore: beginning media file
xfsrestore: media file 0 (media 0, file 2)
xfsrestore: reading ino map
xfsrestore: initializing the map tree
xfsrestore: reading the directory hierarchy
xfsrestore: restoring non-directory files
xfsrestore: ending media file
xfsrestore: restoring directory attributes
xfsrestore: restore complete: 229 seconds elapsed</PRE><p>You can find the session ID by viewing the dump inventory (see <A HREF="IA_BakSecAcc-6.html#SGI43" TARGET=_top>"Examining xfsdump Archives"</A>). Session labels might be duplicated, but session IDs never are.<A NAME="SGI46"></A>
<h4 class="SGITPL-head">Restoring Individual Files with xfsrestore</h4><p>On the <i>xfsrestore</i> command line, you can specify an individual file or subdirectory to restore. In this example, the file <i>people/fred/notes</i> is restored and placed in the <i>/usr/tmp</i> directory (that is, the file is restored in <i>/usr/tmp/people/fred/notes</i>):<PRE># <B>xfsrestore -f /dev/tape -L week_1 -s people/fred/notes /usr/tmp</B></PRE><p>You can also restore a file "in place" that is, restore it directly to where it came from in the original backup. Note, however, that if you do not use a -e, -E, or -n option, you overwrite any existing file(s) of the same name. <p>In the following example, the subdirectory <i>people/fred</i> is restored in the destination <i>/usr</i>   -        this overwrites any files and subdirectories in <i>/usr/people/fred</i> with the data on the dump tape:<PRE># <B>xfsrestore -f /dev/tape -L week_1 -s people/fred /usr</B></PRE><A NAME="SGI47"></A>
<h4 class="SGITPL-head">Performing Network Restores with xfsrestore</h4><p>You can use standard network references to specify devices and files on the network. For example, to use the tape drive on a network host named <i>magnolia</i> as the source for a restore, you can use the command:<PRE># <B>xfsrestore -f magnolia:/dev/tape -L 120694u2 /usr2</B>
xfsrestore: version <var>X.X</var> - type ^C for status and control
xfsrestore: preparing tape drive
xfsrestore: dump session found
xfsrestore: advancing tape to next media file
xfsrestore: dump session found
xfsrestore: restore of level 0 dump of magnolia.abc.xyz.com:/usr2 created Tue Dec 6 10:55:17 1994
xfsrestore: beginning media file
xfsrestore: media file 0 (media 0, file 1)
xfsrestore: reading ino map
xfsrestore: initializing the map tree
xfsrestore: reading the directory hierarchy
xfsrestore: restoring non-directory files
xfsrestore: ending media file
xfsrestore: restoring directory attributes
xfsrestore: restore complete: 203 seconds elapsed</PRE><p>In this case, the dump data is extracted from the tape on <i>magnolia</i>, and the destination is the directory <i>/usr2</i> on the local system. Refer to the section <A HREF="IA_BakSecAcc-6.html#SGI52" TARGET=_top>"Using xfsdump and xfsrestore to Copy Filesystems"</A> for an example of using the standard input option of <i>xfsrestore</i>.<A NAME="SGI48"></A>
<h4 class="SGITPL-head">Performing Interactive Restores with xfsrestore</h4><p>Use the ­i option of <i>xfsrestore</i> to perform interactive file restoration. With interactive restoration, you can use the commands <i>ls</i>, <i>pwd</i>, and <i>cd</i> to peruse the filesystem, and the <i>add</i> and <i>delete</i> commands to create a list of files and subdirectories you want to restore. Then you can enter the <i>extract</i> command to restore the files, or <i>quit</i> to exit the interactive restore session without restoring files. (The use of "wildcards" is not allowed with these commands.)<P><B>Note: </B>Interactive restore is not allowed when the <i>xfsrestore</i> source is standard input (STDIN).<p>The following screen output shows an example of a simple interactive restoration.<PRE># <B>xfsrestore -f /dev/tape -i -v silent .</B>
xfsrestore: dump session found
xfsrestore: no session label
xfsrestore: session id:    d23cbeda-b21d-1001-8f97-080069068eeb
xfsrestore: no media label
xfsrestore: media id:      d23cbedb-b21d-1001-8f97-080069068eeb
do you want to select this dump? (y/n): <B>y</B>
selected

 --- interactive subtree selection dialog ---

the following commands are available:
        pwd 
        ls [ { &lt;name>, ".." } ]
        cd [ { &lt;name>, ".." } ]
        add [ &lt;name> ]
        delete [ &lt;name> ]
        extract 
        quit 
        help 
 -> <B>ls</B>
            4122 people/
            4130 two 
            4126 A/
            4121 one 
 -> <B>add two</B>
 -> <B>cd people</B>
 -> <B>ls</B>
            4124 fred/
 -> <B>add fred</B>
 -> <B>ls</B>
    *       4124 fred/
 -> <B>extract</B>

 ---------------- end dialog ----------------</PRE><p>In the interactive restore session above, the subdirectory <i>people/fred</i> and the file <i>two</i> were restored relative to the current working directory ("."). Note that an asterisk (*) in your <i>ls</i> output indicates your selections.<A NAME="SGI49"></A>
<h4 class="SGITPL-head">Performing Cumulative Restores with xfsrestore</h4><p>Cumulative restores sequentially restore incremental dumps to re-create filesystems and are also used to restore interrupted dumps. To perform a cumulative restore of a filesystem, begin with the media object that contains the base level dump and recover it first, then recover the incremental dump with the next higher dump level number, then the next, and so on. Use the ­r option to inform <i>xfsrestore</i> that you are performing a cumulative recovery. <p>In the following example, the level 0 base dump and succeeding higher level dumps are on <i>/dev/tape</i>. First the level 0 dump is restored, then each higher level dump in succession:<PRE># <B>/usr/tmp/xfsrestore -f /dev/tape -r -v silent .</B>

 =========================== dump selection dialog ============================

the following dump has been found on drive 0

hostname: cumulus
mount point: /disk2
volume: /dev/rdsk/dks0d2s0
session time: Wed Oct 25 14:37:47 1995
level: 0
session label: "week_1"
media label: "Jun_94"
file system id: d2a602fc-b21d-1001-8938-08006906dc5c
session id: d2a60b26-b21d-1001-8938-08006906dc5c
media id: d2a60b27-b21d-1001-8938-08006906dc5c

restore this dump?
1: skip
2: restore (default)
 -> <B>Enter</B>
this dump selected for restoral

 --------------------------------- end dialog ---------------------------------

#</PRE><p>Next, enter the same command again. The program goes to the next dump and again you select the default:<PRE># <B>xfsrestore -f /dev/tape -r -v silent .</B>

 =========================== dump selection dialog ============================

the following dump has been found on drive 0

hostname: cumulus
mount point: /disk2
volume: /dev/rdsk/dks0d2s0
session time: Wed Oct 25 14:40:54 1995
level: 1
session label: "week_2"
media label: "Jun_94"
file system id: d2a602fc-b21d-1001-8938-08006906dc5c
session id: d2a60b2b-b21d-1001-8938-08006906dc5c
media id: d2a60b27-b21d-1001-8938-08006906dc5c

restore this dump?
1: skip
2: restore (default)
 -> <B>Enter</B>
this dump selected for restoral

 --------------------------------- end dialog ---------------------------------
#</PRE><p>You then repeat this process until you have recovered the entire sequence of incremental dumps. The full and latest copy of the filesystem will then have been restored. In this case, it is restored relative to ".", that is, in the directory you are in when the sequence of <i>xfsrestore</i> commands is issued.<p>Restore an interrupted dump just as if it were an incremental dump. Use the -r option to inform <i>xfsrestore</i> that you are performing an incremental restore, and answer <TT><B>y</B></TT> and <TT><B>n</B></TT> appropriately to select the proper "increments" to restore (see <A HREF="IA_BakSecAcc-6.html#SGI49" TARGET=_top>"Performing Cumulative Restores with xfsrestore"</A>).<p>Note that if you try to restore an interrupted dump as if it were a non-interrupted, non-incremental dump, the portion of the dump that occurred before the interruption is restored, but not the remainder of the dump. You can determine if a dump is an interrupted dump by looking in the online inventory.<p>Here is an example of a dump inventory showing an interrupted dump session (the crucial fields are in bold type):<PRE># <B>xfsdump -I depth=3,mobjlabel=AugTape,mnt=indy4.xyz.com:/usr</B>
file system 0:
        fs id:          d23cb450-b21d-1001-8f97-080069068eeb
        session 0:
                mount point:    indy4.xyz.com.com:/usr
                device:         indy4.xyz.com.com:/dev/rdsk/dks0d3s2
                time:           Tue Dec  6 15:01:26 1994
                session label:  "180894usr"
                session id:     d23cc0c3-b21d-1001-8f97-080069068eeb
                level:          0
                resumed:        NO
                subtree:        NO
                streams:        1
                stream 0:
                        pathname:       /dev/tape
                        start:          ino 4121 offset 0
                        end:            ino 0 offset 0
                        <b>interrupted:    YES</b>
                        media files:    2
        session 1:
                mount point:    indy4.xyz.com.com:/usr
                device:         indy4.xyz.com.com:/dev/rdsk/dks0d3s2
                time:           Tue Dec  6 15:48:37 1994
                session label:  "Resumed180894usr"
                session id:     d23cc0cc-b21d-1001-8f97-080069068eeb
                level:          0
                <b>resumed:        YES</b>
                subtree:        NO
                streams:        1
                stream 0:
                        pathname:       /dev/tape
                        start:          ino 4121 offset 0
                        end:            ino 0 offset 0
                        <b>interrupted:    NO</b>
                        media files:    2
.
.
.</PRE><p>From this it can be determined that session 0 was interrupted and then resumed and completed in session 1.<p>To restore the interrupted dump session in the example above, use the following sequence of commands:<PRE># <B>xfsrestore -f /dev/tape -r -L 180894usr .</B>
# <B>xfsrestore -f /dev/tape -r -L Resumed180894usr .</B></PRE><p>This restores the entire <i>/usr</i> backup relative to the current directory. (You should remove the <i>housekeeping</i> directory from the destination directory when you are finished.)<A NAME="SGI50"></A>
<h4 class="SGITPL-head">Interrupting xfsrestore</h4><p>In a manner similar to <i>xfsdump</i> interruptions, you can interrupt an <i>xfsrestore</i> session. This allows you to interrupt a restore session and then resume it later. To interrupt a restore session, type the interrupt character (typically <TT><B>&lt;CTRL-C></B></TT>). You receive a list of options, which include interrupting the session or continuing.<PRE># <B>xfsrestore -f /dev/tape -v silent /disk2</B>

 =========================== dump selection dialog ============================

the following dump has been found on drive 0

hostname: cumulus
mount point: /disk2
volume: /dev/rdsk/dks0d2s0
session time: Wed Oct 25 17:20:16 1995
level: 0
session label: "week1"
media label: "newtape"
file system id: d2a602fc-b21d-1001-8938-08006906dc5c
session id: d2a6129e-b21d-1001-8938-08006906dc5c
media id: d2a6129f-b21d-1001-8938-08006906dc5c

restore this dump?
1: skip
2: restore (default)
 -> <B>2</B>
this dump selected for restoral

 --------------------------------- end dialog ---------------------------------


 ========================= status and control dialog ==========================

status at 17:23:52: 131/910 files restored, 14.4% complete, 42 seconds elapsed

please select one of the following operations
1: interrupt this session
2: change verbosity
3: display metrics
4: other controls
5: continue (default) (timeout in 60 sec)
 -> <B>1</B>

please confirm
1: interrupt this session
2: continue (default) (timeout in 60 sec)
 -> <B>1</B>
interrupt request accepted

 --------------------------------- end dialog ---------------------------------

xfsrestore: initiating session interrupt
</PRE><p>Resume the <i>xfsrestore</i> session with the ­R option:<PRE>#<B> xfsrestore -f /dev/tape -R -v silent /disk2</B></PRE><p>Data recovery continues from the point of the interruption.<A NAME="SGI51"></A>
<h4 class="SGITPL-head">About the housekeeping and orphanage Directories</h4><p>The <i>xfsrestore</i> utility can create two subdirectories in the destination called <i>housekeeping</i> and <i>orphanage</i>. <p>The <i>housekeeping</i> directory is a temporary directory used during cumulative recovery to pass information from one invocation of <i>xfsrestore</i> to the next. It must not be removed during the process of performing the cumulative recovery but should be removed after the cumulative recovery is completed.<p>The <i>orphanage</i> directory is created if a file or subdirectory is restored that is not referenced in the filesystem structure of the dump. For example, if you dump a very active filesystem, it is possible for new files to be in the non-directory portion of the dump, yet none of the directories dumped reference that file. A warning message is displayed, and the file is placed in the <i>orphanage</i> directory, named with its original inode number and generation count (for example, 123479.14.).<A NAME="SGI52"></A>
<h3 class="SGITPL-head">Using xfsdump and xfsrestore to Copy Filesystems</h3><p>You can use <i>xfsdump</i> and <i>xfsrestore</i> to pipe data across filesystems or across the network with a single command line. By piping <i>xfsdump</i> standard output to <i>xfsrestore</i> standard input you create an exact copy of a filesystem.<p>For example, to make a copy of <i>/usr/people/fred</i> in the <i>/usr2</i> directory, enter:<PRE># <B>xfsdump -J -s people/fred - /usr | xfsrestore - /usr2</B></PRE><p>To copy <i>/usr/people/fred</i> to the network host <i>magnolia</i>'s <i>/usr/tmp </i>directory:<PRE>#<B> xfsdump -J -s people/fred - /usr | rsh magnolia \</B>
<B>xfsrestore - /usr/tmp</B></PRE><p>This creates the directory <i>/usr/tmp/people/fred</i> on <i>magnolia</i>.<P><B>Note: </B>The superuser account on the local system must be able to <i>rsh</i> to the remote system without a password. For more information, see hosts.equiv(4).<HR noshade><A NAME="SGI53"></A>
<h2 class="SGITPL-head">About tar</h2><p>The <i>tar</i> (tape archive) utility backs up files and directories. You can copy files to tape, create <i>tar</i> files, compare files on tape to files on disk, read standard input, and pipe the output of<i> tar</i> to other processes. This command is widely used on UNIX systems worldwide. See tar(1) for more details.<P><B>Note: </B>The -K option of <i>tar</i> is for files larger than 2 GB. Without the -K option, <i>tar</i> skips any files larger than 2 GB and issues a warning. Note that use of this option can create <i>tar</i> archives that are unusable except on XFS systems. The -K option is incompatible with the -O option, which creates an old (pre-POSIX) <i>tar</i> archive format.<A NAME="SGI54"></A>
<h3 class="SGITPL-head">Backing Up Files with tar</h3><p>To back up individual files with <i>tar</i>, use the command:<pre><B>tar c </B><var>file</var></pre><A NAME="SGI55"></A>
<h3 class="SGITPL-head">Using tar to Back Up Files by Modification Date </h3><p>The <i>tar</i> command does not have the capability of saving files by modification date built in. However, you can use the <i>find</i> command to archive files that have not been modified in a particular number of days: <pre><B>find /usr -mtime 5 -local -type f -o -type </B><var>othertypes</var><B> -print | tar cv -</B></pre><p>The <i>find</i> command locates regular, local (non-NFS) files that have not been modified in five days. The <i>find</i> command sends its output to the <i>tar</i> command. <A NAME="SGI56"></A>
<h3 class="SGITPL-head">Performing Incremental Backups with tar</h3><p>Although <i>tar</i> does not have a built-in mechanisms for incremental backups, you can use other system commands to accomplish this task.<p>The following example uses the same incremental scheme presented in the preceding section to back up the <i>/usr</i> filesystem. It uses the <i>find</i> command to determine which files to archive:<ol><li>Go to the top of the filesystem that you want to back up. For example:<pre><B>cd /usr</B> </pre><li>Create a complete backup of the filesystem:<pre><B>tar cv .</B> </pre><li>Each day, back up the files that have changed since the previous daily backup:<pre><B>find /usr -mtime 1 -local -print | tar cvf -</B> </pre><li>Every week, back up the files that have changed since the last weekly backup:<pre><B>find /usr -mtime 7 -local -type f -print | tar cvf -</B> </pre><li>At the end of four weeks, perform a complete backup and start the process over.</ol><A NAME="SGI57"></A>
<h3 class="SGITPL-head">Improving tar Performance</h3><p>In general, increasing block size improves tape write and read performance. The IRIX <i>tar</i> command automatically queries tape devices to determine the optimum block size. Very large block sizes could cause portability problems; see tar(1) for details (b option).<A NAME="SGI58"></A>
<h3 class="SGITPL-head">Examining tar Archives</h3><p>For <i>tar</i> archives, use the v keyword for verbose listing of the archive contents:<pre><B>tar tv</B> </pre><p>You can compare files that are archived with the original files using <i>tar</i>:<pre><B>tar C</B> </pre><p>You see messages about the status of the files. Each message begins with a key character (a letter or symbol) that signifies the status of the file in the archive versus the original file. These characters are shown in <A HREF="IA_BakSecAcc-6.html#SGITF4" TARGET=_top>Table 2-3</A>.<TABLE BORDER CELLPADDING=10><p><A NAME="SGITF4"></A><CAPTION ALIGN=TOP><B>Table 2-3 :  </B>tar File Comparison Key Characters</CAPTION><TR VALIGN=TOP ALIGN=LEFT><TH>Key</TH><TH>Meaning</TH><TR ALIGN=LEFT VALIGN=TOP><TD><p>=</TD><TD><p>The files compare</TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p>!</TD><TD><p>The files don't compare</TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p>?</TD><TD><p>Can't read the disk file</TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p>></TD><TD><p>Disk file doesn't exist</TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p>L</TD><TD><p>Linked to an earlier file on the tape</TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p>S</TD><TD><p>Symbolic link</TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p>B</TD><TD><p>Block special file</TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p>C </TD><TD><p>Character special file</TD></TR><TR ALIGN=LEFT VALIGN=TOP><TD><p>P</TD><TD><p>Named pipe</TD></TR></TABLE> <br><br><A NAME="SGI59"></A>
<h3 class="SGITPL-head">Restoring tar Archives</h3><p>To recover individual files from a <i>tar</i> archive, specify the name of the files on the command line:<pre><B>tar xv </B><var>file1 file2 directory/file3</var> </pre><HR noshade><A NAME="SGI60"></A>
<h2 class="SGITPL-head">About cpio</h2><p>Like <i>tar</i>, <i>cpio</i> archives files and directories. With <i>cpio</i>, you can copy files to tape or disk, archive empty directories, swap byte order, create portable ASCII archives, and read from and write to standard output. The <i>cpio</i> utility is also useful for copying files and directories when the cp(1) command is unable to do so. For example, you cannot use <i>cp</i> to copy a directory to a different filesystem.<p>The <i>cpio</i> command is also the command used by the System Manager to create backups. If you are using a server and do not have access to the graphical System Manager, you may use <i>cpio</i> instead. Backups made with <i>cpio</i> are readable by the System Maintenance Menu and Command Monitor. <P><B>Note: </B>XFS and <i>cpio</i>: Use the -K option with the cpio(1) command for files larger than 2 GB. If the -K option is not used, <i>cpio</i> skips any files larger than 2 GB and issues a warning. Note that use of this option can create <i>cpio</i> archives that are not usable on non-XFS systems. The -K option can be used only with the -o (output) option. The -K option cannot be used the -c option (which creates <i>cpio</i> archives with ASCII headers), or with the -H option (used to specify various header formats).<A NAME="SGI61"></A>
<h3 class="SGITPL-head">Backing Up Files with cpio</h3><p>To back up files with <i>cpio</i>, use the command:<pre><B>cat </B><var>filelist</var><B> | cpio -o > /dev/tape</B> </pre><P><B>Tip: </B>For portability to other systems, especially non-IRIX systems, use the -H odc option to create textual header information with small device numbers, and perhaps the -B option to set block size to 5120 bytes per record. Without the -B option, <i>cpio</i> queries the device to determine its recommended block size.<A NAME="SGI62"></A>
<h3 class="SGITPL-head">Using cpio to Back Up Files by Modification Date</h3><p>The <i>cpio</i> command does not have the capability of saving files by modification date built in. However, you can use the <i>find</i> command to archive files that have not been modified in a particular number of days: <pre><B>find /usr -depth -mtime 5 -print | cpio -ocvO /dev/tape</B> </pre><p>The <var>-depth</var> argument causes <i>find</i> to print the name of the directory after printing the files in that directory. This ensures that <i>cpio</i> has permission to place the files in the directory in case the directory is read-only. The -O option designates the output file.<A NAME="SGI63"></A>
<h3 class="SGITPL-head">Performing Incremental Backups with cpio</h3><p>Although <i>tar</i> and <i>cpio</i> do not have built-in mechanisms for incremental backups, you can use other system commands to accomplish this task.<p>The following example uses the same incremental scheme presented in the preceding section to back up the <i>/usr</i> filesystem. It uses the <i>find</i> command to determine which files to archive:<ol><li>Go to the top of the filesystem that you want to back up, and create a complete backup of the filesystem:<PRE><B>cd /usr</B> 
<B>find . -depth -print | cpio -ocLO /dev/tape</B> </PRE><li>Each day, back up the files that have changed since the previous daily backup:<PRE><B>cd /usr</B> 
<B>find . -depth -mtime 1 -print | cpio -ocLO /dev/tape</B> </PRE><li>Every week, back up the files that have changed since the last weekly backup:<PRE><B>cd /usr</B> 
<B>find . -depth -mtime 7 -print | cpio -ocLO /dev/tape</B> </PRE><li>At the end of four weeks, perform a complete backup and start the process over.</ol><A NAME="SGI64"></A>
<h3 class="SGITPL-head">Examining cpio Archives</h3><p>For <i>cpio</i> archives, use the following command to obtain a verbose listing:<pre><B>cpio -itvI /dev/tape</B> </pre><p>The -t option prints a table of contents, the -v option means verbose, and the -I option designates the input file.<p>The <i>cpio</i> program does not have a built-in option to compare files. To compare the files on a <i>cpio</i> archive, you must extract the archive onto disk, then use a comparison program, such as diff(1), cmp(1), or dircmp(1), or compare the checksum of the extracted file with that of the original using sum(1).<A NAME="SGI65"></A>
<h3 class="SGITPL-head">Restoring cpio Archives</h3><p>To recover individual files from a <i>cpio </i>archive, specify the name of the file(s) on the command line:<pre><B>cpio -id </B><var>file1 directory/file2</var><B> &lt; /dev/tape</B> </pre><p>The -i option causes <i>cpio</i> to read input from the tape drive, and the -d option causes it to create the directory it is extracting, if it does not already exist.<HR noshade><A NAME="SGI66"></A>
<h2 class="SGITPL-head">About dd</h2><p>The <i>dd</i> program reads from a specified input file (<var>stdin</var> is the default), performs whatever conversions you specify, and writes the result to a specified output file (<var>stdout</var> is the default). It is not specifically a backup tool, but has many extremely useful features, including the ability to:<ul><li>skip specific blocks in an archive <br><br><li>skip blocks of output <br><br><li>specify input and output block size <br><br><li>copy a specific number of blocks <br><br><li>perform various data conversions such as byte swapping</ul><p>Refer to the dd(1M) reference page for details on the use of the <i>dd</i> command.<HR noshade><A NAME="SGI67"></A>
<H1 class="SGITPL-head">Chapter 3<BR> Troubleshooting Backup and Recovery</h1><p>From time to time you might experience backup failures. It is vitally important that you determine the cause of the failure. Most often, the failure is due to worn or faulty media. Proceeding without determining the cause of a failure makes all your future backups suspect and defeats the purpose of backups. <p>This chapter contains the following sections:<ul><li><A HREF="IA_BakSecAcc-6.html#SGI68" TARGET=_top>"Troubleshooting Unreadable Backups"</A><br><br><li><A HREF="IA_BakSecAcc-6.html#SGI69" TARGET=_top>"Reading Media from Other Systems"</A><br><br><li><A HREF="IA_BakSecAcc-6.html#SGI70" TARGET=_top>"Troubleshooting Errors During Backup"</A><br><br><li><A HREF="IA_BakSecAcc-6.html#SGI71" TARGET=_top>"Restoring the Correct Backup After the Wrong One"</A><br><br><li><A HREF="IA_BakSecAcc-6.html#SGI72" TARGET=_top>"Testing for Bad Media"</A><br><br><li><A HREF="IA_BakSecAcc-6.html#SGI73" TARGET=_top>"Backup and Recovery Error Messages and Actions"</A></ul><HR noshade><A NAME="SGI68"></A>
<h2 class="SGITPL-head">Troubleshooting Unreadable Backups</h2><p>The reasons a backup might be unreadable include:<ul><li>The data on the backup tape is corrupted due to age or media fault. <br><br><li>The tape head is misaligned now, or was when the backup was made.<br><br><li>The tape head is dirty now, or was when the backup was made.</ul><p>Check <i>/var/adm/SYSLOG</i> to see if your tape drive is reporting any of these conditions.<HR noshade><A NAME="SGI69"></A>
<h2 class="SGITPL-head">Reading Media from Other Systems</h2><p>You may not be able to read data created on another vendor's workstation, even if it was made using a standard utility, such as <i>tar</i> or <i>cpio</i>. One problem may be that the tape format is incompatible. Make sure the tape drive where the media originated is compatible with your drive.<p>If you are unable to verify that the drives are completely compatible, use <var>dd</var> to see if you can read the tape at the lowest possible level. Place the tape in the drive and enter the command:<pre><B>mt blksize</B></pre><p>The mt(1) command with these options tells you the block size used to write the tape. Set the block size correspondingly (or larger) when you use <i>dd</i> to read the tape. For example, if the block size used was 1024 bytes, use the command:<pre><B>dd if=/dev/tape of=/usr/tmp/</B><var>outfile</var><B> bs=1024</B></pre><p>If <i>dd</i> can read the tape, it displays a count of the number of records it read in and wrote out. If <i>dd</i> cannot read the tape, make sure your drive is clean and in good working order. Test the drive with a tape you made on your system. <p>If you can read the tape with <i>dd</i>, and the tape was created using a standard utility, such as <i>tar</i> or <i>cpio</i>, you may be able to convert the data format with <i>dd</i>. Several conversions may help:<ul><li>swab­swap every pair of bytes <br><br><li>sync­pad every input block to ibs <br><br><li>block­convert ASCII to blocked ASCII <br><br><li>unblock­convert blocked ASCII to ASCII <br><br><li>noerror­do not stop processing on an error</ul><p>The <i>dd</i> program can convert some completely different formats:<ul><li>ascii­convert EBCDIC to ASCII <br><br><li>ebcdic­convert ASCII to EBCDIC <br><br><li>ibm­slightly different map of ASCII to EBCDIC</ul><p>Converting case of letters:<ul><li>lcase­map alphabetics to lowercase <br><br><li>ucase­map alphabetics to uppercase</ul><p>If the data was written on another vendor's system, you may be able to convert it using <i>dd</i>, then pipe the converted output to another utility to read it.<p>Many other vendors use byte-ordering that is the reverse of the order used by IRIX. If this is the case, you can swap them with the following command:<pre><B>dd if=/dev/tape conv=swab of=/usr/tmp.O/</B><var>tapefile</var> </pre><p>Then use the appropriate archiving utility to extract the information from <i>/tmp/tapefile</i> (or whatever filename you choose). For example, use this command to extract information if the tar utility was used to make the tape on a byte-swapped system:<pre><B>tar xvf /usr/tmp.O/tapefile .</B> </pre><p>Note that you could also pipe the <i>dd</i> output to another local or remote tape drive (if available) if you do not need or want to create a disk file.<p>Or you can use the no-swap tape device to read your files with the following <i>tar</i> command line:<p><TT><B>tar xvf /dev/rmt/tps0d4ns</B></TT><p>Of course, if your tape device is not configured on SCSI unit 4, the exact <i>/dev/rmt</i> device name may be slightly different. For example, it could be <i>/dev/rmt/tps0d3ns</i>. <p>It is good practice to preview the contents of a <i>tar</i> archive with the t keyword before extracting. If the tape contains a system file and was made with absolute pathnames, that system file on your system could be overwritten. For example, if the tape contains a kernel, <i>/unix</i>, and you extract it, your own system kernel will be destroyed. The following command previews the above example archive:<pre><B>tar tvf /tmp/</B><var>tarfile</var> </pre><p>If you wish to extract such a tape on your system without overwriting your current files, use this command to force the extraction to use relative pathnames:<pre><B>tar Rx</B> </pre><p>or the corresponding <i>bru</i> command:<pre><B>bru -j</B> </pre><HR noshade><A NAME="SGI70"></A>
<h2 class="SGITPL-head">Troubleshooting Errors During Backup</h2><p>If you see errors on the system console when trying to create a backup, some causes are:<ul><li>The tape is not locked in the drive. You may see an error message similar to this:<pre>/dev/nrtape rewind 1 failed:Resource temporarily unavailable </pre><p>Make sure the tape is locked in the drive properly. See your <i>Owner's Guide</i> if you do not know how to lock the tape in the drive. <br><br><li>File permission problems. These are especially likely with file-oriented backup programs; make sure you have permission to access all the files in the hierarchy you are backing up. <br><br><li>The drive requires cleaning and maintenance. <br><br><li>Bad media; see <A HREF="IA_BakSecAcc-6.html#SGI72" TARGET=_top>"Testing for Bad Media"</A>.</ul><p>If you encounter problems creating backups, fixing the problem should be your top priority.<HR noshade><A NAME="SGI71"></A>
<h2 class="SGITPL-head">Restoring the Correct Backup After the Wrong One</h2><p>If you accidentally restore the wrong backup, you should rebuild the system from backups. Unless you are very sure of what you are doing, you should not simply restore the correct backup version over the incorrect version. This is because the incorrect backup may have altered files that the correct backup won't restore.<p>In the worst possible case, you may have to reinstall the system, then apply backups to bring it to the desired state. Here are some basic steps to recovering a filesystem. <p>If you used incremental backups, such as from <i>backup</i> or <i>bru</i>:<ol><li>Make a complete backup of the current state of the filesystem. If you successfully recover the filesystem, you will not need this particular backup. But if there is a problem, you may need to return to the current, though undesirable, state. <br><br><li>Start with the first complete backup of the filesystem that was made prior to the backup that you want to have when you're finished. Restore this complete backup. <br><br><li>Apply the series of incremental backups until you reach the desired (correct) backup.</ol><p>If you accidentally restored the wrong file-oriented backup (such as a <i>tar</i> or <i>cpio</i> archive):<ol><li>Make a complete backup of the affected filesystem or directory hierarchy. You may need this not only as protection against an unforeseen problem, but to fill any gaps in your backups. <br><br><li>Bring the system to the condition it was in just before you applied the wrong backup.<p>If you use an incremental backup scheme, follow steps 2 and 3 above (recovering from the wrong incremental backup).<p>If you use only utilities such as <i>tar</i> and <i>cpio</i> for backups, use what backups you have to get the system to the desired state. <br><br><li>Once the system is as close as possible to the correct state, restore the correct backup. You are finished. If the system is in the desired state, skip the remaining steps.<p>If you cannot bring the system to the state it was in just before you applied the wrong backup, continue with the next series of steps. <br><br><li>If you cannot manage to bring the system to the correct state (where it was just before you restored the wrong backup), get it as close as possible. <br><br><li>Make a backup of this interim state. <br><br><li>Compare the current interim state with the backup you made at the outset of this process (with the incorrect backup applied) and with the backup you wish to restore. Note which files changed, which were added and removed, and which files remain unchanged in the process of bringing the system to the desired state.<p>Using these notes, manually extract the correct versions of the files from the various tapes.</ol><HR noshade><A NAME="SGI72"></A>
<h2 class="SGITPL-head">Testing for Bad Media</h2><p>Even the best media can go bad over time. Symptoms are:<ul><li>Data appears to load onto the tape correctly, but the backup fails verification tests. (This is a good reason to always verify backups immediately after you make them.)<p>Another tape is then able to back up the data successfully and pass verification tests. <br><br><li>Data retrieved from the tape is corrupted, while the same data loaded onto a different tape is retrieved without problems. <br><br><li>The backup media device driver (such as the SCSI tape driver) displays errors on the system console when trying to access the tape. <br><br><li>You are unable to write information onto the tape.</ul><p>If errors occur when you try to write information on a tape, make sure the tape is not simply write-protected. Be sure you are using the correct length and density tape for your drive.<p>Make sure that your drive is clean and that tape heads are aligned properly. It is especially important to check tape head alignment if a series of formerly good tapes suddenly appear to go bad.<p>Once you are satisfied that a tape is bad, mark it as a bad tape and discard it. Be sure to mark it "bad" to prevent someone else from accidentally using it.<HR noshade><A NAME="SGI73"></A>
<h2 class="SGITPL-head">Backup and Recovery Error Messages and Actions</h2><p>Following are some of the possible error messages you may see that indicate problems with a backup or recovery.<dl><dt><pre>unix: dks0d1s0: Process [tar] ran out of disk space</pre></dt><dd><p>This error, or similar errors reporting a shortage of disk space, may occur if you are backing up data to a disk partition that does not have enough free space left to contain the data to be backed up. <p>Such errors may likewise occur in data restores if the data being recovered does not fit on the destination disk partition. Note that if you are uncompressing data that was compressed for backup, the uncompressed data could easily require twice as much space as the compressed data.<p>You may wish to add disk space, reclaim disk space, repartition existing disk space (see <i></i>IRIX Admin: Disks and Filesystems    <i></i>), or redesign your backup procedure, for example, to use data compression (see <A HREF="IA_BakSecAcc-6.html#SGI21" TARGET=_top>"Saving Files Using Data Compression"</A>).</dd></dl><dl><dt><pre>unix: ec0: no carrier: check Ethernet cable</pre></dt></dl><dl><dt><pre>unix: NFS write error 151 on host garfield</pre></dt></dl><dl><dt><pre>unix: NFS2 getattr failed for server some.host.name: Timed out</pre></dt><dd><p>These and similar network errors only represent a problem if you are using network resources (for example, a remote tape or disk drive) in your backup or recovery procedure. If this is the case, reestablish proper network connections (see <i></i>IRIX Admin: Networking and Mail    <i></i>) and either verify that your backup or recovery was successful or reinitiate it.</dd></dl><dl><dt><pre>unix: Tape 3: Hardware error, Non-recoverable</pre></dt></dl><dl><dt><pre>unix: Tape 3: requires cleaning</pre></dt></dl><dl><dt><pre>unix: Tape 3: Unrecoverable media error</pre></dt></dl><dl><dt><pre>unix: NOTICE: SCSI tape #0, 6 had 1 successful retried commands</pre></dt></dl><dl><dt><pre>unix: NOTICE: SCSI tape #0,7 Incompatible media when reading</pre></dt></dl><dl><dt><pre>Could not access device /dev/rmt/tps0d6nr, Device busy</pre></dt><dd><p>These are all examples of tape access errors. Depending on whether you were trying to back up or recover data, the system encountered a problem writing or reading the tape. Be sure there is a tape in the drive indicated in the error message, and that it is not set on write-protect if you are attempting a backup. (Also, tape drives should be periodically cleaned according to manufacturer instructions.)<p>If these are not the problem, test the tape for read and/or write capabilities using one or more of the backup and recover utilities. Note that a media error can occur anywhere on a tape; to verify the tape, write and read the entire tape. You can also select "Run Confidence Tests" from the System toolchest and double-click on the Tape Drive test.<p>If you have any doubts about the quality of the tape you're using (for example, it is getting old), copy it to a new tape (if it still has good data) and discard it. If you are using a tape drive that you have not used before, verify that the tape type is compatible with the new drive. Run the mt(1) command to reset the tape drive. Run the hinv(1M) command to determine if the tape drive is recognized by the system.</dd></dl><p>A "device already in use" or "device busy" error probably means that some other program was using the tape drive when you tried to access it.
      

<!-- dtlbook2html START -->
<HR noshade>
<FONT SIZE="-1"><A HREF="index.html"><B>IRIX Admin: Backup, Security, and Accounting</B></A><P><A HREF="IA_BakSecAcc-5.html"><IMG SRC="images/b_prev.gif" ALT="Prev" WIDTH=17 HEIGHT=17 BORDER=0 ALIGN=TOP></A>&nbsp; <A HREF="IA_BakSecAcc-7.html"><IMG SRC="images/b_next.gif" ALT="Next" WIDTH=17 HEIGHT=17 BORDER=0 ALIGN=TOP></A>&nbsp;&nbsp;&nbsp;&nbsp;Table of Contents:&nbsp;&nbsp;<A HREF="index.html">Basic</A>&nbsp;&nbsp;|&nbsp;&nbsp;<A HREF="fulltoc.html">Expanded</A></P></FONT>
<!-- dtlbook2html END -->

<HR noshade>
</BODY>
</HTML>
