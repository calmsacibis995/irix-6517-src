<!-- Produced by version 3.12 (09/13/95) of SGI Frame/SGML translator -->
<CHAPTER LBL="4"><TITLE><XREFTARGET ID="92397">XLV Logical Volumes</TITLE><PARAGRAPH>This chapter provides an overview of the XLV Volume Manager and explains how to create and administer XLV logical volumes. The use of logical volumes enables the creation of filesystems or raw devices that span more than one disk partition. Logical volumes behave like regular disk partitions. Filesystems can be created, mounted, and used in the normal way, or they can be used as raw devices.<INDEXTARGET ID="ch41"><!-- POSTPROCESSDATA: ch41|logical volumes:used as raw devices --><INDEXTARGET ID="ch42"><!-- POSTPROCESSDATA: ch42|logical volumes:disk labels --><INDEXTARGET ID="ch43"><!-- POSTPROCESSDATA: ch43|XLV:logical volumes. <ITALICS>See</ITALICS> logical volumes. --><INDEXTARGET ID="ch44"><!-- POSTPROCESSDATA: ch44|logical volumes:<ITALICS>lv</ITALICS>. <ITALICS>See lv</ITALICS> logical volumes. --><INDEXTARGET ID="ch45"><!-- POSTPROCESSDATA: ch45|logical volumes:<ITALICS>See also</ITALICS> XLV. --><INDEXTARGET ID="ch46"><!-- POSTPROCESSDATA: ch46|XLV:<ITALICS>See also</ITALICS> logical volumes. --></PARAGRAPH>
<PARAGRAPH>This chapter contains these main sections:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="21927" TYPE="TITLE">&ldquo;XLV Overview&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="83099" TYPE="TITLE">&ldquo;Planning a Logical Volume&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="25568" TYPE="TITLE">&ldquo;Using xlv_make to Create Volume Objects&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="64725" TYPE="TITLE">&ldquo;Preparing a Logical Volume for Use&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="63965" TYPE="TITLE">&ldquo;Converting lv Logical Volumes to XLV&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="34840" TYPE="TITLE">&ldquo;Using xlv_admin to Administer Logical Volumes&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="94109" TYPE="TITLE">&ldquo;Using the Real-Time Subvolume&rdquo;</XREF></PARAGRAPH>
</BULLET>
</BULLETLIST>
<NOTE><PREFIX>Note</PREFIX>One feature of the XLV Volume Manager described in this chapter, plexing (mirroring), is available only when you purchase the Disk Plexing Option software option. See the <INDEXTARGET ID="ch47"><!-- POSTPROCESSDATA: ch47|Disk Plexing Option --><INDEXTARGET ID="ch48"><!-- POSTPROCESSDATA: ch48|NetLS licenses:Disk Plexing Option --><INDEXTARGET ID="ch49"><!-- POSTPROCESSDATA: ch49|plexes:Disk Plexing Option --><DOCTITLE>plexing Release Notes</DOCTITLE> for information on purchasing this software option and obtaining the required NetLS license.</NOTE>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="21927">XLV Overview</TITLE><PARAGRAPH>Traditionally, UNIX systems represent disk partitions as block and character devices. These &ldquo;devices&rdquo; are actually kernel-based interfaces that allow applications to access the partitions on either a character or block basis. The actual disk interactions are performed by disk device drivers.<INDEXTARGET ID="ch410"><!-- POSTPROCESSDATA: ch410|XLV:overview --><INDEXTARGET ID="ch411"><!-- POSTPROCESSDATA: ch411|disk partitions:block and character devices --></PARAGRAPH>
<PARAGRAPH>Some applications, such as high-performance databases, access these partition devices directly for maximum performance. However, most applications simplify their disk access by interfacing with filesystems. Filesystems isolate applications from the concerns of disk management by providing the familiar file and directory model for disk access.</PARAGRAPH>
<PARAGRAPH>XLV interposes another layer into this model by building<INDEXTARGET ID="ch412"><!-- POSTPROCESSDATA: ch412|logical volumes:description --><INDEXTARGET ID="ch413"><!-- POSTPROCESSDATA: ch413|EFS filesystems:and XLV logical volumes --><ITALICS>&space;logical volumes</ITALICS> (also known as <ITALICS>volumes</ITALICS>) on top of the partition devices. Volumes appear as block and character devices in the <FILENAME>/dev</FILENAME> directory. Filesystems, databases, and other applications access the volumes rather than the partitions. Logical volumes provide services such as disk plexing (also known as mirroring) and striping transparently to the applications that access the volumes. A logical volume might include partitions from several physical disk drives and, thus, be larger than any of the physical disks. EFS or XFS filesystems can be made on XLV logical volumes. </PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Composition of Logical Volumes</TITLE><PARAGRAPH>Logical volumes are composed of a hierarchy of logical storage objects: volumes are composed of subvolumes, subvolumes are composed of plexes, and plexes are composed of volume elements. Volume elements are composed of disk partitions. This hierarchy of storage units is shown in <INDEXTARGET ID="ch414"><!-- POSTPROCESSDATA: ch414|logical volumes:hierarchy of objects --><INDEXTARGET ID="ch415"><!-- POSTPROCESSDATA: ch415|logical volumes:example (figure) --><XREF IDREF="99451" TYPE="GRAPHIC">Figure&nbsp;4-1</XREF>, an example of a relatively complex logical volume.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="Fig4-1.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="4-1"><PREFIX>Figure 4-1 </PREFIX><XREFTARGET ID="99451">Logical Volume Example</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH><XREF IDREF="99451" TYPE="GRAPHIC">Figure&nbsp;4-1</XREF> illustrates the relationships between volumes, subvolumes, plexes, and volume elements. In this example, six physical disk drives contain eight disk partitions. The logical volume has a log subvolume, a data subvolume, and a real-time subvolume. The log subvolume has two plexes (copies of the data) for higher reliability and the data and real-time subvolumes are not plexed (meaning that they each consist of a single plex). The log plexes each consist of a volume element which is a disk partition on disk 1. The plex of the data subvolume consists of two volume elements, a partition that is the remainder of disk 1 and a partition that is all of disk 2. The plex used for the real-time subvolume is striped for increased performance. The striped volume element is constructed from four disk partitions, each of which is an entire disk.</PARAGRAPH>
<PARAGRAPH>The subsections below describe these logical storage objects in more detail.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="85862">Volumes</TITLE><PARAGRAPH>Volumes are composed of subvolumes. For EFS filesystems, a volume consists of just one subvolume. For XFS filesystems, a volume consists of a data subvolume, an optional log subvolume, and an optional real-time subvolume. The breakdown of a volume into subvolumes is shown in <INDEXTARGET ID="ch416"><!-- POSTPROCESSDATA: ch416|volumes. <ITALICS>See</ITALICS> logical volumes. --><INDEXTARGET ID="ch417"><!-- POSTPROCESSDATA: ch417|logical volumes:definition of volume --><INDEXTARGET ID="ch418"><!-- POSTPROCESSDATA: ch418|logical volumes:volume composition --><XREF IDREF="56177" TYPE="GRAPHIC">Figure&nbsp;4-2</XREF>.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="Fig4-2.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="4-2"><PREFIX>Figure 4-2 </PREFIX><XREFTARGET ID="56177">Volume Composition</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>Each volume can be used as a single filesystem or as a raw partition. Volume information used by the system during system startup is stored in disk labels on each disk used by the volume. At system startup, volumes won't come up if any of their subvolumes cannot be brought online. You can create volumes, delete them, and move them to another system.<INDEXTARGET ID="ch419"><!-- POSTPROCESSDATA: ch419|logical volumes:used as raw devices --><INDEXTARGET ID="ch420"><!-- POSTPROCESSDATA: ch420|logical volumes:disk labels --><INDEXTARGET ID="ch421"><!-- POSTPROCESSDATA: ch421|disk labels:information used at system startup --><INDEXTARGET ID="ch422"><!-- POSTPROCESSDATA: ch422|logical volumes:coming up at system startup --><INDEXTARGET ID="ch423"><!-- POSTPROCESSDATA: ch423|logical volumes:moving to a new system --></PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Subvolumes</TITLE><PARAGRAPH>As explained in the section<INDEXTARGET ID="ch424"><!-- POSTPROCESSDATA: ch424|logical volumes:<ITALICS>See also</ITALICS> subvolumes. --><INDEXTARGET ID="ch425"><!-- POSTPROCESSDATA: ch425|subvolumes:composition --><INDEXTARGET ID="ch426"><!-- POSTPROCESSDATA: ch426|subvolumes:<ITALICS>See also</ITALICS> logical volumes. --><XREF IDREF="85862" TYPE="TITLE">&ldquo;Volumes,&rdquo;</XREF> each logical volume is composed of one to three subvolumes, as shown in <XREF IDREF="81241" TYPE="GRAPHIC">Figure&nbsp;4-3</XREF>. A subvolume is made up of one to four plexes.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="Fig4-3.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="4-3"><PREFIX>Figure 4-3 </PREFIX><XREFTARGET ID="81241">Subvolume Composition</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>Each subvolume is a distinct address space and a distinct type. The types of subvolumes are:<INDEXTARGET ID="ch427"><!-- POSTPROCESSDATA: ch427|subvolumes:subvolume types --></PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>Data subvolume</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The data subvolume is required in all logical volumes. It is the only subvolume present in EFS filesystems.<INDEXTARGET ID="ch428"><!-- POSTPROCESSDATA: ch428|subvolumes:data subvolume definition --></PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>Log subvolume</HANGITEM>
<HANGBODY><PARAGRAPH>The log subvolume contains XFS journaling information. It is a log of filesystem transactions and is used to expedite system recovery after a crash. Log information is sometimes put in the data subvolume rather than in a log subvolume (see the section <INDEXTARGET ID="ch429"><!-- POSTPROCESSDATA: ch429|subvolumes:log subvolume definition --><INDEXTARGET ID="ch430"><!-- POSTPROCESSDATA: ch430|journaling information --><INDEXTARGET ID="ch431"><!-- POSTPROCESSDATA: ch431|XFS:journaling information --><XREF IDREF="93345" TYPE="TITLE">&ldquo;Choosing the Log Type and Size&rdquo; in Chapter&nbsp;2</XREF> and the <COMMAND>mkfs_xfs</COMMAND>(1M) reference page and its discussion of the <BOLD>&ndash;l</BOLD> option for more information).</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>Real-time subvolume</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Real-time subvolumes are generally used for data applications such as video, where guaranteed response time is more important than data integrity. The section <INDEXTARGET ID="ch432"><!-- POSTPROCESSDATA: ch432|subvolumes:real time subvolume definition --><XREF IDREF="94109" TYPE="TITLE">&ldquo;Using the Real-Time Subvolume&rdquo;</XREF> in this chapter and <XREF IDREF="23852" TYPE="TITLE">Chapter&nbsp;5, &ldquo;Guaranteed-Rate I/O,&rdquo;</XREF> explain how applications access data on real-time subvolumes.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>Subvolumes enforce separation among data types. For example, user data cannot overwrite filesystem log data. Subvolumes also enable filesystem data and user data to be configured to meet goals for performance and reliability. For example, performance can be improved by putting subvolumes on different disk drives.</PARAGRAPH>
<PARAGRAPH>Each subvolume can be organized independently. For example, the log subvolume can be plexed for fault tolerance and the real-time subvolume can be striped across a large number of disks to give maximum throughput for video playback.</PARAGRAPH>
<PARAGRAPH>Volume elements that are part of a real-time subvolume should not be on the same disk as volume elements used for data or log subvolumes. This is a recommendation for all files on real-time subvolumes and required for files used for guaranteed-rate I/O with hard guarantees. (See <INDEXTARGET ID="ch433"><!-- POSTPROCESSDATA: ch433|real-time subvolumes:only real-time on disk --><XREF IDREF="26694" TYPE="TITLE">&ldquo;Hardware Configuration Requirements for GRIO&rdquo; in Chapter&nbsp;5</XREF> for more information.)</PARAGRAPH>
<PARAGRAPH>You can create subvolumes, but you cannot detach them from their volumes or delete them. A subvolume is automatically deleted when the volume is deleted.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Plexes</TITLE><PARAGRAPH>A subvolume can contain from one to four <INDEXTARGET ID="ch434"><!-- POSTPROCESSDATA: ch434|plexes:definition --><INDEXTARGET ID="ch435"><!-- POSTPROCESSDATA: ch435|plexes:<ITALICS>See also</ITALICS> logical volumes. --><ITALICS>plexes</ITALICS> (sometimes called <ITALICS>mirrors</ITALICS>). Each plex contains a portion or all of the subvolume's data. By creating a volume with multiple plexes, system reliability is increased.</PARAGRAPH>
<PARAGRAPH>If there is just one plex in a subvolume, that plex spans the entire address space of the subvolume. However, when there are multiple plexes, individual plexes can have holes in their address spaces as long as the union of all plexes spans the entire address space.<INDEXTARGET ID="ch436"><!-- POSTPROCESSDATA: ch436|plexes:holes in address space --></PARAGRAPH>
<PARAGRAPH>Normally, data is written to all plexes. However, when necessary (for example when an additional plex is added to a subvolume), a full plex copy, called a <INDEXTARGET ID="ch437"><!-- POSTPROCESSDATA: ch437|plexes:plex revive definition --><ITALICS>plex revive</ITALICS>, is done automatically by the system. See the <COMMAND>xlv_assemble</COMMAND>(1M) and <COMMAND>xlv_plexd</COMMAND>(1M) reference pages for more information.</PARAGRAPH>
<PARAGRAPH>A plex is composed of one or more volume elements, as shown in <INDEXTARGET ID="ch438"><!-- POSTPROCESSDATA: ch438|plexes:plex composition --><XREF IDREF="37521" TYPE="GRAPHIC">Figure&nbsp;4-4</XREF>, up to a maximum of 128 volume elements. Each volume element represents a range of addresses within the subvolume. </PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="Fig4-4.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="4-4"><PREFIX>Figure 4-4 </PREFIX><XREFTARGET ID="37521">Plex Composition</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>When a plex is composed of two or more volume elements, it is said to have <INDEXTARGET ID="ch439"><!-- POSTPROCESSDATA: ch439|concatenation:definition --><ITALICS>concatenated</ITALICS> volume elements. With concatenation, data written sequentially to the plex is also written sequentially to the volume elements; the first volume element is filled, then the second, and so on. Concatenation is useful for creating a filesystem that is larger than the size of a single disk.</PARAGRAPH>
<PARAGRAPH>You can add plexes to subvolumes, detach them from subvolumes that have multiple plexes (and possibly attach them elsewhere), and delete them from subvolumes that have multiple plexes.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>To have multiple plexes, you must purchase the Disk Plexing Option software option and obtain and install a NetLS license.</NOTE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Volume Elements</TITLE><PARAGRAPH>The simplest type of volume element is a single disk partition. The two other types of volume elements, striped volume elements and multipartition volume elements, are composed of several disk partitions. <INDEXTARGET ID="ch440"><!-- POSTPROCESSDATA: ch440|logical volumes:<ITALICS>See also</ITALICS> volume elements. --><INDEXTARGET ID="ch441"><!-- POSTPROCESSDATA: ch441|volume elements:definition --><INDEXTARGET ID="ch442"><!-- POSTPROCESSDATA: ch442|striped volume elements. <ITALICS>See</ITALICS> volume elements. --><INDEXTARGET ID="ch443"><!-- POSTPROCESSDATA: ch443|volume elements:single partition volume elements, definition --><INDEXTARGET ID="ch444"><!-- POSTPROCESSDATA: ch444|disk partitions:and volume elements --><XREF IDREF="25556" TYPE="GRAPHIC">Figure&nbsp;4-5</XREF> shows a single partition volume element.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="Fig4-5.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="4-5"><PREFIX>Figure 4-5 </PREFIX><XREFTARGET ID="25556">Single Partition Volume Element Composition</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH><INDEXTARGET ID="ch445"><!-- POSTPROCESSDATA: ch445|volume elements:striped, definition --><INDEXTARGET ID="ch446"><!-- POSTPROCESSDATA: ch446|stripe unit, definition --><XREF IDREF="45690" TYPE="GRAPHIC">Figure&nbsp;4-6</XREF> shows a striped volume element. Striped volume elements consist of two or more disk partitions, organized so that an amount of data called the stripe unit is written to each disk partition before writing the next stripe unit-worth of data to the next partition.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="Fig4-6.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="4-6"><PREFIX>Figure 4-6 </PREFIX><XREFTARGET ID="45690">Striped Volume Element Composition</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>Striping can be used to alternate sections of data among multiple disks. This provides a performance advantage by allowing parallel I/O activity.</PARAGRAPH>
<PARAGRAPH><INDEXTARGET ID="ch447"><!-- POSTPROCESSDATA: ch447|volume elements:multipartition volume elements, definition --><XREF IDREF="13867" TYPE="GRAPHIC">Figure&nbsp;4-7</XREF> shows a multipartition volume element in which the volume element is composed of more than one disk partition. In this configuration, the disk partitions are addressed sequentially.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="Fig4-7.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="4-7"><PREFIX>Figure 4-7 </PREFIX><XREFTARGET ID="13867">Multipartition Volume Element Composition</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>Any mixture of the three types of volume elements (single partition, striped, and multipartition) can be concatenated in a plex.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Logical Volume Naming</TITLE><PARAGRAPH>Volumes appear as block and character devices in the <INDEXTARGET ID="ch448"><!-- POSTPROCESSDATA: ch448|logical volumes:naming --><INDEXTARGET ID="ch449"><!-- POSTPROCESSDATA: ch449|logical volumes:device names --><INDEXTARGET ID="ch450"><!-- POSTPROCESSDATA: ch450|<ITALICS>/dev/dsk/xlv</ITALICS> directory --><FILENAME>/dev</FILENAME> directory. The device names for logical volumes are <FILENAME>/dev/dsk/xlv/</FILENAME><VARIABLE>&lt;volume_name></VARIABLE> and <FILENAME>/dev/rdsk/xlv/</FILENAME><VARIABLE>&lt;volume_name></VARIABLE>, where <VARIABLE>&lt;volume_name></VARIABLE> is a volume name specified when the volume is created using <COMMAND>xlv_make</COMMAND>(1M).</PARAGRAPH>
<PARAGRAPH>When a volume is created on one system and moved (by moving the disks) to another system, the new volume name is the same as the original volume name with the hostname of the original system prepended. For example, if a volume called xlv0 is moved from a system called engrlab1 to a system called engrlab2, the device name of the volume on the new system is <INDEXTARGET ID="ch451"><!-- POSTPROCESSDATA: ch451|logical volumes:moving to a new system --><FILENAME>/dev/dsk/xlv/engrlab1.xlv0</FILENAME> (the old system name engrlab1 has been prepended to the volume name xlv0).</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>XLV Daemons</TITLE><PARAGRAPH>The XLV daemons are:<INDEXTARGET ID="ch452"><!-- POSTPROCESSDATA: ch452|daemons:XLV --><INDEXTARGET ID="ch453"><!-- POSTPROCESSDATA: ch453|XLV:daemons --></PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><COMMAND>xlv_labd</COMMAND> </HANGITEM>
<HANGBODY><PARAGRAPH><INDEXTARGET ID="ch454"><!-- POSTPROCESSDATA: ch454|logical volumes:disk labels --><INDEXTARGET ID="ch455"><!-- POSTPROCESSDATA: ch455|disk labels:daemon that writes them --><INDEXTARGET ID="ch456"><!-- POSTPROCESSDATA: ch456|<ITALICS>xlv_labd</ITALICS> daemon:description --><COMMAND>xlv_labd</COMMAND>(1M) writes disk labels. It is started automatically at system startup if it is installed and there are active XLV logical volumes.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><COMMAND>xlvd</COMMAND> </HANGITEM>
<HANGBODY><PARAGRAPH><INDEXTARGET ID="ch457"><!-- POSTPROCESSDATA: ch457|<ITALICS>xlvd</ITALICS> daemon:description --><COMMAND>xlvd</COMMAND>(1M) handles I/O to plexes and performs plex error recovery. It is created automatically during system startup if plexing software is installed and there are active XLV logical volumes.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><COMMAND>xlv_plexd</COMMAND> </HANGITEM>
<HANGBODY><PARAGRAPH><INDEXTARGET ID="ch458"><!-- POSTPROCESSDATA: ch458|<ITALICS>xlv_plexd</ITALICS> daemon:description --><COMMAND>xlv_plexd</COMMAND>(1M) is responsible for making all plexes within a subvolume have the same data. It is started automatically at system startup if there are active XLV logical volumes.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>XLV does not require an explicit configuration file, nor is it turned on and off with <INDEXTARGET ID="ch459"><!-- POSTPROCESSDATA: ch459|disk labels:and logical volume assembly --><INDEXTARGET ID="ch460"><!-- POSTPROCESSDATA: ch460|XLV:no configuration file --><INDEXTARGET ID="ch461"><!-- POSTPROCESSDATA: ch461|logical volumes:coming up at system startup --><COMMAND>chkconfig</COMMAND>(1M). XLV is able to assemble logical volumes based solely upon information written in the disk labels. During initialization, the system performs a hardware inventory, reads all the disk labels, and automatically assembles the available disks into volumes.</PARAGRAPH>
<PARAGRAPH>If some disks are missing, XLV checks to see if there are enough volume elements among the available plexes to map the entire address space. If the whole address space is available, XLV brings the volume online even if some of the plexes are incomplete.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>XLV Error Policy</TITLE><PARAGRAPH>For read failures on log and data subvolumes, XLV rereads from a different plex (when available) and attempts to fix the failed plex by rewriting the results. XLV does not retry on failures for real-time data.<INDEXTARGET ID="ch462"><!-- POSTPROCESSDATA: ch462|XLV:error policy --><INDEXTARGET ID="ch463"><!-- POSTPROCESSDATA: ch463|plexes:read and write errors --><INDEXTARGET ID="ch464"><!-- POSTPROCESSDATA: ch464|hard errors --><INDEXTARGET ID="ch465"><!-- POSTPROCESSDATA: ch465|logical volumes:read and write errors --><INDEXTARGET ID="ch466"><!-- POSTPROCESSDATA: ch466|error recovery:and XLV --></PARAGRAPH>
<PARAGRAPH>For log and data subvolumes, XLV assumes that the write errors it receives are hard errors (the disk driver and controllers handle soft errors). If the volume element with a hard error is plexed, XLV marks the volume element bad and ignores it. If the volume element is not plexed, the volume element remains associated with the volume and an error is returned.</PARAGRAPH>
<PARAGRAPH>XLV doesn't handle write errors on real-time subvolumes. Incorrect data is returned without error messages.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="83099">Planning a Logical Volume</TITLE><PARAGRAPH>The following subsections discuss topics to consider when planning a logical volume.<INDEXTARGET ID="ch467"><!-- POSTPROCESSDATA: ch467|XLV:planning logical volumes --></PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Don't Use XLV When ...</TITLE><PARAGRAPH>There are some situations where logical volumes cannot be used or are not recommended:<INDEXTARGET ID="ch468"><!-- POSTPROCESSDATA: ch468|XLV:don't use XLV when ... --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Swap space cannot be a logical volume.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Logical volumes aren't recommended on systems with a single disk.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Striped or concatenated volumes cannot be used for the root filesystem.<INDEXTARGET ID="ch469"><!-- POSTPROCESSDATA: ch469|concatenation:not allowed on root filesystems --><INDEXTARGET ID="ch470"><!-- POSTPROCESSDATA: ch470|root partition:and XLV --></PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Deciding Which Subvolumes to Use</TITLE><PARAGRAPH>The basic guidelines for choosing which subvolumes to use with EFS filesystems are:<INDEXTARGET ID="ch471"><!-- POSTPROCESSDATA: ch471|logical volumes:choosing which subvolumes --><INDEXTARGET ID="ch472"><!-- POSTPROCESSDATA: ch472|EFS filesystems:XLV subvolumes --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Only data subvolumes can be used.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The maximum useful size of a data subvolume (and therefore the volume) on EFS is 8 GB.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The basic guidelines for choosing which subvolumes to use with XFS filesystems are:<INDEXTARGET ID="ch473"><!-- POSTPROCESSDATA: ch473|logs:internal log, when used --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Data subvolumes are required.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Log subvolumes are optional. If they are not used, log information is put into an <ITALICS>internal log</ITALICS> in the data subvolume (by giving the <BOLD>&ndash;l internal</BOLD> option to <COMMAND>mkfs</COMMAND>).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Real-time subvolumes are optional.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Choosing Subvolume Sizes</TITLE><PARAGRAPH>The basic guidelines for choosing subvolume sizes are:<INDEXTARGET ID="ch474"><!-- POSTPROCESSDATA: ch474|logical volumes:sizes --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The maximum size of a subvolume is one terabyte.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>When real-time subvolumes are used, make a small log subvolume and a small data subvolume. Don't put much (if any) user data in the filesystem, just real-time data.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Choosing the size of the log (and therefore the size of the log subvolume) is discussed in the section <INDEXTARGET ID="ch475"><!-- POSTPROCESSDATA: ch475|disk partitions:and external log size --><XREF IDREF="93345" TYPE="TITLE">&ldquo;Choosing the Log Type and Size&rdquo; in Chapter&nbsp;2</XREF>. Note that if you do not intend to repartition a disk to create an optimal-size log partition, your choice of an available disk partition may determine the size of the log.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Plexing</TITLE><PARAGRAPH>The basic guidelines for plexing are:<INDEXTARGET ID="ch476"><!-- POSTPROCESSDATA: ch476|plexes:when to use --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Use plexing when high reliability and high availability of data are required. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Plexes can have &ldquo;holes&rdquo; in them, portions of the address range not contained by a volume element, as long as at least one of the plexes in the subvolume has a volume element with the address range of the hole.<INDEXTARGET ID="ch477"><!-- POSTPROCESSDATA: ch477|plexes:holes in address space --></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The volume elements in each plex of a subvolume must be identical in size with their counterparts in other plexes (volume elements with the same address range). The structure within a volume element (single partition, striped, or multipartition) does not have to match the structure within its counterparts.<INDEXTARGET ID="ch478"><!-- POSTPROCESSDATA: ch478|plexes:volume element sizes --></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>To make volume elements identical in size, you may have to use <INDEXTARGET ID="ch479"><!-- POSTPROCESSDATA: ch479|volume elements:changing size with <ITALICS>dvhtool</ITALICS> --><INDEXTARGET ID="ch480"><!-- POSTPROCESSDATA: ch480|<ITALICS>dvhtool</ITALICS> utility and volume element sizes --><COMMAND>dvhtool</COMMAND>(1M). <COMMAND>fx</COMMAND>(1M) partitions in units of cylinders and rounds sizes to megabytes, which may not result in exactly the same number of bytes in two partitions of the &ldquo;same size&rdquo; on different types of disks. See the <COMMAND>dvhtool</COMMAND>(1M) reference page for more information.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Striping</TITLE><PARAGRAPH>The basic guidelines for striping are:<INDEXTARGET ID="ch481"><!-- POSTPROCESSDATA: ch481|volume elements:striping, when to use --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The root filesystem cannot be striped.<INDEXTARGET ID="ch482"><!-- POSTPROCESSDATA: ch482|root filesystem:restrictions --><INDEXTARGET ID="ch483"><!-- POSTPROCESSDATA: ch483|root partition:and striping --></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Striped volume elements must be made of disk partitions that are exactly the same size. <INDEXTARGET ID="ch484"><!-- POSTPROCESSDATA: ch484|disk partitions:sizes for striped volume elements --></PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Concatenating Disk Partitions</TITLE><PARAGRAPH>The basic guidelines for the concatenation of disk partitions are:<INDEXTARGET ID="ch485"><!-- POSTPROCESSDATA: ch485|volume elements:multipartition volume elements not recommended --><INDEXTARGET ID="ch486"><!-- POSTPROCESSDATA: ch486|concatenation:guidelines --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The root filesystem cannot have concatenated disk partitions.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>It is better to concatenate single-partition volume elements into a plex rather than create a single multipartition volume element. This is not for performance reasons, but for reliability. When one disk partition goes bad in a multipartition volume, all disks that contain partitions used in that volume element are taken offline.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE>Using <XREFTARGET ID="25568"><COMMAND>xlv_make</COMMAND> to Create Volume Objects</TITLE><PARAGRAPH><INDEXTARGET ID="ch487"><!-- POSTPROCESSDATA: ch487|logical volumes:disk labels --><INDEXTARGET ID="ch488"><!-- POSTPROCESSDATA: ch488|disk labels:written by <ITALICS>xlv_make</ITALICS> --><INDEXTARGET ID="ch489"><!-- POSTPROCESSDATA: ch489|<ITALICS>xlv_make</ITALICS> utility:using to create volume objects --><COMMAND>xlv_make</COMMAND>(1M) is used to create volumes, subvolumes, plexes, and volume elements from unused disk partitions. It writes only the disk labels; data on the disk partitions is untouched. </PARAGRAPH>
<PARAGRAPH>After you create a volume, you must make a filesystem on it if necessary and mount the filesystem so that you can use the logical volume. See the section <XREF IDREF="64725" TYPE="TITLE">&ldquo;Preparing a Logical Volume for Use&rdquo;</XREF> in this chapter for instructions.</PARAGRAPH>
<PARAGRAPH><COMMAND>xlv_make</COMMAND> can be run interactively or it can take commands from an input file. The remainder of this section gives two examples of using <COMMAND>xlv_make</COMMAND>; the first one is interactive and the second is noninteractive.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Example 1: Simple Logical Volume</TITLE><PARAGRAPH>This example shows a simple logical volume composed of a data subvolume created from two entire option disks. The disks are on controller 0, units 2 and 3 (use the <INDEXTARGET ID="ch490"><!-- POSTPROCESSDATA: ch490|logical volumes:creating, examples --><COMMAND>hinv</COMMAND>(1M) command, for example <COMMAND>hinv &ndash;c disk</COMMAND>, to obtain this information). Partition 7 of each disk is normally the entire disk (use the <COMMAND>prtvtoc</COMMAND>(1M) command, for example <COMMAND>prtvtoc /dev/rdsk/dks0d2vh</COMMAND> and <COMMAND>prtvtoc /dev/rdsk/dks0d3vh</COMMAND>, to obtain this information).</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Unmount the disks that will be used in the volume if they are mounted. For example:</PARAGRAPH>
<CODE>
# <USERINPUT>df</USERINPUT>
Filesystem                 Type  blocks     use   avail %use  Mounted on
/dev/root                   efs 1939714  430115 1509599  22%  /
/dev/dsk/dks0d2s7           efs 2004550      22 2004528   0%  /d2
/dev/dsk/dks0d3s7           efs 3826812      22 3826790   0%  /d3
# <USERINPUT>umount /d2</USERINPUT>
# <USERINPUT>umount /d3</USERINPUT>
</CODE>
</LIST>
<LIST><PARAGRAPH>Start <COMMAND>xlv_make</COMMAND>:</PARAGRAPH>
<CODE>
# <USERINPUT>xlv_make</USERINPUT>
xlv_make>
</CODE>
</LIST>
<LIST><PARAGRAPH>Start creating the volume by specifying its name, for example xlv_volume:</PARAGRAPH>
<CODE>
xlv_make> <USERINPUT>vol xlv0</USERINPUT>
xlv0
</CODE>
</LIST>
<LIST><PARAGRAPH>Begin creating the data subvolume:</PARAGRAPH>
<CODE>
xlv_make> <USERINPUT>data</USERINPUT>
xlv0.data
</CODE>
<PARAGRAPH><COMMAND>xlv_make</COMMAND> echoes the name of each object (volume, subvolume, plex, or volume element) you create.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Continue to move down through the hierarchy of the volume by specifying the plex:</PARAGRAPH>
<CODE>
xlv_make> <USERINPUT>plex</USERINPUT>
xlv0.data.0
</CODE>
</LIST>
<LIST><PARAGRAPH>Specify the volume elements (disk partitions) to be included in the volume, for example <FILENAME>/dev/dsk/dks0d2s7</FILENAME> and <FILENAME>/dev/dsk/dks0d3s7</FILENAME>:</PARAGRAPH>
<CODE>
xlv_make> <USERINPUT>ve dks0d2s7</USERINPUT>
xlv0.data.0.0
xlv_make> <USERINPUT>ve dks0d3s7</USERINPUT>
xlv0.data.0.1
</CODE>
<PARAGRAPH>You can specify the last portion of the disk partition pathname (as shown) or the full pathname. <COMMAND>xlv_make</COMMAND> accepts disk partitions that are of types &ldquo;xlv&rdquo;, &ldquo;xfs&rdquo;, and &ldquo;efs&rdquo;. You can use other partition types, for example &ldquo;lvol&rdquo;, by giving the <BOLD>&ndash;force</BOLD> option, for example, <COMMAND>ve &ndash;force dks0d2s7</COMMAND>. <COMMAND>xlv_make</COMMAND> automatically changes the partition type to &ldquo;xlv&rdquo;.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Tell <COMMAND>xlv_make</COMMAND> that you are finished specifying the objects:</PARAGRAPH>
<CODE>
xlv_make> <USERINPUT>end</USERINPUT>
Object specification completed
</CODE>
</LIST>
<LIST><PARAGRAPH>Review the objects that you've specified:</PARAGRAPH>
<CODE>
xlv_make> <USERINPUT>show</USERINPUT>

&space;       Completed Objects
(1)  vol xlv0
ve xlv0.data.0.0 [empty]
&space;       start=0, end=226799, (cat)grp_size=1
&space;       /dev/dsk/dks0d2s2 (226800 blks)
ve xlv0.data.0.1 [empty]
&space;       start=226800, end=453599, (cat)grp_size=1
&space;       /dev/dsk/dks0d2s3 (226800 blks)
</CODE>
</LIST>
<LIST><PARAGRAPH>Write the volume information to the disk labels by exiting <COMMAND>xlv_make</COMMAND>:</PARAGRAPH>
<CODE>
xlv_make> <USERINPUT>exit</USERINPUT>
Newly created objects will be written to disk.
Is this what you want?(yes)  <USERINPUT>yes</USERINPUT>
Invoking xlv_assemble
</CODE>
</LIST>
</ORDEREDLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Example 2: Striped, Plexed Logical Volume</TITLE><PARAGRAPH>This example shows the noninteractive creation of a logical volume from four equal-sized option disks (controller 0, units 2 through 5). Two plexes will be created with the data striped across the two disks in each plex. The stripe unit will be 128 KB.<INDEXTARGET ID="ch491"><!-- POSTPROCESSDATA: ch491|plexes:example of creating --><INDEXTARGET ID="ch492"><!-- POSTPROCESSDATA: ch492|volume elements:striped, example of creating --></PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>As in the previous example, unmount the disks to be used if necessary.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Create a file, called <FILENAME>xlv0.specs</FILENAME> for example, that contains input for <COMMAND>xlv_make</COMMAND>. For this example and a volume named xlv0, the file contains:</PARAGRAPH>
<CODE>
vol xlv0
data
plex
ve -stripe -stripe_unit 256 dks0d2s7 dks0d3s7
plex
ve -stripe -stripe_unit 256 dks0d4s7 dks0d5s7
end
show
exit
</CODE>
<PARAGRAPH>This script specifies the volume hierarchically: volume, subvolume (data), first plex with a striped volume element, then second plex with a striped volume element. The ve commands have a stripe unit argument of 256. This argument is the number of 512-byte blocks (sectors), so 128K/512 = 256. The end command signifies that the specification is complete and the (optional) show command causes the specification to be displayed. The disk label is created by the exit command.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Run <COMMAND>xlv_make</COMMAND> to create the volume. For example:</PARAGRAPH>
<CODE>
<USERINPUT>xlv_make xlv0.specs</USERINPUT>&space;
</CODE>
</LIST>
</ORDEREDLIST>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="64725">Preparing a Logical Volume for Use</TITLE><PARAGRAPH>Once you create a logical volume with <INDEXTARGET ID="ch493"><!-- POSTPROCESSDATA: ch493|logical volumes:preparing for use --><COMMAND>xlv_make</COMMAND>, follow these steps to prepare it for use:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>If there is no filesystem on the logical volume (and you want one) or you want to switch from EFS to XFS, you must create a filesystem with <COMMAND>mkfs</COMMAND>(1M). See <XREF IDREF="86008" TYPE="TITLE">Chapter&nbsp;2, &ldquo;XFS Filesystem Administration.&rdquo;</XREF></PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Mount the logical volume, for example:</PARAGRAPH>
<CODE>
<USERINPUT>mkdir /vol1</USERINPUT>&space;
<USERINPUT>mount /dev/dsk/xlv/xlv0 /vol1</USERINPUT>&space;
</CODE>
</LIST>
<LIST><PARAGRAPH>To have the logical volume mounted automatically at system startup, you must add an entry for the volume to <INDEXTARGET ID="ch494"><!-- POSTPROCESSDATA: ch494|<ITALICS>/etc/fstab</ITALICS> file:entries for XLV logical volumes --><FILENAME>/etc/fstab</FILENAME>, for example:</PARAGRAPH>
<CODE>
/dev/dsk/xlv/xlv0 /vol1 xfs rw,raw=/dev/rdsk/xlv/xlv0 0 0
</CODE>
<PARAGRAPH>See the <COMMAND>fstab</COMMAND>(4) reference page for more information.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="63965">Converting <COMMAND>lv</COMMAND> Logical Volumes to XLV</TITLE><PARAGRAPH>This section explains the procedure for converting <INDEXTARGET ID="ch495"><!-- POSTPROCESSDATA: ch495|<ITALICS>lv</ITALICS> logical volumes:converting to XLV --><INDEXTARGET ID="ch496"><!-- POSTPROCESSDATA: ch496|XLV:converting <ITALICS>lv</ITALICS> logical volumes --><INDEXTARGET ID="ch497"><!-- POSTPROCESSDATA: ch497|<ITALICS>lv_to_xlv</ITALICS> utility:using --><COMMAND>lv</COMMAND>(7M) logical volumes to XLV logical volumes. The files on the logical volumes are not modified or dumped during the conversion. You must be superuser to perform this procedure.</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Choose new names for the logical volumes, if desired. XLV, unlike <COMMAND>lv</COMMAND>, only requires names to be valid filenames, so you can choose more meaningful names. For example, you can make the volume names the same as the mount points you use. If you mount logical volumes at <FILENAME>/a</FILENAME>, <FILENAME>/b</FILENAME>, and <FILENAME>/c</FILENAME>, you can name the XLV volumes a, b, and c. </PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Unmount all <COMMAND>lv</COMMAND> logical volumes that you plan to convert to XLV logical volumes. For example:</PARAGRAPH>
<CODE>
<USERINPUT>umount /a</USERINPUT>&space;
</CODE>
</LIST>
<LIST><PARAGRAPH>Create an input script for <COMMAND>xlv_make</COMMAND> by using <COMMAND>lv_to_xlv</COMMAND>(1M):</PARAGRAPH>
<CODE>
<USERINPUT>lv_to_xlv -o </USERINPUT><VARIABLE>scriptfile</VARIABLE>&space;
</CODE>
<PARAGRAPH><VARIABLE>scriptfile</VARIABLE> is the name of a temporary file that <VARIABLE>lv_to_xlv</VARIABLE> creates, for example /usr/tmp/xlv.script. It contains a series of <COMMAND>xlv_make</COMMAND> commands that can be used to create XLV volumes that are equivalent to the <COMMAND>lv</COMMAND> logical volumes listed in <FILENAME>/etc/lvtab</FILENAME>.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>If you want to change the volume names, edit <VARIABLE>scriptfile</VARIABLE> and replace the names on the lines that begin with <SCREENDISPLAY>vol</SCREENDISPLAY> with the new names. For example, change:</PARAGRAPH>
<CODE>
vol lv0 
</CODE>
<PARAGRAPH>to:</PARAGRAPH>
<CODE>
vol a 
</CODE>
<PARAGRAPH>The volume name can be any name that is a valid filename.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>By default, all <COMMAND>lv</COMMAND> logical volumes on the system are converted to XLV. If you do not want all <COMMAND>lv</COMMAND> logical volumes converted to XLV, edit <VARIABLE>scriptfile</VARIABLE> and remove the <COMMAND>xlv_make</COMMAND> commands for the volumes that you do not want to change. See the section <XREF IDREF="25568" TYPE="TITLE">&ldquo;Using xlv_make to Create Volume Objects&rdquo;</XREF> in this chapter and the <COMMAND>xlv_make</COMMAND>(1M) reference page for more information.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Create the XLV volumes by running <COMMAND>xlv_make</COMMAND> with <VARIABLE>scriptfile</VARIABLE> as input:</PARAGRAPH>
<CODE>
<USERINPUT>xlv_make</USERINPUT>&space;<VARIABLE>scriptfile</VARIABLE>&space;
</CODE>
</LIST>
<LIST><PARAGRAPH>If you converted all <INDEXTARGET ID="ch498"><!-- POSTPROCESSDATA: ch498|<ITALICS>/etc/lvtab</ITALICS> file --><COMMAND>lv</COMMAND> logical volumes to XLV, remove <FILENAME>/etc/lvtab</FILENAME>:</PARAGRAPH>
<CODE>
<USERINPUT>rm /etc/lvtab</USERINPUT>&space;
</CODE>
</LIST>
<LIST><PARAGRAPH>If you converted just some of the <COMMAND>lv</COMMAND> logical volumes to XLV, edit <FILENAME>/etc/lvtab</FILENAME> and remove the entries for the logical volumes you converted.</PARAGRAPH>
<CODE>
<USERINPUT>vi /etc/lvtab</USERINPUT>&space;
</CODE>
</LIST>
<LIST><PARAGRAPH>Edit <INDEXTARGET ID="ch499"><!-- POSTPROCESSDATA: ch499|<ITALICS>/etc/fstab</ITALICS> file:entry for XLV logical volume --><FILENAME>/etc/fstab</FILENAME> so that it automatically mounts the XLV logical volumes at startup. These changes to <FILENAME>/etc/fstab</FILENAME> are required for each XLV logical volume:</PARAGRAPH>
<BULLETLISTIND><BULLETIND><PARAGRAPH>In the first field, insert the subdirectory <SCREENDISPLAY>xlv</SCREENDISPLAY> after <SCREENDISPLAY>/dev/dsk</SCREENDISPLAY>.</PARAGRAPH>
</BULLETIND>
<BULLETIND><PARAGRAPH>If you changed the name of the volume, for example from lv0 to a, make the change in the first field.</PARAGRAPH>
</BULLETIND>
<BULLETIND><PARAGRAPH>Insert the subdirectory <SCREENDISPLAY>xlv</SCREENDISPLAY> into the raw device name.</PARAGRAPH>
</BULLETIND>
<BULLETIND><PARAGRAPH>If you changed the name of the volume, for example from lv0 to a, make the change in the raw device.</PARAGRAPH>
</BULLETIND>
</BULLETLISTIND>
<PARAGRAPH>For example, if an original line is:</PARAGRAPH>
<CODE>
/dev/dsk/lv0   /a efs rw,raw=/dev/rdsk/lv0 0 0
</CODE>
<PARAGRAPH>The changed line, including the name change, is:</PARAGRAPH>
<CODE>
/dev/dsk/xlv/a /a xfs rw,raw=/dev/rdsk/xlv/a 0 0
</CODE>
</LIST>
<LIST><PARAGRAPH>Mount the XLV logical volume, for example:</PARAGRAPH>
<CODE>
<USERINPUT>mount /a</USERINPUT>&space;
</CODE>
</LIST>
</ORDEREDLIST>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="34840">Using <COMMAND>xlv_admin</COMMAND> to Administer Logical Volumes</TITLE><PARAGRAPH>The <INDEXTARGET ID="ch4100"><!-- POSTPROCESSDATA: ch4100|<ITALICS>xlv_admin</ITALICS> utility:menu --><COMMAND>xlv_admin</COMMAND>(1M) command is used to modify logical volume objects and their disk labels after they have been created by <COMMAND>xlv_make</COMMAND>. <COMMAND>xlv_admin</COMMAND> is an interactive command with this menu:</PARAGRAPH>
<CODE>
**************** XLV Administration Menu **********
................ Add Existing Selections...........
1.      Add a ve to an existing plex. 
2.      Add a ve at the END of an existing plex. 
3.      Add a plex to an existing volume. 
................ Detach Selections................
11.     Detach a ve from an existing plex. 
12.     Detach a plex from an existing volume. 
................ Remove Selections................
21.     Remove a ve from an existing plex. 
22.     Remove a plex from an existing volume. 
................ Delete Selections................
31.     Delete an object. 
32.     Delete all XLV disk labels. 
................ Show Selections................
41.     Show object by name and type, only. 
42.     Show information for an object. 
................ Exit ................
99.     Exit 
</CODE>
<NOTE><PREFIX>Note</PREFIX>The full menu is shown above; if you do not have a valid license for the Disk Plexing Option software option, several of the plex-related menu selections do not appear. <INDEXTARGET ID="ch4101"><!-- POSTPROCESSDATA: ch4101|<ITALICS>xlv_admin</ITALICS> utility:and Disk Plexing Option --></NOTE>
<PARAGRAPH>The following subsections explain how to use <COMMAND>xlv_admin</COMMAND> to perform common operations.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Displaying Logical Volume Objects</TITLE><PARAGRAPH>To get a list of the highest-level volume objects on a system, use selection 41 of the <INDEXTARGET ID="ch4102"><!-- POSTPROCESSDATA: ch4102|<ITALICS>xlv_admin</ITALICS> utility:displaying objects --><INDEXTARGET ID="ch4103"><!-- POSTPROCESSDATA: ch4103|logical volumes:displaying objects --><INDEXTARGET ID="ch4104"><!-- POSTPROCESSDATA: ch4104|plexes:displaying --><INDEXTARGET ID="ch4105"><!-- POSTPROCESSDATA: ch4105|subvolumes:displaying --><INDEXTARGET ID="ch4106"><!-- POSTPROCESSDATA: ch4106|volume elements:displaying --><COMMAND>xlv_admin</COMMAND> menu, for example:</PARAGRAPH>
<CODE>
xlv_admin> <USERINPUT>41</USERINPUT>

==================== Listing Objects =============
Volume Element:  'spare_ve'
Volume:          'xlv0'
</CODE>
<PARAGRAPH>In this example, there are two high-level volume objects, a volume element named spare_ve and a logical volume named xlv0. The volume element is a high-level volume object because it is not part of any plex or subvolume.</PARAGRAPH>
<PARAGRAPH>To display the complete hierarchy of a high-level volume object, use selection 42 of the <COMMAND>xlv_admin</COMMAND> menu, for example:</PARAGRAPH>
<CODE>
xlv_admin> <USERINPUT>42</USERINPUT>
Please enter name of object to be operated on.
xlv_admin> <USERINPUT>xlv0</USERINPUT>

============= Displaying Requested Object ==========
vol xlv0
ve xlv0.data.0.0 [active]
&space;       start=0, end=226799, (cat)grp_size=1
&space;       /dev/dsk/dks0d2s7 (226800 blks)
ve xlv0.data.0.1 [active]
&space;       start=226800, end=453599, (cat)grp_size=1
&space;       /dev/dsk/dks0d3s7 (226800 blks)
ve xlv0.data.0.2 [active]
&space;       start=453600, end=680399, (cat)grp_size=1
&space;       /dev/dsk/dks0d4s7 (226800 blks)
</CODE>
<PARAGRAPH>This output shows that xlv0 contains only a data subvolume. The data subvolume has one plex that has three volume elements.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Growing a Logical Volume</TITLE><PARAGRAPH>Growing a logical volume (increasing its size) can be done in two ways by adding one or more volume elements to the end of one or more of its plexes. <INDEXTARGET ID="ch4107"><!-- POSTPROCESSDATA: ch4107|<ITALICS>xlv_admin</ITALICS> utility:growing a volume --><INDEXTARGET ID="ch4108"><!-- POSTPROCESSDATA: ch4108|logical volumes:growing --><INDEXTARGET ID="ch4109"><!-- POSTPROCESSDATA: ch4109|logical volumes:increasing size --><INDEXTARGET ID="ch4110"><!-- POSTPROCESSDATA: ch4110|disk space:growing a logical volume --></PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH><XREFTARGET ID="86002">If any of the volume elements you plan to add to the volume don't exist yet, create them with <COMMAND>xlv_make</COMMAND>. For example, follow this procedure to create a volume element out of a new disk, <FILENAME>/dev/dsk/dks0d4s7</FILENAME>:</PARAGRAPH>
<CODE>
<USERINPUT>xlv_make</USERINPUT>&space;
xlv_make> <USERINPUT>ve new_ve dks0d4s7</USERINPUT>
new_ve
xlv_make> <USERINPUT>end</USERINPUT>
Object specification completed
xlv_make> <USERINPUT>exit</USERINPUT>
Newly created objects will be written to disk.
Is this what you want?(yes)  <USERINPUT>yes</USERINPUT>
Invoking xlv_assemble
</CODE>
<PARAGRAPH>The ve command includes a volume element name, new_ve. This is required because the volume element is not part of a larger hierarchy; it is the root object in this case.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Use selection 2 of the <COMMAND>xlv_admin</COMMAND> command to add each volume element. For example, to add the volume element from step <XREF IDREF="86002" TYPE="TEXT">1</XREF> to plex 0 of the data subvolume of the volume xlv0, use this procedure:</PARAGRAPH>
<CODE>
<USERINPUT>xlv_admin</USERINPUT>&space;
xlv_admin> <USERINPUT>2</USERINPUT>
Please enter name of object to be operated on.
xlv_admin> <USERINPUT>xlv0.data.0</USERINPUT>
&space;Please enter the object you wish to add to the target. 
xlv_admin> <USERINPUT>new_ve</USERINPUT>
&space;Please select choice...
xlv_admin> <USERINPUT>99</USERINPUT>&space;
</CODE>
</LIST>
<LIST><PARAGRAPH>If you are growing an XFS filesystem, mount the filesystem if it isn't already mounted:</PARAGRAPH>
<CODE>
<USERINPUT>mount</USERINPUT>&space;<VARIABLE>volume</VARIABLE>&space;<VARIABLE>mountpoint</VARIABLE>&space;
</CODE>
<PARAGRAPH><VARIABLE>volume</VARIABLE> is the device name of the logical volume, for example /dev/dsk/xlv/xlv0, and <VARIABLE>mountpoint</VARIABLE> is the mount point directory for the logical volume.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>If you are growing an XFS filesystem, use <INDEXTARGET ID="ch4111"><!-- POSTPROCESSDATA: ch4111|<ITALICS>xfs_growfs</ITALICS> utility --><COMMAND>xfs_growfs</COMMAND>(1M) to grow the filesystem:</PARAGRAPH>
<CODE>
<USERINPUT>xfs_growfs -d</USERINPUT>&space;<VARIABLE>mountpoint</VARIABLE>
</CODE>
<PARAGRAPH><VARIABLE>mountpoint</VARIABLE> is the mount point directory for the logical volume.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>If you are growing an EFS filesystem, unmount the filesystem if it is mounted:</PARAGRAPH>
<CODE>
<USERINPUT>umount</USERINPUT>&space;<VARIABLE>mountpoint</VARIABLE>&space;
</CODE>
<PARAGRAPH><VARIABLE>mountpoint</VARIABLE> is the mount point directory for the filesystem.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>If you are growing an EFS filesystem, use <COMMAND>growfs</COMMAND>(1M) to grow the filesystem:</PARAGRAPH>
<CODE>
<USERINPUT>growfs</USERINPUT>&space;<VARIABLE>volume</VARIABLE>&space;
</CODE>
<PARAGRAPH><VARIABLE>volume</VARIABLE> is the device name of the logical volume, for example /dev/dsk/lv0.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="17347">Adding a Plex to a Logical Volume</TITLE><PARAGRAPH>If you have purchased the Disk Plexing Option software option and have installed a NetLS license for it, you can add a plex to an existing subvolume for improved reliability in case of disk failures. The procedure to add a plex to a subvolume is described below. To add more than one plex to a subvolume or to add a plex to each of the subvolumes in a volume, repeat the procedure as necessary.<INDEXTARGET ID="ch4112"><!-- POSTPROCESSDATA: ch4112|<ITALICS>xlv_admin</ITALICS> utility:adding a plex --><INDEXTARGET ID="ch4113"><!-- POSTPROCESSDATA: ch4113|plexes:adding to volumes --><INDEXTARGET ID="ch4114"><!-- POSTPROCESSDATA: ch4114|logical volumes:adding plexes --></PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>If the plex that you want to add to the subvolume doesn't exist yet, create it with <COMMAND>xlv_make</COMMAND>. For example, to create a plex called plex1 to add to the data subvolume of a volume called root_vol, give these commands:</PARAGRAPH>
<CODE>
# <USERINPUT>xlv_make</USERINPUT>&space;
xlv_make> <USERINPUT>show</USERINPUT>&space;

&space;       Completed Objects
(1)  vol root_vol
ve root_vol.data.0.0 [active]
&space;       start=0, end=1992629, (cat)grp_size=1
&space;       /dev/dsk/dks0d1s0 (1992630 blks)

xlv_make> <USERINPUT>plex plex1</USERINPUT>
plex1
xlv_make> <USERINPUT>ve /dev/dsk/dks0d2s0</USERINPUT>
plex1.0
xlv_make> <USERINPUT>end</USERINPUT>
Object specification completed
xlv_make> <USERINPUT>exit</USERINPUT>
Newly created objects will be written to disk.
Is this what you want?(yes)  <USERINPUT>yes</USERINPUT>
Invoking xlv_assemble
</CODE>
</LIST>
<LIST><PARAGRAPH>Use the <COMMAND>xlv_admin</COMMAND> command menu to add the plex to the volume. For example, to add the standalone plex plex1 to root_vol, use this procedure:</PARAGRAPH>
<CODE>
# <USERINPUT>xlv_admin</USERINPUT>
**************** XLV Administration Menu **********
...
3.      Add a plex to an existing volume.
...
42.     Show information for an object.
...
99.     Exit
...
xlv_admin> <USERINPUT>42</USERINPUT>
Please enter name of object to be operated on.
xlv_admin> <USERINPUT>root_vol</USERINPUT>

============= Displaying Requested Object ==========
vol root_vol
ve root_vol.data.0.0 [active]
&space;       start=0, end=1992629, (cat)grp_size=1
&space;       /dev/dsk/dks0d1s0 (1992630 blks)


&space;Please select choice...
xlv_admin> <USERINPUT>42</USERINPUT>
Please enter name of object to be operated on.
xlv_admin> <USERINPUT>plex1</USERINPUT>

============= Displaying Requested Object ==========
plex plex1
ve plex1.0 [empty]
&space;       start=0, end=1992629, (cat)grp_size=1
&space;       /dev/dsk/dks0d2s0 (1992630 blks)


&space;Please select choice...
xlv_admin> <USERINPUT>3</USERINPUT>
Please enter name of object to be operated on.
xlv_admin> <USERINPUT>root_vol</USERINPUT>
&space;Please enter the object you wish to add to the target.
xlv_admin> <USERINPUT>plex1</USERINPUT>
&space;Please select choice...
</CODE>
</LIST>
<LIST><PARAGRAPH>You can confirm that root_vol now has two plexes by using selection 42 of the <COMMAND>xlv_admin</COMMAND> command menu:</PARAGRAPH>
<CODE>
xlv_admin> <USERINPUT>42</USERINPUT>
Please enter name of object to be operated on.
xlv_admin> <USERINPUT>root_vol</USERINPUT>

============= Displaying Requested Object ==========
vol root_vol
ve root_vol.data.0.0 [active]
&space;       start=0, end=1992629, (cat)grp_size=1
&space;       /dev/dsk/dks0d1s0 (1992630 blks)
ve root_vol.data.1.0 [empty]
&space;       start=0, end=1992629, (cat)grp_size=1
&space;       /dev/dsk/dks0d2s0 (1992630 blks)


&space;Please select choice...
</CODE>
<PARAGRAPH>The newly added plex, root_vol.data.1, is in the [empty] state. This is because it is newly created. When a plex is added, <COMMAND>xlv_admin</COMMAND> automatically initiates a plex revive operation to copy the contents of the original plex, root_vol.data.0, to the newly added plex.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Exit <COMMAND>xlv_admin</COMMAND>:</PARAGRAPH>
<CODE>
xlv_admin> <USERINPUT>99</USERINPUT>
#
</CODE>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>The plex revive completes and the new plex switches to [active] state automatically, but if you want to check its progress and verify that the plex has become active, follow this procedure:<INDEXTARGET ID="ch4115"><!-- POSTPROCESSDATA: ch4115|plexes:monitoring plex revives --><INDEXTARGET ID="ch4116"><!-- POSTPROCESSDATA: ch4116|plex revives --></PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>List the XLV daemons running, for example:</PARAGRAPH>
<CODE>
# <USERINPUT>ps -ef | grep xlv</USERINPUT>
&space;   root    27     1  0 10:49:27 ?        0:00 /sbin/xlv_plexd -m 4
&space;   root    35     1  0 10:49:28 ?        0:00 /sbin/xlv_labd
&space;   root    31     1  0 10:49:27 ?        0:00 xlvd
&space;   root   407    27  1 11:01:01 ?        0:00 xlv_plexd -v 2 -n root_vol.data
-d 50331648 -b 128 -w 0 0 1992629
&space;   root   410   397  2 11:01:11 pts/0    0:00 grep xlv
</CODE>
<PARAGRAPH>One instance of <COMMAND>xlv_plexd</COMMAND> is currently reviving root_vol.data. This daemon exits when the plex has been fully revived.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Later, check the XLV daemons again, for example:</PARAGRAPH>
<CODE>
# <USERINPUT>ps -ef | grep xlv</USERINPUT>
ps -ef | grep xlv
&space;   root    27     1  0 10:49:27 ?        0:00 /sbin/xlv_plexd -m 4
&space;   root    35     1  0 10:49:28 ?        0:00 /sbin/xlv_labd
&space;   root    31     1  0 10:49:27 ?        0:03 xlvd
</CODE>
<PARAGRAPH>The instance of <COMMAND>xlv_plexd</COMMAND> that was reviving root_vol.data is no longer running; it has completed the plex revive. </PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Check the state of the plex using <COMMAND>xlv_admin</COMMAND>:</PARAGRAPH>
<CODE>
# <USERINPUT>xlv_admin</USERINPUT>
...
xlv_admin> <USERINPUT>42</USERINPUT>
Please enter name of object to be operated on.
xlv_admin> <USERINPUT>root_vol</USERINPUT>

============= Displaying Requested Object ==========
vol root_vol
ve root_vol.data.0.0 [active]
&space;       start=0, end=1992629, (cat)grp_size=1
&space;       /dev/dsk/dks0d1s0 (1992630 blks)
ve root_vol.data.1.0 [active]
&space;       start=0, end=1992629, (cat)grp_size=1
&space;       /dev/dsk/dks0d2s0 (1992630 blks)


&space;Please select choice...
</CODE>
<PARAGRAPH>Both plexes are now in the [active] state.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Exit <COMMAND>xlv_admin</COMMAND>:</PARAGRAPH>
<CODE>
xlv_admin> <USERINPUT>99</USERINPUT>
#
</CODE>
</LIST>
</ORDEREDLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Detaching a Plex from a Volume</TITLE><PARAGRAPH>Detaching a plex from a volume, perhaps because you want to swap disk drives, can be done while the volume is active. However, the entire address range of the subvolume must still covered by active volume elements in the remaining plex or plexes. <INDEXTARGET ID="ch4117"><!-- POSTPROCESSDATA: ch4117|<ITALICS>xlv_admin</ITALICS> utility:detaching a plex --><INDEXTARGET ID="ch4118"><!-- POSTPROCESSDATA: ch4118|plexes:detaching --><INDEXTARGET ID="ch4119"><!-- POSTPROCESSDATA: ch4119|logical volumes:detaching plexes --><COMMAND>xlv_admin</COMMAND> does not allow you to remove the only active plex in a volume if the other plexes are not yet active. The procedure to detach a plex is:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Start <COMMAND>xlv_admin</COMMAND> and display the volume that has the plex that you plan to detach, for example, root_vol:</PARAGRAPH>
<CODE>
# <USERINPUT>xlv_admin</USERINPUT>
...
1.      Add a ve to an existing plex.
...
12.     Detach a plex from an existing volume.
...
42.     Show information for an object.
................ Exit ................
99.     Exit
&space;Please select choice...
xlv_admin> <USERINPUT>42</USERINPUT>
Please enter name of object to be operated on.
xlv_admin> <USERINPUT>root_vol</USERINPUT>

============= Displaying Requested Object ==========
vol root_vol
ve root_vol.data.0.0 [active]
&space;       start=0, end=1992629, (cat)grp_size=1
&space;       /dev/dsk/dks0d1s0 (1992630 blks)
ve root_vol.data.1.0 [active]
&space;       start=0, end=1992629, (cat)grp_size=1
&space;       /dev/dsk/dks0d2s0 (1992630 blks)
</CODE>
</LIST>
<LIST><PARAGRAPH>Detach plex 1 and give it the name plex1 by giving these commands:</PARAGRAPH>
<CODE>
xlv_admin> <USERINPUT>12</USERINPUT>
Please enter name of object to be operated on.
xlv_admin> <USERINPUT>root_vol</USERINPUT>
&space;Please select plex number (0-3).
xlv_admin> <USERINPUT>1</USERINPUT>
Please enter name of new object.
xlv_admin> <USERINPUT>plex1</USERINPUT>
&space;Please select choice...
</CODE>
</LIST>
<LIST><PARAGRAPH>To examine the volume and the detached plex, give these commands:</PARAGRAPH>
<CODE>
xlv_admin> <USERINPUT>42</USERINPUT>
Please enter name of object to be operated on.
xlv_admin> <USERINPUT>plex1</USERINPUT>

============= Displaying Requested Object ==========
plex plex1
ve plex1.0 [empty]
&space;       start=0, end=1992629, (cat)grp_size=1
&space;       /dev/dsk/dks0d2s0 (1992630 blks)


&space;Please select choice...
xlv_admin> <USERINPUT>42</USERINPUT>
Please enter name of object to be operated on.
xlv_admin> <USERINPUT>root_vol</USERINPUT>

============= Displaying Requested Object ==========
vol root_vol
ve root_vol.data.0.0 [active]
&space;       start=0, end=1992629, (cat)grp_size=1
&space;       /dev/dsk/dks0d1s0 (1992630 blks)
</CODE>
</LIST>
<LIST><PARAGRAPH>Exit <COMMAND>xlv_admin</COMMAND>:</PARAGRAPH>
<CODE>
xlv_admin> <USERINPUT>99</USERINPUT>
#
</CODE>
</LIST>
</ORDEREDLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Deleting an XLV Object</TITLE><PARAGRAPH>You can delete a volume or any other XLV object by using selection 31 of the <INDEXTARGET ID="ch4120"><!-- POSTPROCESSDATA: ch4120|<ITALICS>xlv_admin</ITALICS> utility:deleting volume objects --><INDEXTARGET ID="ch4121"><!-- POSTPROCESSDATA: ch4121|logical volumes:deleting objects --><INDEXTARGET ID="ch4122"><!-- POSTPROCESSDATA: ch4122|plexes:deleting --><INDEXTARGET ID="ch4123"><!-- POSTPROCESSDATA: ch4123|volume elements:deleting --><COMMAND>xlv_admin</COMMAND> command menu. The procedure is:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>If you are deleting a volume, you must unmount it first. For example:</PARAGRAPH>
<CODE>
<USERINPUT>umount /vol1</USERINPUT>&space;
</CODE>
</LIST>
<LIST><PARAGRAPH>Start <COMMAND>xlv_admin</COMMAND> and list the root of each object hierarchy on the system:</PARAGRAPH>
<CODE>
# <USERINPUT>xlv_admin</USERINPUT>
...
31.     Delete an object.
...
41.     Show object by name and type, only.
...
99.     Exit
&space;Please select choice...
xlv_admin> <USERINPUT>41</USERINPUT>

==================== Listing Objects =============
Volume:          `root_vol'
Plex:            `plex1'
</CODE>
</LIST>
<LIST><PARAGRAPH>Delete the object, for example the plex plex1:</PARAGRAPH>
<CODE>
xlv_admin> <USERINPUT>31</USERINPUT>
Please enter name of object to be operated on.
xlv_admin> <USERINPUT>plex1</USERINPUT>
</CODE>
</LIST>
<LIST><PARAGRAPH>Confirm that the object is gone:</PARAGRAPH>
<CODE>
xlv_admin> <USERINPUT>41</USERINPUT>

==================== Listing Objects =============
Volume:          `root_vol'
</CODE>
</LIST>
<LIST><PARAGRAPH>Exit <COMMAND>xlv_admin</COMMAND>:</PARAGRAPH>
<CODE>
xlv_admin> <USERINPUT>99</USERINPUT>
#
</CODE>
</LIST>
</ORDEREDLIST>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="94109">Using the Real-Time Subvolume</TITLE><PARAGRAPH>Files created on the real-time subvolume of an XLV logical volume are known as real-time files. The next three sections describe the special characteristics of these files.<INDEXTARGET ID="ch4124"><!-- POSTPROCESSDATA: ch4124|real-time subvolumes:creating files --><INDEXTARGET ID="ch4125"><!-- POSTPROCESSDATA: ch4125|real-time files --></PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Files on the Real-Time Subvolume and Utilities</TITLE><PARAGRAPH>Real-time files have some special characteristics that cause standard IRIX utilities to operate in ways that you might not expect. In particular:<INDEXTARGET ID="ch4126"><!-- POSTPROCESSDATA: ch4126|real-time subvolumes:and utilities --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>You cannot create real-time files using any standard utilities. Only specially-written programs can create real-time files. The next section, <XREF IDREF="20080" TYPE="TITLE">&ldquo;Creating Files on the Real-time Subvolume,&rdquo;</XREF> explains how.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Real-time files are displayed by <INDEXTARGET ID="ch4127"><!-- POSTPROCESSDATA: ch4127|<ITALICS>fcntl</ITALICS> system call --><COMMAND>ls</COMMAND>(1), just as any other file. However, there is no way to tell from the <COMMAND>ls</COMMAND> output whether a particular file is on a data subvolume or is a real-time file on a real-time subvolume. Only a specially-written program can determine the type of a file. The F_FSGETXATTR <COMMAND>fcntl</COMMAND>(2) system call is used to determine if a file is a real-time or a standard data file. If the file is a real-time file, the fsx_xflags field of the fsxattr structure has the XFS_XFLAG_REALTIME bit set.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The <INDEXTARGET ID="ch4128"><!-- POSTPROCESSDATA: ch4128|<ITALICS>df</ITALICS> utility and XLV --><COMMAND>df</COMMAND>(1) utility displays the disk space in the data subvolume by default. When the <BOLD>&ndash;r</BOLD> option is given, the real-time subvolume's disk space and usage is added. <COMMAND>df</COMMAND> can report that there is free disk space in the filesystem when the real-time subvolume is full, and <COMMAND>df &ndash;r</COMMAND> can report that there is free disk space when the data subvolume is full.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="20080">Creating Files on the Real-time Subvolume</TITLE><PARAGRAPH>To create a real-time file, use the F_FSSETXATTR <COMMAND>fcntl</COMMAND>(2) system call with the XFS_XFLAG_REALTIME bit set in the fsx_xflags field of the fsxattr structure. This must be done after the file has first been created/opened for writing, but before any data has been written to the file. Once data has been written to a file, it cannot be changed from a standard data file to a real-time file, nor can files created as real-time files be changed to standard data files.</PARAGRAPH>
<PARAGRAPH>Real-time files can only be read or written using direct I/O. Therefore, <INDEXTARGET ID="ch4129"><!-- POSTPROCESSDATA: ch4129|direct I/O --><COMMAND>read</COMMAND>(2) and <COMMAND>write</COMMAND>(2) operations to a real-time file must meet the requirements specified by the F_DIOINFO <COMMAND>fcntl</COMMAND>(2) call. See the <COMMAND>open</COMMAND>(2) reference page for a discussion of the O_DIRECT option to the <COMMAND>open</COMMAND>() system call. </PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Guaranteed-Rate I/O and the Real-Time Subvolume</TITLE><PARAGRAPH>The real-time subvolume is used by applications for files that require fixed I/O rates. This feature, called guaranteed-rate I/O, is described in <XREF IDREF="23852" TYPE="TITLE">Chapter&nbsp;5, &ldquo;Guaranteed-Rate I/O.&rdquo;</XREF></PARAGRAPH>
<PARAGRAPH>&space;</PARAGRAPH>
</SECTION2>
</SECTION1>
</CHAPTER>
