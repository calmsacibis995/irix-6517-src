<!-- Fragment document type declaration subset:
ArborText, Inc., 1988-1997, v.4001
<!DOCTYPE SGIDOCBK PUBLIC "-//Silicon Graphics, Inc.//DTD DocBook V2.3-based Subset V1.5//EN">
-->
<chapter id="Z76497" label="3">
<title>Miser Batch Processing System</title>
<para><indexterm><primary>Miser</primary><secondary>overview</secondary></indexterm>Miser is a resource management facility that provides deterministic batch scheduling of applications with known time and space requirements without requiring static partitioning of system resources. When Miser is given a job, it searches through the time/space pool that it manages to find an allocation that best fits the job's resource requirements.</para>
<para>Miser has an extensive administrative interface that allows most parameters to be modified without requiring a restart. Miser runs as a separate trusted process. All communication to Miser, either from the kernel or the user, is done through a series of Miser commands. Miser accepts requests for process scheduling, process state changes, and batch system configuration control, and returns values and status information for those requests.</para>
<section>
<title>Miser Overview</title>
<para><indexterm id="ITch07-3"><primary>Miser</primary><secondary>pools</secondary></indexterm>Miser manages a set of time/space pools. The time component of the pool defines how far into the future Miser can schedule jobs. The space component of the pool is the set of resources against which a job can be scheduled. This component can vary with time.</para>
<para><indexterm id="ITch07-4"><primary>Miser</primary><secondary>system pool</secondary></indexterm>A system pool represents the set of resources (number of CPUs and physical memory) that is available to Miser. A set of user-defined pools represents resources against which jobs can be scheduled. The resources owned by the user pools cannot exceed the total resources available to Miser. Resources managed by Miser are available to non-Miser applications when they are unused by a scheduled job.</para>
<para>Associated with each pool is a definition of the pool resources, a set of jobs allocating resources from the pool, and a policy that controls the scheduling of jobs. The collection of the resource pool, jobs scheduled, and policy is called a <indexterm id="ITch07-5"><primary>Miser</primary><secondary>queue</secondary></indexterm><emphasis>queue</emphasis>.</para>
<para>The queues allow for fine-grained resource management of the batch system. The resources allotted to a queue can vary with time. For example, a queue can be configured to manage 5 CPUs during the day and 20 during the night. The use of multiple queues allows the resources to be partitioned among different users of a batch system. For example, on a 24 CPU system, it is possible to define two queues: one that has 16 CPUs and another that has 6 CPUs (assuming that 2 CPUs have been kept outside
the control of Miser). It is possible to restrict access to queues to particular users or groups of users on a system to enforce this resource partition.</para>
<para>The policy defines the way a block of time/space is searched to satisfy the resource request made by the application. Miser has two policies: &ldquo;default&rdquo; and &ldquo;repack.&rdquo; Default is the first fit policy. Once a job is scheduled, its start and end time remain constant. If an earlier job finishes ahead of schedule, it does not have an effect on the start/end time of future scheduled jobs. On the other hand, in addition to using the first fit policy, repack maintains the order
of the scheduled jobs and attempts to reschedule the jobs to pull them ahead in time in the event of a job's early termination.</para>
<para>Users submit jobs to the queue using the <literal>miser_submit</literal> command, which specifies the queue to which the job should be attached and a resource request to be made against the queue. Each Miser job is an IRIX process group. The resource request is a tuple of time and space. The time is the total CPU wall-clock time if run on a single CPU. The space is the logical number of CPUs and the physical memory required. The request is passed to Miser, and Miser schedules the job against
the queue's resources using the policy attached to the queue. Miser returns a start and end time for the job to the user.</para>
<para>When a job's start time has not yet arrived, the job is in batch state. A job in batch state has lower priority than any non-weightless process. A job in batch state may execute if the system has idle resources; it is said to run opportunistically. When the specified execution time arrives, the job state is changed to batch critical, and the job then has priority over any non-realtime process. The time spent executing in batch state does not count against the time that has been requested and
scheduled. While the process is in batch critical state, it is guaranteed the physical memory and CPUs that it requested. The process is terminated if it exceeds its time allotment or uses more physical memory than it had requested.</para>
<para>A job with the static flag specified that was scheduled with the default policy will only run when the segment is scheduled to run. It will not run earlier even if idle resources are available to the job. If a job is scheduled with the repack policy, it may run earlier.</para>
<section>
<title>About Logical Number of CPUs</title>
<para><indexterm id="ITch07-6"><primary>Miser</primary><secondary>logical number of CPUs</secondary></indexterm> <indexterm id="ITch07-7"><primary>Miser</primary><secondary>CPU allocation</secondary></indexterm>When a job is scheduled by Miser, it requests that a number of CPUs and some amount of memory be reserved for use by the job. When the time period during which these resources were reserved for the job arrives, Miser reserves specific CPUs and some amount of logical swap space for the job.
</para>
<para>There are a number of issues that affect CPU allocation for a job. When a job becomes batch critical, Miser will try to find a dense cluster of nodes. If it fails to find such a cluster, it will assign the threads of the job to any free CPUs that are available. These CPUs may be located at distant parts of the system.</para>
</section>
<section>
<title>The Effect of Reservation of CPUs on Interactive Processes</title>
<para>The way in which Miser handles the reservation of CPUs is one of its strengths. Miser controls and reserves CPUs based on a logical number, not on physical CPUs. This provides Miser with flexibility in how it controls CPU resources.</para>
<para>Interactive and batch processes that run opportunistically are allowed to use all CPUs in a system that have not been reserved for Miser jobs. If new jobs are submitted, Miser attempts to schedule the jobs based on the amount of logical resources still available to Miser. As a result, CPUs could become reserved by Miser, and the interactive processes would no longer be able to execute on the newly reserved CPUs. However, if a resource is not being used by Miser, the resource is free to be used
by any other application. Miser will claim the resource when it needs it.</para>
</section>
<section>
<title>About Miser Memory Management</title>
<para><indexterm id="ITch07-8"><primary>Miser</primary><secondary>memory management</secondary></indexterm>While Miser only reserves CPUs when they are needed, memory must be reserved before it is needed.</para>
<para>When Miser is started, it is told the number of CPUs and amount of memory that it will be able to reserve for use by jobs. The number of CPUs is a logical number. When a Miser job becomes batch critical, it is assigned a set of CPUs. Until a Miser job requires a CPU (in other words, until a process or thread is ready to run), the CPU is available to the rest of the system. When a Miser job's thread begins executing, the currently non-Miser thread is preempted and resumes on a CPU where no Miser
thread is currently running.</para>
<para>Memory resources are quite different than CPU resources. The memory that Miser uses to reserve for jobs is called <indexterm id="ITch07-9"><primary>Miser</primary><secondary>logical swap space</secondary></indexterm><emphasis>logical swap space</emphasis>. Logical swap space is defined as the sum total of physical memory (less space occupied by the kernel) and all the swap devices.</para>
<para>When Miser begins, it needs to reserve memory for its jobs. However, it does not need to reserve physical memory; it simply needs to make sure that there is enough physical memory plus swap to move non-Miser jobs memory to. Miser does this by reserving logical swap equal to the memory that it requires.</para>
<para>Only jobs that are submitted to Miser are able to use allocations of the logical swap space that was reserved for Miser. However, any physical memory that is not being used by Miser is free to be used by any other application. Miser will claim the physical memory when it needs it.</para>
</section>
<section>
<title>How Miser Management Affects Users</title>
<para>If a user submits a job to Miser, that job will have an allocation of resources reserved for the requested time period. The job will not have to compete for system resources. As a result, the job should complete more quickly and have more stable run-times than it would if run as an interactive job. However, there is a cost. Because Miser is space sharing the resources, the job must wait until its scheduled reservation period before the requested resources will be reserved. Prior to that time,
the non-static job may run opportunistically, competing with the interactive workload, but at a lower priority than the interactive workload.</para>
<para>If a user is working interactively, the user will not have full access to all of the system resources. The user's interactive processes will have access to all of the unreserved CPUs on the system, but the processes will only have a limited amount of logical swap space available for memory allocation. The amount of logical swap space available for non-Miser jobs is the amount not reserved by Miser when it was started.</para>
</section>
</section>
<section>
<title>Miser Configuration</title>
<para><indexterm id="ITch07-10"><primary>Miser</primary><secondary>configuration</secondary></indexterm>The central configurable aspect of Miser is the set of queues. The Miser queues define the resources allocated to Miser.</para>
<para>The configuration of Miser consists of the following:</para>
<itemizedlist>
<listitem><para>Set up the Miser system queue definition file. Every Miser system must have a Miser system queue definition file. This file's vector definition specifies the maximum resources available to any other queue's vector definition.</para>
</listitem>
<listitem><para>Define the queues by setting up the Miser user queue definition file.</para>
</listitem>
<listitem><para>Enumerate all the queues that will be part of the Miser system by setting up the Miser configuration file.</para>
</listitem>
<listitem><para>Set up the Miser commandline options file to define the maximum CPUs and memory that can be managed by Miser.</para>
</listitem></itemizedlist>
<section>
<title>Setting Up the Miser System Queue Definition File</title>
<para><indexterm id="ITch07-11"><primary>Miser</primary><secondary>system queue definition file setup</secondary></indexterm>The Miser system queue definition file (<filename>/etc/miser_system.conf</filename>) defines the resources managed by the system pool. This file defines the maximum duration of the pool. All other queues must be less than or equal to the system queue. The system queue identifies the maximum limit for resources that a job can request. It is required that a Miser system queue
be configured.</para>
<para>Valid tokens are as follows:</para>
<deflist>
<deflistentry>
<term>POLICY <replaceable>name</replaceable></term>
<listitem><para>The policy is always &ldquo;none&rdquo; as the system queue has no policy.</para>
</listitem></deflistentry>
<deflistentry>
<term>QUANTUM <replaceable>time</replaceable></term>
<listitem><para>The size of the quantum. A <emphasis>quantum</emphasis> is the Miser term for an arbitrary number of seconds. The quantum is used to specify how you want to break up the time/space pool. It is specified in both the system queue definition file and in the user queue definition file and must be the same in both files.</para>
</listitem></deflistentry>
<deflistentry>
<term>NSEG <replaceable>number</replaceable></term>
<listitem><para>The number of resource segments.</para>
</listitem></deflistentry>
<deflistentry>
<term>SEGMENT</term>
<listitem><para>Defines the beginning of a new segment of the vector definition. Each new segment must begin with the <replaceable>SEGMENT</replaceable> token. Each segment must contain at a minimum the number of CPUs, memory, and wall-clock time.</para>
</listitem></deflistentry>
<deflistentry>
<term>START <replaceable>number</replaceable></term>
<listitem><para>The number of quanta from 0 that the segment begins at. The origin for time is 00:00 Thursday, January 1st 1970 local time.</para>
<para>Miser maps the start and end times to the current time by repeating the queue forward until the current day. For example, a 24-hour queue always begins at midnight of the current day.</para>
</listitem></deflistentry>
<deflistentry>
<term>END <replaceable>number</replaceable></term>
<listitem><para>The number of quanta from 0 that the segment ends at.</para>
</listitem></deflistentry>
<deflistentry>
<term>NCPUS <replaceable>number</replaceable></term>
<listitem><para>The number of CPUs.</para>
</listitem></deflistentry>
<?Pub _newpage>
<deflistentry>
<term>MEMORY <replaceable>amount</replaceable></term>
<listitem><para>The amount of memory, specified by an integer followed by an optional unit of k for kilobytes, m for megabytes, or g for gigabytes. If no unit is specified, the default is bytes.</para>
</listitem></deflistentry>
</deflist>
<para>The following system queue definition file defines a queue that has a quantum of 20 seconds and 1 element in the vector definition. The start and end times of each multiple are specified in quanta, not in seconds.</para>
<para>The segment defines a resource multiple beginning at 00:00 and ending at 00:20, with 1 CPU and 5 megabytes of memory.</para>
<programlisting>POLICY none # System queue has no policy
QUANTUM 20 # Default quantum set to 20 seconds
NSEG 1
&nbsp;
SEGMENT
START 0
END 60# Number of quanta (20min*60sec) / 20
NCPUS 1
MEMORY 5m</programlisting>
</section>
<section>
<title>Setting Up the Miser User Queue Definition FIle</title>
<para><indexterm id="ITch07-12"><primary>Miser</primary><secondary>user queue definition file setup</secondary></indexterm>The Miser user queue definition file (<filename>/etc/miser_default.conf</filename>) defines the CPUs, the physical memory, the policy name, and the resource pool of the queue. The file consists of a header that specifies the policy of the queue, the number of resource segments, and the quantum used by the queue.</para>
<para>Access to a queue is controlled by the file permissions of the queue definition file. Read permission allows a user to examine the contents of the queue using the <literal>miser_qinfo</literal> command. Execute permission allows a user to schedule a job on a queue using the <literal>miser_submit</literal> command. Write permission allows a user to modify the resources of a queue using the <literal>miser_move</literal> and <literal>miser_reset</literal> commands.</para>
<para>The default user queue definition file can be used as a template for other user queue definition files. Each Miser queue has a separate queue definition file, which is named in the overall Miser configuration file (<filename>/etc/miser.conf</filename>	).</para>
<para>Users schedule against the resources managed by the user queues, not against the system queue. If the duration specified by a user queue is less than that specified by the system queue, the user queue will be repeated again and again (for example, the system queue specifies one week and the user queue specifies 24 hours). If the user queue does not divide into the system queue (for example, the system queue is 6 and the user queue is&nbsp;5), the user queue will repeat evenly.</para>
<para>Valid tokens are as follows:</para>
<deflist>
<deflistentry>
<term>POLICY <replaceable>name</replaceable></term>
<listitem><para>The name of the policy that will be used to schedule applications submitted to the queue. The two valid policies are &ldquo;default&rdquo; and repack.&rdquo; Default is the first fit policy; it specifies that once a job is scheduled, its start and end time remain constant. Repack maintains the order of the scheduled jobs and attempts to reschedule the jobs to pull them ahead in time in the event of a job's early termination. Note that both policies initially use the first fit method
when scheduling a job.</para>
</listitem></deflistentry>
<deflistentry>
<term>QUANTUM <replaceable>time</replaceable></term>
<listitem><para>The size of the quantum. A <emphasis>quantum</emphasis> is the Miser term for an arbitrary number of seconds. The quantum is used to specify how you want to break up the time/space pool. It is specified in both the system queue definition file and in the user queue definition file and must be the same in both files.</para>
</listitem></deflistentry>
<deflistentry>
<term>NSEG <replaceable>number</replaceable></term>
<listitem><para>The number of resource segments.</para>
</listitem></deflistentry>
<deflistentry>
<term>SEGMENT</term>
<listitem><para>Defines the beginning of a new segment of the vector definition. Each new segment must begin with the <replaceable>SEGMENT</replaceable> token. Each segment must contain at a minimum the number of CPUs, memory, and wall-clock time.</para>
</listitem></deflistentry>
<deflistentry>
<term>START <replaceable>number</replaceable></term>
<listitem><para>The number of quanta from 0 that the segment begins at. The origin for time is 00:00 Thursday, January 1st 1970 local time.</para>
<para>Miser maps the start and end times to the current time by repeating the queue forward until the current day. For example, a 24-hour queue always begins at midnight of the current day.</para>
</listitem></deflistentry>
<deflistentry>
<term>END <replaceable>number</replaceable></term>
<listitem><para>The number of quanta from 0 that the segment ends at.</para>
</listitem></deflistentry>
<deflistentry>
<term>NCPUS <replaceable>number</replaceable></term>
<listitem><para>The number of CPUs.</para>
</listitem></deflistentry>
<?Pub _newpage>
<deflistentry>
<term>MEMORY <replaceable>amount</replaceable></term>
<listitem><para>The amount of memory, specified by an integer followed by an optional unit of k for kilobytes, m for megabytes, or g for gigabytes. If no unit is specified, the default is bytes.</para>
</listitem></deflistentry>
</deflist>
<para>The following user queue definition file defines a queue using the policy named &ldquo;default&rdquo;. It has a quantum of 20 seconds and 3 elements to the vector definition. The start and end times of each multiple are specified in quanta, not in seconds.</para>
<itemizedlist>
<listitem><para>The first segment defines a resource multiple beginning at 00:00 and ending at 00:50, with 50 CPUs and 100&nbsp;MB of memory.</para>
</listitem>
<listitem><para>The second segment defines a resource multiple beginning at 00:51.67 and ending at 01:00, with 50 CPUs and 100&nbsp;MB.</para>
</listitem>
<listitem><para>The third segment defines a resource multiple beginning at 01:02.00 and ending at 01:03.33, also with 50 CPUs and 100&nbsp;MB of memory.</para>
<programlisting>POLICY default
QUANTUM 20
NSEG 3
&nbsp;
SEGMENT
START 0
END 150 (50min*60sec) / 20
NCPUS 50
MEMORY 100m
&nbsp;
SEGMENT
START 155 ((51min*60sec)+67) / 20
END 185 (1h*60min*60sec) / 20
NCPUS 50
MEMORY 100m
&nbsp;
SEGMENT
START 186 ((1h*60min*60sec)+(2min*60sec)) / 20
END 190 ((1h*60min*60sec)+(3min*60sec)+33sec) / 20
NCPUS 50
MEMORY 100m</programlisting>
</listitem></itemizedlist>
</section>
<section>
<title>Setting Up the Miser Configuration FIle</title>
<para><indexterm id="ITch07-13"><primary>Miser</primary><secondary>configuration file setup</secondary></indexterm>The Miser configuration file (<filename>/etc/miser.conf</filename>) lists the names of all Miser queues and the path name of the queue definition file for each queue. This file enumerates all the queue names and their queue definition files.</para>
<para>Every Miser configuration file must include as one of the queues the Miser system queue that defines the resources of the system pool. The Miser system queue is identified by the queue name &ldquo;system.&rdquo;</para>
<para>Valid tokens are as follows:</para>
<deflist termlength="nextline">
<deflistentry>
<term>QUEUE <replaceable>queue_name queue_definition_file_path</replaceable></term>
<listitem><para>The <replaceable>queue_name</replaceable> identifies the queue when using any interface to Miser. The queue name must be between 1 and 8 characters long. The queue name &ldquo;system&rdquo; is used to designate the Miser system queue.</para>
</listitem></deflistentry>
</deflist>
<para>The following is a sample Miser configuration file:</para>
<programlisting># Miser config file
QUEUE system /hosts/foobar/usr/local/data/system.conf
QUEUE user /hosts/foobar/usr/local/data/usr.conf</programlisting>
</section>
<section>
<title>Setting Up the Miser CommandLine Options File</title>
<para><indexterm id="ITch07-14"><primary>Miser</primary><secondary>command-line options file setup</secondary></indexterm>The Miser commandline options file (<filename>/etc/config/miser.options</filename>) defines the maximum CPUs and memory that can be managed by Miser.</para>
<para>The <command>-c</command> flag defines the maximum number of CPUs that Miser can use. This value is the maximum number of CPUs that any resource segment of the system queue can reserve.</para>
<para>The <command>-m</command> flag defines the maximum memory that Miser can use. This value is the maximum memory that any resource segment of the system queue can reserve. The memory reserved for Miser comes from physical memory. The amount of memory that Miser uses should be less than the total physical memory, leaving enough memory for kernel use. Also, the system should have at least the amount of swap space configured for Miser so that if Miser memory is in full use, the system will have anough
swap space to move previous non Miser submitted processes out of the way.</para>
<?Pub _newpage>
<para>The following example sets the <command>-c</command> and <command>-m</command> values in the commandline options file to <replaceable>1</replaceable> and <replaceable>5</replaceable> megabytes, respectively:</para>
<programlisting>-f/etc/miser.conf -v -d -c 1 -m 5m </programlisting>
<para>The <command>-v</command> flag specifies verbose mode, which results in additional output.</para>
<para>The <command>-d</command> flag specifies debug mode. When this mode is specified, the application does not relinquish control of the tty (that is, it does not become a daemon). This mode is useful in conjunction with the <command>-v</command> flag to figure out why Miser may not be starting up correctly.</para>
<note><para>The <command>-C</command> flag can be used to release any Miser reserved resources after the Miser daemon is killed and before it is restarted. For additional information, see the <command sectionref="1">miser</command> man page.</para>
</note>
</section>
<section>
<title>Configuration Recommendations</title>
<para><indexterm id="ITch07-15"><primary>Miser</primary><secondary>configuration recommendations</secondary></indexterm>The configuration of Miser is site dependent. The following guidelines may be helpful:</para>
<itemizedlist>
<listitem><para>The system must be balanced for interactive/batch use. One suggestion is to keep at least one or two processors outside the control of Miser at all times. These two processors will act as the interactive portion of the system when all of the Miser managed CPUs are reserved. For an interactive load, you typically want the load average for the CPUs to be less than 2.0. Keep this in mind as you adjust for the optimal number of free CPUs.</para>
</listitem>
<listitem><para>The amount of free logical swap should be balanced against the number of free CPUs. When you have a system with <replaceable>N</replaceable> CPUs, you should also have an appropriate amount of memory to be used by processes running on those <replaceable>N</replaceable> CPUs. Also, many system administrators like to back up this memory with swap space. If you think of the free CPUs as a separate system and provide memory and swap space accordingly, interactive work should perform well.
Remember that the free memory not reserved by Miser is logical swap space (the combination of physical memory and the swap devices).</para>
</listitem>
<listitem><para>Be careful when using virtual swap. When no Miser application is running, time-share processes can consume all of physical memory. When Miser runs, it begins to reclaim physical memory and swaps out time-share processes. If the system is using virtual swap, there may be no physical swap to move the process to, and at that point the time-share process may be terminated.</para>
</listitem></itemizedlist>
</section>
</section>
<section>
<title>Miser Configuration Examples</title>
<para><indexterm id="ITch07-16"><primary>Miser</primary><secondary>configuration examples</secondary></indexterm>In the examples used in this section, the system has 12 CPUs and 160&nbsp;MB available to user programs.</para>
<para>Example 1:</para>
<para>In this example, the system is dedicated to batch scheduling with one queue, 24 hours a day.</para>
<para>The first step is to define a system queue. You must decide how long you want the system queue to be. The length of the system queue defines the maximum duration of any job submitted to the system. For this system, you have determined that the maximum duration for any one job can be 48 hours, so you define the system vector to have a duration of 48 hours.</para>
<programlisting># The system queue /usr/local/miser/system.conf
POLICY none # System queue has no policy
QUANTUM 20 # Default quantum set to 20 seconds
NSEG 1
&nbsp;
SEGMENT
NCPUS 12
MEMORY 160m
START 0
END 8640 # Number of quanta (48h*60 min*60 sec) / 20</programlisting>
<para>The next step is to define a user queue.</para>
<programlisting># The user queue /usr/local/miser/physics.conf
POLICY default # First fit, once scheduled maintains start/end time
QUANTUM 20 # Default quantum set to 20 seconds
NSEG 1
&nbsp;
SEGMENT
NCPUS 12
MEMORY 160m
START 0
END 8640 # Number of quanta (48h*60 min*60 sec) / 20</programlisting>
<?Pub _newpage>
<para>The last step is to define a Miser configuration file:</para>
<programlisting># Miser config file
QUEUE system /usr/local/miser/system.conf
QUEUE physics /usr/local/miser/physics.conf</programlisting>
<para>Example 2:</para>
<para>In the following example, the system is dedicated to batch scheduling, 24 hours a day, and split between two user groups: chemistry and physics. The system must be divided between them with a ratio of 75% for physics and 25% for chemistry.</para>
<para>The system queue is identical to the one given in Example 1.</para>
<para>The physics user queue appears as follows:</para>
<programlisting># The physics queue /usr/local/miser/physics
POLICY default # System queue has no policy
QUANTUM 20 # Default quantum set to 20 seconds
NSEG 1
&nbsp;
SEGMENT
NCPUS 8
MEMORY 120m
START 0
END 8640 # Number of quanta (48h*60min*60sec) / 20</programlisting>
<para>Next, you define the chemistry queue:</para>
<programlisting># The chemistry queue /usr/local/miser/chemistry.conf
POLICY default # System queue has no policy
QUANTUM 20 # Default quantum set to 20 seconds
NSEG 1
&nbsp;
SEGMENT
NCPUS 4
MEMORY 40m
START 0
END 8640 # Number of quanta (48h*60min*60sec) / 20</programlisting>
<para>To restrict access to each queue, you create the user group physics and the user group chemistry. You then set the permissions on the physics queue definition file to execute only for group physics and similarly for the chemistry queue.</para>
<para>Having defined the physics and chemistry queue, you can now define the Miser configuration file:</para>
<programlisting># Miser configuration file
QUEUE system /usr/local/miser/system.conf
QUEUE physics /usr/local/miser/physics.conf
QUEUE chem /usr/local/miser/chemistry.conf</programlisting>
<para>Example 3:</para>
<para>In this example, the system is dedicated to time-sharing in the morning and to batch use in the evening. The evening is 8:00 P.M. to 4:00 A.M., and the morning is 4:00 A.M. to 8:00 P.M.</para>
<para>First you define the system queue.</para>
<programlisting># The system queue /hosts/foobar/usr/local/data/system.conf
POLICY none # System queue has no policy
QUANTUM 20 # Default quantum set to 20 seconds
NSEG 2
&nbsp;
SEGMENT
NCPUS 12
MEMORY 160m
START 0
END 720 # (4h*60min*60sec) / 20
&nbsp;
SEGMENT
NCPUS 12
MEMORY 160m
START 3600 # (8pm is 20 hours from UTC, so 20h*60min*60sec) / 20
END 4320</programlisting>
<para>Next, you define the batch queue:</para>
<programlisting># User queue
POLICY repack # Repacks jobs (FIFO) if a job finishes early
QUANTUM 20 # Default quantum set to 20 seconds
NSEG 2
&nbsp;
SEGMENT
NCPUS 12
MEMORY 160m
START 0
END 720 # (4h*60min*60sec) / 20
&nbsp;
SEGMENT
NCPUS 12
MEMORY 160m
START 3600 # (8pm is 20 hours from 0, so 20h*60min*60sec) / 20
END 4320</programlisting>
<para>The last step is to define a Miser configuration file:</para>
<programlisting># Miser config file
QUEUE system /usr/local/miser/system.conf
QUEUE user /usr/local/miser/usr.conf</programlisting>
</section>
<section>
<title>Starting and Stopping Miser</title>
<para><indexterm id="ITch07-17"><primary>Miser</primary><secondary>starting</secondary></indexterm>After the Miser configuration files are modified appropriately, Miser can be selected for boot-time startup with the <command sectionref="1">chkconfig</command> command and the system can be rebooted, or Miser can be started directly by <emphasis>root</emphasis> with the command <literal>/etc/init.d/miser start</literal>. When starting Miser manually without rebooting, the <literal>chkconfig</literal>
command must be issued first or Miser will not start up.</para>
<para>To start Miser manually, use the following command sequence:</para>
<literallayout><userinput>chkconfig miser on</userinput>
<userinput>/etc/init.d/miser start</userinput></literallayout>
<para><indexterm id="ITch07-18"><primary>Miser</primary><secondary>stopping</secondary></indexterm> Miser can be stopped at any time by <emphasis>root</emphasis> with the following command sequence:</para>
<literallayout><userinput>/etc/init.d/miser stop</userinput>
<userinput>/etc/init.d/miser cleanup</userinput></literallayout>
<para>Running Miser jobs are not stopped, and the current committed resources cannot be reclaimed until the jobs are terminated. If you are going to restart Miser after stopping it, you do not need to run the <literal>miser cleanup</literal> command.</para>
<note><para>The Miser <command>-C</command> flag can be used to release any Miser reserved resources after the Miser daemon is killed and before it is restarted.</para>
</note>
</section>
<section>
<title>Submitting Miser Jobs</title>
<para><indexterm id="ITch07-19"><primary>Miser</primary><secondary>submitting jobs</secondary></indexterm>The command to submit a job so that it is managed by Miser is as follows:</para>
<literallayout>miser_submit -q <replaceable>queue</replaceable> -o c=<replaceable>cpus</replaceable>,m=<replaceable>memory</replaceable>, t=<replaceable>time</replaceable>[,static] <replaceable>command</replaceable>
miser_submit -q <replaceable>queue</replaceable> -f <replaceable>file</replaceable>&ensp;<replaceable>command</replaceable></literallayout>
<deflist>
<deflistentry>
<term><literal>-q <?Pub Caret></literal><replaceable>queue</replaceable></term>
<listitem><para>Specifies the name of the queue against which to schedule the application.</para>
</listitem></deflistentry>
<deflistentry>
<term><literal>-o c=</literal><replaceable>cpus</replaceable>,m=<replaceable>memory</replaceable>,<literal> t=</literal><replaceable>time</replaceable><literal>[,static]</literal></term>
<listitem><para>Specifies a block of resources. The CPUs must be an integer up to the maximum number of CPUs available to the queue being scheduled against. The memory consists of an integer followed by a unit of <emphasis>k</emphasis> for kilobyte, <emphasis>m</emphasis> for megabyte, or <emphasis>g</emphasis> for gigabyte. If no unit is specified, the default is bytes.Time can be specified either as an integer followed by a unit specifier of <emphasis>h</emphasis> for hours, <emphasis>m</emphasis>
for minutes, or <emphasis>s</emphasis> for seconds, or by a string in the format <replaceable>hh</replaceable>:<replaceable>mm</replaceable><replaceable>:</replaceable><replaceable>ss</replaceable>.</para>
<para>A job with the <literal>static</literal> flag specified that was scheduled with the default policy will only run when the segment is scheduled to run. It will not run earlier even if idle resources are available to the job. If a job is scheduled with the repack policy, it may run earlier.</para>
</listitem></deflistentry>
<deflistentry>
<term><literal>-f </literal><replaceable>file</replaceable></term>
<listitem><para>File that specifies a list of resource segments. This flag allows greater control over the scheduling parameters of a job.</para>
</listitem></deflistentry>
<deflistentry>
<term><replaceable>command</replaceable></term>
<listitem><para>Specifies a script or program name.</para>
</listitem></deflistentry>
</deflist>
<para>For additional information, see the <command sectionref="1">miser_submit</command> and <command sectionref="4">miser_submit</command> man pages.</para>
<section>
<title>Querying Miser About Job Schedule/Description</title>
<para><indexterm id="ITch07-20"><primary>Miser</primary><secondary>checking job status</secondary></indexterm>The command to query Miser about the schedule/description of a submitted job is as follows:</para>
<literallayout>miser_jinfo -j <replaceable>bid </replaceable>[-d]</literallayout>
<para>The <replaceable>bid</replaceable> is the ID of the Miser job and is the process group ID of the job. The <literal>-d</literal> flag prints the job description including job owner and command.</para>
<para>Note that when the system is being used heavily, Miser swapping can take some time. Therefore, the Miser job may not begin processing immediately after it is submitted.</para>
<para>For additional information, see the <command sectionref="1">miser_jinfo</command> man page.</para>
</section>
<section>
<title>Querying Miser About Queues</title>
<para><indexterm id="ITch07-21"><primary>Miser</primary><secondary>checking queue status</secondary></indexterm>The command to query Miser for information on Miser queues, queue resource status, and a list of jobs scheduled against a queue is as follows:</para>
<literallayout>miser_qinfo -Q|-q <replaceable>queue </replaceable>[-j]|-a</literallayout>
<para>The <literal>-Q</literal> flag returns a list of currently configured Miser queue names. The <literal>-q</literal> flag returns the free resources associated with the specified queue name. The <literal>-j</literal> flag returns the list of jobs currently scheduled against the queue. The <literal>-a</literal> flag returns a list of all scheduled jobs, ordered by job ID, in all configured Miser queues and also produces a brief description of the job.</para>
<para>For additional information, see the <command sectionref="1">miser_qinfo</command> man page.</para>
</section>
<section>
<title>Moving a Block of Resources</title>
<para><indexterm id="ITch07-22"><primary>Miser</primary><secondary>checking queue status</secondary></indexterm>The command to move a block of resources from one queue to another is as follows:</para>
<literallayout>miser_move -s <replaceable>srcq </replaceable>-d <replaceable>destq</replaceable> -f <replaceable>file</replaceable>&ensp;
miser_move -s <replaceable>srcq </replaceable>-d <replaceable>destq</replaceable> -o s=<replaceable>start</replaceable>,e=<replaceable>end</replaceable>,c=<replaceable>CPUs</replaceable>,m=<replaceable>memory</replaceable></literallayout>
<para>This command removes a tuple of space from the source queue's vector and adds it to the destination queue's vector, beginning at the start time and ending at the end time. The resources added or removed do not change the vector definition, and are, therefore, temporary. The command returns a table that lists the start and end times of each resource transfer and the amount of resources transferred.</para>
<para>The <literal>-s</literal> and <literal>-d</literal> flags specify the names of any valid Miser queues. The <literal>-f</literal> flag contains a resource block specification. The <literal>-o</literal> flag specifies a block of resources to be moved. The start and end times are relative to the current time. The CPUs are an integer up to the maximum free CPUs associated with a queue. The memory is an integer with an identifier of <emphasis>k</emphasis> for kilobyte, <emphasis>m</emphasis> for
megabyte, or <emphasis>g</emphasis> for gigabyte.</para>
<note><para>The resource transfer is temporary. If Miser is killed or crashes, the resources transferred are lost, and Miser will be unable to restart.</para>
</note>
<para>For additional information, see the <command sectionref="1">miser_move</command> and <command sectionref="4">miser_move</command> man pages.</para>
</section>
<section>
<title>Resetting Miser</title>
<para><indexterm id="ITch07-23"><primary>Miser</primary><secondary>terminating a job</secondary></indexterm>The command to reset Miser with a new configuration file is as follows:</para>
<literallayout>miser_reset -f <replaceable>file</replaceable></literallayout>
<para>This command forces a running version of Miser to use a new configuration file (specified by <literal>-f </literal><replaceable>file</replaceable>). The new configuration will succeed only if all scheduled jobs can be successfully scheduled against the new configuration.</para>
<para>For additional information, see the <command sectionref="1">miser_reset</command> man page</para>
</section>
<section>
<title>Terminating a Miser Job</title>
<para><indexterm id="ITch07-24"><primary>Miser</primary><secondary>terminating a job</secondary></indexterm>The <literal>miser_kill</literal> command is used to terminate a job submitted to Miser. This command both terminates the process and contacts the Miser daemon to free any resources currently committed to the submitted process. For additional information, see the <command sectionref="1">miser_kill</command> man page.</para>
</section>
<section>
<title>Miser and Batch Management Systems</title>
<para><indexterm id="ITch07-25"><primary>Miser</primary><secondary>differences between Miser and batch management systems</secondary></indexterm>This section discusses the differences between a Miser job and a batch job from a batch management system such as the <indexterm id="ITch07-26"><primary>Network Queuing Environment</primary></indexterm> Network Queuing Environment (NQE) or Load Share Facility (LSF).<indexterm id="ITch07-27"><primary>NQE</primary></indexterm></para>
<para>Miser and batch management systems such as NQE each lack certain key characteristics. For Miser, these characteristics are features to protect and manage the Miser session. For batch management systems, the ability to guarantee resources is lacking. However, these two systems used together provide a much more capable solution, provided the batch management system supports the Miser scheduler.</para>
<para>If your site does not need the job management and protection provided by a batch management system, then Miser alone may be an adequate batch system. However, most production-quality environments require the support and protection provided by batch systems such as NQE or LSF. These sites should run a batch management system in cooperation with the Miser scheduler.</para>
</section>
<section>
<title>Defining and Managing cpusets</title>
<para><indexterm id="ITch07-28"><primary>Miser</primary><secondary>command-line options file setup</secondary></indexterm>The <literal>cpuset</literal> command is used to define and manage a set of CPUs called a <indexterm id="ITch07-29"><primary>Miser</primary><secondary>logical swap space</secondary></indexterm><emphasis>cpuset</emphasis>. A cpuset is a named set of CPUs, which may be defined as restricted or open. The <literal>cpuset</literal> command creates and destroys cpusets, retrieves information
about existing cpusets, and attaches a process and all of its children to a cpuset.</para>
<note><para>The <literal>cpuset</literal> command does not require the use of the Miser batch processing system.</para>
</note>
<para>A restricted cpuset only allows processes that are members of the cpuset to run on the set of CPUs. An open cpuset allows any process to run on its CPUs, but a process that is a member of the cpuset can only run on the CPUs belonging to the cpuset.</para>
<para>A cpuset is defined by a cpuset configuration file and a name. See the <command sectionref="4">cpuset</command> man page for a definition of the file format. The cpuset configuration file is used to list the CPUs that are members of the cpuset. It also contains any additional arguments required to define the cpuset. A cpuset name is between three and eight characters long; names of two or fewer characters are reserved.</para>
<para>The file permissions of the configuration file define access to the cpuset. When permissions need to be checked, the current permissions of the file are used. It is therefore possible to change access to a particular cpuset without having to tear it down and recreate it, simply by changing the access permission. Read access allows a user to retrieve information about a cpuset, while execute permission allows a user to attach a process to the cpuset.</para>
<para>The following is a sample configuration file that describes an exclusive cpuset containing 3 CPUs:</para>
<programlisting># cpuset configuration file
EXCLUSIVE
MEMORY_LOCAL
MEMORY_EXCLUSIVE

CPU 1
CPU 5
CPU 10</programlisting>
<para>This specification will create a cpuset containing 3 CPU. When the <literal>EXCLUSIVE</literal> flag is set, it restricts those CPUs to running threads that have been explicitly assigned to the cpuset. When the <literal>MEMORY_LOCAL</literal> flag is set, the jobs running on the cpuset will use memory from nodes containing the CPUs in the cpuset. When the <literal>MEMORY_EXCLUSIVE</literal> flag is set, jobs running on other cpusets or on the global cpuset will not use memory from these nodes.
</para>
<note><para>On a system with both Miser and cpuset configured, conflicts may occur between a CPU that a Miser queue is using and a CPU assigned to a cpuset. Miser does not have access to CPUs that belong to a cpuset configured with the <literal>EXCLUSIVE</literal> flag set.</para>
</note>
<para>Commands are newline terminated, characters following the comment delimiter, #, are ignored, case matters, and tokens are separated by whitespace which is ignored.</para>
<para>The valid tokens are as follows:<deflist>
<colheads>
<head1>Valid tokens</head1><head2>Description</head2></colheads>
<deflistentry>
<term><literal>EXCLUSIVE</literal></term>
<listitem><para>Defines a cpuset to be restricted. It can occur anywhere in the file. Anything else on the line is ignored.</para>
</listitem></deflistentry>
<deflistentry>
<term><literal>MEMORY_LOCAL</literal></term>
<listitem><para>Threads assigned to the cpuset will attempt to assign memory only from nodes within the cpuset. Assignment of memory from outside the cpuset will occur only if no free memory is available from within the cpuset. No restrictions are made on memory assignment to threads running outside the cpuset.</para>
</listitem></deflistentry>
<deflistentry>
<term><literal>MEMORY_EXCLUSIVE</literal></term>
<listitem><para>Threads not assigned to the cpuset will not use memory from within the cpuset unless no memory outside the cpuset is available.</para>
<para>When a cpuset is created and memory is occupied by threads that are already running on the cpuset nodes, no attempt is made to explicitly move this memory. If page migration is enabled, the pages will be migrated when the system detects the most references to the pages that are non-local.</para>
</listitem></deflistentry>
<deflistentry>
<term><literal>MEMORY_KERNEL_AVOID</literal></term>
<listitem><para>The kernel avoids allocating memory from nodes contained in this cpuset. If kernel memory requests cannot be satisfied from outside this cpuset, this option is ignored and allocations occur from within the cpuset. (This avoidance currently extends only to keeping buffer cache away from the protected nodes.)</para>
</listitem></deflistentry>
<deflistentry>
<term><literal>CPU</literal></term>
<listitem><para>Specifies that a CPU will be part of the cupset.</para>
</listitem></deflistentry>
</deflist></para>
<para>For a description of <literal>cpuset</literal> command arguments and additional information, see the <command sectionref="1">cpuset</command> and <command sectionref="4">cpuset</command> man pages.</para>
</section>
</section>
</chapter>
<?Pub *0000045895 0>
