<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="5"><TITLE><XREFTARGET ID="92718">Window, Session, and Desk Management</TITLE><PARAGRAPH>This chapter contains these sections:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="52150" TYPE="TITLE">&ldquo;Window, Session, and Desk Management Overview&rdquo;</XREF> briefly discusses window, session, and desk management on Silicon Graphics systems.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="14513" TYPE="TITLE">&ldquo;Implementing an Application Model&rdquo;</XREF> describes how to structure your application to follow one of the four application models.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="96868" TYPE="TITLE">&ldquo;Interacting With the Window and Session Manager&rdquo;</XREF> describes how to create windows and interact with the window and session manager.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="52150">Window, Session, and Desk Management Overview</TITLE><PARAGRAPH>This section briefly discusses features of window, session, and desk management on Silicon Graphics system:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="40567" TYPE="TITLE">&ldquo;Window Management&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="17311" TYPE="TITLE">&ldquo;Session Management&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="23180" TYPE="TITLE">&ldquo;Desk Management&rdquo;</XREF></PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>This section also provides a list of references for further reading on window and session management.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="40567">Window Management</TITLE><PARAGRAPH><INDEXTARGET ID="05.Window.Management1"><!-- POSTPROCESSDATA: 05.Window.Management1|Motif window manager4Dwm window managerwindow management --><COMMAND>4Dwm</COMMAND>, which is based on <COMMAND>mwm</COMMAND> (the Motif Window Manager), is the window manager typically used on Silicon Graphics workstations. It provides functions that allow both users and programmers to control elements of window states such as: placement, size, icon/normal display, and input-focus ownership. In addition to window management, <COMMAND>4Dwm</COMMAND> provides session and desks management.</PARAGRAPH>
<PARAGRAPH><EXTREF IDREF="42750" BOOK="UI_Glines" FILE="" HDG="42750" INFO="">Chapter&nbsp;3, &ldquo;Windows in the IRIX Interactive Desktop Environment,&rdquo;</EXTREF>
 of the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE> discusses the interactions and behaviors that your application's windows should support. <XREF IDREF="96868" TYPE="TITLE">&ldquo;Interacting With the Window and Session Manager&rdquo;</XREF> describes how to comply with the style guidelines.</PARAGRAPH>
<PARAGRAPH>See <ITALICS>IRIS Essentials</ITALICS> for more information about the features <COMMAND>4Dwm</COMMAND> provides for your users. See the <REFPAGE>mwm(1X)</REFPAGE> and <REFPAGE>4Dwm(1X)</REFPAGE> reference pages for more information about the features <COMMAND>4Dwm</COMMAND> provides.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="17311">Session Management</TITLE><PARAGRAPH>This section describes session management and explains how to add it to your application. Topics include:<INDEXTARGET ID="05.Window.Management2"><!-- POSTPROCESSDATA: 05.Window.Management2|session management --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="50285" TYPE="TITLE">&ldquo;Overview of Session Management&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="24459" TYPE="TITLE">&ldquo;Adding Session Management to Your Application&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="30184" TYPE="TITLE">&ldquo;Setting the WM_COMMAND String&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="16597" TYPE="TITLE">&ldquo;Saving Session Information to a File&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="50285">Overview of Session Management</TITLE><PARAGRAPH>Session management allows users to log out, and any applications that are running at logout automatically restart when they log back in. The 4Dwm window manager keeps a list of the applications and desks that were previously running when the user last logged out and restarts them when the user logs in again. <INDEXTARGET ID="05.Window.Management3"><!-- POSTPROCESSDATA: 05.Window.Management3|applications:restartingapplications:logging outapplications:automatically restartrestarting applications:session managementsession management:overview --></PARAGRAPH>
<PARAGRAPH>For your application to be restarted via the <COMMAND>4Dwm</COMMAND> session manager, the application must register its initial state with the session manager and make sure the current state is registered at all times.</PARAGRAPH>
<PARAGRAPH>Additionally, your application should restart in the same state it was in when the user logged out (for example, the same windows open, the same files open, and so on). To support this, you need to design your application so that when the <INDEXTARGET ID="05.Window.Management4"><!-- POSTPROCESSDATA: 05.Window.Management4|applications:statesrestarting applications:states --><COMMAND>4Dwm</COMMAND> session manager restarts it, it can redisplay any of its co-primary or support windows that were open when the user logged out, reopen any data files that were open, and so on. You can support this either by providing command-line options to your application or other mechanisms such as a state file that your application reads when it is launched.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Types of Session Management: Continuous and Explicit</TITLE><PARAGRAPH>The two types of session management include <INDEXTARGET ID="05.Window.Management5"><!-- POSTPROCESSDATA: 05.Window.Management5|session management:continuoussession management:explicitexplicit session managementcontinuous session management --><ITALICS>continuous</ITALICS> session management and <ITALICS>explicit</ITALICS> session management. Continuous session management restarts the applications that were running when the user last logged out of the window manager. This is the default setting.</PARAGRAPH>
<PARAGRAPH>Explicit session management ignores the windows that were open when the user last logged out and always opens a particular set of windows that the user has chosen. Users can configure the windows on the desktop by using the Window Settings Control Panel. They can launch this panel via the Toolchest. From the Toolchest, open the Desktop menu, select &ldquo;Customize,&rdquo; and then select &ldquo;Windows.&rdquo; The Windows Settings dialog box appears (see <XREF IDREF="39393" TYPE="GRAPHIC">Figure&nbsp;5-1</XREF>). The &ldquo;Save Windows &amp; Desks&rdquo; item on the Window Settings Control Panel configures either continuous or explicit session management. A user can select explicit, and then press the &ldquo;Set Home Session&rdquo; button to save the (current) explicit window configuration. Also, users can launch this control panel from the Icon Catalog's Control Panel page. </PARAGRAPH>
<!-- RASTERCONVERT: 05.Window.Management.cgm -->
<PARAGRAPH><FIGURE><GRAPHIC FILE="05.Window.Management-1.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="5-1"><PREFIX>Figure 5-1 </PREFIX><XREFTARGET ID="39393">Window Settings Control Panel</CAPTION>
</FIGURE>
</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="24459">Adding Session Management to Your Application</TITLE><PARAGRAPH>Applications can communicate with the window manager by setting properties on the top level window. The WM_COMMAND property gives the window manager the command line that can be used to re-invoke the application in its current state. The 4Dwm window manager sends a WM_SAVE_YOURSELF message to each window that subscribes to tell it to update its WM_COMMAND property and then reads in the value. If the user selects continuous session management, 4Dwm sends the message every 10 minutes and at logout. If the user selects explicit session management, the window manager only queries the applications when the user presses the &ldquo;Set Home Session&rdquo; button.<INDEXTARGET ID="05.Window.Management6"><!-- POSTPROCESSDATA: 05.Window.Management6|applications:window managerapplications:communicationapplications:re-invoke --></PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="30184">Setting the WM_COMMAND String</TITLE><PARAGRAPH>If you use ViewKit or <INDEXTARGET ID="05.Window.Management7"><!-- POSTPROCESSDATA: 05.Window.Management7|session management:WM_COMMANDWM_COMMAND:session management --><COMMAND>XtAppInitialize(3Xt)</COMMAND>, the initial WM_COMMAND string is set for you when the top level window is realized. Use the <COMMAND>xprop</COMMAND>(1) command to make sure the WM_COMMAND string is set correctly for the top level window. For example:</PARAGRAPH>
<CODE>
WM_COMMAND(STRING) = { &ldquo;webmagic&rdquo;, &ldquo;/usr/tmp/sgiLook.html&rdquo; }
</CODE>
<PARAGRAPH>Even if WM_COMMAND is initially set by your toolkit, you need to keep WM_COMMAND updated if your program changes its state. For instance, if the user renames a data file or successfully opens a new data file, you need to change the WM_COMMAND string with the <COMMAND>XSetCommand</COMMAND>(3X11):</PARAGRAPH>
<CODE>
XSetCommand(Display *display, Window w,char **argv,int argc);
</CODE>
<PARAGRAPH>This can be done in the function that changes the state, and is simpler than responding to the window manager's WM_SAVE_YOURSELF message.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="16597">Saving Session Information to a File</TITLE><PARAGRAPH>If your application already saves state information to a file instead of using the command line, this &ldquo;state file&rdquo; can also be used for session management. To work correctly with the user's Windows Control Panel setting, the application should update the file only in response to the window manager's WM_SAVE_YOURSELF message (see <INDEXTARGET ID="05.Window.Management8"><!-- POSTPROCESSDATA: 05.Window.Management8|session management:saving state informationstates:saving --><XREF IDREF="72263" TYPE="TEXT">Example&nbsp;5-1</XREF>, <ITALICS>saveyourself.c</ITALICS>). This strategy does not work correctly if several instances of your application are able to run at the same time. Only applications that enforced a &ldquo;Run Once&rdquo; policy can rely on this strategy. </PARAGRAPH>
<PARAGRAPH>For more information, see the ViewKit reference page, <REFPAGE>VkRunOnce(3x)</REFPAGE>, and <REFPAGE>XSetCommand(3X11)</REFPAGE>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Debugging Tips</TITLE><PARAGRAPH>When debugging:<INDEXTARGET ID="05.Window.Management9"><!-- POSTPROCESSDATA: 05.Window.Management9|window management:debuggingdebugging:session managersession management:debugging --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Use <REFPAGE>xprop(1)</REFPAGE> to see the WM_COMMAND string property.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Make sure that you use the full pathname for data file arguments, which typically are not referenced in the user's path.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>If your application has multiple windows, only set WM_COMMAND for the top-level window.&space;<INDEXTARGET ID="05.Window.Management10"><!-- POSTPROCESSDATA: 05.Window.Management10|session management:example --></PARAGRAPH>
<CODE><CAPTION LBL="5-1"><PREFIX>Example 5-1 </PREFIX><XREFTARGET ID="72263">Session Management Example Code: saveyourself.c</CAPTION>/* saveyourself.c                                       */
/*                                                      */
/* Example code for handling the window manager's       */
/* WM_SAVE_YOURSELF Protocol                            */
/*                                                      */
/* cc -o saveyourself saveyourself.c -lXm -lXt          */
&nbsp;
#include &lt;Xm/Protocols.h>
#include &lt;Xm/Label.h>
&nbsp;
void saveYourSelfCallback(Widget w,  XtPointer client_data, 
&space;                            XtPointer call_data)
{
&space;   printf(&ldquo;Update state file if needed, then update WM_COMMAND\n&rdquo;);
}
&nbsp;
void main(int argc, char** argv)
{
&space;  Widget toplevel, label;
&space;  XtAppContext app_context;
&space;  Atom WM_SAVE_YOURSELF;
&nbsp;
&space;  toplevel = XtAppInitialize(&amp;app_context, &ldquo;SaveYourSelf&rdquo;,
&space;                             NULL, 0, &amp;argc, argv, NULL, NULL, 0);
&nbsp;
&space;  label = XmCreateLabel(toplevel, &ldquo;saveme&rdquo;, NULL, 0);
&space;  XtManageChild(label);
&nbsp;
&space;  WM_SAVE_YOURSELF = XmInternAtom( XtDisplay(toplevel),
&space;                                     &ldquo;WM_SAVE_YOURSELF&rdquo;,
&space;                                     FALSE);
&nbsp;
&space;  XmAddWMProtocolCallback( toplevel, WM_SAVE_YOURSELF,
&space;                           saveYourSelfCallback, NULL );
&nbsp;
&space;  XtRealizeWidget(toplevel);
&space;  XtAppMainLoop(app_context);
}
</CODE>
</BULLET>
</BULLETLIST>
<PARAGRAPH><XREF IDREF="70788" TYPE="TITLE">&ldquo;Handling the Window Manager Save Yourself Protocol&rdquo;</XREF> describes what your application needs to do to support session management. <EXTREF IDREF="17063" BOOK="UI_Glines" FILE="" HDG="17063" INFO="">&ldquo;Session Management&rdquo; in Chapter&nbsp;3</EXTREF>
 of the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE> provides further guidelines for handling session management.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Reference</TITLE><PARAGRAPH>For more information, see <DOCTITLE>Inter-Client Communication Conventions Manual</DOCTITLE> (ICCCM). The ICCCM is reprinted as an appendix in O'Reilly and Associates, <DOCTITLE>X Protocol Reference</DOCTITLE> Manual, Volume Zero. </PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="23180">Desk Management</TITLE><PARAGRAPH>Users can use &ldquo;desks&rdquo; to create multiple virtual screens. They can assign any primary or support window to any desk, causing that window to appear in the thumbnail sketch in the Desks Overview window.<INDEXTARGET ID="05.Window.Management11"><!-- POSTPROCESSDATA: 05.Window.Management11|desk management --><INDEXTARGET ID="05.Window.Management12"><!-- POSTPROCESSDATA: 05.Window.Management12|virtual screensdesk management:virtual screensdesk management:screens --></PARAGRAPH>
<PARAGRAPH><EXTREF IDREF="53752" BOOK="UI_Glines" FILE="" HDG="53752" INFO="">&ldquo;Desks&rdquo; in Chapter&nbsp;3</EXTREF>
 of the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE> discusses the important development concerns issues relating to desks. Review the information in &ldquo;Session Management,&rdquo; and adhere to the &ldquo;Session Management Guidelines,&rdquo; and the window manager will take care of desks for you. </PARAGRAPH>
<PARAGRAPH>The key points to keep in mind are:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Transient windows appear on every desk and are not shown in the Desks overview window&mdash;so choose your transient windows carefully.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Application windows that are on a desk other than the current one are in a state similar to the minimized state&mdash;processing continues although the window is no longer mapped to the screen display. Keep this in mind when selecting which operations should continue to be processed when your application is in a minimized state.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Users can select different backgrounds for different desks, so your application should not create its own screen background. </PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="87980">Further Reading on Window and Session Management</TITLE><PARAGRAPH>For more information on window and session management with <COMMAND>4Dwm</COMMAND>, refer to the <REFPAGE>mwm(1X)</REFPAGE> and <REFPAGE>4Dwm(1X)</REFPAGE> reference pages. You may also want to look at <DOCTITLE>IRIS Essentials</DOCTITLE>, since this book explains important window and session management features to your users.</PARAGRAPH>
<PARAGRAPH>For more information on window and session management with Xt, refer to the chapters on Interclient Communication in these manuals:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><DOCTITLE>The X Window Systems Programming and Applications with Xt, OSF/Motif Edition</DOCTITLE>, Second Edition, by Doug Young</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>O'Reilly Volume Four, <DOCTITLE>X Toolkit Intrinsics Programming Manual</DOCTITLE>, OSF/Motif Edition, by Adrian Nye and Tim O'Reilly</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>For more information on window and session management with Xlib, refer to the chapters on Inter-Client Communication in O'Reilly Volume One, <DOCTITLE>Xlib Programming Manual</DOCTITLE>, by Adrian Nye. For more detailed information, refer to the <DOCTITLE>Inter-Client Communications Conventions Manual</DOCTITLE> (ICCCM). (The ICCCM is reprinted as an appendix of O'Reilly Volume Zero, <DOCTITLE>X Protocol Reference Manual</DOCTITLE>.)</PARAGRAPH>
<PARAGRAPH>More detailed information on window properties is available in the <DOCTITLE>OSF/Motif Programmer's Guide</DOCTITLE>, in the chapter on &ldquo;Inter-Client Communication Conventions.&rdquo;</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="14513">Implementing an Application Model</TITLE><PARAGRAPH><EXTREF IDREF="67644" BOOK="UI_Glines" FILE="" HDG="67644" INFO="">&ldquo;Application Models&rdquo; in Chapter&nbsp;6</EXTREF>
 of the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE>&space;describes four application models based on four different window categories: main primary windows, co-primary windows, support windows, and dialogs. It also describes how to select a model appropriate for your application. This section provides suggestions for implementing each application model, including recommended shell types for your primary windows. <INDEXTARGET ID="05.Window.Management13"><!-- POSTPROCESSDATA: 05.Window.Management13|application modelswindow categories --><XREF IDREF="96868" TYPE="TITLE">&ldquo;Interacting With the Window and Session Manager&rdquo;</XREF> describes how to create the windows and get them to look and behave in the manner described in <EXTREF IDREF="38970" BOOK="UI_Glines" FILE="" HDG="38970" INFO="">&ldquo;Application Window Categories and Characteristics&rdquo; in Chapter&nbsp;3</EXTREF>
 of the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE>.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Implementing the &ldquo;Single Document, One Primary&rdquo; Model</TITLE><PARAGRAPH>This model is the simplest to implement. You can use the ApplicationShell returned by <INDEXTARGET ID="05.Window.Management14"><!-- POSTPROCESSDATA: 05.Window.Management14|application models:&rdquo;single document, one primary&rdquo;&rdquo;single document, one primary&rdquo;:application model --><FUNCTION>XtAppInitialize()</FUNCTION> as your application's main window. This model requires no special treatment to handle schemes or for window or session management.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Implementing the &ldquo;Single Document, Multiple Primaries&rdquo; Model</TITLE><PARAGRAPH>The simplest way to implement this model is to use the ApplicationShell returned by <INDEXTARGET ID="05.Window.Management15"><!-- POSTPROCESSDATA: 05.Window.Management15|application models:&rdquo;single document, multiple primary&rdquo;&rdquo;single document, multiple primary&rdquo;:application model --><FUNCTION>XtAppInitialize()</FUNCTION> as your application's main window. You can create co-primary windows as popup children of the main window using TopLevelShells. This approach requires no special treatment to handle schemes or for window or session management.</PARAGRAPH>
<PARAGRAPH>You can also choose the implement this model using the techniques described in &ldquo;Implementing the &ldquo;Multiple Document, No Visible Main&rdquo; Model,&rdquo; although this requires more work.</PARAGRAPH>
<CAUTION><PREFIX>Caution</PREFIX>Don't use <FUNCTION>XtAppCreateShell()</FUNCTION> to create co-primary windows. If you do, the windows don't pick up the resources specified in schemes.</CAUTION>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Implementing the &ldquo;Multiple Document, Visible Main&rdquo; Model</TITLE><PARAGRAPH>Once again, the simplest way to implement this model is to use the ApplicationShell returned by <INDEXTARGET ID="05.Window.Management16"><!-- POSTPROCESSDATA: 05.Window.Management16|application models:&rdquo;multiple document, visible main&rdquo;&rdquo;multiple document, visible main&rdquo;:application model --><FUNCTION>XtAppInitialize()</FUNCTION> as your application's main window. You can create co-primary windows as popup children of the main window using TopLevelShells. This approach requires no special treatment to handle schemes or for window or session management.</PARAGRAPH>
<PARAGRAPH>You can also choose the implement this model using the techniques described in &ldquo;Implementing the &ldquo;Multiple Document, No Visible Main&rdquo; Model,&rdquo; although this requires more work.</PARAGRAPH>
<CAUTION><PREFIX>Caution</PREFIX>Don't use <FUNCTION>XtAppCreateShell()</FUNCTION> to create co-primary windows. If you do, the windows don't pick up the resources specified in schemes.</CAUTION>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="64025">Implementing the &ldquo;Multiple Document, No Visible Main&rdquo; Model</TITLE><PARAGRAPH>This model requires more careful consideration than the other models. Presumably, the visible windows can be created and destroyed in any order; therefore it is very difficult to use one as a main window and have the others be children of it.<INDEXTARGET ID="05.Window.Management17"><!-- POSTPROCESSDATA: 05.Window.Management17|application models:&rdquo;multiple document, no visible main&rdquo;&rdquo;multiple document, no visible main&rdquo;:application model --></PARAGRAPH>
<PARAGRAPH>Instead, the best solution in this case is to leave the ApplicationShell returned by <FUNCTION>XtAppInitialize()</FUNCTION> unrealized. You can then create the visible co-primary windows as popup children of this invisible shell.</PARAGRAPH>
<PARAGRAPH>Session management requires a realized ApplicationShell widget so that your application can store restart information in its <BOLD>XmNargv</BOLD> and <BOLD>XmNargc</BOLD> resources. Because your application's visible windows can be created and destroyed dynamically, you should use ApplicationShells rather than TopLevelShells for your visible windows. Then you can set the <BOLD>XmNargv</BOLD> and <BOLD>XmNargc</BOLD> resources on any of them. (Another option would be to use TopLevelShells for the visible windows and then explicitly create and set WM_COMMAND and WM_MACHINE properties on the windows.)</PARAGRAPH>
<PARAGRAPH>One complication when using ApplicationShells is that by default, IRIS IM automatically quits an application when it destroys an ApplicationShell. To avoid this, you must set each window's <BOLD>XmNdeleteResponse</BOLD> resource to XmDO_NOTHING, and then explicitly handle the window manager's WM_DELETE_WINDOW protocol for each window. <XREF IDREF="15555" TYPE="TITLE">&ldquo;Handling the Window Manager Delete Window Protocol&rdquo;</XREF> describes how to implement these handlers.</PARAGRAPH>
<PARAGRAPH>Another complication is that the initial values of the <BOLD>XmNargv</BOLD> and <BOLD>XmNargc</BOLD> resources are stored in the application's invisible main window rather than a visible window. This is also true for the <BOLD>XmNgeometry</BOLD> resource if specified by the user. To avoid this, you should copy these values from the invisible main window to your application's first visible window.</PARAGRAPH>
<CAUTION><PREFIX>Caution</PREFIX>Don't use <FUNCTION>XtAppCreateShell()</FUNCTION> to create co-primary windows. If you do, the windows don't pick up the resources specified in schemes. </CAUTION>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="96868">Interacting With the Window and Session Manager</TITLE><PARAGRAPH>Most communication between an application and a window manager takes place through properties on an application's top-level windows. The window manager can also generate events that are available to the application. You can use Xlib functions to set properties and handle window manager events.<INDEXTARGET ID="05.Window.Management18"><!-- POSTPROCESSDATA: 05.Window.Management18|communication:window and session managersession manager:and window managerwindow manager:and session managerwindow management:communication with session managersession management:communication with window manager --></PARAGRAPH>
<PARAGRAPH>In IRIS IM, shell widgets simplify communications with the window manager. The application can set most window properties by setting shell resources. Shells also select for and handle most events from the window manager.</PARAGRAPH>
<PARAGRAPH>Because this guide assumes that you are programming in IRIS IM rather than Xlib, this chapter describes the IRIS IM mechanisms for creating windows and interacting with the window and session manager. Topics include: </PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="51311" TYPE="TITLE">&ldquo;Creating Windows and Setting Decorations&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="73941" TYPE="TITLE">&ldquo;Handling Window Manager Protocols&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="12004" TYPE="TITLE">&ldquo;Setting the Window Title&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="90776" TYPE="TITLE">&ldquo;Controlling Window Placement and Size&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>For detailed information about setting window properties using shell resources, consult Chapter 11, &ldquo;Interclient Communication,&rdquo; in O'Reilly's <DOCTITLE>X Toolkit Intrinsics Programming Manual </DOCTITLE>and Chapter 16, &ldquo;Interclient Communication,&rdquo; in the <DOCTITLE>OSF/Motif Programmer's Guide</DOCTITLE>. For detailed information about window properties and setting them using Xlib routines, consult Chapter 12, &ldquo;Interclient Communication,&rdquo; in O'Reilly's <DOCTITLE>Xlib Programming Manual</DOCTITLE>.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="51311">Creating Windows and Setting Decorations</TITLE><PARAGRAPH><EXTREF IDREF="71076" BOOK="UI_Glines" FILE="" HDG="71076" INFO="">Chapter&nbsp;6, &ldquo;Application Windows,&rdquo;</EXTREF>
 in the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE> describes several application models based on four different window categories: main primary windows, co-primary windows, support windows, and dialogs. This section describes how to implement these window categories with proper window decorations and window menu entries:<INDEXTARGET ID="05.Window.Management19"><!-- POSTPROCESSDATA: 05.Window.Management19|window categories:implementation --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="96168" TYPE="TITLE">&ldquo;Creating a Main Primary Window&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="44175" TYPE="TITLE">&ldquo;Creating a Co-Primary Window&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="40129" TYPE="TITLE">&ldquo;Creating a Support Window&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="37042" TYPE="TITLE">&ldquo;Creating a Dialog&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>To properly integrate with the IRIX Interactive Desktop, you need to use the appropriate shell widget for each widow category. This section describes which shell widget to use for each window category. Then you need to properly set the shell's <INDEXTARGET ID="05.Window.Management20"><!-- POSTPROCESSDATA: 05.Window.Management20|integration:desktopdesktop:integration of windowswindows:integration with desktop --><BOLD>XmNmwmFunctions</BOLD> resource to control which entries appear in the window menu and the <BOLD>XmNmwmDecorations</BOLD> resource to remove the window's resize handles, if appropriate.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="96168">Creating a Main Primary Window</TITLE><PARAGRAPH>Your application's main primary window must be an ApplicationShell. Typically, you use the ApplicationShell widget returned by <INDEXTARGET ID="05.Window.Management21"><!-- POSTPROCESSDATA: 05.Window.Management21|ApplicationShellwidgets:ApplicationShellwindows:mainwindows:primaryprimary windowsmain windows --><FUNCTION>XtAppInitialize()</FUNCTION> as your application's main primary window.</PARAGRAPH>
<PARAGRAPH>You should set the main primary window's <BOLD>XmNmwmFunctions</BOLD> resource to remove the &ldquo;Close&rdquo; option from the window menu. Also, if you don't want the user to be able to resize the window, you should set <BOLD>XmNmwmFunctions</BOLD> to remove the &ldquo;Size&rdquo; and &ldquo;Maximize&rdquo; options and set <BOLD>XmNmwmDecorations</BOLD> to remove the resize handles. <XREF IDREF="25385" TYPE="TEXT">Example&nbsp;5-2</XREF> shows how you can create a main primary window and set the resource values appropriately.</PARAGRAPH>
<PARAGRAPH><EXTREF IDREF="67665" BOOK="UI_Glines" FILE="" HDG="67665" INFO="">&ldquo;Main and Co-Primary Windows&rdquo; in Chapter&nbsp;6</EXTREF>
 of the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE> provides guidelines for using main primary windows.</PARAGRAPH>
<CODE><CAPTION LBL="5-2"><PREFIX>Example 5-2 </PREFIX><XREFTARGET ID="25385">Creating a Main Primary Window <INDEXTARGET ID="05.Window.Management22"><!-- POSTPROCESSDATA: 05.Window.Management22|main windows:exampleprimary windows:examplewindows:example, creating a main primary --></CAPTION>#include&nbsp;&lt;Xm/Xm.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Required&nbsp;by&nbsp;all&nbsp;Motif&nbsp;applications&nbsp;*/
#include&nbsp;&lt;Xm/MwmUtil.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Required to set window menu and decorations */
#include&nbsp;&lt;X11/Shell.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Shell definitions */
&nbsp;
void&nbsp;main&nbsp;(&nbsp;int&nbsp;argc,&nbsp;char&nbsp;**argv&nbsp;)
{
&nbsp;&nbsp;&nbsp;&nbsp;Widget&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mainWindow;&nbsp;/*&nbsp;Main window shell widget&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;XtAppContext&nbsp;app;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;An&nbsp;application&nbsp;context,&nbsp;needed&nbsp;by&nbsp;Xt&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;Arg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args[10];&nbsp;&nbsp;&nbsp;/* Argument list */
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Argument count */
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Initialize resource value flags to include all window menu options and
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* all decorations.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;functions&nbsp;=&nbsp;MWM_FUNC_ALL;
&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;handleMask&nbsp;=&nbsp;MWM_DECOR_ALL;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;n = 0;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;The&nbsp;following&nbsp;lines&nbsp;REMOVE&nbsp;items&nbsp;from&nbsp;the&nbsp;window&nbsp;manager&nbsp;menu.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;functions&nbsp;&nbsp;|=&nbsp;MWM_FUNC_CLOSE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Remove "Close" menu option&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/* Include the following two lines only if the window is *not* resizable */
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;functions&nbsp;&nbsp;|=&nbsp;MWM_FUNC_RESIZE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Remove "Size" menu option&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;functions&nbsp;&nbsp;|=&nbsp;MWM_FUNC_MAXIMIZE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Remove "Maximize" menu option&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;XtSetArg(args[n],&nbsp;XmNmwmFunctions,&nbsp;functions); n++;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Include the following two lines only if the window is *not* resizable&nbsp;*/
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;handleMask&nbsp;|=&nbsp;MWM_DECOR_RESIZEH;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Remove resize handles&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;XtSetArg(args[n],&nbsp;XmNmwmDecorations,&nbsp;handleMask); n++
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;Initialize&nbsp;Xt and create shell
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;mainWindow&nbsp;=&nbsp;XtAppInitialize&nbsp;(&nbsp;&amp;app,&nbsp;"WindowTest",&nbsp;NULL,&nbsp;0,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;argc,&nbsp;argv,&nbsp;NULL,&nbsp;args,&nbsp;n&nbsp;);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/* ... */
&nbsp;
}
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="44175">Creating a Co-Primary Window</TITLE><PARAGRAPH>Your application's co-primary windows should be ApplicationShells or TopLevelShells. <INDEXTARGET ID="05.Window.Management23"><!-- POSTPROCESSDATA: 05.Window.Management23|windows:co-primaryco-primary windowspop-up windowswindows:pop-up --><XREF IDREF="14513" TYPE="TITLE">&ldquo;Implementing an Application Model&rdquo;</XREF> describes which to choose depending on your application model. The easiest way to implement these windows are as pop-up children of the shell widget returned by <FUNCTION>XtAppInitialize()</FUNCTION> (which is typically your application's main primary window). </PARAGRAPH>
<PARAGRAPH>If the user can't quit the application from a co-primary window, you should set the window's <BOLD>XmNmwmFunctions</BOLD> resource to remove the &ldquo;Exit&rdquo; option from the window menu. Also, if you don't want the user to be able to resize the window, you should set <BOLD>XmNmwmFunctions</BOLD> to remove the &ldquo;Size&rdquo; and &ldquo;Maximize&rdquo; options and set <BOLD>XmNmwmDecorations</BOLD> to remove the resize handles. <XREF IDREF="44281" TYPE="TEXT">Example&nbsp;5-3</XREF> shows how you can create a co-primary window and set the resource values appropriately.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>The default action when IRIS IM destroys an ApplicationShell is to quit your application. To avoid this if you are using ApplicationShells for your co-primary windows, you must set each window's <BOLD>XmNdeleteResponse</BOLD> resource to XmDO_NOTHING, and then explicitly handle the window manager's WM_DELETE_WINDOW protocol for each window. You might want to follow this approach even if you use TopLevelShells for co-primary windows so that you can simply popdown the window instead of deleting it. This can save time if you might redisplay the window later. <XREF IDREF="15555" TYPE="TITLE">&ldquo;Handling the Window Manager Delete Window Protocol&rdquo;</XREF> describes how to implement these handlers.</NOTE>
<PARAGRAPH><EXTREF IDREF="67665" BOOK="UI_Glines" FILE="" HDG="67665" INFO="">&ldquo;Main and Co-Primary Windows&rdquo; in Chapter&nbsp;6</EXTREF>
 of the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE> provides guidelines for using co-primary windows.</PARAGRAPH>
<CODE><CAPTION LBL="5-3"><PREFIX>Example 5-3 </PREFIX><XREFTARGET ID="44281">Creating a Co-Primary Window <INDEXTARGET ID="05.Window.Management24"><!-- POSTPROCESSDATA: 05.Window.Management24|co-primary windows:examplewindows:example, creating a co-primary --></CAPTION>#include&nbsp;&lt;Xm/Xm.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Required&nbsp;by&nbsp;all&nbsp;Motif&nbsp;applications&nbsp;*/
#include&nbsp;&lt;Xm/MwmUtil.h>&nbsp;&nbsp;/* Required to set window menu and decorations */
#include&nbsp;&lt;X11/Shell.h>&nbsp;&nbsp;&nbsp;/* Shell definitions */
&nbsp;
Widget&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mainWindow;&nbsp;/*&nbsp;Main window shell widget&nbsp;*/
Widget&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coPrimary;&nbsp;&nbsp;/*&nbsp;Co-primary window shell widget&nbsp;*/
Arg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args[10];&nbsp;&nbsp;&nbsp;/* Argument list */
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Argument count */
&nbsp;
/*
&nbsp;* Initialize resource value flags to include all window menu options and
&nbsp;* all decorations.
&nbsp;*/
&nbsp;
long&nbsp;functions&nbsp;=&nbsp;MWM_FUNC_ALL;
long&nbsp;handleMask&nbsp;=&nbsp;MWM_DECOR_ALL;
&nbsp;
/* ... */

n = 0;
&nbsp;
/*
&nbsp;*&nbsp;The&nbsp;following&nbsp;lines&nbsp;REMOVE&nbsp;items&nbsp;from&nbsp;the&nbsp;&nbsp;window&nbsp;manager&nbsp;menu.
&nbsp;*/
&nbsp;
/* Remove the "Exit" window menu option if users can *not* quit from this window */
&nbsp;
functions&nbsp;&nbsp;|=&nbsp;MWM_FUNC_QUIT;
&nbsp;
/* Include the following two lines only if the window is *not* resizable */
&nbsp;
functions&nbsp;&nbsp;|=&nbsp;MWM_FUNC_RESIZE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Remove "Size" menu option&nbsp;*/
functions&nbsp;&nbsp;|=&nbsp;MWM_FUNC_MAXIMIZE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Remove "Maximize" menu option&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;
XtSetArg(args,&nbsp;XmNmwmFunctions,&nbsp;functions); n++;
&nbsp;
/*&nbsp;Include the following two lines only if the window is *not* resizable&nbsp;*/
&nbsp;
handleMask&nbsp;|=&nbsp;MWM_DECOR_RESIZEH;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Remove resize handles&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;
XtSetArg(args,&nbsp;XmNmwmDecorations,&nbsp;handleMask); n++;
&nbsp;
/*&nbsp;You need the following line only if you use an ApplicationShell for the window&nbsp;*/
&nbsp;
XtSetArg(args,&nbsp;XmNdeleteResponse,&nbsp;XmDO_NOTHING); n++;
&nbsp;
/* 
&nbsp;*&nbsp;Assume that the application has already created a main window and assigned its widget
&nbsp;*&nbsp;to the variable mainWindow
&nbsp;*/
&nbsp;
coPrimary = XtCreatePopupShell(&nbsp;"coPrimary",&nbsp;applicationShellWidgetClass,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mainWindow,&nbsp;args, n );
&nbsp;
/* ... */
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="40129">Creating a Support Window</TITLE><PARAGRAPH>Support windows are essentially custom dialogs. The easiest way to create a support window is to use <INDEXTARGET ID="05.Window.Management25"><!-- POSTPROCESSDATA: 05.Window.Management25|support windowswindows:supportwindows:dialogsdialogs:creating --><FUNCTION>XmCreateBulletinBoardDialog()</FUNCTION> to create a DialogShell containing a BulletinBoard widget, or use <FUNCTION>XmCreateFormDialog()</FUNCTION> to create a DialogShell containing a Form widget. You can then add appropriate controls and displays as children of the BulletinBoard or Form.</PARAGRAPH>
<PARAGRAPH>Another advantage to using a DialogShell for support windows is that they automatically have the proper window menu options and decorations. If you don't want the user to be able to resize the window&mdash;and you implemented the support window as a customized dialog&mdash;you should set <BOLD>XmNnoResize</BOLD> to &ldquo;TRUE&rdquo; to remove the &ldquo;Size&rdquo; and &ldquo;Maximize&rdquo; options and to remove the resize handles. <XREF IDREF="49142" TYPE="TEXT">Example&nbsp;5-4</XREF> shows how you can create a support window and set the resource values appropriately.</PARAGRAPH>
<PARAGRAPH><EXTREF IDREF="30905" BOOK="UI_Glines" FILE="" HDG="30905" INFO="">&ldquo;Support Windows&rdquo; in Chapter&nbsp;6</EXTREF>
 of the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE> provides guidelines for using support windows.</PARAGRAPH>
<CODE><CAPTION LBL="5-4"><PREFIX>Example 5-4 </PREFIX><XREFTARGET ID="49142">Creating a Support Window <INDEXTARGET ID="05.Window.Management26"><!-- POSTPROCESSDATA: 05.Window.Management26|support windows:examplewindows:example, creating a support --></CAPTION>#include&nbsp;&lt;Xm/Xm.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Required&nbsp;by&nbsp;all&nbsp;Motif&nbsp;applications&nbsp;*/
#include&nbsp;&lt;Xm/MwmUtil.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Required to set window menu and decorations */
#include&nbsp;&lt;X11/Form.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Form definitions */
&nbsp;
Widget&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parentWindow;&nbsp;&nbsp;/* Parent window of support window */
Widget&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;supportWindow;&nbsp;/*&nbsp;Support window&nbsp;*/
Arg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args[10];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Argument list */
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Argument count */
&nbsp;
/* ... */
&nbsp;
n = 0;
&nbsp;
/*&nbsp;Include the following line only if the window is *not* resizable&nbsp;*/
&nbsp;
XtSetArg(args, XmNnoResize, TRUE); n++
&nbsp;
supportWindow = XmCreateFormDialog( parentWindow, "supportWindow",&nbsp;args, n );
&nbsp;
/* Create the window interface...&nbsp;*/
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="37042">Creating a Dialog</TITLE><PARAGRAPH>The easiest way to create dialogs is to use the IRIS IM convenience functions such as <INDEXTARGET ID="05.Window.Management27"><!-- POSTPROCESSDATA: 05.Window.Management27|dialogs:windowswindows:dialogsnotification dialogsdialogs:notificationdialogs:creating --><FUNCTION>XmCreateMessageDialog()</FUNCTION> and <FUNCTION>XmCreatePromptDialog()</FUNCTION>. These functions automatically set most of the window characteristics required for the IRIX Interactive Desktop environment.</PARAGRAPH>
<PARAGRAPH>Dialogs automatically have the proper window menu options and decorations. If you don't want the user to be able to resize the dialog, you should set <BOLD>XmNnoResize</BOLD> to &ldquo;TRUE&rdquo; to remove the &ldquo;Size&rdquo; and &ldquo;Maximize&rdquo; options and to remove the resize handles. <XREF IDREF="90677" TYPE="TEXT">Example&nbsp;5-5</XREF> shows an example of creating a WarningDialog and setting the resource values appropriately.</PARAGRAPH>
<PARAGRAPH><EXTREF IDREF="30192" BOOK="UI_Glines" FILE="" HDG="30192" INFO="">Chapter&nbsp;10, &ldquo;Dialogs,&rdquo;</EXTREF>
 in the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE> provides guidelines for using dialogs.</PARAGRAPH>
<CODE><CAPTION LBL="5-5"><PREFIX>Example 5-5 </PREFIX><XREFTARGET ID="90677">Creating a Dialog <INDEXTARGET ID="05.Window.Management28"><!-- POSTPROCESSDATA: 05.Window.Management28|dialogs:examplewindows:example, creating a dialog --></CAPTION>#include&nbsp;&lt;Xm/Xm.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Required&nbsp;by&nbsp;all&nbsp;Motif&nbsp;applications&nbsp;*/
#include&nbsp;&lt;Xm/MwmUtil.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Required to set window menu and decorations */
#include&nbsp;&lt;Xm/MessageB.h>&nbsp;&nbsp;&nbsp;&nbsp;/* Warning dialog definitions */
&nbsp;
Widget&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parentWindow;&nbsp;&nbsp;/* Parent window of dialog */
Widget&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dialog;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Dialog&nbsp;*/
Arg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;args[10];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Argument list */
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Argument count */
&nbsp;
/* ... */
&nbsp;
n = 0;
&nbsp;
/*&nbsp;Include the following line only if the window is *not* resizable&nbsp;*/
&nbsp;
XtSetArg(args, XmNnoResize, TRUE); n++
&nbsp;
dialog&nbsp;=&nbsp;XmCreateWarningDialog&nbsp;( parentWindow, "warningDialog", args, n );
</CODE>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="73941">Handling Window Manager Protocols</TITLE><PARAGRAPH>This section describes how to handle window manager <INDEXTARGET ID="05.Window.Management29"><!-- POSTPROCESSDATA: 05.Window.Management29|window manager:protocolsprotocols:window manager --><ITALICS>protocols</ITALICS>:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="81479" TYPE="TITLE">&ldquo;Handling the Window Manager Quit Protocol&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="15555" TYPE="TITLE">&ldquo;Handling the Window Manager Delete Window Protocol&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="70788" TYPE="TITLE">&ldquo;Handling the Window Manager Save Yourself Protocol&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>&space;Protocols allow the window manager to send messages to your application. The window manager sends these messages only if your application registers callback function to handle the corresponding protocols.<INDEXTARGET ID="05.Window.Management30"><!-- POSTPROCESSDATA: 05.Window.Management30|window manager:sending messageswindows:protocolwindows:sending messages --></PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="81479">Handling the Window Manager Quit Protocol</TITLE><PARAGRAPH>When a user selects the &ldquo;Exit&rdquo; option from a window menu, the window manager sends a Quit message to your application. You should install a callback routine to handle this event. <INDEXTARGET ID="05.Window.Management31"><!-- POSTPROCESSDATA: 05.Window.Management31|protocols:quitquit:window&rdquo;Exit&rdquo; optionmenus:&rdquo;Exit&rdquo; option --><XREF IDREF="80772" TYPE="TEXT">Example&nbsp;5-6</XREF> demonstrates installing such a callback for the window specified by <VARIABLE>mainWindow</VARIABLE>.</PARAGRAPH>
<CODE><CAPTION LBL="5-6"><PREFIX>Example 5-6 </PREFIX><XREFTARGET ID="80772">Handling the Window Manager Quit Protocol <INDEXTARGET ID="05.Window.Management32"><!-- POSTPROCESSDATA: 05.Window.Management32|protocols:quit, examplequit:window&rdquo;Exit&rdquo; optionmenus:&rdquo;Exit&rdquo; optionwindows:example, quit protocol --></CAPTION>Atom WM_QUIT_APP = XmInternAtom( XtDisplay(mainWindow),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_WM_QUIT_APP", 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FALSE );
XmAddWMProtocolCallback( mainWindow, WM_QUIT_APP,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quitCallback,&nbsp;NULL );
&nbsp;
/* ... */
&nbsp;
quitCallback( Widget w, XtPointer clientData,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmAnyCallbackStruct cbs )
{
&nbsp;&nbsp;&nbsp;&nbsp;/* Quit application */
}
</CODE>
<NOTE><PREFIX>Note</PREFIX>You must install the quit callback for each window that contains an &ldquo;Exit&rdquo; option in its window menu. Often the only such window is your application's main primary window.</NOTE>
<PARAGRAPH>The operations performed by the callback function should be the same as those that occur when the user quits from within your application (for example, by selecting an &ldquo;Exit&rdquo; option from a File menu). Your application can prompt the user to save any files that are open, to perform any other cleanup, or even to abort the quit.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="15555">Handling the Window Manager Delete Window Protocol</TITLE><PARAGRAPH>When a user selects the &ldquo;Close&rdquo; option from a window menu, the window manager sends a Delete Window message to your application. How to handle this message depends on whether the window is a co-primary window, a dialog, or support window. (A main primary window should not have a &ldquo;Close&rdquo; option on its window menu.)<INDEXTARGET ID="05.Window.Management33"><!-- POSTPROCESSDATA: 05.Window.Management33|protocols:deletedelete:window&rdquo;Delete&rdquo; optionmenus:&rdquo;Delete&rdquo; optionprotocols:closeclose:window&rdquo;Close&rdquo; optionmenus:&rdquo;Close&rdquo; option --></PARAGRAPH>
<PARAGRAPH>To handle the Delete Window message with a co-primary window, you should make sure to set the window's <BOLD>XmNdeleteResponse</BOLD> resource to XmDO_NOTHING. Otherwise, IRIS automatically deletes the window and, if the window uses an ApplicationShell, quits the application.</PARAGRAPH>
<PARAGRAPH>The callback you install can ask for user confirmation and can decide to comply or not comply with the request. If it decides to comply, your application can either pop down or destroy the window. If you think that the user might want to redisplay the window later, popping down the window is usually the better choice because your application doesn't have to re-create it later. <XREF IDREF="67206" TYPE="TEXT">Example&nbsp;5-7</XREF> shows an example of installing a callback to handle the Delete Window message.</PARAGRAPH>
<CODE><CAPTION LBL="5-7"><PREFIX>Example 5-7 </PREFIX><XREFTARGET ID="67206">Handling the Window Manager Delete Window Protocol in Co-Primary Windows <INDEXTARGET ID="05.Window.Management34"><!-- POSTPROCESSDATA: 05.Window.Management34|protocols:delete, exampledelete:window&rdquo;Delete&rdquo; optionmenus:&rdquo;Delete&rdquo; optionco-primary windows:delete protocol --></CAPTION>Atom WM_DELETE_WINDOW = XmInternAtom( XtDisplay(window),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"WM_DELETE_WINDOW",&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FALSE);
XmAddWMProtocolCallback( window, WM_DELETE_WINDOW,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;closeCallback,&nbsp;NULL );
&nbsp;
/* ... */

closeCallback( Widget w, XtPointer clientData,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmAnyCallbackStruct cbs )
{
&nbsp;&nbsp;&nbsp;&nbsp;/* Delete or pop down window */
}
</CODE>
<PARAGRAPH>For support windows and dialogs, you typically want to dismiss the window when the user selects &ldquo;Close.&rdquo; Therefore, the default value of <BOLD>XmNdeleteResponse</BOLD>, XmDESTROY, is appropriate. Additionally, you should perform whatever other actions are appropriate for when that support window or dialog is dismissed. Typically, you can accomplish this by invoking the callback associated with the <BUTTON>Cancel</BUTTON> button, if it exists. <XREF IDREF="45992" TYPE="TEXT">Example&nbsp;5-8</XREF> shows an example of this.</PARAGRAPH>
<CODE><CAPTION LBL="5-8"><PREFIX>Example 5-8 </PREFIX><XREFTARGET ID="45992">Handling the Window Manager Delete Window Protocol in Support Windows and Dialogs <INDEXTARGET ID="05.Window.Management35"><!-- POSTPROCESSDATA: 05.Window.Management35|dialogs:delete exampledialogs:&rdquo;Delete&rdquo; optionsupport windows:&rdquo;Delete&rdquo; optionwindows:example, delete protocol --></CAPTION>Atom WM_DELETE_WINDOW = XmInternAtom( XtDisplay(dialog),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"WM_DELETE_WINDOW",&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FALSE);
XmAddWMProtocolCallback( dialog, WM_DELETE_WINDOW,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cancelCallback,&nbsp;NULL );
&nbsp;
/* ... */
&nbsp;
cancelCallback( Widget w, XtPointer clientData,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmAnyCallbackStruct cbs )
{
&nbsp;&nbsp;&nbsp;&nbsp;/* Perform cancel operations */
}
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="70788">Handling the Window Manager Save Yourself Protocol</TITLE><PARAGRAPH>The &ldquo;Save Yourself&rdquo; protocol is part of the session management mechanism. The session manager sends a Save Yourself message to allow your application to update the command needed to restart itself in its current state. Currently, the session manager sends Save Yourself messages before ending a session (that is, logging out) and periodically while a session is active.<INDEXTARGET ID="05.Window.Management36"><!-- POSTPROCESSDATA: 05.Window.Management36|windows:save yourself protocolwindows:session managementsession management:saving state informationsession management:continuousrestarting applicationssaving state informationprotocols:saving state information --></PARAGRAPH>
<PARAGRAPH>Your application doesn't need to subscribe to the Save Yourself protocol. Instead, your application can simply update the <BOLD>XmNargv</BOLD> and <BOLD>XmNargc</BOLD> resources on one of its ApplicationShells whenever it changes state, for example, when it opens or closes a file. The session manager re-saves its state information whenever your application changes these resources. (Actually, the session manager monitors the WM_COMMAND and WM_MACHINE properties, which are set by the ApplicationShell whenever you change its <BOLD>XmNargv</BOLD> and <BOLD>XmNargc</BOLD> resources.)</PARAGRAPH>
<PARAGRAPH>If you decide to use Save Yourself for session management, you can handle the protocol on any realized ApplicationShell. Don't use Save Yourself with the unrealized main window of the &ldquo;Multiple Document, No Visible Main&rdquo; application model. When the window manager sends a Save Yourself message to your application, your application must update the value of the <BOLD>XmNargv</BOLD> and <BOLD>XmNargc</BOLD> resources to specify the command needed to restart the application in its current state. Once you've updated the <BOLD>XmNargv</BOLD> and <BOLD>XmNargc</BOLD> resources, the session manager assumes that it can safely kill your application. <XREF IDREF="20969" TYPE="TEXT">Example&nbsp;5-9</XREF> shows how to handle Save Yourself messages.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>Your application shouldn't prompt the user for input when it receives a Save Yourself message. </NOTE>
<CODE><CAPTION LBL="5-9"><PREFIX>Example 5-9 </PREFIX><XREFTARGET ID="20969">Handling the Window Manager &ldquo;Save Yourself&rdquo; Protocol <INDEXTARGET ID="05.Window.Management37"><!-- POSTPROCESSDATA: 05.Window.Management37|windows:save yourself exampleapplications:save yourself examplewindows:example, save yourself protocol --></CAPTION>/* saveyourself.c                                       */
/*                                                     */
/* Example code for handling the window manager's        */
/* WM_SAVE_YOURSELF Protocol                            */
/*                                                     */
/* cc -o saveyourself saveyourself.c -lXm -lXt          */
&nbsp;
#include &lt;Xm/Protocols.h>
#include &lt;Xm/Label.h>
&nbsp;
void saveYourSelfCallback(Widget w,  XtPointer client_data, 
&space;                            XtPointer call_data)
{
&space;   printf(&ldquo;Update WM_COMMAND or state file\n&rdquo;);
}
&nbsp;
void main(int argc, char** argv)
{
&space;  Widget toplevel, label;
&space;  XtAppContext app_context;
&space;  Atom WM_SAVE_YOURSELF;
&nbsp;
&space;  toplevel = XtAppInitialize(&amp;app_context, &ldquo;SaveYourSelf&rdquo;,
&space;                             NULL, 0, &amp;argc, argv, NULL, NULL, 0);
&nbsp;
&space;  label = XmCreateLabel(toplevel, &ldquo;saveme&rdquo;, NULL, 0);
&space;  XtManageChild(label);
&nbsp;
&space;  WM_SAVE_YOURSELF = XmInternAtom( XtDisplay(toplevel),
&space;                                     &ldquo;WM_SAVE_YOURSELF&rdquo;,
&space;                                     FALSE);
&nbsp;
&space;  XmAddWMProtocolCallback( toplevel, WM_SAVE_YOURSELF,
&space;                           saveYourSelfCallback, NULL );
&nbsp;
&space;  XtRealizeWidget(toplevel);
&space;  XtAppMainLoop(app_context);
}
</CODE>
<PARAGRAPH>Your application might not be able to fully specify its state using command line options. In that case, you can design your application to create a state file to save its state and to read the state file when it restarts. </PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="12004">Setting the Window Title</TITLE><PARAGRAPH>To set the title of a main primary window or co-primary window in your application, set the window's <INDEXTARGET ID="05.Window.Management38"><!-- POSTPROCESSDATA: 05.Window.Management38|windows:titlewindows:bannerbanners:in window titletitles:of windows --><BOLD>title</BOLD> resource. If the title you specify uses a non-default encoding, remember to also set the value of the <BOLD>titleEncoding</BOLD> resource appropriately. For support windows and dialogs, set the value of the <BOLD>XmNdialogTitle</BOLD> resource.</PARAGRAPH>
<PARAGRAPH>Choose the title according to the guidelines in the section <EXTREF IDREF="56252" BOOK="UI_Glines" FILE="" HDG="56252" INFO="">&ldquo;Window Title Bar&rdquo; in Chapter&nbsp;3</EXTREF>
 of the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE>. Update the label so that it always reflects the current information. For example, if the label reflects the name of the file the user is working on, you should update the label when the user opens a different file.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="90776">Controlling Window Placement and Size</TITLE><PARAGRAPH>Users have the option of specifying window placement and size, either through the <INDEXTARGET ID="05.Window.Management39"><!-- POSTPROCESSDATA: 05.Window.Management39|windows:placementwindowssizeapplications:window placementapplications:window size --><INDEXTARGET ID="05.Window.Management40"><!-- POSTPROCESSDATA: 05.Window.Management40|size:of windowsplacement:of windowsresize:windows<ITALICS>-geometry</ITALICS> option --><CMDLINEOPT>-geometry</CMDLINEOPT> option interactively using the mouse, or having applications automatically place their windows on the screen. To support automatic window placement, your application should provide default placement information for its main primary and co-primary windows. (Support windows and dialogs appear centered over their parent widget if the value of their <BOLD>XmNdefaultPosition</BOLD> resources are TRUE, which is the default.) You can also specify a default window size, minimum and maximum window sizes, minimum and maximum aspect ratios, and resizing increments for your windows. Typically, you should set these resources in your application's <FILENAME>app-default</FILENAME> file.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Controlling Window Placement</TITLE><PARAGRAPH>You should provide initial values for the window shell's <BOLD>x</BOLD> and <BOLD>y</BOLD> resources before mapping the window to specify its default location. The window manager ignores these values if the user requests interactive window placement or specifies a location using the <CMDLINEOPT>-geometry</CMDLINEOPT> option when invoking your application. You should not use the window's <BOLD>XmNgeometry</BOLD> resource to control initial window placement, either in your application's source code or its <FILENAME>app-default</FILENAME> file.</PARAGRAPH>
<PARAGRAPH><EXTREF IDREF="11715" BOOK="UI_Glines" FILE="" HDG="11715" INFO="">&ldquo;Window Placement&rdquo; in Chapter&nbsp;3</EXTREF>
 of the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE> provides guidelines for controlling window placement.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Controlling Window Size</TITLE><PARAGRAPH>If the user doesn't specify a window size and you don't explicitly set the window size in your application, the initial size of the window is determined by geometry management negotiations of the shell widget's descendents. Typically, the resulting size is just large enough for all of the descendent widget to fit &ldquo;comfortably.&rdquo; Optionally, you can specify a default initial size for a window by providing initial values for the window's <BOLD>width</BOLD> and <BOLD>height</BOLD> resources before mapping the window. You should not use the window's <BOLD>XmNgeometry</BOLD> resource to control initial window size, either in your application's source code or its <FILENAME>app-default</FILENAME> file.</PARAGRAPH>
<PARAGRAPH>You can also set several shell resources to specify minimum and maximum window sizes, minimum and maximum aspect ratios, and resizing increments for a window:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><BOLD>minHeight</BOLD> and <BOLD>minWidth</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The desired minimum height and width for the window.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>maxHeight</BOLD> and <BOLD>maxWidth</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The desired maximum height and width for the window.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>minAspectX</BOLD> and <BOLD>minAspectY</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The desired minimum aspect ratio (X/Y) for the window.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>maxAspectX</BOLD> and <BOLD>maxAspectY</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The desired maximum aspect ratio (X/Y) for the window.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>baseHeight</BOLD> and <BOLD>baseWidth</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The base for a progression of preferred heights and widths for the window. The preferred heights are <BOLD>baseHeight</BOLD> plus integral multiples of <BOLD>heightInc</BOLD>, and the preferred widths are <BOLD>baseWidth</BOLD> plus integral multiples of <BOLD>widthInc</BOLD>. The window can't be resized smaller or larger than the values of the <BOLD>min*</BOLD> and <BOLD>max*</BOLD> resources.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>heightInc</BOLD> and <BOLD>widthInc</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The desired increments for resizing the window. </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH><EXTREF IDREF="32339" BOOK="UI_Glines" FILE="" HDG="32339" INFO="window categories<$endrange\>">&ldquo;Window Size&rdquo; in Chapter&nbsp;3</EXTREF>
 of the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE>&space;provides guidelines for controlling window size.</PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
</CHAPTER>
