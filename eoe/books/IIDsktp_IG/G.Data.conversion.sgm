<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<APPENDIX LBL="G"><TITLE><XREFTARGET ID="41465">Using GoldenGate Data Conversion Services</TITLE><PARAGRAPH>This appendix describes how to use the GoldenGate data conversion services. It covers these topics: <INDEXTARGET ID="G.Data.conversion1"><!-- POSTPROCESSDATA: G.Data.conversion1|data exchangeinterapplication data exchangedata:exchangeexchanging dataapplications:exchanging dataapplications:data exchange --><INDEXTARGET ID="G.Data.conversion2"><!-- POSTPROCESSDATA: G.Data.conversion2|transferring data --><INDEXTARGET ID="G.Data.conversion3"><!-- POSTPROCESSDATA: G.Data.conversion3|GoldenGate:data conversiondata conversion:GoldenGateconverting data:GoldenGateformats:converting datainterapplication data exchange:GoldenGate conversion --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="97872" TYPE="TITLE">&ldquo;Converting Data Using the GoldenGate Data Conversion Service&rdquo;</XREF> explains how to use the converters provided.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="66520" TYPE="TITLE">&ldquo;Compiling and Linking Your Program with GoldenGate&rdquo;</XREF> describes the header file to use when compiling and linking a program. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="61988" TYPE="TITLE">&ldquo;Writing Converters for the GoldenGate Data Conversion Service&rdquo;</XREF> explains how to customize your own converters. <INDEXTARGET ID="G.Data.conversion4"><!-- POSTPROCESSDATA: G.Data.conversion4|GoldenGate --></PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="85961"><XREFTARGET ID="97872">Converting Data Using the GoldenGate Data Conversion Service</TITLE><PARAGRAPH>This section describes how you can use the GoldenGate data conversion service in your application. Specifically, it explains:<INDEXTARGET ID="G.Data.conversion5"><!-- POSTPROCESSDATA: G.Data.conversion5|interapplication data exchange:<ITALICS>See also</ITALICS> data exchange --><INDEXTARGET ID="G.Data.conversion6"><!-- POSTPROCESSDATA: G.Data.conversion6|GoldenGate:<ITALICS>See also</ITALICS> data exchange --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="15075" TYPE="TITLE">&ldquo;Overview of the Conversion Process&rdquo;</XREF> describes the steps involved in converting data using GoldenGate.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="27143" TYPE="TITLE">&ldquo;Selecting a Converter&rdquo;</XREF> describes how to select a converter by querying the converter registry and setting up the conversion context.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="31875" TYPE="TITLE">&ldquo;Using GoldenGate to Convert Data&rdquo;</XREF> describes how to initialize the conversion pipeline, send data through it, and clean up after the conversion.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="15075">Overview of the Conversion Process</TITLE><PARAGRAPH>To convert data using GoldenGate, follow these steps:<INDEXTARGET ID="G.Data.conversion7"><!-- POSTPROCESSDATA: G.Data.conversion7|data exchange:conversion overviewGoldenGate:conversion overview --><INDEXTARGET ID="G.Data.conversion8"><!-- POSTPROCESSDATA: G.Data.conversion8|exchanging data:<ITALICS>See also</ITALICS> data exchange --></PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Choose a converter.</PARAGRAPH>
<BULLETLISTIND><BULLETSQUAREIND><PARAGRAPH>Obtain a list of converters that read the source format and write the target format.</PARAGRAPH>
</BULLETSQUAREIND>
<BULLETSQUAREIND><PARAGRAPH>Create a conversion context structure and set conversion parameters.</PARAGRAPH>
</BULLETSQUAREIND>
<BULLETSQUAREIND><PARAGRAPH>Evaluate the list of converters to determine which one is best suited for the current conversion.</PARAGRAPH>
</BULLETSQUAREIND>
</BULLETLISTIND>
</LIST>
<LIST><PARAGRAPH>Convert data.</PARAGRAPH>
<PARAGRAPH>There are two methods of converting data, depending on whether the data is in a stream or in a file.</PARAGRAPH>
<PARAGRAPH>Converting Stream Data</PARAGRAPH>
<BULLETLISTIND><BULLETSQUAREIND><PARAGRAPH>Initialize the selected converter.</PARAGRAPH>
</BULLETSQUAREIND>
<BULLETSQUAREIND><PARAGRAPH>Send data through the converter and read results back.</PARAGRAPH>
</BULLETSQUAREIND>
<BULLETSQUAREIND><PARAGRAPH>Clean up resources by destroying the conversion context.</PARAGRAPH>
</BULLETSQUAREIND>
</BULLETLISTIND>
<PARAGRAPH>Converting Data Files</PARAGRAPH>
<BULLETLISTIND><BULLETSQUAREIND><PARAGRAPH>Call the file conversion function.</PARAGRAPH>
</BULLETSQUAREIND>
<BULLETSQUAREIND><PARAGRAPH>Clean up resources by destroying the conversion context.</PARAGRAPH>
</BULLETSQUAREIND>
</BULLETLISTIND>
</LIST>
</ORDEREDLIST>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="29775">The Converter Registry</TITLE><PARAGRAPH>GoldenGate maintains a list of available converters in the <INDEXTARGET ID="G.Data.conversion9"><!-- POSTPROCESSDATA: G.Data.conversion9|GoldenGate:converter registryconverter registry:GoldenGatedata exchange:converter registry --><ITALICS>converter registry</ITALICS>. This registry contains an entry for each converter, specifying characteristics such as the type of input data it takes and the type of output data it produces. To find out if there are any converters that will convert from format &ldquo;A&rdquo; to format &ldquo;B,&rdquo; you can query the registry.</PARAGRAPH>
<PARAGRAPH>GoldenGate returns a list of converters that take the specified input and produce the specified output. You can be as specific as you like when querying the registry, to ensure that only relevant converters are listed. You should also use the query to eliminate inappropriate categories of converter, such as those of type <FUNCTION>StreamToStream</FUNCTION> if you are converting a file. If the list contains more than one converter, you may need to evaluate the converters to see which one best meets your needs. Even if the list contains only one converter, you should evaluate it to make sure it can handle your conversion request. </PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Creating a Conversion Context</TITLE><PARAGRAPH>To communicate with a converter, you must create a <INDEXTARGET ID="G.Data.conversion10"><!-- POSTPROCESSDATA: G.Data.conversion10|data exchange:conversion context --><ITALICS>conversion context</ITALICS>. The conversion context is a data object that stores conversion parameters. The conversion context is passed to subsequent library calls that set input and output parameters, evaluate converters, initialize the conversion pipeline, and move data through it.</PARAGRAPH>
<PARAGRAPH>Once you have created a conversion context and specified the desired conversion parameters, you can evaluate the list of converters you obtained when you queried the registry. For example, suppose you want to convert from one audio format to another and change the sample rate at the same time. Querying the registry returns a list of converters that will convert between the specified input and output formats. To determine if any of these converters will perform the desired sample rate conversion, you have to create a conversion context, set the desired parameters (including input and output sample rate) and then evaluate the individual converters.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Evaluating a Converter </TITLE><PARAGRAPH>It's best to evaluate a converter before you invoke it to perform a conversion. You do this for the following reasons:<INDEXTARGET ID="G.Data.conversion11"><!-- POSTPROCESSDATA: G.Data.conversion11|data exchange:converter evaluation --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Evaluation gives the converter an opportunity to inspect your data parameters. Some converters will have more functionality than others, even though their input and output types are the same. A well-designed converter will know just by looking at parameters whether it can do the conversion.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Conversion is typically an expensive operation. If your attempt to convert fails, you can still choose a different converter and try again, but you could have avoided lost time by trying a converter that can accept your specific request.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Depending on your needs, you can select the first converter on the list that passes the evaluation stage, or evaluate the whole list and use your own rules to choose between those that pass.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="86616">Converting Data In a File or Stream</TITLE><PARAGRAPH>Once you determine the converter to use, the final stage depends on whether you are converting data in a file or a stream. <INDEXTARGET ID="G.Data.conversion12"><!-- POSTPROCESSDATA: G.Data.conversion12|data exchange:converting data --></PARAGRAPH>
<PARAGRAPH>If you are converting a stream, initialize a conversion pipeline that reads your stream and passes back results as they are available. Then you send all your data through the pipeline and read the results until you see the end of stream marker for the pipeline. At this point, terminate the pipeline. This causes GoldenGate to clean up data structures it keeps for maintaining a stream conversion.</PARAGRAPH>
<PARAGRAPH>If you are converting a file, the procedure is simpler. You call a single GoldenGate function to perform the operation, and wait for results. If necessary you can provide a callback function that will notify you when results become available. This allows you to service other events going on in your application during what may be a long conversion.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="27143">Selecting a Converter </TITLE><PARAGRAPH>This section describes how to select a converter by querying the converter registry and setting up the conversion context. Specifically, this section covers:<INDEXTARGET ID="G.Data.conversion13"><!-- POSTPROCESSDATA: G.Data.conversion13|data exchange:converter selection --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="62783" TYPE="TITLE">&ldquo;Querying the Converter Registry&rdquo;</XREF>, which explains how to obtain a list of possible converters.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="60733" TYPE="TITLE">&ldquo;Setting Up the Conversion Context&rdquo;</XREF>, which describes how to create a conversion context.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="87840" TYPE="TITLE">&ldquo;Evaluating Converters&rdquo;</XREF>, which explains how to find a converter that performs the specified conversion.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="25846" TYPE="TITLE">&ldquo;Getting Converter Details&rdquo;</XREF>, which describes how to get a description of a converter.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="49475" TYPE="TITLE">&ldquo;Converter Return Status Values&rdquo;</XREF>, which lists return status values. </PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="62783">Querying the Converter Registry</TITLE><PARAGRAPH>To query the converter registry, you specify a set of constraints. Each constraint consists of an attribute (such as input format), a value for the attribute, and a comparison operator. For example, you can ask for a converter that has input format equal to &ldquo;AIFF_FILE,&rdquo; and version number greater than 2. Use the <INDEXTARGET ID="G.Data.conversion14"><!-- POSTPROCESSDATA: G.Data.conversion14|data exchange:querying converter registrydata exchange:converter registry query --><FUNCTION>SgCvtSetQueryConstraint()</FUNCTION> function to fill in an array of <FUNCTION>SgCvtQueryConstraint</FUNCTION> structures, then pass the array to the <FUNCTION>SgCvtQueryRegistry()</FUNCTION> function. The following code fragment demonstrates a simple query that locates converters capable of converting AIFF_FILE to WAVE_FILE:</PARAGRAPH>
<CODE>
SgCvtQueryConstraint constraints[2];
SgCvtStatus status;
SgCvtConverterId *converters;
int num_constraints, num_converters;
SgCvtRegistry registry = NULL;
status = SgCvtSetQueryConstraint(constraints[0],
&space;        SG_CVT_ATTR_INPUT_TYPE, "AIFF_FILE", SG_CVT_OP_EQ);
status = SgCvtSetQueryConstraint(constraints[1],
&space;        SG_CVT_ATTR_OUTPUT_TYPE, "WAVE_FILE", SG_CVT_OP_EQ);
num_constraints = 2;
status = SgCvtQueryRegistry(constraints, num_constraints,
&space;           &amp;registry, &amp;converters, &amp;num_converters);
</CODE>
<PARAGRAPH>The <FUNCTION>SgCvtQueryRegistry()</FUNCTION> function returns an array of <ITALICS>converter IDs</ITALICS> that can be used to identify the individual converters. </PARAGRAPH>
<PARAGRAPH>The <VARIABLE>registry</VARIABLE> argument specifies the GoldenGate converter registry to be queried. During this call, the registry is located on disk (<FILENAME>/var/GoldenGate/ConverterRegistry</FILENAME> by default), and its contents parsed to find a converter that matches your requirements. </PARAGRAPH>
<PARAGRAPH>The first time you call <FUNCTION>SgCvtQueryRegistry</FUNCTION>, specify registry as NULL as in the previous example, which causes this lookup. When you have finished converting, you can either call <FUNCTION>SgCvtFreeRegistry</FUNCTION> to release the resources that GoldenGate may have cached after reading the file, or you can re-use the value returned in registry for subsequent queries, avoiding the overhead of looking up the file. </PARAGRAPH>
<PARAGRAPH>If you choose to free the registry between queries, your program will always have the latest information, even if the registry changes while your program is running. If you choose to re-use the registry handle, you have no control over whether or not GoldenGate will re-parse the registry. It will try to use its cache first. If for any reason the cache is invalid, GoldenGate may at its discretion rebuild it by reading the disk-based registry again. </PARAGRAPH>
<PARAGRAPH>The converters argument returns an array of matching converter IDs, of which the first <VARIABLE>num_converters</VARIABLE> are valid and matched the query. You should free this array when you are finished using it, using <COMMAND>free</COMMAND>(3). </PARAGRAPH>
<PARAGRAPH><INDEXTARGET ID="G.Data.conversion15"><!-- POSTPROCESSDATA: G.Data.conversion15|data exchange:converter attributes --><XREF IDREF="61685" TYPE="TABLE">Table&nbsp;G-1</XREF> lists the attributes you can query.</PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="G-1"><PREFIX>Table G-1 </PREFIX><XREFTARGET ID="61685"> <EMPHASIS>(continued)        </EMPHASIS>Converter Attributes</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="166"><PARAGRAPH>Attribute Name</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>Description</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>SG_CVT_ATTR_NAME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>Converter name</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>SG_CVT_ATTR_INPUT_FORMAT</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>Input format</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>SG_CVT_ATTR_OUTPUT_FORMAT</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>Output format</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>SG_CVT_ATTR_IO_METHOD</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>StreamToStream or FileToFile</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>SG_CVT_ATTR_INPUT_LABEL</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>Input format, human readable version</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>SG_CVT_ATTR_OUTPUT_LABEL</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>Output format, human readable version</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>SG_CVT_ATTR_VENDOR</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>Vendor's name</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>SG_CVT_ATTR_VERSION</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>Vendor's version information</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>SG_CVT_ATTR_DESCRIPTION</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>Description of converter</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Most of the time, you'll be interested in the input format and output format attributes. <XREF IDREF="11667" TYPE="TITLE">&ldquo;Supported Target Formats&rdquo;</XREF> lists common data formats. Other attributes may be useful when listing converters for users. For example, if you want the user to choose between two converters that perform the same conversion, you can display the vendor names and version numbers. </PARAGRAPH>
<PARAGRAPH><INDEXTARGET ID="G.Data.conversion16"><!-- POSTPROCESSDATA: G.Data.conversion16|data exchange:operators --><XREF IDREF="36432" TYPE="TABLE">Table&nbsp;G-2</XREF> lists the operators you can use in your query. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="G-2"><PREFIX>Table G-2 </PREFIX><XREFTARGET ID="36432"> <EMPHASIS>(continued)        </EMPHASIS>Query Operators</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="166"><PARAGRAPH>Operator</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>Symbol</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>equal to</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>SG_CVT_OP_EQ</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>not equal to</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>SG_CVT_OP_NE</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>less than</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>SG_CVT_OP_LT</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>less than or equal to</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>SG_CVT_OP_LE</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>greater than</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>SG_CVT_OP_GT</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>greater than or equal to</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>SG_CVT_OP_GE</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Note that if more than one constraint is specified on a single attribute, a logical AND is implied. For example, you can select a range of version numbers by setting &ldquo;version greater than or equal to one&rdquo; as one constraint and &ldquo;version less than or equal to three&rdquo; as a second constraint.</PARAGRAPH>
<PARAGRAPH><FUNCTION>SgCvtQueryConstraint</FUNCTION> can return the following status value:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>SG_CVT_E_SUCCESS</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The operation succeeded. </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH><FUNCTION>SgCvtQueryRegistry</FUNCTION> can return the following status values:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>SG_CVT_E_SUCCESS</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The operation succeeded.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>SG_CVT_E_FAILURE</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Could not find the registry, or failed to parse it. Most likely when the default registry has been edited to add new converters, and a syntax error introduced. You may also be loading the wrong file. Make sure that if there is a file called ConverterRegistry on your path, it is a valid registry using the CDF syntax. Also make sure the CVT_REGISTRY_OVERRIDE variable is not set. </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="60733">Setting Up the Conversion Context</TITLE><PARAGRAPH>Before you can evaluate or use a converter, you must create a conversion context and set parameters governing the conversion. Use the <INDEXTARGET ID="G.Data.conversion17"><!-- POSTPROCESSDATA: G.Data.conversion17|data exchange:conversion context, setting up --><FUNCTION>SgCvtCreateConversionContext()</FUNCTION> function to create a conversion context:</PARAGRAPH>
<CODE>
SgCvtStatus
SgCvtCreateConversionContext(SgCvtConversionContext *context)
</CODE>
<PARAGRAPH><FUNCTION>SgCvtCreateConversionContext</FUNCTION> can return the following status values:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>SG_CVT_E_SUCCESS</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The operation succeeded.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>SG_CVT_E_NOMEM</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Insufficient memory to allocate a context. </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>Next, set any digital media parameters that affect your conversion by calling <FUNCTION>SgCvtSetContextInfo</FUNCTION>. </PARAGRAPH>
<CODE>
SgCvtStatus SgCvtSetContextInfo
&space;   (
&space;   SgCvtConversionContext    context,
&space;   unsigned long             valuemask,
&space;   SgCvtContextInfo          *context_data
&space;   );
</CODE>
<PARAGRAPH>where</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><VARIABLE>context</VARIABLE> </HANGITEM>
<HANGBODY><PARAGRAPH>specifies the context you created with <FUNCTION>SgCvtCreateConversionContext</FUNCTION>&space;</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>valuemask</VARIABLE> </HANGITEM>
<HANGBODY><PARAGRAPH>specifies which fields in the <FUNCTION>SgCvtContextInfo</FUNCTION> structure are being set in the context. This is specified as any of the following OR'ed together:</PARAGRAPH>
<CODE>
<SCREENDISPLAY>SG_CVT_INFO_INPUT_PARAMS</SCREENDISPLAY>
<SCREENDISPLAY>SG_CVT_INFO_OUTPUT_PARAMS</SCREENDISPLAY>
<SCREENDISPLAY>SG_CVT_INFO_META_PARAMS</SCREENDISPLAY>
<SCREENDISPLAY>SG_CVT_INFO_INPUT_FILE</SCREENDISPLAY>
<SCREENDISPLAY>SG_CVT_INFO_INPUT_HOST</SCREENDISPLAY>
<SCREENDISPLAY>SG_CVT_INFO_OUTPUT_FILE</SCREENDISPLAY>
<SCREENDISPLAY>SG_CVT_INFO_OUTPUT_HOST</SCREENDISPLAY>
</CODE>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>&space;<VARIABLE>context_data</VARIABLE> </HANGITEM>
<HANGBODY><PARAGRAPH>specifies the values being set</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH><FUNCTION>SgCvtSetContextInfo</FUNCTION> can return the following status value:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>SG_CVT_E_SUCCESS</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The operation succeeded. </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>See the <DOCTITLE>IRIS Media Libraries Programming Guide</DOCTITLE> for information on setting <FUNCTION>DMparams</FUNCTION>. </PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="87840">Evaluating Converters</TITLE><PARAGRAPH>To evaluate a converter, call <INDEXTARGET ID="G.Data.conversion18"><!-- POSTPROCESSDATA: G.Data.conversion18|data exchange:converters, evaluatingconverters:evaluation --><FUNCTION>SgCvtEvaluateConverter()</FUNCTION>: </PARAGRAPH>
<CODE>
SgCvtStatus 
SgCvtEvaluateConverter(SgCvtConverterId converter_id, 
&space;                      SgCvtConversionContext context
&space;                      DMparams **output_params)
</CODE>
<PARAGRAPH>where</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><VARIABLE>converter_id</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>is a converter ID returned by the <FUNCTION>SgCvtQueryRegistry()</FUNCTION> function</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>context</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>is a valid conversion context obtained from <FUNCTION>SgCvtCreateConversionContext()</FUNCTION>&space;</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>output_params</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>returns the output of the request. Converters may set these parameters, even though they accept the request.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH><FUNCTION>SgCvtEvaluateConverter()</FUNCTION> can return the following status values:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>SG_CVT_E_ACCEPT </HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The converter can perform the conversion specified by the conversion context. </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>SG_CVT_E_REJECT</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The converter can't perform the requested conversion.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>When evaluating a converter returns a status of SG_CVT_E_ACCEPT, you should take one final step before calling the converter. You should inspect the <VARIABLE>output_params</VARIABLE> argument, which returns a <FUNCTION>DMparams</FUNCTION> list describing the result that the converter will produce. If your program has very strict requirements, this will help protect you if the converter has accepted the request but cannot honor what it considers a minor parameter, or if you passed a parameter it could not understand.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="25846">Getting Converter Details</TITLE><PARAGRAPH>If your program needs to display information about available converters, or do other processing based on the data stored about a converter in the converter registry, call <INDEXTARGET ID="G.Data.conversion19"><!-- POSTPROCESSDATA: G.Data.conversion19|data exchange:display converter details --><FUNCTION>SgCvtGetConverterAttributes()</FUNCTION> to get a description of it. The function prototype for <FUNCTION>SgCvtGetConverterAttributes()</FUNCTION> is shown below.</PARAGRAPH>
<CODE>
SgCvtStatus 
SgCvtGetConverterAttributes(SgCvtConverterId converter_id,
&space;                          unsigned long converter_attr_mask,
&space;                          SgCvtConverterAttrs *attributes)
</CODE>
<PARAGRAPH>When you are finished using the fields of the <FUNCTION>SgCvtConverterAttrs</FUNCTION> structure, you should free the string attributes and the structure itself (if you allocated it dynamically) using <COMMAND>free</COMMAND>(3C).</PARAGRAPH>
<PARAGRAPH><FUNCTION>SgCvtGetConverterAttributes</FUNCTION> can return the following status value:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>SG_CVT_E_SUCCESS</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The operation succeeded.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="31875">Using GoldenGate to Convert Data</TITLE><PARAGRAPH>This section describes the different methods you can use to convert data. Topics include:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="61772" TYPE="TITLE">&ldquo;Converting Data Using File Converters&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="85174" TYPE="TITLE">&ldquo;Converting Data Using Stream Data Converters&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="61772">Converting Data Using File Converters </TITLE><PARAGRAPH>Your file-based data is always converted using the function <INDEXTARGET ID="G.Data.conversion20"><!-- POSTPROCESSDATA: G.Data.conversion20|data exchange:file converters --><FUNCTION>SgCvtConvertFileToFile</FUNCTION>. Before you call it however, you need to decide whether you want the function to block while the conversion is going on, or return immediately and let you know later that the conversion is complete.</PARAGRAPH>
<PARAGRAPH>In many cases blocking mode is sufficient, and it is much simpler to use if your program is not naturally event driven. However, if your application has a GUI, you may prefer non-blocking mode because it allows your event loop to keep running while conversion is going on. When conversion is complete, you are notified through a callback function that you supply, and you can use the converted data.</PARAGRAPH>
<PARAGRAPH>Both modes are invoked using <FUNCTION>SgCvtConvertFileToFile</FUNCTION>:</PARAGRAPH>
<CODE>
typedef void (*SgCvtCallback)(SgCvtConversionContext context,
&space;                             void *client_data,
&space;                             void *callback_data);
&space;    
SgCvtStatus SgCvtConvertFileToFile
&space;       (
&space;        SgCvtConversionContext   context,
&space;        SgCvtConverterId         converter_id,
&space;        char                     *input_file,
&space;        char                     *output_file,
&space;        unsigned long            callback_mask,
&space;        SgCvtCallback            callback,
&space;        void                     *client_data
&space;        );
</CODE>
<PARAGRAPH>where</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><VARIABLE>context</VARIABLE> </HANGITEM>
<HANGBODY><PARAGRAPH>the conversion context, holding the I/O filenames and parameters</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>converter_id</VARIABLE> </HANGITEM>
<HANGBODY><PARAGRAPH>the converter ID, returned by <FUNCTION>SgCvtQueryConverter</FUNCTION></PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>input_file</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>pathname of input file. You must have read permission.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>output_file</VARIABLE> </HANGITEM>
<HANGBODY><PARAGRAPH>pathname of output file. You must have write permission.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>callback_mask</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>mask indicating when callback should be called. It should be some logical combination of the following values:</PARAGRAPH>
<CODE>
SG_CVT_CB_FLAG_CONVERSION_DONE
&space;     (after completion)
SG_CVT_CB_FLAG_STAGE_DONE
&space;     (after each stage if multi-stage pipeline)
</CODE>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>callback</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>specifies the callback function</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>client_data</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>a pointer to application-defined data structure that will be passed to the callback when invoked</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>If specified, the callback argument is the address of the function to call when conditions specified by the <VARIABLE>callback_mask</VARIABLE> arise. If the callback function is not specified, or the mask is zero, the function executes in blocking mode.</PARAGRAPH>
<PARAGRAPH><FUNCTION>SgCvtConvertFileToFile</FUNCTION> can return the following status values:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>SG_CVT_E_SUCCESS</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The operation succeeded.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>SG_CVT_E_BAD_CONVERTER_TYPE</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The converter was not registered as FileToFile IO method.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>SG_CVT_E_READ_FAILED</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The input file could not be read. It may be missing, or the permissions are insufficient for reading.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>SG_CVT_E_WRITE_FAILED</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The output file could not be written. This can happen if the user does not have write permission for the target directory, or if the supplied pathname was invalid. </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="85174">Converting Data Using Stream Data Converters </TITLE><PARAGRAPH>To convert data using your specified converter, you must initialize the conversion pipeline, and then send the data through. After reading the last block of converted data, clean up by destroying the conversion context to free the resources associated with the pipeline. This section covers the following topics:<INDEXTARGET ID="G.Data.conversion21"><!-- POSTPROCESSDATA: G.Data.conversion21|data exchange:stream data convertersstream data convertersconverters:stream data --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="27136" TYPE="TITLE">&ldquo;Initializing the Pipeline&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="39159" TYPE="TITLE">&ldquo;Sending and Receiving Data&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="75494" TYPE="TITLE">&ldquo;Cleaning Up&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="27136">Initializing the Pipeline</TITLE><PARAGRAPH>Prepare the converter to receive data by calling <FUNCTION>SgCvtInitializePipeline()</FUNCTION>:</PARAGRAPH>
<CODE>
SgCvtStatus 
SgCvtInitializePipeline(SgCvtConversionContext context,
&space;                       SgCvtConverterId  converter_id)
</CODE>
<PARAGRAPH>where</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><VARIABLE>context</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>is a valid conversion context obtained from <FUNCTION>SgCvtCreateConversionContext()</FUNCTION></PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>converter_id</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>is a converter ID returned by the SgCvtQueryRegistry() function</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH><FUNCTION>SgCvtInitializePipeline</FUNCTION> can return the following status values:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>SG_CVT_E_SUCCESS</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The operation succeeded.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>SG_CVT_E_FAILURE</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The context or its contents is bad or one of the subprocesses required to host a converter function could not be launched.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>SG_CVT_E_BAD_CONVERTER_TYPE</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The converter was not registered as StreamToStream. Converters that are designed to work with streaming data advertise themselves as using the StreamToStream method of I/O in the registry.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="39159">Sending and Receiving Data</TITLE><PARAGRAPH>You may send and receive arbitrarily sized blocks of data, so use a block size that is convenient. </PARAGRAPH>
<PARAGRAPH>Send data to the converter using <FUNCTION>SgCvtSendData()</FUNCTION>. The function prototype for <FUNCTION>SgCvtSendData()</FUNCTION> is shown below:</PARAGRAPH>
<CODE>
SgCvtStatus  SgCvtSendData(
&space;   SgCvtConversionContext context,
&space;   void                   *data,
&space;   size_t                 length,
&space;   DMparams               *params,
&space;   boolean_t              canwait
)
</CODE>
<PARAGRAPH>where</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><VARIABLE>context</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>is a valid conversion context</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>data</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>is a pointer to the data block to be converted</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>length</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>is the length of the data block</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>params</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>is a <FUNCTION>DMparams</FUNCTION> structure describing the data to be converted</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>canwait</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>is a boolean value that indicates what the function should do if it cannot send the data immediately. If you specify B_TRUE, <FUNCTION>SgCvtSendData()</FUNCTION> will block until it can send the data to the conversion pipeline. If you specify B_FALSE, <FUNCTION>SgCvtGetData()</FUNCTION> will return immediately with a status of SG_CVT_E_AGAIN. This status indicates that you should try again. </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH><FUNCTION>SgCvtSendData</FUNCTION> can return with the following status values:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>SG_CVT_E_SUCCESS</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The operation succeeded.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>SG_CVT_E_FAILURE</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;An I/O error occurred while trying to send data through the pipe connecting two pipeline components.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>SG_CVT_E_AGAIN</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Required resources were temporarily unavailable. The caller should retry later.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>Read data from the converter using <FUNCTION>SgCvtGetData()</FUNCTION>. The function prototype for <FUNCTION>SgCvtGetData()</FUNCTION> is shown below:</PARAGRAPH>
<CODE>
SgCvtStatus  SgCvtGetData(
&space;   SgCvtConversionContext context,
&space;   size_t                 buf_len,
&space;   void                   *buffer,
&space;   size_t                 *length_returned,
&space;   DMparams               **params_returned,
&space;   boolean_t              canwait
)
</CODE>
<PARAGRAPH>where</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><VARIABLE>context</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>is a valid conversion context</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>buf_len</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>specifies the size of buffer</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>buffer</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>is a pointer to a pre-allocated buffer of at least <VARIABLE>buf_len</VARIABLE> bytes.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>length_returned</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>is the actual length of the returned data (this may be less than <VARIABLE>bytes_requested</VARIABLE> if non-blocking mode is specified, or if the converter encounters end-of-stream) <FUNCTION>SgCvtGetData</FUNCTION></PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>params_returned</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;is a <FUNCTION>DMparams</FUNCTION> structure describing the converted data.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>canwait</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>is a boolean value that indicates what the function should do if no data is available. If you specify B_TRUE, <FUNCTION>SgCvtGetData()</FUNCTION> will block until data becomes available from the conversion pipeline. If you specify B_FALSE, <FUNCTION>SgCvtGetData()</FUNCTION> will return immediately with a status of SG_CVT_E_QUEUE_EMPTY. This status indicates that you should try again. </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH><FUNCTION>SgCvtGetData</FUNCTION> can return the following status values:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>SG_CVT_E_SUCCESS</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The operation succeeded.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>SG_CVT_E_FAILURE</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;An I/O error occurred while trying to read data from the pipe connecting two pipeline components.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>SG_CVT_E_AGAIN</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Required resources were temporarily unavailable. The caller should retry later.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>SG_CVT_E_END_OF_STREAM</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The operation succeeded, and the end of the data has been reached.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>The non-blocking mode of <FUNCTION>SgCvtSendData()</FUNCTION> and <FUNCTION>SgCvtGetData()</FUNCTION> allows programs to continue working on other tasks (such as handling events from a graphical interface) while waiting to send data to or read data from the conversion pipeline.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="75494">Cleaning Up</TITLE><PARAGRAPH>When you've sent the last of the data to the converter, call <FUNCTION>SgCvtSendEndOfStream()</FUNCTION> to indicate the end of the data. After you've read the last of the converted data, free the resources associated with the conversion context by calling <FUNCTION>SgCvtDestroyConversionContext()</FUNCTION>:</PARAGRAPH>
<CODE>
SgCvtStatus SgCvtSendEndOfStream(
&space;   SgCvtConversionContext context
);

SgCvtStatus  SgCvtDestroyConversionContext(
&space;   SgCvtConversionContext context
)
</CODE>
<PARAGRAPH>If you need to terminate the conversion process before reaching the end of the data, call <FUNCTION>SgCvtDestroyConversionContext()</FUNCTION>.</PARAGRAPH>
<PARAGRAPH><FUNCTION>SgCvtSendEndOfStream</FUNCTION> can return the following status value:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>SG_CVT_E_SUCCESS</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The operation succeeded.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH><FUNCTION>SgCvtDestroyConversionContext</FUNCTION> can return the following status value:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>SG_CVT_E_SUCCESS</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The operation succeeded.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="49475">Converter Return Status Values </TITLE><PARAGRAPH><XREF IDREF="95781" TYPE="TABLE">Table&nbsp;G-3</XREF> lists converter functions and their return status values. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="G-3"><PREFIX>Table G-3 </PREFIX><XREFTARGET ID="95781">  <EMPHASIS>(continued)        </EMPHASIS>Converter Return Status Values </CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="181"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>Return Value</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>Description</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH>SgCvtSetQueryConstraint</PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_SUCCESS</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The operation succeeded.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH>SgCvtQueryRegistry</PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_SUCCESS</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The operation succeeded.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_FAILURE</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>Could not find the registry, or failed to 
parse it. Most likely when the default 
registry has been edited to add new 
converters, and a syntax error introduced. 
You may also be loading the wrong file. 
Make sure that if there is a file called 
ConverterRegistry on your path, it is a 
valid registry using the converter 
description file syntax. Also make sure the 
CVT_REGISTRY_OVERRIDE variable is 
not set.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH>SgCvtGetConverterAttributes</PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_SUCCESS</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The operation succeeded.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH>SgCvtCreateConversionContext</PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_SUCCESS</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The operation succeeded.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_NOMEM</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>Insufficient memory to allocate a context.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH>SgCvtDestroyConversionContext</PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_SUCCESS</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The operation succeeded.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH>SgCvtSetContextInfo</PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_SUCCESS</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The operation succeeded.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH>SgCvtGetContextInfo</PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_SUCCESS</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The operation succeeded.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH>SgCvtEvaluateConverter </PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_ACCEPT</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The converter can perform the requested 
conversion.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_REJECT</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The converter cannot perform the 
requested conversion.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH>SgCvtInitializePipeline</PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_SUCCESS</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The operation succeeded.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_FAILURE</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The context or its contents is bad or one of 
the subprocesses required to host a 
converter function could not be launched.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_BAD_&lbreak;CONVERTER_TYPE</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The converter was not registered as 
StreamToStream. Converters that are 
designed to work with streaming data 
advertise themselves as using the 
StreamToStream method of I/O in the 
registry.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH>SgCvtTerminatePipeline</PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_SUCCESS</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The operation succeeded.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH>SgCvtSendData</PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_SUCCESS</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The operation succeeded.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_FAILURE</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>An I/O error occurred while trying to 
send data through the pipe connecting 
two pipeline components.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_AGAIN</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The required resources were temporarily 
unavailable. The caller should retry later.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH>SgCvtGetData</PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_SUCCESS</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The operation succeeded.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_FAILURE</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>An I/O error occurred while trying to read 
data from the pipe connecting two 
pipeline components.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_AGAIN</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The required resources were temporarily 
unavailable. The caller should retry later.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_END_OF_&lbreak;STREAM</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The operation succeeded, and the end of 
the data has been reached.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH>SgCvtSendEndOfStream</PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_SUCCESS</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The operation succeeded.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH>SgCvtEncodeParams</PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_SUCCESS</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The operation succeeded.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH>SgCvtDecodeParams</PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_SUCCESS</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The operation succeeded.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_NOMEM</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>Insufficient memory to allocate structures.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH>SgCvtFreeEncodedParams</PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_SUCCESS</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The operation succeeded.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_FAILURE</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The data could not be decoded.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH>SgCvtConvertFileToFile</PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_SUCCESS</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The operation succeeded.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_BAD_&lbreak;CONVERTER_TYPE </PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The converter was not registered as 
FileToFile I/O method.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_READ_&lbreak;FAILED</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The input file could not be read. It may be 
missing, or the permissions are 
insufficient for reading.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_WRITE_&lbreak;FAILED</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The output file could not be written. This 
can happen if the user does not have write 
permission for the target directory, or if 
the supplied pathname was invalid.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH>SgCvtGetFileSelectionTarget</PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_SUCCESS</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The operation succeeded.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_UNKNOWN_&lbreak;TYPE</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The file type could not be determined.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_NO_TARGET</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The selection target for the type of file 
could not be determined, or there is none.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>SG_CVT_E_FAILURE</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The operation could not be performed for 
another reason, such as the underlying file 
typing database library could not be 
accessed, or the database itself was 
corrupt or missing.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH>SgCvtIsPipeline</PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>B_TRUE</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The translator is a multi-stage pipeline.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="181"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="190" WIDTH="149"><PARAGRAPH>B_FALSE</PARAGRAPH>
</CELL>
<CELL LEFT="345" WIDTH="172"><PARAGRAPH>The translator is a single-stage converter. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="66520">Compiling and Linking Your Program with GoldenGate</TITLE><PARAGRAPH>To compile and link your program, you need to include the header file <INDEXTARGET ID="G.Data.conversion22"><!-- POSTPROCESSDATA: G.Data.conversion22|data exchange:compilingdata exchange:linkingGoldenGate:compiling programsGoldenGate:linking programslinking:programs with GoldenGatecompiling:programs with GoldenGate --><FILENAME>SgCvt.h</FILENAME> and include the library <FILENAME>libcvt</FILENAME> in your link line.</PARAGRAPH>
<PARAGRAPH>An example of a simple GoldenGate program follows. It includes the required header file, enumerates the registered converters, and prints their input and output labels.</PARAGRAPH>
<CODE>
#include &lt;SgCvt.h>
main(int argc, char **argv)
{
&space;   SgCvtRegistry         registry = NULL;
&space;   int                   n=0;
&space;   SgCvtStatus           s;
&space;   SgCvtConverterId      *cvtrs;
&space;   int                   ncvtrs;

&space;   s = SgCvtQueryRegistry(NULL, 0, &amp;registry, &amp;cvtrs, &amp;ncvtrs);
&space;   for (n=0; n&lt;ncvtrs; n++) {
&space;           SgCvtConverterAttrs attrs;

&space;           SgCvtGetConverterAttributes(cvtrs[n],
&space;                SG_CVT_ATTR_FLAG_INPUT_LABEL |
&space;                SG_CVT_ATTR_FLAG_OUTPUT_LABEL,
&space;                &amp;attrs);

&space;           printf(&ldquo;%d %25s -> %s\n&rdquo;,
&space;                n+1, attrs.input_label, attrs.output_label);

&space;           free(attrs.input_label);
&space;           free(attrs.output_label);
&space;    }

&space;    SgCvtFreeRegistry(registry);
}
</CODE>
<PARAGRAPH>The following <FILENAME>Makefile</FILENAME> illustrates the compile and link requirements for this program.</PARAGRAPH>
<CODE>
#
# Makefile for GoldenGate Listing sample program
#
CC      =       cc
TARGET  =       gg_listing
SOURCES =       $(TARGET).

INCLUDES=       -I/usr/include/convert

REQLIBS =       -lcvt
all:
&space;       $(CC) -o $(TARGET) $(INCLUDES) $(SOURCES) $(REQLIBS)
</CODE>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="61988">Writing Converters for the GoldenGate Data Conversion Service</TITLE><PARAGRAPH>This section describes how to write converters that can integrate with GoldenGate and become available to any component that is aware of GoldenGate. The following information assumes that you are familiar with the interfaces described in <INDEXTARGET ID="G.Data.conversion23"><!-- POSTPROCESSDATA: G.Data.conversion23|data exchange:writing convertersdata exchange:converters, writingconverters:writing --><XREF IDREF="85961" TYPE="TITLE">&ldquo;Converting Data Using the GoldenGate Data Conversion Service&rdquo;</XREF>. Both converters and applications use many of the functions and data structures.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Overview of the Converter Writing Process </TITLE><PARAGRAPH>Creating a GoldenGate data converter involves writing the converter and building the DSO, then testing, registering, and installing the converter. The topics below describe:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="66083" TYPE="TITLE">&ldquo;Writing Converter Code&rdquo;</XREF> explains how to write the code that converts the data, or choose an existing command that you want to make available through the conversion service.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="44009" TYPE="TITLE">&ldquo;Building a DSO&rdquo;</XREF> describes how to create a Dynamic Shared Object (DSO) and write a registry entry using converter description file syntax.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="53923" TYPE="TITLE">&ldquo;Testing Your Converter&rdquo;</XREF> explains how to test your converter.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="67307" TYPE="TITLE">&ldquo;Registering Your Converter&rdquo;</XREF> describes how to register your converter to make it available to GoldenGate clients. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="81851" TYPE="TITLE">&ldquo;Installing Your Converter&rdquo;</XREF> lists the library location for converter DSOs. </PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH><XREF IDREF="96157" TYPE="TITLE">&ldquo;Some Sample Converters&rdquo;</XREF> shows annotated code for two converters. </PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="66083">Writing Converter Code</TITLE><PARAGRAPH>This section describes how to write converter code and includes the following topics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="95827" TYPE="TITLE">&ldquo;Implementing Your Converter - Handling Evaluation Requests&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="24054" TYPE="TITLE">&ldquo;Implementing Your Converter - Handling Conversion Requests&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="83154" TYPE="TITLE">&ldquo;Input and Output Formats&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="31930" TYPE="TITLE">&ldquo;Process Blocking&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="41367" TYPE="TITLE">&ldquo;Programming Constraints&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="30794" TYPE="TITLE">&ldquo;Example of a Simple Stream Converter&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="95827">Implementing Your Converter - Handling Evaluation Requests</TITLE><PARAGRAPH>When the operation field of the <INDEXTARGET ID="G.Data.conversion24"><!-- POSTPROCESSDATA: G.Data.conversion24|converters:evaluation requestsdata exchange:converter evaluation requests --><FUNCTION>SgCvtConverterData</FUNCTION> structure passed to your converter is equal to SG_CVT_REQ_EVALUATE, your converter should inspect the input, output, and meta parameters held in the conversion context and determine whether or not it can satisfy the request, without actually performing conversion.</PARAGRAPH>
<PARAGRAPH>If your converter can satisfy the request, it should set the <SCREENDISPLAY>status_return</SCREENDISPLAY> field of the <FUNCTION>SgCvtConverterData</FUNCTION> structure to SG_CVT_E_ACCEPT before returning. Otherwise it should set <SCREENDISPLAY>status_return</SCREENDISPLAY> to SG_CVT_E_REJECT.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="24054">Implementing Your Converter - Handling Conversion Requests</TITLE><PARAGRAPH>When the operation field of the <FUNCTION>SgCvtConverterData</FUNCTION> structure is equal to SG_CVT_REQ_CONVERT, your converter must extract the necessary information from the <FUNCTION>SgCvtConverterData</FUNCTION> structure it is passed, and perform the conversion if possible.   If conversion is successful, it should return with the <SCREENDISPLAY>status_return</SCREENDISPLAY> field set to SG_CVT_E_SUCCESS, and if it is unsuccessful, the <SCREENDISPLAY>status_return</SCREENDISPLAY> field should be set to either SG_CVT_E_FAILURE or a more specific error code if appropriate (see the error codes available in <FILENAME>SgCvt.h</FILENAME>).</PARAGRAPH>
<PARAGRAPH>How the converter is implemented depends on whether you are writing the conversion code yourself, or simply using an existing command-line converter.</PARAGRAPH>
<PARAGRAPH>If you are creating a &ldquo;wrapper&rdquo; to make an existing UNIX command available through the GoldenGate conversion service, the procedure is quite straightforward.</PARAGRAPH>
<PARAGRAPH>In this case, your converter is a function that gathers the input and output requirements from its arguments, and executes the external UNIX command (for instance, by calling the <COMMAND>system</COMMAND>(2) function). </PARAGRAPH>
<PARAGRAPH>Your function should do as much checking as possible to ensure that the external command can work. For instance, you should verify that the command is installed before calling it, and that you have execute permission.</PARAGRAPH>
<PARAGRAPH>Also check for appropriate permissions to read input files and write output files, in the case of file converters. If you detect an error before calling the command, return an error status in the status field of the data argument.</PARAGRAPH>
<PARAGRAPH>For example, the code below shows a FileToFile converter that wraps an existing UNIX command <COMMAND>rtf2html</COMMAND>. You will find other fully annotated examples at the end of this section.</PARAGRAPH>
<CODE>
#include &lt;libgen.h>
#include &lt;SgCvt.h>

void RtfToHtml(void *arg)
{
&space;  SgCvtConverterData *data = (SgCvtConverterData *) arg;
&space;  SgCvtContextInfo ctx_info;
&space;  char cmd[BUFSIZ];
&space;  int sys_status = 0;
&space;  char *xlator_path;

&space;  /* Evaluation - just accept for this example */
&space;  if (data->operation == SG_CVT_REQ_EVALUATE) {
&space;     data->status_return = SG_CVT_E_ACCEPT;
&space;     return;
&space;  }
&space;  
&space;  /* Conversion */

&space;  /* depends on `rtf2html' command being available */
&space;  xlator_path = pathfind(getenv (&ldquo;PATH&rdquo;), &ldquo;rtf2html&rdquo;, &ldquo;rx&rdquo;);
&space;  if (xlator_path == NULL) {
&space;     data->status_return = SG_CVT_E_MISSING_COMMAND;
&space;     return;
&space;  }

&space;  (void) SgCvtGetContextInfo(data->context,
&space;               SG_CVT_INFO_INPUT_FILE          |
&space;               SG_CVT_INFO_OUTPUT_FILE,
&space;               &amp;ctx_info);

&space;  /* cmd syntax is `rtf2html inputfile outputfile'
&space;  sprintf(cmd, &ldquo;%s %s %s 2> /dev/null&rdquo;, xlator_path, 
&space;          ctx_info.input_file, ctx_info.output_file);

&space;  sys_status = system(cmd);

&space;  data->status_return =
&space;     sys_status ? SG_CVT_E_FAILURE : SG_CVT_E_SUCCESS;

&space;  return;
}
</CODE>
<PARAGRAPH>Notice that GoldenGate passes the necessary information to a converter by reference. The <FUNCTION>SgCvtConverterData</FUNCTION> structure is the mechanism for this. It is defined as follows:</PARAGRAPH>
<CODE>
typedef struct {
&space;       SgCvtRequestType        operation;
&space;       SgCvtConversionContext  context;
&space;       DMparams                *output_params;
&space;       SgCvtStatus             status_return;
} SgCvtConverterData;
</CODE>
<PARAGRAPH>If your converter does not use an external command to translate the data, but does the conversion itself, the structure of the converter function is essentially the same.</PARAGRAPH>
<PARAGRAPH>You still use the <FUNCTION>SgCvtConverterData</FUNCTION> structure to communicate with GoldenGate. Between extracting the necessary arguments from the structure and returning from the function, you just call your own functions that do the conversion.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="83154">Input and Output Formats</TITLE><PARAGRAPH>Your converter should use standardized names for its input and output types wherever possible. This is important because applications are written to request data by a particular name. If your converter uses a different name for the same data format, GoldenGate will not find your converter and the conversion may fail.<INDEXTARGET ID="G.Data.conversion25"><!-- POSTPROCESSDATA: G.Data.conversion25|converters:input and output formatsdata exchange:input and output formats --></PARAGRAPH>
<PARAGRAPH>See <XREF IDREF="11667" TYPE="TITLE">&ldquo;Supported Target Formats&rdquo;</XREF> for the data formats supported by the default Silicon Graphics converters.</PARAGRAPH>
<PARAGRAPH>You can also use your own data format names. However, the name your application uses must match the name you registered so GoldenGate ca l find the converter. However, if you use your own data format names, it is unlikely that other applications will be able to take advantage of your converter. Do this only if the format name is well understood among all the applications you intend to cooperate with.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="31930">Process Blocking </TITLE><PARAGRAPH>You can use <INDEXTARGET ID="G.Data.conversion26"><!-- POSTPROCESSDATA: G.Data.conversion26|converters:process blockingdata exchange:process blockingprocess blocking:data exchangeblocking:processes, data exchange --><FUNCTION>SgCvtGetData()</FUNCTION> and <FUNCTION>SgCvtSendData()</FUNCTION> in either blocking or non-blocking mode, depending on your requirements. Both modes are described in <XREF IDREF="61772" TYPE="TITLE">&ldquo;Converting Data Using File Converters&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>If your converter needs to return immediately to do other work, such as tracking activity on an I/O device, you should set the <VARIABLE>canwait</VARIABLE> argument to these functions to B_FALSE. If the conversion pipeline is not ready for an immediate read or write operation, the call will return immediately with a status value indicating that nothing happened and that you should try the same operation again. For additional information on the <VARIABLE>canwait</VARIABLE> argument, see <XREF IDREF="39159" TYPE="TITLE">&ldquo;Sending and Receiving Data&rdquo;</XREF>. </PARAGRAPH>
<PARAGRAPH>If <FUNCTION>SgCvtSendData()</FUNCTION> cannot send data immediately and <VARIABLE>canwait</VARIABLE> is B_FALSE, it returns SG_CVT_E_AGAIN. This indicates that your data has not been sent, and you should try the operation again, using the same data.</PARAGRAPH>
<PARAGRAPH><FUNCTION>SgCvtGetData()</FUNCTION> returns SG_CVT_E_QUEUE_EMPTY if there is no data immediately available and <VARIABLE>canwait</VARIABLE> is B_FALSE. You should try the operation again later.</PARAGRAPH>
<PARAGRAPH>If your converter has no other I/O requirements, you can simplify your code slightly by setting the <VARIABLE>canwait</VARIABLE> argument to B_TRUE. You should use this option by default, because it can eliminate redundant context switching to your idling converter, and improve system performance.</PARAGRAPH>
<PARAGRAPH>There are two categories of converter: FileToFile and StreamToStream.</PARAGRAPH>
<PARAGRAPH>A FileToFile converter uses the input and output file attributes of the conversion context to get its input and save its output, as shown in the example above.</PARAGRAPH>
<PARAGRAPH>A StreamToStream converter follows this general procedure after extracting the required parameters from the context:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Fetch a block of input data using <FUNCTION>SgCvtGetData</FUNCTION></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Convert the data to the new format</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Send converted data back to GoldenGate</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The converter repeats these steps until it receives a status of SG_CVT_E_END_OF_STREAM from <FUNCTION>SgCvtGetData</FUNCTION>, and it successfully sends all the converted data. Then it calls <FUNCTION>SgCvtSendEndOfStream</FUNCTION> to tell GoldenGate it is finished converting, and finally it returns.</PARAGRAPH>
<PARAGRAPH>The functions used for stream conversion are the same ones used by applications to work with conversion streams:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>To fetch input and output parameters to be used in the conversion, use <FUNCTION>SgCvtGetContextInfo</FUNCTION>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>To fetch a block on data for conversion, use <FUNCTION>SgCvtGetData</FUNCTION>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>To send a block of converted data back to GOldenGate, use <FUNCTION>SgCvtSendData</FUNCTION>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>To break your connection to the stream and tell GoldenGate your converter is finished, use <FUNCTION>SgCvtSendEndOfStream</FUNCTION>.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="41367">Programming Constraints</TITLE><PARAGRAPH>Keep in mind the following constraints when writing converters:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>You must not use libraries that are unsafe for threads. For instance, you should not use Motif or other GUI libraries that are not &ldquo;multi-thread-safe.&rdquo;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>You should be careful if installing global event handlers, such as timers and signal handlers, if they override those that may already be installed by the host application. The safest policy is to avoid this altogether.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Where possible, you should avoid intentionally locking system resources such as physical memory blocks by using low-level UNIX calls or device drivers, because this can result in deadlock.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Your code should be reentrant. This means it should not rely on global state between calls, because it is possible for more than one instance of your converter to be running at the same time.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Converters are free to choose the size of the data blocks they read and write. GoldenGate writes into the buffer that your converter supplies during a <FUNCTION>SgCvtGetData()</FUNCTION> call. Your converter must allocate and free this buffer space as necessary. During a <FUNCTION>SgCvtSendData()</FUNCTION> call, your converter again supplies a buffer of data. The <FUNCTION>SgCvtSendData()</FUNCTION> call does not alter your buffer. If the call returns SG_CVT_E_SUCCESS to indicate that your data has been sent, or SG_CVT_E_FAILURE to indicate a general failure, free the buffer or re-use it as appropriate. If the call returns SG_CVT_E_AGAIN (you passed B_FALSE as the <ITALICS>canwait</ITALICS> argument) your data has not been sent, and you should retain it to try again later.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="30794">Example of a Simple Stream Converter</TITLE><PARAGRAPH>The following example shows a simple stream converter. It expects a stream of ASCII text characters, and outputs the stream with any uppercase characters replaced by their lowercase equivalents.<INDEXTARGET ID="G.Data.conversion27"><!-- POSTPROCESSDATA: G.Data.conversion27|data exchange:stream converter exampledata exchange:converter exampleconverters:stream converter examplestream converter example --><INDEXTARGET ID="G.Data.conversion28"><!-- POSTPROCESSDATA: G.Data.conversion28|GoldenGate:stream converter example --></PARAGRAPH>
<CODE>
#include &lt;SgCvt.h>
#include &lt;dmedia/dm_params.h>

void CvtToLower
&space;       (
&space;       void *arg
&space;       )
{
&space;  SgCvtConverterData *data = (SgCvtConverterData *) arg;
&space;  SgCvtStatus s;
&space;  char buf[BUFSIZ];
&space;  size_t nreq = BUFSIZ;
&space;  unsigned int len=0;
&space;  int start = 0;
&space;  int i;

&space;  /* Evaluation */
&space;  if (data->operation == SG_CVT_REQ_EVALUATE) {

&space;       /*
&space;        * In less trivial converters, we would check for
&space;        * valid params in the context, but in this case all
&space;        * we're doing is byte translation, so we can always
&space;        * say yes.
&space;        */

&space;       data->status_return = SG_CVT_E_ACCEPT;
&space;       return;
&space;  }

&space;  /*
&space;   * Conversion Loop.  A similar construct will appear in
&space;   * all streaming converters.  The model is fetch data,
&space;   * convert it and forward it, until we have forwarded the
&space;   * end of stream, then jump out the loop.
&space;   */
&space;  for (;;) {

&space;     s = SgCvtGetData(data->context, nreq, buf, &amp;len, NULL, B_TRUE);
&space;     if (s == SG_CVT_E_FAILURE) {
&space;        fprintf(stderr, &ldquo;converter: failed to get data\n&rdquo;);
&space;        return;
&space;     }

&space;     if (s == SG_CVT_E_END_OF_STREAM) {
&space;       SgCvtSendEndOfStream(data->context);
&space;       break;
&space;     }

&space;     /*** start converter-specific part ***/

&space;     for (i=0; i&lt;len; i++)
&space;        buf[i] = tolower(buf[i]);

&space;     /*** end converter-specific part ***/

&space;     s = SgCvtSendData(data->context, (void *)buf,
&space;                      len, NULL, B_TRUE);

&space;     if (s == SG_CVT_E_FAILURE) {
&space;        fprintf(stderr, &ldquo;converter: failed to get data\n&rdquo;);
&space;        return;
&space;     }
&space;     start += (len);
&space;  }
&space;  /*
&space;   * When we get here, this converter's work
&space;   * is complete.  Others in the same pipeline may
&space;   * still be running, but that's irrelevant to us.
&space;   * We simply return.  If we were invoked in a dedicated
&space;   * sproc &ldquo;thread&rdquo;, which is always the case for
&space;   * streaming converters, this terminates it.
&space;   */

&space;  return;
}
</CODE>
<PARAGRAPH>Note the above comment about other converters: <SCREENDISPLAY>Others in the same pipeline may still be running</SCREENDISPLAY>. It is important to remember that your converter is almost always invoked as a subprocess of the application. <XREF IDREF="41367" TYPE="TITLE">&ldquo;Programming Constraints&rdquo;</XREF> lists some considerations when writing converter code.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="44009">Building a DSO</TITLE><PARAGRAPH>GoldenGate converters reside in Dynamic Shared Object (DSO) libraries.<INDEXTARGET ID="G.Data.conversion29"><!-- POSTPROCESSDATA: G.Data.conversion29|data exchange:DSOGoldenGate:DSODSO:GoldenGate convertersconverters:DSOlibraries:GoldenGate DSO --></PARAGRAPH>
<PARAGRAPH>After you have written and tested your conversion function by calling it directly from a test program, you are ready package it as a GoldenGate converter.</PARAGRAPH>
<PARAGRAPH>This section covers the following topics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="59553" TYPE="TITLE">&ldquo;Creating a DSO For Your Converter&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="79942" TYPE="TITLE">&ldquo;Creating a Converter Description File&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="59553">Creating a DSO For Your Converter</TITLE><PARAGRAPH>Create a DSO for your converter. A simple <FILENAME>Makefile</FILENAME> (below) for the previous example, <XREF IDREF="30794" TYPE="TITLE">&ldquo;Example of a Simple Stream Converter&rdquo;</XREF>, illustrates the compilation and linkage requirements for a GoldenGate DSO.</PARAGRAPH>
<CODE>
#
# Makefile for GoldenGate Sample Converter DSO
#
CVTR = CvtToLower
all:
&space;    cc -c -I/usr/include/convert $(CVTR).c   
&space;    ld -no_unresolved -o libUserCvtrs.so -shared $(CVTR).o
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="79942">Creating a Converter Description File</TITLE><PARAGRAPH>After you compile your converter, you must create a <INDEXTARGET ID="G.Data.conversion30"><!-- POSTPROCESSDATA: G.Data.conversion30|converters:description filedata exchange:converter description fileGoldenGate:converter description file --><ITALICS>converter description file</ITALICS> that identifies your converter to GoldenGate. You use this file to test your converter, and intimately to register it with GoldenGate. A simple example for the <COMMAND>CvtToLower</COMMAND> converter follows.</PARAGRAPH>
<CODE>
#
# Lowercase Text Stream
#
Converter {
&space;       Name:           &ldquo;CvtToLower&rdquo;
&space;       IOMethod:       StreamToStream
&space;       Input:          &ldquo;MIXEDCASE&rdquo;
&space;       InputLabel:     &ldquo;ASCII bytes, any case&rdquo;
&space;       Output:         &ldquo;LOWERCASE&rdquo;
&space;       OutputLabel:    &ldquo;ASCII bytes, lower case&rdquo;
&space;       Vendor:         &ldquo;SGI (Sample)&rdquo;
&space;       Version:        &ldquo;1.0&rdquo;
&space;       Description:    &ldquo;Lowercases chars in input stream&rdquo;
&space;       DSO:            &ldquo;/usr/people/fred/libFredsCvtrs.so&rdquo;
&space;       Function:       &ldquo;CvtToLower&rdquo;
}
</CODE>
<PARAGRAPH>Make sure the DSO field is set to the full pathname for the DSO you have built.</PARAGRAPH>
<PARAGRAPH>The grammar of the converter description file is fairly simple. Three types of statements exist; they are identified by the keywords <KEYWORD>Parameter</KEYWORD>, <KEYWORD>Converter</KEYWORD>, and <KEYWORD>Pipeline</KEYWORD>. <XREF IDREF="18863" TYPE="TABLE">Table&nbsp;G-4</XREF> defines the statements. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="G-4"><PREFIX>Table G-4 </PREFIX><XREFTARGET ID="18863">Converter Description File Statements</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="108"><PARAGRAPH>Statement</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="252"><PARAGRAPH>Description</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><KEYWORD>Parameter</KEYWORD> statement</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="252"><PARAGRAPH>Defines a single parameter</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><KEYWORD>Converter</KEYWORD> statement</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="252"><PARAGRAPH>Describes a converter and may include Parameter statements</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><KEYWORD>Pipeline</KEYWORD> statement</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="252"><PARAGRAPH>Defines a series of converters to be used together, and may 
contain both Converter and Parameter statements</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Some example descriptions follow. The easiest way to write a converter description file is to copy an existing one. You can use these examples, or copy entries from the default registry file, <FILENAME>/var/GoldenGate/ConverterRegistry</FILENAME>.</PARAGRAPH>
<CODE>
#
# Lowercase Text Stream
#
Converter {
&space;       Name:           &ldquo;CvtToLower&rdquo;
&space;       IOMethod:       StreamToStream
&space;       Input:          &ldquo;MIXEDCASE&rdquo;
&space;       InputLabel:     &ldquo;ASCII bytes, any case&rdquo;
&space;       Output:         &ldquo;LOWERCASE&rdquo;
&space;       OutputLabel:    &ldquo;ASCII bytes, lower case&rdquo;
&space;       Vendor:         &ldquo;SGI (Sample)&rdquo;
&space;       Version:        &ldquo;1.0&rdquo;
&space;       Description:    &ldquo;Lowercases chars in input stream&rdquo;
&space;       DSO:            &ldquo;/usr/people/fred/libFredsCvtrs.so&rdquo;
&space;       Function:       &ldquo;CvtToLower&rdquo;
}

#
# Windows BMP to XWD
# 
Converter {
&space;       Name:           &ldquo;BMP_FILE_TO_XWD_FILE&rdquo;
&space;       IOMethod:       FileToFile
&space;       Input:          &ldquo;BMP_FILE&rdquo;
&space;       InputLabel:     &ldquo;BMP_FILE&rdquo;
&space;       Output:         &ldquo;XWD_FILE&rdquo;
&space;       OutputLabel:    &ldquo;XWD_FILE&rdquo;
&space;       Vendor:         &ldquo;SGI&rdquo;
&space;       Version:        &ldquo;1.0&rdquo;
&space;       Description:    &ldquo;BMP_FILE to XWD_FILE&rdquo;
&space;       DSO:            &ldquo;libcvt_SGI.so&rdquo;
&space;       Function:       &ldquo;xwdout&rdquo;
}

#
# Windows BMP to Compuserv GIF-89, through JPEG (JFIF)
# This isn't necessary, since the default converters
# can go directly to GIF 89 from BMP, but it illustrates the # Pipeline syntax for chaining converters together.
Pipeline {
&space;       Name:           &ldquo;BMP_FILE_TO_GIF_89_FILE&rdquo;
&space;       IOMethod:       FileToFile
&space;       Input:          &ldquo;BMP_FILE&rdquo;
&space;       InputLabel:     &ldquo;Windows BMP&rdquo;
&space;       Output:         &ldquo;GIF_89_FILE&rdquo;
&space;       OutputLabel:    &ldquo;Compuserve GIF&rdquo;
&space;       Vendor:         &ldquo;SGI&rdquo;
&space;       Version:        &ldquo;1.0&rdquo;
&space;       Description:    &ldquo;Windows BMP to GIF, via JPG&rdquo;
&space;  Converter {
&space;       Name:           &ldquo;BMP_FILE_TO_JFIF_FILE&rdquo;
&space;       IOMethod:       FileToFile
&space;       Input:          &ldquo;BMP_FILE&rdquo;
&space;       InputLabel:     &ldquo;BMP_FILE&rdquo;
&space;       Output:         &ldquo;JFIF_FILE&rdquo;
&space;       OutputLabel:    &ldquo;JFIF_FILE&rdquo;
&space;       Vendor:         &ldquo;SGI&rdquo;
&space;       Version:        &ldquo;1.0&rdquo;
&space;       Description:    &ldquo;BMP_FILE to JFIF_FILE&rdquo;
&space;       DSO:            &ldquo;libcvt_SGI.so&rdquo;
&space;       Function:       &ldquo;jfifout&rdquo;
&space;  }
&space;  Converter {
&space;       Name:           &ldquo;JFIF_FILE_TO_GIF_89_FILE&rdquo;
&space;       IOMethod:       FileToFile
&space;       Input:          &ldquo;JFIF_FILE&rdquo;
&space;       InputLabel:     &ldquo;JFIF_FILE&rdquo;
&space;       Output:         &ldquo;GIF_89_FILE&rdquo;
&space;       OutputLabel:    &ldquo;GIF_89_FILE&rdquo;
&space;       Vendor:         &ldquo;SGI&rdquo;
&space;       Version:        &ldquo;1.0&rdquo;
&space;       Description:    &ldquo;BMP_FILE to GIF_89_FILE&rdquo;
&space;       DSO:            &ldquo;libcvt_SGI.so&rdquo;
&space;       Function:       &ldquo;gifout&rdquo;
&space;  }
}
</CODE>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="53923">Testing Your Converter</TITLE><PARAGRAPH>To test your converter, first verify that your converter description file is valid and does not cause the GoldenGate built-in registry parser to fail.<INDEXTARGET ID="G.Data.conversion31"><!-- POSTPROCESSDATA: G.Data.conversion31|converters:testingdata exchange:converter, testingdata exchange:testing convertersGoldenGate:testing converter --></PARAGRAPH>
<PARAGRAPH>Set the environment variable CVT_REGISTRY_OVERRIDE to the full pathname of the converter description file you just created:</PARAGRAPH>
<CODE>
setenv CVT_REGISTRY_OVERRIDE /usr/people/fred/my_registry.cdf
</CODE>
<PARAGRAPH>Then run a test program that will exercise the parser. The <COMMAND>gg_query</COMMAND> demo program that comes with GoldenGate is good for this. Find it in <FILENAME>/usr/share/src/GoldenGate</FILENAME> (if you haven't already done so, install the demo programs from your IRIX distribution media). Copy the demo programs to your own directory, go into the <FILENAME>Query</FILENAME> subdirectory, and type <USERINPUT>make</USERINPUT>.   Then execute the <COMMAND>gg_query</COMMAND> program. The output should look like this:</PARAGRAPH>
<CODE>
Converter (CvtToLower):
&space;       method: Stream To Stream
&space;       input:  MIXEDCASE (ASCII bytes, any case)
&space;       output: LOWERCASE (ASCII bytes, lower case)
&space;       vendor: SGI (Sample)
&space;       version:        1.0
&space;       descr.: Lowercases chars in input stream
&space;       DSOname:        /usr/people/fred/libFredsCvtrs.so
&space;       Function:       CvtToLower
</CODE>
<PARAGRAPH>If you see an error message, go back and check that your converter description file is valid, checking especially that all string values are properly quoted. Also check that the GoldenGate software is properly installed by unsetting the CVT_REGISTRY_OVERRIDE variable and re-executing the <COMMAND>gg_query</COMMAND> program. It should list the default converters installed on the system (over 100 of these exist).</PARAGRAPH>
<PARAGRAPH>Once the test runs successfully, you are ready to try executing your converter. You can use your own program, or the demo programs in the ConvertFile and ConvertStream directories to do this. Each program prints a help message describing its arguments if you run it with no arguments.</PARAGRAPH>
<PARAGRAPH>After you are satisfied that your converter works when executed via GoldenGate, you are ready to make it available to other applications on the system.   Unset the CVT_REGISTRY_OVERRIDE variable; you are finished unit-testing your converter.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="67307">Registering Your Converter</TITLE><PARAGRAPH>To register your converter, you must add your converter description file to the system registry. <INDEXTARGET ID="G.Data.conversion32"><!-- POSTPROCESSDATA: G.Data.conversion32|converters:registeringdata exchange:converter, registeringdata exchange:registering convertersGoldenGate:registering converter --></PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>The System Registry </TITLE><PARAGRAPH>The system registry is a text file that uses the same syntax as your converter description file. Just edit the file <FILENAME>/var/GoldenGate/ConverterRegistry</FILENAME> (you must be a privileged user to do this) and add your entry wherever you like. </PARAGRAPH>
<PARAGRAPH>Look at the attributes of the converters already registered. If there are potential clashes with your converter, you may wish to insert your converter closer to the beginning of the registry. Some applications may decide to convert using the first converter they find that appears to satisfy their requirements, rather than evaluating the alternatives. If you want to make sure this kind of application executes your converter rather than another one that could do that same conversion, insert your entry closer to the beginning of the file.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Some Registry Syntax Details</TITLE><PARAGRAPH>The most important fields are those that the service uses to locate the executable converter module: the <SCREENDISPLAY>DSO</SCREENDISPLAY> name and the <SCREENDISPLAY>Function</SCREENDISPLAY> name. The other fields are primarily for display by administration tools, and for applications to query the registry. The <VARIABLE>Input</VARIABLE> and <VARIABLE>Output</VARIABLE> fields are strings that must exactly match the format names that applications will use to search for converters. For instance, where there are naming conventions such as ICCCM target names, these should be used exactly. </PARAGRAPH>
<PARAGRAPH>See <XREF IDREF="11667" TYPE="TITLE">&ldquo;Supported Target Formats&rdquo;</XREF> for a list of standard input and output formats supported by the default converters supplied with GoldenGate.</PARAGRAPH>
<PARAGRAPH>Parameters can be one of two types: Constraint or Programmable.</PARAGRAPH>
<PARAGRAPH><ITALICS>Constraint parameters</ITALICS> are used to specify constant values for a data attribute in the description file. When you see a constraint parameter, it means that this converter always sets the corresponding data attribute to the stored value, overriding its current value in the input.</PARAGRAPH>
<PARAGRAPH><ITALICS>Programmable parameters</ITALICS> are used to specify parameters that are set at runtime based upon the requested input and output parameters. Programmable parameters are used to pass a runtime parameter to one of the stages of a pipeline. For example, if you have a two-stage pipeline designed to scale an SGI image to an arbitrary size, then convert it to JPEG, you want to pass one of the output parameters (the required output size) to the first stage of the converter. You do this by specifying a programmable parameter for the first stage. </PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="81851">Installing Your Converter </TITLE><PARAGRAPH>Make sure your installation copies the DSO containing your converter to the standard location for converter DSOs: <INDEXTARGET ID="G.Data.conversion33"><!-- POSTPROCESSDATA: G.Data.conversion33|data exchange:installing convertersdata exchange:converters, installingconverters:installinginstalling:converters --><FILENAME>/usr/lib/convert</FILENAME>. If you install your library there, you can use a relative DSO name in your converter description file. If you install anywhere else, you must use a full path name in the registry to ensure that the service will find your converter. </PARAGRAPH>
<PARAGRAPH>See the GoldenGate Release Notes (type <USERINPUT>relnotes</USERINPUT>&space;<USERINPUT>goldengate</USERINPUT>) for information about installation.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="96157">Some Sample Converters</TITLE><PARAGRAPH>This section presents annotated sample code for two different converters: <INDEXTARGET ID="G.Data.conversion34"><!-- POSTPROCESSDATA: G.Data.conversion34|converters:examplesdata exchange:converter, examplesdata exchange:example convertersGoldenGate:example converters --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The first example, <XREF IDREF="68810" TYPE="TITLE">&ldquo;A Simple StreamToStream Converter - UpperCase&rdquo;</XREF>, directly modifies data flowing through it.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The second example, <XREF IDREF="71684" TYPE="TITLE">&ldquo;A FileToFile Converter - UNIX Man Page File to HTML File&rdquo;</XREF>, illustrates two techniques. First it serves as a basic template for FileToFile converters, and second it shows how you can wrap an external IRIX command to make it available as a GoldenGate converter. </PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="68810">A Simple StreamToStream Converter - UpperCase</TITLE><PARAGRAPH>This type of converter can often offer the best performance in many circumstances, because all the knowledge of the conversion operation is in the converter itself, and because it typically does not need to access the filesystem to achieve conversion. It is appropriate when the data format is naturally streamable, such as ASCII text or other self-identifying or raw data.<INDEXTARGET ID="G.Data.conversion35"><!-- POSTPROCESSDATA: G.Data.conversion35|converters:StreamToStream exampledata exchange:StreamToStream converter, exampledata exchange:StreamToStream exampleGoldenGate:StreamToStream example --></PARAGRAPH>
<PARAGRAPH>The converter used in this example performs a simple mapping of mixed-case text to uppercase text. The converter-specific parts are clearly marked. These are the lines that you will replace with your own task-specific conversion code. The remainder is boilerplate code that can be re-used in many different converters.</PARAGRAPH>
<CODE>
/* converter function */
void UpperCase
(
&space;   void *arg
)
{
&space;   SgCvtConverterData *data = (SgCvtConverterData *) arg;
&space;   SgCvtStatus s;
</CODE>
<PARAGRAPH>The next 2 lines are somewhat task-specific. Your converter should use a buffer size appropriate to the data type and the task. Careful selection of a buffer size will yield better performance in many cases. For instance, if your converters needs to operate on audio or movie &ldquo;frames,&rdquo; then you may choose to read and write buffers that represent whole numbers of frames.</PARAGRAPH>
<CODE>
&space;   char buf[BUFSIZ];
&space;   size_t nreq = BUFSIZ;

&space;   unsigned int len=0;
&space;   int start = 0;
&space;   int i;
</CODE>
<PARAGRAPH>The next part is the Evaluation section. Our converter operates on a byte stream: if a byte represents a lower-case character in the current locale, we are going to uppercase it. Otherwise it passes through untouched. It is appropriate for this converter to accept any stream; it does not need to evaluate parameters.</PARAGRAPH>
<CODE>
&space;   /* Evaluation */
&space;   if (data->operation == SG_CVT_REQ_EVALUATE) {
&space;       data->status_return = SG_CVT_E_ACCEPT;
&space;       return;
&space;   }
</CODE>
<PARAGRAPH>The following loop does the conversion, one block at a time. The loop terminates when the end of stream is detected. </PARAGRAPH>
<CODE>
&space;   /* Conversion */
&space;   for (;;) {

&space;       s = SgCvtGetData(data->context, nreq, buf, &amp;len,
&space;                        NULL, B_TRUE);

&space;       if (s == SG_CVT_E_END_OF_STREAM) {
&space;           SgCvtSendEndOfStream(data->context);
&space;           break;
&space;       }
</CODE>
<PARAGRAPH>These two lines show the entire task-specific code requirements for the uppercase text converter. Your converter will substitute its own conversion-specific code for these lines. The model is the same in each case; the converter generates a buffer to be sent from the buffer it has received, by applying a specific conversion algorithm. </PARAGRAPH>
<CODE>
&space;       for (i=0; i&lt;len; i++)
&space;           buf[i] = toupper(buf[i]);
</CODE>
<PARAGRAPH>When the new buffer has been generated, your converter sends it into the pipeline. In this example, the data was converted in place. Sometimes that is not possible, because the converted data will not fit in the original buffer. In these cases, your converter may allocate, populate, send, then free a dynamic buffer each time through the loop.</PARAGRAPH>
<CODE>
&space;       s = SgCvtSendData(data->context, (void *)buf, len,
&space;                         NULL, B_TRUE);

&space;       start += (len);
&space;   }
</CODE>
<PARAGRAPH>After sending all the converted data, and calling SgCvtSendEndOfStream, your converter can return. You should always set the <SCREENDISPLAY>status_return</SCREENDISPLAY> field.</PARAGRAPH>
<CODE>
&space;   data->status_return = SG_CVT_E_SUCCESS;
&space;   return;
}
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="71684">A FileToFile Converter - UNIX Man Page File to HTML File</TITLE><PARAGRAPH>Often, to convert data from one application into a form usable by another, you need to save the data to a file in one format, convert it using an IRIX command-line translator program, then open the new file using the application you want to use.<INDEXTARGET ID="G.Data.conversion36"><!-- POSTPROCESSDATA: G.Data.conversion36|converters:FileToFile exampledata exchange:converter, FiletoFile exampledata exchange:FileToFile exampleGoldenGate:FileToFile example --></PARAGRAPH>
<PARAGRAPH>Applications using components that are integrated with GoldenGate can eliminate the intermediate end-user steps. The same external translator command can be packaged as a GoldenGate converter and invoked automatically on behalf of the user.</PARAGRAPH>
<PARAGRAPH>It is quite straightforward to integrate an existing IRIX command with GoldenGate. Your main task is to write a function that the service can invoke, which constructs from its parameters a command line for the translator program. </PARAGRAPH>
<PARAGRAPH>The converter described here provides GoldenGate access to a command named <COMMAND>man2html</COMMAND>, which converts <COMMAND>troff</COMMAND> source files for UNIX man pages into HTML files that can be viewed using a Web browser. It can be used by a CGI script that implements an online help system for remote users running Web browsers.</PARAGRAPH>
<PARAGRAPH>The command itself takes one argument: the input file name. It writes its output to stdout. The job of our converter is to make this interface look like any other GoldenGate converter.</PARAGRAPH>
<PARAGRAPH>Converter functions always require the <FILENAME>SgCvt.h</FILENAME> header file and always have the have the same calling convention: </PARAGRAPH>
<CODE>
#include &lt;libgen.h>
#include &lt;SgCvt.h>
void ManToHtml(void *arg)
{
</CODE>
<PARAGRAPH>First, cast the data argument to the right type.</PARAGRAPH>
<CODE>
&space;   SgCvtConverterData *data = (SgCvtConverterData *) arg;
</CODE>
<PARAGRAPH>Then, define some other local variables. Most of these are the same in every converter of this type that you write.</PARAGRAPH>
<CODE>
&space;   SgCvtStatus s;
&space;   SgCvtContextInfo ctx_info;
&space;   char cmd[BUFSIZ];
&space;   int sys_status = 0;
&space;   char *cmdpath;
</CODE>
<PARAGRAPH>Next, handle converter evaluation requests. This <FUNCTION>c</FUNCTION>onverter is very simplistic: there are no parameters, and it just ACCEPTs the request. In real converters, always provide proper evaluation of any parameters, especially if it is expensive for the application to try the conversion and fail. </PARAGRAPH>
<CODE>
&space;   /* Evaluation */
&space;   if (data->operation == SG_CVT_REQ_EVALUATE) {
&space;       data->status_return = SG_CVT_E_ACCEPT;
&space;       return;
&space;   }
</CODE>
<PARAGRAPH>The remaining code handles conversion requests. Note that it is never reached unless the caller requests conversion because the evaluate section has its own return statement.</PARAGRAPH>
<PARAGRAPH>The first thing to do is check that the program you are wrapping is installed and that you can execute it.</PARAGRAPH>
<CODE>
&space;   /* conversion */
&space;   cmdpath = pathfind(getenv (&ldquo;PATH&rdquo;), &ldquo;man2html&rdquo;, &ldquo;rx&rdquo;);
&space;   if (cmdpath == NULL) {
&space;       data->status_return = SG_CVT_E_MISSING_COMMAND;
&space;       return;
&space;   }
</CODE>
<PARAGRAPH>Then, extract the input and output filenames from the conversion context.</PARAGRAPH>
<CODE>
&space;   (void) SgCvtGetContextInfo(data->context,
&space;       SG_CVT_INFO_INPUT_FILE   |
&space;       SG_CVT_INFO_OUTPUT_FILE,
&space;       &amp;ctx_info);
</CODE>
<PARAGRAPH>At this point you know everything needed to construct the command you are going to execute. You use the UNIX <COMMAND>system</COMMAND>(2) call to execute the conversion, so the next step is to create the command line.</PARAGRAPH>
<CODE>
&space;   sprintf(cmd, &ldquo;%s %s > %s 2> /dev/null&rdquo;, cmdpath,
&space;        ctx_info.input_file, ctx_info.output_file);
</CODE>
<PARAGRAPH>Finally, execute the command, and set the return status to indicate whether it worked before returning.</PARAGRAPH>
<CODE>
&space;   sys_status = system(cmd);
&space;   data->status_return =
&space;       sys_status ? SG_CVT_E_FAILURE : SG_CVT_E_SUCCESS;

&space;   return;
}
</CODE>
<PARAGRAPH>Note that your converter is normally run as a subprocess of the invoking application. You should not call <FUNCTION>exit</FUNCTION>(2) to terminate your converter; you should simply return, allowing GoldenGate and the operating system to take care of managing conversion threads. </PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
</APPENDIX>
