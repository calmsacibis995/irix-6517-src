<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="4"><TITLE><XREFTARGET ID="67830">Using the Silicon Graphics Enhanced Widgets</TITLE><PARAGRAPH>This chapter discusses the Silicon Graphics enhanced IRIS IM widgets, the mixed-model programming widgets for using OpenGL in an IRIS IM application, and the HTML viewer widget. This chapter contains these sections:<INDEXTARGET ID="04.Widgets1"><!-- POSTPROCESSDATA: 04.Widgets1|gizmos. <ITALICS>See</ITALICS> widgetswidgetsdesktop:widgets --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="77041" TYPE="TITLE">&ldquo;Using the SGI Enhanced Widgets&rdquo;</XREF> explains how your application can access the SGI enhanced widgets.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="27962" TYPE="TITLE">&ldquo;Using the Widget Demos&rdquo;</XREF> explains how to use the provided demos to experiment with some of the SGI enhanced widgets.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="69317" TYPE="TITLE">&ldquo;The SGI Enhanced Widgets&rdquo;</XREF> lists and discusses each of the new widgets.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="27054" TYPE="TITLE">&ldquo;The Enhanced Widgets&rdquo;</XREF> lists and discusses each of the enhanced widgets.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="43041" TYPE="TITLE">&ldquo;The Mixed-Model Programming Widgets&rdquo;</XREF> discusses the mixed-model programming widgets that Silicon Graphics provides for use with your OpenGL or IRIS GL application.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="46176" TYPE="TITLE">&ldquo;HTML Viewer Component&rdquo;</XREF> explains the HTML viewer component that provides the widgets and libraries necessary for applications to directly access the World Wide Web to display online help and licensing information.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="77041">Using the SGI Enhanced Widgets</TITLE><PARAGRAPH>To use a new or enhanced widget, first switch on the IRIX Interactive Desktop enhanced look and schemes, as described in <XREF IDREF="62287" TYPE="TITLE">Chapter&nbsp;2, &ldquo;Getting the IRIX Interactive Desktop Look,&rdquo;</XREF> and <XREF IDREF="74067" TYPE="TITLE">Chapter&nbsp;3, &ldquo;Using Schemes,&rdquo;</XREF> respectively. </PARAGRAPH>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="27962">Using the Widget Demos</TITLE><PARAGRAPH>Silicon Graphics provides demos for some of the SGI enhanced widgets. These demos let you experiment with the different resources for each widget.<INDEXTARGET ID="04.Widgets2"><!-- POSTPROCESSDATA: 04.Widgets2|widgets:demos --></PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Location of Widget Demos</TITLE><PARAGRAPH>The widget demos are in <FILENAME>/usr/src/X11/motif/Sgm</FILENAME>. The demos are part of the <ITALICS>motif_dev.sw.demoSgi</ITALICS> subsystem&mdash;if you can't find them on your system, check to make sure this subsystem is installed.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Instructions for Building the Widget Demos</TITLE><PARAGRAPH>The demo tree is shipped with X11 Imakefiles, not Makefiles. To build the demos:<INDEXTARGET ID="04.Widgets3"><!-- POSTPROCESSDATA: 04.Widgets3|widgets:building demos --></PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Change to the IRIS IM demos build tree location.</PARAGRAPH>
<EXAMPLE>
% <USERINPUT>cd /usr/src/X11/motif/Sgm</USERINPUT>&space;
</EXAMPLE>
</LIST>
<LIST><PARAGRAPH>Build the initial Makefile.</PARAGRAPH>
<EXAMPLE>
% <USERINPUT>../mmkmf</USERINPUT>&space;
</EXAMPLE>
</LIST>
<LIST><PARAGRAPH>Verify that the Makefile is OK.</PARAGRAPH>
<EXAMPLE>
% <USERINPUT>make Makefile</USERINPUT>&space;
</EXAMPLE>
</LIST>
<LIST><PARAGRAPH>Update the rest of your Makefiles.</PARAGRAPH>
<EXAMPLE>
% <USERINPUT>make Makefiles</USERINPUT>&space;
</EXAMPLE>
</LIST>
<LIST><PARAGRAPH>Clean the directory. If you don't and this isn't your first installation, obsolete binaries might remain, giving unexpected results.</PARAGRAPH>
<EXAMPLE>
% <USERINPUT>make clean</USERINPUT>&space;
</EXAMPLE>
</LIST>
<LIST><PARAGRAPH>Update Makefile dependencies to make sure that everything is installed properly.</PARAGRAPH>
<EXAMPLE>
% <USERINPUT>make depend</USERINPUT>&space;
</EXAMPLE>
</LIST>
<LIST><PARAGRAPH>Build the demos.</PARAGRAPH>
<EXAMPLE>
% <USERINPUT>make all</USERINPUT>&space;
</EXAMPLE>
</LIST>
</ORDEREDLIST>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="27054">The Enhanced Widgets</TITLE><PARAGRAPH>Silicon Graphics provides enhanced versions of these existing IRIS IM widgets:<INDEXTARGET ID="04.Widgets4"><!-- POSTPROCESSDATA: 04.Widgets4|widgets:enhanced --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="38934" TYPE="TITLE">&ldquo;The File Selection Box Widget&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="80138" TYPE="TITLE">&ldquo;The Scale (Percent Done Indicator) Widget&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="92950" TYPE="TITLE">&ldquo;The Text and TextField Widgets&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>This section describes how to use the enhancements to these widgets. For guidelines on when to use these widgets, refer to the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE>.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="38934">The File Selection Box Widget</TITLE><PARAGRAPH>The FileSelectionBox widget (<INDEXTARGET ID="04.Widgets5"><!-- POSTPROCESSDATA: 04.Widgets5|widgets:File Selection BoxFile Selection Box widgetfiles:selecting --><BOLD>SgFileSelectionBox</BOLD>), shown in <XREF IDREF="31121" TYPE="GRAPHIC">Figure&nbsp;4-1</XREF>, is an enhanced version of the existing IRIS IM FileSelectionBox widget (<BOLD>XmFileSelectionBox</BOLD>). The API is consistent with the IRIS IM version of the widget, but the presentation is different.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>To get the enhanced FileSelectionBox, you need to set the <BOLD>SgNuseEnhancedFSB</BOLD> resource to true (in addition to linking with <CMDLINEOPT>-lSgm</CMDLINEOPT>). Typically, do this in your application's <FILENAME>app-defaults</FILENAME> file.</NOTE>
<PARAGRAPH><FIGURE>&space;<GRAPHIC FILE="file.selection.box.online.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="4-1"><PREFIX>Figure 4-1 </PREFIX><XREFTARGET ID="31121">The File Selection Box Widget</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>The FileSelectionBox traverses directories, shows files and subdirectories, and selects files. It has these main areas:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>Show menu and Hidden Files toggle</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;They control what appears in the scrolling list of directories and files beneath them. The Show menu allows the user to restrict the list to display only files of a particular type or format. Minimally the list has two items: All and Custom... . &ldquo;All&rdquo; always appears at the top of the menu, and &ldquo;Custom...&rdquo; always appears at the bottom of the menu following a separator. All shows an unrestricted view of all files and directories in the current subdirectory. Custom... launches the custom filter dialog. </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>Files and directories list</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The scrollable list in the enhanced FileSelectionBox contains both files and directories. Directories appear in bold at the top of the list. Files appear after the directories and are sorted alphabetically. </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>Finder widget</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The DropPocket displays the icon and the text field displays the name of the current directory or file. The user can select a file or directory by dropping its icon on the DropPocket or typing its name in the text field. Automatic file completion is supported. Clicking the right mouse over a path bar button of the path navigation bar shows the directory/file choices at that level. The user can also recall a previously-selected directory from the DynaMenu. <XREF IDREF="81745" TYPE="TITLE">&ldquo;The Finder Widget&rdquo;</XREF> discusses the Finder widget in more detail.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>Command panel</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The buttons at the bottom of the FileSelectionBox reflect the action name; the <BUTTON>OK</BUTTON>, <BUTTON>Cancel</BUTTON> and <BUTTON>Help</BUTTON> buttons operate the same in the enhanced FileSelectionBox as they do in the regular version. The <BUTTON>Filter</BUTTON> button pops up a Filter Dialog, which allows a user to enter a shell-style filename expression as filter pattern. The enhanced FileSelectionBox displays only those files in the current directory that match the given pattern. (The FileSelectionBox continues to display any subdirectories in the current directory.)</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>The programmatic interface to the enhanced FileSelectionBox differs from the regular version in the following points:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>You can retrieve the Finder child of the FileSelectionBox using the standard <BOLD>XmFileSelectionBoxGetChild</BOLD>(3X) by providing the defined constant SgDIALOG_FINDER as the child. You should check the returned widget for validity; it is NULL if the FileSelectionBox is not enhanced.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><BOLD>XmNdirMask</BOLD> is not guaranteed to be exactly the same as the regular version of the FileSelectionBox in all situations. It does conform to the definition in the <REFPAGE>XmFileSelectionBox(3X)</REFPAGE> reference page. Specifically, the directory portion <BOLD>XmNdirMask</BOLD> may not be present in the enhanced FileSelectionBox's representation.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><BOLD>XmNfileTypeMask</BOLD> behavior is different because there is no separate directory list. In the enhanced FileSelectionBox:</PARAGRAPH>
<BULLETLISTIND><BULLETIND><PARAGRAPH>XmFILE_REGULAR and XmFILE_ANY_TYPE show both files and directories in the file list</PARAGRAPH>
</BULLETIND>
<BULLETIND><PARAGRAPH>XmFILE_DIRECTORY shows only directories</PARAGRAPH>
</BULLETIND>
</BULLETLISTIND>
</BULLET>
</BULLETLIST>
<PARAGRAPH>For detailed information on the FileSelectionBox widget, refer to the <REFPAGE>SgFileSelectionBox(3X)</REFPAGE> reference page. For an example program using the FileSelectionBox widget, see <XREF IDREF="36380" TYPE="TITLE">&ldquo;Example Program for File Selection Box&rdquo;</XREF>. See <EXTREF IDREF="30192" BOOK="UI_Glines" FILE="" HDG="30192" INFO="">Chapter&nbsp;10, &ldquo;Dialogs,&rdquo;</EXTREF>
 in the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE> for guidelines on using dialogs in your application. For information about standard <BOLD>XmFileSelectionBox</BOLD> resources, behavior, and callbacks, see the <REFPAGE>XmFileSelectionBox(3X)</REFPAGE> reference page. </PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="80138">The Scale (Percent Done Indicator) Widget</TITLE><PARAGRAPH>The Scale widget (<INDEXTARGET ID="04.Widgets6"><!-- POSTPROCESSDATA: 04.Widgets6|widgets:Scalewidgets:percentage donepercent done indicatorScale widgetwidgets:sliderslider widget --><BOLD>SgScale</BOLD>), is an enhanced version of the IRIS IM Scale widget (<INDEXTARGET ID="04.Widgets7"><!-- POSTPROCESSDATA: 04.Widgets7|widgets:progress indicatorprogress indicator --><BOLD>XmScale</BOLD>). The enhanced Scale widget is also referred to as the Percent Done Indicator or Progress Indicator. </PARAGRAPH>
<PARAGRAPH>To implement this indicator, set the following resources: </PARAGRAPH>
<CODE>
*scale.sliderVisual:    flat_foreground
*scale.slidingMode:     thermometer
*scale.slanted:         true
</CODE>
<PARAGRAPH>For an example of code, see <XREF IDREF="96832" TYPE="TITLE">&ldquo;Example Programs for Scale (Percent Done Indicator) Widget&rdquo;</XREF>. Also see <EXTREF IDREF="85716" BOOK="UI_Glines" FILE="" HDG="85716" INFO="">&ldquo;IRIX Interactive Desktop Scales&rdquo; in Chapter&nbsp;9</EXTREF>
 of the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE> for guidelines on using scales in your application. For more information on the enhanced Scale widget, refer to the <REFPAGE>SgScale(3X)</REFPAGE> reference page. For more information on the unenhanced version of the widget, refer to the <REFPAGE>XmScale(3X)</REFPAGE> reference page. </PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="92950">The Text and TextField Widgets</TITLE><PARAGRAPH>The Text and TextField widgets (<INDEXTARGET ID="04.Widgets8"><!-- POSTPROCESSDATA: 04.Widgets8|widgets:textwidgets:text fieldtext widgettext field widget --><BOLD>SgText</BOLD> and <BOLD>SgTextField</BOLD>) are enhanced versions of the IRIS IM Text and TextField widgets (<BOLD>XmText</BOLD> and <BOLD>XmTextField</BOLD>). In addition to the standard <BOLD>XmText</BOLD> and <BOLD>XmTextField</BOLD> resources, these widgets provide the following new resources:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><BOLD>selectionBackground</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The background color for selected text.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>selectionForeground</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The foreground color for selected text.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>errorBackground</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The background color for text that you select with an &ldquo;error status&rdquo; by using the <FUNCTION>SgTextSetErrorSelection()</FUNCTION> or <FUNCTION>SgTextFieldSetErrorSelection()</FUNCTION> function (depending on whether the widget is a <BOLD>SgText</BOLD> or <BOLD>SgTextField</BOLD> widget).</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>cursorVisibleOnFocus</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;If TRUE (the default), the widget displays the text cursor only when the widget has focus. If FALSE, the cursor is always visible even when the widget doesn't have keyboard focus.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>The <FUNCTION>SgTextSetErrorSelection()</FUNCTION> and <FUNCTION>SgTextFieldSetErrorSelection()</FUNCTION> functions operate almost identically to the <FUNCTION>XmTextSetSelection()</FUNCTION> and <FUNCTION>XmTextFieldSetSelection()</FUNCTION> functions. You use them to select a range of text as the primary selection. The only difference is that the selected text is drawn with the background color specified by the <BOLD>errorBackground</BOLD> resource instead of that specified by the <BOLD>selectionBackground</BOLD> resource.</PARAGRAPH>
<PARAGRAPH>For a detailed description of the new resources for the enhanced versions of these widgets, refer to the <REFPAGE>SgText</REFPAGE><REFPAGE>(3X)</REFPAGE> and <REFPAGE>SgTextField(3X)</REFPAGE> reference pages. For information on the unenhanced versions of these widgets, refer to the <REFPAGE>XmText(3X)</REFPAGE> and <REFPAGE>XmTextField(3X)</REFPAGE> reference pages. See <EXTREF IDREF="36229" BOOK="UI_Glines" FILE="" HDG="36229" INFO="">&ldquo;Text Fields&rdquo; in Chapter&nbsp;9</EXTREF>
 of the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE> for guidelines on using text fields in your application.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="43041">The Mixed-Model Programming Widgets</TITLE><PARAGRAPH>Silicon Graphics provides two sets of mixed-model programming widgets: one set for use with OpenGL and one set for use with IRIS GL. <INDEXTARGET ID="04.Widgets9"><!-- POSTPROCESSDATA: 04.Widgets9|mixed-model programming widgetsprogramming:mixed model widgetswidgets:programming mixed-modelwidgets:OpenGL --></PARAGRAPH>
<PARAGRAPH>A mixed-model program, briefly, is an X program that creates one or more subwindows that use OpenGL or IRIS GL for rendering. Such a program uses Xlib or Xt calls for windowing, event handling, color maps, fonts, and so on. A &ldquo;pure&rdquo; IRIS GL application, on the other hand, uses IRIS GL calls for windowing, event handling, color maps, and fonts. (For a more detailed discussion of mixed-model programming, refer to the <DOCTITLE>OpenGL Porting Guide</DOCTITLE>.) </PARAGRAPH>
<PARAGRAPH>If you plan to port your IRIS GL application to OpenGL, a good first step is to port it to mixed-model. The switch to OpenGL is then much easier. The IRIS GL mixed-model widgets make it much easier to port pure IRIS GL applications to mixed-model. </PARAGRAPH>
<PARAGRAPH>If you're writing a new application, just start with OpenGL and the OpenGL versions of the mixed-model widgets (or use Open Inventor instead of OpenGL&mdash;Open Inventor handles all this for you).</PARAGRAPH>
<PARAGRAPH>The mixed-model widgets are:</PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>IRIS GL</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="145"><PARAGRAPH>OpenGL</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>GlxDraw</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="145"><PARAGRAPH>GLwDrawingArea</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>GlxMDraw</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="145"><PARAGRAPH>GLwMDrawingArea</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The GlxDraw and GLwDrawingArea widgets are suitable for use with any widget set. The GlxMDraw and GLwMDrawingArea widgets are designed especially for use with IRIS IM.</PARAGRAPH>
<PARAGRAPH>This manual does not tell you how to create a mixed-model program. For instructions on mixed-model programming, refer to the <DOCTITLE>OpenGL Porting Guide</DOCTITLE>. (The <DOCTITLE>OpenGL Porting Guide</DOCTITLE> contains mixed-model programming information that's relevant for both IRIS GL and OpenGL programmers.) </PARAGRAPH>
<PARAGRAPH>You can find examples of many mixed-model programs for both OpenGL and IRIS GL in the <FILENAME>4Dgifts</FILENAME> directories. If you have trouble finding the relevant directories, refer to the <FILENAME>README</FILENAME> file in <FILENAME>/usr/people/4Dgifts</FILENAME>. This README file explains the contents and organization of the 4Dgifts directories.</PARAGRAPH>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="69317">The SGI Enhanced Widgets</TITLE><PARAGRAPH>Silicon Graphics provides these new widgets: </PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="95600" TYPE="TITLE">&ldquo;The Color Chooser Widget&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="48293" TYPE="TITLE">&ldquo;The Dial Widget&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="66571" TYPE="TITLE">&ldquo;The Drop Pocket Widget&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="81745" TYPE="TITLE">&ldquo;The Finder Widget&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="30541" TYPE="TITLE">&ldquo;The Graph Widget&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="22284" TYPE="TITLE">&ldquo;The Grid Widget&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="37790" TYPE="TITLE">&ldquo;The Springbox Widget&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="34855" TYPE="TITLE">&ldquo;The Thumbwheel Widget&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>For guidelines on when to use the different widgets (for example, when to use a Thumbwheel or a Dial) refer to the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE>.</PARAGRAPH>
<PARAGRAPH>This section describes each important new IRIS IM widget. It doesn't discuss new widgets that are part of composite widgets, unless they are generally useful.<INDEXTARGET ID="04.Widgets10"><!-- POSTPROCESSDATA: 04.Widgets10|widgets:<ITALICS>SgColorChooser</ITALICS>colors:and widgetscolors:and valuescolors:and huescolors:and saturationcolors:RGBcolors:HSVRGB colorsHSV colorscolors --></PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="95600">The Color Chooser Widget</TITLE><PARAGRAPH>The ColorChooser widget (<INDEXTARGET ID="04.Widgets11"><!-- POSTPROCESSDATA: 04.Widgets11|Color Chooserwidgets:ColorChooserColor Chooser:widget --><BOLD>SgColorChooser</BOLD>) allows users to select colors in RGB or HSV color spaces. <XREF IDREF="84728" TYPE="GRAPHIC">Figure&nbsp;4-2</XREF>&space;shows the ColorChooser's default configuration.<INDEXTARGET ID="04.Widgets12"><!-- POSTPROCESSDATA: 04.Widgets12|widgets:ColorChooser. <ITALICS>See also</ITALICS> colorscolors:<ITALICS>See also</ITALICS> widgets --></PARAGRAPH>
<!-- RASTERCONVERT: 04.Widgets.cgm4 -->
<PARAGRAPH><FIGURE><GRAPHIC FILE="04.Widgets-4.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="4-2"><PREFIX>Figure 4-2 </PREFIX><XREFTARGET ID="84728">The Color Chooser Widget</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>The ColorChooser includes these components:<INDEXTARGET ID="04.Widgets13"><!-- POSTPROCESSDATA: 04.Widgets13|Color Chooser:components --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Menus for setting options and sliders for the color chooser.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A color hexagon that provides visual selection of the hue and saturation components of a color in an HSV color space.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Color sliders for each of the hue, saturation, value, red, green, and blue color components. To make the color sliders visible, the user can select items from the Sliders menu. (<XREF IDREF="42743" TYPE="GRAPHIC">Figure&nbsp;4-3</XREF> shows the ColorChooser with all the sliders visible.) You can also display the color sliders programmatically. Text fields show the exact value of each current color component and allow users to set these values numerically.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Two color swatches: one for showing the current selected color and one for enabling the user to store a second color for reference.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Three or four buttons. The default button labels are <BUTTON>OK</BUTTON>, <BUTTON>Cancel</BUTTON>, <BUTTON>Help</BUTTON>, and <BUTTON>Apply</BUTTON>. If the parent of the ColorChooser widget is a DialogShell, then the <BUTTON>Apply</BUTTON> button is managed; otherwise it is unmanaged.</PARAGRAPH>
<!-- RASTERCONVERT: 04.Widgets.cgm6 -->
<PARAGRAPH><FIGURE><GRAPHIC FILE="04.Widgets-6.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="4-3"><PREFIX>Figure 4-3 </PREFIX><XREFTARGET ID="42743">The Color Chooser Widget With HSV and RGB Sliders</CAPTION>
</FIGURE>
</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Users can select a color by manipulating the color hexagon and any of the six sliders, or by changing the values in any of the text fields.</PARAGRAPH>
<PARAGRAPH>You must include the header file <FILENAME>&lt;Sgm/ColorC.h></FILENAME> in any source file that uses a ColorChooser widget.</PARAGRAPH>
<PARAGRAPH>For more detailed information about the ColorChooser widget, refer to the <REFPAGE>SgColorChooser(3X)</REFPAGE> reference page. For an example program using the ColorChooser widget, see <XREF IDREF="83520" TYPE="TITLE">&ldquo;Example Program for Color Chooser&rdquo;</XREF>. You can also examine, compile, and experiment with the <COMMAND>colorc</COMMAND> demonstration program in the directory <FILENAME>/usr/src/X11/motif/Sgm/colorc</FILENAME>. See <EXTREF IDREF="84245" BOOK="UI_Glines" FILE="" HDG="84245" INFO="">&ldquo;A Specific Standard Support Window: The IRIX Interactive Desktop Color Chooser&rdquo; in Chapter&nbsp;6</EXTREF>
 of the IRIX Interactive Desktop for guidelines on using the ColorChooser widget in your application.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Controlling the Color Chooser Interface</TITLE><PARAGRAPH>By default, the ColorChooser widget uses GL's Gouraud shading to display the colors in the hexagon and sliders. You can force the ColorChooser widget not to use GL by setting the value of the <INDEXTARGET ID="04.Widgets14"><!-- POSTPROCESSDATA: 04.Widgets14|Color Chooser:interface --><BOLD>SgNuseGl</BOLD> resource to FALSE. When <BOLD>SgNuseGl</BOLD> is FALSE, the ColorChooser widget uses only X function calls. In this case, it does not draw a color hexagon and it uses XmScale widgets instead of the special color sliders.</PARAGRAPH>
<PARAGRAPH>When using GL, the ColorChooser normally shades the color hexagon and color sliders so that each point is a true representation of the color that would be selected if the user were to move the hexagon pointer or color slider to that point. However, if the value of the <INDEXTARGET ID="04.Widgets15"><!-- POSTPROCESSDATA: 04.Widgets15|colors:RGBRGB colorssliders:color --><BOLD>SgNwysiwyg</BOLD> resource is FALSE then the ColorChooser always displays the hexagon colors with a Value (intensity) of 1 (maximum intensity), and the RGB sliders with a color range of black to the maximum RGB color component value.</PARAGRAPH>
<PARAGRAPH>For example, if the current selected color RGB value is (100,&nbsp;200,&nbsp;50), then the Red color slider displays the colors (0,&nbsp;200,&nbsp;50) through (255,&nbsp;200,&nbsp;50) if <BOLD>SgNwysiwyg</BOLD> is TRUE, and (0,&nbsp;0,&nbsp;0) through (233,&nbsp;0,&nbsp;0) if <BOLD>SgNwysiwyg</BOLD> is FALSE. (Note that the user can also toggle the value of <BOLD>SgNwysiwyg</BOLD> by selecting the &ldquo;WYSIWYG&rdquo; option from the ColorChooser's Options menu.)</PARAGRAPH>
<PARAGRAPH>The <BOLD>SgNshowSliders</BOLD> resource determines which of the color sliders are visible. Possible values are:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>SgValue</HANGITEM>
<HANGBODY><PARAGRAPH>Show only the slider for the color Value (the default)</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>SgRGB_and_Value</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Show the Value and RGB sliders</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>SgRGB_and_HSV</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Show all six sliders, the HSV and RGB sliders</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>The default labels (in the C locale) for the ColorChooser buttons are &ldquo;OK,&rdquo; &ldquo;Apply,&rdquo; &ldquo;Cancel,&rdquo; and &ldquo;Help.&rdquo; You can change these by setting the values of <BOLD>SgNokLabelString</BOLD>, <BOLD>SgNapplyLabelString</BOLD>, <BOLD>SgNcancelLabelString</BOLD>, and <BOLD>SgNhelpLabelString</BOLD> respectively.</PARAGRAPH>
<PARAGRAPH>You can add additional children to the ColorChooser after creation&mdash;they're laid out in the following manner:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The first child is used as a work area. The work area is placed just below the menu bar. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Buttons&mdash;All <BOLD>XmPushButton</BOLD> widgets or gadgets, and their subclasses are placed after the <BUTTON>OK</BUTTON> button, in the order of their creation.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The layout of additional children that are not in the above categories is undefined.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Getting and Setting the Color Chooser's Colors</TITLE><PARAGRAPH>In ColorChooser callback functions, the RGB color values are provided as the <INDEXTARGET ID="04.Widgets16"><!-- POSTPROCESSDATA: 04.Widgets16|colors:get and setcolors:programming --><VARIABLE>r</VARIABLE>, <VARIABLE>g</VARIABLE>, and <VARIABLE>b</VARIABLE> parameters of the SgColorChooserCallbackStruct structure passed to the functions. <XREF IDREF="51289" TYPE="TITLE">&ldquo;Handling User Interaction With the Color Chooser&rdquo;</XREF> describes the ColorChooser callbacks.</PARAGRAPH>
<PARAGRAPH>ColorChooser also provides several convenience routines for getting and setting both the current color values and setting the stored color value.</PARAGRAPH>
<PARAGRAPH><FUNCTION>SgColorChooserSetColor()</FUNCTION> sets both the current and the stored color values to the same color:</PARAGRAPH>
<CODE>
void SgColorChooserSetColor(Widget <VARIABLE>w</VARIABLE>, short <VARIABLE>r</VARIABLE>, short <VARIABLE>g</VARIABLE>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short <VARIABLE>b</VARIABLE>);
</CODE>
<PARAGRAPH><FUNCTION>SgColorChooserGetColor()</FUNCTION> retrieves the current color values:</PARAGRAPH>
<CODE>
void SgColorChooserGetColor(Widget <VARIABLE>w</VARIABLE>, short *<VARIABLE>r</VARIABLE>, short *<VARIABLE>g</VARIABLE>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short *<VARIABLE>b</VARIABLE>);
</CODE>
<PARAGRAPH><FUNCTION>SgColorChooserSetCurrentColor()</FUNCTION> sets the current color but not the stored color:</PARAGRAPH>
<CODE>
void SgColorChooserSetCurrentColor(Widget <VARIABLE>w</VARIABLE>, short <VARIABLE>r</VARIABLE>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short <VARIABLE>g</VARIABLE>, short <VARIABLE>b</VARIABLE>);
</CODE>
<PARAGRAPH><FUNCTION>SgColorChooserSetStoredColor()</FUNCTION> sets the stored color but not the current color:</PARAGRAPH>
<CODE>
void SgColorChooserSetStoredColor(Widget <VARIABLE>w</VARIABLE>, short <VARIABLE>r</VARIABLE>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short <VARIABLE>g</VARIABLE>, short <VARIABLE>b</VARIABLE>);
</CODE>
<PARAGRAPH>For each function, <VARIABLE>w</VARIABLE> is the ColorChooser widget and <VARIABLE>r</VARIABLE>, <VARIABLE>g</VARIABLE>, and <VARIABLE>b</VARIABLE> are the red, green, and blue values, respectively.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="51289">Handling User Interaction With the Color Chooser</TITLE><PARAGRAPH>The ColorChooser widget defines the following callback resources:<INDEXTARGET ID="04.Widgets17"><!-- POSTPROCESSDATA: 04.Widgets17|Color Chooser:user interactionColor Chooser:callback resourcescallback:Color Chooser --></PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><BOLD>SgNapplyCallback</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Invoked when the user activates the <BUTTON>Apply</BUTTON> button. The callback reason is SgCR_APPLY.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>SgNcancelCallback</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Invoked when the user activates the <BUTTON>Cancel</BUTTON> button. The callback reason is SgCR_CANCEL.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>SgNokCallback</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Invoked when the user activates the <BUTTON>OK</BUTTON> button. The callback reason is SgCR_OK.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>SgNvalueChangedCallback</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Invoked when the user selects a color. The callback reason is XmCR_VALUE_CHANGED. A color is selected when the user changes the value of a color component with the color hexagon, one of the color sliders, or one of the color components text widgets.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>SgNdragCallback</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Specifies the list of callbacks called when the user drags the mouse over the color hexagon or one of the color sliders to select a color. The callback reason is XmCR_DRAG.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>A pointer to a SgColorChooserCallbackStruct structure is passed to each ColorChooser callback function:</PARAGRAPH>
<CODE>
typedef struct {
&nbsp;&nbsp;&nbsp;&nbsp;int <VARIABLE>reason</VARIABLE>;
&nbsp;&nbsp;&nbsp;&nbsp;XEvent *<VARIABLE>event</VARIABLE>;
&nbsp;&nbsp;&nbsp;&nbsp;short <VARIABLE>r</VARIABLE>, <VARIABLE>g</VARIABLE>, <VARIABLE>b</VARIABLE>;
} SgColorChooserCallbackStruct;
</CODE>
<HANGLIST><HANGPAIR><HANGITEM><VARIABLE>reason</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>Indicates why the callback was invoked.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>event</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>Points to the XEvent that triggered the callback.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>r</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>Indicates the red color component of the currently selected color.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>g</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>Indicates the green color component of the currently selected color.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>b</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>Indicates the blue color component of the currently selected color.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="48293">The Dial Widget <INDEXTARGET ID="04.Widgets18"><!-- POSTPROCESSDATA: 04.Widgets18|widgets:knob --></TITLE><PARAGRAPH>The Dial widget (<INDEXTARGET ID="04.Widgets19"><!-- POSTPROCESSDATA: 04.Widgets19|widgets:DialDial widgetpointer widget. <ITALICS>See</ITALICS> Dial widgetknob widget. <ITALICS>See</ITALICS> Dial widget --><BOLD>SgDial</BOLD>), shown in <XREF IDREF="23968" TYPE="GRAPHIC">Figure&nbsp;4-4</XREF>, is a new widget that allows users to input or modify a value from within a range of values. <XREF IDREF="23968" TYPE="GRAPHIC">Figure&nbsp;4-4</XREF> shows two forms of the Dial widget, one with the input control in the shape of a knob and the other in the shape of a pointer. The user can modify the Dial's value by spinning the knob or pointer. The Dial is usually surrounded by tick marks (marked divisions around the perimeter of the Dial).</PARAGRAPH>
<!-- RASTERCONVERT: 04.Widgets.cgm2 -->
<PARAGRAPH><FIGURE><GRAPHIC FILE="04.Widgets-2.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="4-4"><PREFIX>Figure 4-4 </PREFIX><XREFTARGET ID="23968">The Dial Widget in Knob and Pointer Form</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>You must include the header file <FILENAME>&lt;Sgm/Dial.h></FILENAME> in any source file that uses a Dial widget.</PARAGRAPH>
<PARAGRAPH>For more detailed information about the Dial widget, refer to the <REFPAGE>SgDial(3X)</REFPAGE> reference page. For an example program using the Dial widget, see <XREF IDREF="74701" TYPE="TITLE">&ldquo;Example Program for Dial&rdquo;</XREF>. You can also examine, compile, and experiment with the <COMMAND>dial</COMMAND> demonstration program in the directory <FILENAME>/usr/src/X11/motif/Sgm/dial</FILENAME>. See <EXTREF IDREF="97285" BOOK="UI_Glines" FILE="" HDG="97285" INFO="">&ldquo;Dials&rdquo; in Chapter&nbsp;9</EXTREF>
 of the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE> for guidelines on using the Dial widget in an application.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Controlling the Dial Interface</TITLE><PARAGRAPH>You control the display characteristics of a Dial through widget resources.<INDEXTARGET ID="04.Widgets20"><!-- POSTPROCESSDATA: 04.Widgets20|Dial widget:interfaceDial widget:characteristics --></PARAGRAPH>
<PARAGRAPH>The <INDEXTARGET ID="04.Widgets21"><!-- POSTPROCESSDATA: 04.Widgets21|Dial widget:appearance --><BOLD>SgNdialVisual</BOLD> resource determines whether the Dial uses a knob or a pointer. The default value, SgKNOB, specifies a knob and SgPOINTER specifies a pointer. If you use a pointer, you can also specify the color of the small &ldquo;indicator&rdquo; at the center of the pointer using the <BOLD>SgNindicatorColor</BOLD> resource; the default color is red.</PARAGRAPH>
<PARAGRAPH>Specify the position of the lowest value on the Dial with the <BOLD>SgNstartAngle</BOLD> resource. The value, which must be between 0 and 360 inclusive, specifies the number of degrees clockwise from the top of the Dial. A default value of 0 corresponds to the top of the Dial.</PARAGRAPH>
<PARAGRAPH>The <BOLD>SgNangleRange</BOLD> resource determines the range of the Dial in degrees. The value, which must be between 0 and 360 inclusive, specifies the number of degrees clockwise from the start angle of the Dial. The default value of 360 allows the Dial to rotate completely.</PARAGRAPH>
<PARAGRAPH>The Dial widget displays evenly spaced &ldquo;tick marks&rdquo; along the perimeter of the Dial's angle range. You control the number of tick marks with the <BOLD>SgNdialMarkers</BOLD> resource; the default number is 16. The length of the tick marks in pixels is determined by the <BOLD>SgNmarkerLength</BOLD> resource; the default length is 8 pixels. The <BOLD>SgNdialForeground</BOLD> resource determines the color of the tick marks; the default is red.</PARAGRAPH>
<PARAGRAPH>The resources <BOLD>XmNminimum</BOLD> and <BOLD>XmNmaximum</BOLD> determine the minimum and maximum values of the Dial. The Dial takes on the minimum value at the position specified by <BOLD>SgNstartAngle</BOLD> and takes on the maximum value at the position <BOLD>SgNangleRange</BOLD> degrees clockwise from <BOLD>SgNstartAngle</BOLD>. The value of <BOLD>XmNmaximum</BOLD> must be greater than or equal to the value of <BOLD>XmNminimum</BOLD>. The default value of <BOLD>XmNminimum</BOLD> is 0 and the default value of <BOLD>XmNmaximum</BOLD> is 360.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Getting and Setting the Dial's Value</TITLE><PARAGRAPH>The <INDEXTARGET ID="04.Widgets22"><!-- POSTPROCESSDATA: 04.Widgets22|Dial widget:callback functionDial widget:valuesDial widget:getting and setting values --><BOLD>XmNvalue</BOLD> resource, which must be a value between <BOLD>XmNminimum</BOLD> and <BOLD>XmNmaximum</BOLD> inclusive, contains the current position of the Dial. You can set or get the value of a Dial widget at any time by respectively setting or getting its <BOLD>XmNvalue</BOLD> resource.</PARAGRAPH>
<PARAGRAPH>In Dial callback functions, the Dial value is provided as the <VARIABLE>position</VARIABLE> parameter of the SgDialCallbackStruct structure passed to the functions. <XREF IDREF="68199" TYPE="TITLE">&ldquo;Detecting Changes in the Dial's Value&rdquo;</XREF> describes the Dial callbacks.</PARAGRAPH>
<PARAGRAPH>Dial also provides a convenience routine, <FUNCTION>SgDialSetValue()</FUNCTION>, for setting the value of <BOLD>XmNvalue</BOLD>:</PARAGRAPH>
<EXAMPLE>
void SgDialSetValue(Widget <VARIABLE>w</VARIABLE>, int <VARIABLE>value</VARIABLE>);
</EXAMPLE>
<PARAGRAPH><VARIABLE>w</VARIABLE> is the Dial widget whose value you want to set and <VARIABLE>value</VARIABLE> is the new value.</PARAGRAPH>
<PARAGRAPH>You can get the current value of a Dial widget at any time by retrieving the value of its <BOLD>XmNvalue</BOLD> resource. Dial also provides a convenience routine, <FUNCTION>SgDialGetValue()</FUNCTION>, for getting the value of <BOLD>XmNvalue</BOLD>:</PARAGRAPH>
<EXAMPLE>
void SgDialGetValue(Widget <VARIABLE>w</VARIABLE>, int *<VARIABLE>value</VARIABLE>);
</EXAMPLE>
<PARAGRAPH><VARIABLE>w</VARIABLE> is the Dial widget whose value you want to get. Upon returning, <VARIABLE>value</VARIABLE> contains the Dial's value.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="68199">Detecting Changes in the Dial's Value</TITLE><PARAGRAPH>The Dial widget defines two callback list resources, <INDEXTARGET ID="04.Widgets23"><!-- POSTPROCESSDATA: 04.Widgets23|Dial widget:detecting changes in valuewidgets:Dial. <ITALICS>See also</ITALICS> Dial widget --><BOLD>XmNvalueChangedCallback</BOLD> and <BOLD>XmNdragCallback</BOLD>. A Dial widget invokes <BOLD>XmNvalueChangedCallback</BOLD> whenever its value changes either programmatically (for example, by calling <FUNCTION>SgDialSetValue()</FUNCTION>) or through user interaction. A Dial widget invokes <BOLD>XmNdragCallback</BOLD> whenever the user clicks and drags, or &ldquo;spins,&rdquo; the Dial's knob or pointer.</PARAGRAPH>
<PARAGRAPH>A pointer to a SgDialCallbackStruct structure is passed to each Dial callback function:</PARAGRAPH>
<CODE>
typedef struct {
&nbsp;&nbsp;&nbsp;&nbsp;int <VARIABLE>reason</VARIABLE>;
&nbsp;&nbsp;&nbsp;&nbsp;XEvent *<VARIABLE>event</VARIABLE>;
&nbsp;&nbsp;&nbsp;&nbsp;int <VARIABLE>position</VARIABLE>;
} SgDialCallbackStruct;
</CODE>
<PARAGRAPH>The SgDialCallbackStruct parameters are:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><VARIABLE>reason</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>The reason the callback was invoked. This value is XmCR_VALUE_CHANGED in the event of a <BOLD>XmNvalueChangedCallback</BOLD> and XmCR_DRAG in the event of a <BOLD>XmNdragCallback</BOLD>.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>event</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>A pointer to the XEvent that triggered the callback</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>position</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>The new Dial value </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="34855">The Thumbwheel Widget</TITLE><PARAGRAPH>The ThumbWheel widget (<INDEXTARGET ID="04.Widgets24"><!-- POSTPROCESSDATA: 04.Widgets24|widgets:ThumbWheelThumbWheel widgetwheel widget. <ITALICS>See</ITALICS> ThumbWheel widget --><BOLD>SgThumbWheel</BOLD>), shown in <XREF IDREF="15819" TYPE="GRAPHIC">Figure&nbsp;4-5</XREF>, is a new widget that allows users to input or modify a value, either from within a range of values or from an unbounded (infinite) range.<INDEXTARGET ID="04.Widgets25"><!-- POSTPROCESSDATA: 04.Widgets25|widgets:ThumbWheel. <ITALICS>See also</ITALICS> ThumbWheel widget --></PARAGRAPH>
<!-- RASTERCONVERT: 04.Widgets.cgm5 -->
<PARAGRAPH><FIGURE><GRAPHIC FILE="04.Widgets-5.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="4-5"><PREFIX>Figure 4-5 </PREFIX><XREFTARGET ID="15819">The Thumbwheel Widget</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>A ThumbWheel has an elongated rectangular region within which a wheel graphic is displayed. Users can modify the ThumbWheel's value by spinning the wheel. A ThumbWheel can also include a home button, located outside the wheel region. This button allows users to set the ThumbWheel's value to a known position.</PARAGRAPH>
<PARAGRAPH>You must include the header file <FILENAME>&lt;Sgm/ThumbWheel.h></FILENAME> in any source file that uses a Thumbwheel widget.</PARAGRAPH>
<PARAGRAPH>For detailed information on the ThumbWheel widget, refer to the<REFPAGE>&space;SgThumbWheel(3X)</REFPAGE> reference page. For an example program using the ThumbWheel widget, see <XREF IDREF="30790" TYPE="TITLE">&ldquo;Example Program for ThumbWheel&rdquo;</XREF>. You can also examine, compile, and experiment with the <FILENAME>thumbwheel</FILENAME> demonstration program in the directory <FILENAME>/usr/src/X11/motif/Sgm/thumbwheel</FILENAME>. See<EXTREF IDREF="20150" BOOK="UI_Glines" FILE="" HDG="20150" INFO=""> &ldquo;Thumbwheels&rdquo; in Chapter&nbsp;9</EXTREF>
 of the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE> for guidelines on using the ThumbWheel widget in your application.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Controlling the ThumbWheel Interface</TITLE><PARAGRAPH>You control the display characteristics of a ThumbWheel through widget resources.<INDEXTARGET ID="04.Widgets26"><!-- POSTPROCESSDATA: 04.Widgets26|ThumbWheel widget:interfaceThumbWheel widget:interface values --></PARAGRAPH>
<PARAGRAPH>The resources <BOLD>XmNminimum</BOLD> and <BOLD>XmNmaximum</BOLD> determine the minimum and maximum values of the ThumbWheel. Setting <BOLD>XmNmaximum</BOLD> equal to <BOLD>XmNminimum</BOLD> indicates an infinite range.</PARAGRAPH>
<PARAGRAPH>The default value of <BOLD>XmNminimum</BOLD> is 0 and the default value of <BOLD>XmNmaximum</BOLD> is 100.</PARAGRAPH>
<PARAGRAPH>The <BOLD>SgNangleRange</BOLD> resource specifies the angular range, in degrees, through which the ThumbWheel is allowed to rotate. The default of 150 represents roughly the visible amount of the wheel. Thus clicking at one end of the wheel and dragging the mouse to the other end would give roughly the entire range from <BOLD>XmNminimum</BOLD> to <BOLD>XmNmaximum</BOLD>.</PARAGRAPH>
<PARAGRAPH>In conjunction with <BOLD>XmNmaximum</BOLD> and <BOLD>XmNminimum</BOLD>, the <BOLD>SgNangleRange</BOLD> resource controls the fineness or coarseness of the wheel control when it is not infinite. If this value is 0, the ThumbWheel has an infinite range. If the range of the ThumbWheel is infinite, you can use the <BOLD>SgNunitsPerRotation</BOLD> resource to specify the change in the ThumbWheel's value for each full rotation of the wheel.</PARAGRAPH>
<PARAGRAPH>If the value of <BOLD>SgNshowHomeButton</BOLD> is TRUE, the default, the ThumbWheel displays a home button by the slider. The user can click on the home button to set the value of the ThumbWheel to a known value, which is specified by the <BOLD>SgNhomePosition</BOLD> resource. The default value of <BOLD>SgNhomePosition</BOLD> is 50.</PARAGRAPH>
<PARAGRAPH>The <BOLD>XmNorientation</BOLD> resource determines whether the orientation of the ThumbWheel is vertical, indicated by a value of XmVERTICAL, or horizontal, indicated by a value of XmHORIZONTAL. The default value is XmVERTICAL.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Getting and Setting the ThumbWheel's Value</TITLE><PARAGRAPH>The <INDEXTARGET ID="04.Widgets27"><!-- POSTPROCESSDATA: 04.Widgets27|ThumbWheel widget:valuesThumbWheel widget:values --><BOLD>XmNvalue</BOLD> resource contains the current position of the ThumbWheel.<BOLD>&space;XmNvalue</BOLD> must be a value between <BOLD>XmNminimum</BOLD> and <BOLD>XmNmaximum</BOLD> if the ThumbWheel is not &ldquo;infinite.&rdquo; You can set or get the value of a ThumbWheel widget at any time by respectively setting or getting its <BOLD>XmNvalue</BOLD> resource.</PARAGRAPH>
<PARAGRAPH>In ThumbWheel callback functions, the ThumbWheel value is provided as the <VARIABLE>value</VARIABLE> parameter of the SgThumbWheelCallbackStruct structure passed to the functions. <XREF IDREF="27959" TYPE="TITLE">&ldquo;Detecting Changes in the ThumbWheel's Value&rdquo;</XREF> describes the ThumbWheel callbacks.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="27959">Detecting Changes in the ThumbWheel's Value</TITLE><PARAGRAPH>The ThumbWheel widget defines two callback list resources, <INDEXTARGET ID="04.Widgets28"><!-- POSTPROCESSDATA: 04.Widgets28|ThumbWheel widget:detecting changesThumbWheel widget:callback structure --><BOLD>XmNvalueChangedCallback</BOLD> and <BOLD>XmNdragCallback</BOLD>. A ThumbWheel widget invokes <BOLD>XmNvalueChangedCallback</BOLD> whenever its value changes either programmatically (that is, by setting the value of <BOLD>XmNvalue</BOLD>) or through user interaction. A ThumbWheel widget invokes <BOLD>XmNdragCallback</BOLD> whenever the user clicks and drags, or &ldquo;spins,&rdquo; the ThumbWheel's wheel.</PARAGRAPH>
<PARAGRAPH>A pointer to a SgThumbWheelCallbackStruct structure is passed to each ThumbWheel callback function:</PARAGRAPH>
<CODE>
typedef struct { int reason;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XEvent * event;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int value;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} SgThumbWheelCallbackStruct;
</CODE>
<PARAGRAPH>The SgThumbWheelCallbackStruct parameters are:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><VARIABLE>reason</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>The reason the callback was invoked. This value is XmCR_VALUE_CHANGED in the event of a <BOLD>XmNvalueChangedCallback</BOLD> and XmCR_DRAG in the event of a <BOLD>XmNdragCallback</BOLD>.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>event</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>A pointer to the XEvent that triggered the callback.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><VARIABLE>position</VARIABLE></HANGITEM>
<HANGBODY><PARAGRAPH>The new ThumbWheel value. </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="66571">The Drop Pocket Widget</TITLE><PARAGRAPH>The Drop Pocket widget (<INDEXTARGET ID="04.Widgets29"><!-- POSTPROCESSDATA: 04.Widgets29|widgets:Drop PocketDrop Pocket:widget --><BOLD>SgDropPocket</BOLD>), shown in <XREF IDREF="43273" TYPE="GRAPHIC">Figure&nbsp;4-6</XREF>, receives and displays Desktop icons.</PARAGRAPH>
<!-- RASTERCONVERT: 04.Widgets.cgm -->
<PARAGRAPH><FIGURE>&space;<GRAPHIC FILE="04.Widgets-1.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="4-6"><PREFIX>Figure 4-6 </PREFIX><XREFTARGET ID="43273">The Drop Pocket Widget (on left) As Part of the Finder Widget</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>When users drop Desktop file icons onto the Drop Pocket, the Drop Pocket determines the name of the icon and returns information describing the icon to the application in the callback. </PARAGRAPH>
<PARAGRAPH>When users drag an acceptable icon over the Drop Pocket, the Drop Pocket background changes color and the Drop Pocket displays the dropped icon. If the type of a file is not known, or if the file doesn't exist (for example, if the user is specifying a new file), the Drop Pocket displays the icon for unknown file types (this icon looks like a round balloon).</PARAGRAPH>
<PARAGRAPH>For more information on the Drop Pocket widget, refer to the <REFPAGE>SgDropPocket(3X)</REFPAGE> reference page. You can find example code in <FILENAME>/usr/src/X11/motif/Sgm/dropPocket</FILENAME> directory. For an example program using the Drop Pocket widget, see <XREF IDREF="84471" TYPE="TITLE">&ldquo;Example Program for Drop Pocket&rdquo;</XREF>.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Reference Page Text</TITLE><PARAGRAPH>SYNOPSIS #include &lt;Sgm/DropPocket.h></PARAGRAPH>
<PARAGRAPH>New Resources</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><BOLD>SgNDropPocketActivePixel</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Specifies the color for the background of the DropPocket when an icon that can be dropped is above the DropPocket.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>SgNiconDataBasePath</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Specifies the location of the icon database. The default value is <FILENAME>/usr/lib/filetype/workspace.otr</FILENAME>. Setting this resource to a filename that is not a legal icon database will cause serious problems for the DropPocket.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>SgNname</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>Specifies the compound string that is the name of the current icon. By setting this resource, the application can control the initial icon that appears in the DropPocket. If this resource is NULL, the DropPocket will appear empty. Refer to XmString(3X) for more information on the creation and structure of compound strings.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>Callback Information</PARAGRAPH>
<PARAGRAPH>The Callback structure is SgDropPocketCallbackStruct. A pointer to the following structure is passed to each callback:</PARAGRAPH>
<CODE>
typedef struct { int reason;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XEvent * event;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Window window;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmString iconName;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char * iconData;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} SgDropPocketCallbackStruct;
</CODE>
<HANGLIST><HANGPAIR><HANGITEM>reason</HANGITEM>
<HANGBODY><PARAGRAPH>Indicates why the callback was invoked. The constant SgCR_ICON_CHANGE is the reason associated with callbacks generated by a successful icon drop on the DropPocket.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>event</HANGITEM>
<HANGBODY><PARAGRAPH>Points to the XEvent that triggered the callback</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>window</HANGITEM>
<HANGBODY><PARAGRAPH>Specifies the window of the DropPocket.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>iconName</HANGITEM>
<HANGBODY><PARAGRAPH>Specifies the name of the icon. For icons representing files, this is the file name. For other types of icons, the name may not completely specify the icon. For example a person icon may have the name jake, but the icon represents a person in /usr/lib/faces/jake.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>iconData</HANGITEM>
<HANGBODY><PARAGRAPH>The full string description of the icon. </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="81745">The Finder Widget</TITLE><PARAGRAPH>The Finder widget (<INDEXTARGET ID="04.Widgets30"><!-- POSTPROCESSDATA: 04.Widgets30|Finder widgetwidgets:Finder --><BOLD>SgFinder</BOLD>), shown in <XREF IDREF="58911" TYPE="GRAPHIC">Figure&nbsp;4-7</XREF>, is a new widget that accelerates text selection of long objects such as filenames. (A good way to experiment with a Finder widget is to select &ldquo;An Icon&rdquo; from the Find toolchest.)</PARAGRAPH>
<PARAGRAPH><FIGURE>&space;  <GRAPHIC FILE="finder.online.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="4-7"><PREFIX>Figure 4-7 </PREFIX><XREFTARGET ID="58911">The Finder Widget</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>The Finder widget is customizable for various applications (it's not just for looking at directories; see the <INDEXTARGET ID="04.Widgets31"><!-- POSTPROCESSDATA: 04.Widgets31|Finder widget:componentswidgets:Finder. <ITALICS>See also</ITALICS> Finder widget --><REFPAGE>SgFinder(3X)</REFPAGE> reference page for customization details). The Finder widget includes four components:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>Text field</HANGITEM>
<HANGBODY><PARAGRAPH>Displays the name of a file or directory. </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>Path navigation bar<INDEXTARGET ID="04.Widgets32"><!-- POSTPROCESSDATA: 04.Widgets32|path navigationnavigation:pathFinder widget:path navigation --></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Contains buttons representing each directory in the pathname. When the user clicks on a path bar button, the Finder sets the current directory to the directory listed underneath that button. The path bar is created with an <BOLD>SgZoomBar</BOLD>(3X) widget.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>Recycle button<INDEXTARGET ID="04.Widgets33"><!-- POSTPROCESSDATA: 04.Widgets33|recycle buttonbuttons:recycleFinder widget:recycle button --></HANGITEM>
<HANGBODY><PARAGRAPH>When users click on the Recycle button, the recycle list appears listing the directories that the user has selected during the current Finder session. Selecting an item from the recycle list changes the current directory to the selected directory. The recycle button is created with an <BOLD>SgDynaMenu</BOLD>(3X) widget.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>Drop pocket<INDEXTARGET ID="04.Widgets34"><!-- POSTPROCESSDATA: 04.Widgets34|Drop PocketFinder widget:Drop Pocket --></HANGITEM>
<HANGBODY><PARAGRAPH>Displays the Desktop file icon for the file listed in the text field. The user can drop Desktop file icons into the drop pocket to find the pathname for the file and drag icons out of the drop pocket and put them on the Desktop. The recycle button is created with an <BOLD>SgDropPocket</BOLD>(3X) widget.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>You must include the header file <FILENAME>&lt;Sgm/Finder.h></FILENAME> in any source file that uses a Finder widget.</PARAGRAPH>
<PARAGRAPH>For more detailed information on the Finder widget, refer to the <REFPAGE>SgFinder(3X)</REFPAGE>, <REFPAGE>SgDropPocket(3X)</REFPAGE>, and <REFPAGE>SgDynaMenu(3X)</REFPAGE> reference pages. For an example using the Finder widget, see <XREF IDREF="23162" TYPE="TITLE">&ldquo;Example Program for Finder&rdquo;</XREF>. You can also examine, compile, and experiment with the <FILENAME>finderTest</FILENAME> demonstration program in the directory <FILENAME>/usr/src/X11/motif/Sgm/finder</FILENAME>. See <EXTREF IDREF="43846" BOOK="UI_Glines" FILE="" HDG="43846" INFO="">&ldquo;File Finder&rdquo; in Chapter&nbsp;9</EXTREF>
 of the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE> for guidelines on using the Finder widget in your application.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Controlling the Finder Interface</TITLE><PARAGRAPH>If you don't need the drop pocket feature of the Finder widget, you can set the value of the resource <INDEXTARGET ID="04.Widgets35"><!-- POSTPROCESSDATA: 04.Widgets35|Finder widget:interfaceFinder widget:values --><BOLD>SgNuseDropPocket</BOLD> to FALSE when you create the widget. This bypasses the costs of setting up drag and drop and loading the file icon libraries. Note that you can't set this resource using <FUNCTION>XtSetValues()</FUNCTION>; if you don't originally create a Finder widget with a drop pocket, you can't add one afterwards.</PARAGRAPH>
<PARAGRAPH>Similarly, if you don't need the Recycle button, you can set the value of the resource <BOLD>SgNuseHistoryMenu</BOLD> to FALSE. Note that you can't set this resource using <FUNCTION>XtSetValues()</FUNCTION>; if you don't originally create a Finder widget with a Recycle button, you can't add one afterwards.</PARAGRAPH>
<PARAGRAPH>You can customize the appearance of the Recycle button by setting the value of the <INDEXTARGET ID="04.Widgets36"><!-- POSTPROCESSDATA: 04.Widgets36|recycle button:customizebuttons:recycle. <ITALICS>See also</ITALICS> recycle button --><BOLD>SgNhistoryPixmap</BOLD> resource to the pixmap you want to display.</PARAGRAPH>
<PARAGRAPH>By default, the Finder widget determines where to place the buttons on the path navigation bar by the location of the forward slash (/) character in the text field. You can specify a different separator character by providing it as the value of the <BOLD>SgNseparator</BOLD> resource. This feature is useful if you want to use the Finder widget to display something other than filenames.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Getting and Setting Finder Values</TITLE><PARAGRAPH>You can retrieve the current value of the Finder's text field with <INDEXTARGET ID="04.Widgets37"><!-- POSTPROCESSDATA: 04.Widgets37|Finder widget:values --><FUNCTION>SgFinderGetTextString()</FUNCTION>:</PARAGRAPH>
<EXAMPLE>
char *SgFinderGetTextString(Widget <VARIABLE>w</VARIABLE>);
</EXAMPLE>
<PARAGRAPH>You can set the value of the text field with <FUNCTION>SgFinderSetTextString()</FUNCTION>:</PARAGRAPH>
<EXAMPLE>
void SgFinderSetTextString(Widget <VARIABLE>w</VARIABLE>, char *<VARIABLE>value</VARIABLE>);
</EXAMPLE>
<PARAGRAPH>You can add an item to the &ldquo;history list&rdquo; of the Recycle button with <FUNCTION>SgFinderAddHistoryItem()</FUNCTION>:</PARAGRAPH>
<EXAMPLE>
void SgFinderAddHistoryItem(Widget <VARIABLE>w</VARIABLE>, char *<VARIABLE>str</VARIABLE>);
</EXAMPLE>
<PARAGRAPH>You can clear the Recycle button's history list with <FUNCTION>SgFinderClearHistory()</FUNCTION>:</PARAGRAPH>
<EXAMPLE>
void SgFinderClearHistory(Widget <VARIABLE>w</VARIABLE>);
</EXAMPLE>
<PARAGRAPH>You can access a widget component within a finder using <FUNCTION>SgFinderGetChild()</FUNCTION>:</PARAGRAPH>
<EXAMPLE>
Widget SgFinderGetChild(Widget <VARIABLE>w</VARIABLE>, int <VARIABLE>child</VARIABLE>);
</EXAMPLE>
<PARAGRAPH><VARIABLE>child</VARIABLE> specifies the component and can take any of the following values:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>SgFINDER_DROP_POCKET</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The drop pocket</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>SgFINDER_TEXT</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The text field</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>SgFINDER_ZOOM_BAR</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The path navigation bar</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>SgFINDER_HISTORY_MENUBAR</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;The Recycle button</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Handling User Interaction With the Finder</TITLE><PARAGRAPH>When the user clicks a button in the path navigation bar, the default action of the Finder is to set the current directory to the directory listed underneath that button. You can change this behavior by setting the <INDEXTARGET ID="04.Widgets38"><!-- POSTPROCESSDATA: 04.Widgets38|Finder widget:callbackFinder widget:user interactionuser interaction:Finder widget --><BOLD>SgNsetTextSectionFunc</BOLD> resource to the handler you want to use. The handler function must be of type SgSetTextFunc, which is defined in <FILENAME>&lt;Sg/Finder.h></FILENAME>:</PARAGRAPH>
<EXAMPLE>
typedef void (*SgSetTextFunc)(Widget finder, int section);
</EXAMPLE>
<PARAGRAPH>The first argument is the Finder widget and the second is an integer corresponding to the button pressed. Buttons are numbered sequentially from the left, starting with 0. You can perform whatever operations you want in this function, but typically you include a call to <FUNCTION>SgFinderSetTextString()</FUNCTION> to set the value of the text field after the user clicks a button.</PARAGRAPH>
<PARAGRAPH>Additionally, the Finder widget defines two callback list resources:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><BOLD>XmNactivateCallback</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Invoked when the user clicks a path navigation bar button, when the text field generates an activateCallback (for example, the user presses the <USERINPUT>&lt;Return></USERINPUT> key in the text field), or when you set the text string by calling <FUNCTION>SgFinderSetTextString()</FUNCTION>. A pointer to an XmAnyCallbackStruct structure is passed to each callback function. The reason sent by the callback is XmCR_ACTIVATE.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>XmNvalueChangedCallback</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Invoked when text is deleted from or inserted into the text field. A pointer to an XmAnyCallbackStruct structure is passed to each callback function. The reason sent by the callback is XmCR_VALUE_CHANGED. </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="30541">The Graph Widget</TITLE><PARAGRAPH>The Graph widget (<INDEXTARGET ID="04.Widgets39"><!-- POSTPROCESSDATA: 04.Widgets39|Graph widgetwidgets:Graph --><BOLD>SgGraph</BOLD>) allows you to display any group of widgets as a graph, with each widget representing a node. <XREF IDREF="43660" TYPE="GRAPHIC">Figure&nbsp;4-8</XREF> shows an example of a Graph widget.</PARAGRAPH>
<PARAGRAPH><FIGURE>&space;<GRAPHIC FILE="graph.online.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="4-8"><PREFIX>Figure 4-8 </PREFIX><XREFTARGET ID="43660">The Graph Widget</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>The arcs used to connect the nodes are instances of an Arc widget (<INDEXTARGET ID="04.Widgets40"><!-- POSTPROCESSDATA: 04.Widgets40|Arc widgetwidgets:Arc --><BOLD>SgArc</BOLD>), developed specifically for use with the Graph widget. </PARAGRAPH>
<PARAGRAPH>The Graph widget allows you to display any group of widgets as a graph, with each widget representing a node. The graph can be disconnected and can contain cycles. The arcs used to connect the nodes are instances of an Arc widget (<BOLD>SgArc</BOLD>), developed specifically for use with the Graph widget. Arcs may be undirected, directed, or bidirected. Note that the Graph widget does not understand the semantics of arc direction; in other words, for layout and editing purposes, an Arc will always have a parent and a child regardless of its direction.</PARAGRAPH>
<PARAGRAPH>The Graph widget has the ability to arrange all nodes either horizontally or vertically according to an internal layout algorithm, and supports an edit mode in which arcs and nodes may be interactively repositioned as well as created. There is also a read-only mode in which all events are passed directly to the children of the Graph widget. In edit mode, the Graph takes over all device events for editing commands.</PARAGRAPH>
<PARAGRAPH>The Graph is a complex widget, and a full discuss of its resources, utility functions, and capabilities is beyond the scope of this document. For detailed information about the Graph and Arc widgets, refer to the <REFPAGE>SgGraph(3X)</REFPAGE> and <REFPAGE>SgArc(3X)</REFPAGE> reference pages.</PARAGRAPH>
<PARAGRAPH>You must include the header file <FILENAME>&lt;Sgm/Graph.h></FILENAME> in any source file that uses a Graph widget. You must include the header files <FILENAME>&lt;Sgm/Graph.h></FILENAME> and <FILENAME>&lt;Sgm/Arc.h></FILENAME> in any source file that uses an Arc widget.&space;</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="37790">The Springbox Widget</TITLE><PARAGRAPH>The SpringBox widget (<INDEXTARGET ID="04.Widgets41"><!-- POSTPROCESSDATA: 04.Widgets41|Springbox widgetwidgets:Springbox --><BOLD>SgSpringBox</BOLD>) is a new container widget that arranges its children in a single row or column based on a set of spring constraints assigned to each child. You can use the SpringBox widget to create layouts similar to those supported by the <BOLD>XmForm</BOLD> widget, but the SpringBox widget is usually easier to set up.</PARAGRAPH>
<PARAGRAPH>The value of the SpringBox widget's <FUNCTION>XmNorientation</FUNCTION> resource determines its orientation. The default value, XmHORIZONTAL, specifies a horizontal SpringBox and the value XmVERTICAL specifies a vertical SpringBox.</PARAGRAPH>
<PARAGRAPH>To use the SpringBox, you set constraint resources on each child of the widget to specify the &ldquo;springiness&rdquo; for both the widget's size and position relative to its siblings.</PARAGRAPH>
<PARAGRAPH>You control the springiness of a widget's size by setting the values of its <FUNCTION>XmNverticalSpring</FUNCTION> and <FUNCTION>XmNhorizontalSpring</FUNCTION> resources. A value of zero means the child cannot be resized in that direction. For non-zero values, the values are compared to the values of other springs in the overall system to determine the proportional effects of any resizing. For example, a widget with a springiness of 200 would stretch twice as much as a widget with a springiness of 100. The default value of both resources is zero.</PARAGRAPH>
<PARAGRAPH>The values of the resources <FUNCTION>XmNleftSpring</FUNCTION>, <FUNCTION>XmNrightSpring</FUNCTION>, <FUNCTION>XmNtopSpring</FUNCTION>, and <FUNCTION>XmNbottomSpring</FUNCTION> control the springiness of a widget's position in relation to its neighboring boundaries. By default, the value of each of these springs is 50. A value of zero means that the SpringBox widget cannot add additional space adjacent to that part of a widget. Larger values are considered in relation to all other spring values in the system.</PARAGRAPH>
<PARAGRAPH>You must include the header file <FILENAME>&lt;Sgm/SpringBox.h></FILENAME> in any source file that uses a SpringBox widget. For more detailed information on the SpringBox widget, refer to the <REFPAGE>SgSpringBox(3X)</REFPAGE> reference page. </PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="22284">The Grid Widget</TITLE><PARAGRAPH>The Grid widget (<INDEXTARGET ID="04.Widgets42"><!-- POSTPROCESSDATA: 04.Widgets42|Grid widgetwidgets:Grid --><BOLD>SgGrid</BOLD>) is a new container widget that arranges its children in a two-dimensional grid of arbitrary size. You can separately designate each row and column of the grid as having a fixed size or as having some degree of stretchability. You can also resize each child in either or both directions, or force a child to a fixed size.</PARAGRAPH>
<PARAGRAPH>You must include the header file <FILENAME>&lt;Sgm/Grid.h></FILENAME> in any source file that uses a Grid widget. For detailed information on the Grid widget, refer to the <REFPAGE>SgGrid(3X)</REFPAGE> reference page.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Setting Grid Characteristics</TITLE><PARAGRAPH>You specify the number of rows and columns in a Grid by setting the values of its <INDEXTARGET ID="04.Widgets43"><!-- POSTPROCESSDATA: 04.Widgets43|Grid widget:characteristicswidgets:Grid. <ITALICS>See also</ITALICS> Grid widget --><BOLD>XmNnumRows</BOLD> and <BOLD>XmNnumColumns</BOLD> resources, respectively. The default value for each is 1. Note that you can set the size of a Grid only when you create it; you can't use <FUNCTION>XtSetValues()</FUNCTION> to change the number of rows or columns in a Grid.&space;<INDEXTARGET ID="04.Widgets44"><!-- POSTPROCESSDATA: 04.Widgets44|Grid widget:layout --></PARAGRAPH>
<PARAGRAPH>The <BOLD>XmNautoLayout</BOLD> resource determines the layout policy for a Grid. If its value is TRUE (the default), all rows and columns that have a non-zero resizability factor (described below) are sized according to the desired natural size of the widgets in that row or column.</PARAGRAPH>
<PARAGRAPH>If <BOLD>XmNautoLayout</BOLD> is FALSE, all widgets in resizable rows or columns are sized according to the resizability factor for that row or column. By default, the resizability factor is &ldquo;1&rdquo; for all rows and columns, which results in each cell in the grid having an equal size. You can change the resizability factor for a row or column by calling <FUNCTION>SgGridSetRowMargin()</FUNCTION> or <FUNCTION>SgGridSetColumnMargin()</FUNCTION> respectively:</PARAGRAPH>
<CODE>
SgGridSetRowResizability(Widget <VARIABLE>widget</VARIABLE>, int <VARIABLE>row</VARIABLE>, int <VARIABLE>factor</VARIABLE>);

SgGridSetColumnResizability(Widget <VARIABLE>widget</VARIABLE>, int <VARIABLE>column</VARIABLE>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int <VARIABLE>factor</VARIABLE>);
</CODE>
<PARAGRAPH><VARIABLE>widget</VARIABLE> is the Grid widget. The second argument specifies the row or column. Rows are numbered sequentially from the top starting at 0; columns are numbered sequentially from the left starting with 0. <VARIABLE>factor</VARIABLE> is the resizability factor for the row or column. Setting this value to 0 establishes the specified row or column as not resizable, regardless of the setting of <BOLD>XmNautoLayout</BOLD>. Other values are taken relative to all other rows. For example, if a Grid has three rows whose resizability factors are set to 100, 100, and 200, the first and second rows will occupy one quarter of the space (100/(100+100+200)), while the third row will occupy one half of the available space.</PARAGRAPH>
<PARAGRAPH>The <BOLD>XmNdefaultSpacing</BOLD> resource default spacing between rows and columns. The default value is 4 pixels. You can override the value on a per row/column basis using <FUNCTION>SgGridSetColumnMargin()</FUNCTION> or <FUNCTION>SgGridSetRowMargin()</FUNCTION> respectively:</PARAGRAPH>
<CODE>
SgGridSetRowMargin(Widget <VARIABLE>widget</VARIABLE>, int <VARIABLE>row</VARIABLE>, Dimension <VARIABLE>margin</VARIABLE>);

SgGridSetColumnMargin(Widget <VARIABLE>widget</VARIABLE>, int <VARIABLE>column</VARIABLE>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dimension <VARIABLE>margin</VARIABLE>);
</CODE>
<PARAGRAPH><VARIABLE>widget</VARIABLE> is the Grid widget. The second argument specifies the row or column. <VARIABLE>margin</VARIABLE> specifies the margin in pixels between the row or column's edges and the widgets it contains. The margin is added to both sides of each row or column, so adding a 1 pixel margin increases the relevant dimension of the affected row or column by 2 pixels.</PARAGRAPH>
<PARAGRAPH>You can display the boundaries of a Grid by setting the value of its <BOLD>XmNshowGrid</BOLD> resource to TRUE. You might find this useful for debugging resize specifications. The default value is FALSE.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Setting Constraints on the Child Widget of a Grid</TITLE><PARAGRAPH>The <INDEXTARGET ID="04.Widgets45"><!-- POSTPROCESSDATA: 04.Widgets45|Grid widget:childChild widget:Grid widget --><BOLD>XmNrow</BOLD> and <BOLD>XmNcolumn</BOLD> resources of a Grid's child widget specify the row and column in which the Grid places the child. If you don't specify these values, the Grid widget places the child in a randomly selected unoccupied cell.</PARAGRAPH>
<PARAGRAPH>The <BOLD>XmNresizeVertical</BOLD> and <BOLD>XmNresizeHorizontal</BOLD> resources determine whether the Grid can resize the child to fill the cell in the vertical and horizontal directions. The default value of TRUE allows the Grid to resize the child.</PARAGRAPH>
<PARAGRAPH>If a child is a fixed size, and smaller than the cell that contains it, the child's position within the cell is determined by an <BOLD>XmNgravity</BOLD> resource. Gravity may be any of the gravity values defined by Xlib except StaticGravity and ForgetGravity. The default is NorthWestGravity. Note that gravity has no effect if both <BOLD>XmNresizeVertical</BOLD> and <BOLD>XmNresizeHorizontal</BOLD> are TRUE.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Examples of Using the Grid Widget</TITLE><PARAGRAPH><INDEXTARGET ID="04.Widgets46"><!-- POSTPROCESSDATA: 04.Widgets46|Grid widget:examples --><XREF IDREF="10463" TYPE="TEXT">Example&nbsp;4-1</XREF> creates a grid of four buttons that all size (and resize) equally to fill one quarter of their parent.</PARAGRAPH>
<CODE><CAPTION LBL="4-1"><PREFIX>Example 4-1 </PREFIX><XREFTARGET ID="10463">An Example of Using the Grid Widget</CAPTION>createGrid(Widget parent)
{
&nbsp;&nbsp;&nbsp;&nbsp;int n;
&nbsp;&nbsp;&nbsp;&nbsp;Arg args[10];
&nbsp;&nbsp;&nbsp;&nbsp;Widget grid, child1, child2, child3, child4;
&nbsp;&nbsp;&nbsp;&nbsp;n = 0;
&nbsp;&nbsp;&nbsp;&nbsp;XtSetArg(args[n], XmNnumRows, 2); n++;
&nbsp;&nbsp;&nbsp;&nbsp;XtSetArg(args[n], XmNnumColumns, 2); n++;
&nbsp;&nbsp;&nbsp;&nbsp;grid = SgCreateGrid(parent, "grid", args, n);

&nbsp;&nbsp;&nbsp;&nbsp;child1 = XtVaCreateManagedWidget("child1",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmPushButtonWidgetClass,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmNrow, 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmNcolumn, 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL);
&nbsp;&nbsp;&nbsp;&nbsp;child2 = XtVaCreateManagedWidget("child2",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmPushButtonWidgetClass,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmNrow, 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmNcolumn, 1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL);
&nbsp;&nbsp;&nbsp;&nbsp;child3 = XtVaCreateManagedWidget("child3",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmPushButtonWidgetClass
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmNrow, 1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmNcolumn, 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL);
&nbsp;&nbsp;&nbsp;&nbsp;child4 = XtVaCreateManagedWidget("child4",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmPushButtonWidgetClass
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmNrow, 1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmNcolumn, 1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL);
&nbsp;&nbsp;&nbsp;&nbsp;XtManageChild(grid);
}
</CODE>
<PARAGRAPH><XREF IDREF="16679" TYPE="TEXT">Example&nbsp;4-2</XREF> creates four buttons. The top row has a fixed vertical size, while the bottom row is resizable. The left column has a fixed size, but the right column can be resized. The button in the lower right can be resized, but the others cannot. The button in the lower left cell, which can be resized vertically, floats in the middle of its cell. The button in the upper right stays to the left of its cell.</PARAGRAPH>
<CODE><CAPTION LBL="4-2"><PREFIX>Example 4-2 </PREFIX><XREFTARGET ID="16679">Another Example of Using the Grid Widget</CAPTION>createGrid(Widget parent) {
&nbsp;&nbsp;&nbsp;&nbsp;int n;
&nbsp;&nbsp;&nbsp;&nbsp;Arg args[10];
&nbsp;&nbsp;&nbsp;&nbsp;Widget grid, chidl1, child2, child3, child4;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;n = 0;
&nbsp;&nbsp;&nbsp;&nbsp;XtSetArg(args[n], XmNnumRows, 2); n++;
&nbsp;&nbsp;&nbsp;&nbsp;XtSetArg(args[n], XmNnumColumns, 2); n++;
&nbsp;&nbsp;&nbsp;&nbsp;grid = SgCreateGrid( parent, "grid", args, n );
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;SgGridSetColumnResizability(grid, 0, 0);
&nbsp;&nbsp;&nbsp;&nbsp;SgGridSetRowResizability(grid, 0, 0);
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;child1 = XtVaCreateManagedWidget("child1",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmPushButtonWidgetClass,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmNrow, 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmNcolumn, 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL);
&nbsp;&nbsp;&nbsp;&nbsp;child2 = XtVaCreateManagedWidget("child2",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmPushButtonWidgetClass,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmNrow, 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmNcolumn, 1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmNresizeHorizontal, FALSE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmNgravity, WestGravity,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL);
&nbsp;&nbsp;&nbsp;&nbsp;child3 = XtVaCreateManagedWidget("child3",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmPushButtonWidgetClass,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmNrow, 1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmNcolumn, 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmNresizeVertical, FALSE,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmNgravity, CenterGravity,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL);
&nbsp;&nbsp;&nbsp;&nbsp;child4 = XtVaCreateManagedWidget("child4",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmPushButtonWidgetClass,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmNrow, 1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XmNcolumn, 1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL);
&nbsp;&nbsp;&nbsp;&nbsp;XtManageChild(grid); 
} 
</CODE>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="46176">HTML Viewer Component</TITLE><PARAGRAPH>The HTML viewer component provides the widgets and libraries necessary for applications to include direct Web access for information from within an application (no external applications have to be run). Thus, applications can provide direct Web access to licensing, online help, and information retrieval.<INDEXTARGET ID="04.Widgets47"><!-- POSTPROCESSDATA: 04.Widgets47|widgets:HTML viewer componentHTML:widgetHTML:viewer componentHTML:librariesWeb access:HTML widget --><INDEXTARGET ID="04.Widgets48"><!-- POSTPROCESSDATA: 04.Widgets48|Web access:licensinglicensing on the WebWeb access:online helponline help:Web access --><INDEXTARGET ID="04.Widgets49"><!-- POSTPROCESSDATA: 04.Widgets49|access:helphelp:Web accessWeb access:information retrieval --></PARAGRAPH>
<PARAGRAPH>For example, applications can use this component with a form and the post method to obtain a license for a user on a local or remote server. Also, applications can use the component to format text and images as read-only text, or provide help to the user. <XREF IDREF="27208" TYPE="GRAPHIC">Figure&nbsp;4-9</XREF> shows an example of the HTML widget.</PARAGRAPH>
<!-- RASTERCONVERT: 04.Widgets.cgm7 -->
<PARAGRAPH><FIGURE><GRAPHIC FILE="04.Widgets-7.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="4-9"><PREFIX>Figure 4-9 </PREFIX><XREFTARGET ID="27208">The HTML Widget</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>This section covers the following aspects of the HTML viewer component:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="12495" TYPE="TITLE">&ldquo;Overview of the HTML Viewer Components&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="40627" TYPE="TITLE">&ldquo;Viewer Components&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="47778" TYPE="TITLE">&ldquo;Supported Tags and Attributes&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="12495">Overview of the HTML Viewer Components</TITLE><PARAGRAPH>The HTML viewer makes the World Wide Web accessible from any application. Prior to the Web, applications had to develop a protocol for remote help and construct a server to answer the protocol. Today, however, the Web supplies a predesigned protocol. And the HTML viewer provides the additional components to implement a Web viewer. </PARAGRAPH>
<PARAGRAPH>The HTML viewer understands how to render HTML markup language. The viewer is derived from the widget and class library licensed for the Silicon Graphics WebMagic authoring environment. The library allows each application to decide exactly what it needs to support. This component is not meant to supplant general Web browsers which have support for things like bookmarks and search engines. However, the HTML viewer component answers the need for online access to licensing and help. </PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="40627">Viewer Components</TITLE><PARAGRAPH>The viewer ViewKit component uses the Motif widget to access Web sites, a prebuilt GUI, and provides browsing, navigation, and history control. The ViewKit component requires the use of C++. It is composed of the following components:<INDEXTARGET ID="04.Widgets50"><!-- POSTPROCESSDATA: 04.Widgets50|HTML:viewer componentsViewKit:HTML widget --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><FUNCTION>VkWebViewerBase</FUNCTION> class, which is for programmers who want to provide their own interface.<FUNCTION>&space;VkWebViewerBase</FUNCTION> is, from a widget point of view, just a scrolled window with a viewer in it. The scrolled window is held in a form. The subclass uses this form to add the other controls.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><FUNCTION>VkWebViewer</FUNCTION> class, which is a more complete browser for an application programmer that doesn't want to do a lot of programming with the component.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The include file is <FILENAME>/usr/include/Vk/VkWebViewer.h</FILENAME>. For example, to create the widget:</PARAGRAPH>
<CODE>
&space;  _viewer = new VkWebViewer(&ldquo;Viewer&rdquo;, mainWindowWidget());
&space;   addView(_viewer);
</CODE>
<PARAGRAPH>For more information about ViewKit, see the <DOCTITLE>IRIS ViewKit Programmer's Guide</DOCTITLE>.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="47778">Supported Tags and Attributes</TITLE><PARAGRAPH><INDEXTARGET ID="04.Widgets51"><!-- POSTPROCESSDATA: 04.Widgets51|HTML:tagsHTML:attributes --><XREF IDREF="77006" TYPE="TABLE">Table&nbsp;4-1</XREF> lists the HTML viewer supported tags. The tags are basically all of HTML 2, selective tags of HTML 3, and extended tags from Netscape and Silicon Graphics </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="4-1"><PREFIX>Table 4-1 </PREFIX><XREFTARGET ID="77006"> <EMPHASIS>(continued)        </EMPHASIS> HTML Viewer Tags and Attributes</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="100"><PARAGRAPH>Tag</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Attributes</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>A</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>HREF, TARGET, NAME</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>AREA</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>HREF, TARGET, COORDS, SHAPE</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>BASE</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>HREF, TARGET</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>BASEFONT</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>SIZE (1..7, or exact size such as 24pt)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>BLOCKQUOTE, BQ</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>BR</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>BODY</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>BACKGROUND, VLINK, LINK. ALINK, BGCOLOR, TEXT, LANG</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>CAPTION</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>ALIGN</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>DIV</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>ALIGN</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>DIR, OL, MENU, UL</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>START (for OL). See also P, H<ITALICS>n</ITALICS>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>DL</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>DT</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>FRAME</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>SRC, NAME, WIDTH, HEIGHT</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>FRAMESET</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>COLS, ROWS</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>FORM</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>METHOD, ACTION, TARGET</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>HEAD</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>HTML</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>HR</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>SIZE, WIDTH, NOSHADE, ALIGN</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>IMG</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>SRC, NOFLOW, ALT, ALIGN, WIDTH, HEIGHT, BORDER, VSPACE, 
CLEAR</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>INPUT</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>NAME, VALUE, TYPE, SIZE, MAXLENGTH, CHECKED</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>ISINDEX</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>PROMPT</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>LI</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>LISTING</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH><VARIABLE>Deprecated</VARIABLE></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>MAP</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>NAME</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>NOBR</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>NOFRAMES</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>OPTION</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>VALUE, SELECTED</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>P, H<VARIABLE>n</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>CLEAR</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>PLAINTEXT</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH><VARIABLE>Deprecated</VARIABLE></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>PRE</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>SELECT</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>NAME, SIZE, MULTIPLE</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>TABLE</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>CELLSPACING, CELLPADDING, BORDER, ALIGN, WIDTH, 
NOFLOW, CLEAR, BGCOLOR</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>TD, TH</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>ROWSPAN, COLSPAN, ALIGN, VALIGN, BGCOLOR, NOWRAP</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>TEXTAREA</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>NAME, ROWS, COLS</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>TITLE</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>TR</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>ALIGN, VALIGN, BGCOLOR</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>WBR</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>XMP</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH><VARIABLE>Deprecated </VARIABLE></PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH><XREF IDREF="94898" TYPE="TABLE">Table&nbsp;4-2</XREF> lists HTML viewer character tags. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="4-2"><PREFIX>Table 4-2 </PREFIX><XREFTARGET ID="94898">  <EMPHASIS>(continued)        </EMPHASIS>HTML Viewer Character Tags</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="108"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="108"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="72"><PARAGRAPH></PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH>ADDRESS</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="108"><PARAGRAPH>B</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="72"><PARAGRAPH>BIG</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH>CITE</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="108"><PARAGRAPH>CODE</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="72"><PARAGRAPH>DFN</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH>EM</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="108"><PARAGRAPH>I</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="72"><PARAGRAPH>KBD</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH>FONT SIZE=(0..7)</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="108"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="72"><PARAGRAPH></PARAGRAPH>
<TABLEXREF></TABLEXREF>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH>COLOR=&rdquo;#rrbbgg&rdquo; <TABLEXREF IDREF="04.WidgetsTF2a">a</TABLEXREF></PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="108"><PARAGRAPH></PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="72"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH>S </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="108"><PARAGRAPH>SAMP</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="72"><PARAGRAPH>SMALL</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH>STRIKE</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="108"><PARAGRAPH>STRONG</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="72"><PARAGRAPH>SUB</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH>SUP</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="108"><PARAGRAPH>IT</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="72"><PARAGRAPH>U</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH>UL</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="108"><PARAGRAPH>VAR</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="72"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
<TABLEFOOTNOTE LBL="a" ID="04.WidgetsTF2a">COLOR=&rdquo;#rrbbgg&rdquo; or COLOR=&rdquo;colorname&rdquo; </TABLEFOOTNOTE>
</TABLE>
</SECTION2>
</SECTION1>
</CHAPTER>
