<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="7"><TITLE><XREFTARGET ID="58622">Interapplication Data Exchange</TITLE><PARAGRAPH>This chapter describes how to implement the recommended data exchange mechanisms in your applications. It contains these sections:<INDEXTARGET ID="07.Data.Exchange1"><!-- POSTPROCESSDATA: 07.Data.Exchange1|data exchangeinterapplication data exchangedata:exchange transferring of dataapplications:exchanging dataapplications:data exchange --><INDEXTARGET ID="07.Data.Exchange2"><!-- POSTPROCESSDATA: 07.Data.Exchange2|transferring data --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="28382" TYPE="TITLE">&ldquo;Data Exchange Overview&rdquo;</XREF> provides a brief description of how the Primary and Clipboard Transfer Models should work in your application. You should implement both.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="35778" TYPE="TITLE">&ldquo;Implementing the Primary Transfer Model&rdquo;</XREF> describes how to implement the Primary Transfer Model in your application.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="56716" TYPE="TITLE">&ldquo;Implementing the Clipboard Transfer Model&rdquo;</XREF> describes how to implement the Primary Transfer Model in your application.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="11667" TYPE="TITLE">&ldquo;Supported Target Formats&rdquo;</XREF> provides tables listing the atom names of supported data formats, along with brief descriptions of what each format is used for.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="97061" TYPE="TITLE">&ldquo;Data Conversion Service&rdquo;</XREF> describes the service available for converting files from one data format to another. For details on the process, refer to <XREF IDREF="41465" TYPE="TITLE">Appendix&nbsp;G, &ldquo;Using GoldenGate Data Conversion Services.&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="28382">Data Exchange Overview</TITLE><PARAGRAPH>As detailed in <EXTREF IDREF="15852" BOOK="UI_Glines" FILE="" HDG="15852" INFO="">Chapter&nbsp;5, &ldquo;Data Exchange on the IRIX Interactive Desktop,&rdquo;</EXTREF>
 in the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE>, Silicon Graphics recommends that your application support both the Primary and Clipboard Transfer Models. The Primary Transfer Model allows users to copy data using mouse buttons, whereas the Clipboard Transfer model allows users to use the &ldquo;Cut,&rdquo; &ldquo;Copy,&rdquo; and &ldquo;Paste&rdquo; options from the Edit menu (or the corresponding keyboard accelerators) to transfer data.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>Silicon Graphics recommends that you not use the IRIS IM clipboard routines for handling data exchange.</NOTE>
<PARAGRAPH>The data exchange model recommended by Silicon Graphics is based on the standard mechanisms provided by the X and Xt. You can consult the O'Reilly &amp; Associates book <DOCTITLE>The X Window System, Volume 4: X Toolkit Intrinsics Programming Manual</DOCTITLE> by Adrian Nye for more information on the standard Xt data exchange methods.</PARAGRAPH>
<PARAGRAPH>The following sections describe:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="68459" TYPE="TITLE">&ldquo;Primary Transfer Model Overview&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="30175" TYPE="TITLE">&ldquo;Clipboard Transfer Model Overview&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="69257" TYPE="TITLE">&ldquo;Interaction Between the Primary and Clipboard Transfer Models&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="68459">Primary Transfer Model Overview</TITLE><PARAGRAPH>When the user selects some data in an application, the application should highlight that data and assert ownership of the PRIMARY selection. Until the application loses the PRIMARY selection, it should then be prepared to respond to requests for the selected data in various target formats. <INDEXTARGET ID="07.Data.Exchange3"><!-- POSTPROCESSDATA: 07.Data.Exchange3|data exchange:Primary TransferPrimary Transfer:data exchange --><INDEXTARGET ID="07.Data.Exchange4"><!-- POSTPROCESSDATA: 07.Data.Exchange4|copy text. <ITALICS>See</ITALICS> data exchangetext:copy. <ITALICS>See</ITALICS> data exchange --><XREF IDREF="11667" TYPE="TITLE">&ldquo;Supported Target Formats&rdquo;</XREF> describes the standard target formats. <INDEXTARGET ID="07.Data.Exchange5"><!-- POSTPROCESSDATA: 07.Data.Exchange5|transferring data:<ITALICS>See</ITALICS> Primary Transfer --></PARAGRAPH>
<PARAGRAPH>When the user selects data in another application, your application loses ownership of the PRIMARY selection. In general, when your application loses the primary selection, it should keep its current selection highlighted. When a user has selections highlighted in more than one window at a time, the most recent selection is always the primary selection. This is consistent with the <ITALICS>persistent always selection</ITALICS> discussed in Section 4.2, &ldquo;Selection Actions,&rdquo; in the <DOCTITLE>OSF/Motif Style Guide, Release 1.2</DOCTITLE>. There is an exception to this guideline: those applications that use selection only for primary transfer, for example, the <ITALICS>winterm</ITALICS> shell window. The only reason for users to select text in a shell window is to transfer that text using the primary transfer mechanism. In this case, when the <ITALICS>winterm</ITALICS> window loses the primary selection, the highlighting is removed. This is referred to as <ITALICS>nonpersistent selection</ITALICS> in Section 4.2, &ldquo;Selection Actions,&rdquo; in the <DOCTITLE>OSF/Motif Style Guide, Release 1.2</DOCTITLE>.</PARAGRAPH>
<PARAGRAPH>The <ITALICS>persistent always selection</ITALICS> mechanism allows the user to have data selected in different applications. The user can still manipulate selected data using application controls. Furthermore, the user can reassert the selected data as the PRIMARY selection by pressing <USERINPUT>&lt;Alt&ndash;Insert></USERINPUT>.</PARAGRAPH>
<PARAGRAPH>When the user clicks the middle mouse button (<BUTTON>BTransfer</BUTTON>) in your application, your application should attempt to copy the primary selection to the current location of the mouse pointer. First, your application should request a list of target formats supported by the primary selection owner. Then your application should select the most appropriate target format and request the primary selection in that format.</PARAGRAPH>
<PARAGRAPH><EXTREF IDREF="61999" BOOK="UI_Glines" FILE="" HDG="61999" INFO="">&ldquo;Supporting the Primary Transfer Model&rdquo; in Chapter&nbsp;5</EXTREF>
 of the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE> further discusses use of the Primary Transfer Model. </PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="30175">Clipboard Transfer Model Overview</TITLE><PARAGRAPH>When the user selects the &ldquo;Copy&rdquo; option from your application's Edit menu (or uses the keyboard accelerator), your application should assert ownership of the CLIPBOARD selection. Until the application loses the CLIPBOARD selection, it should then be prepared to respond to requests for the data selected at the time your application took ownership of the CLIPBOARD selection. (In other words, your application must somehow store the value of the selection when the user performs the copy action; the application can then provide this value even if the user subsequently changes the application's selection.)<INDEXTARGET ID="07.Data.Exchange6"><!-- POSTPROCESSDATA: 07.Data.Exchange6|data exchange:Clipboard TransferClipboard Transfer:data exchange --><INDEXTARGET ID="07.Data.Exchange7"><!-- POSTPROCESSDATA: 07.Data.Exchange7|&ldquo;Copy&rdquo; optionClipboard Transfer:CLIPBOARD selection --><INDEXTARGET ID="07.Data.Exchange8"><!-- POSTPROCESSDATA: 07.Data.Exchange8|Edit menu:&rdquo;Cut&rdquo; optionEdit menu:&rdquo;Copy&rdquo; optionEdit menu:&rdquo;Paste&rdquo; option --></PARAGRAPH>
<PARAGRAPH>When the user selects the &ldquo;Cut&rdquo; option for your application's Edit menu (or uses the keyboard accelerator), your application should assert ownership of the CLIPBOARD selection. Your application must cut the selected data, but it should store the data and be prepared to respond to requests for the data until it loses ownership of the CLIPBOARD selection.<INDEXTARGET ID="07.Data.Exchange9"><!-- POSTPROCESSDATA: 07.Data.Exchange9|&ldquo;Cut&rdquo; option --></PARAGRAPH>
<PARAGRAPH>When the user selects the &ldquo;Paste&rdquo; option for your application's Edit menu (or uses the keyboard accelerator), your application should attempt to copy the clipboard selection to the current location of the location cursor. First, your application should request a list of target formats supported by the clipboard selection owner. Then your application should select the most appropriate target format and request the clipboard selection in that format.<INDEXTARGET ID="07.Data.Exchange10"><!-- POSTPROCESSDATA: 07.Data.Exchange10|&ldquo;Paste&rdquo; option --></PARAGRAPH>
<PARAGRAPH><EXTREF IDREF="27430" BOOK="UI_Glines" FILE="" HDG="27430" INFO="">&ldquo;Supporting the Clipboard Transfer Model&rdquo; in Chapter&nbsp;5</EXTREF>
 of the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE> further discusses use of the Clipboard Transfer Model.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="69257">Interaction Between the Primary and Clipboard Transfer Models</TITLE><PARAGRAPH>Silicon Graphics recommends that you implement the Primary and Clipboard Transfer Models so that they operate separately. The only complication is maintaining data in the PRIMARY selection when the user performs a cut action. Consider the following example:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>The user selects data in an application. The application asserts ownership of the PRIMARY selection.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The user performs a cut action. The application asserts ownership of the CLIPBOARD selection and removes the selected data from the display.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The user goes to another application that already has data selected.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The user cuts the data selected in the second application. The second application asserts ownership of the CLIPBOARD selection and removes the selected data from the display.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>The clipboard actions described above should not affect the PRIMARY selection. In this example, the first application should retain ownership of the PRIMARY selection and continue to be prepared to respond to requests for the value of the PRIMARY selection. To support this, the application should somehow store the value of the PRIMARY selection until it no longer owns the PRIMARY selection.</PARAGRAPH>
<PARAGRAPH>To properly handle the situation described above, your application should implement the following:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>In the function that handles the Clipboard Transfer Model's cut action, test to see whether the application owns the PRIMARY selection. If it does, you should preserve the selected data. If selections in your application are typically small (for example, ASCII text), you might simply copy the data to a buffer. If selections in your application are typically large (for example, sound or movie clips), you might remove the data from the display but retain pointers to it.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>In the function that handles losing the PRIMARY selection, test to see whether you have data preserved from a cut action. If so, and the application currently doesn't own the CLIPBOARD selection, you should free that data or reset the pointers to it.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="35778">Implementing the Primary Transfer Model</TITLE><PARAGRAPH>This section describes how to implement support for the Primary Transfer Model in your application. Topics covered include:<INDEXTARGET ID="07.Data.Exchange11"><!-- POSTPROCESSDATA: 07.Data.Exchange11|Primary Transfer:implementation --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="17379" TYPE="TITLE">&ldquo;Data Selection&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="83248" TYPE="TITLE">&ldquo;Requests for the Primary Selection&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="14041" TYPE="TITLE">&ldquo;Loss of the Primary Selection&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="13583" TYPE="TITLE">&ldquo;Inserting the Primary Selection&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
</BULLETLIST>
<NOTE><PREFIX>Note</PREFIX>Silicon Graphics recommends that you don't use the IRIS IM clipboard routines, because they are not as flexible as the Xt selection routines. </NOTE>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="17379">Data Selection</TITLE><PARAGRAPH>When the user selects data in a window of your application, it should call <INDEXTARGET ID="07.Data.Exchange12"><!-- POSTPROCESSDATA: 07.Data.Exchange12|Primary Transfer:data selectiondata selection:Primary Transfer --><FUNCTION>XtOwnSelection(3Xt)</FUNCTION> to assert ownership of the PRIMARY selection and highlight the selected data.</PARAGRAPH>
<PARAGRAPH>The code fragment in <XREF IDREF="59545" TYPE="TEXT">Example&nbsp;7-1</XREF> shows a simple example of asserting ownership of the PRIMARY selection. For clarity, this example omits code for manipulating the selection itself (for example, setting up pointers to the selection).</PARAGRAPH>
<PARAGRAPH><EXTREF IDREF="59818" BOOK="UI_Glines" FILE="" HDG="59818" INFO="">&ldquo;Selection&rdquo; in Chapter&nbsp;7</EXTREF>
 of the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE> discusses guidelines for allowing users to select data and for hightlighting selected data.</PARAGRAPH>
<CODE><CAPTION LBL="7-1"><PREFIX>Example 7-1 </PREFIX><XREFTARGET ID="59545">Asserting Ownership of PRIMARY Selection</CAPTION>Boolean ownPrimary;
&nbsp;
/*
&nbsp;&nbsp;&nbsp;w is window in which selection occurred
&nbsp;&nbsp;&nbsp;event is pointer to event that caused selection
*/
&nbsp;
void dataSelected(Widget w, XButtonEvent *event)
{
...
&nbsp;&nbsp;/* 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assert ownership of PRIMARY selection.
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XA_PRIMARY is the slection.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;event->time is timestamp of the event.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;primaryRequestCallback is the function called
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;whenever another application requests the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value of the PRIMARY selection.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lostPrimaryCallback is the function called whenever
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the application loses the selection.
&nbsp;&nbsp;*/
&nbsp;
&nbsp;&nbsp;ownPrimary = XtOwnSelection(w, XA_PRIMARY, event->time,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;primaryRequestCallback,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lostPrimaryCallback,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL);
&nbsp;
&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If we successfully obtained ownership, highlight
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the data; otherwise, clean up
&nbsp;&nbsp;*/
&nbsp;
&nbsp;&nbsp;if (ownPrimary)
&nbsp;&nbsp;&nbsp;&nbsp;highlightSelection();
&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;lostPrimaryCallback(w, XA_PRIMARY);
...
}
</CODE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="83248">Requests for the Primary Selection</TITLE><PARAGRAPH>When you assert ownership of the PRIMARY selection, one of the parameters you pass to <INDEXTARGET ID="07.Data.Exchange13"><!-- POSTPROCESSDATA: 07.Data.Exchange13|Primary Transfer:requests forPrimary Transfer:callback functionPrimary Selection:<ITALICS>See also</ITALICS> Primary Transfer --><FUNCTION>XtOwnSelection()</FUNCTION> is a callback function to handle requests for the value of the PRIMARY selection. When another application requests the value of the PRIMARY selection, the Xt selection mechanism invokes your application's callback function.</PARAGRAPH>
<PARAGRAPH>The requesting application indicates a desired target format. Typically, a requestor first asks for the special target format TARGETS. Your application should respond with a list of target formats it supports. The requestor then chooses an appropriate target format and requests the selection value in that format. <XREF IDREF="11667" TYPE="TITLE">&ldquo;Supported Target Formats&rdquo;</XREF> describes some of the common target formats your application should support.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="14041">Loss of the Primary Selection</TITLE><PARAGRAPH>When your application loses the PRIMARY selection and your application follows the <INDEXTARGET ID="07.Data.Exchange14"><!-- POSTPROCESSDATA: 07.Data.Exchange14|Primary Transfer:loss ofpersistent selection:<ITALICS>See</ITALICS> Primary Transfer --><ITALICS>persistent always selection</ITALICS> model discussed in <XREF IDREF="68459" TYPE="TITLE">&ldquo;Primary Transfer Model Overview&rdquo;</XREF>, don't remove the highlight from any selected data. The user should still be able to cut or copy any selected data using the Clipboard Transfer Model. If your application follows the <ITALICS>nonpersistent selection</ITALICS> model as discussed in <XREF IDREF="68459" TYPE="TITLE">&ldquo;Primary Transfer Model Overview,&rdquo;</XREF> you should remove the highlight.</PARAGRAPH>
<PARAGRAPH>Your application should also test to see whether you have data preserved from a cut action (see <XREF IDREF="63612" TYPE="TITLE">&ldquo;Cut Actions&rdquo;</XREF>). If so, and your application currently doesn't own the CLIPBOARD selection, you should free that data or reset the pointers to it. <XREF IDREF="69257" TYPE="TITLE">&ldquo;Interaction Between the Primary and Clipboard Transfer Models&rdquo;</XREF> describes the rationale for this procedure.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>To comply with the <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE>, if the user presses <USERINPUT>&lt;Alt&ndash;Insert></USERINPUT> in your application, you should reassert ownership of PRIMARY for your application.</NOTE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="13583">Inserting the Primary Selection</TITLE><PARAGRAPH>When the user clicks the middle mouse button in your application, it should perform the steps described below.<INDEXTARGET ID="07.Data.Exchange15"><!-- POSTPROCESSDATA: 07.Data.Exchange15|Primary Selection:insertingmiddle mouse button:inserting text --></PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Your application should ask the owner of the PRIMARY selection for a list of its TARGETS, using <FUNCTION>XtGetSelectionValue()</FUNCTION> with selection PRIMARY and target TARGETS.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Your application should look through the list of supported targets, select the one that is appropriate for your application, and call <FUNCTION>XtGetSelectionValue()</FUNCTION> again with that new target.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>If the selection owner does not support TARGETS, then your application should ask for the target STRING, if it can support that target.</PARAGRAPH>
<PARAGRAPH>Silicon Graphics recommends that you support STRING, even if your application doesn't support text. For instance, a movie player could get the selection as a string and try to parse it as a filename. That way users could select a filename in a terminal emulator window and paste it into another application. </PARAGRAPH>
</LIST>
</ORDEREDLIST>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="56716">Implementing the Clipboard Transfer Model</TITLE><PARAGRAPH>This section describes how to implement support for the Clipboard Transfer Model in your application. Topics include:<INDEXTARGET ID="07.Data.Exchange16"><!-- POSTPROCESSDATA: 07.Data.Exchange16|Clipboard Transfer:implementation --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="63612" TYPE="TITLE">&ldquo;Cut Actions&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="37249" TYPE="TITLE">&ldquo;Copy Actions&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="59533" TYPE="TITLE">&ldquo;Requests for the Clipboard Selection&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="96161" TYPE="TITLE">&ldquo;Paste Actions&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="10915" TYPE="TITLE">&ldquo;Loss of the Clipboard Selection&rdquo;</XREF></PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="63612">Cut Actions</TITLE><PARAGRAPH>When the user performs a cut action, your application should:<INDEXTARGET ID="07.Data.Exchange17"><!-- POSTPROCESSDATA: 07.Data.Exchange17|&ldquo;Cut&rdquo; optionClipboard Transfer:&rdquo;Cut&rdquo; actions --></PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Call <FUNCTION>XtOwnSelection(3Xt)</FUNCTION> to assert ownership of the CLIPBOARD selection.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Remove the selected data from the display. Retain the selected data until your application loses ownership of the CLIPBOARD selection.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Test to see whether the application owns the PRIMARY selection. If it does, you should preserve the selected data, even after losing ownership of the CLIPBOARD selection. You should retain the data until your application also loses ownership of the PRIMARY selection.</PARAGRAPH>
<PARAGRAPH>If selections in your application are typically small (for example, ASCII text), you might simply copy the data to a buffer. If selections in your application are typically large (for example, sound or movie clips), you might remove the data from the display but retain pointers to it.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>The code fragment in <XREF IDREF="55139" TYPE="TEXT">Example&nbsp;7-2</XREF> shows a simple example of handling a cut action and asserting ownership of the CLIPBOARD selection. For clarity, this example omits code for manipulating the selection itself (for example, setting up pointers to the selection).</PARAGRAPH>
<CODE><CAPTION LBL="7-2"><PREFIX>Example 7-2 </PREFIX><XREFTARGET ID="55139">Handling Cut Actions in the Clipboard Transfer Model</CAPTION>Boolean ownPrimary;
Boolean primaryPreserved;
/*
&nbsp;&nbsp;&nbsp;w is window in which selection occurred
&nbsp;&nbsp;&nbsp;event is pointer to event that caused selection
&nbsp;&nbsp;*/
void selectionCut(Widget w, XButtonEvent *event)
{
...
&nbsp;&nbsp;/* 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Assert ownership of CLIPBOARD selection.
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XA_CLIPBOARD is the selection.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;event->time is timestamp of the event.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clipboardRequestCallback is the function called
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;whenever another application requests the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value of the CLIPBOARD selection.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lostClipboardCallback is the function called whenever
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the application loses the selection.
&nbsp;&nbsp;*/
&nbsp;
&nbsp;&nbsp;ownClipboard = XtOwnSelection(w, XA_CLIPBOARD, event->time,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clipboardRequestCallback,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lostClipboardCallback,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL);
&nbsp;
&nbsp;&nbsp;if (ownClipboard)
&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Retain the selected data until the application loses
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ownership of the CLIPBOARD selection.
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;preserveClipboardSelection();
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;/*
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If we also own the PRIMARY selection, we need to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preserve the selected data separately so that we can
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue to satisfy requests for the PRIMARY selection
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;even if we lose the CLIPBOARD selection.
&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;if (ownPrimary)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;primaryPreserved = preservePrimarySelection();
&nbsp;&nbsp;}
...
}
</CODE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="37249">Copy Actions</TITLE><PARAGRAPH>When the user performs a copy action, your application should call <INDEXTARGET ID="07.Data.Exchange18"><!-- POSTPROCESSDATA: 07.Data.Exchange18|&ldquo;Copy&rdquo; optionClipboard Transfer:&rdquo;Copy&rdquo; actions --><FUNCTION>XtOwnSelection(3Xt)</FUNCTION> to assert ownership of the CLIPBOARD selection. No other actions are required.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="59533">Requests for the Clipboard Selection</TITLE><PARAGRAPH>When you assert ownership of the CLIPBOARD selection, one of the parameters you pass to <INDEXTARGET ID="07.Data.Exchange19"><!-- POSTPROCESSDATA: 07.Data.Exchange19|ownership:Clipboard SelectionClipboard Selection:ownership --><FUNCTION>XtOwnSelection()</FUNCTION> is a callback function to handle requests for the value of the CLIPBOARD selection. When another application requests the value of the CLIPBOARD selection, the Xt selection mechanism invokes your application's callback function.</PARAGRAPH>
<PARAGRAPH>The requesting application indicates a desired target format. Typically, a requestor first asks for the special target format TARGETS. Your application should respond with a list of target formats it supports. The requestor then chooses an appropriate target format and requests the selection value in that format. <XREF IDREF="11667" TYPE="TITLE">&ldquo;Supported Target Formats&rdquo;</XREF> describes some of the common target formats your application should support.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="96161">Paste Actions</TITLE><PARAGRAPH>When the user selects &ldquo;Paste&rdquo; from the File menu, your application should: <INDEXTARGET ID="07.Data.Exchange20"><!-- POSTPROCESSDATA: 07.Data.Exchange20|&ldquo;Paste&rdquo; optionClipboard Transfer:&rdquo;Paste&rdquo; actions --></PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Ask the owner of the CLIPBOARD selection for a list of its TARGETS, using <FUNCTION>XtGetSelectionValue()</FUNCTION> with selection CLIPBOARD and target TARGETS.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Look through the list of supported targets, select the one that is appropriate for your application, and call <FUNCTION>XtGetSelectionValue()</FUNCTION> again with that new target. </PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>If the selection owner doesn't support TARGETS, then your application should ask for the target STRING, if it can support that target. </PARAGRAPH>
<PARAGRAPH>Silicon Graphics recommends that you support STRING, even if your application doesn't support text. For instance, a movie player can get the selection as a string and try to parse it as a filename. That way users can select a filename in a terminal emulator window and paste it into another application. </PARAGRAPH>
</LIST>
</ORDEREDLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="10915">Loss of the Clipboard Selection</TITLE><PARAGRAPH>When your application loses the Clipboard selection, don't remove the highlight from any selected data. The user should still be able to cut or copy any selected data. Your application can discard any data it had retained as a result of a cut operation (see <INDEXTARGET ID="07.Data.Exchange21"><!-- POSTPROCESSDATA: 07.Data.Exchange21|Clipboard Transfer:loss of Clipboard Selection --><XREF IDREF="63612" TYPE="TITLE">&ldquo;Cut Actions&rdquo;</XREF>). </PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="11667">Supported Target Formats</TITLE><PARAGRAPH>Every application should support the TARGETS, TIMESTAMP, MULTIPLE, and STRING targets. The Xt selection functions support the MULTIPLE targets for you. <INDEXTARGET ID="07.Data.Exchange22"><!-- POSTPROCESSDATA: 07.Data.Exchange22|data exchange:target formatstargets:data exchangeinterapplication data exchange:target formatsexchanging data:target formats --><FUNCTION>XmuConvertStandardSelection()</FUNCTION> supports the TIMESTAMP target. (Silicon Graphics recommends that applications use <FUNCTION>XmuConvertStandardSelection()</FUNCTION> because it also supports HOSTNAME, NAME, CLIENT_WINDOW, and a variety of other useful targets.)&space;Your application must support the TARGETS and STRING targets itself. In addition, Silicon Graphics has defined other targets for data types used by Silicon Graphics applications and libraries. <INDEXTARGET ID="07.Data.Exchange23"><!-- POSTPROCESSDATA: 07.Data.Exchange23|target formats:SGI formatsformats:SGIatom:SGIdata exchange:SGI --></PARAGRAPH>
<PARAGRAPH>The tables that follow list supported target formats:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="94080" TYPE="TABLE">Table&nbsp;7-1</XREF> lists target names for audio formats</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="70552" TYPE="TABLE">Table&nbsp;7-2</XREF> shows target names for image formats</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="20712" TYPE="TABLE">Table&nbsp;7-3</XREF> presents target names for movie formats</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="52294" TYPE="TABLE">Table&nbsp;7-4</XREF> lists target names for 3D graphics formats</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="31415" TYPE="TABLE">Table&nbsp;7-5</XREF> shows target names for Silicon Graphics data types</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="39181" TYPE="TABLE">Table&nbsp;7-6</XREF> shows target names for World Wide Web formats</PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="7-1"><PREFIX>Table 7-1 </PREFIX><XREFTARGET ID="94080"> <EMPHASIS>(continued)        </EMPHASIS>Audio Formats <INDEXTARGET ID="07.Data.Exchange24"><!-- POSTPROCESSDATA: 07.Data.Exchange24|audio formats --><INDEXTARGET ID="07.Data.Exchange25"><!-- POSTPROCESSDATA: 07.Data.Exchange25|target formats:audio formatsformats:audioatom:audiodata exchange:audio --></CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="126"><PARAGRAPH>Name of Atom/Target</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Description</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>AIFF_FILE<INDEXTARGET ID="07.Data.Exchange26"><!-- POSTPROCESSDATA: 07.Data.Exchange26|AIFF data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Audio Interchange Format, used on Apple systems.<INDEXTARGET ID="07.Data.Exchange27"><!-- POSTPROCESSDATA: 07.Data.Exchange27|Apple data --></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>AIFF_C_FILE</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Modified version of Apple's AIFF, compatible with SGI 
systems.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>NEXT_FILE<INDEXTARGET ID="07.Data.Exchange28"><!-- POSTPROCESSDATA: 07.Data.Exchange28|NEXT data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Used on Next and Sun systems.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>SD2_FILE<INDEXTARGET ID="07.Data.Exchange29"><!-- POSTPROCESSDATA: 07.Data.Exchange29|SD2 data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Sound Designer 2 format</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>WAVE_FILE<INDEXTARGET ID="07.Data.Exchange30"><!-- POSTPROCESSDATA: 07.Data.Exchange30|WAVE data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Microsoft Wave format<INDEXTARGET ID="07.Data.Exchange31"><!-- POSTPROCESSDATA: 07.Data.Exchange31|Microsoft data --></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>MPEG_1_AUDIO_FILE<INDEXTARGET ID="07.Data.Exchange32"><!-- POSTPROCESSDATA: 07.Data.Exchange32|MPEG data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>MPEG Audio. The name of a file that contains MPEG-1 audio 
data.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>MPEG_1_AUDIO</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Stream of audio data, in MPEG-1 Stream format.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>SGI_AUDIO_FILE<INDEXTARGET ID="07.Data.Exchange33"><!-- POSTPROCESSDATA: 07.Data.Exchange33|SGI audio data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>The name of a file that contains Silicon Graphics format sound 
data, that can be read using libaudiofile. The file is the 
responsibility of the receiver, once the selection owner has 
generated it.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>SGI_AUDIO</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Stream of audio data, readable with the SGI audio library.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<TABLE COLUMNS="2"><CAPTION LBL="7-2"><PREFIX>Table 7-2 </PREFIX><XREFTARGET ID="70552"> <EMPHASIS>(continued)        </EMPHASIS>Image Formats <INDEXTARGET ID="07.Data.Exchange34"><!-- POSTPROCESSDATA: 07.Data.Exchange34|image formats --><INDEXTARGET ID="07.Data.Exchange35"><!-- POSTPROCESSDATA: 07.Data.Exchange35|target formats:image formatsformats:imageatom:imagedata exchange:image --></CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="126"><PARAGRAPH>Name of Atom/Target</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Description</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>FITS_FILE<INDEXTARGET ID="07.Data.Exchange36"><!-- POSTPROCESSDATA: 07.Data.Exchange36|FITS data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Flexible Image Transport System</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>GIF_89<INDEXTARGET ID="07.Data.Exchange37"><!-- POSTPROCESSDATA: 07.Data.Exchange37|GIF data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Graphics Interchange Format (streaming bit format)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>GIF_89_FILE</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Graphics Interchange Format (file format)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>JFIF_FILE<INDEXTARGET ID="07.Data.Exchange38"><!-- POSTPROCESSDATA: 07.Data.Exchange38|JIFF data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>JPEG File Interchange Format<INDEXTARGET ID="07.Data.Exchange39"><!-- POSTPROCESSDATA: 07.Data.Exchange39|JPEG data --></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>DIB_FILE<INDEXTARGET ID="07.Data.Exchange40"><!-- POSTPROCESSDATA: 07.Data.Exchange40|DIB data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Microsoft image format<INDEXTARGET ID="07.Data.Exchange41"><!-- POSTPROCESSDATA: 07.Data.Exchange41|Microsoft data --></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>PHOTO_CD_FILE<INDEXTARGET ID="07.Data.Exchange42"><!-- POSTPROCESSDATA: 07.Data.Exchange42|PHOTO data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Kodak photo CD<INDEXTARGET ID="07.Data.Exchange43"><!-- POSTPROCESSDATA: 07.Data.Exchange43|Kodak data --></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>PPM_FILE<INDEXTARGET ID="07.Data.Exchange44"><!-- POSTPROCESSDATA: 07.Data.Exchange44|PPM data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Portable pixmap format<INDEXTARGET ID="07.Data.Exchange45"><!-- POSTPROCESSDATA: 07.Data.Exchange45|pixmap data --></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>PNM_FILE</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Portable anymap format</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>PGM_FILE</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Portable graymap format</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>SGI_RGBIMAGE_FILE<INDEXTARGET ID="07.Data.Exchange46"><!-- POSTPROCESSDATA: 07.Data.Exchange46|SGI data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>The name of a file that contains a Silicon Graphics format 
image file. This is an rgb file. The file is the responsibility of the 
receiver, once the selection owner has generated it.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>SGI_RGBIMAGE</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>The rgb image data stream.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>TIFF_FILE<INDEXTARGET ID="07.Data.Exchange47"><!-- POSTPROCESSDATA: 07.Data.Exchange47|TIFF data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Tagged Image File Format</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<TABLE COLUMNS="2"><CAPTION LBL="7-3"><PREFIX>Table 7-3 </PREFIX><XREFTARGET ID="20712"> <EMPHASIS>(continued)        </EMPHASIS>Movie Formats&space;<INDEXTARGET ID="07.Data.Exchange48"><!-- POSTPROCESSDATA: 07.Data.Exchange48|movie formats --><INDEXTARGET ID="07.Data.Exchange49"><!-- POSTPROCESSDATA: 07.Data.Exchange49|target formats:movie formatsformats:movieatom:moviedata exchange:movie --></CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="126"><PARAGRAPH>Name of Atom/Target</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Description</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>APPLE_QUICKTIME_FILE<INDEXTARGET ID="07.Data.Exchange50"><!-- POSTPROCESSDATA: 07.Data.Exchange50|Apple Quicktime data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Apple Quicktime&trademarksans; format</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>AVID_OMFI_FILE<INDEXTARGET ID="07.Data.Exchange51"><!-- POSTPROCESSDATA: 07.Data.Exchange51|AVID data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>AVID OMFI&trademarksans;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>AVI_FILE</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Microsoft AVI&trademarksans; format</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>MPEG_1_VIDEO_FILE<INDEXTARGET ID="07.Data.Exchange52"><!-- POSTPROCESSDATA: 07.Data.Exchange52|MPEG data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Motion Picture Experts Group MPEG-1 file </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>MPEG_1_VIDEO</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Stream format</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>MPEG_1_SYSTEMS_FILE</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Motion Picture Experts Group MPEG-1 systems file</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>MPEG_1_SYSTEMS</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Stream format</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>SGI_MOVIE_FILE<INDEXTARGET ID="07.Data.Exchange53"><!-- POSTPROCESSDATA: 07.Data.Exchange53|SGI data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>SGI movie format</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>SGI_MOVIE</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Stream format</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<TABLE COLUMNS="2"><CAPTION LBL="7-4"><PREFIX>Table 7-4 </PREFIX><XREFTARGET ID="52294"> <EMPHASIS>(continued)        </EMPHASIS>3D Graphics Formats <INDEXTARGET ID="07.Data.Exchange54"><!-- POSTPROCESSDATA: 07.Data.Exchange54|target formats:3D graphics formatsformats:3D graphicsatom:3D graphicsdata exchange:3D graphics3D graphics formats --></CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="126"><PARAGRAPH>Name of Atom/Target</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Description</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>INVENTOR_2_1<INDEXTARGET ID="07.Data.Exchange55"><!-- POSTPROCESSDATA: 07.Data.Exchange55|INVENTOR data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>SGI Open Inventor V2.1 data</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>INVENTOR_2_1_FILE</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>SGI Open Inventor V2.1 file</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>AUTODESK_DXF_FILE<INDEXTARGET ID="07.Data.Exchange56"><!-- POSTPROCESSDATA: 07.Data.Exchange56|AUTODESK data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>AUTODESK DXF&trademarksans;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>AUTODESK_3DS_FILE</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>AUTODESK 3DS&trademarksans;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>ALIAS_FILE<INDEXTARGET ID="07.Data.Exchange57"><!-- POSTPROCESSDATA: 07.Data.Exchange57|ALIAS data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Alias wire file</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>IGES_FILE<INDEXTARGET ID="07.Data.Exchange58"><!-- POSTPROCESSDATA: 07.Data.Exchange58|IGES data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>IGES file</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>PIXAR_RIB_FILE<INDEXTARGET ID="07.Data.Exchange59"><!-- POSTPROCESSDATA: 07.Data.Exchange59|PIXAR data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Pixar Renderman .RIB file</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>SOFTIMAGE_HRC_FILE<INDEXTARGET ID="07.Data.Exchange60"><!-- POSTPROCESSDATA: 07.Data.Exchange60|SOFTIMAGE data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Softimage .hrc file</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>SOFTIMAGE_DSC_FILE</PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Softimage .dsc file</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>WAVEFRONT_OBJ_FILE<INDEXTARGET ID="07.Data.Exchange61"><!-- POSTPROCESSDATA: 07.Data.Exchange61|WAVEFRONT data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>Wavefront .OBJ file</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="126"><PARAGRAPH>VRML_1_0_FILE<INDEXTARGET ID="07.Data.Exchange62"><!-- POSTPROCESSDATA: 07.Data.Exchange62|VRML data --></PARAGRAPH>
</CELL>
<CELL LEFT="135" WIDTH="252"><PARAGRAPH>VRML 1.0 file<INDEXTARGET ID="07.Data.Exchange63"><!-- POSTPROCESSDATA: 07.Data.Exchange63|virtual reality data --></PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<TABLE COLUMNS="2"><CAPTION LBL="7-5"><PREFIX>Table 7-5 </PREFIX><XREFTARGET ID="31415"> <EMPHASIS>(continued)        </EMPHASIS>Additional Data Types Supported by Silicon Graphics </CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="162"><PARAGRAPH>Name of Atom/Target</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="216"><PARAGRAPH>Description</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="162"><PARAGRAPH>INVENTOR</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="216"><PARAGRAPH>Synonym for INVENTOR_2_0.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="162"><PARAGRAPH>_SGI_RGB_IMAGE_FILENAME</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="216"><PARAGRAPH>Replaced by SGI_RGBIMAGE_FILE.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="162"><PARAGRAPH>_SGI_RGB_IMAGE</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="216"><PARAGRAPH>Replaced by SGI_RGBIMAGE.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="162"><PARAGRAPH>_SGI_AUDIO_FILENAME</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="216"><PARAGRAPH>Replaced by SGI_AUDIO_FILE.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="162"><PARAGRAPH>_SGI_AUDIO</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="216"><PARAGRAPH>Replaced by SGI_AUDIO.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="162"><PARAGRAPH>_SGI_MOVIE_FILENAME</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="216"><PARAGRAPH>Replaced by SGI_MOVIE_FILE.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="162"><PARAGRAPH>_SGI_MOVIE</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="216"><PARAGRAPH>Replaced by SGI_MOVIE.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="162"><PARAGRAPH>SGI_SHOWCASE_FILE</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="216"><PARAGRAPH>Name of file containing SGI Showcase data.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</BULLET>
</BULLETLIST>
<CAUTION><PREFIX>Caution</PREFIX>Xt implements a timeout when transferring data using the selection mechanism. The default is five seconds. Often, this is inadequate for applications transferring audio, image, or movie data. Therefore, if your application supports receiving such selections, you should call <FUNCTION>XtAppSetSelectionTimeout()</FUNCTION> to change the timeout to a larger value. </CAUTION>
<TABLE COLUMNS="2"><CAPTION LBL="7-6"><PREFIX>Table 7-6 </PREFIX><XREFTARGET ID="39181"> <EMPHASIS>(continued)        </EMPHASIS>World Wide Web Targets</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="166"><PARAGRAPH>Type of Atom/Target</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>Description</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>HTML<INDEXTARGET ID="07.Data.Exchange64"><!-- POSTPROCESSDATA: 07.Data.Exchange64|HTML data --></PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>Hypertext Markup Language as an 
ASCII Stream.<INDEXTARGET ID="07.Data.Exchange65"><!-- POSTPROCESSDATA: 07.Data.Exchange65|hypertext data --></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH>HTML_FILE</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>Name of the file containing HTML.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<NOTE><PREFIX>Note</PREFIX>Silicon Graphics applications should also support the generic X11/ICCCM targets such as STRING and COMPOUND_TEXT. </NOTE>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="97061">Data Conversion Service</TITLE><PARAGRAPH>Silicon Graphics provides GoldenGate data conversion service to help you convert data from one format to another, offloading the responsibility for data conversion from your application. See <INDEXTARGET ID="07.Data.Exchange66"><!-- POSTPROCESSDATA: 07.Data.Exchange66|GoldenGate:data conversiondata conversion:GoldenGateconverting data:GoldenGateformats:converting datainterapplication data exchange:GoldenGate conversion --><XREF IDREF="41465" TYPE="TITLE">Appendix&nbsp;G, &ldquo;Using GoldenGate Data Conversion Services,&rdquo;</XREF> for more information.</PARAGRAPH>
<PARAGRAPH>The GoldenGate conversion service consists of four elements: </PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>the header file, <FILENAME>/usr/include/convert/SgCvt.h</FILENAME></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the conversion library, <FILENAME>libcvt.so</FILENAME></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the converter registry file, <FILENAME>/etc/ConverterRegistry</FILENAME></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>a set of pluggable converters</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The header file and library provide the Application Programmatic Interface (API) for the service. The converter registry file describes the converters available to the service. The actual code for the converters is stored in separate Dynamic Shared Objects (DSOs). When an application program tries to access a converter, the service dynamically loads the associated DSO.</PARAGRAPH>
<PARAGRAPH>The GoldenGate API uses Digital Media parameter-value lists to describe data formats. See the <DOCTITLE>IRIS Media Libraries Programming Guide</DOCTITLE> for information on how to use the Digital Media library to create and manipulate digital media parameter-value lists.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>The Converter Registry</TITLE><PARAGRAPH>The converter registry contains entries describing each converter available to the service. Each converter entry lists the data format that the converter takes as input, the format that the converter produces as output, and information that allows the service to locate the converter code.<INDEXTARGET ID="07.Data.Exchange67"><!-- POSTPROCESSDATA: 07.Data.Exchange67|GoldenGate:converter registryconverter registrydata exchange:convertersconverters:data exchange --></PARAGRAPH>
<PARAGRAPH>The converter registry can also contain entries defining<ITALICS>&space;pipelines</ITALICS>. A pipeline is a set of converters connected in series, with the output of one converter feeding the next. As far as application programs are concerned, a pipeline is just another converter.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>The GoldenGate API</TITLE><PARAGRAPH>All programs using the GoldenGate API should include the <INDEXTARGET ID="07.Data.Exchange68"><!-- POSTPROCESSDATA: 07.Data.Exchange68|GoldenGate:APIAPI:GoldenGateGoldenGate:converter header filedata exchange:API --><FILENAME>libSgCvt</FILENAME> header file:</PARAGRAPH>
<EXAMPLE>
#include &lt;convert/SgCvt.h>
</EXAMPLE>
<PARAGRAPH>The GoldenGate API uses a fairly simple programming model. For application programs, the most complicated part of the conversion process is picking an appropriate converter. </PARAGRAPH>
<PARAGRAPH>Once the application program has picked a converter, it initializes the conversion pipeline, and proceeds to send data through the pipeline. The pipeline is a &ldquo;black box.&rdquo; It may consist of one converter, or several converters running in series. The API for application programs using the service is described in <XREF IDREF="41465" TYPE="TITLE">Appendix&nbsp;G, &ldquo;Using GoldenGate Data Conversion Services.&rdquo;</XREF></PARAGRAPH>
<PARAGRAPH>Converters, on the other hand, must read data from the pipeline, convert it, and write data back to the pipeline. Again, the pipeline is a black box. A converter can't tell if its input is coming from another converter, or from an application program. Likewise, it can't tell if its output is going to another converter or back to the application program. Designing converters is discussed in <XREF IDREF="41465" TYPE="TITLE">Appendix&nbsp;G, &ldquo;Using GoldenGate Data Conversion Services.&rdquo;</XREF>&space;</PARAGRAPH>
</SECTION2>
</SECTION1>
</CHAPTER>
