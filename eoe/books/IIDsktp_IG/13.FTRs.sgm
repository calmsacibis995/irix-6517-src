<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="13"><TITLE><XREFTARGET ID="36003">File Typing Rules</TITLE><PARAGRAPH>The Desktop uses file typing rules (FTRs) to evaluate all files that are presented within the Desktop. This chapter describes each of the file typing rules in detail, and offers suggestions for good file typing style and strategies. <INDEXTARGET ID="13.FTRs1"><!-- POSTPROCESSDATA: 13.FTRs1|File Typing RulesFTRsFile Typing Rules:<ITALICS>Also see</ITALICS> FTRs --><EXTREF IDREF="25444" BOOK="UI_Glines" FILE="" HDG="25444" INFO="">&ldquo;Defining the Behavior of Icons With FTRs&rdquo; in Chapter&nbsp;2</EXTREF>
 in <DOCTITLE>IRIX Interactive User Interface Guidelines</DOCTITLE> describes the behaviors your icon should support.</PARAGRAPH>
<PARAGRAPH>This chapter contains these sections:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="10520" TYPE="TITLE">&ldquo;A Table of the FTRs With Descriptions&rdquo;</XREF> provides a reference table listing the FTRs along with brief descriptions.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="50570" TYPE="TITLE">&ldquo;Naming File Types: The TYPE Rule&rdquo;</XREF> describes the TYPE rule, used to name a file typ. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="27184" TYPE="TITLE">&ldquo;Categorizing File Types: The SUPERTYPE Rule&rdquo;</XREF> describes the SUPERTYPE rule, used to categorize file types.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="98067" TYPE="TITLE">&ldquo;Matching File Types With Applications: The MATCH Rule&rdquo;</XREF> describes the MATCH rule, used to match the application with the corresponding file type.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="92689" TYPE="TITLE">&ldquo;Matching Non-Plain Files: The SPECIALFILE Rule&rdquo;</XREF> describes the SPECIALFILE rule, used to match non-plain files.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="15180" TYPE="TITLE">&ldquo;Adding a Descriptive Phrase: The LEGEND Rule&rdquo;</XREF> describes the LEGEND rule, used to provide a brief phrase describing the application or data file.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="85210" TYPE="TITLE">&ldquo;Setting FTR Variables: The SETVAR Rule&rdquo;</XREF> describes how to set variables that affect the way your icon behaves.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="33157" TYPE="TITLE">&ldquo;Programming Open Behavior: The CMD OPEN Rule&rdquo;</XREF> describes the CMD OPEN rule, used to define what happens when users open the icon.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="33173" TYPE="TITLE">&ldquo;Programming Alt-Open Behavior: The CMD ALTOPEN Rule&rdquo;</XREF> describes the CMD ALTOPEN rule, used to define what happens when users double-click your icon while pressing the <USERINPUT>&lt;Alt></USERINPUT> key.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="91613" TYPE="TITLE">&ldquo;Programming Drag and Drop Behavior: The CMD DROP and DROPIF Rules&rdquo;</XREF> describes the CMD DROP rule, used to define what happens when a user drags another icon and drops it on top of your application's icon.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="45038" TYPE="TITLE">&ldquo;Mapping Names: The MAP Rule&rdquo;</XREF> describes the MAP rule, used to specify a list of all mappings from the desktop name space. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="40547" TYPE="TITLE">&ldquo;Programming Print Behavior: The CMD PRINT Rule&rdquo;</XREF> describes the CMD PRINT rule, used to tell the Desktop what to do when a user selects your icon, then selects &ldquo;Print&rdquo; from the Desktop popup menu.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="31739" TYPE="TITLE">&ldquo;Adding Menu Items: The MENUCMD Rule&rdquo;</XREF> describes the MENUCMD rule, used to add menu items to the Desktop menu</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="35039" TYPE="TITLE">&ldquo;Getting the Icon Picture: The ICON Rule&rdquo;</XREF> describes how to tell the Desktop where to find the file(s) containing the picture(s) of the icon for a file type</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="88324" TYPE="TITLE">&ldquo;Creating a File Type: An Example&rdquo;</XREF> provides a detailed example of how to program an icon.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="10520">A Table of the FTRs With Descriptions</TITLE><PARAGRAPH><INDEXTARGET ID="13.FTRs2"><!-- POSTPROCESSDATA: 13.FTRs2|File Typing Rules:description of --><XREF IDREF="56127" TYPE="TABLE">Table&nbsp;13-1</XREF> lists the rules that appear in a filetype definition along with brief descriptions.</PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="13-1"><PREFIX>Table 13-1 </PREFIX>&space; <EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="56127">Rules That Appear in a Filetype Definition</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="100"><PARAGRAPH>Rules </PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="273"><PARAGRAPH>Function </PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>TYPE</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="273"><PARAGRAPH>Declares a new type. <INDEXTARGET ID="13.FTRs3"><!-- POSTPROCESSDATA: 13.FTRs3|FTRs:TYPE rule --></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>SUPERTYPE<INDEXTARGET ID="13.FTRs4"><!-- POSTPROCESSDATA: 13.FTRs4|FTRs:SUPERTYPE rule --></PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="273"><PARAGRAPH>Tells the Desktop to treat the file as a subset of another type under 
certain circumstances.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>MATCH<INDEXTARGET ID="13.FTRs5"><!-- POSTPROCESSDATA: 13.FTRs5|FTRs:MATCH rule --></PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="273"><PARAGRAPH>Lets the Desktop determine if a file is of the declared type.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>SPECIALFILE<INDEXTARGET ID="13.FTRs6"><!-- POSTPROCESSDATA: 13.FTRs6|FTRs:SPECIALFILE rule --></PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="273"><PARAGRAPH>Tells the Desktop to use the file typing rule only on non-plain files.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>LEGEND<INDEXTARGET ID="13.FTRs7"><!-- POSTPROCESSDATA: 13.FTRs7|FTRs:LEGEND rule --></PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="273"><PARAGRAPH>Provides a text description of the file type.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>SETVAR<INDEXTARGET ID="13.FTRs8"><!-- POSTPROCESSDATA: 13.FTRs8|FTRs:SETVAR rule --></PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="273"><PARAGRAPH>Sets variables that affect the operation of your icon.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>CMD OPEN<INDEXTARGET ID="13.FTRs9"><!-- POSTPROCESSDATA: 13.FTRs9|FTRs:CMD OPEN rule --></PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="273"><PARAGRAPH>Defines a series of actions that occur when a user double-clicks the 
mouse on an icon or selects &ldquo;open&rdquo; from the main menu.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>CMD ALTOPEN<INDEXTARGET ID="13.FTRs10"><!-- POSTPROCESSDATA: 13.FTRs10|FTRs:CMD ALTOPEN rule --></PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="273"><PARAGRAPH>Defines a series of actions that occur when a user alt-double-clicks 
the mouse on an icon.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>CMD DROP<INDEXTARGET ID="13.FTRs11"><!-- POSTPROCESSDATA: 13.FTRs11|FTRs:CMD DROP rule --></PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="273"><PARAGRAPH>Defines a series of actions that occur when a user &ldquo;drops&rdquo; one icon 
on top of another.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>DROPIF<INDEXTARGET ID="13.FTRs12"><!-- POSTPROCESSDATA: 13.FTRs12|FTRs:DROPIF rule --></PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="273"><PARAGRAPH>Defines a set of file types that the icon will allow to be dropped on it.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>CMD PRINT<INDEXTARGET ID="13.FTRs13"><!-- POSTPROCESSDATA: 13.FTRs13|FTRs:CMD PRINT rule --></PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="273"><PARAGRAPH>Defines a series of actions that occur when a user chooses &ldquo;Print&rdquo; 
from the Desktop or Directory View menus.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>MENUCMD<INDEXTARGET ID="13.FTRs14"><!-- POSTPROCESSDATA: 13.FTRs14|FTRs:MENUCMD rule --></PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="273"><PARAGRAPH>Defines menu entries that appear in the Desktop menu and the 
Selected toolchest when an icon is selected.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>ICON<INDEXTARGET ID="13.FTRs15"><!-- POSTPROCESSDATA: 13.FTRs15|FTRs:ICON rule --></PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="273"><PARAGRAPH>Defines the appearance (geometry) of the file type's icon.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="100"><PARAGRAPH>MAP<INDEXTARGET ID="13.FTRs16"><!-- POSTPROCESSDATA: 13.FTRs16|FTRs:MAP rule --></PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="273"><PARAGRAPH>Maps the Desktop file-type name with the ICCCM or MIME 
target-type names. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>All file types must begin with a TYPE rule. Aside from that, the rules can appear in any order; however, the most efficient order for parsing is to include the MATCH rule second and the ICON rule last.</PARAGRAPH>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="50570"><XREFTARGET ID="10863">Naming File Types: The TYPE Rule</TITLE><PARAGRAPH>It is important that your file type have a unique name so that it doesn't collide with Silicon Graphics types or types added by other developers. A good way to generate a unique file type name is to base your file type name on your application name (which is presumably unique). Another method is to include your company's initials or stock symbol in the file type name. You can also use the<INDEXTARGET ID="13.FTRs17"><!-- POSTPROCESSDATA: 13.FTRs17|FTRs:TYPE ruleTYPE rule --><INDEXTARGET ID="13.FTRs18"><!-- POSTPROCESSDATA: 13.FTRs18|.ftr filesfiles:.ftr --><COMMAND>&space;grep</COMMAND>(1) command to search through existing <ITALICS>.ftr</ITALICS> files:</PARAGRAPH>
<EXAMPLE>
% <USERINPUT>grep </USERINPUT><VARIABLE>name</VARIABLE><USERINPUT>&space;/usr/lib/filetype/*/*.ftr</USERINPUT>&space;
</EXAMPLE>
<PARAGRAPH>Substitute your proposed new type name for the words <VARIABLE>name</VARIABLE>. If <COMMAND>grep</COMMAND> doesn't find your name, then go ahead and use it.</PARAGRAPH>
<PARAGRAPH>You name a file type by using the TYPE rule. You can define more than one file type in a single file, as long as each new file type begins with the TYPE rule. The TYPE rule always goes on the first line of the file type definition. </PARAGRAPH>
<PARAGRAPH>Here is the syntax and description for the TYPE rule:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><BOLD>Syntax:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>TYPE <ITALICS>type-name</ITALICS></PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Description:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH><VARIABLE>type-name</VARIABLE> is a one-word ASCII string. You can use a legal C language variable as a type name. Choose a name that is in some way descriptive of the file type it represents. All rules that follow a TYPE declaration apply to that type, until the next TYPE declaration is encountered in the FTR file. Each TYPE declaration must have a unique type name.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Example:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH><SCREENDISPLAY>TYPE GenericExecutable</SCREENDISPLAY></PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="27184">Categorizing File Types: The SUPERTYPE Rule</TITLE><PARAGRAPH>Use the SUPERTYPE rule to tell other file types that your file type should be treated as a &ldquo;subset&rdquo; of a larger type such as executables or directories. For example, you can create an executable with a custom icon, then use the SUPERTYPE rule to tell other Desktop file types that the icon represents an executable.<INDEXTARGET ID="13.FTRs19"><!-- POSTPROCESSDATA: 13.FTRs19|SUPERTYPE ruleFTRs:SUPERTYPE rule --></PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>In general, file types don't &ldquo;inherit&rdquo; icons, rules, or any other behavior from SUPERTYPEs. Directories are a special case. The Desktop automatically handles the DROP, OPEN, and ALTOPEN behavior for all directories marked as &ldquo;SUPERTYPE Directory.&rdquo; You can't override the DROP, OPEN, or ALTOPEN behavior if you include &ldquo;SUPERTYPE Directory.&rdquo;</NOTE>
<PARAGRAPH>You can use any existing file type as a SUPERTYPE. <XREF IDREF="44691" TYPE="TITLE">Appendix&nbsp;E, &ldquo;Predefined File Types,&rdquo;</XREF> lists some of the file types defined by Silicon Graphics. You can generate a complete list of file types installed on your system using the <COMMAND>grep</COMMAND>(1) command:</PARAGRAPH>
<EXAMPLE>
% <USERINPUT>grep TYPE /usr/lib/filetype/*/*.ftr</USERINPUT>&space;
</EXAMPLE>
<NOTE><PREFIX>Note</PREFIX>The list of file types generated by the above command is very long and unsorted.</NOTE>
<PARAGRAPH>Here is the syntax and description for the SUPERTYPE rule:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><BOLD>Syntax:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>SUPERTYPE <ITALICS>type-name</ITALICS> [<VARIABLE>type-name</VARIABLE> &hellip; ]</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Description:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH><ITALICS>type-name</ITALICS> is the TYPE name of any valid file type. Use SUPERTYPE to identify the file type as a &ldquo;subset&rdquo; of one or more other file types. This information can be accessed by other file types by calling <COMMAND>isSuper</COMMAND>(1) from within their CMD rules (OPEN, ALTOPEN, and so on). A file type can have multiple SUPERTYPEs. (For example, the Script file type has both Ascii and SourceFile SUPERTYPES.) See the <REFPAGE>isSuper(1)</REFPAGE> reference page for more information.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Example:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH><SCREENDISPLAY>SUPERTYPE Executable</SCREENDISPLAY></PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>A common use for SUPERTYPEs is to allow users to drag data files onto other application icons to open and manipulate them. For example, if your application uses ASCII data files but you create a custom data type for those files, you can include in the file type declaration:</PARAGRAPH>
<EXAMPLE>
SUPERTYPE Ascii
</EXAMPLE>
<PARAGRAPH>This allows users to drag your application's data files onto any text editor to open and view them. If your application creates images files, you could make a similar declaration to allow users to drag data file icons to appropriate image viewers such as <COMMAND>ipaste</COMMAND>(1).</PARAGRAPH>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="98067">Matching File Types With Applications: The MATCH Rule</TITLE><PARAGRAPH>The Desktop needs some way to figure out which FTRs pair up with which files. Your FTRs <INDEXTARGET ID="13.FTRs20"><!-- POSTPROCESSDATA: 13.FTRs20|MATCH ruleFTRs:MATCH rule --><ITALICS>will not work</ITALICS> if they don't include some way for the Desktop to match them with the appropriate files. To do this, include the MATCH rule in your file type definition. This section explains how to use the MATCH rule to identify your files. The method you use depends on the kind of file you are matching and on the file permissions. First, here's the MATCH rule syntax and description:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><BOLD>Syntax:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>MATCH <ITALICS>match-expression</ITALICS>;</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Description:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH><ITALICS>match-expression</ITALICS> is a logical expression that should evaluate to true if, and only if, a file is of the type declared by TYPE. The match-expression must consist only of valid MATCH functions, as described later in this section. The match-expression can use multiple lines, but must terminate with a semicolon (;). Multiple match-expressions are not permitted for a given type. The MATCH rule is employed each time a file is encountered by the Desktop, to assign a type to that file.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Examples:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH><SCREENDISPLAY>MATCH tag == 0x00001005;&lbreak;MATCH glob(&ldquo;myExecutabel&rdquo;);</SCREENDISPLAY></PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<SECTION2 LBL="" HELPID = ""><TITLE>Matching Tagged Files</TITLE><PARAGRAPH>The easiest way to match your application with its FTRs is to use the <INDEXTARGET ID="13.FTRs21"><!-- POSTPROCESSDATA: 13.FTRs21|matching tagged files<ITALICS>tag</ITALICS> command --><INDEXTARGET ID="13.FTRs22"><!-- POSTPROCESSDATA: 13.FTRs22|FTRs:matching tagged files --><COMMAND>tag</COMMAND>(1) command to assign a unique number to the application itself. You can then label the associated FTRs with this same unique number, using the MATCH rule, as shown in the example above.</PARAGRAPH>
<PARAGRAPH>There are a few situations in which you cannot use<COMMAND>&space;tag</COMMAND> to label your files. You cannot use <COMMAND>tag</COMMAND> if:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>your file is neither an executable nor a shell script</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>you don't have the necessary permissions to change the file</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>For more information on matching your files without using the <ITALICS>tag</ITALICS> command, see <XREF IDREF="56776" TYPE="TITLE">&ldquo;Matching Files Without the tag Command&rdquo;</XREF>.<XREFTARGET ID="35959"></PARAGRAPH>
<PARAGRAPH>To tag your application and its associated FTRs using the <ITALICS>tag</ITALICS> command, follow these steps:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>The <COMMAND>tag</COMMAND> command attaches an identification number to your application. Before you tag your application, select a number that is not already in use. Silicon Graphics assigns each company (or individual developer) a block of ID numbers for tagging files at no cost. If your company doesn't already have an assigned block of numbers, just send a request to Silicon Graphics. The best way is to e-mail your request to this address:</PARAGRAPH>
<EXAMPLE>
desktoptags@sgi.com
</EXAMPLE>
</LIST>
<LIST><PARAGRAPH>Once you have your block of numbers, you can select a number from the block of numbers assigned to your company. Make sure that you select a number that no one else in your company is using. </PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>After you select a unique tag number for your application, go to the directory that contains your application and tag it using the<COMMAND>&space;tag</COMMAND> command. This is the syntax:</PARAGRAPH>
<EXAMPLE>
% <USERINPUT>tag </USERINPUT><VARIABLE>number</VARIABLE>&space;<VARIABLE>filename</VARIABLE>&space;
</EXAMPLE>
<PARAGRAPH>Replace the word<ITALICS>&space;number </ITALICS>with the number that you are assigning to the application and <ITALICS>filename </ITALICS>with the name of your application. For more information on the <ITALICS>tag</ITALICS> command, see the<REFPAGE>&space;tag(1)</REFPAGE> reference page.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>After tagging the application itself, include the tag in your application's FTRs, using the MATCH rule. Just include a line like this in your FTR file:</PARAGRAPH>
<EXAMPLE>
MATCH tag ==<ITALICS>&space;number</ITALICS>;
</EXAMPLE>
<PARAGRAPH>where <ITALICS>number</ITALICS> is the unique tag number assigned to your application. </PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>You can also use the <COMMAND>tag</COMMAND> command to automatically assign a tag number for a predefined file type. Silicon Graphics provides a set of generic types, called predefined types, that you can use for utilities that do not require a personalized look. These predefined file types come complete with icons, FTRs, and tag numbers. Use the appropriate<COMMAND>&space;tag</COMMAND> command arguments to get the desired file type features. For more information on <COMMAND>tag</COMMAND> arguments, see the <REFPAGE>tag(1)</REFPAGE> reference page. The predefined file types are listed in <XREF IDREF="44691" TYPE="TITLE">Appendix&nbsp;E, &ldquo;Predefined File Types.&rdquo;</XREF></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="56776">Matching Files Without the <COMMAND>tag</COMMAND> Command</TITLE><PARAGRAPH>If you cannot use the <INDEXTARGET ID="13.FTRs23"><!-- POSTPROCESSDATA: 13.FTRs23|FTRs:matching files --><COMMAND>tag</COMMAND> command to match your application with the corresponding FTRs, you need to write a sequence of expressions that check files for distinguishing characteristics. Once you have written a sequence of expressions that adequately defines your application file, include that sequence in your FTR file, using the MATCH rule. For example, you can use this MATCH rule to match a C source file:</PARAGRAPH>
<EXAMPLE>
MATCH glob("*.c") &amp;&amp; ascii;
</EXAMPLE>
<PARAGRAPH>The <FUNCTION>glob</FUNCTION> function returns TRUE if the filename matches the string within the quotes. The <FUNCTION>ascii</FUNCTION> function returns TRUE if the first 512 bytes of the file are all printable ASCII characters. (<XREF IDREF="40184" TYPE="TABLE">Table&nbsp;13-3</XREF> lists all of the available match-expression functions.) The &amp;&amp; conditional operator tells the Desktop that the functions on either side of it must <ITALICS>both</ITALICS> return TRUE for a valid match. See <XREF IDREF="44766" TYPE="TITLE">&ldquo;Valid Match-Expressions&rdquo;</XREF> for a list of all of the operators, constants, and numerical representations that you can use in your match-expressions.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Writing Effective Match Expressions</TITLE><PARAGRAPH>The most effective way to order match-expressions in a single MATCH rule is to choose a set of expressions, each of which tests for a single characteristic, and conjoin them all using &ldquo;and&rdquo; conditionals (&amp;&amp;).<INDEXTARGET ID="13.FTRs24"><!-- POSTPROCESSDATA: 13.FTRs24|FTRs:writing MATCH expressions --></PARAGRAPH>
<PARAGRAPH>The order in which you list the expressions in a MATCH rule is important. Order the expressions so that the maximum number of files are &ldquo;weeded out&rdquo; by the first expressions. This is advised because the conditional operator, &amp;&amp;, stops evaluation as soon as one side of the conditional is found to be false. Therefore, the more likely an expression is to be false, the further to the left of the MATCH rule you should place it.</PARAGRAPH>
<PARAGRAPH>For instance, in the previous MATCH expression example, it is more efficient to place the <FUNCTION>glob</FUNCTION>("*.c") expression first because there are many more ASCII text files than there are files that end in .<ITALICS>c</ITALICS>.</PARAGRAPH>
<PARAGRAPH>Since the Desktop scans FTR files sequentially, you must make sure that your match rule is specific enough not to &ldquo;catch&rdquo; any unwanted files. For example, suppose you define a type named &ldquo;myDataFile&rdquo; using this MATCH rule:</PARAGRAPH>
<EXAMPLE>
MATCH ascii;
</EXAMPLE>
<PARAGRAPH>Now every text file in your system will be defined as a file of type &ldquo;myDataFile.&rdquo;</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="44766">Valid Match-Expressions</TITLE><PARAGRAPH>This section describes the syntax and function of valid match-expressions. You can use these C language operators in a match-expression:<INDEXTARGET ID="13.FTRs25"><!-- POSTPROCESSDATA: 13.FTRs25|FTRs:MATCH expressions --></PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>+</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>-</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>*</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>/ </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>&amp;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>| </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>^</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>! </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>%</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>( )</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>You can use these C language conditional operators in a match-expression:</PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>&amp;&amp;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>|| </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>==</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>!= </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>&lt;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>> </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>&lt;=</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>>=</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The `==' operator works for string comparisons in addition to numerical comparisons.</PARAGRAPH>
<PARAGRAPH>You can use these constants in a match-expression:</PARAGRAPH>
<EXAMPLE>
true false
</EXAMPLE>
<PARAGRAPH>You can represent numbers in match-expressions in decimal, octal, or hexadecimal notation. See <XREF IDREF="12188" TYPE="TABLE">Table&nbsp;13-2</XREF>.</PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="13-2"><PREFIX>Table 13-2 </PREFIX><XREFTARGET ID="12188">Numerical Representations in Match-Expressions</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="83"><PARAGRAPH>Representation</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="48"><PARAGRAPH>Syntax </PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH>decimal</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="48"><PARAGRAPH>num </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH>octal</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="48"><PARAGRAPH>0num </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="83"><PARAGRAPH>hexadecimal</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="48"><PARAGRAPH>0xnum</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Functions&space;</TITLE><PARAGRAPH><XREF IDREF="40184" TYPE="TABLE">Table&nbsp;13-3</XREF> lists the valid match-expression functions.</PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="13-3"><PREFIX>Table 13-3 </PREFIX><XREFTARGET ID="40184">Match-Expression Functions</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="90"><PARAGRAPH>Function Syntax</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="288"><PARAGRAPH>Definition </PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>ascii</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="288"><PARAGRAPH>Returns TRUE if the first 512 bytes of the file are all printable ASCII 
characters.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>char(<ITALICS>n</ITALICS>)</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="288"><PARAGRAPH>Returns the nth byte in the file as a signed character; range is -128 to 127.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>dircontains("<ITALICS>string</ITALICS>")</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="288"><PARAGRAPH>Returns TRUE if the file is a directory and contains the file named by 
string. Allows use of the following expansions in string for pattern 
matching: { } [ ] * ? and backslash (see <REFPAGE>sh</REFPAGE><REFPAGE>(1)</REFPAGE> filename expansion). See 
<XREF IDREF="46509" TYPE="TITLE">&ldquo;Using dircontains()&rdquo;</XREF>&space;for more information.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>glob("<ITALICS>string</ITALICS>")</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="288"><PARAGRAPH>Returns TRUE if the file's name matches string;. Allows use of the 
following expansions in string for pattern matching: { } [ ] * ? and 
backslash (see <REFPAGE>sh</REFPAGE><REFPAGE>(1)</REFPAGE> filename expansion).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>linkcount</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="288"><PARAGRAPH>Returns the number of hard links to the file.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>long(<ITALICS>n</ITALICS>)</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="288"><PARAGRAPH>Returns the nth byte in the file as a signed long integer; range is -231 to 
231 - 1.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>mode</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="288"><PARAGRAPH>Returns the mode bits of the file (see chmod(1)).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>print(<ITALICS>expr</ITALICS> or "<ITALICS>string</ITALICS>")</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="288"><PARAGRAPH>Prints the value of the expression expr or string to stdout each time the 
rule is evaluated; used for debugging. Always returns true.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>short(<ITALICS>n</ITALICS>)</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="288"><PARAGRAPH>Returns the nth byte of the file as a signed short integer; range is -32768 
to 32767.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>size</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="288"><PARAGRAPH>Returns the size of the file in bytes.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>string(<ITALICS>n</ITALICS>,<ITALICS>m</ITALICS>)</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="288"><PARAGRAPH>Returns a string from the file that is m bytes (characters) long, beginning 
at the nth byte of the file.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>uchar (<ITALICS>n</ITALICS>)</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="288"><PARAGRAPH>Returns the nth byte of the file as an unsigned character; range is 0 to 
255.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>tag</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="288"><PARAGRAPH>Returns the specific Desktop application tag injected into an executable 
file by the tag injection tool (see the <REFPAGE>tag(1)</REFPAGE> reference page.) Returns -1 if 
the file is not a tagged file.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>ushort(<ITALICS>n</ITALICS>)</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="288"><PARAGRAPH>Returns the nth byte of the file as an unsigned short integer; range is 0 
to 65535. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="46509">Using dircontains()</TITLE><PARAGRAPH>In order to use the <INDEXTARGET ID="13.FTRs26"><!-- POSTPROCESSDATA: 13.FTRs26|FTRs:<ITALICS>dircontains</ITALICS> function<ITALICS>dircontains</ITALICS> function --><FUNCTION>dircontains()</FUNCTION> function, you need to include these two rules in your filetype definition:</PARAGRAPH>
<CODE>
&nbsp;&nbsp;&nbsp;&nbsp;SUPERTYPE SpecialFile
&nbsp;&nbsp;&nbsp;&nbsp;SPECIALFILE
</CODE>
<PARAGRAPH>You can declare more than one SUPERTYPE in a file type, so the following would be a legal FTR file:</PARAGRAPH>
<CODE>
TYPE&nbsp;scrimshawToolsDir
&nbsp;&nbsp;&nbsp;&nbsp;MATCH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dircontains(".toolsPref");
&nbsp;&nbsp;&nbsp;&nbsp;LEGEND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scrimshaw&nbsp;drawing&nbsp;tools directory
&nbsp;&nbsp;&nbsp;&nbsp;SUPERTYPE&nbsp;&nbsp;&nbsp;&nbsp;Directory
&nbsp;&nbsp;&nbsp;&nbsp;SUPERTYPE&nbsp;&nbsp;&nbsp;&nbsp;SpecialFile
&nbsp;&nbsp;&nbsp;&nbsp;SPECIALFILE
&nbsp;&nbsp;&nbsp;&nbsp;ICON&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(opened)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;include("../iconlib/generic.folder.open.fti");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;include("../iconlib/generic.folder.closed.fti");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;include("iconlib/scrimshaw.tools.dir.fti");
&nbsp;&nbsp;&nbsp;&nbsp;}
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="30222">Predefined File Types</TITLE><PARAGRAPH>For some applications, you may not want to create a unique file type and icon. Several predefined file types exist and you can use them as necessary. If you use a predefined file type for your application, <INDEXTARGET ID="13.FTRs27"><!-- POSTPROCESSDATA: 13.FTRs27|FTRs:predefined file typesFTRs:file types, predefinedpredefined file types, FTRsfile types:predefined, FTRs --><COMMAND>tag</COMMAND> can automatically assign it a tag number. Just use the appropriate command line arguments as described in the<REFPAGE>&space;tag(1)</REFPAGE> reference page. The predefined file types and their tag numbers are listed in <XREF IDREF="44691" TYPE="TITLE">Appendix&nbsp;E</XREF>.</PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="92689">Matching Non-Plain Files: The SPECIALFILE Rule</TITLE><PARAGRAPH>SPECIALFILE is used to distinguish a file typing rule used for matching non-plain files. Device files and other non-plain files can cause damage to physical devices if they are matched using standard file typing rules (which might alter the device state by opening and reading the first block of the file).<INDEXTARGET ID="13.FTRs28"><!-- POSTPROCESSDATA: 13.FTRs28|FTRs:SPECIALFILE ruleSPECIALFILE rule --><INDEXTARGET ID="13.FTRs29"><!-- POSTPROCESSDATA: 13.FTRs29|FTRs:matching non-plain filesfiles:device filesdevice files:FTRsFTRs:device files --></PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><BOLD>Syntax:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>SPECIALFILE</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Description:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>Special files are matched using only rules containing SPECIALFILE, which are written so as not to interfere with actual physical devices. Similarly, plain files are not matched using rules containing a SPECIALFILE rule.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Example:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH><SCREENDISPLAY>SPECIALFILE</SCREENDISPLAY></PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<NOTE><PREFIX>Note</PREFIX>When you include the SPECIALFILE rule in your file type, you should also include the line:</NOTE>
<EXAMPLE>
SUPERTYPE SpecialFile
</EXAMPLE>
<PARAGRAPH>The SUPERTYPE declaration allows applications to use <COMMAND>isSuper</COMMAND>(1) to test whether your file type is a SPECIALFILE. </PARAGRAPH>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="15180">Adding a Descriptive Phrase: The LEGEND Rule</TITLE><PARAGRAPH>Use the LEGEND rule to provide the Desktop with a short phrase that describes the file type. This phrase appears when users view your icon's directory as a list. It also appears when a user selects your icon, then selects the &ldquo;Get File Info&rdquo; item from the Desktop menu. Make your legend simple and informative and keep it to 25 characters or less.<INDEXTARGET ID="13.FTRs30"><!-- POSTPROCESSDATA: 13.FTRs30|FTRs:LEGEND ruleLEGEND rule --></PARAGRAPH>
<PARAGRAPH>Here is the syntax and description for the LEGEND rule:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><BOLD>Syntax:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>LEGEND <ITALICS>text-string</ITALICS></PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Description:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH><ITALICS>text-string</ITALICS> is a string that describes the file type in plain language that a user can understand. Legends that are longer than 25 characters might be truncated in some circumstances.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Example:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH><SCREENDISPLAY>LEGEND C program source file</SCREENDISPLAY></PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>You might also see a LEGEND rule that is prepended with a number between two colons&mdash;something like this:</PARAGRAPH>
<EXAMPLE>
LEGEND :290:image in RGB format
</EXAMPLE>
<PARAGRAPH>The colons and the number between them are used for internationalization. For more information, refer to &ldquo;Internationalizing File Typing Rule Strings&rdquo; in Chapter&nbsp;4 of the <DOCTITLE>Topics in IRIX Programming</DOCTITLE>.</PARAGRAPH>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="85210">Setting FTR Variables: The SETVAR Rule</TITLE><PARAGRAPH>The SETVAR rule allows you to set variables that affect operation of your icon.<INDEXTARGET ID="13.FTRs31"><!-- POSTPROCESSDATA: 13.FTRs31|FTRs:SETVAR ruleSETVAR ruleFTRs:set variablesvariables:set, FTRs --></PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><BOLD>Syntax:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>SETVAR <ITALICS>variable</ITALICS>&space;<ITALICS>value</ITALICS>&space;</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Description:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH><ITALICS>variable</ITALICS> is a FTR variable and <ITALICS>value</ITALICS> is the value to assign to the variable. Currently, two FTR variables are supported: <VARIABLE>noLaunchEffect</VARIABLE> and <VARIABLE>noLaunchSound</VARIABLE>. Set <VARIABLE>noLaunchEffect</VARIABLE> to True to turn off the visual launch effect when the user opens your icon. Set <VARIABLE>noLaunchSound</VARIABLE> to True to turn off the launch sound effect when the user opens your icon.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Example:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH><SCREENDISPLAY>SETVAR noLaunchEffect True</SCREENDISPLAY>&space;</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="33157">Programming Open Behavior: The CMD OPEN Rule</TITLE><PARAGRAPH>Use the CMD OPEN rule to tell the Desktop what to do when a user opens your icon. Users can open an icon in any of these ways:<INDEXTARGET ID="13.FTRs32"><!-- POSTPROCESSDATA: 13.FTRs32|FTRs:CMD OPEN ruleCMD OPEN ruleFTRs:iconsicons:CMD OPEN rule --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>double-clicking it</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>selecting it and then choosing the &ldquo;Open&rdquo; item from the Desktop popup menu (the Desktop menu is the menu that appears when you hold down the right mouse button while the cursor is over the Desktop background)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>selecting it and then choosing the &ldquo;Open Icon&rdquo; selection in the Selected tool chest.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<NOTE><PREFIX>Note</PREFIX>Directories are a special case. The Desktop automatically handles the OPEN behavior for all files marked as &ldquo;SUPERTYPE Directory.&rdquo; You can't override the OPEN behavior if you include &ldquo;SUPERTYPE Directory.&rdquo;</NOTE>
<PARAGRAPH>Here is the syntax and description for the CMD OPEN rule:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><BOLD>Syntax:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>CMD OPEN<ITALICS>&space;sh-expression</ITALICS>[;<ITALICS>&space;sh-expression</ITALICS>; &hellip; ;<ITALICS>&space;sh-expression</ITALICS>]</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Description:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>The OPEN rule should reflect the most frequently used function that would be applied to a file of the given type. <ITALICS>sh-expression</ITALICS> can be any valid Bourne shell expression. Any expression can use multiple lines. Any number of expressions can be used, and must be separated by semicolons (;). The final expression should not end with a semicolon. Variables can be defined and used as in a Bourne shell script, including environment variables. See <XREF IDREF="71351" TYPE="TITLE">Appendix&nbsp;B</XREF> for a list of special environment variables set by the Desktop. These environment variables can be used to refer to the currently selected icons within the Desktop or Directory View.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Examples:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH><SCREENDISPLAY>CMD OPEN $WINEDITOR $SELECTED</SCREENDISPLAY></PARAGRAPH>
<PARAGRAPH>The CMD OPEN rule for the &ldquo;Makefile&rdquo; file type is more complex:<INDEXTARGET ID="13.FTRs33"><!-- POSTPROCESSDATA: 13.FTRs33|FTRs:CMD OPEN rule, MakefileMakefile:CMD OPEN rule --></PARAGRAPH>
<CODE>
TYPE Makefile
...
CMD OPEN&nbsp;echo "make -f $LEADER |&amp; tee $LEADER.log; rm $LEADER.run" \
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;> $LEADER.run; winterm -H -t make -c csh -f $LEADER.run
</CODE>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="33173">Programming Alt-Open Behavior: The CMD ALTOPEN Rule</TITLE><PARAGRAPH>By using the CMD ALTOPEN rule, you can tell the Desktop what to do when users double-click your icon while pressing the <INDEXTARGET ID="13.FTRs34"><!-- POSTPROCESSDATA: 13.FTRs34|FTRs:CMD ALTOPEN ruleCMD ALTOPEN ruleicons:double-clicking&lt;Alt\> keykeys:&lt;Alt\> --><USERINPUT>&lt;Alt></USERINPUT> key.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>Directories are a special case. The Desktop automatically handles the ALTOPEN behavior for all files marked as &ldquo;SUPERTYPE Directory.&rdquo; You can't override the ALTOPEN behavior if you include &ldquo;SUPERTYPE Directory.&rdquo;</NOTE>
<PARAGRAPH>Here is the syntax and description for the CMD ALTOPEN rule:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><BOLD>Syntax:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>CMD ALTOPEN <ITALICS>sh-expression</ITALICS>[; <ITALICS>sh-expression</ITALICS>; &hellip; ; <ITALICS>sh-expression</ITALICS>]</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Description:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>The ALTOPEN rule provides added functionality for power users. Typically, you set ALTOPEN to pop up a launch window to let the user edit arguments. <ITALICS>sh-expression</ITALICS> can be any valid Bourne shell expression. Any expression can use multiple lines. Any number of expressions can be used, and must be separated by semicolons (;). The final expression should not end with a semicolon. Variables can be defined and used as in a Bourne shell script, including environment variables. See <XREF IDREF="71351" TYPE="TITLE">Appendix&nbsp;B</XREF> for a list of special environment variables set by the Desktop. These environment variables can be used to refer to the currently selected icons within the Desktop or Directory View.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Examples:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH><SCREENDISPLAY>CMD ALTOPEN launch -c $LEADER $REST</SCREENDISPLAY></PARAGRAPH>
<PARAGRAPH>The CMD ALTOPEN rule for the &ldquo;SGIImage&rdquo; file type, defined in <INDEXTARGET ID="13.FTRs35"><!-- POSTPROCESSDATA: 13.FTRs35|CMD ALTOPEN rule:exampleIMGVIEWER environment variableenvironment variable:IMGVIEWER --><FILENAME>/usr/lib/filetype/system/sgiimage.ftr</FILENAME>, is more complex:</PARAGRAPH>
<CODE>
TYPE SGIImage
CMD ALTOPEN if test -n &ldquo;$IMGVIEWER&rdquo;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IMGVIEWER $LEADER $REST
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if test -x /usr/sbin/imgview
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imgview $LEADER $REST
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if test -x /usr/sbin/ipaste
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ipaste $LEADER $REST
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xconfirm -t &ldquo;&grave;gettxt uxsgidesktop:650
`/usr/sbin/imgview is missing.
Please install imgtools.sw.tools.'&grave;&rdquo; \
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-B &ldquo;&grave;gettxt uxsgidesktop:736 `Continue'&grave;&rdquo; >
/dev/null
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fi
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fi
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fi
</CODE>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>In the previous example:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>This filetype uses the IMGVIEWER environment variable. This is one of six environment variables the user can set on the Desktop Utilities panel (<FILENAME>/usr/sbin/dtUtilities</FILENAME>). Your filetype should make use of such utilities as well, if appropriate. For example, if your application needs to open some data into an editor for one of its rules, then the rule should check for the WINEDITOR variable and use it to open the data. For more information on <ITALICS>dtUtilities</ITALICS>, see Chapter 10, <XREF IDREF="73704" TYPE="TITLE">&ldquo;Using the Default Viewer and Editor Utilities Panel.&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>This filetype posts a dialog if it can't find any appropriate applications in which to open the SGIImage file. This dialog has text that you can translate into other languages; the embedded <SCREENDISPLAY>gettxt</SCREENDISPLAY> commands retrieve the text in the appropriate language from the specified <ITALICS>uxsgidesktop</ITALICS> message catalog. You can make a message catalog to hold your own messages, then use <SCREENDISPLAY>gettxt</SCREENDISPLAY> to make your filetypes use these messages. For more information, see Chapter 11, <XREF IDREF="17054" TYPE="TITLE">&ldquo;Step Three: Programming Your Icon.&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="91613">Programming Drag and Drop Behavior: The CMD DROP and DROPIF Rules</TITLE><PARAGRAPH>Users can perform certain functions by dragging an icon and dropping it on top of another icon. For example, users can move a file from one directory to another by dragging the icon representing the file and dropping it onto the icon representing the new directory. You use the CMD DROP rule to tell the Desktop what to do when a user drags another icon and drops it on top of your application's icon.<INDEXTARGET ID="13.FTRs36"><!-- POSTPROCESSDATA: 13.FTRs36|FTRs:CMD DROP ruleCMD DROP ruleicons:drag and dropdrag and drop icons --></PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>Directories are a special case. The Desktop automatically handles the DROP behavior for all files marked as &ldquo;SUPERTYPE Directory.&rdquo; You can't override the DROP behavior if you include &ldquo;SUPERTYPE Directory.&rdquo;</NOTE>
<PARAGRAPH>Here is the syntax and description for the CMP DROP rule:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><BOLD>Syntax:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>CMD DROP <ITALICS>sh-expression</ITALICS>[; <ITALICS>sh-expression</ITALICS>; &hellip; ; <ITALICS>sh-expression</ITALICS>]</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Description:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>The DROP rule is invoked whenever a selected (file) icon is &ldquo;dropped&rdquo; onto another icon in the Desktop or Directory View windows. When this happens, the Desktop checks to see if the file type being dropped upon has a DROP rule to handle the files being dropped. In this way, you can write rules that allow one icon to process the contents of other icons. Simply drag the selected icons that you want processed and put them on top of the target icon (that is, the one with the DROP rule).</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Example:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH><SCREENDISPLAY>CMD DROP $TARGET $SELECTED</SCREENDISPLAY></PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>By default, the CMD DROP rule handles all icons dropped on the target icon. However, if you include a DROPIF rule in your file type, only those icons whose file types are listed in the DROPIF rule are accepted as drop candidates; the Desktop doesn't allow the user to drop other types of icons on the target icon. Here is the syntax and description for the DROPIF rule:<INDEXTARGET ID="13.FTRs37"><!-- POSTPROCESSDATA: 13.FTRs37|FTRs:DROPIF ruleDROPIF rule --></PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><BOLD>Syntax:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH> DROPIF <ITALICS>file-type</ITALICS> [ <ITALICS>file-type</ITALICS>  &hellip;  <ITALICS>file-type</ITALICS>]</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Description:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>Specifies the allowable file types that a user can drop on the icon.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Example:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH><SCREENDISPLAY>DROPIF&nbsp;</SCREENDISPLAY>MailFile </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>Using the DROPIF rule in conjunction with the CMD DROP rule is a good practice to follow to ensure that the file types of selected icons are compatible with the selected icon. You can also use the environment variables set by the Desktop, listed in <XREF IDREF="71351" TYPE="TITLE">Appendix&nbsp;B</XREF>, to determine other attributes of the selected icons.</PARAGRAPH>
<PARAGRAPH>For example, the following CMD DROP and DROPIF rules accept only a single icon with the type &ldquo;MyAppDataFile&rdquo;:</PARAGRAPH>
<CODE>
DROPIF MyAppDataFile
CMD DROP&nbsp;&nbsp;&nbsp;&nbsp;if [ $ARGC -gt 1 ]
&space;           then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inform "Only one data file allowed."
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$TARGET $SELECTED
</CODE>
<PARAGRAPH>In the example above, the DROPIF rule prevents users from dropping any file on the target icon except those with the type &ldquo;MyAppDataFile.&rdquo; The CMD DROP rule is invoked only after a successful drop. It checks the value of the environment variable ARGC to see how many icons were dropped on the target icon. If more than one icon is dropped, it displays an error message; if only one is dropped, it invokes the application with the dropped file as an argument.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>The DROPIF rule doesn't &ldquo;follow&rdquo; SUPERTYPES. If you specify a file type in a DROPIF rule, only files of that type are accepted, not files that have that type as a SUPERTYPE.</NOTE>
<PARAGRAPH>If you want to handle all files with a given SUPERTYPE, you must use <COMMAND>isSuper</COMMAND>(1) to test for that SUPERTYPE in the CMD DROP rule. The following CMD DROP definition demonstrates this by accepting one or more files with an &ldquo;Ascii&rdquo; SUPERTYPE:</PARAGRAPH>
<CODE>
CMD DROP&nbsp;&nbsp;&nbsp;&nbsp;okfile='true'
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in $SELECTEDTYPELIST
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if isSuper Ascii $i > /dev/null
&space;                  then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;okfile='true'
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;okfile='false'
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fi
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;done
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;if [ $okfile = 'true' ]
&space;              then
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$TARGET $SELECTED
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xconfirm "$TARGET accepts only ASCII files."
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fi
</CODE>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="45038">Mapping Names: The MAP Rule</TITLE><PARAGRAPH>If you want your datafile to work with the GoldenGate conversion, which is based on ICCCM target type names, you need to use the MAP rule to associate the desktop file-type name with the ICCCM target-type name. Then GoldenGate can access the ICCCM type.<INDEXTARGET ID="13.FTRs38"><!-- POSTPROCESSDATA: 13.FTRs38|FTRs:MAP ruleMAP ruleICCCM targetstargets:ICCCMMIME typestypes:MIME --></PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><BOLD>Syntax:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>MAP <VARIABLE>namespace</VARIABLE>&space;<VARIABLE>value</VARIABLE></PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Description:</BOLD>
</HANGITEM>
<HANGBODY><PARAGRAPH><BOLD></BOLD>The MAP rules specify a list of all mappings from desktop name space to a non-desktop name. Desktop <VARIABLE>namespace</VARIABLE> is defined by the TYPE    names. The <VARIABLE>value</VARIABLE> is mapped onto the desktop type, which you can obtain based on the value or TYPE name. You can use the MAP rule to translate from a desktop TYPE to another name space, such as ICCCM or MIME types. In the example below, the keyword <SCREENDISPLAY>SelectionTarget</SCREENDISPLAY> indicates a ICCCM name space. </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>ICCCM Example:</BOLD>
</HANGITEM>
<HANGBODY><PARAGRAPH><BOLD></BOLD>&space;</PARAGRAPH>
<CODE>
TYPE AIFFSoundFile
MAP  SelectionTarget AIFF_FILE
</CODE>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>For more information about GoldenGate conversion, see<XREF IDREF="41465" TYPE="TITLE">, &ldquo;Using GoldenGate Data Conversion Services,&rdquo;</XREF> and <XREF IDREF="97061" TYPE="TITLE">&ldquo;Data Conversion Service&rdquo;</XREF>. </PARAGRAPH>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="40547">Programming Print Behavior: The CMD PRINT Rule</TITLE><PARAGRAPH>Use the CMD PRINT rule to tell the Desktop what to do when a user selects your icon, then selects &ldquo;Print&rdquo; from the Desktop popup menu. Here is the syntax and description for the CMD PRINT rule; see also <INDEXTARGET ID="13.FTRs39"><!-- POSTPROCESSDATA: 13.FTRs39|FTRs:CMD PRINT ruleCMD PRINT ruledesktop:printingdesktop:CMD PRINT rule --><XREF IDREF="55672" TYPE="TITLE">Chapter&nbsp;14, &ldquo;Printing From the Desktop,&rdquo;</XREF> for information on writing rules to convert your new file type into one of the printable types.</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><BOLD>Syntax:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>CMD PRINT <ITALICS>sh-expression</ITALICS>[; <ITALICS>sh-expression</ITALICS>; &hellip; ; <ITALICS>sh-expression</ITALICS>]</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Description:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH><ITALICS>sh-expression</ITALICS> can be any valid Bourne shell expression. Any expression can use multiple lines. Any number of expressions can be used, and must be separated by semicolons (;). The final expression should not end with a semicolon. Variables can be defined and used as in a Bourne shell script, including environment variables. See <XREF IDREF="71351" TYPE="TITLE">Appendix&nbsp;B</XREF> for a list of special environment variables set by the Desktop. These environment variables can be used to refer to the currently selected icons within the Desktop or Directory View. The recommended method of implementing the PRINT rule is to use <COMMAND>routeprint</COMMAND>, the Desktop's print-job routing utility, as in the example below. <COMMAND>routeprint</COMMAND> uses print conversion rules to automatically convert the selected files into formats accepted by the system's printers. See the <REFPAGE>routeprint(1)</REFPAGE> reference page for details on its syntax. See <XREF IDREF="55672" TYPE="TITLE">Chapter&nbsp;14</XREF> for information on setting up print conversion rules.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Example:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH><SCREENDISPLAY>CMD PRINT routeprint $LEADER $REST</SCREENDISPLAY></PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="31739">Adding Menu Items: The MENUCMD Rule</TITLE><PARAGRAPH>Use the MENUCMD rule to add items to the bottom of both the Desktop menu and the Selected toolchest menu. The Desktop menu is the menu that appears when you hold down the right mouse button while the cursor is positioned on the Desktop. The Selected toolchest menu is the menu that appears when you hold down the left mouse button while the cursor is positioned over the Selected toolchest menu. <INDEXTARGET ID="13.FTRs40"><!-- POSTPROCESSDATA: 13.FTRs40|FTRs:MENUCMD ruleMENUCMD ruledesktop:menu, MENUCMD rule --></PARAGRAPH>
<PARAGRAPH>Menu items added to the Desktop menu and the Selected toolchest menu appear only when the icon is selected (highlighted in yellow) on the Desktop. </PARAGRAPH>
<PARAGRAPH>You can add as many menu items as you like by adding multiple MENUCMD rules to your file type. Any menu items added using the MENUCMD rule are added both to the Desktop menu and the Selected toolchest menu&mdash;you can't add menu items to just one of these menus.</PARAGRAPH>
<PARAGRAPH>&space;Here is the syntax and description for the MENUCMD rule:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><BOLD>Syntax:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>MENUCMD "<ITALICS>string</ITALICS>" <ITALICS>sh-expression</ITALICS>[; <ITALICS>sh-expression</ITALICS>; &hellip; ; <ITALICS>sh-expression</ITALICS>]</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Description:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH>MENUCMD inserts the menu entry <ITALICS>string</ITALICS> into the Desktop or Directory View menu if a single file of the appropriate type is selected, or if a group of all of the same, appropriate type is selected. If the menu entry is chosen, the actions described by the<ITALICS>&space;sh-expressions</ITALICS> are performed on each of the selected files.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Example:</BOLD></HANGITEM>
<HANGBODY><PARAGRAPH><SCREENDISPLAY>MENUCMD "Empty Dumpster" compress $LEADER $REST</SCREENDISPLAY></PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>You might also see a MENUCMD rule that is prepended with a number between two colons&mdash;something like this:</PARAGRAPH>
<CODE>
MENUCMD :472:<SCREENDISPLAY>"</SCREENDISPLAY>make install<SCREENDISPLAY>"</SCREENDISPLAY> winterm -H -t 'make install' \
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-c make -f $LEADER install
</CODE>
<PARAGRAPH>The colons and the number between them are used for internationalization. For more information, refer to &ldquo;Internationalizing File Typing Rule Strings&rdquo; in Chapter&nbsp;4 of the <DOCTITLE>Topics in IRIX Programming</DOCTITLE>.</PARAGRAPH>
<PARAGRAPH>To add more than one menu item to the Desktop popup menu, just add a MENUCMD rule for each item. For example, the &ldquo;Makefile&rdquo; file type includes all of the following MENUCMD rules:</PARAGRAPH>
<CODE>
MENUCMD <SCREENDISPLAY>"</SCREENDISPLAY>make install<SCREENDISPLAY>"</SCREENDISPLAY> winterm -H -t 'make install' \
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-c make -f $LEADER install
MENUCMD <SCREENDISPLAY>"</SCREENDISPLAY>make clean<SCREENDISPLAY>"</SCREENDISPLAY> winterm -H -t 'make clean' \
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-c make -f $LEADER clean
MENUCMD <SCREENDISPLAY>"</SCREENDISPLAY>make clobber<SCREENDISPLAY>"</SCREENDISPLAY> winterm -H -t 'make clobber' \
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-c make -f $LEADER clobber
MENUCMD <SCREENDISPLAY>"</SCREENDISPLAY>Edit<SCREENDISPLAY>"</SCREENDISPLAY> $WINEDITOR $LEADER $REST
</CODE>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="35039">Getting the Icon Picture: The ICON Rule</TITLE><PARAGRAPH>Use the ICON rule, described in this section, to tell the Desktop where to find the file(s) containing the picture(s) of the icon for a file type. The simplest way to do this is to provide the full IRIX pathname. For example, if the <INDEXTARGET ID="13.FTRs41"><!-- POSTPROCESSDATA: 13.FTRs41|FTRs:ICON ruleICON ruleicons:ICON rule --><ITALICS>.fti</ITALICS> file is in the directory called <FILENAME>/usr/lib/filetype/install/iconlib</FILENAME>, you would simply write that pathname directly into your FTR file. </PARAGRAPH>
<PARAGRAPH>If you prefer not to use the absolute pathname in your FTR, you can use a relative pathname, as long as the icon file resides anywhere within the<FILENAME>&space;/usr/lib/filetype</FILENAME> directory structure. To make use of relative pathnames, list the pathname relative to the directory containing the FTR file that contains the ICON rule. If you choose to do this, take care to keep path names used in FTR files synchronized with icon locations.</PARAGRAPH>
<PARAGRAPH>The Desktop sets Boolean status variables to indicate the state of an icon. You can use conditional statements that test these variables to alter the appearance of an icon based on its state. The state variables are: opened, which is True when the icon is opened; and selected, which is True when the icon is selected.</PARAGRAPH>
<PARAGRAPH>As described in <XREF IDREF="27381" TYPE="TITLE">&ldquo;Importing Generic Icon Components (Magic Carpet)&rdquo; in Chapter&nbsp;12</XREF>, a common technique is to draw a unique badge to identify an application and then combine that badge with a generic icon component. This works well if you also use conditional statements to change the appearance of an icon depending on its state. You can then combine the unique badge with a generic icon component appropriate to the icon's state. The example shown below demonstrates this technique.</PARAGRAPH>
<PARAGRAPH>Use the basic format from the example below to tell the Desktop where to find your icon files (the files that you created using IconSmith). Here is the syntax and description for the ICON rule:</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM><BOLD>Syntax:</BOLD> </HANGITEM>
<HANGBODY><PARAGRAPH>ICON <ITALICS>icon-description-routine</ITALICS>&space;</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Description:</BOLD> </HANGITEM>
<HANGBODY><PARAGRAPH><ITALICS>icon-description-routine</ITALICS>&space;is a routine written using the icon description language, detailed below. The routine can continue for any number of lines. The ICON rule is invoked any time a file of the specified type needs to be displayed in the Desktop or Directory View. The rule is evaluated each time the icon is painted by the application that needs it.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM><BOLD>Examples:</BOLD> </HANGITEM>
<HANGBODY><PARAGRAPH><SCREENDISPLAY>ICON {</SCREENDISPLAY></PARAGRAPH>
<CODE>
if (opened) {
&nbsp;&nbsp;include("../iconlib/generic.exec.open.fti");
&nbsp;&nbsp;} else {
&nbsp;&nbsp;include("../iconlib/generic.exec.closed.fti");
&nbsp;&nbsp;}
&nbsp;&nbsp;include("iconlib/ack.fti");
}
</CODE>
<PARAGRAPH>The example above shows you exactly how to write the standard ICON rule. The first line invokes the ICON rule. The next two lines tell the Desktop where to find the parts of the icon representing the open and closed &ldquo;magic carpet&rdquo; that makes up the generic executable icons. The unique badge is in a file named <FILENAME>ack.fti</FILENAME><ITALICS>.</ITALICS></PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<NOTE><PREFIX>Note</PREFIX>You must include your badge <ITALICS>after</ITALICS> including the generic component so that it appears over the generic components when displayed on the Desktop.</NOTE>
<PARAGRAPH>If you have two separate badges, one for the open and one for the closed state, your ICON rule is:</PARAGRAPH>
<CODE>
ICON {
&nbsp;&nbsp;&nbsp;&nbsp;if (opened) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;include("../iconlib/generic.exec.open.fti");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;include("iconlib/ack.open.fti");
&nbsp;&nbsp;&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;include("../iconlib/generic.exec.closed.fti");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;include("iconlib/ack.closed.fti");
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</CODE>
<PARAGRAPH>Notice that this example gives the pathname of the icon files (<ITALICS>.fti</ITALICS> files) <ITALICS>relative</ITALICS> to the directory in which the FTR file is located. You can use the full pathname if you prefer. Your icon description routine would then look like this, assuming that <FILENAME>ack.fti</FILENAME> was placed in <FILENAME>/usr/lib/filetype/install/iconlib</FILENAME>:</PARAGRAPH>
<CODE>
ICON {
&nbsp;&nbsp;&nbsp;&nbsp;if (opened) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;include("/usr/lib/filetype/iconlib/genericexec.open..fti");
&nbsp;&nbsp;&nbsp;&nbsp;else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;include("/usr/lib/filetype/iconlib/generic.exec.close.fti");
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;include("/usr/lib/filetype/install/iconlib/ack.fti");
}
</CODE>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="88324">Creating a File Type: An Example</TITLE><PARAGRAPH>This section provides an example that demonstrates how to write a file type. In this example, assume we're writing a file type for a simple text editor called <INDEXTARGET ID="13.FTRs42"><!-- POSTPROCESSDATA: 13.FTRs42|FTRs: example, creating file typeFTRs:creating a file typeFTRs:file type, creatingcreating:FTR file typefiles:creating file type, FTR --><COMMAND>scribble</COMMAND> and that we've decided on these behaviors for the <COMMAND>scribble</COMMAND> icon:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>When a user double-clicks the<ITALICS>&space;scribble</ITALICS> icon, the Desktop runs the application.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>When a user drops another icon onto the <ITALICS>scribble</ITALICS> icon, the Desktop brings up the<ITALICS>&space;scribble</ITALICS> application with the file represented by the dropped icon. Users can then use the <COMMAND>scribble</COMMAND> application to edit this file.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>We're making no provision for rejecting icons that represent files unsuitable for editing. You could enhance the <ITALICS>scribble</ITALICS> file type by including a line that tells the Desktop to notify users when they drop an icon of the wrong type onto the <ITALICS>scribble</ITALICS> icon.</NOTE>
</BULLET>
</BULLETLIST>
<PARAGRAPH>(This section assumes that we're writing the file type completely from scratch. You might prefer instead to modify an existing file type. To learn how to find the FTRs for an existing icon, see <XREF IDREF="80328" TYPE="TITLE">&ldquo;Add the FTRs: An Alternate Method&rdquo;</XREF>.)</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Open an FTR File for <ITALICS>scribble</ITALICS></TITLE><PARAGRAPH>For the purposes of this example, assume we're creating a new FTR file, rather than adding to an existing one. We just open a new file using any editor we choose, then type in whatever file typing rules we decide to use.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Add the Rules to the <ITALICS>scribble</ITALICS> FTR File</TITLE><PARAGRAPH>Now that we've opened a file for the FTRs, we just type in the rules we need to program the icon. The file type has to begin with the TYPE rule on the first line. The TYPE rule names the file type. This section discusses each line we use to create the file type. </PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Line 1: Name the File Type</TITLE><PARAGRAPH>Each file type has to have a unique name. Since our application is called <COMMAND>scribble</COMMAND>, assume that we decide to name the new file type &ldquo;scribbleExecutable.&rdquo; By basing the file type name on the application name, we help insure a unique file type name. </PARAGRAPH>
<PARAGRAPH>Before using the name, <ITALICS>scribbleExecutable</ITALICS>, we search for it in the <FILENAME>/usr/lib/filetype</FILENAME> directory, to make sure that the name is not already in use:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Change to the <FILENAME>/usr/lib/filetype</FILENAME> directory:</PARAGRAPH>
<EXAMPLE>
% <USERINPUT>cd /usr/lib/filetype</USERINPUT>&space;
</EXAMPLE>
</LIST>
<LIST><PARAGRAPH>Search for the name scribbleExecutable:</PARAGRAPH>
<EXAMPLE>
% <USERINPUT>grep "scribbleExecutable" */*.ftr</USERINPUT>&space;
</EXAMPLE>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>Assume that we do not find an existing file type with the name &ldquo;scribbleExecutable,&rdquo; so that's what we name the new file type. </PARAGRAPH>
<PARAGRAPH>Now we use the TYPE rule to name the file type by typing this line into our FTR file:</PARAGRAPH>
<EXAMPLE>
TYPE scribbleExecutable
</EXAMPLE>
<PARAGRAPH>For more information on the TYPE rule, see <XREF IDREF="50570" TYPE="TITLE">&ldquo;Naming File Types: The TYPE Rule&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Line 2: Classify the Filetype</TITLE><PARAGRAPH>Next we use the SUPERTYPE rule to tell the Desktop what type of file the icon represents. Since<ITALICS>&space;scribble</ITALICS> is an executable, we add this line to the FTRs:</PARAGRAPH>
<EXAMPLE>
SUPERTYPE Executable
</EXAMPLE>
<PARAGRAPH>For more information on the SUPERTYPE rule, see <XREF IDREF="27184" TYPE="TITLE">&ldquo;Categorizing File Types: The SUPERTYPE Rule&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Line 3: Match the File Type</TITLE><PARAGRAPH>Now we add the scribble executable's tag number to the file type definition by adding this line to the FTRs:</PARAGRAPH>
<EXAMPLE>
MATCH   tag == 0x00001001;
</EXAMPLE>
<PARAGRAPH>This step assumes that we've already tagged the executable itself with the tag 0X001001, as described in <XREF IDREF="46561" TYPE="TITLE">&ldquo;Step One: Tagging Your Application&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>(Since <COMMAND>scribble</COMMAND> is an executable, we're able to use the <COMMAND>tag</COMMAND> command to tag it. If we were unable to use the <COMMAND>tag</COMMAND> command to assign an identification number to the application itself, we would need a slightly more complicated MATCH rule to match the application with its FTRs. For more information, see <XREF IDREF="98067" TYPE="TITLE">&ldquo;Matching File Types With Applications: The MATCH Rule&rdquo;</XREF> and <XREF IDREF="92689" TYPE="TITLE">&ldquo;Matching Non-Plain Files: The SPECIALFILE Rule&rdquo;</XREF>.)</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Line 4: Provide a Descriptive Phrase</TITLE><PARAGRAPH>Next we use the LEGEND rule to provide a <ITALICS>legend</ITALICS> for the file type. The legend is a brief descriptive phrase that appears when users view a directory as a list or select &ldquo;Get File Info&rdquo; from the Desktop menu. It should be simple, informative, and 25 characters or less. To add the legend for<ITALICS>&space;scribble</ITALICS>, add this line to the FTRs:</PARAGRAPH>
<EXAMPLE>
LEGEND scribble text editor
</EXAMPLE>
<PARAGRAPH>For more information on using the LEGEND rule, see <XREF IDREF="15180" TYPE="TITLE">&ldquo;Adding a Descriptive Phrase: The LEGEND Rule&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Line 5: Define Icon-Opening Behavior</TITLE><PARAGRAPH>We use the CMD OPEN rule to tell the Desktop what to do when users open the<ITALICS>&space;scribble </ITALICS>icon. In this example we want the Desktop to run the <COMMAND>scribble</COMMAND>&space;<COMMAND>application </COMMAND>when the icon is opened, so we include this line in the FTRs:</PARAGRAPH>
<EXAMPLE>
CMD OPEN $LEADER $REST
</EXAMPLE>
<PARAGRAPH>$LEADER refers to the opened application, in this case<ITALICS>&space;scribble</ITALICS>. The Desktop uses $LEADER to open $REST. In this case, $REST means any other selected icons in the same window. $LEADER and $REST are Desktop environmental variables. These variables are listed and described in <XREF IDREF="71351" TYPE="TITLE">Appendix&nbsp;B, &ldquo;Desktop Variables.&rdquo;</XREF></PARAGRAPH>
<PARAGRAPH>For more information on using the CMD OPEN rule, see <XREF IDREF="33157" TYPE="TITLE">&ldquo;Programming Open Behavior: The CMD OPEN Rule&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Line 6: Define Drag and Drop Behavior</TITLE><PARAGRAPH>We use the CMD DROP rule to tell the Desktop what to do when users drop another icon onto the<ITALICS>&space;scribble</ITALICS> icon. In this example we want the Desktop to open the <COMMAND>scribble</COMMAND>&space;<COMMAND>application </COMMAND>with the contents of the dropped file, so we include this line in the FTRs:</PARAGRAPH>
<EXAMPLE>
CMD DROP $TARGET $SELECTED
</EXAMPLE>
<PARAGRAPH>$TARGET refers to the icon that the user dropped another icon on, in this case <ITALICS>scribble</ITALICS>; $SELECTED refers to the icon that the user dropped onto the<ITALICS>&space;scribble</ITALICS> icon. $TARGET and $SELECTED are Desktop environmental variables. These variables are listed and described in <XREF IDREF="71351" TYPE="TITLE">Appendix&nbsp;B</XREF>.</PARAGRAPH>
<PARAGRAPH>For more information on the CMD DROP rule, see <XREF IDREF="91613" TYPE="TITLE">&ldquo;Programming Drag and Drop Behavior: The CMD DROP and DROPIF Rules&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Line 7: Define Alt-Open Behavior</TITLE><PARAGRAPH>We use the ALTOPEN rule to tell the Desktop what to do when users open the<ITALICS>&space;scribble </ITALICS>icon while holding down the <USERINPUT>&lt;Alt></USERINPUT> key. In this example, we want the Desktop to run the <COMMAND>launch</COMMAND>(1) program, so we include this line in the FTRs:</PARAGRAPH>
<EXAMPLE>
CMD ALTOPEN launch -c $LEADER $REST
</EXAMPLE>
<PARAGRAPH>Again, $LEADER refers to the opened application,<ITALICS>&space;scribble</ITALICS> and $REST refers to any other selected icons in the same window. <COMMAND>launch</COMMAND> runs the <COMMAND>launch</COMMAND> program, and <BOLD>-c</BOLD> is a command line argument to <COMMAND>launch</COMMAND>. </PARAGRAPH>
<PARAGRAPH>For more information on the CMD ALTOPEN rule, see <XREF IDREF="33173" TYPE="TITLE">&ldquo;Programming Alt-Open Behavior: The CMD ALTOPEN Rule&rdquo;</XREF>. See the <REFPAGE>launch(1)</REFPAGE> reference page for more information about using the <COMMAND>launch</COMMAND> command.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="70583">Line 8: Add the Icon Picture</TITLE><PARAGRAPH>We use the ICON rule to tell the Desktop where to find the picture for the<ITALICS>&space;scribble</ITALICS> icon. Assume we have an icon picture in the file <FILENAME>/usr/local/lib/install/iconlib/scribble.fti</FILENAME>. In this example, we add these lines to the FTRs:</PARAGRAPH>
<CODE>
ICON{
if (opened) {
&space;  include("../iconlib/generic.open.fti");
} else {
&space;  include("../iconlib/generic.closed.fti");
}
include("iconlib/scribble.fti");
}
</CODE>
<PARAGRAPH>These lines tell the Desktop how to find pictures for the<ITALICS>&space;scribble</ITALICS> icon in the opened and closed states.The pathname of the icon (<ITALICS>.fti</ITALICS>) files is listed relative to the location of the FTR file containing the ICON rule. Relative pathnames work as long as the icon files are located within the <FILENAME>/usr/lib/filetype</FILENAME> directory structure. Alternatively, you can use the absolute pathnames to the files: </PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><FILENAME>/usr/local/lib/iconlib/generic.open.fti</FILENAME>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><FILENAME>/usr/local/lib/iconlib/generic.closed.fti</FILENAME>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><FILENAME>/usr/local/lib/iconlib/scribble.fti</FILENAME>&space;</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>For more information on the ICON rule, see <XREF IDREF="35039" TYPE="TITLE">&ldquo;Getting the Icon Picture: The ICON Rule&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Name the <ITALICS>scribble</ITALICS> FTR File and Put It in the Appropriate Directory</TITLE><PARAGRAPH>Assume the name of our company is Shakespeare. Then according to the naming conventions in <XREF IDREF="58709" TYPE="TITLE">&ldquo;Naming FTR Files&rdquo;</XREF>, we should name our FTR file <FILENAME>Shakespeare.scribble.ftr</FILENAME>. We put the file in the <FILENAME>/usr/lib/filetype/install</FILENAME> directory.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="25205"><XREFTARGET ID="41208">The <ITALICS>scribble</ITALICS> FTRs</TITLE><PARAGRAPH>Here is the set of FTRs that we created to define the file type called &ldquo;scribbleExecutable.&rdquo;</PARAGRAPH>
<CODE>
TYPE scribbleExecutable
&space;  SUPERTYPE Executable
&space;  MATCH tag == 0x00001001;
&space;  LEGEND scribble text editor
&space;  CMD OPEN $LEADER $REST
&space;  CMD ALTOPEN launch -c $LEADER $REST
&space;  CMD DROP $TARGET $SELECTED
&space;  ICON {
&space;  if (opened) {
&space;     include("../iconlib/generic.open.fti");
&space;   } else {
&space;     include("../iconlib/generic.closed.fti");
&space;  }
&space;  include("iconlib/scribble.fti"):
} 
</CODE>
<PARAGRAPH></PARAGRAPH>
</SECTION2>
</SECTION1>
</CHAPTER>
