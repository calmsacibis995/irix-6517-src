<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="13"><TITLE><XREFTARGET ID="49713">Interactive Viewing of 3D Objects</TITLE><PARAGRAPH>Interactive viewing must be supported in the user interface of all 3D applications, even if those applications don't support editing. </PARAGRAPH>
<PARAGRAPH>Viewing 3D content is more complex than viewing a 2D image because of the added dimension. This added dimension means not only that there is more to look at, but also that there are more ways of looking at things. For example, users may want to view the sides, back, and top of a 3D model of a computer, walk through a virtual room, or fly through a 3D landscape. Interface designers have to determine the appropriate viewing functionality for their application and implement it in a consistent and intuitive way. </PARAGRAPH>
<PARAGRAPH>This chapter discusses interactive viewing of 3D objects in these sections: </PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="15212" TYPE="TITLE">&ldquo;Introduction to 3D Viewing&rdquo;</XREF> provides an introduction to the viewing paradigm and discusses some terminology.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="58437" TYPE="TITLE">&ldquo;3D Viewing Functions&rdquo;</XREF> introduces inspection and navigation, which are two different viewing modes, and describes the viewing functions an application needs to support in each mode. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="94814" TYPE="TITLE">&ldquo;3D Viewing Interface Trade-Offs&rdquo;</XREF> discusses 3D application design issues that developers typically must address and provides recommendations for resolving these issues. </PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="15212">Introduction to 3D Viewing</TITLE><PARAGRAPH>3D viewing can be thought of as using a camera to view the world. The following concepts are used in this document to describe the user interface to viewing functions (see <XREF IDREF="26229" TYPE="GRAPHIC">Figure&nbsp;13-1</XREF>): </PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><BOLD>Eyepoint</BOLD>. The eyepoint is the position of the user's eye. The camera is always positioned at the eyepoint. As the user moves the location of the camera, the location of the eyepoint also changes.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Viewing area. The viewing area is what the user can currently see while looking through the camera. It's what the user sees in the application's viewport.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><BOLD>Viewing direction</BOLD>. The viewing direction refers to how the camera is oriented in space. As the user turns the camera to the left or right or tilts the camera up or down, the viewing direction changes accordingly. As the user changes the viewing direction, the contents of the viewing area also changes. In effect, the user is looking through the camera at a different part of the scene.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><BOLD>Look-at point</BOLD>. The look-at point is the current center of interest within the scene. The camera's viewing direction is always aimed so that the look-at point is in the center of the viewing area.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="view_intro.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="13-1"><PREFIX>Figure 13-1 </PREFIX><XREFTARGET ID="26229">The Camera Analogy in 3D Viewing</CAPTION>
</FIGURE>
</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="58437">3D Viewing Functions</TITLE><PARAGRAPH>In the context of this document, <ITALICS>viewing<INDEXTARGET ID="ch13.3Dview1"><!-- POSTPROCESSDATA: ch13.3Dview1|viewing:3D definition 3D applications:viewing techniques viewing:<ITALICS>See Also</ITALICS> inspection, navigation --></ITALICS> refers to manipulating a camera to view the contents of a 3D application (see <XREF IDREF="15212" TYPE="TITLE">&ldquo;Introduction to 3D Viewing&rdquo;</XREF>). This document distinguishes between the two basic viewing modes, inspection and navigation. Every 3D application needs to support at least one; if your application supports both, pick one as the primary mode.</PARAGRAPH>
<PARAGRAPH>Although viewing refers to manipulating a camera in a 3D application, users may base their interaction with the application on a different metaphor. These fundamental metaphors are also discussed in the following sections. For example, during inspection users interact with the scene (or object) they are viewing as if it were a single object that they are holding in their hand. They expect to be able to move this scene (or object) around in space (see <XREF IDREF="93079" TYPE="TITLE">&ldquo;3D Viewing Trade-Offs and Related Guidelines&rdquo;</XREF>). Application developers, on the other hand, find it useful to implement the inspection functions in terms of a camera that moves around the scene being viewed. It's important that your application allows users to work with viewing functions using the metaphors they expect regardless of how the application implements them.</PARAGRAPH>
<PARAGRAPH>This section describes the different functions available in inspection and in navigation. <XREF IDREF="83685" TYPE="TABLE">Table&nbsp;13-1</XREF> provides an overview of each function, the mouse and key bindings used to access it, and the pointer shape displayed when the user is accessing it. Each function is discussed in detail in the following sections.</PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="13-1"><PREFIX>Table 13-1 </PREFIX><XREFTARGET ID="83685"> <EMPHASIS>(continued)        </EMPHASIS>3D Viewing Functions and User Interface</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="54"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="72"><PARAGRAPH>View Mode</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="57"><PARAGRAPH>Pointer</PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="208"><PARAGRAPH>Mouse and Keyboard Binding</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><XREF IDREF="90557" TYPE="TEXT">Tumbling</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="72"><PARAGRAPH>Inspection 
(default)&lbreak;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="57"><PARAGRAPH><FIGURE><GRAPHIC FILE="tumble_cursor.gif" POSITION="TBLCELL" SCALE="FALSE"></FIGURE>
</PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="208"><PARAGRAPH>Dragging with the left mouse button.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><XREF IDREF="34136" TYPE="TEXT">Dollying</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="72"><PARAGRAPH>Inspection</PARAGRAPH>
<PARAGRAPH>&lbreak;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="57"><PARAGRAPH><FIGURE><GRAPHIC FILE="dolly_cursor.gif" POSITION="TBLCELL" SCALE="FALSE"></FIGURE>
</PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="208"><PARAGRAPH>Dragging while simultaneously pressing the left 
and middle mouse buttons.<INDEXTARGET ID="ch13.3Dview2"><!-- POSTPROCESSDATA: ch13.3Dview2|viewing: overview of techniques --></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><XREF IDREF="97362" TYPE="TEXT">Panning</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="72"><PARAGRAPH>Inspection&lbreak;&lbreak;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="57"><PARAGRAPH><FIGURE><GRAPHIC FILE="pan_cursor.gif" POSITION="TBLCELL" SCALE="FALSE"></FIGURE>
</PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="208"><PARAGRAPH>Dragging with the middle mouse button.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><XREF IDREF="82935" TYPE="TEXT">Roaming</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="72"><PARAGRAPH>Navigation 
(default)&lbreak;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="57"><PARAGRAPH><FIGURE><GRAPHIC FILE="walk_cursor.gif" POSITION="TBLCELL" SCALE="FALSE"></FIGURE>
</PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="208"><PARAGRAPH>Dragging with the left mouse button.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><XREF IDREF="61562" TYPE="TEXT">Tilting</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="72"><PARAGRAPH>Navigation&lbreak;&lbreak;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="57"><PARAGRAPH><FIGURE><GRAPHIC FILE="tilt_cursor.gif" POSITION="TBLCELL" SCALE="FALSE"></FIGURE>
</PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="208"><PARAGRAPH>Dragging while simultaneously pressing the left 
and middle mouse buttons.<INDEXTARGET ID="ch13.3Dview3"><!-- POSTPROCESSDATA: ch13.3Dview3|viewing: overview of techniques --></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><XREF IDREF="43061" TYPE="TEXT">Sidling</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="72"><PARAGRAPH>Navigation&lbreak;&lbreak;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="57"><PARAGRAPH><FIGURE><GRAPHIC FILE="sidle_cursor.gif" POSITION="TBLCELL" SCALE="FALSE"></FIGURE>
</PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="208"><PARAGRAPH>Dragging with the middle mouse button.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><XREF IDREF="88303" TYPE="TEXT">Seeking</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="72"><PARAGRAPH>Inspection and 
Navigation</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="57"><PARAGRAPH><FIGURE><GRAPHIC FILE="seek_cursor.gif" POSITION="TBLCELL" SCALE="FALSE"></FIGURE>
</PARAGRAPH>
</CELL>
<CELL LEFT="205" WIDTH="208"><PARAGRAPH>Clicking with the left mouse button.<TABLEXREF IDREF="ch13.3DviewTF0a">a</TABLEXREF></PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
<TABLEFOOTNOTE LBL="a" ID="ch13.3DviewTF0a">Many applications need to reserve clicking with the left mouse button for a more useful function (for example, 
activating a link or initiating object behavior). In those applications, allow users to first activate a seek tool, 
then click in the scene with the left mouse button to seek.</TABLEFOOTNOTE>
</TABLE>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="34679">Inspection Functions for 3D Viewing</TITLE><PARAGRAPH>This section first gives an overview of inspection, then describes three viewing functions that apply only to inspection (and not to navigation):</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="90557" TYPE="TITLE">&ldquo;Tumbling&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="34136" TYPE="TITLE">&ldquo;Dollying&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="97362" TYPE="TITLE">&ldquo;Panning&rdquo;</XREF></PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The section also discusses <XREF IDREF="88303" TYPE="TITLE">&ldquo;Seeking,&rdquo;</XREF> which has the same effect in both inspection and navigation.</PARAGRAPH>
<PARAGRAPH>Each function is first presented from the user's point of view, then discussed in terms of the implementation model. </PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="10928">Inspection Overview</TITLE><PARAGRAPH>Inspection is an approach to viewing where users can examine a scene as if it's a single object they are holding in their hand. For example, users may want to examine the model of a coffee mug the same way they would examine a real mug by holding it and turning it around.<INDEXTARGET ID="ch13.3Dview4"><!-- POSTPROCESSDATA: ch13.3Dview4|inspection:overview --></PARAGRAPH>
<PARAGRAPH>The expected user model for inspection is that users are manipulating the scene, not the camera. From the users' perspective, all inspection controls appear to manipulate the scene (or object) while the camera remains stationary. For example: </PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Pressing the left mouse button and dragging the pointer down (tumbling) rotates the object towards the user. To achieve this, the application actually moves the camera up over the object (see <XREF IDREF="33764" TYPE="GRAPHIC">Figure&nbsp;13-2</XREF>).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Pressing the middle mouse button and dragging the pointer to the left (panning) moves the scene toward the left of the viewing window. To achieve this, the application moves the camera to the right (see <XREF IDREF="75531" TYPE="GRAPHIC">Figure&nbsp;13-5</XREF>).</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Note that in both examples, users move the control (and pointer) in the direction they want the scene (or object) to move. To achieve this, the application moves the camera in the opposite direction of the control (and pointer). </PARAGRAPH>
<PARAGRAPH><XREF IDREF="29484" TYPE="TABLE">Table&nbsp;13-2</XREF> provides an overview of the different functions available in inspection. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="13-2"><PREFIX>Table 13-2 </PREFIX><XREFTARGET ID="29484">  <EMPHASIS>(continued)        </EMPHASIS>Overview of Inspection Viewing Functions</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="54"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="141"><PARAGRAPH>User Model</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="200"><PARAGRAPH>Implementation Model</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><XREF IDREF="90557" TYPE="TEXT">Tumbling</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="141"><PARAGRAPH>User holds object and rotates it to 
view it from all sides and angles.</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="200"><PARAGRAPH>Camera (eyepoint) moves around a fixed look-at 
point on a spherical course. Camera moves 
opposite to direction of user's action.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><XREF IDREF="34136" TYPE="TEXT">Dollying</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="141"><PARAGRAPH>User moves object closer or farther 
away.</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="200"><PARAGRAPH>Camera (eyepoint) moves toward a fixed look-at 
point to move object closer and moves away from 
look-at point to move object farther away. 
Viewing direction remains unchanged.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><XREF IDREF="97362" TYPE="TEXT">Panning</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="141"><PARAGRAPH>User moves object up, down, left, 
or right in viewing window. </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="200"><PARAGRAPH>Camera (eyepoint) moves in plane perpendicular 
to viewing direction. Camera moves opposite to 
movement of object. Viewing direction is 
unchanged. Look-at point moves with camera.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><XREF IDREF="88303" TYPE="TEXT">Seeking</XREF></PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="141"><PARAGRAPH>User selects object (or part of 
object). Selected object is centered 
in viewing window and moved 
closer to user with each click. </PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="200"><PARAGRAPH>Look-at point moves to where user clicked in the 
scene. Camera (eyepoint) turns so that look-at 
point is centered in viewing window. Camera 
moves closer by half the original distance 
between camera and object. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="90557">Tumbling</TITLE><PARAGRAPH>Tumbling is the default viewing function for inspection. Users rotate a model of an object or a scene as if they were holding it in their hand. Users expect to be able to tumble the object in all three dimensions around the fixed look-at point. Tumbling doesn't change the location of the object in space.<INDEXTARGET ID="ch13.3Dview5"><!-- POSTPROCESSDATA: ch13.3Dview5|tumbling inspection:tumbling --></PARAGRAPH>
<PARAGRAPH>The user controls tumbling by dragging with the left mouse button. The movement follows a virtual trackball imposed on the viewing window. The initial position of the pointer on this virtual trackball influences the tumbling behavior: If the user positions the pointer in the center of the viewing window (trackball) and drags horizontally (or vertically), the object tumbles around the y axis (or x axis). If the user positions the pointer in the center of the viewing window and drags out in any direction, the object tumbles around an axis perpendicular to the drag. If the user drags in a circle around the center of the virtual trackball, the object tumbles around the z axis. If the user drags beyond the limits of the trackball, the object continues to tumble until the user releases the mouse button.</PARAGRAPH>
<PARAGRAPH><XREF IDREF="33764" TYPE="GRAPHIC">Figure&nbsp;13-2</XREF> illustrates tumbling from the implementation perspective. The camera (eyepoint) moves around the scene as though the camera were placed on the surface of a sphere. The look-at point remains stationary at the center of the sphere. The camera moves opposite to the direction of the rotation. Using the original camera position, the user can look into the pot but can't see much of the pot's outside surface. After the user has tumbled the bottom of the pot upwards, it's possible to see the pot's surface. To accomplish this rotation, the eyepoint (camera) moves down along the surface of the sphere and the look-at point remains stationary. <INDEXTARGET ID="ch13.3Dview6"><!-- POSTPROCESSDATA: ch13.3Dview6|eyepoint during tumbling look-at point during tumbling --></PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="tumbling.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="13-2"><PREFIX>Figure 13-2 </PREFIX><XREFTARGET ID="33764">Schematic Illustration of Tumbling (Implementation Perspective)</CAPTION>
</FIGURE>
</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="34136">Dollying</TITLE><PARAGRAPH>Dollying allows users to move a model of an object or a scene closer or farther away. Users move the object as if they were holding it in their hand. The user controls dollying by dragging while simultaneously pressing the left and middle mouse buttons during inspection. Dragging down in the viewing window moves the object closer; dragging up moves it farther away. <INDEXTARGET ID="ch13.3Dview7"><!-- POSTPROCESSDATA: ch13.3Dview7|dollying inspection:dollying --></PARAGRAPH>
<PARAGRAPH><XREF IDREF="43472" TYPE="GRAPHIC">Figure&nbsp;13-3</XREF> illustrates dollying from the implementation perspective. The look-at point and viewing direction are fixed. The camera (eyepoint) moves toward the look-at point along the viewing direction to move the object closer to the user. If the user wants to move the object further away, the camera would move away from the look-at point.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="dollying.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="13-3"><PREFIX>Figure 13-3 </PREFIX><XREFTARGET ID="43472">Schematic Illustration of Dollying (Implementation Perspective) </CAPTION>
</FIGURE>
</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>When users move closer to an object, they eventually reach the point where they would touch the object. As they dolly even farther forward, the eyepoint moves past the (fixed) look-at point as if the user just moved through the object. When the user passes this point, the tumble controls are &ldquo;reversed&rdquo; because the user is now dragging along the inside of the virtual trackball (see <XREF IDREF="90557" TYPE="TITLE">&ldquo;Tumbling&rdquo;</XREF>) and along its backside. <INDEXTARGET ID="ch13.3Dview8"><!-- POSTPROCESSDATA: ch13.3Dview8|dollying:moving through object --></NOTE>
<PARAGRAPH>Dollying is different from zooming. In both cases the objects change in size in the viewing window. However, in contrast to dollying, zooming doesn't move the object closer or farther away from the user. Zooming instead allows users to change the viewing angle of the camera, the same way they would use a zoom lens on an actual camera. That is, as the user zooms out the viewing angle is increased so that the viewing area becomes larger and more of the scene is visible. This new larger viewing area is then mapped to the viewing window. <INDEXTARGET ID="ch13.3Dview9"><!-- POSTPROCESSDATA: ch13.3Dview9|zooming --></PARAGRAPH>
<PARAGRAPH>As shown in <XREF IDREF="31766" TYPE="GRAPHIC">Figure&nbsp;13-4</XREF>, objects appear larger (or smaller) after zooming in (or out) even though the location of the camera hasn't changed. This is because the viewing angle changes but the size of the viewing window hasn't changed.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="zooming.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="13-4"><PREFIX>Figure 13-4 </PREFIX><XREFTARGET ID="31766">Schematic Illustration of Zooming (Implementation Perspective)</CAPTION>
</FIGURE>
</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="97362">Panning</TITLE><PARAGRAPH>Panning allows users to move a model of an object or a scene up, down, left, or right in the viewing window. Users move the object as if they were holding it in their hand. The user controls panning by dragging while pressing the middle mouse button. The object moves in the direction of the drag; for example, dragging up in the viewing window moves the object up and dragging left moves the object left.<INDEXTARGET ID="ch13.3Dview10"><!-- POSTPROCESSDATA: ch13.3Dview10|panning inspection:panning --></PARAGRAPH>
<PARAGRAPH><XREF IDREF="75531" TYPE="GRAPHIC">Figure&nbsp;13-5</XREF> illustrates panning from the implementation perspective. The camera (eyepoint) moves in the plane perpendicular to the viewing direction. The camera moves opposite to the movement of the object. As shown in the figure, the camera moves right, which moves the scene to the left in the viewing window. The look-at point moves with the camera. The viewing direction is unchanged.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="panning.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="13-5"><PREFIX>Figure 13-5 </PREFIX><XREFTARGET ID="75531">Schematic Illustration of Panning (User Drags Right)</CAPTION>
</FIGURE>
</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="88303">Seeking</TITLE><PARAGRAPH>Seeking allows users to move an object in the scene into the center of the viewing window. In inspection, the user model is that the user is incrementally moving the object closer (see <INDEXTARGET ID="ch13.3Dview11"><!-- POSTPROCESSDATA: ch13.3Dview11|seeking --><XREF IDREF="10928" TYPE="TITLE">&ldquo;Inspection Overview&rdquo;</XREF>). In navigation, the user model is that the user is incrementally moving closer to the object (see <XREF IDREF="83395" TYPE="TITLE">&ldquo;Navigation Overview&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH> For both inspection and navigation, the user controls seeking by clicking on the object (or part of the object) of interest. Clicking on the object centers the object (or part) in the viewing window and brings the object and user closer together. Each additional click on the same object (or part) brings the object and user still closer. <XREF IDREF="47218" TYPE="GRAPHIC">Figure&nbsp;13-6</XREF> shows a simple example of seeking to the door of a house. The first click on the door positions the door in the center of the viewing window and halves the distance between the door and the user. The second click halves the distance again.</PARAGRAPH>
<PARAGRAPH>Many applications need to reserve clicking with the left mouse button for a more critical or useful function (for example, activating a link or initiating object behavior). In those applications, allow users to first activate a seek tool, then click with the left mouse button in the scene to actually seek.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="seeking.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="13-6"><PREFIX>Figure 13-6 </PREFIX><XREFTARGET ID="47218">Simple Example of Seeking to Door</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>From the implementation perspective, seeking sets a new look-at point at the location of the user's click and moves the camera so that this new look-at point is at the center of the viewing window. The camera is also moved forward half the original distance between the camera and the object. Note that in the case of inspection, resetting the look-at point by seeking means that the camera tumbles around this new point after the seeking action. </PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="33502">Navigation Functions for 3D Viewing</TITLE><PARAGRAPH>This section first gives an overview of navigation, then describes three viewing functions that apply only to navigation (and not to inspection):</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="82935" TYPE="TITLE">&ldquo;Roaming&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="61562" TYPE="TITLE">&ldquo;Tilting&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="43061" TYPE="TITLE">&ldquo;Sidling&rdquo;</XREF></PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH><XREF IDREF="88303" TYPE="TITLE">&ldquo;Seeking,&rdquo;</XREF> which has the same effect in both inspection and navigation, is discussed in the preceding section.</PARAGRAPH>
<PARAGRAPH>Each function is first presented from the user's point of view, then discussed in terms of the implementation model. </PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="83395">Navigation Overview</TITLE><PARAGRAPH>Navigation is useful when users want to move through a world, for example, walk through a 3D model of a museum or an architectural model. In navigation, the user maneuvers through a fixed, immovable world by walking, flying, or another navigation mechanism. <INDEXTARGET ID="ch13.3Dview12"><!-- POSTPROCESSDATA: ch13.3Dview12|navigation:overview --></PARAGRAPH>
<PARAGRAPH>The expected user model for navigation is that users are manipulating the camera. From the users' perspective, all navigation controls appear to manipulate the camera while the scene remains stationary. For example: </PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Pressing the left mouse button and dragging the pointer up while roaming moves the user farther forward into the scene. To achieve this, the application also moves the camera farther into the scene (see <XREF IDREF="25744" TYPE="GRAPHIC">Figure&nbsp;13-7</XREF>).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Pressing the middle mouse button and dragging the pointer to the left while sidling sidesteps the user towards the left of the viewing window. To achieve this, the application also moves the camera to the left (see <XREF IDREF="47995" TYPE="GRAPHIC">Figure&nbsp;13-9</XREF>).</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Note that in both examples, users move the control (and pointer) in the direction they want the camera to move. </PARAGRAPH>
<PARAGRAPH><XREF IDREF="66993" TYPE="TABLE">Table&nbsp;13-3</XREF> provides an overview of the different functions available in navigation.</PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="13-3"><PREFIX>Table 13-3 </PREFIX><XREFTARGET ID="66993"> Overview of Navigation Viewing Functions</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="47"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="138"><PARAGRAPH>User Model</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="200"><PARAGRAPH>Implementation Model</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="47"><PARAGRAPH>Roaming</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="138"><PARAGRAPH>User moves forward or backward 
in the scene. Turning changes 
direction of movement.</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="200"><PARAGRAPH>Camera (eyepoint) moves forward or backward 
along viewing direction in the same direction as 
the user action. Viewing direction moves in the 
direction that the user turns. Look-at point 
changes as the viewing direction changes.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="47"><PARAGRAPH>Tilting</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="138"><PARAGRAPH>User looks up or down. </PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="200"><PARAGRAPH>Viewing direction moves in the direction that the 
user looks (up or down). Position of camera 
(eyepoint) remains fixed. Look-at point changes 
as the viewing direction changes. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="47"><PARAGRAPH>Sidling</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="138"><PARAGRAPH>User sidesteps left or right in the 
scene or &ldquo;elevators&rdquo; up or down 
in the scene.</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="200"><PARAGRAPH>Camera (eyepoint) moves in plane perpendicular 
to viewing direction. Camera moves in the same 
direction as user action. Viewing direction 
remains unchanged. Look-at point moves with 
camera. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="47"><PARAGRAPH>Seeking</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="138"><PARAGRAPH>User selects object (or part of 
object). Selected object is centered 
in viewing window and moved 
closer to user with each click. </PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="200"><PARAGRAPH>Look-at point moves to where user clicked in the 
scene. Camera (eyepoint) turns so that look-at 
point is centered in viewing window. Camera 
moves closer by half the original distance 
between camera and object. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="82935">Roaming</TITLE><PARAGRAPH>Roaming (and turning) is the default viewing function for navigation. Users move through a fixed scene as if walking through it. While users are moving they expect to be able to turn to change the direction of the movement. Users control roaming by dragging with the left mouse button while the application is in view mode. Since users may sometimes want to turn without moving, dragging on the horizontal is interpreted differently than dragging in other directions as follows: </PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Dragging up in the viewing window moves the user forward into the scene; dragging down moves the user backwards out of the scene.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Dragging directly left on the horizontal in the viewing window turns the user left without any forward or backward movement; dragging directly right turns the user right without any movement.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Dragging in any direction above the horizontal both turns the user in that direction and moves the user forward in that direction; dragging in any direction below the horizontal both turns the user and moves the user backward in that direction. </PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>From the implementation perspective, the camera (eyepoint) moves forward or backward along the viewing direction in the same direction as the user's action; that is, as the user moves forward, the camera moves forward (see <XREF IDREF="25744" TYPE="GRAPHIC">Figure&nbsp;13-7</XREF>). The viewing direction moves in the same direction that the user turns; that is, as the user turns left, the viewing direction rotates left. If the user indicates a wish to turn but not move (by dragging the pointer directly left or right on the horizontal), the viewing direction changes appropriately but the camera doesn't move forward or backward. The look-at point changes as the viewing direction changes.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="roam.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="13-7"><PREFIX>Figure 13-7 </PREFIX><XREFTARGET ID="25744">Schematic illustration of Roaming (Implementation Perspective)</CAPTION>
</FIGURE>
</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="61562">Tilting</TITLE><PARAGRAPH>Tilting allows users to look up and down to see an object higher or lower than their current viewing direction in the scene. Tilting doesn't move the user. To move toward an object in the new view, the user has to use roaming (see <XREF IDREF="82935" TYPE="TITLE">&ldquo;Roaming&rdquo;</XREF>). To control tilting, the user simultaneously presses the left and middle mouse buttons and drags. Dragging up in the viewing window tilts the user's head up to look up in the scene; dragging down allows the user to look down.</PARAGRAPH>
<PARAGRAPH>From the implementation perspective, tilting changes the viewing direction in the same direction the user's head is tilted (see <XREF IDREF="32526" TYPE="GRAPHIC">Figure&nbsp;13-8</XREF>). As the user looks up, the viewing direction moves up; looking down moves the viewing direction down. The location of the camera (eyepoint) doesn't change. The location of the look-at point changes as the viewing direction changes.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="tilt.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="13-8"><PREFIX>Figure 13-8 </PREFIX><XREFTARGET ID="32526">Schematic Illustration of Tilting (Implementation Perspective).</CAPTION>
</FIGURE>
</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="43061">Sidling</TITLE><PARAGRAPH>Sidling allows users to sidestep left and right in the scene or to &ldquo;elevator&rdquo; up and down in the scene. Sidling moves the user left, right, up and down in the plane perpendicular to the viewing direction; it doesn't move the user forward or back in the scene. The user controls sidling by dragging while pressing the middle mouse button. The user moves in the direction of the drag; for example, the user drags left in the viewing window to sidestep to the left. Dragging up moves the user up as if riding on an elevator.<INDEXTARGET ID="ch13.3Dview13"><!-- POSTPROCESSDATA: ch13.3Dview13|sidling navigation:sidling --></PARAGRAPH>
<PARAGRAPH><XREF IDREF="47995" TYPE="GRAPHIC">Figure&nbsp;13-9</XREF> illustrates sidling from the implementation perspective. The camera (eyepoint) moves in the plane perpendicular to the viewing direction. The camera moves in the same direction that the user wants to move. As the user sidesteps left, the camera moves left. If the user moves up, the camera also moves up. The orientation of the camera remains unchanged. The look-at point moves with the camera.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="panning.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="13-9"><PREFIX>Figure 13-9 </PREFIX><XREFTARGET ID="47995">Schematic Illustration of Sidling (User Drags Left)</CAPTION>
</FIGURE>
</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Guidelines for 3D Viewing Functions</TITLE><PARAGRAPH><BOLD>When designing the user interface for a 3D application...</BOLD></PARAGRAPH>
<CHECKOFF><CHECKOFFITEM>Provide a viewing interface regardless of other capabilities of the application (for example, editing).</CHECKOFFITEM>
</CHECKOFF>
<PARAGRAPH><BOLD>When designing the user interface for 3D viewing...</BOLD></PARAGRAPH>
<CHECKOFF><CHECKOFFITEM>Decide whether your application will support inspection, navigation, or both, then provide the appropriate viewing functions. If your application supports both inspection and navigation, choose one as the primary mode for viewing.</CHECKOFFITEM>
<CHECKOFFITEM>Use standard pointer shapes to indicate the current 3D viewing function.</CHECKOFFITEM>
</CHECKOFF>
<PARAGRAPH><BOLD>When designing the user interface for INSPECTION in a 3D application...</BOLD></PARAGRAPH>
<CHECKOFF><CHECKOFFITEM>Support the user model that users are manipulating a scene as though it were a single object they are holding in their hand (not the user model that users are manipulating a camera). From the user's perspective, all controls appear to manipulate the object or scene while the camera remains stationary. </CHECKOFFITEM>
<CHECKOFFITEM>Support tumbling as the default inspection function to allow users to view all sides of the scene. </CHECKOFFITEM>
<CHECKOFFITEM>Assign tumbling to dragging with the left mouse button.</CHECKOFFITEM>
<CHECKOFFITEM>Display the tumble pointer while the user accesses the tumble function. </CHECKOFFITEM>
<CHECKOFFITEM>Support dollying to allow users to move the scene closer or farther away. </CHECKOFFITEM>
<CHECKOFFITEM>Assign dollying to dragging with the left and middle mouse buttons pressed simultaneously. </CHECKOFFITEM>
<CHECKOFFITEM>Display the dolly pointer while the user accesses the dolly function. </CHECKOFFITEM>
<CHECKOFFITEM>Support panning to allow users to move the scene left, right, up, or down. </CHECKOFFITEM>
<CHECKOFFITEM>Assign panning to dragging with the middle mouse button.</CHECKOFFITEM>
<CHECKOFFITEM>Display the pan pointer while the user accesses the panning function.</CHECKOFFITEM>
<CHECKOFFITEM>Support seeking to allow users to change the look-at point and center the object of interest and to bring the object incrementally closer.</CHECKOFFITEM>
<CHECKOFFITEM>Support seeking as follows:</CHECKOFFITEM>
</CHECKOFF>
<BULLETLIST><BULLET><PARAGRAPH>If your application needs to reserve clicking with the left mouse button for a more critical or useful function, allow users to seek by first activating a seek tool, then clicking with the left mouse button in the scene. Otherwise, support seeking without the use of a tool.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>In either case, the user seeks by clicking on a part of the scene with the left mouse button. The application centers that part of the scene in the viewing window and moves the scene closer by half the distance between the camera and the object. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>With each subsequent click on the same part of the scene, the scene again moves closer. </PARAGRAPH>
</BULLET>
</BULLETLIST>
<CHECKOFF><CHECKOFFITEM>Display the seek pointer while the user accesses the seek function.</CHECKOFFITEM>
</CHECKOFF>
<PARAGRAPH><BOLD>When designing the user interface for NAVIGATION in a 3D application...</BOLD></PARAGRAPH>
<CHECKOFF><CHECKOFFITEM>Support the user model that the scene is stationary and the user is moving through this fixed, immovable world. From the user's perspective, all navigation controls appear to manipulate the camera (user's view into the world) while the scene remains stationary. </CHECKOFFITEM>
<CHECKOFFITEM>Support roaming as the default navigation function. In roaming, the user can move forward and backward, turn left and right, and turn while moving. </CHECKOFFITEM>
<CHECKOFFITEM>Assign roaming to dragging with the left mouse button. </CHECKOFFITEM>
<CHECKOFFITEM>Display the roam pointer while the user accesses the roaming function. </CHECKOFFITEM>
<CHECKOFFITEM>Support tilting to allow users to change their view of the scene by tilting their head up and down. Tilting doesn't move the user forward or backward. </CHECKOFFITEM>
<CHECKOFFITEM>Assign tilting to dragging with the left and middle mouse buttons pressed simultaneously. </CHECKOFFITEM>
<CHECKOFFITEM>Display the tilt pointer while the user accesses the tilting function. </CHECKOFFITEM>
<CHECKOFFITEM>Support sidling to allows users to sidestep left and right and to move up and down as if on an elevator.</CHECKOFFITEM>
<CHECKOFFITEM>Assign sidling to dragging with the middle mouse button.</CHECKOFFITEM>
<CHECKOFFITEM>Display the sidle pointer while the user accesses the sidling function, </CHECKOFFITEM>
<CHECKOFFITEM>Support seeking to allow users to move closer to an object in the scene.</CHECKOFFITEM>
<CHECKOFFITEM>Support seeking as follows:</CHECKOFFITEM>
</CHECKOFF>
<BULLETLIST><BULLET><PARAGRAPH>If your application needs to reserve clicking with the left mouse button for a more critical or useful function, allow users to seek by first activating a seek tool, then clicking with the left mouse button in the scene. Otherwise, support seeking without the use of a tool.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>In either case, the user seeks by clicking on a part of the scene with the left mouse button. The application centers that part of the scene in the viewing window and moves the scene closer by half the distance between the camera and the object. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>With each subsequent click on the same part of the scene, the scene again moves closer. </PARAGRAPH>
</BULLET>
</BULLETLIST>
<CHECKOFF><CHECKOFFITEM>Display the seek pointer while the user accesses the seek function.</CHECKOFFITEM>
</CHECKOFF>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="94814">3D Viewing Interface Trade-Offs</TITLE><PARAGRAPH>When designing a user interface for viewing in a 3D application, developers often need to address the design issues discussed in this section:<INDEXTARGET ID="ch13.3Dview14"><!-- POSTPROCESSDATA: ch13.3Dview14|viewing:trade-offs in 3D 3D viewing:trade-offs trade-offs in 3D viewing --><INDEXTARGET ID="ch13.3Dview15"><!-- POSTPROCESSDATA: ch13.3Dview15|viewing and editing (3D) editing and viewing (3D) --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="62811" TYPE="TITLE">&ldquo;Viewing and Editing in 3D Applications&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="85958" TYPE="TITLE">&ldquo;Single-Viewport and Multi-Viewport Viewing in 3D Applications&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="30380" TYPE="TITLE">&ldquo;3D Viewing Performance and Scene Fidelity&rdquo;</XREF></PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="62811">Viewing and Editing in 3D Applications</TITLE><PARAGRAPH>Only a limited number of mouse and keyboard key combinations is available for interacting with an application. Users therefore can't easily have access to all necessary editing and viewing functions at the same time. Instead, they need to switch contexts between editing and viewing so that they can use the same mouse and keyboard combinations in the different contexts to access different functions.</PARAGRAPH>
<PARAGRAPH>This context switch is best done by splitting editing and viewing functionality into two separate explicit modes. Using explicit modes avoids a potentially confusing interface that may result if the user doesn't know whether the next action will change the view of the object or the object itself. </PARAGRAPH>
<PARAGRAPH>In general, when users work with an application that allows editing, they like to be offered several ways to access the viewing functions, and they like to always have quick access to these functions. </PARAGRAPH>
<PARAGRAPH>The following sections discuss several techniques for providing both viewing and editing capabilities to the user: </PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="72813" TYPE="TITLE">&ldquo;Separate View and Edit Modes&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="23130" TYPE="TITLE">&ldquo;View Overlay&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="91257" TYPE="TITLE">&ldquo;Viewing Controls&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="55792" TYPE="TITLE">&ldquo;Dedicated Viewing Peripheral Devices&rdquo;</XREF></PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>No matter how an application allows users access to viewing and editing, it's important to always display the correct pointer shape to let users know which function they are currently performing. See <XREF IDREF="75279" TYPE="TITLE">&ldquo;Pointer Shapes for 3D Functions&rdquo; in Chapter&nbsp;12</XREF>.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="72813">Separate View and Edit Modes</TITLE><PARAGRAPH>If an application supports editing, separate and explicit view and edit modes are highly recommended. This allows more flexibility in assigning functions to mouse and keyboard key combinations. In edit mode, mouse and keyboard input perform editing functions on selected objects and on the scene; in view mode, mouse and keyboard input perform viewing functions.<INDEXTARGET ID="ch13.3Dview16"><!-- POSTPROCESSDATA: ch13.3Dview16|view mode edit mode --></PARAGRAPH>
<PARAGRAPH>Users expect an obvious mechanism to switch modes, for example an item in a pull-down menu or a button on a tool palette that provides a variety of possible modes. In addition, users also expect to be able to switch modes using the &lt;Esc> key (see <INDEXTARGET ID="ch13.3Dview17"><!-- POSTPROCESSDATA: ch13.3Dview17|&lt;Esc\> key:for view mode --><XREF IDREF="94371" TYPE="TITLE">&ldquo;Using Modifier Keys in 3D Applications&rdquo; in Chapter&nbsp;12</XREF>). Pressing this key takes the user to the next mode.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="23130">View Overlay</TITLE><PARAGRAPH>When they are editing, users expect to always have quick access to viewing with a view overlay. A view overlay is a temporary view mode that's available while the user holds down the &lt;Alt> key (see <INDEXTARGET ID="ch13.3Dview18"><!-- POSTPROCESSDATA: ch13.3Dview18|view overlay overlay <ITALICS>See </ITALICS> view overlay --><INDEXTARGET ID="ch13.3Dview19"><!-- POSTPROCESSDATA: ch13.3Dview19|&lt;Alt\> key:for view overlay --><XREF IDREF="94371" TYPE="TITLE">&ldquo;Using Modifier Keys in 3D Applications&rdquo; in Chapter&nbsp;12</XREF>). As long as the &lt;Alt> key remains pressed, mouse and keyboard input is temporarily interpreted as providing viewing input rather than editing input. Releasing the &lt;Alt> key returns the application to standard editing operations. If the application is already in view mode when the user presses the &lt;Alt> key, the &lt;Alt> key is ignored. </PARAGRAPH>
<PARAGRAPH>A view overlay offers users quick access to temporary viewing but allows them to stay focused on the editing tasks at hand. This avoids forcing the user to make a heavyweight switch between edit and view modes. Although the view overlay is temporary, users still need to see the correct pointer shape feedback while accessing the viewing functions (for example, the roam pointer or tilt pointer). See <XREF IDREF="75279" TYPE="TITLE">&ldquo;Pointer Shapes for 3D Functions&rdquo; in Chapter&nbsp;12</XREF>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="91257">Viewing Controls </TITLE><PARAGRAPH>Applications can optionally provide separate user interface controls to access viewing functions. In this approach, all mouse input is interpreted as editing input unless the user is using the mouse pointer to manipulate a viewing control. </PARAGRAPH>
<PARAGRAPH><XREF IDREF="64817" TYPE="GRAPHIC">Figure&nbsp;13-10</XREF> shows an application window with viewing controls around the sides and the bottom of the window. Manipulating the thumbwheels or sliders with the mouse affects viewing: For example, dragging the thumbwheel in the lower right hand corner of the window dollies the camera, which changes the view but doesn't edit it. Using the mouse in the viewing area of the window performs editing actions: for example, clicking on the star selects that object for editing.<INDEXTARGET ID="ch13.3Dview20"><!-- POSTPROCESSDATA: ch13.3Dview20|viewing controls:thumbwheels viewing controls:sliders --></PARAGRAPH>
<!-- RASTERCONVERT: ch13.3Dview.cgm17 -->
<PARAGRAPH><FIGURE><GRAPHIC FILE="ch13.3Dview-17.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="13-10"><PREFIX>Figure 13-10 </PREFIX>Application With Viewing Controls<XREFTARGET ID="64817"></CAPTION>
</FIGURE>
</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="55792">Dedicated Viewing Peripheral Devices</TITLE><PARAGRAPH>Another optional method of addressing the conflict between viewing and editing input is to assign all viewing actions to one dedicated input device, such as a spaceball. All input from the dedicated input device performs viewing functions; input from other devices performs editing functions. This approach provides more input bandwidth: Context switching between viewing and editing is handled by the choice of input device. <INDEXTARGET ID="ch13.3Dview21"><!-- POSTPROCESSDATA: ch13.3Dview21|spaceball viewing peripherals:3D input device peripherals: 3D input device --></PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="85958">Single-Viewport and Multi-Viewport Viewing in 3D Applications</TITLE><PARAGRAPH>When designing a viewing interface, you must decide whether to offer users only one view of the scene (single-viewport) or multiple views simultaneously (multi-viewport). Multiple views may be, for example, one close-up and one distance view or one view from the top and one from each side. This section presents <INDEXTARGET ID="ch13.3Dview22"><!-- POSTPROCESSDATA: ch13.3Dview22|single-viewport viewing multi-viewport viewing --><XREF IDREF="62256" TYPE="TITLE">&ldquo;Single-Viewport Viewing&rdquo;</XREF> and <XREF IDREF="81758" TYPE="TITLE">&ldquo;Multi-Viewport Viewing,&rdquo;</XREF> discussing their advantages and disadvantages.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="62256">Single-Viewport Viewing</TITLE><PARAGRAPH>In the single-viewport model, only one view of the scene can be projected to the single viewport at any given time, even if there are multiple cameras in the scene. This is a serially multiplexed approach; different views are presented one after another in the same viewport and the user can switch among them.<INDEXTARGET ID="ch13.3Dview23"><!-- POSTPROCESSDATA: ch13.3Dview23|single-viewport viewing:advantages --></PARAGRAPH>
<PARAGRAPH>By default, the viewport provides a perspective view of the scene. The view updates as the user selects different cameras.</PARAGRAPH>
<PARAGRAPH>Single-viewport viewing has these advantages:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><BOLD>Performance</BOLD>&mdash;Updating the contents of one view is less computationally expensive than updating two or more views. Application performance deteriorates as the number of views increases, so single-viewport viewing is faster than multi-viewport viewing. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><BOLD>Space</BOLD>&mdash;The view doesn't need to share space with other views in the application window. The total viewing area is dedicated to a single view; this allows the largest possible representation of the 3D data. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><BOLD>Simpler user model</BOLD>&mdash;Users have to deal only with one view and one window. In contrast, a multi-viewport model requires that users determine the relationship among the different views or decide how changes in one view influence the other views.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="81758">Multi-Viewport Viewing</TITLE><PARAGRAPH>In the multi-viewport model, two or more views of a scene are simultaneously available. Typically, there are four views: front, top, one side (typically the right), and perspective. <INDEXTARGET ID="ch13.3Dview24"><!-- POSTPROCESSDATA: ch13.3Dview24|multi-viewport viewing:advantages --></PARAGRAPH>
<PARAGRAPH>A view isn't necessarily bound to a particular camera. For each view, the user can choose which camera to use and what each camera views. For example, to view an object from the bottom that's currently visible from the front, the user can either find a camera that displays it from the bottom or tumble or roam to get that view.</PARAGRAPH>
<PARAGRAPH>Multi-viewport viewing has the advantage that it allows simultaneous views of different representations of data. Users can examine and edit data from different perspectives simultaneously and can edit and examine data across multiple views without having to switch views. This is important for editing complex objects or during scene composition. While performance can be worse with multiple views (because more windows must be updated during viewing operations), experienced users find multiple views useful because they can coordinate operations across multiple viewports to get more accurate feedback on the actions they are performing.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="30380">3D Viewing Performance and Scene Fidelity</TITLE><PARAGRAPH>Viewing is critical to interacting with 3D environments and applications. The more responsive the application is during viewing, the more realistic and compelling the user's experience.</PARAGRAPH>
<PARAGRAPH>To achieve realistic user interaction, an application has to maintain at least 8 fps while the user interacts with the view. The frame rate&mdash;number of frames per second (fps)&mdash;is a good gauge of acceptable viewing performance:<INDEXTARGET ID="ch13.3Dview25"><!-- POSTPROCESSDATA: ch13.3Dview25|performance 3D viewing:performance frame rate:3D applications 3D applications:frame rate --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>If the frame rate drops below 8 fps, users typically find interacting with the application cumbersome. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>In an editing context, 10-12 fps can be sufficient. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>15 fps is the minimum frame rate to give the user a fluid, in-control experience. Action games or immersive experiences may require a greater frame rate to achieve that goal. </PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Some 3D scenes are so complex that just rotating the view becomes computationally expensive. In that case, the 3D scene can't be rendered at an acceptable frame rate. In such situations, applications must provide automatic adaptive rendering, user-controlled adaptive rendering, or both:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>In automatic adaptive rendering, the application always maintains viewing responsiveness at the expense of scene fidelity. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>In user-controlled adaptive rendering, users explicitly choose between adaptive rendering (that is, maintaining viewing responsiveness at the expense of scene fidelity) and fully rendering the contents of the scene (but taking a performance hit during viewing). This choice is important if users sometimes need fully rendered, high-fidelity scenes and, therefore, need to turn off adaptive rendering. </PARAGRAPH>
</BULLET>
</BULLETLIST>
<NOTE><PREFIX>Note</PREFIX>It isn't acceptable to let the frame rate drop below 8 fps without explicit user confirmation. </NOTE>
<PARAGRAPH>Adaptive rendering maintains viewing performance by changing the rendering characteristics of objects and elements during viewing operations. Typically, some detail is omitted from the display to reduce the computational requirements. As a result, a higher frame rate is achieved at a somewhat lower level of fidelity. Once viewing stops, the scene is returned to its original fidelity. Most users are satisfied with such a trade-off. Without adaptive rendering, users complain of poor performance or sluggishness. Adaptive rendering maintains responsive behavior without reducing functionality or impeding user tasks.<INDEXTARGET ID="ch13.3Dview26"><!-- POSTPROCESSDATA: ch13.3Dview26|adaptive rendering --></PARAGRAPH>
<PARAGRAPH>To implement adaptive rendering, an application can use techniques such as turning off texturing when an object is being moved, or using wireframe models. If an application has multiple views, adaptive rendering can be implemented by updating only one of the views. Then, when the view is no longer changing, the other views can be updated.<INDEXTARGET ID="ch13.3Dview27"><!-- POSTPROCESSDATA: ch13.3Dview27|multi-viewport viewing:adaptive rendering --></PARAGRAPH>
<PARAGRAPH>Note that if an application uses only automatic adaptive rendering, it needs to provide users easy access to fully rendered scenes. At a minimum, this should occur when the user stops interacting with the view. </PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="93079">3D Viewing Trade-Offs and Related Guidelines</TITLE><PARAGRAPH><BOLD>To make viewing quickly and easily accessible in 3D applications...</BOLD></PARAGRAPH>
<CHECKOFF><CHECKOFFITEM>Always provide ready access to viewing no matter what the user is doing (for example editing). </CHECKOFFITEM>
</CHECKOFF>
<PARAGRAPH><BOLD>When designing a viewing interface for a 3D application that also supports editing...</BOLD></PARAGRAPH>
<CHECKOFF><CHECKOFFITEM>Display the appropriate pointer depending on the task the user is performing: </CHECKOFFITEM>
</CHECKOFF>
<BULLETLIST><BULLET><PARAGRAPH>While the user is accessing editing functions, display the edit pointer. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>While the user is accessing viewing functions, display the appropriate view pointer based on the user's current viewing function (for example, the roaming pointer if the user is currently navigating a scene). </PARAGRAPH>
</BULLET>
</BULLETLIST>
<CHECKOFF><CHECKOFFITEM>Provide a modal interface to viewing and editing whenever possible. </CHECKOFFITEM>
<CHECKOFFITEM>Provide an obvious mechanism for changing between the view and edit modes, such as buttons in a tool palette or entries in a pull-down menu. </CHECKOFFITEM>
<CHECKOFFITEM>Reserve the &lt;Esc> key for switching between the view and edit modes.</CHECKOFFITEM>
<CHECKOFFITEM>Always provide a view overlay for quick access to viewing. That is, when the primary task is editing, the user can at any time temporarily enter a view mode by pressing and holding the &lt;Alt> key. The user can release the &lt;Alt> key to return the application to edit mode. </CHECKOFFITEM>
<CHECKOFFITEM>Reserve the &lt;Alt> key for providing access to a view overlay. If the user is already in view mode, the &lt;Alt> key has no effect. </CHECKOFFITEM>
<CHECKOFFITEM>Display the appropriate pointer for the current viewing function (for example, the tumble pointer or the roaming pointer) while the user is accessing a view overlay.</CHECKOFFITEM>
<CHECKOFFITEM>Optionally provide additional ways to access viewing, for example, offer viewing fixtures or split viewing and editing input across separate dedicated input devices. </CHECKOFFITEM>
</CHECKOFF>
<PARAGRAPH><BOLD>When deciding between a single viewport and multiple viewports...</BOLD></PARAGRAPH>
<CHECKOFF><CHECKOFFITEM>Use a single viewport if the user doesn't need to do much editing, performance or screen real estate is critical, you need a simple user model, or if several of these conditions are met. </CHECKOFFITEM>
<CHECKOFFITEM>Support multiple viewports if the user needs two or more views of the data simultaneously (such as when editing complex objects or working on scene composition) and performance isn't a critical issue.</CHECKOFFITEM>
</CHECKOFF>
<PARAGRAPH><BOLD>When designing a viewing interface for a single viewport...</BOLD></PARAGRAPH>
<CHECKOFF><CHECKOFFITEM>Use the perspective view of the scene as the default view. </CHECKOFFITEM>
<CHECKOFFITEM>Update the single-viewport view with a new view as the user selects different cameras.</CHECKOFFITEM>
</CHECKOFF>
<PARAGRAPH><BOLD>When making viewing performance design decisions...</BOLD></PARAGRAPH>
<CHECKOFF><CHECKOFFITEM>Support a minimum frame rate of 8 fps when the user is interacting with the view.</CHECKOFFITEM>
<CHECKOFFITEM>Ideally, support a minimum rate of 10-12 fps for editing and a minimum frame rate of 15 fps for a realistic interactive experience. </CHECKOFFITEM>
<CHECKOFFITEM>If the frame rate drops below 8 fps, provide at least one of the following solutions:</CHECKOFFITEM>
</CHECKOFF>
<BULLETLIST><BULLET><PARAGRAPH>Automatic adaptive rendering, where the application always maintains an acceptable frame rate at the expense of scene fidelity. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>User-controlled adaptive rendering, where the user explicitly chooses between adaptive rendering (acceptable frame rate but loss of detail) and fully rendering the contents of the scene (at a possibly unacceptably low frame rate). </PARAGRAPH>
</BULLET>
</BULLETLIST>
<CHECKOFF><CHECKOFFITEM>If users sometimes need fully rendered, high-fidelity scenes and the frame rate is likely to drop below 8 fps, provide user-controlled adaptive rendering.</CHECKOFFITEM>
<CHECKOFFITEM>If you application only provides automatic adaptive rendering, provide users ready access to fully rendered scenes. At a minimum, this should happen when the user stops interacting with the view. </CHECKOFFITEM>
</CHECKOFF>
</SECTION2>
</SECTION1>
</CHAPTER>
