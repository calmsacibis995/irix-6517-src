<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="7"><TITLE><XREFTARGET ID="63208">Focus, Selection, and Drag and Drop</TITLE><PARAGRAPH>Users can interact with your application through three general mechanisms, which are discussed in the following sections:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="50040" TYPE="TITLE">&ldquo;Keyboard Focus and Navigation&rdquo;</XREF> discusses how your application should allow users to direct keyboard input to specific components. It also discusses how certain components should be controlled from the keyboard. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="59818" TYPE="TITLE">&ldquo;Selection&rdquo;</XREF> discusses various models for allowing users to select data in your application.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="83927" TYPE="TITLE">&ldquo;Drag and Drop&rdquo;</XREF> discusses how users expect to directly manipulate text and other objects in your application by dragging them with the mouse.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="50040">Keyboard Focus and Navigation</TITLE><PARAGRAPH>Keyboard input allows users to enter data into text fields and to control other components in your application. The keyboard focus policy determines which component in which window receives the keyboard input. Only one component in one window receives input from the keyboard at any given time; this component has the keyboard focus (also called <INDEXTARGET ID="ch07.focus1"><!-- POSTPROCESSDATA: ch07.focus1|focus, keyboard. <ITALICS>See</ITALICS> keyboard focus --><INDEXTARGET ID="ch07.focus2"><!-- POSTPROCESSDATA: ch07.focus2|input focus. <ITALICS>See</ITALICS> keyboard focus --><INDEXTARGET ID="ch07.focus3"><!-- POSTPROCESSDATA: ch07.focus3|navigation. <ITALICS>See</ITALICS> keyboard navigation, mouse navigation --><INDEXTARGET ID="ch07.focus4"><!-- POSTPROCESSDATA: ch07.focus4|keyboard focus --><INDEXTARGET ID="ch07.focus5"><!-- POSTPROCESSDATA: ch07.focus5|keyboard navigation --><ITALICS>input focus</ITALICS>). For example, if a button has the keyboard focus and the user presses the Space bar on the keyboard, the button is activated. The process of moving the keyboard focus is called <ITALICS>navigation</ITALICS>. <ITALICS>Keyboard navigation</ITALICS> allows the user to navigate among components in a window using only the keyboard rather than having to manipulate the mouse (or other pointing device). </PARAGRAPH>
<PARAGRAPH>As described in <INDEXTARGET ID="ch07.focus6"><!-- POSTPROCESSDATA: ch07.focus6|explicit focus --><INDEXTARGET ID="ch07.focus7"><!-- POSTPROCESSDATA: ch07.focus7|implicit focus --><XREF IDREF="59672" TYPE="TITLE">&ldquo;Keyboard Focus Across Windows&rdquo; in Chapter&nbsp;3</XREF>, the IRIX Interactive Desktop environment uses one policy for moving the keyboard focus among components within a window and a different policy for moving the keyboard focus between windows. When moving the keyboard focus among components within a window, your application should use an explicit focus policy. In other words, the user clicks a mouse button or presses a key to move the keyboard focus to a new component in the active window. In contrast, <COMMAND>4Dwm</COMMAND>, the window manager for the IRIX Interactive Desktop, uses implicit focus across windows: the window directly underneath the pointer receives keyboard input (that is, it's the <ITALICS>active window</ITALICS>). Note that users can't navigate among windows using the keyboard when using <COMMAND>4Dwm</COMMAND> in its default configuration.</PARAGRAPH>
<PARAGRAPH>This section discusses keyboard focus and navigation among components in the active window and includes:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="86870" TYPE="TITLE">&ldquo;Keyboard Focus Policy and Navigation Within a Window&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="17698" TYPE="TITLE">&ldquo;Keyboard Focus and Navigation Guidelines&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="86870">Keyboard Focus Policy and Navigation Within a Window</TITLE><PARAGRAPH>Only one component in the active window has the keyboard focus at any given time. Your application should use <ITALICS>explicit</ITALICS> focus (as opposed to implicit focus) within a window; in other words, the user must explicitly select the component that receives the keyboard input. Your application should support the models described in this section for navigating to specific components in a window and for using the keyboard to activate these components.</PARAGRAPH>
<PARAGRAPH>Within the active window, the component with the keyboard focus is visually identified by the location cursor. The location cursor isn't necessarily a cursor in the traditional sense of a text cursor. It gives the user visual feedback as to which component receives the keyboard input. Each standard component described in <INDEXTARGET ID="ch07.focus8"><!-- POSTPROCESSDATA: ch07.focus8|location cursorcursors:location --><XREF IDREF="95140" TYPE="TITLE">Chapter&nbsp;9, &ldquo;Controls,&rdquo;</XREF> has its own method for displaying a location cursor when the component has keyboard focus. For example, the location cursor used to indicate that a specific radio button has the keyboard focus is a simple box, as shown in <XREF IDREF="15861" TYPE="GRAPHIC">Figure&nbsp;7-1</XREF>. </PARAGRAPH>
<!-- RASTERCONVERT: ch07.focus.cgm -->
<PARAGRAPH><FIGURE><GRAPHIC FILE="ch07.focus-1.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="7-1"><PREFIX>Figure 7-1 </PREFIX><XREFTARGET ID="15861">Location Cursor Example</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>Keyboard activation and keyboard navigation are strongly linked: if a user can activate or control a component from the keyboard, the user should also be able to navigate to that component from within the window using the keyboard. This enables the user to perform the task without having to frequently switch between using the mouse and keyboard.</PARAGRAPH>
<PARAGRAPH>Section 2.2 in the <DOCTITLE>OSF/Motif Style Guide</DOCTITLE> states that &ldquo;all application functionality must be available from the keyboard alone.&rdquo; This includes navigating among windows, navigating among components in a window, and activating components. By default, users will be able to navigate to and control all components in a window except for those that aren't traversable or don't accept input (for example, labels and separators). </PARAGRAPH>
<PARAGRAPH>Since all Silicon Graphics systems include a mouse, it's not as critical to provide access to all functionality from the keyboard alone when programming for Silicon Graphics systems. Just keep in mind that some users use alternate input devices that rely on having functions available from the keyboard. At a minimum, your application should let users do the following from the keyboard:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>navigate between editable text fields in a window</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>enter data into editable text fields</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>select data in a text field (see <XREF IDREF="59818" TYPE="TITLE">&ldquo;Selection&rdquo;</XREF> later in this chapter and <XREF IDREF="36229" TYPE="TITLE">&ldquo;Text Fields&rdquo; in Chapter&nbsp;9</XREF>)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>navigate to a list component (see <XREF IDREF="72866" TYPE="TITLE">&ldquo;Lists&rdquo; in Chapter&nbsp;9</XREF>)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>select data in a list (see <XREF IDREF="59818" TYPE="TITLE">&ldquo;Selection&rdquo;</XREF> later in this chapter and <XREF IDREF="72866" TYPE="TITLE">&ldquo;Lists&rdquo; in Chapter&nbsp;9</XREF>)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>navigate among all types of menus (pull-down, popup, and option menus) and their entries (see <XREF IDREF="19797" TYPE="TITLE">&ldquo;Menu Traversal and Activation&rdquo; in Chapter&nbsp;8</XREF>)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>activate menu entries (see <XREF IDREF="19797" TYPE="TITLE">&ldquo;Menu Traversal and Activation&rdquo; in Chapter&nbsp;8</XREF>)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>scroll any scrollable component (see <XREF IDREF="33826" TYPE="TITLE">&ldquo;Scrollbars&rdquo; in Chapter&nbsp;9</XREF>)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>activate the default button in a dialog if there is one (see <XREF IDREF="32754" TYPE="TITLE">&ldquo;Standard Dialog Actions&rdquo; in Chapter&nbsp;10</XREF>)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>use mnemonics for all menu titles and menu entries in the pull-down menus (see <XREF IDREF="62421" TYPE="TITLE">&ldquo;Choosing Mnemonics&rdquo; in Chapter&nbsp;8</XREF>)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>use keyboard accelerators for frequently used entries in the pull-down menus, such as &ldquo;Cut,&rdquo; &ldquo;Copy,&rdquo; and &ldquo;Paste&rdquo; in the Edit menu (see <XREF IDREF="75819" TYPE="TITLE">&ldquo;Choosing Keyboard Accelerators&rdquo; in Chapter&nbsp;8</XREF>)</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="74637">Keyboard Navigation</TITLE><PARAGRAPH>This section discusses guidelines for moving the focus to a different component in the window using the keyboard. (The<DOCTITLE>&space;OSF/Motif Style Guide</DOCTITLE> refers to this as <ITALICS>component navigation</ITALICS>.) Each window is divided into fields, where a field can be an individual control (for example, a text input field) or a group of controls (such as a group of radio buttons). By default, the fields that can accept the keyboard focus are ordered, in general, from upper left to lower right. If a window has multiple <ITALICS>panes</ITALICS>, the focus moves by default through the fields in the topmost (or leftmost) pane, then the fields in the next pane, and so on, until it wraps back to the beginning. </PARAGRAPH>
<PARAGRAPH>In some cases, you may have to modify the default order in which components are navigated from the keyboard. For example, when a window first becomes active, the component that should have the keyboard focus is the one that the user is most likely to want to interact with&space;using the keyboard. This isn't necessarily the component in the upper left-hand corner. Also, when a user returns the keyboard focus to a window that was previously the active window, the keyboard focus should return to where it was when the user moved the focus out of that window.</PARAGRAPH>
<PARAGRAPH>By default, users can cycle through the fields in order using the &lt;Tab> key. They also can use the arrow keys to move the keyboard focus among the individual components in the current field. For example, in the Add Printer window, shown in <XREF IDREF="44860" TYPE="GRAPHIC">Figure&nbsp;7-2</XREF>, a user can use &lt;Tab> to move keyboard focus from the first field (&ldquo;New Printer Name&rdquo;) to the second field (&ldquo;Connection Type&rdquo;). Once in the second field, the user can move keyboard focus between the radio buttons using the directional arrow keys. </PARAGRAPH>
<!-- RASTERCONVERT: ch07.focus.cgm2 -->
<PARAGRAPH><FIGURE>.<GRAPHIC FILE="ch07.focus-2.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="7-2"><PREFIX>Figure 7-2 </PREFIX><XREFTARGET ID="44860">Components and Fields</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>By default, the following keyboard commands are used for navigating within a window. In addition, as discussed in <INDEXTARGET ID="ch07.focus9"><!-- POSTPROCESSDATA: ch07.focus9|keys:special --><INDEXTARGET ID="ch07.focus10"><!-- POSTPROCESSDATA: ch07.focus10|&lt;Shift\>&lt;F10\> key --><INDEXTARGET ID="ch07.focus11"><!-- POSTPROCESSDATA: ch07.focus11|popup menusmenus:popup --><XREF IDREF="19797" TYPE="TITLE">&ldquo;Menu Traversal and Activation&rdquo; in Chapter&nbsp;8</XREF>, &lt;Shift>-&lt;F10> should move the location cursor to a popup menu if one is available for the current context. </PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>&lt;Tab><INDEXTARGET ID="ch07.focus12"><!-- POSTPROCESSDATA: ch07.focus12|&lt;Tab\> key --></HANGITEM>
<HANGBODY><PARAGRAPH>Moves the location cursor to the next field that can accept the keyboard focus, unless the current field is a multi-line editable text field. In this case it simply inserts a tab character.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>&lt;Ctrl>-&lt;Tab><INDEXTARGET ID="ch07.focus13"><!-- POSTPROCESSDATA: ch07.focus13|&lt;Ctrl\>&lt;Tab\> keys --></HANGITEM>
<HANGBODY><PARAGRAPH>Always moves the location cursor to the next field that can accept the keyboard focus.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>&lt;Shift>-&lt;Tab><INDEXTARGET ID="ch07.focus14"><!-- POSTPROCESSDATA: ch07.focus14|&lt;Shift\>&lt;Tab\> keys --></HANGITEM>
<HANGBODY><PARAGRAPH>Moves the location cursor to the previous field that can accept the keyboard focus.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>&lt;Ctrl>-&lt;Shift>-&lt;Tab><INDEXTARGET ID="ch07.focus15"><!-- POSTPROCESSDATA: ch07.focus15|&lt;Ctrl\>&lt;Shift\>&lt;Tab\> keys --></HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Always moves the location cursor to the previous field that can accept the keyboard focus.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>&lt;down arrow><INDEXTARGET ID="ch07.focus16"><!-- POSTPROCESSDATA: ch07.focus16|&lt;down arrow\> key --></HANGITEM>
<HANGBODY><PARAGRAPH>Moves the location cursor within a field forward (or down) to the next component that can receive the keyboard focus, eventually wrapping back to the first component. If the components are in a matrix, &lt;down arrow> moves down through a column and then proceeds to the top of the next column to the right. </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>&lt;up arrow><INDEXTARGET ID="ch07.focus17"><!-- POSTPROCESSDATA: ch07.focus17|&lt;up arrow\> key --></HANGITEM>
<HANGBODY><PARAGRAPH>Moves the location cursor within a field opposite to the direction of the &lt;down arrow> to the next component that can receive the keyboard focus. Eventually it wraps back to the last component.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>&lt;right arrow><INDEXTARGET ID="ch07.focus18"><!-- POSTPROCESSDATA: ch07.focus18|&lt;right arrow\> key --></HANGITEM>
<HANGBODY><PARAGRAPH>Moves the location cursor within a field to the next component to the right that can receive the keyboard focus, eventually wrapping back to the first component. If the components are in a matrix, &lt;right arrow> moves across an entire row and then proceeds to the row below. </PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>&lt;left arrow><INDEXTARGET ID="ch07.focus19"><!-- POSTPROCESSDATA: ch07.focus19|&lt;left arrow\> key --></HANGITEM>
<HANGBODY><PARAGRAPH>Moves the location cursor within a field opposite to the direction of the &lt;right arrow> to the next component that can receive the keyboard focus. Eventually it wraps back to the last component.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>&lt;F10><INDEXTARGET ID="ch07.focus20"><!-- POSTPROCESSDATA: ch07.focus20|&lt;F10\> key --></HANGITEM>
<HANGBODY><PARAGRAPH>Moves the location cursor to the leftmost menu in the menu bar if there is one. If a menu is already displayed, &lt;F10> closes the menu and returns the location cursor to where it was previously. (See <XREF IDREF="19797" TYPE="TITLE">&ldquo;Menu Traversal and Activation&rdquo; in Chapter&nbsp;8</XREF>.)</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
<PARAGRAPH>Because the keys listed above are used for navigating among components, don't use them for other purposes. However, there's an exception to this rule: the arrow keys can be used to control a component that's the only component in its field. For this reason, each editable text field, list, scrollbar or sash is by default placed in its own field.&space;</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Mouse Navigation</TITLE><PARAGRAPH>To move the keyboard focus in the current active window using the mouse, users put the pointer over a specific component and click the left mouse button. The keyboard focus moves to the selected component, if you've allowed that component to accept keyboard focus, and typically performs some action or selects some data. For example, clicking the left mouse button on a pushbutton activates the pushbutton, as well as moves keyboard focus to the pushbutton. Clicking the left mouse button in an editable text field moves keyboard focus to the text field and places the insertion point in the text field at the pointer location. If users want to move the keyboard focus to a component using the mouse without activating that component, they can position the pointer over the component, then hold down the &lt;Ctrl> key while clicking the left mouse button.<INDEXTARGET ID="ch07.focus21"><!-- POSTPROCESSDATA: ch07.focus21|mouse navigation --></PARAGRAPH>
<PARAGRAPH>By default, certain components do not grab the keyboard focus when activated using the mouse. These include scrollbars, sashes, any other component that's used only to change the size or location of other elements, and any components that you've designated as being unable to accept keyboard focus. If the user uses the mouse to activate any of these components, it's activated and the keyboard focus stays where it was. </PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="17698">Keyboard Focus and Navigation Guidelines</TITLE><PARAGRAPH><BOLD>When designing keyboard focus and navigation for your application windows . . .</BOLD>&space;</PARAGRAPH>
<CHECKOFF><CHECKOFFITEM>Use explicit focus for navigating among components within a window.</CHECKOFFITEM>
<CHECKOFFITEM>Support at least the minimum required functionality from the keyboard, such as navigating to and entering data into editable text fields, using mnemonics and keyboard accelerators to access menu entries, and scrolling any scrollable component. Keep in mind that some users use alternate input devices that rely on having functions available from the keyboard.</CHECKOFFITEM>
<CHECKOFFITEM>When the window becomes active for the first time, give focus to the component that the user is most likely to want to interact with using the keyboard. When a user returns the keyboard focus to a window that was previously the active window, return the keyboard focus to where it was when the user moved the focus out of that window.</CHECKOFFITEM>
<CHECKOFFITEM>Put each component that requires the use of arrow keys to control it in its own field. The following components are by default put in fields of their own: editable text fields, lists, scrollbars, and sashes.</CHECKOFFITEM>
<CHECKOFFITEM>Don't use the default keyboard navigation keys for other purposes. These keys are &lt;Tab>, &lt;Ctrl>-&lt;Tab>, &lt;Shift>-&lt;Tab>, &lt;Ctrl>-&lt;Shift>-&lt;Tab>, the arrow keys, &lt;F10>, &lt;Shift>-&lt;F10>, and &lt;Ctrl> in combination with a left mouse button click.</CHECKOFFITEM>
</CHECKOFF>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="59818">Selection</TITLE><PARAGRAPH>IRIS IM is based on the object-action model of direct manipulation. This means that a user must first select an object or group of objects, then choose an action to perform on that data. Users typically select data by clicking the left mouse button (to select a single object) or by dragging with the left mouse button (to select a range of objects). The selection is completed when the mouse button is released. Making a selection shouldn't automatically perform any operation on that selection. When users select data in an application window, that data should be highlighted in some way so that when they pick an action, they'll know which chunk of data that action is being applied to. <INDEXTARGET ID="ch07.focus22"><!-- POSTPROCESSDATA: ch07.focus22|selectionsdata exchange:selections --><INDEXTARGET ID="ch07.focus23"><!-- POSTPROCESSDATA: ch07.focus23|primary selection --></PARAGRAPH>
<PARAGRAPH>At any time, there's one selection that's the <ITALICS>primary selection</ITALICS>. This is the last selection explicitly started by the user and is used to copy data between applications. For details on supporting the primary transfer model in your application, see <XREF IDREF="61999" TYPE="TITLE">&ldquo;Supporting the Primary Transfer Model&rdquo; in Chapter&nbsp;5</XREF>. </PARAGRAPH>
<PARAGRAPH>This section describes:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="46912" TYPE="TITLE">&ldquo;Selection Models&mdash;What Can Be Selected and How To Select It&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="93501" TYPE="TITLE">&ldquo;Highlighting a Selection&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="71910" TYPE="TITLE">&ldquo;Multiple Collections in One Application Window&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="46912">Selection Models&mdash;What Can Be Selected and How To Select It</TITLE><PARAGRAPH>The data in an application window is divided into <INDEXTARGET ID="ch07.focus24"><!-- POSTPROCESSDATA: ch07.focus24|selections:modelscollectionsselections:collections --><ITALICS>collections</ITALICS>. A collection is a group of related elements that share a selection model. There are four basic selection models described in the <DOCTITLE>OSF/Motif Style Guide</DOCTITLE>:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>In the <INDEXTARGET ID="ch07.focus25"><!-- POSTPROCESSDATA: ch07.focus25|single selection model --><ITALICS>single selection</ITALICS> model, only one element in the collection can be selected at any given time. For example, a color palette usually allows you to pick only one color at a time. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The <INDEXTARGET ID="ch07.focus26"><!-- POSTPROCESSDATA: ch07.focus26|browse selection model --><ITALICS>browse selection</ITALICS> model is essentially the same as the single selection model, except that it allows users to browse through the available elements by dragging with the left mouse button. The list of available schemes in the Schemes control panel is an example of this model.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>In the <INDEXTARGET ID="ch07.focus27"><!-- POSTPROCESSDATA: ch07.focus27|range selection model --><ITALICS>range selection</ITALICS> model, more than one element in the collection can be selected at any given time, but these elements must be next to each other. Text is usually selected in this fashion&mdash;a user can select any number of contiguous characters in a piece of text.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>In the <INDEXTARGET ID="ch07.focus28"><!-- POSTPROCESSDATA: ch07.focus28|discontiguous selection model --><ITALICS>discontiguous selection</ITALICS> model, more than one element in the collection can be selected at any given time, and these elements don't have to be next to each other. An example of this model is a list of files that allows a user to select multiple files.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Note that the <INDEXTARGET ID="ch07.focus29"><!-- POSTPROCESSDATA: ch07.focus29|multiple selection model --><DOCTITLE>OSF/Motif Style Guide</DOCTITLE> also describes a fifth selection model, <ITALICS>multiple selection</ITALICS>. Your application shouldn't use this model because it uses mouse actions for adding and removing selected elements that are different from other mouse actions. Eliminating these inconsistent mouse actions for selection makes it much easier for users to learn how to select data.</PARAGRAPH>
<PARAGRAPH>Each collection of data in your application should support the mouse and keyboard actions for selecting and deselecting data listed in <INDEXTARGET ID="ch07.focus30"><!-- POSTPROCESSDATA: ch07.focus30|deselecting dataselecting datadata, selecting --><XREF IDREF="65350" TYPE="TABLE">Table&nbsp;7-1</XREF>, depending on which of the above models it supports. By default, the IRIS IM list component supports the browse selection model, and the IRIS IM text component supports the range selection model.</PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="7-1"><PREFIX>Table 7-1 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="65350">Selection Actions and Results</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="147"><PARAGRAPH>Action</PARAGRAPH>
</CELL>
<CELL LEFT="155" WIDTH="70"><PARAGRAPH>Model</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="285"><PARAGRAPH>Result</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="147"><PARAGRAPH>Click on an element in the collection</PARAGRAPH>
</CELL>
<CELL LEFT="155" WIDTH="70"><PARAGRAPH>All</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="285"><PARAGRAPH>The element is selected, and any elements in the collection that were 
previously selected are deselected. The location cursor is moved to the 
selected element.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="147"><PARAGRAPH>Drag through a range of data in the 
collection</PARAGRAPH>
</CELL>
<CELL LEFT="155" WIDTH="70"><PARAGRAPH>Browse</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="285"><PARAGRAPH>As the user moves the pointer over each element in the collection, that 
element becomes selected and all other elements in the collection are 
deselected. When the user releases the left mouse button, the element 
currently under the pointer remains the selected item, and the location 
cursor is moved to this element.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="147"><PARAGRAPH>Drag through a range of data in the 
collection</PARAGRAPH>
</CELL>
<CELL LEFT="155" WIDTH="70"><PARAGRAPH>Range and 
discontiguous</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="285"><PARAGRAPH>Any elements in the collection that were previously selected are 
deselected, and an <ITALICS>anchor</ITALICS> is set on the element or at the location where 
the left mouse button was pressed. While the user continues to drag the 
mouse, all elements between the anchor and the current location of the 
pointer are selected. When the user releases the mouse button, the 
current selection is set to all the elements between the anchor and the 
location of the pointer when the mouse button was released.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="147"><PARAGRAPH>&lt;Shift>-click on an element or 
&lt;Shift>-drag through a range of 
elements in a collection</PARAGRAPH>
</CELL>
<CELL LEFT="155" WIDTH="70"><PARAGRAPH>Range or 
discontiguous</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="285"><PARAGRAPH>The anchor is left in place, and the current selection is modified using 
one of three models for extending a range described in Section 4.1.4 of 
the <DOCTITLE>OSF/Motif Style Guide</DOCTITLE>. The preferred model is the <ITALICS>balance beam</ITALICS> 
model, which is also the default for the IRIS IM text component.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="147"><PARAGRAPH>&lt;Ctrl>-click on an element in the 
collection</PARAGRAPH>
</CELL>
<CELL LEFT="155" WIDTH="70"><PARAGRAPH>Discontiguous</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="285"><PARAGRAPH>The selection state of the element is toggled, and the anchor and 
location cursor are moved to that element.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="147"><PARAGRAPH>&lt;Ctrl> drag through a range of data 
in the collection</PARAGRAPH>
</CELL>
<CELL LEFT="155" WIDTH="70"><PARAGRAPH>Discontiguous</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="285"><PARAGRAPH>The selection state of the range of elements is toggled based on the 
<ITALICS>anchor toggle</ITALICS> model described in the<DOCTITLE> OSF/Motif Style Guide</DOCTITLE>, section<DOCTITLE>&space;</DOCTITLE>4.1.5. 
That is, you pick the element in the range that is closest to the anchor 
and set all of the elements in the range to the inverse of the selection 
state of this element.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="147"><PARAGRAPH>Click outside of the selection (but 
not on any element in a collection 
that requires at least one element to 
be selected at any given time)</PARAGRAPH>
</CELL>
<CELL LEFT="155" WIDTH="70"><PARAGRAPH>All </PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="285"><PARAGRAPH>All elements are deselected.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="147"><PARAGRAPH>When all of the data in a collection is 
selected, click anywhere inside the 
collection</PARAGRAPH>
</CELL>
<CELL LEFT="155" WIDTH="70"><PARAGRAPH>Range and 
discontiguous</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="285"><PARAGRAPH>All elements are deselected.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="147"><PARAGRAPH>&lt;Esc> while in the process of 
making a selection in any collection 
of data.</PARAGRAPH>
</CELL>
<CELL LEFT="155" WIDTH="70"><PARAGRAPH>All</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="285"><PARAGRAPH>The current selection action is cancelled, and all user input is ignored 
until the user has released all keys and buttons. The selection state is 
returned to its previous state.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="147"><PARAGRAPH>&lt;Ctrl>-&lt;/> when the collection has 
keyboard focus</PARAGRAPH>
</CELL>
<CELL LEFT="155" WIDTH="70"><PARAGRAPH>Range and 
discontiguous</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="285"><PARAGRAPH>All elements in the collection are selected. The anchor is placed at the 
beginning of the collection. The location cursor remains unchanged.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="147"><PARAGRAPH>&lt;Ctrl>-&lt;\> when the collection has 
keyboard focus</PARAGRAPH>
</CELL>
<CELL LEFT="155" WIDTH="70"><PARAGRAPH>Range and 
discontiguous</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="285"><PARAGRAPH>All elements in the collection are deselected. The location cursor 
remains at its current position, and the anchor is moved to where the 
location cursor is.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>When users select data in a component that can be scrolled, the component should support automatic scrolling&mdash;that is, if the data being selected is in a scrollable component and the user drags the pointer out of the data display region while still holding down the mouse button, the data should scroll in the direction of the pointer and should continue to be selected. Note that this behavior is automatically supported in the IRIS IM list and text components.</PARAGRAPH>
<PARAGRAPH>The mouse and keyboard actions described above represent a subset of those defined in the <DOCTITLE>OSF/Motif</DOCTITLE>&space;<DOCTITLE>Style Guide</DOCTITLE>, which requires that all functionality be available from the keyboard. The <DOCTITLE>OSF/Motif</DOCTITLE>&space;<DOCTITLE>Style Guide</DOCTITLE> describes specific keyboard actions to select individual elements, select a range of data, and modify the data selected. If you determine that users will want to access any of this functionality in your application using the keyboard, see Section 4.1.6 of the <DOCTITLE>OSF/Motif</DOCTITLE>&space;<DOCTITLE>Style Guide</DOCTITLE> for details on supporting keyboard selection. Note that keyboard selection is automatically supported in IRIS IM list and text components.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="93501">Highlighting a Selection</TITLE><PARAGRAPH>When the user initiates and continues to add to a selection, your application should visually highlight the currently selected data. In addition, while the data in the collection is being adjusted, the currently selected data should always be highlighted to show users what would be selected if they were to release the mouse button immediately. Selections should remain highlighted, even when the window containing that selection is no longer the active window. The <INDEXTARGET ID="ch07.focus31"><!-- POSTPROCESSDATA: ch07.focus31|selections:highlightinghighlighting selected data --><INDEXTARGET ID="ch07.focus32"><!-- POSTPROCESSDATA: ch07.focus32|persistent always selection model --><DOCTITLE>OSF/Motif Style Guide</DOCTITLE> refers to this as <ITALICS>persistent always</ITALICS> highlighting. This is the best type of selection highlighting to use when implicit focus is used for moving the keyboard focus across windows (implicit focus is the default for 4Dwm, as explained in <XREF IDREF="59672" TYPE="TITLE">&ldquo;Keyboard Focus Across Windows&rdquo; in Chapter&nbsp;3</XREF>).</PARAGRAPH>
<PARAGRAPH>Use persistent always highlighting except when the only reason a user can make a selection is to transfer that data using the primary transfer model and the user cannot perform any other actions on this data. (The primary transfer model is discussed in <INDEXTARGET ID="ch07.focus33"><!-- POSTPROCESSDATA: ch07.focus33|nonpersistent selection model --><XREF IDREF="61999" TYPE="TITLE">&ldquo;Supporting the Primary Transfer Model&rdquo; in Chapter&nbsp;5</XREF>.) For this type of data, your application should use <ITALICS>nonpersistent</ITALICS> highlighting, which means that the selection is highlighted only when it's the primary selection. When this data is no longer the primary selection, the currently selected data is no longer highlighted and the current selection is set to empty.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="71910">Multiple Collections in One Application Window</TITLE><PARAGRAPH>This section describes some common ways that multiple collections of data might interact in a single application window. There are three basic scenarios for using multiple collections in the same window:<INDEXTARGET ID="ch07.focus34"><!-- POSTPROCESSDATA: ch07.focus34|multiple collectionscollections:multipleselections:collections:multiple --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The user can select data in only one collection at a time.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The user can select data in more than one collection at a time, and any given mouse, keyboard, or menu command applies to only one of the collections.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The user can select data in more than one collection at a time, and some mouse, keyboard, or menu commands can be applied to more than one of the collections.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>If the user can select data in only one collection at a time, deselect the previous selection whenever the user makes a new selection in any of the collections. If the user can select data in more than one collection at a time, and any given mouse, keyboard, or menu command applies to only one of the collections, don't do anything special. Since each action can be applied only to one collection, it's obvious which collection to apply it to. For mouse, keyboard, or menu commands that can be applied to more than one of the collections, apply the operation to the collection that most recently had a selection made in it. (See <XREF IDREF="50040" TYPE="TITLE">&ldquo;Keyboard Focus and Navigation&rdquo;</XREF> earlier in this chapter.)</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Selection Guidelines</TITLE><PARAGRAPH><BOLD>For each collection of data . . .</BOLD>&space;</PARAGRAPH>
<CHECKOFF><CHECKOFFITEM>Use one of the four recommended selection models&mdash;single selection, browse selection, range selection, or discontiguous selection. Don't use the multiple selection model.</CHECKOFFITEM>
<CHECKOFFITEM>Automatically scroll the data as the user drags the pointer out of the scrollable data display region.</CHECKOFFITEM>
<CHECKOFFITEM>Determine if your users will need to create or modify a selection using the keyboard. If so, then support the keyboard actions defined in Section 4.1.6 of the <DOCTITLE>OSF/Motif Style Guide</DOCTITLE>. (These actions are automatically supported if you use the IRIS IM list or text components.)</CHECKOFFITEM>
</CHECKOFF>
<PARAGRAPH><BOLD>When highlighting a selection . . . </BOLD></PARAGRAPH>
<CHECKOFF><CHECKOFFITEM>Update the highlighting continuously as the user initiates and extends the selection.</CHECKOFFITEM>
<CHECKOFFITEM>Use persistent always highlighting, unless the only reason a user can select this data is to transfer it using the primary transfer model. In this case, use nonpersistent highlighting.</CHECKOFFITEM>
</CHECKOFF>
<PARAGRAPH><BOLD>When managing multiple collections of data in a single window . . . </BOLD></PARAGRAPH>
<CHECKOFF><CHECKOFFITEM>Deselect the previous selection whenever the user makes a new selection in any of the collections for cases where the user can select data in only one collection at a time. </CHECKOFFITEM>
<CHECKOFFITEM>Apply the operation to the collection that most recently had a selection made in it when the user can select data in more than one collection at a time and there are mouse, keyboard, or menu commands that can be applied to more than one of the collections.</CHECKOFFITEM>
</CHECKOFF>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="83927">Drag and Drop</TITLE><PARAGRAPH>Direct manipulation, or <INDEXTARGET ID="ch07.focus35"><!-- POSTPROCESSDATA: ch07.focus35|drag and dropdata exchange:drag and drop --><ITALICS>drag and drop</ITALICS>, describes an interface in which the user moves icons on the desktop or in application windows in order to perform various actions on the objects represented by the icons. Some typical uses for drag and drop include the following:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Moving an object from one place to another by dragging the object with the mouse and dropping it on a target. For example, to move a file from one directory to another, the user drags the icon representing the file and drops it on the folder icon representing the new directory location.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Making a reference to the object in the new location. For example, to add an online book to the personal bookshelf in IRIS Insight, the user drags an icon representing an online book from the main bookshelf to the personal bookshelf. This creates a reference to that book on the personal bookshelf in addition to the reference on the main bookshelf.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Performing some operation on the item being dragged. For example, a user can print a file by dragging the icon that represents the file onto a printer icon.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>If the user presses &lt;Esc> during a drag and drop operation, the operation should be cancelled, and both the object and the target should be left as they were before the operation was initiated.</PARAGRAPH>
<PARAGRAPH>This section covers the following topics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="43408" TYPE="TITLE">&ldquo;Two Models of Drag and Drop&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="77130" TYPE="TITLE">&ldquo;Pointers for Drag Operations&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="43408">Two Models of Drag and Drop</TITLE><PARAGRAPH>Two models for drag and drop exist, one recommended for use with text, and the other recommended for use with other objects.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="47539">Drag and Drop for Non-Text Objects</TITLE><PARAGRAPH>The most common model for drag and drop found in applications requires the user to select and drag the object using the left mouse button. This is the preferred model for implementing drag and drop of non-text objects; it reinforces the direct manipulation model of controlling objects directly using the left mouse button. The two most common scenarios for this are the following:<INDEXTARGET ID="ch07.focus36"><!-- POSTPROCESSDATA: ch07.focus36|drag and drop:non-text objects --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The user initiates dragging the object by positioning the cursor over the object, pressing with the left mouse button and dragging the mouse. Pressing the left mouse button in this case selects the object. Dragging the mouse drags the object. (Note that if the pointer is over two different elements that can be dragged, the topmost element should be the one selected and dragged.) Releasing the mouse button drops the object on the target below the pointer location. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The user selects one or more objects in a collection using the left mouse button. The user then positions the pointer anywhere over the selection, presses the left mouse button, and drags the mouse to drag the object(s). As with the above scenario, when the user releases the mouse button, the object is dropped on the target below the pointer location. Note that in this case, if users positions the pointer outside of the selection and begins dragging with the left mouse button, they're indicating that they want to make a new selection. See <XREF IDREF="59818" TYPE="TITLE">&ldquo;Selection&rdquo;</XREF> earlier in this chapter.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>For either of the above scenarios, after a drop the target should determine both the format of the data and whether the user meant to perform a move or a copy operation. In some cases, dropping the object might simply mean that the object should be moved to a new location in the same component. In the case where the drop is in the same component, after the drop the data should remain selected. For example, the user can move files around in a Directory View window using drag and drop. In other cases, dragging an object onto a target means that the object should be copied to the target so that the target can perform some operation on it. For example, when the user drags a file onto a printer icon, the file is translated into an appropriate format and sent to the printer.</PARAGRAPH>
<PARAGRAPH>To make drag and drop of file objects easy to include in your application, IRIX Interactive Desktop includes a file finder component, which provides a drop pocket (see <INDEXTARGET ID="ch07.focus37"><!-- POSTPROCESSDATA: ch07.focus37|controls:File FinderFile Finder --><XREF IDREF="45317" TYPE="GRAPHIC">Figure&nbsp;7-3</XREF>). If the user drops a file icon in the drop pocket, the text field updates to show the pathname of the file represented by the icon. If the user types in the field, the icon in the drop pocket changes to show the new choice. For guidelines on when to use this type of control in your application, see <XREF IDREF="43846" TYPE="TITLE">&ldquo;File Finder&rdquo; in Chapter&nbsp;9</XREF>.</PARAGRAPH>
<!-- RASTERCONVERT: ch07.focus.cgm3 -->
<PARAGRAPH><FIGURE><GRAPHIC FILE="ch07.focus-3.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="7-3"><PREFIX>Figure 7-3 </PREFIX><XREFTARGET ID="45317">File Finder Component</CAPTION>
</FIGURE>
</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Drag and Drop for Text</TITLE><PARAGRAPH>Drag and drop can also be implemented using the middle mouse button. Use this model of drag and drop for transferring text rather than the model described in the previous section because the left mouse button is so heavily used for selection in text.<INDEXTARGET ID="ch07.focus38"><!-- POSTPROCESSDATA: ch07.focus38|drag and drop:text --></PARAGRAPH>
<PARAGRAPH>In this case, the user selects a region of text to be dragged using the selection techniques described in <XREF IDREF="59818" TYPE="TITLE">&ldquo;Selection,&rdquo;</XREF> earlier in this chapter. Then the user positions the pointer over the selected text region and drags the text with the middle mouse button. When the user releases the middle mouse button, the text is dropped on the target under the pointer. By default, all text (including labels) can be dragged using the middle mouse button. You may want to turn off drag and drop for some of the text in your application if users will never need to drag it (for example, labels).</PARAGRAPH>
<PARAGRAPH>For additional details of implementing drag and drop of text, see Sections 4.3.4 and 6.2.5 in the <DOCTITLE>OSF/Motif</DOCTITLE>&space;<DOCTITLE>Style Guide</DOCTITLE>.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="77130">Pointers for Drag Operations</TITLE><PARAGRAPH>When selecting and dragging are integrated into the left mouse button, use the standard arrow cursor for simplicity. When drag and drop is implemented using the middle mouse button (typically for dragging text), replace the standard pointer with a <INDEXTARGET ID="ch07.focus39"><!-- POSTPROCESSDATA: ch07.focus39|drag and drop:pointerspointer:drag and dropdrag icons --><ITALICS>drag icon</ITALICS>. This reinforces to users that they're using the middle mouse button to perform a drag and drop operation. The design of drag icons is discussed in Section 6.2.5.1 of the &lbreak;<DOCTITLE>OSF/Motif</DOCTITLE>&space;<DOCTITLE>Style Guide</DOCTITLE>. </PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Drag and Drop Guidelines</TITLE><PARAGRAPH><BOLD>When designing drag and drop for your application . . .</BOLD>&space;</PARAGRAPH>
<CHECKOFF><CHECKOFFITEM>Cancel a drag and drop operation if the user presses &lt;Esc>, and leave both the object and the target as they were before the operation was initiated.</CHECKOFFITEM>
<CHECKOFFITEM>Use the left mouse button for both selecting and dragging non-text objects. Use the standard cursor in this case.</CHECKOFFITEM>
<CHECKOFFITEM>Use the middle mouse button for dragging text, and replace the cursor with a drag icon when the text is being dragged.</CHECKOFFITEM>
</CHECKOFF>
</SECTION2>
</SECTION1>
</CHAPTER>
