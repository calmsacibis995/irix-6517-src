<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="1"><TITLE><XREFTARGET ID="82162">Process Address Space</TITLE><PARAGRAPH>When planning a complex program, you must understand how IRIX creates the virtual address space of a process, and how you can modify the normal behavior of the address space. The major topics covered here are as follows:<INDEXTARGET ID="TIP_1.aspace1"><!-- POSTPROCESSDATA: TIP_1.aspace1|memory --><INDEXTARGET ID="TIP_1.aspace2"><!-- POSTPROCESSDATA: TIP_1.aspace2|virtual memory: <ITALICS>See also</ITALICS> memoryvirtual memory:ZZZ --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="71588" TYPE="TITLE">&ldquo;Defining the Address Space&rdquo;</XREF> tells what the address space is and how it is created.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="76038" TYPE="TITLE">&ldquo;Interrogating the Memory System&rdquo;</XREF> summarizes the ways your program can get information about the address space.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="54272" TYPE="TITLE">&ldquo;Mapping Segments of Memory&rdquo;</XREF> documents the different ways that you can create new memory segments with predefined contents.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="25692" TYPE="TITLE">&ldquo;Locking and Unlocking Pages in Memory&rdquo;</XREF> discusses when and how to lock pages of virtual memory to avoid page faults.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="48924" TYPE="TITLE">&ldquo;Additional Memory Features&rdquo;</XREF> summarizes functions for address space management.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="88017" TYPE="TITLE">&ldquo;Using Origin2000 Nonuniform Memory&rdquo;</XREF> describes the use of CC-NUMA memory in the Origin2000 and Onyx2 systems.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="71588">Defining the Address Space</TITLE><PARAGRAPH>Each user-level process has a virtual address space. This term means simply: the set of memory addresses that the process can use without error. When 32-bit addressing is in use, addresses can range from 0 to 0x7fffffff; that is, 2^31 possible numbers, for a total theoretical size of 2 gigabytes. (Numbers greater than 2^31 are in the IRIX kernel's address space.)<INDEXTARGET ID="TIP_1.aspace3"><!-- POSTPROCESSDATA: TIP_1.aspace3|32-bit addressing:address size --><INDEXTARGET ID="TIP_1.aspace4"><!-- POSTPROCESSDATA: TIP_1.aspace4|64-bit addressing:address size --><INDEXTARGET ID="TIP_1.aspace5"><!-- POSTPROCESSDATA: TIP_1.aspace5|kernel address space --><INDEXTARGET ID="TIP_1.aspace6"><!-- POSTPROCESSDATA: TIP_1.aspace6|memory:address ranges of --><INDEXTARGET ID="TIP_1.aspace7"><!-- POSTPROCESSDATA: TIP_1.aspace7|address range --><INDEXTARGET ID="TIP_1.aspace8"><!-- POSTPROCESSDATA: TIP_1.aspace8|virtual address space. <ITALICS>See</ITALICS> address space --><INDEXTARGET ID="TIP_1.aspace9"><!-- POSTPROCESSDATA: TIP_1.aspace9|address space --></PARAGRAPH>
<PARAGRAPH>When 64-bit addressing is used, a process's address space can encompass 2^40 numbers. (The numbers greater than 2^40 are reserved for kernel address spaces.) For more details on the structure of physical and virtual address spaces, see the <DOCTITLE>IRIX Device Driver Programmer's Guide</DOCTITLE> and the MIPS architecture documents listed on <XREF IDREF="67758" TYPE="TEXT">page&nbsp;xxxiv</XREF>.</PARAGRAPH>
<PARAGRAPH>Although the address space includes a vast quantity of potential numbers, usually only a small fraction of the addresses are valid.</PARAGRAPH>
<PARAGRAPH>A <INDEXTARGET ID="TIP_1.aspace10"><!-- POSTPROCESSDATA: TIP_1.aspace10|memory:segment --><INDEXTARGET ID="TIP_1.aspace11"><!-- POSTPROCESSDATA: TIP_1.aspace11|address space:segment --><INDEXTARGET ID="TIP_1.aspace12"><!-- POSTPROCESSDATA: TIP_1.aspace12|segment --><ITALICS>segment</ITALICS> of the address space is any range of contiguous addresses. Certain segments are created or reserved for certain uses.</PARAGRAPH>
<PARAGRAPH>The address space is called &ldquo;virtual&rdquo; because the address numbers are not directly related to physical RAM addresses where the data resides. The mapping from a virtual address to the corresponding real memory location is kept in a table created by the IRIX kernel and used by the MIPS processor chip. </PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="16308">Address Space Boundaries</TITLE><PARAGRAPH>A process has at least three segments of usable addresses:<INDEXTARGET ID="TIP_1.aspace13"><!-- POSTPROCESSDATA: TIP_1.aspace13|process:address space --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>A <INDEXTARGET ID="TIP_1.aspace14"><!-- POSTPROCESSDATA: TIP_1.aspace14|text segment --><INDEXTARGET ID="TIP_1.aspace15"><!-- POSTPROCESSDATA: TIP_1.aspace15|segment:text --><INDEXTARGET ID="TIP_1.aspace16"><!-- POSTPROCESSDATA: TIP_1.aspace16|address space:text segment --><ITALICS>text</ITALICS> segment contains the executable image of the program. Another text segment is created for each dynamic shared object (DSO) with which a process is linked.Text segments are always read-only.<INDEXTARGET ID="TIP_1.aspace17"><!-- POSTPROCESSDATA: TIP_1.aspace17|DSO, text segment for --></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A <INDEXTARGET ID="TIP_1.aspace18"><!-- POSTPROCESSDATA: TIP_1.aspace18|heap segment --><INDEXTARGET ID="TIP_1.aspace19"><!-- POSTPROCESSDATA: TIP_1.aspace19|segment:heap --><INDEXTARGET ID="TIP_1.aspace20"><!-- POSTPROCESSDATA: TIP_1.aspace20|address space:heap segment --><ITALICS>data</ITALICS> segment contains the &ldquo;heap&rdquo; of dynamically allocated data space. A process can create additional data segments in various ways described later.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A <INDEXTARGET ID="TIP_1.aspace21"><!-- POSTPROCESSDATA: TIP_1.aspace21|stack segment --><INDEXTARGET ID="TIP_1.aspace22"><!-- POSTPROCESSDATA: TIP_1.aspace22|segment:stack --><INDEXTARGET ID="TIP_1.aspace23"><!-- POSTPROCESSDATA: TIP_1.aspace23|address space:stack segment --><ITALICS>stack</ITALICS> segment contains the function-call stack. This segment is extended automatically as needed.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Although the address space begins at location 0, by convention the lowest segment is allocated at 0x0040&nbsp;0000 (4&nbsp;MB). Addresses less than this are intentionally left undefined so that any attempt to use them (for example, through an uninitialized pointer variable) causes a hardware exception and stops the program.<INDEXTARGET ID="TIP_1.aspace24"><!-- POSTPROCESSDATA: TIP_1.aspace24|address space:lowest used address --><INDEXTARGET ID="TIP_1.aspace25"><!-- POSTPROCESSDATA: TIP_1.aspace25|segment:lowest address --></PARAGRAPH>
<PARAGRAPH>Typically, text segments are at smaller virtual addresses and stack and data segments at larger ones, although you should not write code that depends on this.</PARAGRAPH>
<TIP><PREFIX>Tip</PREFIX>The boundaries of all distributed DSOs are declared in the file <FILENAME>/usr/lib/so_locations</FILENAME>. When IRIX loads a DSO that is not declared in this file, it seeks a segment of the address space that does not overlap any declared DSO and that will not interfere with growth of the stack segment. To learn more about DSOs, see the <REFPAGE>rld(1)</REFPAGE> and <REFPAGE>dso(5)</REFPAGE> reference pages, and the <DOCTITLE>MIPSpro Compiling, Linking, and Performance Tuning Guide</DOCTITLE>.</TIP>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="94319">Page Numbers and Offsets</TITLE><PARAGRAPH>IRIX manages memory in units of a page. The size of a page can differ from one system to another. In systems such as the O2 workstation, which support only 32-bit addressing, the page size is always 4,096 bytes. In each 32-bit virtual address,<INDEXTARGET ID="TIP_1.aspace26"><!-- POSTPROCESSDATA: TIP_1.aspace26|32-bit addressing:page size --><INDEXTARGET ID="TIP_1.aspace27"><!-- POSTPROCESSDATA: TIP_1.aspace27|page size --><INDEXTARGET ID="TIP_1.aspace28"><!-- POSTPROCESSDATA: TIP_1.aspace28|memory:page --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>the least-significant 12 bits specify an offset from 0 to 0x0fff within a page</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the most-significant 20 bits specify a virtual page number (VPN)<INDEXTARGET ID="TIP_1.aspace29"><!-- POSTPROCESSDATA: TIP_1.aspace29|VPN. <ITALICS>See</ITALICS> virtual page number --><INDEXTARGET ID="TIP_1.aspace30"><!-- POSTPROCESSDATA: TIP_1.aspace30|virtual page number --></PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>In systems that support 64-bit addressing the page size is greater than 4,096 bytes. The page size is configurable, and in fact different programs can have different page sizes, and a single program can have different size pages for the text segment, stack segment, and data segments. However, the page size is always a power of 2, and the bits of the virtual address are used in the same way: the least-significant bits of an address specify an offset within a page, while the most-significant bits specify the VPN.<INDEXTARGET ID="TIP_1.aspace31"><!-- POSTPROCESSDATA: TIP_1.aspace31|64-bit addressing:page size --></PARAGRAPH>
<PARAGRAPH>You can learn the actual size of a page in the present system with <INDEXTARGET ID="TIP_1.aspace32"><!-- POSTPROCESSDATA: TIP_1.aspace32|<FUNCTION>getpagesize()</FUNCTION> --><FUNCTION>getpagesize()</FUNCTION>, as noted under <XREF IDREF="76038" TYPE="TITLE">&ldquo;Interrogating the Memory System&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>Page tables, built by IRIX during a <FUNCTION>fork()</FUNCTION> or <FUNCTION>exec()</FUNCTION> call, define the address space for a process by specifying which VPNs are defined. These tables are consulted by the hardware. Recently-used table entries are cached for instant lookup in the processor chip, in an array called the Translation Lookaside Buffer (TLB).</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="82209">Address Definition</TITLE><PARAGRAPH>Most of the possible addresses in an address space are undefined; that is, not defined in the page tables, not related to contents of any kind, and not available for use. A reference to an undefined address causes a SIGSEGV error.<INDEXTARGET ID="TIP_1.aspace33"><!-- POSTPROCESSDATA: TIP_1.aspace33|signal:SIGSEGV --><INDEXTARGET ID="TIP_1.aspace34"><!-- POSTPROCESSDATA: TIP_1.aspace34|address space:defining addresses --><INDEXTARGET ID="TIP_1.aspace35"><!-- POSTPROCESSDATA: TIP_1.aspace35|SIGSEGV:on reference to undefined page --></PARAGRAPH>
<PARAGRAPH>Addresses are <ITALICS>defined</ITALICS>&mdash;that is, made available for potential use&mdash;in one of five ways: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Fork</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>When a process is created using <INDEXTARGET ID="TIP_1.aspace36"><!-- POSTPROCESSDATA: TIP_1.aspace36|<FUNCTION>fork()</FUNCTION>:defines address space --><FUNCTION>fork()</FUNCTION>, the new process is given a 
duplicate copy of the parent process's page table, so that any addresses 
that were defined in the parent's address space are defined the same way 
in the address space of the new process. (See the <REFPAGE>fork(2)</REFPAGE> reference page.)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Exec</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>The <INDEXTARGET ID="TIP_1.aspace37"><!-- POSTPROCESSDATA: TIP_1.aspace37|<FUNCTION>exec()</FUNCTION>:new address space --><FUNCTION>exec()</FUNCTION> function creates a new address space in which to execute a 
specified program or interpreter. (See the <REFPAGE>exec(2)</REFPAGE> reference page.) </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Stack</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>The call stack is created and extended automatically. When a function is 
entered and more stack space is needed, IRIX makes the stack segment 
larger, defining new addresses if required.<INDEXTARGET ID="TIP_1.aspace38"><!-- POSTPROCESSDATA: TIP_1.aspace38|stack segment --></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Mapping</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>A process can ask IRIX to map (associate byte for byte) a segment of 
address space to one of a number of special objects, for example, the 
contents of a file. This is covered further under <INDEXTARGET ID="TIP_1.aspace39"><!-- POSTPROCESSDATA: TIP_1.aspace39|memory mapping --><XREF IDREF="54272" TYPE="TITLE">&ldquo;Mapping Segments of 
Memory&rdquo;</XREF>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Allocation</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>The<INDEXTARGET ID="TIP_1.aspace40"><!-- POSTPROCESSDATA: TIP_1.aspace40|<FUNCTION>malloc()</FUNCTION> --><INDEXTARGET ID="TIP_1.aspace41"><!-- POSTPROCESSDATA: TIP_1.aspace41|<FUNCTION>brk()</FUNCTION> --><INDEXTARGET ID="TIP_1.aspace42"><!-- POSTPROCESSDATA: TIP_1.aspace42|heap segment --><FUNCTION> brk()</FUNCTION> function extends the heap, the segment devoted to data, to a 
specific virtual address. The <FUNCTION>malloc()</FUNCTION> function allocates memory for use, 
calling <FUNCTION>brk()</FUNCTION> as required. (See the <REFPAGE>brk(2)</REFPAGE>, <REFPAGE>malloc(3)</REFPAGE>, and <REFPAGE>malloc(3x)</REFPAGE> 
reference pages).</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>An address is defined by an entry in the page tables. A defined address is always related to a <INDEXTARGET ID="TIP_1.aspace43"><!-- POSTPROCESSDATA: TIP_1.aspace43|swap --><INDEXTARGET ID="TIP_1.aspace44"><!-- POSTPROCESSDATA: TIP_1.aspace44|memory:backing store for --><INDEXTARGET ID="TIP_1.aspace45"><!-- POSTPROCESSDATA: TIP_1.aspace45|backing store --><ITALICS>backing store</ITALICS>, a source from which its contents can be refreshed. A page in a text segment is related to the executable file. A page of a data or stack segment is related to a page in a swap partition on disk.</PARAGRAPH>
<PARAGRAPH>The total size of the defined pages in an address space is its <INDEXTARGET ID="TIP_1.aspace46"><!-- POSTPROCESSDATA: TIP_1.aspace46|<COMMAND>ps</COMMAND> command --><INDEXTARGET ID="TIP_1.aspace47"><!-- POSTPROCESSDATA: TIP_1.aspace47|address space:virtual size of --><INDEXTARGET ID="TIP_1.aspace48"><!-- POSTPROCESSDATA: TIP_1.aspace48|virtual size --><ITALICS>virtual size</ITALICS>, displayed by the <COMMAND>ps</COMMAND> command under the heading SZ (see the <REFPAGE>ps(1)</REFPAGE> reference page).</PARAGRAPH>
<PARAGRAPH>Once addresses have been defined in the address space by allocation, there is no way to undefine them except to terminate the process. To free allocated memory makes the freed memory available for reuse within the process, but the pages are still defined in the page tables and the swap space is still allocated.<INDEXTARGET ID="TIP_1.aspace49"><!-- POSTPROCESSDATA: TIP_1.aspace49|address space:cannot undefine --></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="63368">Address Space Limits</TITLE><PARAGRAPH>The segments of the address space have maximum sizes that are set as resource limits on the process. Hard limits are set by these variables:<INDEXTARGET ID="TIP_1.aspace50"><!-- POSTPROCESSDATA: TIP_1.aspace50|rlimit kernel parameter --><INDEXTARGET ID="TIP_1.aspace51"><!-- POSTPROCESSDATA: TIP_1.aspace51|kernel:address space limits in --><INDEXTARGET ID="TIP_1.aspace52"><!-- POSTPROCESSDATA: TIP_1.aspace52|address space:limits of --></PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><VARIABLE>rlimit_vmem_max</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Total size of the address space of a process</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><VARIABLE>rlimit_data_max</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Size of the portion of the address space used for data</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><VARIABLE>rlimit_stack_max</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="243"><PARAGRAPH>Size of the portion of the address space used for stack</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The limits active during a login session can be displayed and changed using the C-shell command <INDEXTARGET ID="TIP_1.aspace53"><!-- POSTPROCESSDATA: TIP_1.aspace53|<FUNCTION>setrlimit()</FUNCTION> --><INDEXTARGET ID="TIP_1.aspace54"><!-- POSTPROCESSDATA: TIP_1.aspace54|<FUNCTION>getrlimit()</FUNCTION> --><INDEXTARGET ID="TIP_1.aspace55"><!-- POSTPROCESSDATA: TIP_1.aspace55|<ITALICS>limits</ITALICS> command --><COMMAND>limits</COMMAND>. A program can query the limits with <FUNCTION>getrlimit()</FUNCTION> and change them with <FUNCTION>setrlimit()</FUNCTION> (see the <REFPAGE>getrlimit(2)</REFPAGE> reference page).</PARAGRAPH>
<PARAGRAPH>The initial default value and the possible range of a resource limit is established in the kernel tuning parameters. For a quick look at the kernel limits, use</PARAGRAPH>
<EXAMPLE>
fgrep rlimit /var/sysgen/mtune/kernel
</EXAMPLE>
<PARAGRAPH>To examine and change the limits, use <INDEXTARGET ID="TIP_1.aspace56"><!-- POSTPROCESSDATA: TIP_1.aspace56|<ITALICS>systune</ITALICS> command --><COMMAND>systune</COMMAND> (see the <REFPAGE>systune(1)</REFPAGE> reference page):</PARAGRAPH>
<CODE><CAPTION LBL="1-1"><PREFIX>Example 1-1 </PREFIX>Using systune to Check Address Space Limits</CAPTION>systune -i
Updates will be made to running system and /unix.install
systune-> rlimit_vmem_max
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rlimit_vmem_max = 536870912 (0x20000000) ll
systune-> resource
group: resource (statically changeable)
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rlimit_vmem_max = 536870912 (0x20000000) ll
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rlimit_vmem_cur = 536870912 (0x20000000) ll
...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rlimit_stack_max = 536870912 (0x20000000) ll
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rlimit_stack_cur = 67108864 (0x4000000) ll
...
</CODE>
<TIP><PREFIX>Tip</PREFIX>These limits interact in the following way: each time your program creates a process with <FUNCTION>sproc() </FUNCTION>and does not supply a stack area (see the<REFPAGE>&space;sproc(2)</REFPAGE> reference page), an address segment equal to <VARIABLE>rlimit_stack_max</VARIABLE> is dedicated to the stack of the new process. When <VARIABLE>rlimit_stack_max</VARIABLE> is set high, a program that creates many processes can quickly run into the <VARIABLE>rlimit_vmem_max</VARIABLE> boundary.</TIP>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="61327">Delayed and Immediate Space Definition</TITLE><PARAGRAPH>IRIX supports two radically different ways of defining segments of address space.<INDEXTARGET ID="TIP_1.aspace57"><!-- POSTPROCESSDATA: TIP_1.aspace57|virtual swap --><INDEXTARGET ID="TIP_1.aspace58"><!-- POSTPROCESSDATA: TIP_1.aspace58|<FUNCTION>malloc()</FUNCTION> --><INDEXTARGET ID="TIP_1.aspace59"><!-- POSTPROCESSDATA: TIP_1.aspace59|<FUNCTION>brk()</FUNCTION> --></PARAGRAPH>
<PARAGRAPH>The conventional behavior of UNIX systems, and the default behavior of current releases of IRIX, is that space created using <FUNCTION>brk()</FUNCTION> or <FUNCTION>malloc()</FUNCTION> is immediately defined. Page table entries are created to define the addresses, and swap space is allocated as a backing store. Three results follow from the conventional method:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>A program can detect immediately when swap space is exhausted. A call to <INDEXTARGET ID="TIP_1.aspace60"><!-- POSTPROCESSDATA: TIP_1.aspace60|<FUNCTION>malloc()</FUNCTION>:used to find limit of swap --><FUNCTION>malloc()</FUNCTION> returns NULL when memory cannot be allocated. A program can test the limits of swap space by making repeated calls to <FUNCTION>malloc()</FUNCTION>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A large memory allocation by one program can fill the swap disk partition, causing other programs to see out-of-memory errors&mdash;whether the program ever uses its allocated memory or not.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A <FUNCTION>fork()</FUNCTION> or <FUNCTION>exec()</FUNCTION> call fails unless there is free space in swap equal to the data and stack sizes of the new process.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>By default in IRIX 5.2, and optionally in later releases, IRIX uses a different method sometimes called &ldquo;virtual swap.&rdquo; In this method, the definition of new segments is delayed until the space is actually used. Functions like <FUNCTION>brk()</FUNCTION> and <FUNCTION>malloc()</FUNCTION> merely test the new size of the data segment against the resource limits. They do not actually define the new addresses, and they do not cause swap disk space to be allocated. Addresses are <ITALICS>reserved</ITALICS> with <FUNCTION>brk()</FUNCTION> or <FUNCTION>malloc()</FUNCTION>, but they are only <ITALICS>defined</ITALICS> and allocated in swap when your program references them.</PARAGRAPH>
<PARAGRAPH>When IRIX uses delayed definition (&ldquo;virtual swap&rdquo;), it has the following effects:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>A program cannot find the limits of swap space using <FUNCTION>malloc()</FUNCTION>&mdash;it never returns NULL until the program exceeds its resource limit, regardless of available swap.</PARAGRAPH>
<PARAGRAPH>Instead, when a program finally accesses a new page of allocated space and there is <INDEXTARGET ID="TIP_1.aspace61"><!-- POSTPROCESSDATA: TIP_1.aspace61|virtual swap:SIGKILL from --><INDEXTARGET ID="TIP_1.aspace62"><!-- POSTPROCESSDATA: TIP_1.aspace62|SIGKILL:on reaching limit of virtual swap --><INDEXTARGET ID="TIP_1.aspace63"><!-- POSTPROCESSDATA: TIP_1.aspace63|signal:SIGKILL --><ITALICS>at that time</ITALICS> no room in the swap partition, the program receives a SIGKILL signal.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A large memory allocation by one program cannot monopolize the swap disk until the program actually uses the allocated memory, if it ever does.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Much less swap space is required for a successful <FUNCTION>fork()</FUNCTION> call.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>You can test whether the system uses virtual swap with the <COMMAND>chkconfig</COMMAND> command (as described in the <REFPAGE>chkconfig(1)</REFPAGE> reference page):</PARAGRAPH>
<CODE>
# chkconfig vswap; echo $status
0
</CODE>
<PARAGRAPH>As you write a new program, assume that virtual swap may be used. Do not allocate memory merely to find out if you can. Allocate no more memory than your program needs, and use the memory immediately after allocating it.</PARAGRAPH>
<PARAGRAPH>If you are porting a program written for a conventional UNIX system, you might discover that it tests the limits of allocatable memory by calling <FUNCTION>malloc()</FUNCTION> until <FUNCTION>malloc()</FUNCTION> returns a NULL, and then does not use the memory. In this case you have several choices:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Recode this part of the program to derive the maximum memory size in some more reasonable and portable way, for instance from an environment variable or the size of an input file.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Using <INDEXTARGET ID="TIP_1.aspace64"><!-- POSTPROCESSDATA: TIP_1.aspace64|<FUNCTION>setrlimit()</FUNCTION>:limit --><INDEXTARGET ID="TIP_1.aspace65"><!-- POSTPROCESSDATA: TIP_1.aspace65|<FUNCTION>malloc()</FUNCTION>:use --><FUNCTION>setrlimit()</FUNCTION>, set a lower maximum for <VARIABLE>rlimit_data_max</VARIABLE>, so that <FUNCTION>malloc()</FUNCTION> returns NULL at a reasonable allocation size, independent of the swap disk allocation (see the <REFPAGE>getrlimit(2)</REFPAGE> reference page).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Restore the conventional UNIX behavior for the whole system. Use <INDEXTARGET ID="TIP_1.aspace66"><!-- POSTPROCESSDATA: TIP_1.aspace66|<ITALICS>chkconfig</ITALICS> command --><COMMAND>chkconfig</COMMAND> to turn off the variable <VARIABLE>vswap</VARIABLE>, and reboot (see the <REFPAGE>chkconfig(1)</REFPAGE> reference page).</PARAGRAPH>
</BULLET>
</BULLETLIST>
<NOTE><PREFIX>Note</PREFIX>The function <INDEXTARGET ID="TIP_1.aspace67"><!-- POSTPROCESSDATA: TIP_1.aspace67|<FUNCTION>calloc()</FUNCTION> --><FUNCTION>calloc() </FUNCTION>touches all allocated pages in the course of filling them with zeros. Hence memory allocated by <FUNCTION>calloc()</FUNCTION> is defined as soon as it is allocated. However, you should not rely on this behavior. It is possible to implement <FUNCTION>calloc()</FUNCTION> in such a way that it, like <FUNCTION>malloc()</FUNCTION>, does not define allocated pages until they are used. This might be done in a future version of IRIX.<INDEXTARGET ID="TIP_1.aspace68"><!-- POSTPROCESSDATA: TIP_1.aspace68|virtual swap: <ITALICS>See also</ITALICS> address spacevirtual swap:ZZZ --></NOTE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="31393">Page Validation</TITLE><PARAGRAPH>Although an address is defined, the corresponding page is not necessarily loaded in physical memory. The sum of the defined address spaces of all processes is normally far larger than available real memory. IRIX keeps selected pages in real memory. A page that is not present in real memory is marked as &ldquo;invalid&rdquo; in the page tables. When the program refers to an address on an invalid page, the CPU traps to the kernel, which supplies the page.<INDEXTARGET ID="TIP_1.aspace69"><!-- POSTPROCESSDATA: TIP_1.aspace69|backing store --><INDEXTARGET ID="TIP_1.aspace70"><!-- POSTPROCESSDATA: TIP_1.aspace70|virtual memory:loading pages --><INDEXTARGET ID="TIP_1.aspace71"><!-- POSTPROCESSDATA: TIP_1.aspace71|page validation --></PARAGRAPH>
<PARAGRAPH>The contents of invalid pages can be supplied in one of the following ways: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Text</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="333"><PARAGRAPH>Pages of program text&mdash;executable code of programs and dynamically 
linked libraries&mdash;can be retrieved on demand from the program file or 
library files on disk.<INDEXTARGET ID="TIP_1.aspace72"><!-- POSTPROCESSDATA: TIP_1.aspace72|text segment:loaded from program file --></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Data</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="333"><PARAGRAPH>Pages of data from the heap and stack can be retrieved from the swap 
partition or file on disk.<INDEXTARGET ID="TIP_1.aspace73"><!-- POSTPROCESSDATA: TIP_1.aspace73|swap --></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Mapped</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="333"><PARAGRAPH>When a segment is created by <FUNCTION>mmap()</FUNCTION>, a backing store file is specified by 
the program (see <XREF IDREF="54272" TYPE="TITLE">&ldquo;Mapping Segments of Memory&rdquo;</XREF>).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Never used</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="333"><PARAGRAPH>Pages that have been defined but never used can be created as pages of 
binary zero when they are needed.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>When a process refers to a VPN that is defined but invalid, a hardware interrupt occurs. The interrupt handler in the IRIX kernel chooses a page of physical RAM to hold the page. In order to acquire this space, the kernel might have to invalidate some other page belonging to your process or to another process. The contents of the needed page are read from the appropriate backing store into memory, and the process continues to execute.<INDEXTARGET ID="TIP_1.aspace74"><!-- POSTPROCESSDATA: TIP_1.aspace74|interrupt:validity fault --><INDEXTARGET ID="TIP_1.aspace75"><!-- POSTPROCESSDATA: TIP_1.aspace75|validity fault --></PARAGRAPH>
<PARAGRAPH>Page validation takes from 10 to 50 milliseconds. Most applications are not impeded by page fault processing, but a real-time program cannot tolerate these delays.</PARAGRAPH>
<PARAGRAPH>The total size of all the defined pages in an address space is displayed by the <INDEXTARGET ID="TIP_1.aspace76"><!-- POSTPROCESSDATA: TIP_1.aspace76|<COMMAND>ps</COMMAND>command --><INDEXTARGET ID="TIP_1.aspace77"><!-- POSTPROCESSDATA: TIP_1.aspace77|resident set size --><INDEXTARGET ID="TIP_1.aspace78"><!-- POSTPROCESSDATA: TIP_1.aspace78|address space:resident set size --><COMMAND>ps</COMMAND> command under the heading SZ. The aggregate size of the pages that are actually in memory is the <ITALICS>resident set size</ITALICS>, displayed by <COMMAND>ps</COMMAND> under the heading RSS.</PARAGRAPH>
<TIP><PREFIX>Tip</PREFIX>A sophisticated IRIX user might know that the daemon responsible for reading and writing pages from disk was called <COMMAND>vhand</COMMAND>, and its activity could be monitored. However, starting with IRIX       6.4 all such system daemons became &ldquo;kernel threads&rdquo; and are no longer visible to commands such as <COMMAND>ps</COMMAND> or <COMMAND>gr_top</COMMAND>.</TIP>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Read-Only Pages</TITLE><PARAGRAPH>A page of memory can be marked as valid for reading but invalid for writing. Program text is marked this way because program text is read-only; it is never changed. If a process attempts to modify a read-only page, a hardware interrupt occurs. When the page is truly read-only, the kernel turns this into a SIGSEGV signal to the program. Unless the program is handling this signal, the result is to terminate the program with a segmentation fault.<INDEXTARGET ID="TIP_1.aspace79"><!-- POSTPROCESSDATA: TIP_1.aspace79|signal:SIGSEGV --><INDEXTARGET ID="TIP_1.aspace80"><!-- POSTPROCESSDATA: TIP_1.aspace80|SIGSEGV:on attempt to change read-only page --><INDEXTARGET ID="TIP_1.aspace81"><!-- POSTPROCESSDATA: TIP_1.aspace81|address space:read-only pages --><INDEXTARGET ID="TIP_1.aspace82"><!-- POSTPROCESSDATA: TIP_1.aspace82|text segment:read-only --><INDEXTARGET ID="TIP_1.aspace83"><!-- POSTPROCESSDATA: TIP_1.aspace83|page:read-only --></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Copy-on-Write Pages</TITLE><PARAGRAPH>When <INDEXTARGET ID="TIP_1.aspace84"><!-- POSTPROCESSDATA: TIP_1.aspace84|<FUNCTION>fork()</FUNCTION>:new address space copy-on-write --><INDEXTARGET ID="TIP_1.aspace85"><!-- POSTPROCESSDATA: TIP_1.aspace85|address space:copy-on-write pages --><INDEXTARGET ID="TIP_1.aspace86"><!-- POSTPROCESSDATA: TIP_1.aspace86|page:copy on write --><FUNCTION>fork()</FUNCTION> is executed, the new process shares the pages of the parent process under a rule of <ITALICS>copy-on-write</ITALICS>. The pages in the new address space are marked read-only. When the new process attempts to modify a page, a hardware interrupt occurs. The kernel makes a copy of that page, and changes the new address space to point to the copied page. Then the process continues to execute, modifying the page of which it now has a unique copy.</PARAGRAPH>
<PARAGRAPH>You can apply the copy-on-write discipline to the pages of an arena shared with other processes (see <XREF IDREF="51714" TYPE="TITLE">&ldquo;Mapping a File for Shared Memory&rdquo;</XREF>). </PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="76038">Interrogating the Memory System</TITLE><PARAGRAPH>You can get information about the state of the memory system with the system calls shown in <INDEXTARGET ID="TIP_1.aspace87"><!-- POSTPROCESSDATA: TIP_1.aspace87|memory:interrogating size of --><INDEXTARGET ID="TIP_1.aspace88"><!-- POSTPROCESSDATA: TIP_1.aspace88|address space:interrogating --><XREF IDREF="45521" TYPE="TABLE">Table&nbsp;1-1</XREF>.</PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="1-1"><PREFIX>Table 1-1 </PREFIX><XREFTARGET ID="45521">Memory System Calls <INDEXTARGET ID="TIP_1.aspace89"><!-- POSTPROCESSDATA: TIP_1.aspace89|<FUNCTION>sysconf()</FUNCTION> --></CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="153"><PARAGRAPH>Memory Information</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="234"><PARAGRAPH>System Call Invocation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>Size of a page (in a data segment) </PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="234"><PARAGRAPH>uiPageSize = getpagesize();&lbreak;uiPageSize = sysconf(_SC_PAGESIZE);</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>Virtual and resident sizes of a process</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="234"><PARAGRAPH>syssgi(SGI_PROCSZ, pid, &amp;uiSZ, &amp;uiRSS);</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>Maximum stack size of a process</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="234"><PARAGRAPH>uiStackSize = prctl(PR_GETSTACKSIZE)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>Free swap space in 512-byte units</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="234"><PARAGRAPH>swapctl(SC_GETFREESWAP, &amp;uiBlocks);</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>Total physical swap space in 512-byte 
units</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="234"><PARAGRAPH>swapctl(SC_GETSWAPTOT, &amp;uiBlocks);</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>Total real memory</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="234"><PARAGRAPH>sysmp(MP_KERNADDR, MPSA_RMINFO, &amp;rmstruct);</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>Free real memory</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="234"><PARAGRAPH>sysmp(MP_KERNADDR, MPSA_RMINFO, &amp;rmstruct);</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="153"><PARAGRAPH>Total real memory + swap space</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="234"><PARAGRAPH>sysmp(MP_KERNADDR, MPSA_RMINFO, &amp;rmstruct);</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The structure used with the <FUNCTION>sysmp()</FUNCTION> call shown above has this form (a more detailed layout is in <FILENAME>sys/sysmp.h</FILENAME>):</PARAGRAPH>
<CODE>
struct rminfo {
&nbsp;&nbsp;&nbsp;__uint32_t freemem; /* pages of free memory */
&nbsp;&nbsp;&nbsp;__uint32_t availsmem; /* total real+swap memory space */
&nbsp;&nbsp;&nbsp;__uint32_t availrmem; /* available real memory space */
&nbsp;&nbsp;&nbsp;__uint32_t bufmem; /* not useful */
&nbsp;&nbsp;&nbsp;__uint32_t physmem; /* total real memory space */
};
</CODE>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="54272">Mapping Segments of Memory</TITLE><PARAGRAPH>Your process can create new segments within the address space. Such a &ldquo;mapped&rdquo; segment can represent<INDEXTARGET ID="TIP_1.aspace90"><!-- POSTPROCESSDATA: TIP_1.aspace90|memory: <ITALICS>See also</ITALICS> memory mapping, virtual memorymemory:ZZZ --><INDEXTARGET ID="TIP_1.aspace91"><!-- POSTPROCESSDATA: TIP_1.aspace91|memory mapping --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>the contents of a file</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>a segment initialized to binary zero</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>a POSIX shared memory object</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>a view of the kernel's private address space or of physical memory</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>a portion of VME A24 or A32 bus address space (when a VME bus exists on the system)</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>A mapped segment can be private to one address space, or it can be shared between address spaces. When shared, it can be</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>read-only to all processes</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>read-write to the creating process and read-only to others</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>read-write to all sharing processes</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>copy-on-write, so that any sharing process that modifies a page is given its own unique copy of that page</PARAGRAPH>
</BULLET>
</BULLETLIST>
<NOTE><PREFIX>Note</PREFIX>Some of the memory-mapping capabilities described in this section are unique to IRIX and nonportable. Some of the capabilities are compatible with System V Release&nbsp;4 (SVR4). IRIX also supports the POSIX 1003.1b shared memory functions. Compatibility issues with SVR4 and POSIX are noted in the text of this section.</NOTE>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="29280">Segment Mapping Function mmap()</TITLE><PARAGRAPH>The <INDEXTARGET ID="TIP_1.aspace92"><!-- POSTPROCESSDATA: TIP_1.aspace92|<FUNCTION>mmap()</FUNCTION> --><FUNCTION>mmap()</FUNCTION> function (see the <REFPAGE>mmap(2)</REFPAGE> reference page) creates shared or unshared segments of memory. The syntax and most basic features of <FUNCTION>mmap()</FUNCTION> are compatible with SVR4 and with POSIX 1003.1b. A few features of <FUNCTION>mmap()</FUNCTION> are unique to IRIX.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>mmap()</FUNCTION> function performs many kinds of mappings based on six parameters. The function prototype is</PARAGRAPH>
<CODE>
void * mmap(void *<VARIABLE>addr</VARIABLE>, size_t <VARIABLE>len</VARIABLE>, int <VARIABLE>prot</VARIABLE>, int <VARIABLE>flags</VARIABLE>, int <VARIABLE>fd</VARIABLE>, off_t <VARIABLE>off</VARIABLE>)
</CODE>
<PARAGRAPH>The function returns the base address of a new segment, or else -1 to indicate that no segment was created. The size of the new segment is <VARIABLE>len</VARIABLE>, rounded up to a page. An attempt to access data beyond that point causes a SIGBUS signal.<INDEXTARGET ID="TIP_1.aspace93"><!-- POSTPROCESSDATA: TIP_1.aspace93|signal:SIGBUS --><INDEXTARGET ID="TIP_1.aspace94"><!-- POSTPROCESSDATA: TIP_1.aspace94|SIGBUS:on reference past end of mapped segment --></PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Describing the Mapped Object</TITLE><PARAGRAPH>Three of the <INDEXTARGET ID="TIP_1.aspace95"><!-- POSTPROCESSDATA: TIP_1.aspace95|<FUNCTION>mmap()</FUNCTION>:parameters of --><FUNCTION>mmap()</FUNCTION> parameters describe the object to be mapped into memory (which is the backing store of the new segment): </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="36"><PARAGRAPH><VARIABLE>fd</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="45" WIDTH="360"><PARAGRAPH>A file descriptor returned by <INDEXTARGET ID="TIP_1.aspace96"><!-- POSTPROCESSDATA: TIP_1.aspace96|backing store --><INDEXTARGET ID="TIP_1.aspace97"><!-- POSTPROCESSDATA: TIP_1.aspace97|<FUNCTION>open()</FUNCTION> --><INDEXTARGET ID="TIP_1.aspace98"><!-- POSTPROCESSDATA: TIP_1.aspace98|file descriptor:with <FUNCTION>mmap()</FUNCTION> --><FUNCTION>open()</FUNCTION> or by the POSIX-defined function 
<FUNCTION>shm_open()</FUNCTION> (see the<REFPAGE> open(2)</REFPAGE> and <REFPAGE>shm_open(2)</REFPAGE> reference pages). All <FUNCTION>mmap()</FUNCTION> calls 
require a file descriptor to define the backing store for the mapped segment. The 
descriptor can represent a file, or it can be based on a pseudo-file that represents 
kernel memory or a device special file.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="36"><PARAGRAPH><VARIABLE>off</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="45" WIDTH="360"><PARAGRAPH>The offset into the object represented by <VARIABLE>fd</VARIABLE> where the mapped data begins. When 
<VARIABLE>fd</VARIABLE> describes a disk file, <VARIABLE>off</VARIABLE> is an offset into the file. When <VARIABLE>fd</VARIABLE> describes memory, <VARIABLE>off</VARIABLE> 
is an address in that memory. <VARIABLE>off</VARIABLE> must be an integral multiple of the memory page 
size (see <XREF IDREF="76038" TYPE="TITLE">&ldquo;Interrogating the Memory System&rdquo;</XREF>).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="36"><PARAGRAPH><VARIABLE>len</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="45" WIDTH="360"><PARAGRAPH>The number of bytes of data from <VARIABLE>fd</VARIABLE> to be mapped. The initial size of the segment 
is <VARIABLE>len</VARIABLE>, rounded up to a multiple of whole pages.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Describing the New Segment</TITLE><PARAGRAPH>Three parameters of <FUNCTION>mmap()</FUNCTION> describe the segment to be created: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>addr</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="351"><PARAGRAPH>Normally 0 to indicate that IRIX should pick a convenient base address, <VARIABLE>addr</VARIABLE> 
can specify a virtual address to be the base of the segment. See <XREF IDREF="27102" TYPE="TITLE">&ldquo;Choosing a 
Segment Address&rdquo;</XREF>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH><VARIABLE>prot</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="351"><PARAGRAPH>Access control on the new segment. You use constants to specify a combination 
of read, write, and execute permission. The access control can be changed later 
(see <XREF IDREF="90829" TYPE="TITLE">&ldquo;Changing Memory Protection&rdquo;</XREF>).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><VARIABLE>flags</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="351"><PARAGRAPH>Options on how the new segment is to be managed.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The elements of <VARIABLE>flags</VARIABLE> determine the way the segment behaves, and are as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH>MAP_FIXED </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="288"><PARAGRAPH>Take <VARIABLE>addr</VARIABLE> literally.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH>MAP_PRIVATE </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="288"><PARAGRAPH>Changes to the mapped data are visible only to this process.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH>MAP_SHARED </PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="288"><PARAGRAPH>Changes to the mapped data are visible to all processes that map 
the same object.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH>MAP_AUTOGROW</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="288"><PARAGRAPH>Extend the object when the process stores beyond its end (not a 
POSIX feature)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH>MAP_LOCAL</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="288"><PARAGRAPH>Map is not visible to other processes in share group (not POSIX)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH>MAP_AUTORESRV</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="288"><PARAGRAPH>Delay reserving swap space until a store is done (not POSIX).</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The MAP_FIXED element of <VARIABLE>flags</VARIABLE> modifies the meaning of <VARIABLE>addr</VARIABLE>. Discussion of this is under <XREF IDREF="27102" TYPE="TITLE">&ldquo;Choosing a Segment Address&rdquo;</XREF>. </PARAGRAPH>
<PARAGRAPH>The MAP_AUTOGROW element of <INDEXTARGET ID="TIP_1.aspace99"><!-- POSTPROCESSDATA: TIP_1.aspace99|MAP_AUTOGROW flag --><VARIABLE>flags</VARIABLE> specifies what should happen when a process stores data past the current end of the segment (provided storing is allowed by <VARIABLE>prot</VARIABLE>). When <VARIABLE>flags</VARIABLE> contains MAP_AUTOGROW, the segment is extended with zero-filled space. Otherwise the initial <VARIABLE>len</VARIABLE> value is a permanent limit, and an attempt to store more than <VARIABLE>len</VARIABLE> bytes from the base address causes a SIGSEGV signal. <INDEXTARGET ID="TIP_1.aspace100"><!-- POSTPROCESSDATA: TIP_1.aspace100|signal:SIGSEGV --><INDEXTARGET ID="TIP_1.aspace101"><!-- POSTPROCESSDATA: TIP_1.aspace101|SIGSEGV:on store past end of mapped segment --></PARAGRAPH>
<PARAGRAPH>Two elements of <VARIABLE>flags</VARIABLE> specify the rules for sharing the segment between two address spaces when the segment is writable:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>MAP_SHARED specifies that changes made to the common pages are visible to other processes sharing the segment. This is the normal setting when a memory arena is shared among multiple processes.<INDEXTARGET ID="TIP_1.aspace102"><!-- POSTPROCESSDATA: TIP_1.aspace102|MAP_SHARED flag --></PARAGRAPH>
<PARAGRAPH>When a mapped segment is writable, any changes to the segment in memory are also written to the file that is mapped. The mapped file is the backing store for the segment.</PARAGRAPH>
<PARAGRAPH>When MAP_AUTOGROW is specified also, a store beyond the end of the segment lengthens the segment and also the file to which it is mapped.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>MAP_PRIVATE specifies that changes to shared pages are private to the process that makes the changes.<INDEXTARGET ID="TIP_1.aspace103"><!-- POSTPROCESSDATA: TIP_1.aspace103|MAP_PRIVATE flag --></PARAGRAPH>
<PARAGRAPH>The pages of a private segment are shared on a copy-on-write basis&mdash;there is only one copy as long as they are unmodified. When the process that specifies MAP_PRIVATE stores into the segment, that page is copied. The process has a private copy of the modified page from then on. The backing store for unmodified pages is the file, while the backing store for modified pages is the system swap space.</PARAGRAPH>
<PARAGRAPH>When MAP_AUTOGROW is specified also, a store beyond the end of the segment lengthens only the private copy of the segment; the file is unchanged.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The difference between MAP_SHARED and MAP_PRIVATE is important only when the segment can be modified. When the <VARIABLE>prot</VARIABLE> argument does not include PROT_WRITE, there is no question of modifying or extending the segment, so the backing store is always the mapped object. However, the choice of MAP_SHARED or MAP_PRIVATE does affect how you lock the mapped segment into memory, if you do; see <XREF IDREF="96827" TYPE="TITLE">&ldquo;Locking Program Text and Data&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>Processes created with <INDEXTARGET ID="TIP_1.aspace104"><!-- POSTPROCESSDATA: TIP_1.aspace104|MAP_LOCAL flag --><INDEXTARGET ID="TIP_1.aspace105"><!-- POSTPROCESSDATA: TIP_1.aspace105|lightweight process:and mapped segments --><INDEXTARGET ID="TIP_1.aspace106"><!-- POSTPROCESSDATA: TIP_1.aspace106|<FUNCTION>sproc()</FUNCTION>:and mapped segments --><FUNCTION>sproc()</FUNCTION> normally share a single address space, including mapped segments (see the <REFPAGE>sproc(2)</REFPAGE> reference page). However, if <VARIABLE>flags</VARIABLE> contains MAP_LOCAL, each new process created with <FUNCTION>sproc()</FUNCTION> receives a private copy of the mapped segment on a copy-on-write basis.</PARAGRAPH>
<PARAGRAPH>When the segment is based on a file or on <INDEXTARGET ID="TIP_1.aspace107"><!-- POSTPROCESSDATA: TIP_1.aspace107|MAP_AUTOGROW flag --><INDEXTARGET ID="TIP_1.aspace108"><!-- POSTPROCESSDATA: TIP_1.aspace108|<ITALICS>/dev/zero</ITALICS>:and <FUNCTION>mmap()</FUNCTION> --><INDEXTARGET ID="TIP_1.aspace109"><!-- POSTPROCESSDATA: TIP_1.aspace109|<FUNCTION>mmap()</FUNCTION>:when swap is allocated --><INDEXTARGET ID="TIP_1.aspace110"><!-- POSTPROCESSDATA: TIP_1.aspace110|memory mapping:when pages are defined --><FILENAME>/dev/zero</FILENAME> (see <XREF IDREF="67507" TYPE="TITLE">&ldquo;Mapping a Segment of Zeros&rdquo;</XREF>), <FUNCTION>mmap()</FUNCTION> normally defines all the pages in the segment. This includes allocating swap space for the pages of a segment based on <FILENAME>/dev/zero</FILENAME>. However, if <VARIABLE>flags</VARIABLE> contains MAP_AUTOGROW, the pages are not defined until they are accessed (see <XREF IDREF="61327" TYPE="TITLE">&ldquo;Delayed and Immediate Space Definition&rdquo;</XREF>).</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>The MAP_LOCAL and MAP_AUTOGROW flag elements are IRIX features that are not portable to POSIX or to System V.<INDEXTARGET ID="TIP_1.aspace111"><!-- POSTPROCESSDATA: TIP_1.aspace111|MAP_LOCAL flag --><INDEXTARGET ID="TIP_1.aspace112"><!-- POSTPROCESSDATA: TIP_1.aspace112|MAP_AUTOGROW flag --></NOTE>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="87009">Mapping a File for I/O</TITLE><PARAGRAPH>You can use <INDEXTARGET ID="TIP_1.aspace113"><!-- POSTPROCESSDATA: TIP_1.aspace113|file, mapping into memory --><INDEXTARGET ID="TIP_1.aspace114"><!-- POSTPROCESSDATA: TIP_1.aspace114|memory mapping:for I/O --><FUNCTION>mmap()</FUNCTION> as a simple, low-overhead way of reading and writing a disk file. Open the file using <FUNCTION>open()</FUNCTION>, but instead of passing the file descriptor to <FUNCTION>read()</FUNCTION> or <FUNCTION>write()</FUNCTION>, use it to map the file. Access the file contents as a memory array. The memory accesses are translated into direct calls to the device driver, as follows:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>An attempt to access a mapped page, when the page is not resident in memory, is translated into a call on the read entry point of the device driver to read that page of data.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>When the kernel needs to reclaim a page of physical memory occupied by a page of a mapped file, and the page has been modified, the kernel calls the write entry point of the device driver to write the page. It also writes any modified pages when the file mapping is changed by <INDEXTARGET ID="TIP_1.aspace115"><!-- POSTPROCESSDATA: TIP_1.aspace115|<FUNCTION>msync()</FUNCTION> --><FUNCTION>munmap()</FUNCTION> or another <FUNCTION>mmap()</FUNCTION> call, when the program applies <FUNCTION>msync()</FUNCTION> to the segment, or when the program ends.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>When mapping a file for input only (when the <VARIABLE>prot</VARIABLE> argument of <FUNCTION>mmap()</FUNCTION> does not contain PROT_WRITE), you can use either MAP_SHARED or MAP_PRIVATE. When writing is allowed, you must use MAP_SHARED, or changes will not be reflected in the file.</PARAGRAPH>
<TIP><PREFIX>Tip</PREFIX>Memory mapping provides an excellent way to read a file containing precalculated, constant data used by an interactive program. Time-consuming calculation of the data elements can be done offline by another program; the other program also maps the file in order to fill it with data.</TIP>
<PARAGRAPH>You can lock a mapped file into memory. This is discussed further under <XREF IDREF="25692" TYPE="TITLE">&ldquo;Locking and Unlocking Pages in Memory&rdquo;</XREF>.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Mapped File Sizes</TITLE><PARAGRAPH>Because the potential 32-bit address space is more than 2000 megabytes (and the 64-bit address space vastly greater), you can in theory map very large files into memory. However, many segments of the virtual address space are preassigned to DSOs (see <XREF IDREF="16308" TYPE="TITLE">&ldquo;Address Space Boundaries&rdquo;</XREF> and the file <FILENAME>/usr/lib/so_locations</FILENAME>), and this restricts the available size of maps in 32-bit space. To map an entire file, follow these steps:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Open the file to get a file descriptor.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Use <INDEXTARGET ID="TIP_1.aspace116"><!-- POSTPROCESSDATA: TIP_1.aspace116|<FUNCTION>lseek()</FUNCTION>:for file size --><FUNCTION>lseek</FUNCTION>(<VARIABLE>fd</VARIABLE>,0,SEEK_END) to discover the size of the file (see the <REFPAGE>lseek(2)</REFPAGE> reference page).</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Map the file with an <VARIABLE>off</VARIABLE> of 0 and <VARIABLE>len</VARIABLE> of the file size.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Apparent Process Size</TITLE><PARAGRAPH>When you map a large file into memory, the space is counted as part of the virtual size of the process. This can lead to very large apparent sizes. For example, under IRIX&nbsp;5.3 and&nbsp;6.2, the Object Server maps a large database into memory, with the result that a typical result of <INDEXTARGET ID="TIP_1.aspace117"><!-- POSTPROCESSDATA: TIP_1.aspace117|address space:virtual size of --><COMMAND>ps&nbsp;-l</COMMAND> looks like this:</PARAGRAPH>
<EXAMPLE>
70 S 0 566 1 0 26 20 * 33481:225 80272230 ? 0:45 objectser
</EXAMPLE>
<PARAGRAPH>The total virtual size of 33481 certainly gets your attention! However, note the more modest real storage size of 225. Most of the mapped pages are not in physical memory. Also realize that the backing store for pages of a mapped file is the file itself&mdash;no swap space is used.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="67229">Mapping Portions of a File</TITLE><PARAGRAPH>You do not have to map the entire file; you can map any portion of it, from one page to the file size. Simply specify the desired length as <INDEXTARGET ID="TIP_1.aspace118"><!-- POSTPROCESSDATA: TIP_1.aspace118|<FUNCTION>mmap()</FUNCTION>:in place of <FUNCTION>lseek()</FUNCTION> --><VARIABLE>len</VARIABLE> and the starting offset as <VARIABLE>off</VARIABLE>.</PARAGRAPH>
<PARAGRAPH>You can remap a file to a different segment by calling <FUNCTION>mmap()</FUNCTION> again. In this way you can use the <VARIABLE>off</VARIABLE> parameter of <FUNCTION>mmap()</FUNCTION> as the logical equivalent of <FUNCTION>lseek()</FUNCTION>. That is, to map a different segment of the file, specify</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>the same file descriptor</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the new offset in <VARIABLE>off</VARIABLE>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the current segment base address as <VARIABLE>addr</VARIABLE>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>MAP_FIXED in <INDEXTARGET ID="TIP_1.aspace119"><!-- POSTPROCESSDATA: TIP_1.aspace119|MAP_FIXED flag --><VARIABLE>flags</VARIABLE> to force the use of <VARIABLE>addr</VARIABLE> as the base address (otherwise the new portion of the file maps to a different, additional memory segment)</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The old segment is replaced with a new segment at the same address, now containing data from a different offset in the file.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>Each time you replace a segment with <INDEXTARGET ID="TIP_1.aspace120"><!-- POSTPROCESSDATA: TIP_1.aspace120|memory mapping:replacing a mapped segment --><FUNCTION>mmap()</FUNCTION>, the previous segment is discarded. The new segment is not locked in memory, even if the old segment was locked.</NOTE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>File Permissions</TITLE><PARAGRAPH>Access to a file for mapping is controlled by the same file permissions that control I/O to the file. The protection in <INDEXTARGET ID="TIP_1.aspace121"><!-- POSTPROCESSDATA: TIP_1.aspace121|memory mapping:and file access permissions --><INDEXTARGET ID="TIP_1.aspace122"><!-- POSTPROCESSDATA: TIP_1.aspace122|<FUNCTION>mmap()</FUNCTION>:and file permissions --><INDEXTARGET ID="TIP_1.aspace123"><!-- POSTPROCESSDATA: TIP_1.aspace123|file access permissions and <FUNCTION>mmap()</FUNCTION> --><VARIABLE>prot</VARIABLE> must agree with the file permissions. For example, if the file is read-only to the process, <FUNCTION>mmap()</FUNCTION> does not allow <VARIABLE>prot</VARIABLE> to specify write or execute access.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>When a program runs with superuser privilege for other reasons, file permissions are not a protection against accidental updates.</NOTE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>NFS Considerations</TITLE><PARAGRAPH>The file that is mapped can be local to the machine, or can be mounted by NFS. In either case, be aware that changes to the file are buffered and are not immediately reflected on disk. Use <INDEXTARGET ID="TIP_1.aspace124"><!-- POSTPROCESSDATA: TIP_1.aspace124|memory mapping:of NFS-mounted file<FUNCTION>msync()</FUNCTION> --><INDEXTARGET ID="TIP_1.aspace125"><!-- POSTPROCESSDATA: TIP_1.aspace125|<FUNCTION>mmap()</FUNCTION>:and NFS-mounted files --><INDEXTARGET ID="TIP_1.aspace126"><!-- POSTPROCESSDATA: TIP_1.aspace126|NFS and memory-mapped files --><FUNCTION>msync()</FUNCTION> to force modified pages of a segment to be written to disk (see <XREF IDREF="46112" TYPE="TITLE">&ldquo;Synchronizing the Backing Store&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>If IRIX needs to read a page of a mapped, NFS mounted file, and an NFS error occurs (for example, because the file server has gone down), the error is reflected to your program as a SIGBUS exception.<INDEXTARGET ID="TIP_1.aspace127"><!-- POSTPROCESSDATA: TIP_1.aspace127|SIGBUS:on NFS error in mapped file --><INDEXTARGET ID="TIP_1.aspace128"><!-- POSTPROCESSDATA: TIP_1.aspace128|signal:SIGBUS --></PARAGRAPH>
<CAUTION><PREFIX>Caution</PREFIX>When two or more processes in the <ITALICS>same</ITALICS> system map an NFS-mounted file, their image of the file will be consistent. But when two or more processes in <ITALICS>different</ITALICS> systems map the same NFS-mounted file, there is no way to coordinate their updates, and the file can be corrupted.</CAUTION>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>File Integrity</TITLE><PARAGRAPH>Any change to a file is immediately visible in the mapped segment. This is always true when <INDEXTARGET ID="TIP_1.aspace129"><!-- POSTPROCESSDATA: TIP_1.aspace129|MAP_PRIVATE flag --><INDEXTARGET ID="TIP_1.aspace130"><!-- POSTPROCESSDATA: TIP_1.aspace130|MAP_SHARED flag --><INDEXTARGET ID="TIP_1.aspace131"><!-- POSTPROCESSDATA: TIP_1.aspace131|memory mapping:conflicts with normal file access --><INDEXTARGET ID="TIP_1.aspace132"><!-- POSTPROCESSDATA: TIP_1.aspace132|<FUNCTION>ftruncate()</FUNCTION> on memory-mapped file --><VARIABLE>flags</VARIABLE> contains MAP_SHARED, and initially true when <VARIABLE>flags</VARIABLE> contains MAP_PRIVATE. A change to the file can be made by another process that has mapped the same file.</PARAGRAPH>
<PARAGRAPH>A mapped file can also be changed by a process that opens the file for output and then applies either <FUNCTION>write()</FUNCTION> to update the file or <FUNCTION>ftruncate()</FUNCTION> to shorten it (see the <REFPAGE>write(2)</REFPAGE> and <REFPAGE>ftruncate(3)</REFPAGE> reference pages). In particular, if any process truncates a mapped file, an attempt to access a mapped memory page that corresponds to a now-deleted portion of the file causes a bus error signal (SIGBUS) to be sent.<INDEXTARGET ID="TIP_1.aspace133"><!-- POSTPROCESSDATA: TIP_1.aspace133|signal:SIGBUS --><INDEXTARGET ID="TIP_1.aspace134"><!-- POSTPROCESSDATA: TIP_1.aspace134|SIGBUS:on access to truncated mapped file --></PARAGRAPH>
<PARAGRAPH>When MAP_PRIVATE is specified, a private copy of a page of memory is created whenever the process stores into the page (copy-on-write). This prevents the change from being seen by any other process that uses or maps the same file, and it protects the process from detecting any change made to that page by another process. However, this applies only to pages that have been written into.<INDEXTARGET ID="TIP_1.aspace135"><!-- POSTPROCESSDATA: TIP_1.aspace135|memory mapping:private copy of file --></PARAGRAPH>
<PARAGRAPH>Frequently you cannot use MAP_PRIVATE because it is important to see data changes and to share them with other processes that map the same file. However, it is also important to prevent an unrelated process from truncating the file and so causing SIGBUS exceptions.</PARAGRAPH>
<PARAGRAPH>The one sure way to block changes to the file is to install a mandatory file lock. You place a file lock with the <FUNCTION>lockf()</FUNCTION> function (see <XREF IDREF="33600" TYPE="TITLE">Chapter&nbsp;7, &ldquo;File and Record Locking&rdquo;</XREF>). However, a file lock is normally &ldquo;advisory&rdquo;; that is, it is effective only when every process that uses the file also calls <FUNCTION>lockf()</FUNCTION> before changing it.</PARAGRAPH>
<PARAGRAPH>You create a mandatory file lock by changing the protection mode of the file, using the <INDEXTARGET ID="TIP_1.aspace136"><!-- POSTPROCESSDATA: TIP_1.aspace136|<ITALICS>chmod</ITALICS> command --><INDEXTARGET ID="TIP_1.aspace137"><!-- POSTPROCESSDATA: TIP_1.aspace137|<FUNCTION>lockf()</FUNCTION>:to protect mapped file --><INDEXTARGET ID="TIP_1.aspace138"><!-- POSTPROCESSDATA: TIP_1.aspace138|memory mapping:mandatory file locks with --><FUNCTION>chmod()</FUNCTION> function to set the mandatory file lock protection bit (see the <REFPAGE>chmod(2)</REFPAGE> reference page). When this is done, a lock placed with <FUNCTION>lockf()</FUNCTION> is recognized and enforced by <FUNCTION>open()</FUNCTION>. </PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="51714">Mapping a File for Shared Memory</TITLE><PARAGRAPH>You can use <INDEXTARGET ID="TIP_1.aspace139"><!-- POSTPROCESSDATA: TIP_1.aspace139|<FUNCTION>mmap()</FUNCTION>:parameters of --><INDEXTARGET ID="TIP_1.aspace140"><!-- POSTPROCESSDATA: TIP_1.aspace140|shared memory segment --><INDEXTARGET ID="TIP_1.aspace141"><!-- POSTPROCESSDATA: TIP_1.aspace141|memory mapping:to create shared segments --><FUNCTION>mmap()</FUNCTION> simply to create a segment of memory that can be shared among unrelated processes.</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>In one process, create a file or a POSIX shared memory object to represent the segment.</PARAGRAPH>
<PARAGRAPH>Typically a file is located in <FILENAME>/var/tmp</FILENAME>, but it can be anywhere. The permissions on the file or POSIX object determine the access permitted to other processes.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Map the file or POSIX object into memory with <FUNCTION>mmap()</FUNCTION>; initialize the segment contents by writing into it.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>In another process, get a file descriptor using <FUNCTION>open()</FUNCTION> or the POSIX function <FUNCTION>shm_open()</FUNCTION>, specifying the same pathname.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>In that other process, use <FUNCTION>mmap()</FUNCTION> specifying the file descriptor of the file.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>After this procedure, both processes are using the identical segment of memory pages. Data stored by one is immediately visible to the other.</PARAGRAPH>
<PARAGRAPH>This is the most basic method of sharing a memory segment. More elaborate methods with additional services are discussed in <XREF IDREF="28345" TYPE="TITLE">Chapter&nbsp;3, &ldquo;Sharing Memory Between Processes.&rdquo;</XREF></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="67507">Mapping a Segment of Zeros</TITLE><PARAGRAPH>You can use <INDEXTARGET ID="TIP_1.aspace142"><!-- POSTPROCESSDATA: TIP_1.aspace142|<ITALICS>/dev/zero</ITALICS>:and <FUNCTION>mmap()</FUNCTION> --><INDEXTARGET ID="TIP_1.aspace143"><!-- POSTPROCESSDATA: TIP_1.aspace143|<FUNCTION>open()</FUNCTION>:of <ITALICS>/dev/zero</ITALICS> --><INDEXTARGET ID="TIP_1.aspace144"><!-- POSTPROCESSDATA: TIP_1.aspace144|<FUNCTION>mmap()</FUNCTION>:of zero segment --><INDEXTARGET ID="TIP_1.aspace145"><!-- POSTPROCESSDATA: TIP_1.aspace145|memory mapping:of segment of zeros --><FUNCTION>mmap()</FUNCTION> to create a segment of zero-filled memory. Create a file descriptor by applying <FUNCTION>open()</FUNCTION> to the special device file <FILENAME>/dev/zero</FILENAME>. Map this descriptor with <VARIABLE>addr</VARIABLE> of 0, <VARIABLE>off</VARIABLE> of 0, and <VARIABLE>len</VARIABLE> set to the segment size you want. </PARAGRAPH>
<PARAGRAPH>A segment created this way cannot be shared between unrelated processes. However, it can be shared among any processes that share access to the original file descriptor&mdash;that is, processes created with <FUNCTION>sproc()</FUNCTION> using the PR_SFDS flag (see the <REFPAGE>sproc(2)</REFPAGE> reference page). For more information about <FILENAME>/dev/zero</FILENAME>, see the <REFPAGE>zero(7)</REFPAGE> reference page.</PARAGRAPH>
<PARAGRAPH>The difference between using <INDEXTARGET ID="TIP_1.aspace146"><!-- POSTPROCESSDATA: TIP_1.aspace146|MAP_AUTOGROW flag --><FUNCTION>mmap()</FUNCTION> of <FILENAME>/dev/zero</FILENAME> and <FUNCTION>calloc()</FUNCTION> is that <FUNCTION>calloc()</FUNCTION> defines all pages of the segment immediately. When you specify MAP_AUTOGROW, <FUNCTION>mmap()</FUNCTION> does not actually define a page of the segment until the page is accessed. You can create a very large segment and yet consume swap space in proportion to the pages actually used.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>This feature is unique to IRIX. The file <FILENAME>/dev/zero</FILENAME> may not exist in other versions of UNIX. Since the feature is nonportable, you should not use the POSIX function <FUNCTION>shm_open()</FUNCTION> with <FILENAME>/dev/zero</FILENAME> (or any device special file).</NOTE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="50575">Mapping Physical Memory</TITLE><PARAGRAPH>You can use <INDEXTARGET ID="TIP_1.aspace147"><!-- POSTPROCESSDATA: TIP_1.aspace147|<ITALICS>/dev/mem</ITALICS> --><INDEXTARGET ID="TIP_1.aspace148"><!-- POSTPROCESSDATA: TIP_1.aspace148|<FUNCTION>mmap()</FUNCTION>:of <ITALICS>/dev/mem</ITALICS> --><INDEXTARGET ID="TIP_1.aspace149"><!-- POSTPROCESSDATA: TIP_1.aspace149|memory mapping:of physical memory --><FUNCTION>mmap()</FUNCTION> to create a segment that is a window on physical memory. To do so you create a file descriptor by opening the special file <FILENAME>/dev/mem</FILENAME>. For more information, see the<REFPAGE>&space;mem(7)</REFPAGE> reference page.</PARAGRAPH>
<PARAGRAPH>Obviously the use of such a segment is nonportable, hardware-dependent, and dependent on the OS release.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Mapping Kernel Virtual Memory</TITLE><PARAGRAPH>You can use <INDEXTARGET ID="TIP_1.aspace150"><!-- POSTPROCESSDATA: TIP_1.aspace150|<ITALICS>/dev/mmem</ITALICS> --><INDEXTARGET ID="TIP_1.aspace151"><!-- POSTPROCESSDATA: TIP_1.aspace151|<FUNCTION>mmap()</FUNCTION>:of <ITALICS>/dev/mmem</ITALICS> --><INDEXTARGET ID="TIP_1.aspace152"><!-- POSTPROCESSDATA: TIP_1.aspace152|memory mapping:of kernel memory --><FUNCTION>mmap()</FUNCTION> to create a segment that is a window on the kernel's virtual address space. To do so you create a file descriptor by opening the special file <FILENAME>/dev/mmem</FILENAME> (note the double &ldquo;m&rdquo;). For more information, see the <REFPAGE>mem(7)</REFPAGE> (single &ldquo;m&rdquo;) reference page.</PARAGRAPH>
<PARAGRAPH>The acceptable <VARIABLE>off</VARIABLE> and <VARIABLE>len</VARIABLE> values you can use when mapping <FILENAME>/dev/mmem</FILENAME> are defined by the contents of <FILENAME>/var/sysgen/master.d/mem</FILENAME>. Normally this file restricts possible mappings to specific hardware registers such as the high-precision clock. For an example of mapping <FILENAME>/dev/mmem</FILENAME>, see the example code in the <REFPAGE>syssgi(2)</REFPAGE> reference page under the SGI_QUERY_CYCLECNTR argument.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="86957">Mapping a VME Device</TITLE><PARAGRAPH>You can use <INDEXTARGET ID="TIP_1.aspace153"><!-- POSTPROCESSDATA: TIP_1.aspace153|<ITALICS>/dev/vme</ITALICS> --><INDEXTARGET ID="TIP_1.aspace154"><!-- POSTPROCESSDATA: TIP_1.aspace154|<FUNCTION>mmap()</FUNCTION>:of <ITALICS>/dev/vme/*</ITALICS> --><INDEXTARGET ID="TIP_1.aspace155"><!-- POSTPROCESSDATA: TIP_1.aspace155|VME PIO --><INDEXTARGET ID="TIP_1.aspace156"><!-- POSTPROCESSDATA: TIP_1.aspace156|memory mapping:of VME device --><FUNCTION>mmap()</FUNCTION> to create a segment that is a window on the bus address space of a particular VME bus adapter. This allows you to do programmed I/O (PIO) to VME devices.</PARAGRAPH>
<PARAGRAPH>To do PIO, you create a file descriptor by opening one of the special devices in <FILENAME>/dev/vme</FILENAME>. These files correspond to VME devices. For details on the naming of these files, see the <REFPAGE>usrvme(7)</REFPAGE> reference page.</PARAGRAPH>
<PARAGRAPH>The name of the device that you open and pass as the file descriptor determines the bus address space (A16, A24, or A32). The values you specify in <VARIABLE>off</VARIABLE> and <VARIABLE>len</VARIABLE> must agree with accessible locations in that VME bus space. A read or write to a location in the mapped segment causes a call to the read or write entry of the kernel device driver for VME PIO. An attempt to read or write an invalid location in the bus address space causes a SIGBUS exception to all processes that have mapped the device.<INDEXTARGET ID="TIP_1.aspace157"><!-- POSTPROCESSDATA: TIP_1.aspace157|SIGBUS:on PIO access to invalid bus address --></PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>On the CHALLENGE and Onyx hardware, PIO reads and writes are asynchronous. Following an invalid read or write, as much as 10 milliseconds can elapse before the SIGBUS signal is raised. <INDEXTARGET ID="TIP_1.aspace158"><!-- POSTPROCESSDATA: TIP_1.aspace158|Challenge/Onyx architecture:PIO error latency --><INDEXTARGET ID="TIP_1.aspace159"><!-- POSTPROCESSDATA: TIP_1.aspace159|signal:SIGBUS --><INDEXTARGET ID="TIP_1.aspace160"><!-- POSTPROCESSDATA: TIP_1.aspace160|SIGBUS:on PIO access to invalid bus address --></NOTE>
<PARAGRAPH>For a detailed discussion of VME PIO, see the <DOCTITLE>IRIX Device Driver Programmer's Guide</DOCTITLE>.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>Mapping of devices through <FUNCTION>mmap()</FUNCTION> is an IRIX feature that is not defined by POSIX standard. Do not use the POSIX <FUNCTION>shm_open()</FUNCTION> function with device special files.</NOTE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="27102">Choosing a Segment Address</TITLE><PARAGRAPH>Normally there is no need to map a segment to any particular virtual address. You specify <INDEXTARGET ID="TIP_1.aspace161"><!-- POSTPROCESSDATA: TIP_1.aspace161|segment address --><INDEXTARGET ID="TIP_1.aspace162"><!-- POSTPROCESSDATA: TIP_1.aspace162|memory mapping:choosing segment address for --><VARIABLE>addr</VARIABLE> as 0 and IRIX picks an unused virtual address. This is the usual method and the recommended one.</PARAGRAPH>
<PARAGRAPH>You can specify a nonzero value in <INDEXTARGET ID="TIP_1.aspace163"><!-- POSTPROCESSDATA: TIP_1.aspace163|MAP_FIXED flag --><VARIABLE>addr</VARIABLE> to request a particular base address for the new segment. You specify MAP_FIXED in <VARIABLE>flags</VARIABLE> to say that <VARIABLE>addr</VARIABLE> is an absolute requirement, and that the segment must begin at <VARIABLE>addr</VARIABLE> or not be created. If you omit MAP_FIXED, <FUNCTION>mmap()</FUNCTION> takes a nonzero <VARIABLE>addr</VARIABLE> as a suggestion only.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Segments at Fixed Offsets</TITLE><PARAGRAPH>In rare cases you may need to create two or more mapped segments with a fixed relationship between their base addresses. This would be the case when there are offset values in one segment that refer to the other segment, as diagrammed in <INDEXTARGET ID="TIP_1.aspace164"><!-- POSTPROCESSDATA: TIP_1.aspace164|segments at fixed offsets --><XREF IDREF="50936" TYPE="GRAPHIC">Figure&nbsp;1-1</XREF>.</PARAGRAPH>
<PARAGRAPH><FIGURE><GRAPHIC FILE="segoffs.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="1-1"><PREFIX>Figure 1-1 </PREFIX><XREFTARGET ID="50936">Segments With a Fixed Offset Relationship</CAPTION>
</FIGURE>
</PARAGRAPH>
<PARAGRAPH>In <XREF IDREF="50936" TYPE="GRAPHIC">Figure&nbsp;1-1</XREF>, a word in one segment contains an offset value <VARIABLE>A</VARIABLE> giving the distance in bytes to an object in a different mapped segment. Offset <VARIABLE>A</VARIABLE> is accurate only when the two segments are separated by a known distance, offset <VARIABLE>S</VARIABLE>.</PARAGRAPH>
<PARAGRAPH>You can create segments in such a relationship using the following procedure.</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Map a single segment large enough to encompass the lengths of all segments that need fixed offsets. Use 0 for <VARIABLE>addr</VARIABLE>, allowing IRIX to pick the base address. Let this base address be <VARIABLE>B</VARIABLE>.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Map the smaller segments over the larger one. For the first (the one at the lowest relative position), specify <INDEXTARGET ID="TIP_1.aspace165"><!-- POSTPROCESSDATA: TIP_1.aspace165|MAP_FIXED flag --><VARIABLE>B</VARIABLE> for <VARIABLE>addr</VARIABLE> and MAP_FIXED in <VARIABLE>flags</VARIABLE>.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>For the remaining segments, specify <VARIABLE>B</VARIABLE>+<VARIABLE>S</VARIABLE> for <VARIABLE>addr</VARIABLE> and MAP_FIXED in <VARIABLE>flags</VARIABLE>.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>The initial, large segment establishes a known base address and reserves enough address space to hold the other segments. The later mappings replace the first one, which cannot be used for its own sake.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Segments at a Fixed Address</TITLE><PARAGRAPH>You can specify any value for <INDEXTARGET ID="TIP_1.aspace166"><!-- POSTPROCESSDATA: TIP_1.aspace166|<FUNCTION>mmap()</FUNCTION>:using specified addresses --><INDEXTARGET ID="TIP_1.aspace167"><!-- POSTPROCESSDATA: TIP_1.aspace167|memory mapping:at fixed addresses --><VARIABLE>addr</VARIABLE>. IRIX creates the mapping if there is no conflict with an existing segment, or returns an error if the mapping is impossible. However, you cannot normally tell what virtual addresses will be available for mapping in any particular installation or version of the operating system.</PARAGRAPH>
<PARAGRAPH>There are three exceptions. First, after IRIX has chosen an address for you, you can always map a new segment of the same or shorter length at the same address. This allows you to map different parts of a file into the same segment at different times (see <XREF IDREF="67229" TYPE="TITLE">&ldquo;Mapping Portions of a File&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>Second, the low 4&nbsp;MB of the address space are unused (see <INDEXTARGET ID="TIP_1.aspace168"><!-- POSTPROCESSDATA: TIP_1.aspace168|address space:low 4 MB reserved --><XREF IDREF="16308" TYPE="TITLE">&ldquo;Address Space Boundaries&rdquo;</XREF>). It is a very bad idea to map anything into the 0 page because that makes it hard to trap the use of uninitialized pointers. But you can use other parts of the initial 4&nbsp;MB for mapping.</PARAGRAPH>
<PARAGRAPH>Third, the MIPS Application Binary Interface (ABI) specification (an extension of the System V ABI published by AT&amp;T) states that addresses from 0x3000&nbsp;0000 through 0x3ffc&nbsp;0000 are reserved for user-defined segment base addresses.<INDEXTARGET ID="TIP_1.aspace169"><!-- POSTPROCESSDATA: TIP_1.aspace169|MIPS ABI:reserved address space --><INDEXTARGET ID="TIP_1.aspace170"><!-- POSTPROCESSDATA: TIP_1.aspace170|address space:segment reserved for user mapping --></PARAGRAPH>
<PARAGRAPH>You may specify values in this range as <INDEXTARGET ID="TIP_1.aspace171"><!-- POSTPROCESSDATA: TIP_1.aspace171|MAP_FIXED flag --><VARIABLE>addr</VARIABLE> with MAP_FIXED in <VARIABLE>flags</VARIABLE>. When you map two or more segments into this region, no two segments can occupy the same 256-KB unit. This rule ensures that segments always start in different pages, even when the maximum possible page size is in use. For example, if you want to create two segments each of 4096 bytes, you can place one at 0x30000000 through 0x3000&nbsp;0fff and the other at 0x3004&nbsp;0000 through 0x3004&nbsp;0fff. (256&nbsp;KB is 0x0004&nbsp;0000.)</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>If two programs in the same system attempt to map different objects to the same absolute address, the second attempt fails.&space;</NOTE>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="25692">Locking and Unlocking Pages in Memory</TITLE><PARAGRAPH>A page fault interrupts a process for many milliseconds. Not only are page faults lengthy, their occurrence and frequency are unpredictable. A real-time application cannot tolerate such interruptions. The solution is to lock some or all of the pages of the address space into memory. A page fault cannot occur on a locked page.<INDEXTARGET ID="TIP_1.aspace172"><!-- POSTPROCESSDATA: TIP_1.aspace172|page fault:prevent by locking memory --><INDEXTARGET ID="TIP_1.aspace173"><!-- POSTPROCESSDATA: TIP_1.aspace173|page:locking --><INDEXTARGET ID="TIP_1.aspace174"><!-- POSTPROCESSDATA: TIP_1.aspace174|memory:locking pages in --></PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Memory Locking Functions</TITLE><PARAGRAPH>You can use any of the functions summarized in <XREF IDREF="18228" TYPE="TABLE">Table&nbsp;1-2</XREF> to lock memory. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="1-2"><PREFIX>Table 1-2 </PREFIX><XREFTARGET ID="18228"> <EMPHASIS>(continued)        </EMPHASIS>Functions for Locking Memory</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>Compatibility</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Purpose and Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>mlock(3C)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>POSIX</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Lock a specified range of addresses.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>mlockall(3C)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>POSIX</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Lock the entire address space of the calling process.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>mpin(3C)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>IRIX</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Lock a specified range of addresses.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>plock(3C)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>SVR4</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Lock all program text, or all data, or the entire address space.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Locking memory causes all pages of the specified segments to be defined before they are locked. When virtual swap is in use, it is possible to receive a SIGKILL exception while locking because there was not enough swap space to define all pages (see <XREF IDREF="61327" TYPE="TITLE">&ldquo;Delayed and Immediate Space Definition&rdquo;</XREF>). <INDEXTARGET ID="TIP_1.aspace175"><!-- POSTPROCESSDATA: TIP_1.aspace175|signal:SIGKILL --><INDEXTARGET ID="TIP_1.aspace176"><!-- POSTPROCESSDATA: TIP_1.aspace176|SIGKILL:possible when locking pages --></PARAGRAPH>
<PARAGRAPH>Locking pages in memory of course reduces the memory that is available for all other programs in the system. Locking a large program increases the rate of page faults for other programs.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="96827">Locking Program Text and Data</TITLE><PARAGRAPH>Using <FUNCTION>mpin()</FUNCTION> and <FUNCTION>mlock()</FUNCTION> you have to calculate the starting address and the length of the segment to be locked. It is relatively easy to calculate the starting address and length of global data or of a mapped segment, but it can be awkward to learn the starting address and length of program text or of stack space.</PARAGRAPH>
<PARAGRAPH>Using <FUNCTION>mlockall()</FUNCTION> you lock all of the program text and data as it exists at the time of the call. You specify a flag, either MCL_CURRENT or MCL_FUTURE, to give the scope in time. One possible way to lock only program text is to call <FUNCTION>mlockall()</FUNCTION> with MCL_CURRENT early in the initialization of a program. The program's text and static data are locked, but not any dynamic or mapped pages that may be created subsequently. Specific ranges of dynamic or mapped data can be locked with <FUNCTION>mlock()</FUNCTION> as they are created.</PARAGRAPH>
<PARAGRAPH>Using <FUNCTION>plock()</FUNCTION> you specify whether to lock text, data, or both. When you specify the text option, the function locks all executable text as loaded for the program, including shared objects (DSOs). (It does not lock segments created with <FUNCTION>mmap()</FUNCTION> even when you specify PROT_EXEC to <FUNCTION>mmap()</FUNCTION>. Use <FUNCTION>mlock()</FUNCTION> or <FUNCTION>mpin()</FUNCTION> to lock executable, mapped segments.)</PARAGRAPH>
<PARAGRAPH>When you specify the data option, <FUNCTION>plock()</FUNCTION> locks the default data (heap) and stack segments, and any mapped segments made with MAP_PRIVATE, as they are defined at the time of the call. If you extend these segments after locking them, the newly defined pages are also locked as they are defined.</PARAGRAPH>
<PARAGRAPH>Although new pages are locked when they are defined, you still should extend these segments to their maximum size while initializing the program. The reason is that it takes time to extend a segment: the kernel must process a page fault and create a new page frame, possibly writing other pages to backing store to make space.</PARAGRAPH>
<PARAGRAPH>One way to ensure that the full stack is created before it is locked is to call <INDEXTARGET ID="TIP_1.aspace177"><!-- POSTPROCESSDATA: TIP_1.aspace177|segment:locking --><INDEXTARGET ID="TIP_1.aspace178"><!-- POSTPROCESSDATA: TIP_1.aspace178|data segment:locking --><INDEXTARGET ID="TIP_1.aspace179"><!-- POSTPROCESSDATA: TIP_1.aspace179|stack segment:locking --><INDEXTARGET ID="TIP_1.aspace180"><!-- POSTPROCESSDATA: TIP_1.aspace180|text segment:locking --><FUNCTION>plock()</FUNCTION> from a function like the function in <XREF IDREF="87261" TYPE="TEXT">Example&nbsp;1-2</XREF>.</PARAGRAPH>
<CODE><CAPTION LBL="1-2"><PREFIX>Example 1-2 </PREFIX><XREFTARGET ID="87261">Function to Lock Maximum Stack Size</CAPTION>#define MAX_STACK_DEPTH 100000 /* your best guess */
int call_plock()
{
&nbsp;&nbsp;&nbsp;char dummy[MAX_STACK_DEPTH];
&nbsp;&nbsp;&nbsp;return plock(PROCLOCK);
}
<INDEXTARGET ID="TIP_1.aspace181"><!-- POSTPROCESSDATA: TIP_1.aspace181|<FUNCTION>plock()</FUNCTION>:example of --></CODE>
<PARAGRAPH>The large local variable forces the call stack to what you expect will be its maximum size before <FUNCTION>plock()</FUNCTION> is entered.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>plock()</FUNCTION> function does not lock mapped segments you create with MAP_SHARED. You must lock them individually using <FUNCTION>mpin()</FUNCTION>. You need to do this from only one of the processes that shares the segment.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Locking Mapped Segments</TITLE><PARAGRAPH>It may be better for your program to not lock the entire address space, but to lock only a particular mapped segment.</PARAGRAPH>
<PARAGRAPH>Immediately after calling <FUNCTION>mmap()</FUNCTION> you have the address and length of the mapped segment. This is a convenient time to call either <FUNCTION>mpin()</FUNCTION> or <FUNCTION>mlock()</FUNCTION> to lock the mapped segment.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>mmap()</FUNCTION> flags MAP_AUTOGROW and MAP_AUTORESRV are unique to IRIX and not defined by POSIX. However, the POSIX <FUNCTION>mlock()</FUNCTION> function for IRIX does recognize autogrow segments. If you lock an autogrow segment with <FUNCTION>mpin()</FUNCTION>, <FUNCTION>mlock()</FUNCTION>, or <FUNCTION>mlockall()</FUNCTION> with the MCL_FUTURE flag, additional pages are locked as they are added to the segment. If you lock the segment with <FUNCTION>mlockall()</FUNCTION> with the MCL_CURRENT flag, the segment is locked for its current size only and added pages are not locked.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="55556">Locking Mapped Files</TITLE><PARAGRAPH>If you map a file before you use <INDEXTARGET ID="TIP_1.aspace182"><!-- POSTPROCESSDATA: TIP_1.aspace182|memory mapping:locking mapped file --><INDEXTARGET ID="TIP_1.aspace183"><!-- POSTPROCESSDATA: TIP_1.aspace183|file, mapping into memory --><FUNCTION>mlockall(</FUNCTION>MCL_CURRENT<FUNCTION>)</FUNCTION> or <FUNCTION>plock()</FUNCTION> to lock the data segment into memory (see <XREF IDREF="87009" TYPE="TITLE">&ldquo;Mapping a File for I/O&rdquo;</XREF>), the mapped file is read into the locked pages during the lock operation. If you lock the program with <FUNCTION>mlockall(</FUNCTION>MCL_FUTURE<FUNCTION>)</FUNCTION> and then map a file into memory, the mapped file is read into memory and the pages locked.</PARAGRAPH>
<PARAGRAPH>If you map a file after locking the data segment with <FUNCTION>plock()</FUNCTION> or <FUNCTION>mlockall(</FUNCTION>MCL_CURRENT<FUNCTION>)</FUNCTION>, the new mapped segment is not locked. Pages of file data are read on demand, as the program accesses them.</PARAGRAPH>
<PARAGRAPH>From these facts you can conclude the following:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>You should map small files before locking memory, thus getting fast access to their contents without paging delays.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Conversely, if you map a file after locking memory, your program could be delayed for input on any access to the mapped segment.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>However, if you map a large file and then try to lock memory, the attempt to lock could fail because there is not enough physical memory to hold the entire address space including the mapped file.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>One alternative is to map an entire file, perhaps hundreds of megabytes, into the address space, but to lock only the portion or portions that are of interest at any moment. For example, a visual simulator could lock the parts of a scenery file that the simulated vehicle is approaching. When the vehicle moves away from a segment of scenery, the simulator could unlock those parts of the file, and possibly use <FUNCTION>madvise()</FUNCTION> to release them (see <XREF IDREF="88177" TYPE="TITLE">&ldquo;Releasing Unneeded Pages&rdquo;</XREF>).</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Unlocking Memory</TITLE><PARAGRAPH>The function summarized in <XREF IDREF="44306" TYPE="TABLE">Table&nbsp;1-3</XREF> are used to unlock memory. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="1-3"><PREFIX>Table 1-3 </PREFIX><XREFTARGET ID="44306"> <EMPHASIS>(continued)        </EMPHASIS>Functions for Unlocking Memory</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>Compatibility</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Purpose and Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>munlock(3C)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>POSIX</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Unlock a specified range of locked addresses.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>mlockall(3C)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>POSIX</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Unlock the entire address space of the calling process.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>munpin(3C)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>IRIX</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Unlock a specified range of addresses.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>punlock()</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="63"><PARAGRAPH>SVR4</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="252"><PARAGRAPH>Unlock addresses locked by <FUNCTION>plock()</FUNCTION>.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>You should avoid mixing function families; for example, if you lock memory with the POSIX function <FUNCTION>mlock()</FUNCTION>, do not unlock the memory using <FUNCTION>munpin()</FUNCTION>.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>mpin()</FUNCTION> function maintains a counter for each locked page showing how many times it has been locked. You must call <FUNCTION>munpin()</FUNCTION> the same number of times before the page is unlocked. This feature is not available through the POSIX and SVR4 interfaces.</PARAGRAPH>
<PARAGRAPH>Locked pages of an address space are unlocked when the last process using the address space terminates. Locked pages of a mapped segment are unlocked when the last process that mapped the segment unmaps it or terminates.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="48924">Additional Memory Features</TITLE><PARAGRAPH>Your program can work with the IRIX memory manager to change the handling of the address space.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="90829">Changing Memory Protection</TITLE><PARAGRAPH>You can change the memory protection of specified pages using <INDEXTARGET ID="TIP_1.aspace184"><!-- POSTPROCESSDATA: TIP_1.aspace184|address space:protection --><INDEXTARGET ID="TIP_1.aspace185"><!-- POSTPROCESSDATA: TIP_1.aspace185|memory:protection --><FUNCTION>mprotect()</FUNCTION> (see the <REFPAGE>mprotect(2)</REFPAGE> reference page). For a segment that contains a whole number of pages, you can specify protection of these types: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Read-only</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>By making pages read-only, you cause a SIGSEGV signal to be generated 
in any process that tries to modify them. You could do this as a 
debugging measure, to trap an intermittent program error. <INDEXTARGET ID="TIP_1.aspace186"><!-- POSTPROCESSDATA: TIP_1.aspace186|signal:SIGSEGV --><INDEXTARGET ID="TIP_1.aspace187"><!-- POSTPROCESSDATA: TIP_1.aspace187|SIGSEGV:on access to read-only page --></PARAGRAPH>
<PARAGRAPH>You can change read-only pages back to read-write. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Read-write</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>You can put read-write protection on pages of program text, but this is 
bad idea except in unusual cases. For example, a debugging tool makes 
text pages read-write in order to set breakpoints.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Executable</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>Normal data pages cannot be executed. This is a protection against 
program errors&mdash;wild branches into data are trapped quickly. If your 
program constructs executable code, or reads it from a file, the protection 
must be changed to executable before the code can be executed.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>No access</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="324"><PARAGRAPH>You can make pages inaccessible while retaining them as part of the 
address space.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<NOTE><PREFIX>Note</PREFIX>The <FUNCTION>mprotect()</FUNCTION> function changes the access rights only to the memory image of a mapped file. You can apply it to the pages of a mapped file in order to control access to the file image in memory. However, <FUNCTION>mprotect()</FUNCTION> does not affect the access rights to the file itself, nor does it prevent other processes from opening and using the file as a file.</NOTE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="46112">Synchronizing the Backing Store</TITLE><PARAGRAPH>IRIX writes modified pages to the backing store as infrequently as possible, in order to save time. When pages are locked, they are never written to backing store. This does not matter when the pages are ordinary data.<INDEXTARGET ID="TIP_1.aspace188"><!-- POSTPROCESSDATA: TIP_1.aspace188|virtual memory:synchronizing backing store --><INDEXTARGET ID="TIP_1.aspace189"><!-- POSTPROCESSDATA: TIP_1.aspace189|backing store --></PARAGRAPH>
<PARAGRAPH>When the pages represent a file mapped into memory, you may want to force IRIX to write any modifications into the file. This creates a checkpoint, a known-good file state from which the program could resume.</PARAGRAPH>
<PARAGRAPH>The <INDEXTARGET ID="TIP_1.aspace190"><!-- POSTPROCESSDATA: TIP_1.aspace190|<FUNCTION>msync()</FUNCTION> --><FUNCTION>msync()</FUNCTION> function (see the <REFPAGE>msync(2)</REFPAGE> reference page) asks IRIX to write a specified segment to backing store. The segment must be a whole multiple of pages. You can optionally request</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>synchronous writes, so the call does not return until the disk I/O is complete&mdash;ensuring that the data has been written</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>page invalidation, so that the memory pages are released and will have to be reloaded from backing store if they are referenced again</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="88177">Releasing Unneeded Pages</TITLE><PARAGRAPH>Using the <INDEXTARGET ID="TIP_1.aspace191"><!-- POSTPROCESSDATA: TIP_1.aspace191|page:releasing unneeded --><INDEXTARGET ID="TIP_1.aspace192"><!-- POSTPROCESSDATA: TIP_1.aspace192|<FUNCTION>madvise()</FUNCTION> --><FUNCTION>madvise()</FUNCTION> function (see the <REFPAGE>madvise(2)</REFPAGE> reference page), you can tell IRIX that a range of pages is not needed by your process. The pages remain defined in the address space, so this is not a means of reducing the need for swap space. However, IRIX puts the pages at the top of its list of pages to be reclaimed when another process (or the calling process) suffers a page fault.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>madvise()</FUNCTION> function is rarely needed by real-time programs, which are usually more concerned with keeping pages in memory than with letting them leave memory. However, there could be a use for it in special cases</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="88017">Using Origin2000 Nonuniform Memory</TITLE><PARAGRAPH>In the Origin2000 systems (which include the Origin200 and Onyx2 product lines) physical memory is implemented using a <ITALICS>cache-coherent nonuniform memory architecture</ITALICS>, abbreviated CC-NUMA (or sometimes simply NUMA).</PARAGRAPH>
<PARAGRAPH>For almost all programs, the CC-NUMA hardware makes no difference at all. The virtual address space as described in this chapter is implemented exactly the same in all versions of IRIX. Your program cannot tell whether the memory hardware is bus-based as in a CHALLENGE system, or uses CC-NUMA as in the Origin2000 (except that in a heavily-loaded multiprocessor, your program will run faster in an Origin than in a CHALLENGE).</PARAGRAPH>
<PARAGRAPH>However, when you implement a program that has critical performance requirements, uses multithreading, and needs a large memory space&mdash;all three conditions must be present&mdash;you may need to control the placement of virtual pages in physical memory for best performance.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>About Origin Hardware</TITLE><PARAGRAPH>You need to understand the Origin hardware at a high level in order to understand memory placement.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Basic Building Blocks</TITLE><PARAGRAPH>The basic building block of an Origin system is a <ITALICS>node</ITALICS>, a single board containing</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Two MIPS R10000 CPUs, each with a secondary cache of 1&nbsp;MB or 4&nbsp;MB.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Some amount of main memory, from 64&nbsp;MB to 4&nbsp;GB.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>One <ITALICS>hub</ITALICS> custom ASIC that manages all access to memory in the node.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Nodes are packaged into a <ITALICS>module</ITALICS>. A module contains</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>One to four node boards.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>One or two routers, high-bandwidth switches that connect nodes and modules.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><ITALICS>Crossbow</ITALICS> I/O interface chips.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The Crossbow chips are used to connect I/O devices of all sorts: SCSI, PCI, FDDI, and other types. Each Crossbow chip connects to the hub of one or two nodes, so any I/O card is closely connected to as many as two main-memory banks and as many as four CPUs.</PARAGRAPH>
<PARAGRAPH>An Origin2000 or Onyx2 system can consist of a single module, or multiple modules can be connected to make a larger system. Modules are connected by their routers. Routers in different modules are connected by special cables, the CrayLink interconnection fabric. Routers form a hypercube topology to minimize the number of hops from any node to any other.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Uniform Addressing</TITLE><PARAGRAPH>Physical memory is distributed throughout an Origin system, with some memory installed at each node. However, the system maintains a single, uniform, physical address space. Each CPU translates memory addresses from virtual to physical, and presents the physical address to its hub. A few high-order bits in the physical address designate the node where the physical memory is found. The hub uses these bits to direct the memory request as required: to the local memory in its own node, or through a router to another node.</PARAGRAPH>
<PARAGRAPH>All translation and routing of physical addresses is entirely transparent to software, which operates in a uniform virtual memory space.</PARAGRAPH>
<PARAGRAPH>Two aspects of memory mapping are not uniform. First, the physical memory map can contain gaps. Not all nodes have the same amount of memory installed. Indeed, there is no requirement that all nodes be present in the system, and in future releases of IRIX it will be possible to remove and replace nodes while the system remains up.</PARAGRAPH>
<PARAGRAPH>Second, the access time to memory differs, depending on the distance between the memory and the CPU that requests it:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Memory in the same node is accessed fastest.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Memory located on another node in the same module costs one or two router hops.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Memory in another module costs additional router hops.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Normally, memory location relative to a program has an insignificant effect on performance, because</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>IRIX takes is careful to locate a process in a CPU near the process's data.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Most programs are so written that 90% or more of the memory accesses are satisfied from the secondary cache, which is connected directly to the CPU.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The CrayLink interconnection fabric has an extremely high bandwidth (in excess of 600MB/sec sustained bidirectionally on every link), so each router hop adds only a small fraction of a microsecond to the access time.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Performance problems only arise when multithreaded programs defeat the caching algorithms or place high-bandwidth memory demands from multiple CPUs to a single node.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Cache Coherency</TITLE><PARAGRAPH>Each CPU in an Origin system has an independent secondary cache, organized as a set of 128-byte <ITALICS>cache lines</ITALICS>. The memory lines that were most recently used by the CPU are stored here for high-speed access.</PARAGRAPH>
<PARAGRAPH>When two or more CPUs access the same memory, each has an independent copy of that data. There can be as many copies of a data item as there are CPUs; and for some important tables in the IRIX kernel, this may often be the case.</PARAGRAPH>
<PARAGRAPH>Cache <ITALICS>coherency</ITALICS> means that the system hardware ensures that every cached copy remains a true reflection of the memory data, without software intervention.</PARAGRAPH>
<PARAGRAPH>Cache coherency requires no effort as long as all CPUs merely read the memory data. The hardware must intervene when a CPU attempts to modify memory. Then, that CPU must be given exclusive ownership of the modified cache line, and all other copies of the same data must be marked invalid, so that when the other CPUs need this data, they will fetch a fresh copy.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Cache Coherency in CHALLENGE Systems</TITLE><PARAGRAPH>The CHALLENGE and Onyx systems are designed around a central bus over which all memory requests pass. Each CPU board in a CHALLENGE system monitors the bus. When a board observes a write to memory, it checks its own cache and, if it has a copy of that same line, it invalidates the copy. This design, often called a &ldquo;snoopy cache&rdquo; because each CPU reads its neighbors' mail, works well when all memory access moves on a single bus.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Cache Coherency in Origin Systems</TITLE><PARAGRAPH>The cache coherency design of the Origin systems is fundamentally different, because in the Origin machines there is no central bus. Memory access packets can flow within a node or between any two nodes. Instead, cache coherence is implemented using what is called a <ITALICS>directory-based</ITALICS> scheme. The following is a simplified account of it.</PARAGRAPH>
<PARAGRAPH>Each 128-byte line of main memory is supplied with extra bits, one for each possible node, plus an 8-bit integer for the number of the node that owns the line exclusively. These extra bits are called directory bits. The directory bits are managed as part of memory by the hub chip in the node that contains the memory. The directory bits are not accessible to user-level software. (The kernel can read and write the directory bits using privileged instructions.)</PARAGRAPH>
<PARAGRAPH>When a CPU accesses an unmodified cache line for reading, the request is routed to the node that contains the memory. The hub chip in that node returns the memory data, and also sets the bit for the reading CPU to 1. When a CPU discards a cached line for any reason, the corresponding bit is set to 0. Thus the directory bits reflect the existence of cached copies of data. As long as all CPUs only read the data, there is no time cost for directory management.</PARAGRAPH>
<PARAGRAPH>When a CPU wants to modify a cache line, two things happen. The hub chip in the node that contains the memory sends a message to every CPU whose directory bit for that line is 1, telling the CPU to discard its copy because it is no longer valid. And the modifying CPU is noted as the exclusive owner of that line. Any further requests for that line's data are rerouted to the owning CPU, so that it can supply the latest version of the data.</PARAGRAPH>
<PARAGRAPH>Eventually the owning CPU updates memory and discards the cache line, and the directory status returns to its original condition.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>About CC-NUMA Performance Issues</TITLE><PARAGRAPH>Most programs operate with good performance when they simply treat the system as having a single large, uniform, memory. When this is not the case, IRIX contains tools you can use to exploit the hardware.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>About Default Memory Location</TITLE><PARAGRAPH>Clearly it is a performance advantage for a process to execute on a CPU that is as close as possible to the data used by the process. Default IRIX policies ensure this for most programs:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Memory is usually allocated on a &ldquo;first touch&rdquo; basis; that is, it is allocated in the node where the program that first defines that page is executing. When that is not possible, the memory is allocated as close as possible (in router hops) to the CPU that first accessed the page.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The IRIX scheduler maintains process affinity to CPUs based on both cache affinity (as in previous versions) and on memory affinity. When a process is ready to run it is dispatched to</PARAGRAPH>
<BULLETLISTIND><BULLETIND><PARAGRAPH>The CPU where it last ran, if possible</PARAGRAPH>
</BULLETIND>
<BULLETIND><PARAGRAPH>The other CPU in the same node, if possible</PARAGRAPH>
</BULLETIND>
<BULLETIND><PARAGRAPH>A CPU in a nearby node</PARAGRAPH>
</BULLETIND>
</BULLETLISTIND>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The great majority of commands and user programs have memory requirements that fit comfortably in a single node; and most execute at least as well, usually faster, than in any previous Silicon Graphics system.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>About Large Memory Use</TITLE><PARAGRAPH>Only one memory performance issue arises with a single-threaded program. When the program allocates much more virtual memory than is physically available in its node, at least some of its virtual address space is allocated in other nodes. The program pays an access time penalty on some segments of its address space. When this occurs, the penalty is usually unnoticeable as long as the program has good cache behavior.</PARAGRAPH>
<PARAGRAPH>Typically, IRIX allocates the first-requested memory in the requester's node. When the first-requested memory is also the most-used, average access time still remains low. When this is not the case, there are tools you can use to ensure that specific memory segments are located next to specific CPUs.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>About Multithreaded Memory Use</TITLE><PARAGRAPH>IRIX supports parallel processing under several different models (see <XREF IDREF="93055" TYPE="TITLE">Chapter&nbsp;10, &ldquo;Models of Parallel Computation&rdquo;</XREF>). When a program uses multiple, parallel threads of execution, additional performance issues can arise:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Cache contention can occur as multiple threads, running in different CPUs, invalidate each other's cached data.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Default allocation policies can place memory segments in different nodes from the CPUs the threads that use the data.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Default allocation to a single node, when threads are running in many nodes, can saturate the node with memory requests, slowing access.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>These issues are discussed in the following topics.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="51657">Dealing With Cache Contention</TITLE><PARAGRAPH>When one CPU updates a cache line, all other CPUs that refer to the same data must fetch a fresh copy. When a line is used often from multiple CPUs and is also updated frequently, the data is effectively not cached, but accessed at memory speeds.</PARAGRAPH>
<PARAGRAPH>In addition, when more than one CPU updates the same cache line, the CPUs are forced to execute in turn. Each waits until it can have exclusive ownership of the line. When multiple CPUs update the same line concurrently, the data is accessed at a fraction of memory speeds, and all the CPUs are forced to idle for many cycles.</PARAGRAPH>
<PARAGRAPH>An update of one 64-bit word invalidates the 15 other words in the same cache line. When the other words are not related to the new data, <ITALICS>false sharing</ITALICS> occurs; that is, variables are invalidated and have to be reloaded from memory merely by the accident of their address, with no logical need.</PARAGRAPH>
<PARAGRAPH>These cache contention issues are not new to the Origin architecture; they arise in any multiprocessor that supports cache coherency.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Detecting Cache Contention</TITLE><PARAGRAPH>The first problem with cache contention is to recognize that it is occurring. In earlier systems you diagnosed cache contention by elimination. Now you can use software tools and the hardware features of the MIPS R10000 CPU to detect it directly.</PARAGRAPH>
<PARAGRAPH>The R10000 includes hardware registers that can count a variety of discrete events during execution, at no performance cost. The R10000 can count individual clock cycles, numbers of loads, stores, and floating-point instructions executed, as well as cache invalidation events.</PARAGRAPH>
<PARAGRAPH>The IRIX kernel contains support for &ldquo;virtualizing&rdquo; the R10000 counter registers, so that each IRIX process appears to have its own set of counters (just as the kernel ensures that each process has its own unique set of other machine register contents).</PARAGRAPH>
<PARAGRAPH>Included with IRIX is the <COMMAND>perfex</COMMAND> profiling tool (see the <REFPAGE>perfex(1)</REFPAGE> reference page). It executes a specified program after setting up the kernel to count the events you specify. At the end of the test run, <COMMAND>perfex</COMMAND> displays the profile of counts. You can use <COMMAND>perfex</COMMAND> to count the number of instructions a program executes, or the number of page faults it encounters, and so on. No recompilation or relinking is required, and the program runs only fractionally slower than normal.</PARAGRAPH>
<PARAGRAPH>Using <COMMAND>perfex</COMMAND> you can discover approximately how much time a program, or a single thread of a program, loses to cache invalidations, and how many invalidations there were. This allows you to easily distinguish cache contention from other performance problems.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Correcting Cache Contention Problems</TITLE><PARAGRAPH>Cache contention is corrected by changing the layout of data in the source program. In general terms, the available strategies are these:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Minimize the number of variables that are accessed by more than one thread.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Segregate nonvolatile data items into different cache lines from volatile items.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Isolate volatile items that are not related into separate cache lines to eliminate false sharing.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>When volatile items are updated together, group them into single cache lines.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>A common design for a large program is to define a block of global status variables that is visible to all parallel threads. In the normal course of the program, every CPU caches all or most of such a common area. Read-only access does no harm, but if the items in the block are volatile, contention occurs. For example a global area might contain the anchor for a LIFO queue of some kind. Every time a thread puts or takes an item from the queue, it updates the queue anchor, and invalidates that cache line for every other thread.</PARAGRAPH>
<PARAGRAPH>It is inevitable that a queue anchor variable will be frequently invalidated. However, the time cost can be isolated to queue access by applying strategy 2: allocate the queue anchor in separate memory from the global status area. Put a nonvolatile pointer to the queue in the status area. Now the cost of fetching the queue anchor is born only by threads that access the queue.</PARAGRAPH>
<PARAGRAPH>If there are other items that are updated with the queue anchor, such as the lock that controls exclusive access to the queue (see <XREF IDREF="82386" TYPE="TITLE">Chapter&nbsp;4, &ldquo;Mutual Exclusion&rdquo;</XREF>), place those items adjacent to the queue anchor so that all are in the same cache line (strategy 4). However, if there are two queues that are updated at unrelated times, place each in its own cache line (strategy 3).</PARAGRAPH>
<PARAGRAPH>The locks, semaphores, and message queues that are used to synchronize threads (see <XREF IDREF="76877" TYPE="TITLE">&ldquo;Types of Interprocess Communication Available&rdquo;</XREF>) are global variables that must be updated by any CPU that uses them. It is best to assume that such objects are accessed at memory speeds. Two things can be done to reduce contention:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Minimize contention for locks and semaphores through algorithmic design. In particular, use more rather than fewer semaphores, and make each stand for the smallest possible resource. (Of course, this makes it more difficult to avoid deadlocks.)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Never place unrelated synchronization objects in the same cache line (strategy 3). A lock or semaphore can be in the same cache line as the data that it controls, because an update of one usually follows an update of the other (strategy 4).</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Carefully review the design of any data collection that is used by parallel code. For example, the root and the first few branches of a binary tree or B-tree are likely to be visited by every CPU that searches that tree, and therefore will be cached by every CPU. Elements at higher levels in the tree may be visited and cached by only a few CPUs.</PARAGRAPH>
<PARAGRAPH>Other classic data structures can cause cache contention (computer science textbooks on data structures are generally still written from the standpoint of a single-level mainframe memory architecture). For example, a hash table can be implemented compactly, with only a word or two in each entry. But that creates false sharing by putting several table entries (which are unrelated by definition) in the same cache line. To avoid false sharing in a hash table, make each table entry a full 128 bytes, cache-aligned. You can take advantage of the extra bytes in each entry to store a list of overflow hits&mdash;such a list can be quickly scanned because the entire cache line is fetched as one memory access.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Getting Optimum Memory Placement</TITLE><PARAGRAPH>Suppose a Fortran program allocates a 1000 by 1000 array of complex numbers. By default IRIX places this 16&nbsp;MB memory allocation in the node where the program starts up. But what if the program contains the C$DOACROSS directive to parallelize the DO-loop that processes the array? (See <XREF IDREF="41755" TYPE="TITLE">Chapter&nbsp;11, &ldquo;Statement-Level Parallelism.&rdquo;</XREF>) Some number threads&mdash;say, four&mdash;execute blocks of the DO-loop in parallel, using four CPUs located in two, three, or even four different nodes. Two problems arise:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>At least two of the threads have to pay a penalty of at least one router hop to get the data.</PARAGRAPH>
<PARAGRAPH>It would be better to allocate parts of the array in the nodes where those threads are running.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>A single hub chip can easily keep up with the memory demands of two CPUs, but when four CPUs are generating constant memory requests, one hub may saturate, slowing access.</PARAGRAPH>
<PARAGRAPH>It would be better to distribute the array data among other nodes&mdash;<ITALICS>any</ITALICS> other nodes&mdash;to prevent a single hub from being a bottleneck.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION3 LBL="" HELPID = ""><TITLE>Detecting Memory Placement Problems</TITLE><PARAGRAPH>Unfortunately none of the counter values reported by <COMMAND>perfex</COMMAND> provide a direct diagnosis of bad memory placement. You can suspect memory placement problems from a combination of circumstances:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Performance does not improve as expected when more parallel threads and CPUs are added.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The <COMMAND>perfex</COMMAND> report shows a relatively low percentage of cache line reuse (less than 85% secondary cache hits, to pick a common number).</PARAGRAPH>
<PARAGRAPH>This is a performance problem you can address for its own sake; but it demonstrates that the program depends on a high memory bandwidth.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The program has a high CPU utilization, so it is not being delayed for I/O or by synchronization with other threads.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The program has no other performance problems that can be detected with <COMMAND>perfex</COMMAND> of the Speedshop tools (see the <REFPAGE>speedshop(1)</REFPAGE> reference page).</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>There are two issues: to make sure that each thread concentrates memory access on some definable subset of the data; and second, to make sure that this data is allocated on or near the node where the thread executes.</PARAGRAPH>
<PARAGRAPH>The first issue is algorithmic. It is not possible for a page of data to be in two nodes at once. When data is used simultaneously by two or more threads, that data must be closer to some threads than to others, and it must be delivered to all threads from a single hub chip. (Parenthetically, what is true of data is not necessarily true of program text, which is read-only. The kernel can and does replicate the pages of common DSOs in every node so that there is no time penalty for fetching instructions from common DSOs like the C or Fortran runtime libraries.)</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Programming Desired Memory Placement</TITLE><PARAGRAPH>When you have a clear separation of data between parallel threads, there are several tools for placing pages near the threads that use them. The tool you use depends on the model of parallel computation you use.</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Using the Fortran compiler, specify how array elements are distributed among the threads of a parallelized loop using compiler directives. The C compiler supports pragma statements for the same purpose.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Take advantage of IRIX memory-allocation rules to ensure that memory is allocated next to the threads that use it.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Enable dynamic page migration to handle slowly-changing access patterns.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Use the <COMMAND>dprof</COMMAND> tool to learn the memory-use patterns of a program (see the <REFPAGE>dprof(1)</REFPAGE> reference page).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Use the <COMMAND>dplace</COMMAND> tool to set the initial memory layout of any program, without needing to modify the source code (see the <REFPAGE>dplace(1)</REFPAGE> reference page).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Code dynamic calls to <COMMAND>dplace</COMMAND> within the program, to request dynamic relocation of data between one program phase and the next.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using Compiler Directives for Memory Placement</TITLE><PARAGRAPH>The Silicon Graphics Fortran 77 and Fortran 90 compilers support compiler directives for data placement. You use compiler directives to specify parallel processing over loops. You can supplement these with directives specifying how array sections should be distributed among the nodes that execute the parallel threads.</PARAGRAPH>
<PARAGRAPH>You use the Fortran directives to declare a static placement for array sections. You can also use directives to specify redistribution of data at runtime, when access patterns change in the course of the program. For details on these directives, see the Fortran programmer's guides cited under <XREF IDREF="67758" TYPE="TITLE">&ldquo;Other Useful References&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>The Silicon Graphics C and C++ compilers support some pragma statements for data placement. These are documented in the <DOCTITLE>C Language Reference Manual</DOCTITLE> (see <XREF IDREF="67758" TYPE="TITLE">&ldquo;Other Useful References&rdquo;</XREF>).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Taking Advantage of First-Touch Allocation</TITLE><PARAGRAPH>By default, IRIX places memory pages in the nodes where they are first &ldquo;touched,&rdquo; that is, referenced by a CPU. In order to take advantage of this rule you have to be aware of when a first touch can take place. With reference to the different means of <XREF IDREF="82209" TYPE="TITLE">&ldquo;Address Definition&rdquo;</XREF>,</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The system call <FUNCTION>fork(</FUNCTION>) duplicates the address space, including the placement of all its pages.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The system call <FUNCTION>exec()</FUNCTION> creates initial stack and data pages in the node where the new program will run.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The system calls <FUNCTION>brk()</FUNCTION> and <FUNCTION>sbrk()</FUNCTION> extend the virtual address space but do not &ldquo;touch&rdquo; new, complete pages.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The standard and optional library functions <FUNCTION>malloc()</FUNCTION>, when called to allocate more than a page size aligned on a page boundary, do not touch any <ITALICS>new</ITALICS> pages they allocate. (Space that has been allocated, touched, and freed can be reused, and it stays where it was first touched.)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The system call <FUNCTION>mmap()</FUNCTION> does not touch the pages it maps (see <XREF IDREF="54272" TYPE="TITLE">&ldquo;Mapping Segments of Memory&rdquo;</XREF>).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The library call <FUNCTION>calloc()</FUNCTION> touches the pages it allocates to fill them with zero.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The system functions to lock memory pages (see <XREF IDREF="25692" TYPE="TITLE">&ldquo;Locking and Unlocking Pages in Memory&rdquo;</XREF>) do touch the pages they lock.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>It is typical to allocate all memory, including work areas used by subprocesses or threads, in the parent process. This practice ensures that all memory is allocated in the node where the parent runs. Instead, the parent process should allocate and touch only data space that is used by multiple threads. Work areas that are unique to a thread should be allocated and touched first by that thread; then they are placed in the node where the thread runs.</PARAGRAPH>
<PARAGRAPH>Shared memory arenas (see <XREF IDREF="28345" TYPE="TITLE">Chapter&nbsp;3, &ldquo;Sharing Memory Between Processes&rdquo;</XREF>) are based on memory-mapping. However, the library function or system call that creates an arena will typically touch at least the beginning of the arena in order to initialize it. If each thread is to have a private data area within an arena, make the private area at least a page in size, allocated on a page-size boundary; and allocate it from the thread that uses it.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using Round-Robin Allocation</TITLE><PARAGRAPH>When a Fortran or C program uses statement-level parallelism (based on the multiprocessing library <FILENAME>libmp</FILENAME>&mdash;see <XREF IDREF="66886" TYPE="TITLE">&ldquo;Managing Statement-Parallel Execution&rdquo;</XREF>), you can replace the first-touch allocation rule with round-robin allocation. When you set an environment variable _DSM_ROUND_ROBIN, <FILENAME>libmp</FILENAME> distributes all data memory for the program across the nodes in which the program runs. Each new virtual page is allocated in a different node.</PARAGRAPH>
<PARAGRAPH>Round-robin allocation does not produce optimal placement because there is no relationship between the threads and the pages they use. However, it does ensure that the data will be served by multiple hub chips.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using Dynamic Page Migration</TITLE><PARAGRAPH>Dynamic page migration can be enabled for a specific program, or for all programs. When migration is enabled, IRIX keeps track of the source of the references to each page of memory. When a page is being used predominately from a different node, IRIX copies the page contents to the node that is using it, and resets the page tables to direct references to the new location.</PARAGRAPH>
<PARAGRAPH>Dynamic migration is a relatively expensive operation: besides the overhead of a daemon that uses hardware counters to monitor page usage, a migration itself entails a memory copy of data and the forced invalidation of translate lookaside registers in all affected nodes (see <XREF IDREF="94319" TYPE="TITLE">&ldquo;Page Numbers and Offsets&rdquo;</XREF>). For this reason, migration is not enabled by default. (The system administrator can turn it on for all programs using the <COMMAND>sn</COMMAND> command as described in the <REFPAGE>sn(1)</REFPAGE> reference page, but this is not recommended.)</PARAGRAPH>
<PARAGRAPH>You can experiment to see whether dynamic page migration helps a particular program. It is likely to help when the initial placement of data is not optimal, and when the program maintains consistent access patterns for long periods (many seconds to minutes). When the program has variable, inconsistent access patterns, migration can hurt performance by causing frequent, unhelpful page movements.</PARAGRAPH>
<PARAGRAPH>To enable migration for a Fortran or C program using libmp, set the _DSM_MIGRATION environment variable, as described in <REFPAGE>mp(3)</REFPAGE>. In order to enable migration for another type of program, run the program under the <COMMAND>dplace</COMMAND> command with the <COMMAND>-migration</COMMAND> option.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using Explicit Memory Placement</TITLE><PARAGRAPH>The <COMMAND>dplace</COMMAND> execution monitor is a powerful tool that runs any program (other than programs that use <FILENAME>libmp</FILENAME>; <COMMAND>dplace</COMMAND> and <FILENAME>libmp</FILENAME> manage the same facilities and cannot be used together) using a custom memory-placement policy that you define using a simple control file. The program you run does not have to be recompiled or modified in any way to take advantage of the memory placement, and it runs at full speed once started.</PARAGRAPH>
<PARAGRAPH>The <COMMAND>dplace</COMMAND> tool is documented in three reference pages: <REFPAGE>dplace(1)</REFPAGE> describes the command syntax and options; <REFPAGE>dplace(5)</REFPAGE> documents the control file syntax; and <REFPAGE>dplace(3)</REFPAGE> describes how you can call on <COMMAND>dplace</COMMAND> dynamically, from within a program.</PARAGRAPH>
<PARAGRAPH>Using <COMMAND>dplace</COMMAND> you can:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Establish the virtual page size of the stack, heap, and text segments individually at sizes from 16&nbsp;KB to 16&nbsp;MB. For example, if the <COMMAND>perfex</COMMAND> monitor shows the program is suffering many TLB misses, you can increase the size of a data page, effectively increasing the span of addresses covered by each TLB entry.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Turn on dynamic page migration for the program, and set the threshold of local to remote accesses that triggers migration.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Place each process within the program on a specific node, either by node number or with respect to the node where a certain I/O device is attached.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Distribute the processes of a program among any available cluster of nodes having a specified topology (usually cube topology to minimize router distances between nodes).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Place specified segments of the virtual address space in designated nodes.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The <COMMAND>dprof</COMMAND> profiler (see the <REFPAGE>dprof(1)</REFPAGE> reference page) complements <COMMAND>dplace</COMMAND>. You use <COMMAND>dprof</COMMAND> to run a program and get a trace report showing which pages are read and written by each process in the program.</PARAGRAPH>
<PARAGRAPH>When you have control of the source code of a program, you can place explicit calls to <COMMAND>dplace</COMMAND> within the code. The program can call <COMMAND>dplace</COMMAND> to move specific processes to specific nodes, or to migrate specific ranges of addresses to nodes. </PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
</CHAPTER>
