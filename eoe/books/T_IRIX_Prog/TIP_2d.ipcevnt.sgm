<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="5"><TITLE><XREFTARGET ID="89823">Signalling Events</TITLE><PARAGRAPH>Processes can receive <ITALICS>signals</ITALICS> in order to respond to asynchronous requests from software or to unexpected hardware events. There are three different programming interfaces for receiving signals; you must select one and use it consistently throughout a program.</PARAGRAPH>
<PARAGRAPH>Many programs need access to time data for one of two purposes: to produce <ITALICS>timestamps</ITALICS> so that data can be ordered by its time of origin, and to define <ITALICS>intervals</ITALICS> so the program can take action at regular times. (Intervals are presented to the program as signals.)</PARAGRAPH>
<PARAGRAPH>These two issues are covered in the following topics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="45686" TYPE="TITLE">&ldquo;Signals&rdquo;</XREF> describes signal facilities in general and details the differences between the POSIX, SVR4, and BSD interfaces.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="20149" TYPE="TITLE">&ldquo;Timer Facilities&rdquo;</XREF> describes POSIX and IRIX methods of defining timestamps and intervals.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="45686">Signals</TITLE><PARAGRAPH>A signal is a notification of an event, sent asynchronously to a process. Some signals originate from the kernel in response to hardware traps; for example, the SIGFPE signal that notifies of an arithmetic overflow, or the SIGALRM that notifies of the expiration of a timer interval. Other signals are issued by software. For a detailed, formal discussion of signals, read the <INDEXTARGET ID="TIP_2d.ipcevnt1"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt1|signal --><REFPAGE>signal(5)</REFPAGE> reference page.</PARAGRAPH>
<PARAGRAPH>A process can block all signals or selected signals, ignore some signals, or request a default system handling for some signals. When a signal that has been sent to a process is blocked by the process, the signal remains pending. When a signal is not blocked, the process receives the signal. In a multithreaded process, signals can be blocked or received by individual threads.</PARAGRAPH>
<PARAGRAPH>When receiving a signal, a process or thread can handle the signal by an asynchronous call into a signal-handling function. Alternatively, using the POSIX interface, a process or thread can handle signals synchronously, as a stream of event objects.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="90328">Signal Numbers</TITLE><PARAGRAPH>IRIX supports the following 64 signal numbers: <INDEXTARGET ID="TIP_2d.ipcevnt2"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt2|signal:signal numbers --></PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>1-31</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Same meanings as SVR4 and BSD; see Table&nbsp;5-1.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>32</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Reserved by IRIX kernel.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>33-48</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Reserved by the POSIX standard for system use.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="45"><PARAGRAPH>49-64</PARAGRAPH>
</CELL>
<CELL LEFT="50" WIDTH="342"><PARAGRAPH>Reserved by POSIX for real-time programming.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Signals with smaller numbers have priority for delivery. The low-numbered BSD-compatible signals, which include all kernel-produced signals, are delivered ahead of real-time signals, and signal 49 takes precedence over signal 64.</PARAGRAPH>
<PARAGRAPH><XREF IDREF="67027" TYPE="TABLE">Table&nbsp;5-1</XREF> is reproduced from the <REFPAGE>signal(5)</REFPAGE> reference page for convenience. </PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="5-1"><PREFIX>Table 5-1 </PREFIX><XREFTARGET ID="67027"> <EMPHASIS>(continued)        </EMPHASIS>Signal Numbers and Default Actions</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="63"><PARAGRAPH>Symbolic 
Name</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>Numeric 
Value</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>&lbreak;Default Action</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>&lbreak;Normal Meaning</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGHUP</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>1</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Controlling terminal disconnect; see <REFPAGE>termio(7)</REFPAGE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGINT</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>2</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Interrupt key signal from controlling terminal; 
see <REFPAGE>termio(7)</REFPAGE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGQUIT</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>3</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate and dump</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Quit key signal from controlling terminal; see 
<REFPAGE>termio(7)</REFPAGE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGILL</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>4</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate and dump</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Attempt to execute illegal instruction.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGTRAP</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>5</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate and dump</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Trace/breakpoint reached; see <REFPAGE>proc(4)</REFPAGE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGABRT</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>6</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate and dump</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Abort.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGEMT</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>7</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate and dump</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Emulation trap.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGFPE</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>8</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate and dump</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Arithmetic exception; see <REFPAGE>math(3M)</REFPAGE>, <REFPAGE>sigfpe(3C)</REFPAGE>, 
and <REFPAGE>matherr(3M)</REFPAGE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGKILL</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>9</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Kill request from software or user.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGBUS</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>10</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate and dump</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Bus error (hardware exception).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGSEGV</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>11</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate and dump</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Segmentation fault (illegal address).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGSYS</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>12</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate and dump</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Invalid system call.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGPIPE</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>13</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Read or write to broken pipe; see <REFPAGE>pipe(2)</REFPAGE>, 
<REFPAGE>read(2)</REFPAGE>, <REFPAGE>write(2)</REFPAGE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGALRM</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>14</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Interval timer elapsed; see <XREF IDREF="20149" TYPE="TITLE">&ldquo;Timer Facilities&rdquo;</XREF>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGTERM</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>15</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Process terminated.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGUSR1</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>16</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Programmer-defined; see also text below.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGUSR2</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>17</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Programmer-defined.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGCHLD or 
SIGCLD</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>18</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Child process status change; see <REFPAGE>wait(2)</REFPAGE> and 
<XREF IDREF="49551" TYPE="TITLE">&ldquo;Process &ldquo;Reaping&rdquo;&rdquo;</XREF>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGPWR</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>19</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Ignore</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Power fail/restart.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGWINCH</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>20</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Ignore</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Change in size of window; see <REFPAGE>xterm(1)</REFPAGE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGURG</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>21</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Ignore</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Urgent socket condition; see <REFPAGE>socket(2)</REFPAGE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGPOLL</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>22</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Pollable event from a STREAMS device, see 
<REFPAGE>streamio(7)</REFPAGE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGIO</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>22</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Input/output possible.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGSTOP</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>23</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Suspend</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Stopped.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGTSTP</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>24</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Suspend</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Stop key signal from controlling terminal; see 
<REFPAGE>termio(7)</REFPAGE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGCONT</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>25</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Ignore</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Continued.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGTTIN</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>26</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Suspend</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Attempt to read terminal from background 
process; see <REFPAGE>termio(7)</REFPAGE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGTTOU</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>27</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Suspend</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Attempt to write terminal from background 
process; see <REFPAGE>termio(7)</REFPAGE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGVTALRM</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>28</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Virtual timer expired; see <REFPAGE>getitimer(2)</REFPAGE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGPROF</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>29</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Profiling timer expired; see <REFPAGE>getitimer(2)</REFPAGE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGXCPU</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>30</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate and dump</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>CPU time limit exceeded; see <REFPAGE>getrlimit(2)</REFPAGE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGXFSZ</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>31</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate and dump</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>File size limit exceeded; see <REFPAGE>getrlimit(2)</REFPAGE> and 
<REFPAGE>write(2)</REFPAGE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>(no symbol)</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>32-48</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>Unassigned; do not use.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH>SIGRTMIN - 
SIGRTMAX</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="39"><PARAGRAPH>49-64</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="90"><PARAGRAPH>Terminate</PARAGRAPH>
</CELL>
<CELL LEFT="210" WIDTH="194"><PARAGRAPH>POSIX real-time signal range.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Although SIGUSR1 and SIGUSR2 are nominally defined by the you for your program's purposes, they are also used by different application packages for special signals. For example, if you set a file lock on an NFS mounted file, the NFS lock daemon may send SIGUSR1&mdash;see <XREF IDREF="35973" TYPE="TITLE">&ldquo;NFS File Locking&rdquo;</XREF>. &nbsp;</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Signal Implementations</TITLE><PARAGRAPH>There are three UNIX traditions for signals, and IRIX supports all three. They differ in the library calls used, in the range of signals allowed, and in the details of signal delivery. The basic signal operations and the implementing functions are summarized in <INDEXTARGET ID="TIP_2d.ipcevnt3"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt3|signal:compatibility --><XREF IDREF="82143" TYPE="TABLE">Table&nbsp;5-2</XREF>.(You can click on the reference pages in this table to display them.) </PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="5-2"><PREFIX>Table 5-2 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="82143">Signal Handling Interfaces</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="108"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="108"><PARAGRAPH>POSIX Functions</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="90"><PARAGRAPH>SVR4 Functions</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="79"><PARAGRAPH>BSD 4.2 Functions</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH>Set and query signal 
handler</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="108"><PARAGRAPH>sigaction(2) &lbreak;sigsetops(3) &lbreak;sigaltstack(2) </PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="90"><PARAGRAPH>sigset(2) &lbreak;signal(2) </PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="79"><PARAGRAPH>sigvec(3) &lbreak;signal(3) </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH>Send a signal</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="108"><PARAGRAPH>sigqueue(2) &lbreak;kill(2) &lbreak;pthread_kill(3P) </PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="90"><PARAGRAPH>sigsend(2) &lbreak;kill(2) </PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="79"><PARAGRAPH>kill(3) &lbreak;killpg(3) </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH>Temporarily block 
specified signals</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="108"><PARAGRAPH>sigprocmask(2) &lbreak;pthread_sigmask(3P) </PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="90"><PARAGRAPH>sighold(2) &lbreak;sigrelse(2) </PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="79"><PARAGRAPH>sigblock(3) &lbreak;sigsetmask(3<REFPAGE>)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH>Query pending signals</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="108"><PARAGRAPH>sigpending(2) </PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="90"><PARAGRAPH>n.a.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="79"><PARAGRAPH>n.a.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH>Wait for a signal handler 
to be invoked.</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="108"><PARAGRAPH>sigsuspend(2) </PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="90"><PARAGRAPH>sigpause(2) </PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="79"><PARAGRAPH>sigpause(3) </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH>Wait for a signal and 
receive synchronously</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="108"><PARAGRAPH>sigwait(2) &lbreak;sigwaitinfo(2) &lbreak;sigtimedwait(2)</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="90"><PARAGRAPH>n.a.</PARAGRAPH>
</CELL>
<CELL LEFT="325" WIDTH="79"><PARAGRAPH>n.a.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>It is important to not mix these signal facilities. Your program should use functions from only one column of <XREF IDREF="82143" TYPE="TABLE">Table&nbsp;5-2</XREF>; otherwise unexpected results can occur.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="97454">Signal Blocking and Signal Masks</TITLE><PARAGRAPH>Certain ideas are basic to the use of signals. One basic idea is that a program can block the delivery of any signal. When a signal that is sent to a program is blocked, the signal is queued and remains pending until the program unblocks the signal, or terminates. Certain urgent signals&mdash;SIGKILL, SIGSTOP, SIGCONT&mdash;cannot be blocked.<INDEXTARGET ID="TIP_2d.ipcevnt4"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt4|signal:blockingsignal:mask --></PARAGRAPH>
<PARAGRAPH>You specify which signals are blocked using a signal mask, a set of bits in which each bit corresponds to one signal number. When a bit in the mask is set on, the signal is blocked (if it is a signal that can be blocked).</PARAGRAPH>
<PARAGRAPH>Each process has a signal mask, inherited from its parent process. All three interfaces provide ways to set and clear bits in the current signal mask. The BSD interface, however, only lets you mask the first 32 signal numbers listed in <XREF IDREF="67027" TYPE="TABLE">Table&nbsp;5-1</XREF>.</PARAGRAPH>
<PARAGRAPH>Each POSIX thread has a signal mask also (see <XREF IDREF="59366" TYPE="TITLE">&ldquo;Setting Signal Masks&rdquo;</XREF>). A multithreaded program (defined as a program that is linked with <FILENAME>libpthread</FILENAME>, so it uses the pthreads version of the standard library) should use the POSIX interface for signal handling.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Multiple Signals</TITLE><PARAGRAPH>In most cases, if a signal of a certain number is pending for a process, and another signal of the same number arrives, the second signal is discarded. In other words, at most one signal of a given number can normally be pending for a process.<INDEXTARGET ID="TIP_2d.ipcevnt5"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt5|signal:multiple received --></PARAGRAPH>
<PARAGRAPH>In the POSIX interface you can use one particular function, <FUNCTION>sigqueue()</FUNCTION>, to send a signal that is queued regardless of how many signals of the same number are already pending.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="79800">Signal Handling Policies</TITLE><PARAGRAPH>You can specify one of three policies for handling an unblocked signal. You set the policy for each signal number individually. <INDEXTARGET ID="TIP_2d.ipcevnt6"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt6|signal:handling policy for --></PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Default Handling</TITLE><PARAGRAPH>Initially, all signals receive default handling. This means that when a signal arrives and is not blocked, it causes the default action listed in <XREF IDREF="67027" TYPE="TABLE">Table&nbsp;5-1</XREF>. In many cases the default action is to ignore the signal, that is, to silently discard it. In other cases, the default action is to terminate the program, or to terminate it with a dump. </PARAGRAPH>
<PARAGRAPH>Each signal interface gives you a way to specify non-default handling or a specified signal, or to return a signal to default handling.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Ignoring Signals</TITLE><PARAGRAPH>You can request that a specified signal be ignored. You would do this when the signal is not meaningful to your program and the default action is not what you wish. For example, in a noninteractive program, you might set Ignore handling for SIGHUP (the default action is to terminate).<INDEXTARGET ID="TIP_2d.ipcevnt7"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt7|signal:ignoring --></PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="35142">Catching Signals</TITLE><PARAGRAPH>You can request that a signal be caught and handled asynchronously, at the moment it arrives. You specify that a signal should be caught by specifying the address of a function to be called when the signal is received.<INDEXTARGET ID="TIP_2d.ipcevnt8"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt8|signal:catching --></PARAGRAPH>
<PARAGRAPH>The signal-handling function is entered asynchronously, without regard for what the process was doing at the time the signal was delivered. You cannot be sure what code was executing when the signal handler is called; it could have been any function in your own code, or it could have been code in the C library or in any layer of the X-Windows or Motif support libraries.</PARAGRAPH>
<PARAGRAPH>All three interfaces provide for passing the signal number as the first argument of the signal-handling function. Other arguments to the handler function depend on the interface used and the options you specify when establishing the handler.</PARAGRAPH>
<PARAGRAPH>You can create an alternate memory area to be used as a stack when executing the signal handler. Typically a signal handler does not require a great deal of stack space. On the other hand, each POSIX thread has limited stack space, and when you provide an alternate signal-handling stack, you do not have to allow for possible signals in allocating thread stack space (see <XREF IDREF="68192" TYPE="TITLE">&ldquo;Setting Signal Actions&rdquo;</XREF>).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Synchronous Signal Handling</TITLE><PARAGRAPH>Using the POSIX signal interface you can process signals in a synchronous way, as a stream of input items to your program. This allows you to design your program so that signals are received when the process is in a known state, without the uncertainties of asynchronous delivery.<INDEXTARGET ID="TIP_2d.ipcevnt9"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt9|signal:synchronous receipt --></PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="48541">Signal Latency</TITLE><PARAGRAPH>The time that elapses from the moment a signal is generated until a signal handler begins to execute is the <INDEXTARGET ID="TIP_2d.ipcevnt10"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt10|signal:latencylatency of signal --><ITALICS>signal latency</ITALICS>. Signal latency can be long (as real-time programs measure time) and signal latency has a high variability.</PARAGRAPH>
<PARAGRAPH>The IRIX kernel normally delivers a pending, unblocked signal the next time the process returns to user code from the kernel domain. In most cases, this occurs</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>when the process is dispatched after a wait or preemption</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>upon return from a system function</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>upon return from the kernel's usual 10-millisecond &ldquo;tick&rdquo; (dispatch) interrupt</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>SIGALRM, which signals the expiration of a real-time timer (see <XREF IDREF="20149" TYPE="TITLE">&ldquo;Timer Facilities&rdquo;</XREF>), is given special treatment. It is delivered as soon as the kernel is ready to return to a user process after the timer interrupt, in order to preserve timer accuracy.</PARAGRAPH>
<PARAGRAPH>When a process is ready to run and is not preempted by a process of higher priority, and is executing in user code, not calling a system function, the latency for other than SIGALRM can be as much as 10 milliseconds. However, when the process is suspended (for example, waiting on a semaphore), or when there are competing processes having higher priorities, the delivery of a signal is delayed until the next time the receiving process is scheduled. This can be many milliseconds.</PARAGRAPH>
<PARAGRAPH>In general, you should use signals to deliver infrequent messages of high priority. You should not use the exchange of signals as the basis for real-time scheduling.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Signals Under X-Windows</TITLE><PARAGRAPH>If you plan to handle signals asynchronously in a program that uses X intrinsics, you must take special steps. Before establishing a signal handler with the operating system, you establish one or more signal callback procedures using <INDEXTARGET ID="TIP_2d.ipcevnt11"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt11|signal:and X intrinsics --><FUNCTION>XtAppAddSignal()</FUNCTION>. Then, in the asynchronous signal handling function, you call <FUNCTION>XtNoticeSignal()</FUNCTION>. This function ensures that the established signal callback will be invoked like other callback functions, when it is safe to do so. This process is documented in the <REFPAGE>XtAppAddSignal(3Xt)</REFPAGE> reference page.</PARAGRAPH>
<PARAGRAPH>The only X-windows function that can safely be called from a signal handler is <FUNCTION>XtNoticeSignal()</FUNCTION>.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="58175">POSIX Signal Facility</TITLE><PARAGRAPH>The POSIX interface to signals is the most functionally complete and robust of the three. It is the recommended interface for all new programs. The functions used in POSIX style signal handling are summarized in <INDEXTARGET ID="TIP_2d.ipcevnt12"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt12|signal:POSIX facilities --><XREF IDREF="46878" TYPE="TABLE">Table&nbsp;5-3</XREF>.</PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="5-3"><PREFIX>Table 5-3 </PREFIX><XREFTARGET ID="46878"> <EMPHASIS>(continued)        </EMPHASIS>Functions for POSIX Signal Handling</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="108"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>kill(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>Send a signal to a process or process group. (Discards multiple signals 
of the same number.)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>sigqueue(3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>Queue a signal to a specified process, including a <VARIABLE>sigval</VARIABLE> for added 
information about the signal. (Queues multiple signals of the same 
number.)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>pthread_kill(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>Send a signal to a specified thread. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>sigprocmask(2)</REFPAGE> &lbreak;<REFPAGE>pthread_sigmask(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>Examine or change the mask of signals allowed and blocked. You 
must use <FUNCTION>pthread_sigmask()</FUNCTION> in a program that is linked with 
<FILENAME>libpthread</FILENAME>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>sigaction(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>Specify or query the signal handling policy for a specified signal.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>sigaltstack(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>Specify or query an alternate stack area to be used by a signal handler.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>sigpending(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>Return the set of signals pending for the calling process or thread.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>sigsetops(3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>Manipulate signal mask objects in memory.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>sigsuspend(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>Unblock selected signals for the calling process or thread, and wait for 
a signal to be received asynchronously.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>sigwait(3)</REFPAGE> &lbreak;<REFPAGE>sigtimedwait(3)</REFPAGE> &lbreak;<REFPAGE>sigwaitinfo(3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>Wait for and receive specified signals in a synchronous manner.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>In addition to the reference pages listed in <XREF IDREF="46878" TYPE="TABLE">Table&nbsp;5-3</XREF>, the following have important information about signal handling: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>signal(5)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>Detailed overview of signals and signal handling.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>siginfo(5)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>Description of the information structure passed to a POSIX 
signal handler.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>ucontext(5)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>Description of machine context structure passed to a POSIX 
signal handler.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<SECTION3 LBL="" HELPID = ""><TITLE>Signal Masking</TITLE><PARAGRAPH>Each process and thread has an active signal mask. A single-thread program sets or queries its signal mask using <INDEXTARGET ID="TIP_2d.ipcevnt13"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt13|signal:mask --><FUNCTION>sigprocmask()</FUNCTION>. A multithreaded program (any program that linked <FILENAME>libpthread</FILENAME>, which provides the pthread version of the standard library) should use <FUNCTION>pthread_sigmask()</FUNCTION>.</PARAGRAPH>
<PARAGRAPH>Besides the active signal mask, you may have other signal mask objects (type <VARIABLE>sigset_t</VARIABLE>) in memory. The <REFPAGE>sigsetops(3)</REFPAGE> reference page documents a number of utility functions for setting, clearing, and testing the bits in a signal mask object. Several POSIX signal functions take a signal mask as an argument. For example, <FUNCTION>sigsuspend()</FUNCTION> takes a new signal mask and swaps it for the current signal mask, establishing which pending signals will be accepted while the process is suspended.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using Synchronous Handling</TITLE><PARAGRAPH>You can design your program so that it treats arriving signals as a stream of event records to be processed in sequence. For example, you could use one or more signal numbers in the POSIX real-time range to signify events that are meaningful to your application. Your application, or one thread in your application, can receive each signal in turn and act upon it.<INDEXTARGET ID="TIP_2d.ipcevnt14"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt14|signal:synchronous receipt --></PARAGRAPH>
<PARAGRAPH>To implement this design approach, follow these steps:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Block the expected signal numbers in all processes or threads using <FUNCTION>sigprocmask()</FUNCTION> or <FUNCTION>pthread_sigmask()</FUNCTION>.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Send the signals using <FUNCTION>sigqueue()</FUNCTION>. This function permits you to augment the signal number with a <VARIABLE>union sigval</VARIABLE> (in effect creating an open-ended set of sub-signals), and also assures that multiple signals will be retained until you process them.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>In the signal-processing loop, wait for the next signal with <FUNCTION>sigwaitinfo()</FUNCTION> or <FUNCTION>sigtimedwait()</FUNCTION>. When the signal arrives, act accordingly and wait again.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>The <FUNCTION>sigwaitinfo()</FUNCTION> and <FUNCTION>sigtimedwait()</FUNCTION> functions accept a new signal mask. They unblock the specified signal or signals and suspend until one such signal arrives. They accept that signal, restore the original signal mask, and return the signal information.</PARAGRAPH>
<PARAGRAPH>You could construct a very similar work-handling application using a message queue (see <XREF IDREF="48324" TYPE="TITLE">Chapter&nbsp;6, &ldquo;Message Queues&rdquo;</XREF>). However, this design approach allows you to integrate the handling of unplanned signals such as SIGPIPE, and interval-timer signals such as SIGALRM, into the same scheme as planned application events.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using Asynchronous Handling</TITLE><PARAGRAPH>Using <INDEXTARGET ID="TIP_2d.ipcevnt15"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt15|<FUNCTION>sigaction()</FUNCTION> --><FUNCTION>sigaction()</FUNCTION>, you specify a function to be called when a particular signal is received. You have a choice of function prototypes. In each case the signal handler is passed the signal number, additional information about the signal, and information about the machine context at the time the signal was delivered.</PARAGRAPH>
<PARAGRAPH>Your signal handler can have the POSIX prototype, as follows:</PARAGRAPH>
<EXAMPLE>
void <VARIABLE>name</VARIABLE>(int sig, siginfo_t *sip, ucontext_t *up)
</EXAMPLE>
<PARAGRAPH>The second argument, a POSIX information structure <VARIABLE>siginfo_t</VARIABLE>, contains these fields: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>si_signo</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>The signal number (again).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>si_errno</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Either 0 or an error code from <FILENAME>errno.h</FILENAME>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>si_code</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>An indication of the source of the signal.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>si_value</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>When <VARIABLE>si_code</VARIABLE> is SI_QUEUE, the <VARIABLE>union sigval</VARIABLE> passed to <FUNCTION>sigqueue()</FUNCTION>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>si_pid</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>When <VARIABLE>si_code</VARIABLE> is SI_USER, the process ID that called <FUNCTION>kill()</FUNCTION>.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>When the signal is an error reported by the kernel or hardware, <VARIABLE>si_code</VARIABLE> is an explanatory number. These values are spelled out in detail in the <REFPAGE>siginfo(5)</REFPAGE> reference page. The third argument, a pointer to a <VARIABLE>ucontext_t</VARIABLE> object, gives the machine state at the time the signal was delivered. The <VARIABLE>ucontext_t</VARIABLE> is detailed in the <REFPAGE>ucontext(5)</REFPAGE> reference page.</PARAGRAPH>
<PARAGRAPH>Alternatively, your signal handler can have this prototype:</PARAGRAPH>
<EXAMPLE>
void <VARIABLE>name</VARIABLE>(int sig, int code, struct sigcontext *sc);
</EXAMPLE>
<PARAGRAPH>The second argument gives some added information about the signal (see <REFPAGE>signal(5)</REFPAGE> for a list of codes). The third argument, a pointer to a <VARIABLE>sigcontext_t</VARIABLE> object, gives the machine state at the time the signal was delivered (in slightly different form from the <VARIABLE>ucontext_t</VARIABLE>).</PARAGRAPH>
<PARAGRAPH>When you use <FUNCTION>sigaction()</FUNCTION> to set up a signal handler, you pass an argument structure containing option flags that affect the treatment of the signal: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>SA_SIGINFO</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="297"><PARAGRAPH>When set, you are specifying asynchronous handling and your 
handler uses the POSIX prototype. Its address is passed in the 
<VARIABLE>sa_sigaction</VARIABLE> structure field. When not set, a handler uses the older 
prototype and its address is passed in <VARIABLE>sa_handler</VARIABLE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>SA_ONSTACK</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="297"><PARAGRAPH>When set, your handler is called using alternate stack memory you 
have previously assigned with <FUNCTION>sigaltstack()</FUNCTION>. Otherwise the 
handler uses the stack of the process or thread stack executing at 
the time of the signal.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>SA_RESETHAND</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="297"><PARAGRAPH>When set, the policy for this signal is reset to the default when your 
handler is called. Your handler is expected to reestablish the action 
if that is desired.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>SA_NODEFER</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="297"><PARAGRAPH>When not set, the signal is automatically blocked while your 
handler executes, and unblocked when your handler returns. 
When set, the same signal could be taken while your handler 
executes, resulting in multiple entries to the handler.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>SA_RESTART</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="297"><PARAGRAPH>When not set, if this signal interrupts a blocked system function 
the system function returns EINTR. When set, the system function 
is restarted.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>&space;</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>System V Signal Facility</TITLE><PARAGRAPH>The System V signal interface is compatible with code ported from UNIX System V. It includes compatibility for release 3 (SVR3) and release 4 (SVR4). <INDEXTARGET ID="TIP_2d.ipcevnt16"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt16|signal:SVR4 facilities --><XREF IDREF="33406" TYPE="TABLE">Table&nbsp;5-4</XREF> summarizes the functions you use to manage signals through this interface.</PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="5-4"><PREFIX>Table 5-4 </PREFIX><XREFTARGET ID="33406"> <EMPHASIS>(continued)        </EMPHASIS>Functions for SVR4 Signal Handling</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="81"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>kill(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Send a signal to a process or process group. (A duplicate of a pending signal 
is discarded.)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>sigsend(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Send a signal to a set of processes or process groups, specified in a variety of 
ways, for example by user ID.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>signal(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>SVR3 call to establish handling policy of default, ignore, or catch for a 
specified signal.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>sigset(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>SVR4 call to establish handling policy of default, ignore, or catch for a 
specified signal.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>sighold(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Hold (block) a specified signal.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>sigignore(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Set the handling for a specified signal to Ignore.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>sigrelse(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Release (unblock) a specified signal.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>sigpause(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Suspend the calling process until a specified signal arrives.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Only asynchronous signal handling is supported by the System V interface. Also, you must block and unblock signals individually; there is no support for setting the entire signal mask in one operation.</PARAGRAPH>
<PARAGRAPH>The semantics of SVR3-compatible signal established with <FUNCTION>signal()</FUNCTION> are not desirable for most programs. When control enters a signal handler you established using <FUNCTION>signal()</FUNCTION>, the handling of that same signal is set to default, and that signal remains unblocked. Your signal handler can use <FUNCTION>signal()</FUNCTION> to reestablish itself as the handler, or it can use <FUNCTION>sighold()</FUNCTION> to block the signal. However, even if these actions are the first statements of the handler function, there is a period of time at the beginning of the handler during which a second signal of the same type could be received. If this occurs, the second signal receives default handling and is not seen by your handler.</PARAGRAPH>
<PARAGRAPH>You can avoid this problem by using the SVR4 function <FUNCTION>sigset() </FUNCTION>instead of <FUNCTION>signal() </FUNCTION>to establish a handler. Before a handler established by <FUNCTION>sigset()</FUNCTION> is called, that signal is blocked until the handler returns, and the signal disposition is not reset to default.&space;</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>BSD Signal Facility</TITLE><PARAGRAPH>The BSD signal facility is compatible with code ported from the BSD 4.2 distribution. <INDEXTARGET ID="TIP_2d.ipcevnt17"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt17|signal:BSD facilities --><XREF IDREF="90301" TYPE="TABLE">Table&nbsp;5-5</XREF> summarizes the functions you use to manage signals with this interface.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>In order to use any of the functions in <XREF IDREF="90301" TYPE="TABLE">Table&nbsp;5-5</XREF> you must define one of the compiler variables _BSD_SIGNALS or _BSD_COMPAT prior to the inclusion of the header file <FILENAME>signal.h</FILENAME>. You can do this directly in the source file with #define. More commonly you will include -D_BSD_COMPAT as one of the compiler flags you define in your Makefile. </NOTE>
<TABLE COLUMNS="2"><CAPTION LBL="5-5"><PREFIX>Table 5-5 </PREFIX><XREFTARGET ID="90301"> <EMPHASIS>(continued)        </EMPHASIS>Functions for BSD Signal Handling</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="99"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Purpose and Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>kill(3B)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Send a signal to a specified process, or broadcast a signal to a process 
group or to all processes with the same effective user ID. (A duplicate of 
a pending signal is discarded.)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>killpg(3B)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Send a signal to all members of a process group. (A duplicate of a 
pending signal is discarded.)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>sigvec(3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Establish a policy of default, ignore, or catch for a specified signal.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>signal(3B)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Simplified interface to <FUNCTION>sigvec()</FUNCTION>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>sigstack(2B)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Establish an alternate stack for the use of signal-handling functions.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>sigsetmask(3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Set the active signal mask.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>sigblock(3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Add blocked signals to the active signal mask.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>sigpause(3B)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Wait for specified signals to arrive.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Only asynchronous signal handling is supported by the BSD interface. It is possible to set and interrogate the signal mask in a single operation; however, the signal mask type is the integer, so only signal numbers 1-32 can be blocked. The BSD interface does not recognize higher-numbered signals.&space;</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="20149">Timer Facilities</TITLE><PARAGRAPH>You use timer facilities for a number of purposes: to get information about program performance; to make a program pause for a certain time; to program an interval of time; and to create a timestamp value to store with other data.<INDEXTARGET ID="TIP_2d.ipcevnt18"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt18|timer --></PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Timed Pauses and Schedule Cession</TITLE><PARAGRAPH>In many instances a program, or a process within a multiprocess program, needs to suspend execution for a period of time. IRIX contains a variety of functions that provide this capability. The functions differ in their precision and in their portability. <INDEXTARGET ID="TIP_2d.ipcevnt19"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt19|<FUNCTION>sched_yield()</FUNCTION> --><INDEXTARGET ID="TIP_2d.ipcevnt20"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt20|<FUNCTION>sginap()</FUNCTION> --><INDEXTARGET ID="TIP_2d.ipcevnt21"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt21|wait, timedyielding --><XREF IDREF="73058" TYPE="TABLE">Table&nbsp;5-6</XREF> contains a summary. </PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="5-6"><PREFIX>Table 5-6 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="73058">Functions for Timed Suspensions</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Reference Page</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>Precision</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="63"><PARAGRAPH>Compatibility</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="180"><PARAGRAPH>Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>sched_yield(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>n.a.</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="63"><PARAGRAPH>POSIX</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="180"><PARAGRAPH>Defer to any processes eligible to run.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>sginap(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>dispatching 
interval (10ms)</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="63"><PARAGRAPH>IRIX</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="180"><PARAGRAPH>Defer to other processes for the specified 
number of dispatching cycles.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>sleep(3C)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>second</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="63"><PARAGRAPH>POSIX</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="180"><PARAGRAPH>Suspend for a number of seconds or until a 
signal arrives.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>usleep(3C)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>microsecond</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="63"><PARAGRAPH>IRIX</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="180"><PARAGRAPH>Suspend for a number of microseconds or 
until a signal arrives.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>nanosleep(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="72"><PARAGRAPH>nanosecond</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="63"><PARAGRAPH>POSIX</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="180"><PARAGRAPH>Suspend for a number of seconds and 
nanoseconds or until a signal arrives.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Sometimes you do not want to suspend for any particular amount of time, but simply want to make the current process defer to other processes, so that any waiting processes receive a chance to run. You can achieve this in two ways. The IRIX unique function <FUNCTION>sginap()</FUNCTION> accepts an argument of 0, meaning to defer for the minimum amount of time. However, <FUNCTION>sched_yield()</FUNCTION> is a POSIX compliant function for this purpose.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Time Data Structures</TITLE><PARAGRAPH>The include files <INDEXTARGET ID="TIP_2d.ipcevnt22"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt22|timer:data structures --><FILENAME>time.h</FILENAME> and <FILENAME>sys/time.h</FILENAME> define several data types and data structures related to time. Some of these are used in POSIX time functions and others in BSD-based functions; and there are somewhat confusing similarities between them. Features of these structures are summarized in <XREF IDREF="74719" TYPE="TABLE">Table&nbsp;5-7</XREF>. </PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="5-7"><PREFIX>Table 5-7 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="74719">Time Data Structures and Usage</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="54"><PARAGRAPH>Data Type</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="54"><PARAGRAPH>Declared In</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="144"><PARAGRAPH>Contains</PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="136"><PARAGRAPH>Some Functions Using This Type</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>time_t</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="54"><PARAGRAPH><FILENAME>time.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="144"><PARAGRAPH>long int with time in seconds since 
00:00:00 UTC, January 1, 1970</PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="136"><PARAGRAPH><REFPAGE>time(2)</REFPAGE>, <REFPAGE>ctime(3C)</REFPAGE>, <REFPAGE>cftime(3C)</REFPAGE>, 
<REFPAGE>difftime(3C)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>timeval</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="54"><PARAGRAPH><FILENAME>sys/time.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="144"><PARAGRAPH>structure of <VARIABLE>time_t</VARIABLE> giving seconds 
and a long int giving microseconds</PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="136"><PARAGRAPH><REFPAGE>adjtime(2)</REFPAGE>, <REFPAGE>getitimer(2)</REFPAGE>, 
<REFPAGE>getrusage(3C)</REFPAGE>, 
<REFPAGE>gettimeofday(3C)</REFPAGE>, <REFPAGE>select(2)</REFPAGE>, 
<REFPAGE>utimes(3B)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>itimerval</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="54"><PARAGRAPH><FILENAME>sys/time.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="144"><PARAGRAPH>structure of two <VARIABLE>timeval</VARIABLE> fields for 
first interval and repeat interval</PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="136"><PARAGRAPH><REFPAGE>getitimer(2)</REFPAGE> and <REFPAGE>setitimer(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>timespec_t</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="54"><PARAGRAPH><FILENAME>time.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="144"><PARAGRAPH>structure of <VARIABLE>time_t</VARIABLE> giving seconds 
and a long int giving nanoseconds</PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="136"><PARAGRAPH><REFPAGE>clock_gettime(2)</REFPAGE>, <REFPAGE>nanosleep(2)</REFPAGE>, 
<REFPAGE>aio_suspend(3)</REFPAGE>, 
<REFPAGE>sigtimedwait(3C)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>itimerspec</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="54"><PARAGRAPH><FILENAME>time.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="144"><PARAGRAPH>structure of two <VARIABLE>timespec_t</VARIABLE> fields 
for first interval and repeat interval</PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="136"><PARAGRAPH><REFPAGE>timer_settime(3C)</REFPAGE>, 
<REFPAGE>timer_gettime(3C)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>tm</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="54"><PARAGRAPH><FILENAME>time.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="120" WIDTH="144"><PARAGRAPH>structure of int fields for seconds, 
minutes, hours, day, month, etc.</PARAGRAPH>
</CELL>
<CELL LEFT="270" WIDTH="136"><PARAGRAPH><REFPAGE>localtime(2)</REFPAGE>, <REFPAGE>gmtime(2)</REFPAGE>, 
<REFPAGE>strftime(3C)</REFPAGE>&space;</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Time Signal Latency</TITLE><PARAGRAPH>It takes time for the kernel to deliver the SIGALRM that notifies your program at the end of an interval. (The issue of signal latency in general is discussed under <INDEXTARGET ID="TIP_2d.ipcevnt23"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt23|timer:latencylatency of time signal --><XREF IDREF="48541" TYPE="TITLE">&ldquo;Signal Latency&rdquo;</XREF>.) The signal latency is less for SIGALRM than for other signals, since the kernel initiates a scheduling cycle immediately after the timer interrupt, without waiting for the end of a fixed time slice. When the receiving process or thread is running or ready to run, the latency is fairly short and consistent from one signal to the next. (Even so, it is not advisable to use a repeating itimer as the time base for a real-time program). Under less favorable conditions, signal latency can be variable and sometimes lengthy (tens of milliseconds) relative to a fast timer frequency.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>How Timers Are Managed</TITLE><PARAGRAPH>The IRIX kernel can be asked to implement itimers for many processes at once, each interval having a different length and starting at a different time. The kernel's method differs depending on the hardware architecture (this issue is discussed at length in the <INDEXTARGET ID="TIP_2d.ipcevnt24"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt24|timer:implementation --><REFPAGE>timers(5)</REFPAGE> reference page).</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Some obsolete Silicon Graphics systems have no hardware support for interval timers, so the kernel had to rely on frequent, periodic interrupts as a time base.</PARAGRAPH>
<PARAGRAPH>In those systems, the precision of timer interrupts was controlled by a kernel tuning variable, <INDEXTARGET ID="TIP_2d.ipcevnt25"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt25|timer:fasthz obsolete --><VARIABLE>fasthz</VARIABLE>, which determined the rate at which the kernel was interrupted to poll for an expired timer.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>In all current architectures, each CPU has a clock comparator that the kernel can program to cause an interrupt after a specific interval has elapsed.</PARAGRAPH>
<PARAGRAPH>In these systems, timer interrupts have sub-microsecond precision and do not impose overhead for timer-polling interrupts.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>In earlier versions of IRIX, in order to minimize the overhead of polling for elapsed timers, the kernel did not allow normal processes to ask for timer intervals with fine granularity (sub-millisecond precision). Only processes that executed under real-time scheduling priority could ask for precise timer intervals.</PARAGRAPH>
<PARAGRAPH>Starting with IRIX       6.2, any process can request a timer interval with any precision. If this support is misused, it is possible to cause performance problems. For example, a process can set up a repeating timer at an interval so short that one CPU is monopolized by setting and handling that timer.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>POSIX Timers</TITLE><PARAGRAPH>IRIX supports the time and timer facilities specified by IEEE standard 1003.1b-1993, commonly called POSIX timers. This timer interface is the most complete, robust, and portable, and is recommended for all new applications. The functions it includes for time measurement are summarized in <INDEXTARGET ID="TIP_2d.ipcevnt26"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt26|timer:POSIX facilities --><XREF IDREF="81143" TYPE="TABLE">Table&nbsp;5-8</XREF>.</PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="5-8"><PREFIX>Table 5-8 </PREFIX><XREFTARGET ID="81143"> <EMPHASIS>(continued)        </EMPHASIS>POSIX Time Management Functions</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="108"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="270"><PARAGRAPH>Purpose and Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>time(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="270"><PARAGRAPH>Return a <VARIABLE>time_t</VARIABLE> value containing the count of seconds elapsed since 
00:00:00 UTC, January 1, 1970.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>times(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="270"><PARAGRAPH>Return user and system execution time consumption for the calling 
process and its terminated child processes.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>clock_gettime(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="270"><PARAGRAPH>Return the instantaneous reading of one of two clocks: the system 
time (CLOCK_REALTIME), or the hardware cycle counter 
(CLOCK_SGI_CYCLE).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>clock_getres(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="270"><PARAGRAPH>Return the precision of the system time (CLOCK_REALTIME), the 
hardware cycle counter in this system (CLOCK_SGI_CYCLE) or 
the high-resolution timer base (CLOCK_SGI_FAST).</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The POSIX functions for interval timers are summarized in <XREF IDREF="63531" TYPE="TABLE">Table&nbsp;5-9</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="5-9"><PREFIX>Table 5-9 </PREFIX><XREFTARGET ID="63531"> <EMPHASIS>(continued)        </EMPHASIS>POSIX Time Management Functions</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="108"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="270"><PARAGRAPH>Purpose and Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>alarm(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="270"><PARAGRAPH>Cause a SIGALRM signal after a specified number of whole 
seconds.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>timer_create(3C)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="270"><PARAGRAPH>Create a POSIX timer and specify its time base 
(CLOCK_REALTIME or CLOCK_SGI_FAST) and the signal 
number it can generate.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>timer_delete(3C)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="270"><PARAGRAPH>Remove a timer created with <FUNCTION>timer_create()</FUNCTION>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>timer_settime(3C)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="270"><PARAGRAPH>Set expiration and reload times of a timer, or disarm it.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>timer_gettime(3C)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="270"><PARAGRAPH>Query the time remaining in a timer.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><REFPAGE>timer_getoverrun(3C)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="270"><PARAGRAPH>Query the number of overrun events generated by a timer.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<SECTION3 LBL="" HELPID = ""><TITLE>Getting Program Execution Time</TITLE><PARAGRAPH>The <FUNCTION>times()</FUNCTION> function returns counts of accumulated user-process and system execution time. These counts have a resolution of the system dispatching interval, 10 milliseconds.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Creating Timestamps</TITLE><PARAGRAPH>The <FUNCTION>time()</FUNCTION> function returns a timestamp with a resolution of 1 second. A timestamp with a resolution this coarse can be used only for infrequent events.</PARAGRAPH>
<PARAGRAPH>You can use the <FUNCTION>clock_gettime()</FUNCTION> function to sample the system time with a resolution of 0.01&nbsp;second, or you can use it to read the hardware cycle counter&mdash;a free-running binary counter with an update frequency near the machine clock rate. The <FUNCTION>clock_getres()</FUNCTION> function returns the resolution of either of these clocks.</PARAGRAPH>
<PARAGRAPH>The program in <XREF IDREF="40803" TYPE="TEXT">Example&nbsp;5-1</XREF> demonstrates the use of <FUNCTION>clock_gettime()</FUNCTION> and <FUNCTION>clock_getres()</FUNCTION>. The following is an example of the output of this program, <COMMAND>ptime</COMMAND>, as executed on an Indy workstation:</PARAGRAPH>
<CODE>
$ ptime
CLOCK_REALTIME value: sec 835660711, ns 465330000 [8.35661e+08 sec]
CLOCK_REALTIME units: sec 0, ns 10000000 [0.01 sec]
CLOCK_SGI_CYCLE value: sec 83, ns 449744360 [83.4497 sec]
CLOCK_SGI_CYCLE units: sec 0, ns 40 [4e-08 sec]
CLOCK_SGI_FAST units: sec 0, ns 1000000 [0.001 sec]
</CODE>
<PARAGRAPH>&nbsp;</PARAGRAPH>
<CODE><CAPTION LBL="5-1"><PREFIX>Example 5-1 </PREFIX><XREFTARGET ID="40803">Example of POSIX Time Functions</CAPTION>/*
||&nbsp;Program&nbsp;to&nbsp;exercise&nbsp;POSIX&nbsp;clock_gettime()&nbsp;and&nbsp;clock_getres()&nbsp;functions.
||
||&nbsp;&nbsp;ptime&nbsp;[-r&nbsp;-c&nbsp;-R&nbsp;-C -F]
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-r&nbsp;&nbsp;display&nbsp;CLOCK_REALTIME&nbsp;value
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-R&nbsp;&nbsp;display&nbsp;CLOCK_REALTIME&nbsp;resolution
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-c&nbsp;&nbsp;display&nbsp;CLOCK_SGI_CYCLE&nbsp;value
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-C&nbsp;&nbsp;display&nbsp;CLOCK_SGI_CYCLE&nbsp;resolution
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-F&nbsp;&nbsp;display&nbsp;CLOCK_SGI_FAST&nbsp;resolution&nbsp;(cannot&nbsp;get&nbsp;time&nbsp;from&nbsp;this)
||&nbsp;Default&nbsp;is&nbsp;display&nbsp;everything&nbsp;(-rRcC).
*/
#include&nbsp;&lt;time.h>
#include&nbsp;&lt;unistd.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;for&nbsp;getopt()&nbsp;*/
#include&nbsp;&lt;errno.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;errno&nbsp;and&nbsp;perror&nbsp;*/
#include&nbsp;&lt;stdio.h>
void&nbsp;showtime(const&nbsp;timespec_t&nbsp;tm,&nbsp;const&nbsp;char&nbsp;*caption)
{
&nbsp;&nbsp;&nbsp;&nbsp;printf("%s:&nbsp;sec&nbsp;%ld,&nbsp;ns&nbsp;%ld&nbsp;[%g&nbsp;sec]\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;caption,&nbsp;tm.tv_sec,&nbsp;tm.tv_nsec,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((double)tm.tv_sec)&nbsp;+&nbsp;((double)tm.tv_nsec&nbsp;/&nbsp;1e9));
}
main(int&nbsp;argc,&nbsp;char&nbsp;**argv)
{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;opta&nbsp;=&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;optr&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;optR&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;optc&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;optC&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;optF&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;timespec_t&nbsp;sample,&nbsp;res;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;c;
&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(&nbsp;-1&nbsp;!=&nbsp;(c&nbsp;=&nbsp;getopt(argc,argv,"arRcCF"))&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(c)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'a':&nbsp;opta=1;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'r':&nbsp;optr=1;&nbsp;opta=0;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'R':&nbsp;optR=1;&nbsp;opta=0;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'c':&nbsp;optc=1;&nbsp;opta=0;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'C':&nbsp;optC=1;&nbsp;opta=0;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'F':&nbsp;optF=1;&nbsp;opta=0;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;return&nbsp;-1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(opta&nbsp;||&nbsp;optr)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!clock_gettime(CLOCK_REALTIME,&amp;sample))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showtime(sample,"CLOCK_REALTIME&nbsp;value");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("clock_gettime(CLOCK_REALTIME)");
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(opta&nbsp;||&nbsp;optR)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!clock_getres(CLOCK_REALTIME,&amp;res))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showtime(res,"CLOCK_REALTIME&nbsp;units");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("clock_getres(CLOCK_REALTIME)");
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(opta&nbsp;||&nbsp;optc)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!clock_gettime(CLOCK_SGI_CYCLE,&amp;sample))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showtime(sample,"CLOCK_SGI_CYCLE&nbsp;value");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("clock_gettime(CLOCK_SGI_CYCLE)");
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(opta&nbsp;||&nbsp;optC)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!clock_getres(CLOCK_SGI_CYCLE,&amp;res))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showtime(res,"CLOCK_SGI_CYCLE&nbsp;units");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("clock_getres(CLOCK_SGI_CYCLE)");
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(opta&nbsp;||&nbsp;optF)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!clock_getres(CLOCK_SGI_FAST,&amp;res))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showtime(res,"CLOCK_SGI_FAST&nbsp;units");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("clock_getres(CLOCK_SGI_FAST)");
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</CODE>
<PARAGRAPH>The real-time clock (CLOCK_REALTIME) can shift backward or jump forward under the influence of adjustments to the system time by a time daemon. The Silicon Graphics hardware cycle counter always increases at a steady rate. However, the cycle counter has a limited precision that depends on the hardware. You can use the <FUNCTION>syssgi()</FUNCTION> system function to find out the precision of the cycle counter (see <REFPAGE>syssgi(2)</REFPAGE> and look for the SGI_CYCLECNTR_SIZE option).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using Interval Timers</TITLE><PARAGRAPH>You create an interval timer object by calling <FUNCTION>timer_create()</FUNCTION>. To this function you pass codes that specify the time base to use and the signal to send upon timer expiration. It returns an ID value to identify the timer to other functions.</PARAGRAPH>
<PARAGRAPH>The time base for a timer is either CLOCK_REALTIME or CLOCK_SGI_FAST (the latter is a nonportable request). Typically CLOCK_SGI_FAST has finer resolution, but you can verify that using the <FUNCTION>clock_getres()</FUNCTION> function, as shown in <XREF IDREF="40803" TYPE="TEXT">Example&nbsp;5-1</XREF>.</PARAGRAPH>
<PARAGRAPH>You also pass a <VARIABLE>sigevent_t</VARIABLE> object to <FUNCTION>timer_create()</FUNCTION>. In it you would normally set the following values: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><VARIABLE>sigev_notify</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>SIGEV_SIGNAL to have the timer generate a signal on 
expiration.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><VARIABLE>sigev_signo</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>The signal number you want sent, possibly selected from the 
POSIX real-time range, for example, SIGRTMIN+1.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><VARIABLE>sigev_value.sival_int</VARIABLE> &lbreak;<VARIABLE>sigev_value.sival_ptr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>An extra value to be passed to the signal-handling function or 
to <FUNCTION>sigwait()</FUNCTION> when the signal is delivered.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>You can pass a NULL instead of the address of a <VARIABLE>sigevent_t</VARIABLE>. In that case, the timer signals with a SIGALRM.</PARAGRAPH>
<PARAGRAPH>Initially, a timer is disarmed (inactive). You start a timer by calling <FUNCTION>timer_settime()</FUNCTION>. The principal argument to this function is an <VARIABLE>itimerspec_t</VARIABLE> object, which contains two times. One, <VARIABLE>it_value</VARIABLE>, specifies when the timer next expires. The other, <VARIABLE>it_interval</VARIABLE>, is the value to be loaded into the timer when it expires. You can call <FUNCTION>timer_settime()</FUNCTION> to accomplish any of three different operations:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>With <VARIABLE>it_value</VARIABLE> nonzero and <VARIABLE>it_interval</VARIABLE> zero, arm the timer and initiate a one-time interval.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>With <VARIABLE>it_value</VARIABLE> nonzero and <VARIABLE>it_interval</VARIABLE> nonzero, arm and initiate a repeating timer.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>With <VARIABLE>it_value</VARIABLE> zero, disarm the timer, preventing it from expiring (if it has not expired already).</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>You can also use <FUNCTION>timer_settime()</FUNCTION> to reprogram the intervals in a timer while it runs.</PARAGRAPH>
<PARAGRAPH>A timer can be programmed in terms of relative time (you pass an <VARIABLE>it_value</VARIABLE> that represents increments past the present time) or absolute time (you pass an <VARIABLE>it_value</VARIABLE> that represents actual future times when the timer should expire).</PARAGRAPH>
<PARAGRAPH>You can interrogate the time remaining in a timer by calling <FUNCTION>timer_gettime()</FUNCTION>. After a timer has expired&mdash;for example, in the signal handling function&mdash;you can call <FUNCTION>timer_getoverrun()</FUNCTION> to find out how many additional intervals it would have signalled, but could not signal because the first signal was pending.&space;</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>BSD Timers</TITLE><PARAGRAPH>IRIX supports the BSD UNIX feature of interval timers or &ldquo;itimers.&rdquo; <INDEXTARGET ID="TIP_2d.ipcevnt27"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt27|timer:BSD facilities --><XREF IDREF="41999" TYPE="TABLE">Table&nbsp;5-10</XREF> summarizes the functions you use to manage itimers. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="5-10"><PREFIX>Table 5-10 </PREFIX><XREFTARGET ID="41999"> <EMPHASIS>(continued)        </EMPHASIS>BSD Functions for Interval Timers</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="99"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="270"><PARAGRAPH>Purpose and Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>setitimer(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="270"><PARAGRAPH>Set the expiration and repeat interval of a timer.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>getitimer(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="270"><PARAGRAPH>Return the current value of a timer.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Each process has three itimers available to it, as summarized in <XREF IDREF="33360" TYPE="TABLE">Table&nbsp;5-11</XREF>.&nbsp;&nbsp;</PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="5-11"><PREFIX>Table 5-11 </PREFIX><XREFTARGET ID="33360">Types of itimer <INDEXTARGET ID="TIP_2d.ipcevnt28"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt28|signal:SIGALRM --><INDEXTARGET ID="TIP_2d.ipcevnt29"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt29|SIGALRM:from interval timer --></CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="99"><PARAGRAPH><XREFTARGET ID="99091">Kind of itimer</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="90"><PARAGRAPH>Interval Measured</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="90"><PARAGRAPH>Resolution</PARAGRAPH>
</CELL>
<CELL LEFT="295" WIDTH="90"><PARAGRAPH>Signal Sent</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>ITIMER_REAL</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="90"><PARAGRAPH>Elapsed clock time</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="90"><PARAGRAPH>1 millisecond or less</PARAGRAPH>
</CELL>
<CELL LEFT="295" WIDTH="90"><PARAGRAPH>SIGALRM</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>ITIMER_VIRTUAL</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="90"><PARAGRAPH>User time (process 
execution time)</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="90"><PARAGRAPH>1 second</PARAGRAPH>
</CELL>
<CELL LEFT="295" WIDTH="90"><PARAGRAPH>SIGVTALRM</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH>ITIMER_PROF</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="90"><PARAGRAPH>User+system time</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="90"><PARAGRAPH>1 second</PARAGRAPH>
</CELL>
<CELL LEFT="295" WIDTH="90"><PARAGRAPH>SIGPROF</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The ITIMER_VIRTUAL and ITIMER_PROF have a relatively coarse precision. Their intervals vary depending on when and how often the process is dispatched. The ITIMER_REAL timer is comparable to the POSIX time base CLOCK_SGI_FAST.</PARAGRAPH>
<PARAGRAPH>In order to use an itimer, you establish a signal handler for the appropriate signal as shown in <XREF IDREF="33360" TYPE="TABLE">Table&nbsp;5-11</XREF>, then issue the <FUNCTION>setitimer()</FUNCTION> call. The principal argument to this function is a <COMMAND>struct itimerval</COMMAND>, an object containing two incremental time values. The <VARIABLE>it_value</VARIABLE> field specifies the time until the timer should expire. The <VARIABLE>it_interval</VARIABLE> field, when nonzero, gives the time that should be loaded into the timer after it expires.</PARAGRAPH>
<TIP><PREFIX>Tip</PREFIX>One excellent reason not to mix BSD and POSIX timer support in the same program is that the POSIX <VARIABLE>struct itimerspec</VARIABLE>, used to set a POSIX timer, and the BSD <VARIABLE>struct itermval</VARIABLE>, used to set a BSD itimer, have fields with identical names, but these fields have different data types and precisions.</TIP>
<PARAGRAPH>You can use <FUNCTION>setitimer()</FUNCTION> for any of three operations:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>With <VARIABLE>it_value</VARIABLE> nonzero and <VARIABLE>it_interval</VARIABLE> zero, initiate a one-time interval.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>With <VARIABLE>it_value</VARIABLE> nonzero and <VARIABLE>it_interval</VARIABLE> nonzero, initiate a repeating timer.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>With <VARIABLE>it_value</VARIABLE> zero, disarm the timer, preventing it from expiring (if it has not expired already).&space;</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Hardware Cycle Counter</TITLE><PARAGRAPH>All current Silicon Graphics systems have a hardware &ldquo;cycle counter,&rdquo; a free-running binary counter that is incremented at a high, regular frequency. You can use the cycle counter as a high-precision timestamp.<INDEXTARGET ID="TIP_2d.ipcevnt30"><!-- POSTPROCESSDATA: TIP_2d.ipcevnt30|timer:hardware cycle countercycle counterhardware timer --></PARAGRAPH>
<PARAGRAPH>The precision of the cycle counter is different in different system types; for example, it is a 24-bit counter in the Indy workstation, but a 64-bit counter in CHALLENGE and Onyx systems. The rate at which the timer increments is its resolution, and this also varies with the hardware type.</PARAGRAPH>
<PARAGRAPH>The cycle counter is an addressable hardware device that you can map into the address space of your process (see <XREF IDREF="50575" TYPE="TITLE">&ldquo;Mapping Physical Memory&rdquo;</XREF>). When this is done you can sample the cycle counter as if it were a program variable. The code to do this mapping is discussed in the <REFPAGE>syssgi(2)</REFPAGE> reference page under SGI_QUERY_CYCLECNTR.</PARAGRAPH>
<PARAGRAPH>However, the use of the hardware cycle counter has been integrated into the POSIX timer support beginning in IRIX 6.2, and this makes access to the cycle counter much simpler than before:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>In order to sample the cycle counter, call <FUNCTION>clock_gettime()</FUNCTION> passing CLOCK_SGI_CYCLE.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>In order to find out the resolution (update frequency) of the cycle counter, call <FUNCTION>clock_getres()</FUNCTION> passing CLOCK_SGI_CYCLE.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>In order to find out the precision of the cycle counter, call <FUNCTION>syssgi()</FUNCTION> passing SGI_CYCLECNTR_SIZE. The returned value is the number of bits in the counter.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The first two operations are illustrated in <XREF IDREF="40803" TYPE="TEXT">Example&nbsp;5-1</XREF>.&space;</PARAGRAPH>
</SECTION2>
</SECTION1>
</CHAPTER>
