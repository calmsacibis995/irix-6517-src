<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="13"><TITLE><XREFTARGET ID="77267"><XREFTARGET ID="89404">Thread-Level Parallelism</TITLE><PARAGRAPH>IRIX 6.5 conforms to ISO/IEC 9945-1:1996 and UNIX 98; that is, it supports POSIX threads, or pthreads.<INDEXTARGET ID="TIP_4d.mpcthrd1"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd1|pthreads --><INDEXTARGET ID="TIP_4d.mpcthrd2"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd2|parallel computation:thread-level --></PARAGRAPH>
<PARAGRAPH>This chapter contains the following main topics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="42332" TYPE="TITLE">&ldquo;Overview of POSIX Threads&rdquo;</XREF> summarizes the similarities and differences of pthreads and processes.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="58652" TYPE="TITLE">&ldquo;Compiling and Debugging a Pthread Application&rdquo;</XREF> covers compiling and debugging tools.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="39919" TYPE="TITLE">&ldquo;Creating Pthreads&rdquo;</XREF> covers the process of creating a pthread with the desired attributes.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="24508" TYPE="TITLE">&ldquo;Executing and Terminating Pthreads&rdquo;</XREF> discusses how threads initialize themselves and how you synchronize on thread termination.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="24978" TYPE="TITLE">&ldquo;Using Thread-Unique Data&rdquo;</XREF> tells how to define variables that have a unique value in each thread.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="51680" TYPE="TITLE">&ldquo;Pthreads and Signals&rdquo;</XREF> discusses the pthread-specific details of signal handling (see <XREF IDREF="45686" TYPE="TITLE">&ldquo;Signals&rdquo;</XREF> for the general information).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="23231" TYPE="TITLE">&ldquo;Scheduling Pthreads&rdquo;</XREF> covers scheduling priorities and policies.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="77545" TYPE="TITLE">&ldquo;Synchronizing Pthreads&rdquo;</XREF> details the use of mutexes and condition variables.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="42332">Overview of POSIX Threads</TITLE><PARAGRAPH>A <INDEXTARGET ID="TIP_4d.mpcthrd3"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd3|process:compared to pthreadpthreads:compare to process --><ITALICS>thread</ITALICS> is an independent execution state; that is, a set of machine registers, a call stack, and the ability to execute code. When IRIX creates a process, it also creates one thread to execute that process. However, you can write a program that creates many more threads to execute in the same address space. For a comparison of pthreads to processes, see <XREF IDREF="97562" TYPE="TITLE">&ldquo;Thread-Level Parallelism&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>POSIX threads are similar in some ways to IRIX lightweight processes made with <FUNCTION>sproc()</FUNCTION>. You use pthreads in preference to lightweight processes for two main reasons: portability and performance. A program based on pthreads is normally easier to port from another vendor's equipment than a program that depends on a unique facility such as <FUNCTION>sproc()</FUNCTION>. <XREF IDREF="79859" TYPE="TABLE">Table&nbsp;13-1</XREF> summarizes some of the differences between pthreads and lightweight processes. </PARAGRAPH>
<TABLE COLUMNS="4"><CAPTION LBL="13-1"><PREFIX>Table 13-1 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="79859">Comparison of Pthreads and Processes</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="90"><PARAGRAPH>Attribute</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="99"><PARAGRAPH>POSIX Threads</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="99"><PARAGRAPH>Lightweight Processes</PARAGRAPH>
</CELL>
<CELL LEFT="305" WIDTH="99"><PARAGRAPH>UNIX Processes</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>Source portability</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="99"><PARAGRAPH>Standard interface, 
portable between 
vendors</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="99"><PARAGRAPH><FUNCTION>sproc()</FUNCTION> is unique to 
IRIX</PARAGRAPH>
</CELL>
<CELL LEFT="305" WIDTH="99"><PARAGRAPH><FUNCTION>fork()</FUNCTION> is a UNIX 
standard</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>Creation overhead</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="99"><PARAGRAPH>Relatively small</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="99"><PARAGRAPH>Moderately large</PARAGRAPH>
</CELL>
<CELL LEFT="305" WIDTH="99"><PARAGRAPH>Quite large</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>Block/Unblock 
(Dispatch) Overhead</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="99"><PARAGRAPH>Few microseconds</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="99"><PARAGRAPH>Many microseconds</PARAGRAPH>
</CELL>
<CELL LEFT="305" WIDTH="99"><PARAGRAPH>Many microseconds</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>Address space</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="99"><PARAGRAPH>Shared</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="99"><PARAGRAPH>Shared, or copy on 
write, or separate</PARAGRAPH>
</CELL>
<CELL LEFT="305" WIDTH="99"><PARAGRAPH>Separate</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>Memory-mapped 
files and arenas</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="99"><PARAGRAPH>Shared</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="99"><PARAGRAPH>Shared, or copy on 
write, or separate</PARAGRAPH>
</CELL>
<CELL LEFT="305" WIDTH="99"><PARAGRAPH>Explicit sharing only</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>Mutual exclusion 
objects</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="99"><PARAGRAPH>Mutexes, condition 
variables, and 
read-write locks; 
POSIX semaphores; 
IRIX semaphores and 
locks</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="99"><PARAGRAPH>IRIX semaphores and 
locks; POSIX 
semaphores</PARAGRAPH>
</CELL>
<CELL LEFT="305" WIDTH="99"><PARAGRAPH>IRIX semaphores and 
locks; POSIX 
semaphores</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>Files, pipes, and I/O 
streams</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="99"><PARAGRAPH>Shared single-process 
file table</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="99"><PARAGRAPH>Shared or separate file 
table</PARAGRAPH>
</CELL>
<CELL LEFT="305" WIDTH="99"><PARAGRAPH>Separate file table</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>Signal masks and 
signal handlers</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="99"><PARAGRAPH>Each thread has a mask 
but handlers are shared</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="99"><PARAGRAPH>Each process has a 
mask and its own 
handlers</PARAGRAPH>
</CELL>
<CELL LEFT="305" WIDTH="99"><PARAGRAPH>Each process has a 
mask and its own 
handlers</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>Resource limits</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="99"><PARAGRAPH>Single-process limits</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="99"><PARAGRAPH>Single-process limits</PARAGRAPH>
</CELL>
<CELL LEFT="305" WIDTH="99"><PARAGRAPH>Limits apply to each 
process separately</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>Process ID</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="99"><PARAGRAPH>One PID applies to all 
threads</PARAGRAPH>
</CELL>
<CELL LEFT="200" WIDTH="99"><PARAGRAPH>PID per process plus 
share-group PID</PARAGRAPH>
</CELL>
<CELL LEFT="305" WIDTH="99"><PARAGRAPH>PID per process</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>It takes relatively little time to create or destroy a pthread, as compared to creating a lightweight process. Threads share all resources and attributes of a single process (except for the signal mask; see <XREF IDREF="51680" TYPE="TITLE">&ldquo;Pthreads and Signals&rdquo;</XREF>). If you want each executing entity to have its own set of file descriptors, or if you want to make sure that one entity cannot modify data shared with another entity, you must use lightweight processes or normal processes.</PARAGRAPH>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="58652">Compiling and Debugging a Pthread Application</TITLE><PARAGRAPH>A pthread application is a C or a C++ program that uses some of the POSIX pthreads functions. In order to use these functions, and in order to access the thread-safe versions of the standard I/O macros, you must include the proper header files and link with the pthreads library. You can debug and analyze the compiled program using some of the tools available for IRIX.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Compiling Pthread Source</TITLE><PARAGRAPH>The header files related to pthreads functions are summarized in <INDEXTARGET ID="TIP_4d.mpcthrd4"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd4|pthreads:compiling --><XREF IDREF="71288" TYPE="TABLE">Table&nbsp;13-2</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="13-2"><PREFIX>Table 13-2 </PREFIX><XREFTARGET ID="71288"> <EMPHASIS>(continued)        </EMPHASIS>Header Files Related to Pthreads</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="54"><PARAGRAPH>Header</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Primary Contents</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><FILENAME>errno.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>System error codes returned by pthreads functions.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><FILENAME>pthread.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Pthread functions and special pthread data types.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><FILENAME>sched.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>The <VARIABLE>sched_param</VARIABLE> structure and related functions used in setting thread priorities.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><FILENAME>stdio.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Standard stream I/O macros, including thread-safe versions.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><FILENAME>sys/types.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>IRIX and standard data types.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><FILENAME>limits.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Some POSIX constants such as _POSIX_THREAD_THREADS_MAX. </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><FILENAME>unistd.h</FILENAME>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Constants used when calling <FUNCTION>sysconf()</FUNCTION> to query POSIX limits (see the <REFPAGE>sysconf(3)</REFPAGE> 
reference page).</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>It is recommended that the thread-safe options be enabled at compile time using the feature test macro, _POSIX_C_SOURCE (see <REFPAGE>intro</REFPAGE>(3) for details). For example, to compile these options, use this command:</PARAGRAPH>
<CODE>
cc -D_POSIX_C_SOURCE=199506L app.c -l<VARIABLE>lib0</VARIABLE> -l<VARIABLE>lib1</VARIABLE> ... -lpthread
</CODE>
<PARAGRAPH>You can use pthreads with a program compiled to any of the supported execution models: <COMMAND>-32</COMMAND> for compatibility with older systems, <COMMAND>-n32</COMMAND> for 64-bit data and 32-bit addressing, or <COMMAND>-64</COMMAND> for 64-bit addressing.</PARAGRAPH>
<PARAGRAPH>The pthreads functions are defined in the library <FILENAME>libpthread.so</FILENAME>. Link with this library using the <COMMAND>-lpthread</COMMAND> compiler option, which should be the last library on the command line. The compiler chooses the correct library based on the execution model: <FILENAME>/usr/lib/libpthread.so</FILENAME>, <FILENAME>/usr/lib32/libpthread.so</FILENAME>, and <FILENAME>/usr/lib64/libpthread.so</FILENAME>.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>A pthread program is a program that links with <FILENAME>libpthread</FILENAME>. Do not link with <FILENAME>libpthread</FILENAME> unless you intend to use the pthread interface, because <FILENAME>libpthread</FILENAME> replaces many standard library functions.</NOTE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Debugging Pthread Programs</TITLE><PARAGRAPH>The <INDEXTARGET ID="TIP_4d.mpcthrd5"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd5|pthreads:debugging --><COMMAND>dbx</COMMAND> debugger and Workshop Debugger have been extended for use with threaded programs. See the <REFPAGE>dbx</REFPAGE>(1M) reference page and the documentation for Workshop Debugger for more details.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="39919">Creating Pthreads</TITLE><PARAGRAPH>You create a pthread by calling <INDEXTARGET ID="TIP_4d.mpcthrd6"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd6|pthreads:creating --><FUNCTION>pthread_create()</FUNCTION>. One argument to this function is a thread attribute object of type <VARIABLE>pthread_attr_t</VARIABLE>. You pass a null address to request a thread having default attributes, or you prepare an attribute object to reflect the features you want the thread to have. You can use one attribute object to create many pthreads.</PARAGRAPH>
<PARAGRAPH>Functions related to attribute objects and pthread creation are summarized in <XREF IDREF="24533" TYPE="TABLE">Table&nbsp;13-3</XREF> and described in the following sections:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="55135" TYPE="TITLE">&ldquo;Initial Detach State&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="56878" TYPE="TITLE">&ldquo;Initial Scheduling Scope, Priority, and Policy&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="63932" TYPE="TITLE">&ldquo;Thread Stack Allocation&rdquo;</XREF></PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="13-3"><PREFIX>Table 13-3 </PREFIX><XREFTARGET ID="24533"> <EMPHASIS>(continued)        </EMPHASIS>Functions for Creating Pthreads</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="151"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="237"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="151"><PARAGRAPH><REFPAGE>pthread_attr_init(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="237"><PARAGRAPH>Initialize a <VARIABLE>pthread_attr_t</VARIABLE> object to default settings.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="151"><PARAGRAPH><REFPAGE>pthread_attr_setdetachstate(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="237"><PARAGRAPH>Set the automatic-detach attribute.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="151"><PARAGRAPH><REFPAGE>pthread_attr_setinheritsched(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="237"><PARAGRAPH>Specify whether scheduling attributes come from the 
attribute object or are inherited from the creating thread.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="151"><PARAGRAPH><REFPAGE>pthread_attr_setschedparam(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="237"><PARAGRAPH>Set the starting thread priority.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="151"><PARAGRAPH><REFPAGE>pthread_attr_setschedpolicy(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="237"><PARAGRAPH>Set the scheduling policy.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="151"><PARAGRAPH><REFPAGE>pthread_attr_setscope(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="237"><PARAGRAPH>Set the scheduling scope.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="151"><PARAGRAPH><REFPAGE>pthread_attr_setstacksize(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="237"><PARAGRAPH>Set the stack size attribute.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="151"><PARAGRAPH><REFPAGE>pthread_attr_setguardsize(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="237"><PARAGRAPH>Set the stack guard size attribute.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="151"><PARAGRAPH><REFPAGE>pthread_attr_setstackaddr(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="237"><PARAGRAPH>Set the address of memory to use as a stack (when you 
allocate the stack for the new thread). </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="151"><PARAGRAPH><REFPAGE>pthread_attr_destroy(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="237"><PARAGRAPH>Uninitialize a <VARIABLE>pthread_attr_t</VARIABLE> object.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="151"><PARAGRAPH><REFPAGE>pthread_create(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="237"><PARAGRAPH>Create a new thread based on an attribute object, or with 
default attributes.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="55135">Initial Detach State</TITLE><PARAGRAPH>Detaching means that the pthreads library frees up resources held by the thread after it terminates (see <INDEXTARGET ID="TIP_4d.mpcthrd7"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd7|pthreads:detach --><XREF IDREF="69606" TYPE="TITLE">&ldquo;Joining and Detaching&rdquo;</XREF>). There are three ways to detach a thread:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>automatically when the thread terminates</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>explicitly by calling <FUNCTION>pthread_join()</FUNCTION></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>explicitly by calling <FUNCTION>pthread_detach()</FUNCTION></PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>You can use <FUNCTION>pthread_attr_setdetachstate()</FUNCTION> to specify that a thread should be detached automatically when it terminates. Do this when you know that the thread will not be joined or detached by an explicit function call. </PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="56878">Initial Scheduling Scope, Priority, and Policy </TITLE><PARAGRAPH>You can specify an initial thread scheduling scope by calling <FUNCTION>pthread_attr_setscope()</FUNCTION> and passing one of the scope constants (PTHREAD_SCOPE_SYSTEM or PTHREAD_SCOPE_PROCESS) in the <VARIABLE>pthread_attr_t</VARIABLE> object. By default, process scope is selected and scheduling is performed by the thread runtime, but thread scheduling by the kernel is provided with the system scope attribute. System scope threads run at real-time policy and priority and may be created only by privileged users.</PARAGRAPH>
<PARAGRAPH>You can specify an initial thread priority in a <VARIABLE>struct</VARIABLE>&space;<VARIABLE>sched_param</VARIABLE> object in memory (the structure is declared in <FILENAME>sched.h</FILENAME>). Set the desired priority in the <VARIABLE>sched_priority</VARIABLE> field. Pass the structure to <FUNCTION>pthread_attr_setschedparam()</FUNCTION>. </PARAGRAPH>
<PARAGRAPH>You can specify an initial scheduling policy by calling <FUNCTION>pthread_attr_setschedpolicy()</FUNCTION>, passing one of the policy constants SCHED_FIFO or SCHED_RR. </PARAGRAPH>
<PARAGRAPH>The <FUNCTION>pthread_attr_setinheritsched()</FUNCTION> function is used to specify, in the attribute object, whether a new thread's scheduling policy and priority should be taken from the attribute object, or whether they should be inherited from the thread that creates the new thread. When you set an attribute object for inheritance, the scheduling policy and priority in the attribute object are ignored.</PARAGRAPH>
<PARAGRAPH>Scheduling scope, priorities, and policies are described in <INDEXTARGET ID="TIP_4d.mpcthrd8"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd8|pthreads:scheduling --><XREF IDREF="23231" TYPE="TITLE">&ldquo;Scheduling Pthreads&rdquo;</XREF>. </PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="63932">Thread Stack Allocation</TITLE><PARAGRAPH>Each pthread has an execution stack area in memory. By default, <INDEXTARGET ID="TIP_4d.mpcthrd9"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd9|pthreads:stack allocation --><FUNCTION>pthread_create()</FUNCTION> allocates stack space from dynamic memory, and automatically releases it when the thread terminates.</PARAGRAPH>
<PARAGRAPH>You use <FUNCTION>pthread_attr_setstacksize()</FUNCTION> to specify the size of this stack area. You cannot specify a stack size less than a minimum. A pthread process can find the minimum by calling <FUNCTION>sysconf()</FUNCTION> with _SC_THREAD_STACK_MIN (see the <REFPAGE>sysconf(3C)</REFPAGE> reference page).</PARAGRAPH>
<PARAGRAPH>Threads may overrun their stack area. By default, a thread's stack is created with guard protection, and extra memory is allocated at the overflow end of the stack as a buffer. If an application overflows into this buffer, an exception results (a SIGSEGV signal is delivered to the thread).</PARAGRAPH>
<PARAGRAPH>The <VARIABLE>guardsize</VARIABLE> attribute controls the size of the guard area for the created thread's stack and protects against overflow of the stack pointer. The <VARIABLE>guardsize</VARIABLE> attribute is set using <FUNCTION>pthread_attr_setguardsize()</FUNCTION>. </PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>Because thread stack space is taken from dynamic memory, the allocation is charged against the process virtual memory limit, not the process stack size limit as you might expect.</NOTE>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="24508">Executing and Terminating Pthreads</TITLE><PARAGRAPH>The functions for managing the progress of a thread are summarized in <XREF IDREF="76434" TYPE="TABLE">Table&nbsp;13-4</XREF> and described in the following sections:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="39938" TYPE="TITLE">&ldquo;Getting the Thread ID&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="40385" TYPE="TITLE">&ldquo;Initializing Static Data&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="16237" TYPE="TITLE">&ldquo;Setting Event Handlers&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="13295" TYPE="TITLE">&ldquo;Terminating a Thread&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="69606" TYPE="TITLE">&ldquo;Joining and Detaching&rdquo;</XREF></PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="13-4"><PREFIX>Table 13-4 </PREFIX>&space;<EMPHASIS>(continued)        </EMPHASIS><XREFTARGET ID="76434">Functions for Managing Thread Execution</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="135"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>pthread_atfork(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Register functions to handle the event of a <FUNCTION>fork()</FUNCTION>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>pthread_cancel(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Request cancellation of a specified thread.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>pthread_cleanup_push(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Register function to handle the event of thread termination.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>pthread_cleanup_pop(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Unregister and optionally call termination handler.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>pthread_detach(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Detach a terminated thread.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>pthread_exit(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Explicitly terminate the calling thread.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>pthread_join(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Wait for a thread to terminate and receive its return value.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>pthread_once(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Execute initialization function once only.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>pthread_self(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Return the calling thread's ID.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>pthread_equal(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Compare two thread IDs for equality.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>pthread_setcancelstate(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Permit or block cancellation of the calling thread.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>pthread_setcanceltype(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Specify deferred or asynchronous cancellation.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>pthread_testcancel(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Permit cancellation to take place, if it is pending.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="39938">Getting the Thread ID</TITLE><PARAGRAPH>Call <INDEXTARGET ID="TIP_4d.mpcthrd10"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd10|pthreads:thread ID --><FUNCTION>pthread_self()</FUNCTION> to get the thread ID of the calling thread. A thread can use this thread ID when changing its own scheduling priority, for example (see <XREF IDREF="23231" TYPE="TITLE">&ldquo;Scheduling Pthreads&rdquo;</XREF>).</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="40385">Initializing Static Data</TITLE><PARAGRAPH>Your program may use static data that should be initialized exactly once. The code can be entered by multiple threads, and might be entered concurrently. How can you ensure that only one thread will perform the initialization?<INDEXTARGET ID="TIP_4d.mpcthrd11"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd11|pthreads:static initializer --></PARAGRAPH>
<PARAGRAPH>One answer is to create a variable of type <VARIABLE>pthread_once_t</VARIABLE>, statically initialized to the value PTHREAD_ONCE_INIT. Call <FUNCTION>pthread_once(),</FUNCTION> passing the addresses of the variable and of an initialization function. The pthreads library ensures that the initialization function is called only once, and that any other threads calling <FUNCTION>pthread_once()</FUNCTION> for this variable wait until the first thread completes the initialization function. See <XREF IDREF="81868" TYPE="TEXT">Example&nbsp;13-1</XREF>.</PARAGRAPH>
<CODE><CAPTION LBL="13-1"><PREFIX>Example 13-1 </PREFIX><XREFTARGET ID="81868">One-Time Initialization</CAPTION>pthread_once_t first_time_flag = PTHREAD_ONCE_INIT;
elaborate_struct_t uninitialized; /* thing to initialize */
void elaborate_initializer(void); /* function to do it */
int subroutine(...)
{
&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;pthread_once(&amp;first_time_flag, elaborate_initializer);
&nbsp;&nbsp;&nbsp;...
}
</CODE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="16237">Setting Event Handlers</TITLE><PARAGRAPH>A thread can establish functions that are called when it terminates and when the process forks.<INDEXTARGET ID="TIP_4d.mpcthrd12"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd12|pthreads:termination eventpthreads:fork event --></PARAGRAPH>
<PARAGRAPH>Call <FUNCTION>pthread_cleanup_push()</FUNCTION> to register a function that is to be called in the event that the current thread terminates, either by exiting or by cancellation. Call <FUNCTION>pthread_cleanup_pop()</FUNCTION> to retract this registration and, optionally, to call the handler. These functions are often used in library code, with the push operation done on entry to the library and the pop done upon exit from the library. The push and pop operations are in fact implemented partly as macro code. For this reason, calls to them must be strictly balanced&mdash;a pop for each push&mdash;and each push/pop pair must appear in a single C lexical scope. A nonstructured jump such as a longjmp (see the <REFPAGE>setjmp(3)</REFPAGE> reference page) or goto can cause unexpected results.</PARAGRAPH>
<PARAGRAPH>Call <FUNCTION>pthread_atfork()</FUNCTION> to register three handlers related to a UNIX <FUNCTION>fork()</FUNCTION> call. The first handler executes just before the <FUNCTION>fork()</FUNCTION> takes place; the second executes just after the <FUNCTION>fork()</FUNCTION> in the parent process; the third executes just after the <FUNCTION>fork()</FUNCTION> in the child process. </PARAGRAPH>
<PARAGRAPH>The <FUNCTION>fork()</FUNCTION> operation creates a new process with a copy of the calling process's address space, including any locked mutexes or semaphores. Typically, the new process immediately calls <FUNCTION>exec()</FUNCTION> to replace the address space with a new program. When this is the case, there is no need for <FUNCTION>pthread_atfork()</FUNCTION> (see the <REFPAGE>exec(2)</REFPAGE> and <REFPAGE>fork(2)</REFPAGE> reference pages). However, if the new process continues to execute with the inherited address space, including perhaps calls to library code that uses pthreads, it may be necessary for the library code to reinitialize data in the address space of the child process. You can do this in the fork event handlers.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="13295">Terminating a Thread</TITLE><PARAGRAPH>A thread begins execution in the function that is named in the <INDEXTARGET ID="TIP_4d.mpcthrd13"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd13|pthreads:terminationpthreads:cancel --><FUNCTION>pthread_create()</FUNCTION> call. When it returns from that function, the thread terminates. A thread can terminate earlier by calling <FUNCTION>pthread_exit()</FUNCTION>. In either case, the thread returns a value of type <VARIABLE>void*</VARIABLE>.</PARAGRAPH>
<PARAGRAPH>One thread can request early termination of another by calling <FUNCTION>pthread_cancel()</FUNCTION>, passing the thread ID of the target thread. A thread can protect itself against cancellation using two built-in switches:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The <FUNCTION>pthread_setcancelstate()</FUNCTION> function lets you postpone cancellation indefinitely (PTHREAD_CANCEL_DISABLE) or permit cancellation (PTHREAD_CANCEL_ENABLE).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The <FUNCTION>pthread_setcanceltype()</FUNCTION> function lets you decide when cancellation will take place, if it is allowed at all. Cancellation can happen whenever it is requested (PTHREAD_CANCEL_ASYNCHRONOUS) or only at defined points (PTHREAD_CANCEL_DEFERRED).</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>When you prevent cancellation by setting PTHREAD_CANCEL_DISABLE, a cancellation request is blocked but remains pending until the thread terminates or changes its cancellation state.</PARAGRAPH>
<PARAGRAPH>The initial cancellation state of a thread is PTHREAD_CANCEL_ENABLE and the type is PTHREAD_CANCEL_DEFERRED. In this state, a cancellation request is blocked until the thread calls a function that is a defined cancellation point. The functions that are cancellation points are listed in the <REFPAGE>pthread_setcanceltype(3P)</REFPAGE> reference page. A thread can explicitly permit cancellation by calling <FUNCTION>pthread_testcancel()</FUNCTION>.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="69606">Joining and Detaching</TITLE><PARAGRAPH>Sometimes you do not care when threads terminate&mdash;your program starts a set of threads, and they continue until the entire program terminates. <INDEXTARGET ID="TIP_4d.mpcthrd14"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd14|pthreads:detach --></PARAGRAPH>
<PARAGRAPH>In other cases, threads are created and terminated as the program runs. One thread can wait for another to terminated by calling <FUNCTION>pthread_join()</FUNCTION>, specifying the thread ID. The function does not return until the specified thread terminates. The value the specified thread passed to <FUNCTION>pthread_exit()</FUNCTION> is returned. At this time, your program can release any resources that you associate with the thread, for example, stack space (see <XREF IDREF="63932" TYPE="TITLE">&ldquo;Thread Stack Allocation&rdquo;</XREF>).</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>pthread_join()</FUNCTION> function also detaches the terminated thread. If your program does not use <FUNCTION>pthread_join()</FUNCTION>, you must arrange for terminated threads to be detached in some other way. One way is by specifying automatic detachment when the threads are created (see <XREF IDREF="55135" TYPE="TITLE">&ldquo;Initial Detach State&rdquo;</XREF>). Another is to call <FUNCTION>pthread_detach()</FUNCTION> at any time after creating the thread, including after it has terminated.</PARAGRAPH>
<PARAGRAPH>If your program creates threads and lets them terminate, but does not detach them, resources will be used up and eventually an error will occur when trying to create a thread.&space;</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="24978">Using Thread-Unique Data</TITLE><PARAGRAPH>In some designs, especially modules of library code, you need to store data that is both<INDEXTARGET ID="TIP_4d.mpcthrd15"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd15|pthreads:thread-unique data --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>unique to the calling thread</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>persistent from one function call to another</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Normally, the only data that is unique to a thread is the contents of its local variables on the stack, and these do not persist between calls. However, the pthreads library provides a way to create persistent, thread-unique data. The functions for this are summarized in <XREF IDREF="93349" TYPE="TABLE">Table&nbsp;13-5</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="13-5"><PREFIX>Table 13-5 </PREFIX><XREFTARGET ID="93349">Functions for Thread-Unique Data</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="135"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>pthread_key_create(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Create a key.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>pthread_key_delete(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Delete a key.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>pthread_getspecific(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Retrieve this thread's value for a key.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>pthread_setspecific(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Set this thread's value for a key.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Your program calls <FUNCTION>pthread_key_create()</FUNCTION> to define a new storage <ITALICS>key</ITALICS>. Once created, a key may be used by all threads to identify a unique key <VARIABLE>value</VARIABLE>. </PARAGRAPH>
<PARAGRAPH>Any thread can use <FUNCTION>pthread_getspecific()</FUNCTION> to retrieve that thread's unique value stored under a key. A thread can fetch only its own value, which is the value stored by this same thread using <FUNCTION>pthread_setspecific()</FUNCTION>. The initial stored value is NULL.</PARAGRAPH>
<PARAGRAPH>When you create a key, you can specify a destructor function that is called automatically when a thread terminates. The destructor is called while the key is valid and the key value for the terminating thread is not NULL. The destructor receives the thread's key value as its argument.</PARAGRAPH>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="51680">Pthreads and Signals</TITLE><PARAGRAPH>For a general overview of signal concepts and numbers, see <XREF IDREF="45686" TYPE="TITLE">&ldquo;Signals&rdquo;</XREF> and the <REFPAGE>signal(5)</REFPAGE> reference page. IRIX supports three different signal facilities: BSD signals, SVR4 signals, and POSIX signals. When you are writing a pthreads program, you should use only the POSIX signal facilities (see <XREF IDREF="58175" TYPE="TITLE">&ldquo;POSIX Signal Facility&rdquo;</XREF>). </PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="59366">Setting Signal Masks</TITLE><PARAGRAPH>Each thread has a signal mask that specifies the signals it is willing to receive (see <INDEXTARGET ID="TIP_4d.mpcthrd16"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd16|pthreads:signal masks --><INDEXTARGET ID="TIP_4d.mpcthrd17"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd17|signal:mask in pthread --><XREF IDREF="97454" TYPE="TITLE">&ldquo;Signal Blocking and Signal Masks&rdquo;</XREF>). In a program that is linked with the pthreads library, this should be changed using <FUNCTION>pthread_sigmask()</FUNCTION>. Each thread inherits the signal mask of the thread that calls <FUNCTION>pthread_create()</FUNCTION>. Typically you set an initial mask in the first thread, so that it can be inherited by all other threads.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>In IRIX, you can use <FUNCTION>sigprocmask()</FUNCTION> instead of<FUNCTION>&space;pthread_sigmask()</FUNCTION>, but it may not be portable to other systems.</NOTE>
<PARAGRAPH>When a signal is directed to a specific thread that is blocking the signal, the signal remains pending on the thread until that thread unblocks it. When a signal is directed to a process, it is delivered to the first thread that is not blocking that signal. If all threads block that signal, the signal remains pending on the process until some thread unblocks it or the process terminates.</PARAGRAPH>
<PARAGRAPH>A thread can find out which signals are pending by calling <FUNCTION>sigpending()</FUNCTION>. This function returns a mask showing the set of signals pending on the process as a whole or for the calling thread; that is, the signals that could be delivered to the calling thread if they were not blocked.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="68192">Setting Signal Actions</TITLE><PARAGRAPH>When a signal is delivered, some action is taken. You specify what that action should be using the <INDEXTARGET ID="TIP_4d.mpcthrd18"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd18|signal:handling in pthread --><INDEXTARGET ID="TIP_4d.mpcthrd19"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd19|pthreads:signal action in --><FUNCTION>sigaction()</FUNCTION> function. These actions are set on a process-wide basis, <ITALICS>not</ITALICS> individually for each thread. Although each thread has a private signal mask, signal actions are shared with all threads in the process. See <XREF IDREF="79800" TYPE="TITLE">&ldquo;Signal Handling Policies&rdquo;</XREF> for details.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Receiving Signals Synchronously</TITLE><PARAGRAPH>You can design a program to receive signals in a synchronous manner instead of asynchronously. To do this, set a mask that blocks all the signals that are to be received synchronously. Then call one of the following three functions: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>sigwait(3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Suspend until one of a specified set of signals is generated, then 
return the signal number.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>sigwaitinfo(3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Like <FUNCTION>sigwait()</FUNCTION>, but returns additional information about the signal.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>sigtimedwait(3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Like <FUNCTION>sigwaitinfo()</FUNCTION>, but also returns after a specified time has elapsed 
if no signal is received.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Using these functions you can write a thread that treats signals as a stream of events to be processed. This is generally the safest program model, much easier to work with than the asynchronous model of signal delivery.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="23231">Scheduling Pthreads</TITLE><PARAGRAPH>The pthreads scheduling algorithm is controlled by three variables: a scope, policy, and priority for each thread. These variables are set initially when the thread is created (see <INDEXTARGET ID="TIP_4d.mpcthrd20"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd20|pthreads:scheduling --><XREF IDREF="56878" TYPE="TITLE">&ldquo;Initial Scheduling Scope, Priority, and Policy&rdquo;</XREF>), but policy and priority can be modified while the thread is running. </PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Contention Scope</TITLE><PARAGRAPH>The scheduling contention scope of a pthread (see <INDEXTARGET ID="TIP_4d.mpcthrd21"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd21|pthread scheduling contention --><REFPAGE>pthread_attr_setscope</REFPAGE>(3P)) determines the set of threads that it competes against for resources.</PARAGRAPH>
<PARAGRAPH>System scope threads compete with all other threads on the system and can be created only by privileged users. These threads are used in programs when some form of guaranteed (that is, real-time) response is required. Their scheduling parameters directly affect how the system treats them. In addition to the usual scheduling attributes, they can select a CPU on which to run using the <INDEXTARGET ID="TIP_4d.mpcthrd22"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd22|system scope threadsthreads:system scope --><FUNCTION>pthread_setrunon_np() <INDEXTARGET ID="TIP_4d.mpcthrd23"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd23|<FUNCTION>pthread_setrunon_np()</FUNCTION> --></FUNCTION>call.</PARAGRAPH>
<PARAGRAPH>Process scope threads compete within the process and their scheduling attributes are used by the pthread library to select which threads to run on a pool of kernel entities. The size of the pool is determined dynamically, but may be influenced using the <INDEXTARGET ID="TIP_4d.mpcthrd24"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd24|process scope threadsthreads:process scope --><FUNCTION>pthread_setconcurrency()<INDEXTARGET ID="TIP_4d.mpcthrd25"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd25|<FUNCTION>pthread_setconcurrency()</FUNCTION> --></FUNCTION> call.</PARAGRAPH>
<PARAGRAPH>Process scope threads generally require fewer resources than system scope threads because they can share kernel resources. The kernel entities themselves share a common set of scheduling attributes which privileged users can change using the process scheduling interfaces (see <REFPAGE>sched_setscheduler</REFPAGE>(2) and <REFPAGE>sched_setparam</REFPAGE>(2)). For further details, see the <REFPAGE>pthreads</REFPAGE>(5) reference page.</PARAGRAPH>
<PARAGRAPH>The functions used in scheduling are summarized in <XREF IDREF="83208" TYPE="TABLE">Table&nbsp;13-6</XREF> and described in the following sections:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="12077" TYPE="TITLE">&ldquo;Scheduling Policy&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="36175" TYPE="TITLE">&ldquo;Scheduling Priority&rdquo;</XREF></PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="13-6"><PREFIX>Table 13-6 </PREFIX><XREFTARGET ID="83208">Functions for Schedule Management</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="135"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>pthread_getschedparam(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Get a thread's policy and priority.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>pthread_setschedparam(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Set a thread's policy and priority.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>sched_get_priority_max(3C)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Return the maximum priority value.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>sched_get_priority_min(3C)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Return the minimum priority value.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>sched_yield(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Relinquish the processor.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>pthread_setconcurrency(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Modify concurrency level.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>pthread_getconcurrency(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Check the concurrency level.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>pthread_setrunon_np(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Select a CPU to run a system scope thread.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH><REFPAGE>pthread_getrunon_np(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>Query a named CPU's affinity.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</BULLET>
</BULLETLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="12077">Scheduling Policy</TITLE><PARAGRAPH>There are two scheduling policies in this implementation: first-in-first-out (SCHED_FIFO) and the default round-robin (SCHED_RR). SCHED_FIFO and SCHED_RR are similar. The round-robin scheduler ensures that after a thread has used a certain maximum amount of time, it is moved to the end of the queue of threads of the same priority, and can be preempted by other threads.</PARAGRAPH>
<PARAGRAPH>The details of scheduling are discussed in the <REFPAGE>pthread_attr_setschedpolicy(3P)</REFPAGE> reference page.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="36175">Scheduling Priority</TITLE><PARAGRAPH>Threads are ordered by priority values, with a small number representing a low priority, and a larger number representing a higher priority. Threads with higher priorities are chosen to execute before threads with lower priorities.<INDEXTARGET ID="TIP_4d.mpcthrd26"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd26|pthreads:priority --></PARAGRAPH>
<PARAGRAPH>The <FUNCTION>sched_get_priority_max()</FUNCTION> and <FUNCTION>sched_get_priority_min()</FUNCTION> functions return the highest and lowest priority numbers for a given policy. There are at least 32 priority values and the lowest is greater than or equal to 0. </PARAGRAPH>
<PARAGRAPH>A thread can set another's priority and scheduling policy, using <FUNCTION>pthread_setschedparam()</FUNCTION>. A simple function to set a specified priority on the current thread is shown in <XREF IDREF="66387" TYPE="TEXT">Example&nbsp;13-2</XREF>. </PARAGRAPH>
<CODE><CAPTION LBL="13-2"><PREFIX>Example 13-2 </PREFIX><XREFTARGET ID="66387">Function to Set Own Priority</CAPTION>#include &lt;sched.h> /* struct sched_param */
void setMyPriority(int newP)
{
&nbsp;&nbsp;&nbsp;pthread_t myTid = pthread_self();
&nbsp;&nbsp;&nbsp;int policy;
&nbsp;&nbsp;&nbsp;struct sched_param sp;
&nbsp;&nbsp;&nbsp;(void) pthread_getschedparam(myTID,&amp;policy,&amp;sp);
&nbsp;&nbsp;&nbsp;sp.sched_priority = newP;
&nbsp;&nbsp;&nbsp;(void) pthread_setschedparam(myTID,policy,&amp;sp);
} &space;
</CODE>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="77545">Synchronizing Pthreads</TITLE><PARAGRAPH>Threads using a common address space must cooperate and coordinate their use of shared variables. IRIX provides many mechanisms for coordinating threads, including:<INDEXTARGET ID="TIP_4d.mpcthrd27"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd27|pthreads:synchronization of --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>POSIX semaphores for general coordination and resource management (see <XREF IDREF="82695" TYPE="TITLE">&ldquo;POSIX Facilities for Mutual Exclusion&rdquo;</XREF>).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>POSIX or SVR4 message queues (see <XREF IDREF="48324" TYPE="TITLE">Chapter&nbsp;6, &ldquo;Message Queues&rdquo;</XREF>).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>POSIX mutex objects, which allow threads to gain exclusive use of a shared variable (see <XREF IDREF="98602" TYPE="TITLE">&ldquo;Mutexes&rdquo;</XREF>).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>POSIX condition variables, which allow a thread to wait when a controlling predicate is false (see <XREF IDREF="77156" TYPE="TITLE">&ldquo;Condition Variables&rdquo;</XREF>).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>POSIX read-write locks, which allow one thread exclusive access to locked data to write it or read access to locked data for several threads (see <XREF IDREF="16679" TYPE="TITLE">&ldquo;Read-Write Locks&rdquo;</XREF>).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>IRIX semaphores and locks.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>SVR4 semaphores.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<TIP><PREFIX>Tip</PREFIX>Synchronization between processes (such as POSIX process-shared mechanisms, IRIX IPC, and SVR4 IPC) is more costly than synchronization between threads (POSIX process-private mechanisms). So where possible, use the process-private mechanisms.</TIP>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="98602">Mutexes</TITLE><PARAGRAPH>A mutex is a software object that arbitrates the right to modify some shared variable, or the right to execute a critical section of code. A mutex can be owned by only one thread at a time; other threads trying to acquire it wait. Mutexes are intended to be lightweight and owned only for a short time.<INDEXTARGET ID="TIP_4d.mpcthrd28"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd28|mutual exclusion --><INDEXTARGET ID="TIP_4d.mpcthrd29"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd29|mutual exclusion:mutex --></PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Preparing Mutex Objects</TITLE><PARAGRAPH>When a thread wants to modify a variable that it shares with other threads, or execute a critical section, the thread claims the associated mutex. This can cause the thread to wait until it can acquire the mutex. When the thread has finished using the shared variable or critical code, it releases the mutex. If two or more threads claim the mutex at once, one acquires the mutex and continues, while the others are blocked until the mutex is released.</PARAGRAPH>
<PARAGRAPH>A mutex has attributes that control its behavior. The pthreads library contains several functions used to prepare a mutex for use. These functions are summarized in <XREF IDREF="22792" TYPE="TABLE">Table&nbsp;13-7</XREF>.</PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="13-7"><PREFIX>Table 13-7 </PREFIX><XREFTARGET ID="22792"> <EMPHASIS>(continued)        </EMPHASIS>Functions for Preparing Mutex Objects</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="176"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="208"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="176"><PARAGRAPH><REFPAGE>pthread_mutexattr_init(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="208"><PARAGRAPH>Initialize a <VARIABLE>pthread_mutexattr_t</VARIABLE> with default 
attributes.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="176"><PARAGRAPH><REFPAGE>pthread_mutexattr_destroy(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="208"><PARAGRAPH>Uninitialize a <VARIABLE>pthread_mutexattr_t</VARIABLE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="176"><PARAGRAPH><REFPAGE>pthread_mutexattr_getprotocol(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="208"><PARAGRAPH>Query the priority protocol.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="176"><PARAGRAPH><REFPAGE>pthread_mutexattr_setprotocol(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="208"><PARAGRAPH>Set the priority protocol choice.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="176"><PARAGRAPH><REFPAGE>pthread_mutexattr_getprioceiling(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="208"><PARAGRAPH>Query the minimum priority.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="176"><PARAGRAPH><REFPAGE>pthread_mutexattr_setprioceiling(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="208"><PARAGRAPH>Set the minimum priority.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="176"><PARAGRAPH><REFPAGE>pthread_mutexattr_getpshared(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="208"><PARAGRAPH>Query the process-shared attribute.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="176"><PARAGRAPH><REFPAGE>pthread_mutexattr_setpshared(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="208"><PARAGRAPH>Set the process-shared attribute.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="176"><PARAGRAPH><REFPAGE>pthread_mutexattr_gettype(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="208"><PARAGRAPH>Get the mutex type.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="176"><PARAGRAPH><REFPAGE>pthread_mutexattr_settype(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="208"><PARAGRAPH>Set the mutex type.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="176"><PARAGRAPH><REFPAGE>pthread_mutex_init(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="208"><PARAGRAPH>Initialize a mutex object.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="176"><PARAGRAPH><REFPAGE>pthread_mutex_destroy(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="208"><PARAGRAPH>Uninitialize a mutex object.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>A mutex must be initialized before use. You can do this in one of three ways:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Static assignment of the constant PTHREAD_MUTEX_INITIALIZER.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Calling <FUNCTION>pthread_mutex_init()</FUNCTION> passing NULL instead of the address of a mutex attribute object.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Calling <FUNCTION>pthread_mutex_init()</FUNCTION> passing a <VARIABLE>pthread_mutexattr_t</VARIABLE> object that you have set up with attribute values.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The first two methods initialize the mutex to default attributes. </PARAGRAPH>
<PARAGRAPH>Four attributes can be set in a <VARIABLE>pthread_mutexattr_t</VARIABLE>. You can set the priority inheritance protocol using <FUNCTION>pthread_mutexattr_setprotocol()</FUNCTION> to one of three values:</PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH>PTHREAD_PRIO_NONE</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>The mutex has no effect on the thread that acquires it. 
This is the default.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH>PTHREAD_PRIO_PROTECT</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>The thread holding the mutex runs at a priority at least 
as high as the highest priority of any mutex that it 
currently holds.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH>PTHREAD_PRIO_INHERIT</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>The thread holding the mutex runs at a priority at least 
as high as the highest priority of any thread blocked on 
that mutex.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>If a thread acquires a mutex and then is suspended (for example, because its time slice is up), other threads can be blocked waiting for the mutex. The PTHREAD_PRIO_PROTECT protocol prevents this. Using <FUNCTION>pthread_mutexattr_setprioceiling(),</FUNCTION> you set a priority higher than normal for the mutex. A thread that acquires the mutex runs at this higher priority while it holds the mutex. </PARAGRAPH>
<PARAGRAPH>Another problem is that when a low-priority thread has acquired a mutex, and a thread with higher priority claims the mutex and is blocked, a &ldquo;priority inversion&rdquo; takes place&mdash;a higher-priority thread is forced to wait for one of lower priority. The PTHREAD_PRIO_INHERIT protocol prevents this&mdash;when a thread of higher priority blocks, the thread holding the mutex has its priority boosted during the time it holds the mutex.</PARAGRAPH>
<TIP><PREFIX>Tip</PREFIX>PTHREAD_PRIO_NONE uses a faster code path than the other two priority options for mutexes.</TIP>
<PARAGRAPH>By default, only threads within a process share a mutex. Using <FUNCTION>pthread_mutexattr_setpshared()<INDEXTARGET ID="TIP_4d.mpcthrd30"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd30|<FUNCTION>pthread_mutexattr_setpshared()</FUNCTION> --></FUNCTION>, you can allow any thread (from any process) with access to the mutex memory location to use the mutex. Enable mutex sharing by changing the default PTHREAD_PROCESS_PRIVATE attribute to PTHREAD_PROCESS_SHARED.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>The PTHREAD_PRIO_INHERIT attribute is not available with <FUNCTION>pthread_mutexattr_setpshared()</FUNCTION>.</NOTE>
<PARAGRAPH>By default, no error checking is performed on threads that attempt to use a mutex. For example, a thread that attempts to lock a mutex that it already owns deadlocks. Using <FUNCTION>pthread_mutexattr_settype()<INDEXTARGET ID="TIP_4d.mpcthrd31"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd31|<FUNCTION>pthread_mutexattr_settype()</FUNCTION> --></FUNCTION> with PTHREAD_MUTEX_ERRORCHECK allows you to have the lock call return an error instead. If recursive mutexes are required, PTHREAD_MUTEX_RECURSIVE enables recursive mutexes.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using Mutexes</TITLE><PARAGRAPH>The functions for claiming, releasing, and using mutexes are summarized in <XREF IDREF="13370" TYPE="TABLE">Table&nbsp;13-8</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="13-8"><PREFIX>Table 13-8 </PREFIX><XREFTARGET ID="13370">Functions for Using Mutexes</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="163"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="223"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="163"><PARAGRAPH><REFPAGE>pthread_mutex_lock(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="223"><PARAGRAPH>Claim a mutex, blocking until it is available.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="163"><PARAGRAPH><REFPAGE>pthread_mutex_trylock(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="223"><PARAGRAPH>Test a mutex and acquire it if it is available, else return 
an error.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="163"><PARAGRAPH><REFPAGE>pthread_mutex_unlock(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="223"><PARAGRAPH>Release a mutex.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="163"><PARAGRAPH><REFPAGE>pthread_mutex_getprioceiling(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="223"><PARAGRAPH>Query the minimum priority of a mutex.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="163"><PARAGRAPH><REFPAGE>pthread_mutex_setprioceiling(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="223"><PARAGRAPH>Set the minimum priority of a mutex.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>To determine where mutexes should be used, examine the memory variables and other objects (such as files) that can be accessed from multiple threads. Create a mutex for each set of shared objects that are used together. Ensure that the code acquires the proper mutex before it modifies the shared objects. You acquire a mutex by calling <FUNCTION>pthread_mutex_lock()</FUNCTION>, and release it with <FUNCTION>pthread_mutex_unlock()</FUNCTION>. When a thread must not be blocked, it can use <FUNCTION>pthread_mutex_trylock()</FUNCTION> to test the mutex and lock it only if it is available.&space;</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="77156">Condition Variables</TITLE><PARAGRAPH>A condition variable provides a way in which a thread can wait for an event (or condition) defined by the program, to be satisfied. Condition variables use mutexes to synchronize the wait and wakeup operations.<INDEXTARGET ID="TIP_4d.mpcthrd32"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd32|condition variable --><INDEXTARGET ID="TIP_4d.mpcthrd33"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd33|mutual exclusion:condition variable --></PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Preparing Condition Variables</TITLE><PARAGRAPH>Like mutexes and threads themselves, condition variables are supplied with a mechanism of attribute objects (<VARIABLE>pthread_condattr_t</VARIABLE> objects) and static and dynamic initializers. (Only the condition variable for the process-shared attribute can be initialized in this implementation.) The functions for initializing one are summarized in <XREF IDREF="53593" TYPE="TABLE">Table&nbsp;13-9</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="13-9"><PREFIX>Table 13-9 </PREFIX><XREFTARGET ID="53593">Functions for Preparing Condition Variables</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="151"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="237"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="151"><PARAGRAPH><REFPAGE>pthread_condattr_init(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="237"><PARAGRAPH>Initialize a <VARIABLE>pthread_condattr_t</VARIABLE> to default attributes.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="151"><PARAGRAPH><REFPAGE>pthread_condattr_destroy(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="237"><PARAGRAPH>Uninitialize a <VARIABLE>pthread_condattr_t</VARIABLE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="151"><PARAGRAPH><REFPAGE>pthread_condattr_getpshared(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="237"><PARAGRAPH>Get the process-shared attribute.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="151"><PARAGRAPH><REFPAGE>pthread_condattr_setpshared(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="237"><PARAGRAPH>Set the process-shared attribute.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="151"><PARAGRAPH><REFPAGE>pthread_cond_init(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="237"><PARAGRAPH>Initialize a condition variable based on an attribute object.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="151"><PARAGRAPH><REFPAGE>pthread_cond_destroy(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="160" WIDTH="237"><PARAGRAPH>Uninitialize a condition variable.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>A condition variable must be initialized before use. You can do this in one of three ways:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Static assignment of the constant PTHREAD_COND_INITIALIZER.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Calling <FUNCTION>pthread_cond_init()</FUNCTION> passing NULL instead of the address of an attribute object.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Calling <FUNCTION>pthread_cond_init()</FUNCTION> passing a <VARIABLE>pthread_condattr_t</VARIABLE> object that you have set up with attribute values.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The first two methods initialize the variable to default attributes. </PARAGRAPH>
<PARAGRAPH>By default, only threads within a process share a condition variable. Using <FUNCTION>pthread_condattr_setpshared()</FUNCTION>, you can allow any thread (from any process) with access to the condition variable memory location to use the condition variable. Enable condition variable sharing by changing the default PTHREAD_PROCESS_PRIVATE attribute to PTHREAD_PROCESS_SHARED.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using Condition Variables</TITLE><PARAGRAPH>A condition variable is a software object that represents a test of a Boolean condition. Typically the condition changes because of a software event such as &ldquo;other thread has supplied data.&rdquo; A thread establishes that it needs to wait by first evaluating the condition. The thread that satisfies the condition signals the condition variable, releasing one or all threads that are waiting.</PARAGRAPH>
<PARAGRAPH>For example, a thread might acquire a mutex that represents a shared resource. While holding the mutex, the thread finds that the shared resource is not complete. The thread does three things:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Wait, giving up the mutex so that some other thread can renew the shared resource.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Wait until the condition is signalled.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Wake-up, re-acquiring the mutex for the shared resource and rechecking the condition.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>These three actions are combined into one using a condition variable. The functions used with condition variables are summarized in <XREF IDREF="78810" TYPE="TABLE">Table&nbsp;13-10</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="13-10"><PREFIX>Table 13-10 </PREFIX><XREFTARGET ID="78810">Functions for Using Condition Variables</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="144"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="241"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH><REFPAGE>pthread_cond_wait(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="241"><PARAGRAPH>Wait on a condition variable.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH><REFPAGE>pthread_cond_timedwait(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="241"><PARAGRAPH>Wait on a condition variable, returning with an error after a 
time limit expires.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH><REFPAGE>pthread_cond_signal(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="241"><PARAGRAPH>Signal that an awaited event has occurred, releasing at least 
one waiting thread.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="144"><PARAGRAPH><REFPAGE>pthread_cond_broadcast(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="241"><PARAGRAPH>Signal that an awaited event has occurred, releasing all 
waiting threads.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The <FUNCTION>pthread_cond_wait()</FUNCTION> and <FUNCTION>pthread_cond_timedwait()</FUNCTION> functions require both a condition variable and a mutex that is owned by the calling thread. The mutex is released and the wait begins. When the event is signalled (or the time limit expires), the mutex is reacquired, as if by a call to <FUNCTION>pthread_mutex_lock()</FUNCTION>.</PARAGRAPH>
<PARAGRAPH>The POSIX standard explicitly warns that it is possible in some cases for a conditional wait to return before the event has been signalled. For this reason, a conditional wait should always be coded in a loop that tests the shared resource for the needed status. These principles are suggested in the code in <XREF IDREF="45070" TYPE="TEXT">Example&nbsp;13-3</XREF>, which is modeled after an example in the POSIX 1003.1c standard.</PARAGRAPH>
<CODE><CAPTION LBL="13-3"><PREFIX>Example 13-3 </PREFIX><XREFTARGET ID="45070">Use of Condition Variables</CAPTION>#include &lt;assert.h>
#include &lt;pthread.h>
typedef&nbsp;int&nbsp;listKey_t;
typedef&nbsp;struct&nbsp;element_s&nbsp;{&nbsp;/*&nbsp;list&nbsp;element&nbsp;*/
&nbsp;&nbsp;&nbsp;listKey_t&nbsp;key;
&nbsp;&nbsp;&nbsp;struct&nbsp;element_s&nbsp;*next;
&nbsp;&nbsp;&nbsp;int&nbsp;busyFlag;
&nbsp;&nbsp;&nbsp;pthread_cond_t&nbsp;notBusy;&nbsp;/*&nbsp;event&nbsp;of&nbsp;no-longer-in-use&nbsp;*/
}&nbsp;element_t;
typedef&nbsp;struct&nbsp;listHead_s&nbsp;{&nbsp;/*&nbsp;list&nbsp;head&nbsp;and&nbsp;mutex&nbsp;*/
&nbsp;&nbsp;&nbsp;pthread_mutex_t&nbsp;mutList;&nbsp;/*&nbsp;right&nbsp;to&nbsp;modify&nbsp;the&nbsp;list&nbsp;*/
&nbsp;&nbsp;&nbsp;element_t&nbsp;*head;
}&nbsp;listHead_t;
/*
||&nbsp;Internal&nbsp;function&nbsp;to&nbsp;find&nbsp;an&nbsp;element&nbsp;in&nbsp;a&nbsp;list,&nbsp;returning&nbsp;NULL
||&nbsp;if&nbsp;the&nbsp;key&nbsp;is&nbsp;not&nbsp;in&nbsp;the&nbsp;list.
||&nbsp;A&nbsp;returned&nbsp;element&nbsp;could&nbsp;be&nbsp;in&nbsp;use&nbsp;by&nbsp;another&nbsp;thread&nbsp;(busy).
||&nbsp;The&nbsp;caller&nbsp;is&nbsp;assumed&nbsp;to&nbsp;hold&nbsp;the&nbsp;list&nbsp;mutex,&nbsp;otherwise
||&nbsp;the&nbsp;returned&nbsp;value&nbsp;could&nbsp;be&nbsp;made&nbsp;invalid&nbsp;at&nbsp;any&nbsp;time.
*/
static&nbsp;element_t&nbsp;*scanList(listHead_t*&nbsp;lp,&nbsp;listKey_t&nbsp;key)
{
&nbsp;&nbsp;&nbsp;element_t&nbsp;*ep;
&nbsp;&nbsp;&nbsp;for&nbsp;(ep=lp->head;&nbsp;(ep)&nbsp;;&nbsp;ep=ep->next)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ep->key&nbsp;==&nbsp;key)&nbsp;break;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;return&nbsp;ep;
}
/*
||&nbsp;Public&nbsp;function&nbsp;to&nbsp;find&nbsp;a&nbsp;key&nbsp;in&nbsp;a&nbsp;list,&nbsp;wait&nbsp;until&nbsp;the&nbsp;element
||&nbsp;is&nbsp;no&nbsp;longer&nbsp;busy,&nbsp;mark&nbsp;it&nbsp;busy,&nbsp;and&nbsp;return&nbsp;it.
*/
element_t&nbsp;*getFromList(listHead_t*&nbsp;lp,&nbsp;listKey_t&nbsp;key)
{
&nbsp;&nbsp;&nbsp;element_t&nbsp;*ep;
&nbsp;&nbsp;&nbsp;pthread_mutex_lock(&amp;lp->mutList);&nbsp;/*&nbsp;lock&nbsp;list&nbsp;against&nbsp;changes&nbsp;*/
&nbsp;&nbsp;&nbsp;while&nbsp;((ep=scanList(lp,key))&nbsp;&amp;&amp;&nbsp;(ep->busyFlag))
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_cond_wait(&amp;ep->notBusy,&nbsp;&amp;lp->mutList);&nbsp;/*&nbsp;(A)&nbsp;*/
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if&nbsp;(ep)&nbsp;ep->busyFlag&nbsp;=&nbsp;1;
&nbsp;&nbsp;&nbsp;pthread_mutex_unlock(&amp;lp->mutList);
&nbsp;&nbsp;&nbsp;return&nbsp;ep;
}
/*
||&nbsp;Public&nbsp;function&nbsp;to&nbsp;release&nbsp;an&nbsp;element&nbsp;returned&nbsp;by&nbsp;getFromList().
*/
void&nbsp;freeInList(listHead_t*&nbsp;lp,&nbsp;element_t&nbsp;*ep)
{
&nbsp;&nbsp;&nbsp;assert(ep->busyFlag);
&nbsp;&nbsp;&nbsp;pthread_mutex_lock(&amp;lp->mutList);&nbsp;/*&nbsp;lock&nbsp;list&nbsp;to prevent races&nbsp;*/
&nbsp;&nbsp;&nbsp;ep->busyFlag&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;pthread_cond_signal(&amp;ep->notBusy);
&nbsp;&nbsp;&nbsp;pthread_mutex_unlock(&amp;lp->mutList);
}
/*
||&nbsp;Public&nbsp;function&nbsp;to&nbsp;delete&nbsp;a&nbsp;list&nbsp;element&nbsp;returned&nbsp;by&nbsp;getFromList().
*/
void&nbsp;deleteInList(listHead_t*&nbsp;lp,&nbsp;element_t&nbsp;*ep)
{
&nbsp;&nbsp;&nbsp;element_t&nbsp;**epp;
&nbsp;&nbsp;&nbsp;assert(ep->busyFlag);
&nbsp;&nbsp;&nbsp;pthread_mutex_lock(&amp;lp->mutList);
&nbsp;&nbsp;&nbsp;for&nbsp;(epp&nbsp;=&nbsp;&amp;lp->head;&nbsp;ep&nbsp;!=&nbsp;*epp;&nbsp;epp&nbsp;=&nbsp;&amp;((*epp)->next))
&nbsp;&nbsp;&nbsp;{&nbsp;/*&nbsp;finding&nbsp;anchor&nbsp;of&nbsp;*ep&nbsp;in&nbsp;list&nbsp;*/&nbsp;}
&nbsp;&nbsp;&nbsp;*epp&nbsp;=&nbsp;ep->next;&nbsp;/*&nbsp;remove&nbsp;*ep&nbsp;from&nbsp;list&nbsp;*/
&nbsp;&nbsp;&nbsp;ep->busyFlag&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;pthread_cond_broadcast(&amp;ep->notBusy);
&nbsp;&nbsp;&nbsp;pthread_mutex_unlock(&amp;lp->mutList);
&nbsp;&nbsp;&nbsp;pthread_cond_destroy(&amp;ep->notBusy);
&nbsp;&nbsp;&nbsp;free(ep);
}
</CODE>
<PARAGRAPH>The functions in <XREF IDREF="45070" TYPE="TEXT">Example&nbsp;13-3</XREF> implement part of a simple library for managing lists. In a list head, <VARIABLE>mutList</VARIABLE> is a mutex object that represents the right to modify any part of the list. The elements of a list can be &ldquo;busy,&rdquo; that is, in use by some thread. An element that is busy has a nonzero <VARIABLE>busyFlag</VARIABLE> field.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>getFromList()</FUNCTION> function looks up an element in a specified list, makes that element busy, and returns it. The function begins by acquiring the list mutex. This ensures that the list cannot change while the function is searching the list, and makes it legitimate for the function to change the busy flag in an element.</PARAGRAPH>
<PARAGRAPH>When it finds the element, the function might discover that the element is already busy. In this case, it must wait for the event &ldquo;element is no longer busy,&rdquo; which is represented by the condition variable <VARIABLE>notBusy</VARIABLE> in the element. In order to wait for this event, <FUNCTION>getFromList()</FUNCTION> calls <FUNCTION>pthread_cond_wait()</FUNCTION> passing its list mutex and the condition variable (point &ldquo;(A)&rdquo; in the code). This releases the list mutex so that other threads can acquire the list and do their work on other elements.</PARAGRAPH>
<PARAGRAPH>When any thread wants to release the use of a list element, it calls <FUNCTION>freeInList()</FUNCTION>. After clearing the busy flag in the list element, <FUNCTION>freeInList()</FUNCTION> announces that the event &ldquo;element is no longer busy&rdquo; has occurred, by calling <FUNCTION>pthread_cond_signal()</FUNCTION>.</PARAGRAPH>
<PARAGRAPH>This call releases a thread that is waiting at point &ldquo;(A).&rdquo; If there is more than one thread waiting for the same element, the first in priority order is released. The released thread re-acquires the list mutex and resumes execution. The first thing it does is repeat its search of the list for the desired key and, on finding the element again, test it again for busyness. This repetition is needed because it is possible to get spurious returns from a condition variable.</PARAGRAPH>
<PARAGRAPH>When a thread wants to delete a list element, it gets the list element by calling <FUNCTION>getFromList()</FUNCTION>. This ensures that the element is busy, so no other thread is using it. Then the thread calls <FUNCTION>deleteInList()</FUNCTION>. This function changes the list, so it begins by acquiring the list mutex. Then it can safely modify the list pointers. It scans up the list looking for the pointer that points to the target element. It removes the target element from the list by copying its <VARIABLE>next</VARIABLE> field to replace the pointer to the target element.</PARAGRAPH>
<PARAGRAPH>With the element removed from the list, <FUNCTION>deleteInList()</FUNCTION> calls <FUNCTION>pthread_cond_broadcast()</FUNCTION> to wake up all threads&mdash;not just the first thread&mdash;that might be waiting for the element to become nonbusy. Each of these threads resumes execution at point &ldquo;(A)&rdquo; by attempting to re-acquire the list mutex. However, <FUNCTION>deleteInList()</FUNCTION> is still holding the list mutex. The mutex is released; then the other threads can resume execution following point &ldquo;(A),&rdquo; but this time when they search the list, the desired key is no longer found.</PARAGRAPH>
<PARAGRAPH>Meanwhile, <FUNCTION>deleteInList()</FUNCTION> uses <FUNCTION>pthread_cond_destroy()</FUNCTION> to release any memory that the pthreads library might have associated with the condition variable, before releasing the list element object itself. </PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="16679">Read-Write Locks</TITLE><PARAGRAPH>A read-write lock is a software object that gives one thread the right to modify some data, or multiple threads the right to read that data. A read-write lock can be owned for write or for read. If acquired for write, only one thread can own it and other threads must wait. If acquired for read, other threads wishing to acquire it for write must wait, but multiple readers can own the lock at the same time.<INDEXTARGET ID="TIP_4d.mpcthrd34"><!-- POSTPROCESSDATA: TIP_4d.mpcthrd34|mutual exclusion:read-write locks --></PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Preparing Read-Write Locks</TITLE><PARAGRAPH>When a thread wants to modify or read data shared by several threads, the thread claims the associated lock. This can cause the thread to wait until it can acquire the lock. When the thread has finished reading or writing the shared data, it releases the lock.</PARAGRAPH>
<PARAGRAPH>A read-write lock has attributes that control its behavior. The pthreads library contains several functions used to prepare a lock for use. These functions are summarized in <XREF IDREF="34823" TYPE="TABLE">Table&nbsp;13-11</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="13-11"><PREFIX>Table 13-11 </PREFIX><XREFTARGET ID="34823">Functions for Preparing Read-Write Locks</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="176"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="208"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="176"><PARAGRAPH><REFPAGE>pthread_rwlockattr_init(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="208"><PARAGRAPH>Initialize a <VARIABLE>pthread_rwlockattr_t</VARIABLE> with default 
attributes.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="176"><PARAGRAPH><REFPAGE>pthread_rwlockattr_destroy(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="208"><PARAGRAPH>Uninitialize a <VARIABLE>pthread_rwlockattr_t</VARIABLE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="176"><PARAGRAPH><REFPAGE>pthread_rwlockattr_getpshared(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="208"><PARAGRAPH>Query the process-shared attribute.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="176"><PARAGRAPH><REFPAGE>pthread_rwlockattr_setpshared(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="208"><PARAGRAPH>Set the process-shared attribute.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="176"><PARAGRAPH><REFPAGE>pthread_rwlock_init(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="208"><PARAGRAPH>Initialize a rwlock object based on a 
<VARIABLE>pthread_rwlockattr_t</VARIABLE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="176"><PARAGRAPH><REFPAGE>pthread_rwlock_destroy(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="185" WIDTH="208"><PARAGRAPH>Uninitialize a read-write lock object.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>A read-write lock must be initialized before use. You can do this in one of three ways:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Static assignment of the constant PTHREAD_RWLOCK_INITIALIZER.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Calling <FUNCTION>pthread_rwlock_init()</FUNCTION> passing NULL instead of the address of a read-write lock attribute object.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Calling <FUNCTION>pthread_rwlock_init()</FUNCTION> passing a <VARIABLE>pthread_rwlockattr_t</VARIABLE> object that you have set up with attribute values.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The first two methods initialize the read-write lock to default attributes. </PARAGRAPH>
<PARAGRAPH>By default, only threads within a process share a read-write lock. Using <FUNCTION>pthread_rwlockattr_setpshared()</FUNCTION>, you can allow any thread (from any process) with access to the read-write lock memory location to claim the read-write lock. Enable read-write lock sharing by changing the default PTHREAD_PROCESS_PRIVATE attribute to PTHREAD_PROCESS_SHARED.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using Read-Write Locks</TITLE><PARAGRAPH>The functions for claiming, releasing, and using read-write locks are summarized in <XREF IDREF="26583" TYPE="TABLE">Table&nbsp;13-12</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="13-12"><PREFIX>Table 13-12 </PREFIX><XREFTARGET ID="26583">Functions for Using Read-Write Locks</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="163"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="223"><PARAGRAPH>Purpose</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="163"><PARAGRAPH><REFPAGE>pthread_rwlock_wrlock(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="223"><PARAGRAPH>Apply a write lock, blocking until it is available.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="163"><PARAGRAPH><REFPAGE>pthread_rwlock_trywrlock(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="223"><PARAGRAPH>Test a write lock and acquire it if it is available, else 
return an error.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="163"><PARAGRAPH><REFPAGE>pthread_rwlock_rdlock(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="223"><PARAGRAPH>Apply a read lock, blocking until it is available.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="163"><PARAGRAPH><REFPAGE>pthread_rwlock_tryrdlock(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="223"><PARAGRAPH>Test a read lock and acquire it if it is available, else 
return an error.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="163"><PARAGRAPH><REFPAGE>pthread_rwlock_unlock(3P)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="223"><PARAGRAPH>Release a read or a write lock.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>To determine where read-write locks should be used, examine the memory variables and other objects (such as files) that can be accessed from multiple threads. Create a read lock for each set of shared objects that are used together. Ensure that the code acquires the write lock before it modifies the shared objects. You acquire a write lock by calling <FUNCTION>pthread_rwlock_wrlock()</FUNCTION>, and release it with <FUNCTION>pthread_rwlock_unlock()</FUNCTION>. A read lock is acquired by calling <FUNCTION>pthread_rwlock_rdlock()</FUNCTION>, and released with <FUNCTION>pthread_rwlock_unlock()</FUNCTION>. When a thread must not be blocked, it can use <FUNCTION>pthread_rwlock_trywrlock()</FUNCTION> or <FUNCTION>pthread_rwlock_tryrdlock() </FUNCTION>to test the lock and apply it only if it is available.&space;</PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
</CHAPTER>
