<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="7"><TITLE><XREFTARGET ID="33600">File and Record Locking</TITLE><PARAGRAPH>IRIX supports the ability to place a lock upon an entire file or upon a range of bytes within a file. Programs must cooperate in respecting record locks. A file lock can be made mandatory but only at a cost in performance. For these reasons, file and record locking should normally be seen as a synchronization mechanism, not a security mechanism.<INDEXTARGET ID="TIP_3a.flock1"><!-- POSTPROCESSDATA: TIP_3a.flock1|file and record locking --></PARAGRAPH>
<PARAGRAPH>The chapter includes these topics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="49540" TYPE="TITLE">&ldquo;Overview of File and Record Locking&rdquo;</XREF> presents an introduction to locking mechanisms.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="70619" TYPE="TITLE">&ldquo;Controlling File Access With File Permissions&rdquo;</XREF> discusses the relationship of file permissions to exclusive file access.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="24893" TYPE="TITLE">&ldquo;Using Record Locking&rdquo;</XREF> discusses the use of file and record locks to get exclusive data access.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="64660" TYPE="TITLE">&ldquo;Enforcing Mandatory Locking&rdquo;</XREF> describes how file locks can be made mandatory on programs that do not use locking.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="60993" TYPE="TITLE">&ldquo;Record Locking Across Multiple Systems&rdquo;</XREF> discusses how file locking can be extended to NFS-mounted files.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="49540">Overview of File and Record Locking</TITLE><PARAGRAPH>Simultaneous access to file data is characteristic of many multiprocess, multithreaded, or real-time applications.The purpose of the file and record locking facility is to provide a way for programs to synchronize their use of common file data.<INDEXTARGET ID="TIP_3a.flock2"><!-- POSTPROCESSDATA: TIP_3a.flock2|file and record locking:overview --></PARAGRAPH>
<PARAGRAPH>Advisory file and record locking can be used to coordinate independent, unrelated processes. In mandatory locking, on the other hand, the standard I/O subroutines and I/O system calls enforce the locking protocol. Mandatory locking keeps unrelated programs from accessing data out of sequence, at some cost of access speed.</PARAGRAPH>
<PARAGRAPH>The system functions used in file and record locking are summarized in <XREF IDREF="47524" TYPE="TABLE">Table&nbsp;7-1</XREF>.</PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="7-1"><PREFIX>Table 7-1 </PREFIX><XREFTARGET ID="47524"> <EMPHASIS>(continued)        </EMPHASIS>Functions for File and Record Locking</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="99"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Purpose and Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>fcntl(2)</REFPAGE>, <REFPAGE>fcntl(5)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>General function for modifying an open file descriptor; can be used to 
set file and record locks.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>lockf(3C)</REFPAGE>, <REFPAGE>lockf(3F)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Library function to set and remove file and record locks on open files 
(SVR4 compatible).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>f</REFPAGE><REFPAGE>lock(3B)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Library function to set and remove file and record locks on open files 
(BSD compatible).</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>chmod(1)</REFPAGE>, <REFPAGE>chmod(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Command and system function that can enable mandatory file locking 
on a specified file.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="87212">Terminology</TITLE><PARAGRAPH>The discussion of file and record locking depends on the terms defined in this section.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Record</TITLE><PARAGRAPH>A record is any contiguous sequence of bytes in a file. The UNIX operating system does not impose any record structure on files. The boundaries of records are defined by the programs that use the files. Within a single file, a record as defined by one process can overlap partially or completely on a record as defined by some other process.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Read (Shared) Lock</TITLE><PARAGRAPH>A read lock keeps a record from changing while one or more processes read the data. If a process holds a read lock, it may assume that no other process can alter that record at the same time. A read lock is also a shared lock because more than one process can place a read lock on the same record or on a record that overlaps a read-locked record. No process, however, can have a write lock that overlaps a read lock.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Write (Exclusive) Lock</TITLE><PARAGRAPH>A write lock is used to gain complete control over a record. A write lock is an exclusive lock because, when a write lock is in place on a record, no other process may read- or write-lock that record or any data that overlaps it. If a process holds a write lock it can assume that no other process will read or write that record at the same time. </PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Advisory Locking</TITLE><PARAGRAPH>An advisory lock is visible only when a program explicitly tries to place a conflicting lock. An advisory lock is not visible to the file I/O system functions such as <FUNCTION>read()</FUNCTION> and <FUNCTION>write()</FUNCTION>. A process that does not test for an advisory lock can violate the terms of the lock, for example, by writing into a locked record.</PARAGRAPH>
<PARAGRAPH>Advisory locks are useful when all processes make an appropriate record lock request before performing any I/O operation. When all processes use advisory locking, access to the locked data is controlled by the advisory lock requests. The success of advisory locking depends on the cooperation of all processes in enforcing the locking protocol; it is not enforced by the file I/O subsystem.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Mandatory Locking</TITLE><PARAGRAPH>Mandatory record locking is enforced by the file I/O system functions, and so is effective on unrelated processes that are not part of a cooperating group. Respect for locked records is enforced by the <FUNCTION>creat()</FUNCTION>, <FUNCTION>open()</FUNCTION>, <FUNCTION>read()</FUNCTION>, and <FUNCTION>write()</FUNCTION> system calls. When a record is locked, access to that record by any other process is restricted according to the type of lock on the record. Cooperating processes should still request an appropriate record lock before an I/O operation, but an additional check is made by IRIX before each I/O operation to ensure the record locking protocol is being honored. Mandatory locking offers security against unplanned file use by unrelated programs, but it imposes additional system overhead on access to the controlled files.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Lock Promotion and Demotion</TITLE><PARAGRAPH>A read lock can be promoted to write-lock status if no other process is holding a read lock in the same record. If processes with pending write locks are waiting for the same record, the lock promotion succeeds and the other (sleeping) processes wait. Demoting a write lock to a read lock can be done at any time.</PARAGRAPH>
<PARAGRAPH>Because the <FUNCTION>lockf()</FUNCTION> function does not support read locks, lock promotion is not applicable to locks set with that call. > <INDEXTARGET ID="TIP_3a.flock3"><!-- POSTPROCESSDATA: TIP_3a.flock3|file and record locking:overview&lt;$endrange --></PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="70619">Controlling File Access With File Permissions</TITLE><PARAGRAPH>The access permissions for each UNIX file control which users can read, write, or execute the file. These access permissions may be set only by the owner of the file or by the superuser. The permissions of the directory in which the file resides can also affect the access permissions for a file. Note that if the permissions for a directory allow anyone to write in the directory, and the &ldquo;sticky bit&rdquo; is not included in the permissions, files within that directory can be removed even by a user who does not have read, write, or execute permission for those files.<INDEXTARGET ID="TIP_3a.flock4"><!-- POSTPROCESSDATA: TIP_3a.flock4|file and record locking: file permissions and --></PARAGRAPH>
<PARAGRAPH>If your application warrants the use of record locking, make sure that the permissions on your files and directories are also set properly. A record lock, even a mandatory record lock, protects only the records that are locked, while they are locked. Unlocked parts of the files can be corrupted if proper precautions are not taken.</PARAGRAPH>
<PARAGRAPH>Only a known set of programs or users should be able to read or write a database. This can be enforced through file permissions as follows:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Using the <COMMAND>chown</COMMAND> facility (see the <REFPAGE>chown(1)</REFPAGE> and <REFPAGE>chown(2)</REFPAGE> reference pages), set the ownership of the critical directories and files to reflect the authorized group ID.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Using the <COMMAND>chmod</COMMAND> facility (see also the <REFPAGE>chmod(1)</REFPAGE> and <REFPAGE>chmod(2)</REFPAGE> reference pages), set the file permissions of the critical directories and files so that only members of the authorized group have write access (&ldquo;775&rdquo; permissions).</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Using the <COMMAND>chown</COMMAND> facility, set the accessing program executable files to be owned by the authorized group.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Using the <COMMAND>chmod</COMMAND> facility, set the set-GID bit for each accessing program executable file and to permit execution by anyone (&ldquo;2755&rdquo; permissions).</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>Users who are not members of the authorized group cannot modify the critical directories and files. However, when an ordinary user executes one of the accessing programs, the program automatically adopts the group ID of its owner. The accessing program can create and modify files in the critical directory, but other programs started by an ordinary user cannot.</PARAGRAPH>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="24893">Using Record Locking</TITLE><PARAGRAPH>This section covers the following topics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="55490" TYPE="TITLE">&ldquo;Opening a File for Record Locking&rdquo;</XREF>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="50785" TYPE="TITLE">&ldquo;Setting a File Lock&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="70576" TYPE="TITLE">&ldquo;Setting and Removing Record Locks&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="15347" TYPE="TITLE">&ldquo;Getting Lock Information&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="98149" TYPE="TITLE">&ldquo;Deadlock Handling&rdquo;</XREF></PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="55490">Opening a File for Record Locking</TITLE><PARAGRAPH>The first requirement for locking a file or segment of a file is having a valid open file descriptor. If read locks are to be used, then the file must be opened with at least read access; likewise for write locks and write access. <INDEXTARGET ID="TIP_3a.flock5"><!-- POSTPROCESSDATA: TIP_3a.flock5|file and record locking:opening files --></PARAGRAPH>
<PARAGRAPH><XREF IDREF="93451" TYPE="TEXT">Example&nbsp;7-1</XREF> opens a file for both read and write access.</PARAGRAPH>
<CODE><CAPTION LBL="7-1"><PREFIX>Example 7-1 </PREFIX><XREFTARGET ID="93451">Opening a File for Locked Use</CAPTION>#include&nbsp;&lt;stdio.h>
#include&nbsp;&lt;errno.h>
#include&nbsp;&lt;fcntl.h>
int&nbsp;fd;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;file&nbsp;descriptor&nbsp;*/
char&nbsp;*filename;
main(argc,&nbsp;argv)
int&nbsp;argc;
char&nbsp;*argv[];
{
&nbsp;&nbsp;&nbsp;&nbsp;extern&nbsp;void&nbsp;exit(),&nbsp;perror();
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;get&nbsp;database&nbsp;file&nbsp;name&nbsp;from&nbsp;command&nbsp;line&nbsp;and&nbsp;open&nbsp;the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;file&nbsp;for&nbsp;read&nbsp;and&nbsp;write&nbsp;access.&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(argc&nbsp;&lt;&nbsp;2)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void)&nbsp;fprintf(stderr,&nbsp;"usage:&nbsp;%s&nbsp;filename\n",&nbsp;argv[0]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(2);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;filename&nbsp;=&nbsp;argv[1];
&nbsp;&nbsp;&nbsp;&nbsp;fd&nbsp;=&nbsp;open(filename,&nbsp;O_RDWR);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fd&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror(filename);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(2);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</CODE>
<PARAGRAPH>The file is now open to perform both locking and I/O functions. The next step is to set a lock.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="50785">Setting a File Lock</TITLE><PARAGRAPH>Several ways exist to set a lock on a file. These methods depend upon how the lock interacts with the rest of the program. Issues of portability and performance need to be considered. Three methods for setting a lock are given here: using the <INDEXTARGET ID="TIP_3a.flock6"><!-- POSTPROCESSDATA: TIP_3a.flock6|file and record locking:locking a file --><FUNCTION>fcntl()</FUNCTION> system call; using the <ITALICS>/usr/group </ITALICS>standards-compatible <FUNCTION>lockf()</FUNCTION> library function; and using the BSD compatible <FUNCTION>flock()</FUNCTION> library function.</PARAGRAPH>
<PARAGRAPH>Locking an entire file is just a special case of record locking&mdash;one record is locked, which has the size of the entire file. The file is locked starting at a byte offset of zero and size of the maximum file size. This size is beyond any real end-of-file so that no other lock can be placed on the file.</PARAGRAPH>
<PARAGRAPH>You have a choice of three functions for this operation: the basic <FUNCTION>fcntl()</FUNCTION>, the library function <FUNCTION>lockf()</FUNCTION>, and the BSD compatible library function <FUNCTION>flock()</FUNCTION>. All three functions can interoperate. That is, a lock placed by one is respected by the other two.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Whole-File Lock With fcntl()</TITLE><PARAGRAPH>The <FUNCTION>fcntl()</FUNCTION> function treats a lock length of 0 as meaning &ldquo;size of file.&rdquo; The function <FUNCTION>lockWholeFile()</FUNCTION> in <XREF IDREF="97459" TYPE="TEXT">Example&nbsp;7-2</XREF> attempts a specified number of times to obtain a whole-file lock using <FUNCTION>fcntl()</FUNCTION>. When the lock is placed, it returns 0; otherwise it returns the error code for the failure.</PARAGRAPH>
<CODE><CAPTION LBL="7-2"><PREFIX>Example 7-2 </PREFIX><XREFTARGET ID="97459">Setting a Whole-File Lock With fcntl()</CAPTION>#include&nbsp;&lt;fcntl.h>
#include&nbsp;&lt;errno.h>
#define&nbsp;MAX_TRY&nbsp;10
&nbsp;
int
lockWholeFile(int&nbsp;fd,&nbsp;int&nbsp;tries)
{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;limit&nbsp;=&nbsp;(tries)?tries:MAX_TRY;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;try;
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;flock&nbsp;lck;
&nbsp;&nbsp;&nbsp;&nbsp;lck.l_type&nbsp;=&nbsp;F_WRLCK;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;write&nbsp;(exclusive)&nbsp;lock&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;lck.l_whence&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;0&nbsp;offset&nbsp;for&nbsp;l_start&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;lck.l_start&nbsp;=&nbsp;0L;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;lock&nbsp;starts&nbsp;at&nbsp;BOF&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;lck.l_len&nbsp;=&nbsp;0L;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;extent&nbsp;is&nbsp;entire&nbsp;file&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(try&nbsp;=&nbsp;0;&nbsp;try&nbsp;&lt;&nbsp;limit;&nbsp;++try)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;0&nbsp;==&nbsp;fcntl(fd,&nbsp;F_SETLK,&nbsp;&amp;lck)&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;/*&nbsp;mission&nbsp;accomplished&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((errno&nbsp;!=&nbsp;EAGAIN)&nbsp;&amp;&amp;&nbsp;(errno&nbsp;!=&nbsp;EACCES))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;/*&nbsp;mission&nbsp;impossible&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sginap(1);&nbsp;/*&nbsp;let&nbsp;lock&nbsp;holder&nbsp;run&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;errno;
}
</CODE>
<PARAGRAPH>The following points should be noted in <XREF IDREF="97459" TYPE="TEXT">Example&nbsp;7-2</XREF>:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Because <FUNCTION>fcntl()</FUNCTION> supports both read and write locks, the type of the lock (F_WRLCK) is specified in the <VARIABLE>l_type</VARIABLE>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The operation code F_SETLK is used to request that the function return if it cannot place the lock. The code F_SETLKW would request that the function suspend until the lock can be placed.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The starting location of the record is the sum of two fields, <VARIABLE>l_whence</VARIABLE> and <VARIABLE>l_start</VARIABLE>. Both must be set to 0 in order to get the starting point to the beginning of the file.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Whole-File Lock With lockf()</TITLE><PARAGRAPH><XREF IDREF="57304" TYPE="TEXT">Example&nbsp;7-3</XREF> shows a version of the <FUNCTION>lockWholeFile()</FUNCTION> function that uses <FUNCTION>lockf()</FUNCTION>. Like <FUNCTION>fcntl()</FUNCTION>, <FUNCTION>lockf()</FUNCTION> treats a record length of 0 as meaning &ldquo;to end of file.&rdquo;</PARAGRAPH>
<CODE><CAPTION LBL="7-3"><PREFIX>Example 7-3 </PREFIX><XREFTARGET ID="57304">Setting a Whole-File Lock With lockf()</CAPTION>#include&nbsp;&lt;unistd.h>&nbsp;/*&nbsp;for&nbsp;F_TLOCK&nbsp;*/
#include&nbsp;&lt;fcntl.h>&nbsp;&nbsp;/*&nbsp;for&nbsp;O_RDWR&nbsp;*/
#include&nbsp;&lt;errno.h>&nbsp;&nbsp;/*&nbsp;for&nbsp;EAGAIN&nbsp;*/
#define&nbsp;MAX_TRY&nbsp;10
&nbsp;
int
lockWholeFile(int&nbsp;fd,&nbsp;int&nbsp;tries)
{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;limit&nbsp;=&nbsp;(tries)?tries:MAX_TRY;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;try;
&nbsp;&nbsp;&nbsp;&nbsp;lseek(fd,0L,SEEK_SET);&nbsp;&nbsp;/*&nbsp;set&nbsp;start&nbsp;of&nbsp;lock&nbsp;range&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(try&nbsp;=&nbsp;0;&nbsp;try&nbsp;&lt;&nbsp;limit;&nbsp;++try)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(0&nbsp;==&nbsp;lockf(fd,&nbsp;F_TLOCK,&nbsp;0L)&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;/*&nbsp;mission&nbsp;accomplished&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(errno&nbsp;!=&nbsp;EAGAIN)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;/*&nbsp;mission&nbsp;impossible&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sginap(1);&nbsp;/*&nbsp;let&nbsp;lock&nbsp;holder&nbsp;run&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;errno;
}
</CODE>
<PARAGRAPH>The following points should be noted about <XREF IDREF="57304" TYPE="TEXT">Example&nbsp;7-3</XREF>:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The type of lock is not specified, because <FUNCTION>lockf()</FUNCTION> only supports exclusive locks.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The operation code F_TLOCK specifies that the function should return if the lock cannot be placed. The F_LOCK operation would request that the function suspend until the lock could be placed.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The start of the record is set implicitly by the current file position. That is why <FUNCTION>lseek()</FUNCTION> is called, to ensure the correct file position before <FUNCTION>lockf()</FUNCTION> is called.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Whole-File Lock With flock()</TITLE><PARAGRAPH><XREF IDREF="98802" TYPE="TEXT">Example&nbsp;7-4</XREF> displays a third example of the lockWholeFile subroutine, this one using <FUNCTION>flock()</FUNCTION>.</PARAGRAPH>
<CODE><CAPTION LBL="7-4"><PREFIX>Example 7-4 </PREFIX><XREFTARGET ID="98802">Setting a Whole-File Lock With flock()</CAPTION>#define&nbsp;_BSD_COMPAT
#include&nbsp;&lt;sys/file.h>&nbsp;/*&nbsp;includes&nbsp;fcntl.h&nbsp;*/
#include&nbsp;&lt;errno.h>&nbsp;&nbsp;/*&nbsp;for&nbsp;EAGAIN&nbsp;*/
#define&nbsp;MAX_TRY&nbsp;10
int
lockWholeFile(int&nbsp;fd,&nbsp;int&nbsp;tries)
{
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;limit&nbsp;=&nbsp;(tries)?tries:MAX_TRY;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;try;
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(try&nbsp;=&nbsp;0;&nbsp;try&nbsp;&lt;&nbsp;limit;&nbsp;++try)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;0&nbsp;==&nbsp;flock(fd,&nbsp;LOCK_EX+LOCK_NB)&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;/*&nbsp;mission&nbsp;accomplished&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(errno&nbsp;!=&nbsp;EWOULDBLOCK)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;/*&nbsp;mission&nbsp;impossible&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sginap(1);&nbsp;/*&nbsp;let&nbsp;lock&nbsp;holder&nbsp;run&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;errno;
}
</CODE>
<PARAGRAPH>The following points should be noted about <XREF IDREF="98802" TYPE="TEXT">Example&nbsp;7-4</XREF>:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>The compiler variable _BSD_COMPAT is defined in order to get BSD-compatible definitions from standard header files.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The only use of <FUNCTION>flock()</FUNCTION> is to lock an entire file, so there is no attempt to specify the start or length of a record.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The LOCK_NB flag requests the function to return if the lock cannot be placed. Without this flag the function suspends until the lock can be placed.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="70576">Setting and Removing Record Locks</TITLE><PARAGRAPH>Locking a record is done the same way as locking a file, except that the record does not encompass the entire file contents. This section examines an example problem of dealing with two records (which may be either in the same file or in different files) that must be updated simultaneously so that other processes get a consistent view of the information they contain. This type of problem occurs, for example, when updating the inter-record pointers in a doubly linked list. <INDEXTARGET ID="TIP_3a.flock7"><!-- POSTPROCESSDATA: TIP_3a.flock7|file and record locking:setting locksfile and record locking:removing locks --></PARAGRAPH>
<PARAGRAPH>To deal with multiple locks, consider the following questions:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>What do you want to lock?</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>For multiple locks, in what order do you want to lock and unlock the records?</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>What do you do if you succeed in getting all the required locks?</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>What do you do if you fail to get one or more locks?</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>In managing record locks, you must plan a failure strategy for the case in which you cannot obtain all the required locks. It is because of contention for these records that you have decided to use record locking in the first place. Different programs might<INDEXTARGET ID="TIP_3a.flock8"><!-- POSTPROCESSDATA: TIP_3a.flock8|file and record locking:failure --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>wait a certain amount of time, and try again</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>end the procedure and warn the user</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>let the process sleep until signaled that the lock has been freed</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>a combination of the above</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Look now at the example of inserting an entry into a doubly linked list. All the following examples assume that a record is declared as follows:</PARAGRAPH>
<CODE>
struct record {
.../* data portion of record */...
&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;prev;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;index&nbsp;to&nbsp;previous&nbsp;record&nbsp;in&nbsp;the&nbsp;list&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;next;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;index&nbsp;to&nbsp;next&nbsp;record&nbsp;in&nbsp;the&nbsp;list&nbsp;*/
};
</CODE>
<PARAGRAPH>For the example, assume that the record after which the new record is to be inserted has a read lock on it already. The lock on this record must be promoted to a write lock so that the record may be edited. <XREF IDREF="45802" TYPE="TEXT">Example&nbsp;7-5</XREF> shows a function that can be used for this.</PARAGRAPH>
<CODE><CAPTION LBL="7-5"><PREFIX>Example 7-5 </PREFIX><XREFTARGET ID="45802">Record Locking With Promotion Using fcntl()</CAPTION>/*
||&nbsp;This function is called with a file descriptor and the
|| offsets to three records in it: this, here, and next.
|| The caller is assumed to hold read locks on both here and next.
||&nbsp;This function promotes these locks to write locks.
||&nbsp;If&nbsp;write&nbsp;locks&nbsp;on&nbsp;"here"&nbsp;and&nbsp;"next"&nbsp;are&nbsp;obtained
||&nbsp;&nbsp;&nbsp;&nbsp;Set&nbsp;a&nbsp;write&nbsp;lock&nbsp;on&nbsp;"this".
||&nbsp;&nbsp;&nbsp;&nbsp;Return&nbsp;index&nbsp;to&nbsp;"this"&nbsp;record.
||&nbsp;If&nbsp;any&nbsp;write&nbsp;lock&nbsp;is&nbsp;not&nbsp;obtained:
||&nbsp;&nbsp;&nbsp;&nbsp;Restore&nbsp;read&nbsp;locks&nbsp;on&nbsp;"here"&nbsp;and&nbsp;"next".
||&nbsp;&nbsp;&nbsp;&nbsp;Remove&nbsp;all&nbsp;other&nbsp;locks.
||&nbsp;&nbsp;&nbsp;&nbsp;Return&nbsp;-1.
*/
long&nbsp;set3Locks(int fd, long this, long&nbsp;here,&nbsp;long next)
{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;flock&nbsp;lck;
&nbsp;&nbsp;&nbsp;&nbsp;lck.l_type&nbsp;=&nbsp;F_WRLCK;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;setting&nbsp;a&nbsp;write&nbsp;lock&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;lck.l_whence&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;offsets are absolute&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;lck.l_len&nbsp;=&nbsp;sizeof(struct&nbsp;record);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Promote&nbsp;the lock&nbsp;on&nbsp;"here"&nbsp;to&nbsp;write&nbsp;lock&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;lck.l_start&nbsp;=&nbsp;here;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fcntl(fd,&nbsp;F_SETLKW,&nbsp;&amp;lck)&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(-1);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Lock&nbsp;"this"&nbsp;with&nbsp;write&nbsp;lock&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;lck.l_start&nbsp;=&nbsp;this;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fcntl(fd,&nbsp;F_SETLKW,&nbsp;&amp;lck)&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Failed to lock&nbsp;"this"; return&nbsp;"here"&nbsp;to&nbsp;read&nbsp;lock. */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lck.l_type&nbsp;=&nbsp;F_RDLCK;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lck.l_start&nbsp;=&nbsp;here;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void)&nbsp;fcntl(fd,&nbsp;F_SETLKW,&nbsp;&amp;lck);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(-1);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Promote&nbsp;lock&nbsp;on&nbsp;"next"&nbsp;to&nbsp;write&nbsp;lock&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;lck.l_start&nbsp;=&nbsp;next;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fcntl(fd,&nbsp;F_SETLKW,&nbsp;&amp;lck)&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Failed to promote&nbsp;"next";&nbsp;return&nbsp;"here"&nbsp;to&nbsp;read&nbsp;lock...&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lck.l_type&nbsp;=&nbsp;F_RDLCK;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lck.l_start&nbsp;=&nbsp;here;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void)&nbsp;fcntl(fd,&nbsp;F_SETLK,&nbsp;&amp;lck);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;...and&nbsp;remove&nbsp;lock&nbsp;on&nbsp;"this".&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lck.l_type&nbsp;=&nbsp;F_UNLCK;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lck.l_start&nbsp;=&nbsp;this;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void)&nbsp;fcntl(fd,&nbsp;F_SETLK,&nbsp;&amp;lck);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(-1)
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(this);
}
</CODE>
<PARAGRAPH><INDEXTARGET ID="TIP_3a.flock9"><!-- POSTPROCESSDATA: TIP_3a.flock9|file and record locking:F_SETLK --><XREF IDREF="45802" TYPE="TEXT">Example&nbsp;7-5</XREF> uses the F_SETLKW command to <FUNCTION>fcntl()</FUNCTION>, with the result that the calling process will sleep if there are conflicting locks at any of the three points. If the F_SETLK command was used instead, the <FUNCTION>fcntl()</FUNCTION> system calls would fail if blocked. The program would then have to be changed to handle the blocked condition in each of the error return sections (as in <XREF IDREF="97459" TYPE="TEXT">Example&nbsp;7-2</XREF>).</PARAGRAPH>
<PARAGRAPH>It is possible to unlock or change the type of lock on a subsection of a previously set lock; this may cause an additional lock (two locks for one system call) to be used by the operating system. This occurs if the subsection is from the middle of the previously set lock.</PARAGRAPH>
<PARAGRAPH><XREF IDREF="53572" TYPE="TEXT">Example&nbsp;7-6</XREF> shows a similar example using the <FUNCTION>lockf()</FUNCTION> function. Since it does not support read locks, all (write) locks are referenced generically as locks.</PARAGRAPH>
<CODE><CAPTION LBL="7-6"><PREFIX>Example 7-6 </PREFIX><XREFTARGET ID="53572">Record Locking Using lockf()</CAPTION>/*
||&nbsp;This function is called with a file descriptor and the
|| offsets to three records in it: this, here, and next.
|| The caller is assumed to hold no locks on any of the records.
||&nbsp;This function tries to lock "here" and "next" using lockf().
||&nbsp;If&nbsp;locks&nbsp;on&nbsp;"here"&nbsp;and&nbsp;"next"&nbsp;are&nbsp;obtained
||&nbsp;&nbsp;&nbsp;&nbsp;Set&nbsp;a&nbsp;lock&nbsp;on&nbsp;"this".
||&nbsp;&nbsp;&nbsp;&nbsp;Return&nbsp;index&nbsp;to&nbsp;"this"&nbsp;record.
||&nbsp;If&nbsp;any&nbsp;lock&nbsp;is&nbsp;not&nbsp;obtained:
||&nbsp;&nbsp;&nbsp;&nbsp;Remove&nbsp;all&nbsp;other&nbsp;locks.
||&nbsp;&nbsp;&nbsp;&nbsp;Return&nbsp;-1.
*/
long&nbsp;set3Locks(int fd, long this, long&nbsp;here,&nbsp;long next)
{
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Set a lock&nbsp;on&nbsp;"here"&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;(void) lseek(fd, here, 0);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(lockf(fd, F_LOCK, sizeof(struct record))&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(-1);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Lock&nbsp;"this"&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;(void) lseek(fd, this, 0);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(lockf(fd, F_LOCK, sizeof(struct record))&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Failed to lock&nbsp;"this"; clear&nbsp;"here"&nbsp;lock. */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void) lseek(fd, here, 0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void) lockf(fd, F_ULOCK, sizeof(struct record));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(-1);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Lock "next"&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;(void) lseek(fd, next, 0);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(lockf(fd, F_LOCK, sizeof(struct record))&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Failed to lock&nbsp;"next";&nbsp;release&nbsp;"here"...&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void)&nbsp;lseek(fd,&nbsp;here,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void)&nbsp;lockf(fd,&nbsp;F_ULOCK,&nbsp;sizeof(struct&nbsp;record));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;...and&nbsp;remove&nbsp;lock&nbsp;on&nbsp;"this".&nbsp;&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void)&nbsp;lseek(fd,&nbsp;this,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void)&nbsp;lockf(fd,&nbsp;F_ULOCK,&nbsp;sizeof(struct&nbsp;record));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(-1)
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(this);
}
</CODE>
<PARAGRAPH>Locks are removed in the same manner as they are set; only the lock type is different (F_UNLCK or F_ULOCK). An unlock cannot be blocked by another process. An unlock can affect only locks that were placed by the unlocking process.<INDEXTARGET ID="TIP_3a.flock10"><!-- POSTPROCESSDATA: TIP_3a.flock10|file and record locking:order of lock removallock removal, order --><INDEXTARGET ID="TIP_3a.flock11"><!-- POSTPROCESSDATA: TIP_3a.flock11|file and record locking:F_UNLCKfile and record locking:F_ULOCK --></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="15347">Getting Lock Information</TITLE><PARAGRAPH>You can determine which processes, if any, are blocking a lock from being set. This can be used as a simple test or as a means to find locks on a file. To find this information, set up a lock as in the previous examples and use the F_GETLK command in the <INDEXTARGET ID="TIP_3a.flock12"><!-- POSTPROCESSDATA: TIP_3a.flock12|file and record locking:F_GETLK --><INDEXTARGET ID="TIP_3a.flock13"><!-- POSTPROCESSDATA: TIP_3a.flock13|file and record locking:lock information --><FUNCTION>fcntl()</FUNCTION> call. If the lock passed to <FUNCTION>fcntl()</FUNCTION> would be blocked, the first blocking lock is returned to the process through the structure passed to <FUNCTION>fcntl()</FUNCTION>. That is, the lock data passed to <FUNCTION>fcntl()</FUNCTION> is overwritten by blocking lock information.</PARAGRAPH>
<PARAGRAPH>The returned information includes two pieces of data, <VARIABLE>l_pidf</VARIABLE> and <VARIABLE>l_sysid</VARIABLE>, that are used only with F_GETLK. These fields uniquely identify the process holding the lock. (For systems that do not support a distributed architecture, the value in <VARIABLE>l_sysid</VARIABLE> can be ignored.)</PARAGRAPH>
<PARAGRAPH>If a lock passed to <FUNCTION>fcntl()</FUNCTION> using the F_GETLK command is not blocked by another lock, the <VARIABLE>l_type</VARIABLE> field is changed to F_UNLCK and the remaining fields in the structure are unaffected.</PARAGRAPH>
<PARAGRAPH><XREF IDREF="25012" TYPE="TEXT">Example&nbsp;7-7</XREF> shows how to use this capability to print all the records locked by other processes. Note that if several read locks occur over the same record, only one of these is found.<INDEXTARGET ID="TIP_3a.flock14"><!-- POSTPROCESSDATA: TIP_3a.flock14|file and record locking:multiple read locks --></PARAGRAPH>
<CODE><CAPTION LBL="7-7"><PREFIX>Example 7-7 </PREFIX><XREFTARGET ID="25012">Detecting Contending Locks Using fcntl()</CAPTION>/*
|| This function takes a file descriptor and prints a report showing
|| all locks currently set on that file. The loop variable is the
|| l_start field of the flock structure. The function asks fcntl()
|| for the first lock that would block a lock from l_start to the end
|| of the file (l_len==0). When no lock would block such a lock,
|| the returned l_type contains F_UNLCK and the loop ends.
|| Otherwise the contending lock is displayed, l_start is set to
|| the end-point of that lock, and the loop repeats.
*/
void printAllLocksOn(int fd)
{
&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;flock&nbsp;lck;
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Find&nbsp;and&nbsp;print&nbsp;"write&nbsp;lock"&nbsp;blocked&nbsp;segments&nbsp;of&nbsp;file.&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;(void)&nbsp;printf("sysid&nbsp;pid&nbsp;type&nbsp;start&nbsp;length\n");
&nbsp;&nbsp;&nbsp;&nbsp;lck.l_whence&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;lck.l_start&nbsp;=&nbsp;0L;
&nbsp;&nbsp;&nbsp;&nbsp;lck.l_len&nbsp;=&nbsp;0L;
&nbsp;&nbsp;&nbsp;&nbsp;for( lck.l_type = 0; lck.l_type != F_UNLCK; )
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lck.l_type&nbsp;=&nbsp;F_WRLCK;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void)&nbsp;fcntl(fd,&nbsp;F_GETLK,&nbsp;&amp;lck);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(lck.l_type&nbsp;!=&nbsp;F_UNLCK)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void)&nbsp;printf("%5d&nbsp;%5d&nbsp;%c&nbsp;%8d&nbsp;%8d\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lck.l_sysid,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lck.l_pid,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lck.l_type&nbsp;==&nbsp;F_WRLCK)&nbsp;?&nbsp;'W'&nbsp;:&nbsp;'R',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lck.l_start,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lck.l_len);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(lck.l_len&nbsp;==&nbsp;0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break; /* this lock goes to end of file, stop */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lck.l_start&nbsp;+=&nbsp;lck.l_len;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</CODE>
<PARAGRAPH><FUNCTION>fcntl()</FUNCTION> with the F_GETLK command always returns correctly (that is, it will not sleep or fail) if the values passed to it as arguments are valid.</PARAGRAPH>
<PARAGRAPH>The <INDEXTARGET ID="TIP_3a.flock15"><!-- POSTPROCESSDATA: TIP_3a.flock15|file and record locking:F_TEST --><FUNCTION>lockf()</FUNCTION> function with the F_TEST command can also be used to test if there is a process blocking a lock. This function does not, however, return the information about where the lock actually is and which process owns the lock. <XREF IDREF="69027" TYPE="TEXT">Example&nbsp;7-8</XREF> shows a code fragment that uses <FUNCTION>lockf()</FUNCTION> to test for a lock on a file.</PARAGRAPH>
<CODE><CAPTION LBL="7-8"><PREFIX>Example 7-8 </PREFIX><XREFTARGET ID="69027">Testing for Contending Lock Using lockf()</CAPTION>/*&nbsp;find&nbsp;a&nbsp;blocked&nbsp;record.&nbsp;*/
/*&nbsp;seek&nbsp;to&nbsp;beginning&nbsp;of&nbsp;file&nbsp;*/
(void)&nbsp;lseek(fd,&nbsp;0,&nbsp;0L);
/*&nbsp;set&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;test&nbsp;region&nbsp;to&nbsp;zero
&nbsp;*&nbsp;to&nbsp;test&nbsp;until&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;file&nbsp;address&nbsp;space.
&nbsp;*/
if&nbsp;(lockf(fd,&nbsp;F_TEST,&nbsp;0L)&nbsp;&lt;&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(errno)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;EACCES:
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;EAGAIN:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void)&nbsp;printf("file&nbsp;is&nbsp;locked&nbsp;by&nbsp;another&nbsp;process\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;EBADF:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;bad&nbsp;argument&nbsp;passed&nbsp;to&nbsp;lockf&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("lockf");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;default:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void)&nbsp;printf("lockf:&nbsp;unknown&nbsp;error&nbsp;&lt;%d>\n",&nbsp;errno);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</CODE>
<PARAGRAPH>When a process forks, the child receives a copy of the file descriptors that the parent has opened. The parent and child also share a common file pointer for each file. If the parent seeks to a point in the file, the child's file pointer is also set to that location. Similarly, when a share group of processes is created using <FUNCTION>sproc()</FUNCTION>, and the <FUNCTION>sproc()</FUNCTION> flag PR_SFDS is used to keep the open-file table synchronized for all processes (see the <REFPAGE>sproc(2)</REFPAGE> reference page), then there is a single file pointer for each file and it is shared by every process in the share group.</PARAGRAPH>
<PARAGRAPH>This feature has important implications when using record locking. The current value of the file pointer is used as the reference for the offset of the beginning of the lock, in <FUNCTION>lockf()</FUNCTION> at all times and in <FUNCTION>fcntl()</FUNCTION> when using an <VARIABLE>l_whence</VARIABLE> value of 1. Since there is no way to perform the sequence <VARIABLE>lseek(); fcntl();</VARIABLE> as an atomic operation, there is an obvious potential for race conditions&mdash;a lock might be set using a file pointer that was just changed by another process.</PARAGRAPH>
<PARAGRAPH>The solution is to have the child process close and reopen the file. This creates a distinct file descriptor for the use of that process. Another solution is to always use the <INDEXTARGET ID="TIP_3a.flock16"><!-- POSTPROCESSDATA: TIP_3a.flock16|forkingfile and record locking:forking --><FUNCTION>fcntl()</FUNCTION> function for locking with an <VARIABLE>l_whence</VARIABLE> value of 0 or 2. This makes the locking function independent of the file pointer (processes might still contend for the use of the file pointer for other purposes such as direct-access input).</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="98149">Deadlock Handling</TITLE><PARAGRAPH>A certain level of deadlock detection and avoidance is built into the record locking facility. This deadlock handling provides the same level of protection granted by the <INDEXTARGET ID="TIP_3a.flock17"><!-- POSTPROCESSDATA: TIP_3a.flock17|deadlocksfile and record locking:deadlocks --><ITALICS>/usr/group</ITALICS> standard <FUNCTION>lockf()</FUNCTION> call. This deadlock detection is valid only for processes that are locking files or records on a single system. </PARAGRAPH>
<PARAGRAPH>Deadlocks can potentially occur only when the system is about to put a record locking system call to sleep. A search is made for constraint loops of processes that would cause the system call to sleep indefinitely. If such a situation is found, the locking system call fails and sets <VARIABLE>errno</VARIABLE> to the deadlock error number. </PARAGRAPH>
<PARAGRAPH>If a process wishes to avoid using the system's deadlock detection, it should set its locks using F_GETLK instead of F_GETLKW.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="64660">Enforcing Mandatory Locking <XREFTARGET ID="43386"></TITLE><PARAGRAPH>File locking is usually an in-memory service of the IRIX kernel. The kernel keeps a table of locks that have been placed. Processes anywhere in the system update the table by calling <INDEXTARGET ID="TIP_3a.flock18"><!-- POSTPROCESSDATA: TIP_3a.flock18|file and record locking:mandatoremandatory file locking --><FUNCTION>fcntl()</FUNCTION> or <FUNCTION>lockf()</FUNCTION> to request locks. When all processes that use a file do this, and respect the results, file integrity can be maintained.</PARAGRAPH>
<PARAGRAPH>It is possible to extend file locking by making it mandatory on all processes, whether or not they were designed to be part of the cooperating group. Mandatory locking is enforced by the file I/O function calls. As a result, an independent process that calls <FUNCTION>write()</FUNCTION> to update a locked record is blocked or receives an error code.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>write()</FUNCTION> and other system functions test for a contending lock on a file that has mandatory locking applied. The test is made for every operation on that file. When the caller is a process that is cooperating in the lock, and has already set an appropriate lock, the mandatory test is unnecessary overhead.</PARAGRAPH>
<PARAGRAPH>Mandatory locking is enforced on a file-by-file basis, triggered by a bit in the file inode that is set by <COMMAND>chmod</COMMAND> (see the <REFPAGE>chmod(1)</REFPAGE> and <REFPAGE>chmod(2)</REFPAGE> reference pages). In order to enforce mandatory locking on a particular file, turn on the set-group-ID bit along with a nonexecutable group permission, as in these examples, which are equivalent:</PARAGRAPH>
<CODE>
$ chmod 2644 target.file
$ chmod +l target.file
</CODE>
<PARAGRAPH>The bit must be set before the file is opened; a change has no effect on a file that is already open.</PARAGRAPH>
<PARAGRAPH><XREF IDREF="30370" TYPE="TEXT">Example&nbsp;7-9</XREF> shows a fragment of code that sets mandatory lock mode on a given filename.</PARAGRAPH>
<CODE><CAPTION LBL="7-9"><PREFIX>Example 7-9 </PREFIX><XREFTARGET ID="30370">Setting Mandatory Locking Permission Bits</CAPTION>#include &lt;sys/types.h>
#include &lt;sys/stat.h>
int setMandatoryLocking(char *filename)
{
&nbsp;&nbsp;&nbsp;int mode;
&nbsp;&nbsp;&nbsp;struct stat buf;
&nbsp;&nbsp;&nbsp;if (stat(filename, &amp;buf) &lt; 0)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("stat(2)");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return error;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;mode = buf.st_mode;
&nbsp;&nbsp;&nbsp;/* ensure group execute permission 0010 bit is off */
&nbsp;&nbsp;&nbsp;mode &amp;= ~(S_IEXEC>>3);
&nbsp;&nbsp;&nbsp;/* turn on 'set group id bit' in mode */
&nbsp;&nbsp;&nbsp;mode |= S_ISGID;
&nbsp;&nbsp;&nbsp;if (chmod(filename, mode) &lt; 0)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("chmod(2)");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return error;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;return 0;
}
</CODE>
<PARAGRAPH>When IRIX opens a file, it checks to see whether both of two conditions are true:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Set-group-ID bit is 1.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Group execute permission is 0.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>When both are true, the file is marked for mandatory locking, and each use of <FUNCTION>creat()</FUNCTION>, <FUNCTION>open()</FUNCTION>, <FUNCTION>read()</FUNCTION>, and <FUNCTION>write()</FUNCTION> tests for contending locks.</PARAGRAPH>
<PARAGRAPH>Some points to remember about mandatory locking:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Mandatory locking does not protect against file truncation with the <FUNCTION>truncate()</FUNCTION> function (see the <REFPAGE>truncate(2)</REFPAGE> reference page), which does not look for locks on the truncated portion of the file.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Mandatory locking protects only those portions of a file that are locked. Other portions of the file that are not locked may be accessed according to normal UNIX system file permissions.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Advisory locking is more efficient because a record lock check does not have to be performed for every I/O request.<INDEXTARGET ID="TIP_3a.flock19"><!-- POSTPROCESSDATA: TIP_3a.flock19|file and record locking:efficiency, comparative --></PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="60993">Record Locking Across Multiple Systems</TITLE><PARAGRAPH>Record locking is always effective within a single copy of the IRIX kernel. Locking is effective within a multiprocessor because processes running in different CPUs of the multiprocessor share a single copy of the IRIX kernel.<INDEXTARGET ID="TIP_3a.flock20"><!-- POSTPROCESSDATA: TIP_3a.flock20|file and record locking:across systems --></PARAGRAPH>
<PARAGRAPH>Record locking can be effective on processes that execute in different systems that access a filesystem mounted through NFS. However, there are these drawbacks:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Deadlock detection is not possible between processes in different systems.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>You must make sure that the NFS locking daemon is running in both the NFS client (application) and server systems.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Using record locking on NFS files has a strong impact on performance.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="35973">NFS File Locking</TITLE><PARAGRAPH>When a process running in an NFS client system requests a file or record lock, a complex sequence of events begins. (For details, consult the <INDEXTARGET ID="TIP_3a.flock21"><!-- POSTPROCESSDATA: TIP_3a.flock21|rpc.lockd daemon --><INDEXTARGET ID="TIP_3a.flock22"><!-- POSTPROCESSDATA: TIP_3a.flock22|file and record locking:NFS withNFS and file locking --><REFPAGE>lockd(1M)</REFPAGE> reference page.)</PARAGRAPH>
<PARAGRAPH>First the kernel in the client system receives the lock request and determines that the file resides on a filesystem mounted using NFS. The kernel sends the lock request to a daemon called <COMMAND>rpc.lockd</COMMAND>. This daemon is responsible for communicating lock requests to other systems.</PARAGRAPH>
<PARAGRAPH>The <COMMAND>rpc.lockd</COMMAND> process sends the lock request to the <COMMAND>rpc.lockd</COMMAND> daemon running on the NFS server where the target file is physically mounted. On the server, that <COMMAND>rpc.lockd</COMMAND> issues the lock request locally. The server <COMMAND>rpc.lockd</COMMAND> sends the result, success or failure, back to the client <COMMAND>rpc.lockd</COMMAND>. The result is passed back to the calling process.</PARAGRAPH>
<PARAGRAPH>When the lock succeeds on the server side, <COMMAND>rpc.lockd</COMMAND> on the client system requests another daemon, <COMMAND>rpc.statd</COMMAND>, to monitor the NFS server that implements the lock. If the server fails and then recovers, <COMMAND>rpc.statd</COMMAND> will be informed. It then tries to reestablish all active locks. If the NFS server fails and recovers, and <COMMAND>rpc.lockd</COMMAND> is unable to reestablish a lock, it sends a signal (SIGUSR1) to the process that requested the lock.</PARAGRAPH>
<PARAGRAPH>When a process writes to a write-locked record, the data is sent directly to the NFS server, bypassing the local NFS buffer cache. This can have a significant impact on file performance.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Configuring NFS Locking</TITLE><PARAGRAPH>When <COMMAND>rpc.lockd</COMMAND> is not running in the NFS client system, or in the NFS server system, a cross-system lock cannot be established. In this case, locks are effective within the local system, but are not effective against contending file access from other systems.</PARAGRAPH>
<PARAGRAPH>To discover whether <COMMAND>rpc.lockd</COMMAND> is running, use the <COMMAND>chkconfig</COMMAND> command:</PARAGRAPH>
<EXAMPLE>
% /etc/chkconfig | grep lockd
</EXAMPLE>
<PARAGRAPH>If the returned value is off, <COMMAND>rpc.lockd</COMMAND> is not running and locks have local scope only.</PARAGRAPH>
<PARAGRAPH>To use <COMMAND>rpc.lockd</COMMAND>, the administrator must configure it on as follows:</PARAGRAPH>
<EXAMPLE>
% /etc/chkconfig lockd on
</EXAMPLE>
<PARAGRAPH>Then the system must be rebooted. This must be done on both the NFS file server and on all NFS clients where locks are requested.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Performance Impact</TITLE><PARAGRAPH>Normally, the NFS software uses a data cache to speed access to files. Data read or written to NFS mounted files is held in a memory cache for some time, and access requests to cached data is satisfied from memory instead of being read from the server. Data caching has a major effect on the speed of NFS file access.</PARAGRAPH>
<PARAGRAPH>As soon as any process places a file or record lock on an NFS mounted file, the file is marked as uncachable. All I/O requests for that file bypass the local memory cache and are sent to the NFS server. This ensures consistent results and data integrity. However, it means that every read or write to the file, at any offset, and from any process, incurs a network delay.</PARAGRAPH>
<PARAGRAPH>The file remains uncachable even when the lock is released. The file cannot use the cache again until it has been closed by all processes that have it open. </PARAGRAPH>
</SECTION2>
</SECTION1>
</CHAPTER>
