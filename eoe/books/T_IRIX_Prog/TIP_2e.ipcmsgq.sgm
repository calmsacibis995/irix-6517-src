<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="6"><TITLE><XREFTARGET ID="48324">Message Queues</TITLE><PARAGRAPH>You use a message queue to pass blocks of data between processes or threads without having to share any memory between the processes. One process or thread puts a message into the queue. The message is held in the queue until another process or thread asks for the message.<INDEXTARGET ID="TIP_2e.ipcmsgq1"><!-- POSTPROCESSDATA: TIP_2e.ipcmsgq1|message queue --></PARAGRAPH>
<PARAGRAPH>IRIX supports two implementations of message queues: a POSIX implementation as specified by IEEE standard 1003.1b-1993, and an SVR4 implementation compatible with System V Release 4. Both implementations can be used to coordinate POSIX threads or IRIX processes. This chapter discusses message queues under these headings:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="73455" TYPE="TITLE">&ldquo;Overview of Message Queues&rdquo;</XREF> describes message queues and the differences between the two implementations.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="32730" TYPE="TITLE">&ldquo;POSIX Message Queues&rdquo;</XREF> documents the use of the POSIX implementation.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="34344" TYPE="TITLE">&ldquo;System V Message Queues&rdquo;</XREF> documents the use of the SVR4 implementation.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="73455">Overview of Message Queues</TITLE><PARAGRAPH>A message queue is a software object maintained by the IRIX kernel, logically apart from the address space of any process. When you create a message queue, the queue has a public identifier. (The identifier is a file pathname for POSIX, or an integer for SVR4.) A process uses the identifier to open the queue. When the queue is open, the process can send messages to the queue or receive messages from the queue.<INDEXTARGET ID="TIP_2e.ipcmsgq2"><!-- POSTPROCESSDATA: TIP_2e.ipcmsgq2|message queue:overview of --></PARAGRAPH>
<PARAGRAPH>A message queue has an access mode similar to a file access mode, specifying read and write access for its owner, its owner's group, or all users. A process with an effective user ID giving only read access can only receive messages from the queue. A process with an effective user ID lacking access cannot open the queue.</PARAGRAPH>
<PARAGRAPH>When a process requests a message from a queue and no message is available, the process can be notified immediately with an error code, or it can be suspended until a message is sent.</PARAGRAPH>
<PARAGRAPH>A message queue has a limit on the amount of data that can be queued. (POSIX limits the number of messages; SVR4 limits the total size of queued messages.) When a process sends a message that would exceed the queue's limit, the process can be notified immediately with an error code, or it can be suspended until there is room in the queue.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Implementation Differences</TITLE><PARAGRAPH>The abstract operations that a message queue supports are summarized in <INDEXTARGET ID="TIP_2e.ipcmsgq3"><!-- POSTPROCESSDATA: TIP_2e.ipcmsgq3|message queue:comparing POSIX, SVR4 --><XREF IDREF="11815" TYPE="TABLE">Table&nbsp;6-1</XREF> with the names of the POSIX and SVR4 functions that implement them. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="6-1"><PREFIX>Table 6-1 </PREFIX><XREFTARGET ID="11815"> <EMPHASIS>(continued)        </EMPHASIS>Abstract Operations on a Message Queue</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="162"><PARAGRAPH>Operation</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="110"><PARAGRAPH>POSIX Function</PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="110"><PARAGRAPH>SVR4 Function</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="162"><PARAGRAPH>Gain access to a queue, creating it if it 
does not exist.</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="110"><PARAGRAPH>mq_open(3) </PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="110"><PARAGRAPH>msgget(2) </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="162"><PARAGRAPH>Query attributes of a queue and 
number of pending messages.</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="110"><PARAGRAPH>mq_getattr(3) </PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="110"><PARAGRAPH>msgctl(2) </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="162"><PARAGRAPH>Change attributes of a queue.</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="110"><PARAGRAPH>mq_setattr(3) </PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="110"><PARAGRAPH>msgctl(2) </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="162"><PARAGRAPH>Give up access to a queue.</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="110"><PARAGRAPH>mq_close(3) </PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="110"><PARAGRAPH>n.a.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="162"><PARAGRAPH>Remove a queue from the system.</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="110"><PARAGRAPH>mq_unlink(3), rm(1) </PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="110"><PARAGRAPH>msgctl(2), ipcrm(1) </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="162"><PARAGRAPH>Send a message to a queue.</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="110"><PARAGRAPH>mq_send(3) </PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="110"><PARAGRAPH>msgsnd(2) </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="162"><PARAGRAPH>Receive a message from a queue.</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="110"><PARAGRAPH>mq_receive(3) </PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="110"><PARAGRAPH>msgrcv(2) </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="162"><PARAGRAPH>Request asynchronous notification of a 
message arriving at a queue.</PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="110"><PARAGRAPH>mq_notify(3) </PARAGRAPH>
</CELL>
<CELL LEFT="285" WIDTH="110"><PARAGRAPH>n.a. </PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Both implementations can be used to communicate between POSIX threads and between IRIX processes in any combination. Besides obvious features of syntax, the principal differences between the two implementations are as follows:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>POSIX functions are implemented as library functions in the <FILENAME>libc</FILENAME> library and operate primarily in the user process address space. SVR4 functions are implemented in the kernel, and every operation requires a context switch. This generally results in lower overhead for the POSIX functions.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>The identity of a POSIX or an SVR4 queue is retained over a reboot. The contents of a POSIX queue might or might not survive a reboot, but you should not depend on either type of queue to retain its state after the last program closes it.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>POSIX allows you to set a limit on the number of messages and the size of one message. SVR4 allows you to set a limit on the aggregate size of queued messages, but not on their number or their individual sizes.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>With a POSIX queue, the choice of whether or not operations should block on a full or empty queue is an attribute of the queue descriptor. With SVR4, you specify blocking or nonblocking operation on each send or receive operation.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>POSIX supports asynchronous notification of a message arrival. SVR4 does not.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>SVR4 allows a receiver to request a message from a particular priority class, in effect creating sub-queues within a queue. POSIX supports a priority class on each message, but it always returns the first message of the highest priority class.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Uses of Message Queues</TITLE><PARAGRAPH>You can use message queues in a variety of ways. For example, you can use a message queue to implement the &ldquo;producer-consumer&rdquo; model of cooperating processes or threads. The &ldquo;producer&rdquo; sends its output to the queue; the &ldquo;consumer&rdquo; receives the data from the queue. When one process gets ahead of the other, it is automatically suspended on the queue until the other process catches up.<INDEXTARGET ID="TIP_2e.ipcmsgq4"><!-- POSTPROCESSDATA: TIP_2e.ipcmsgq4|message queue:use of --></PARAGRAPH>
<PARAGRAPH>Another design model, common in real-time programming, is to use message queues to dispatch units of work to waiting processes or threads. A process or thread dedicated to one type of work waits on a message queue. Whenever another process or thread needs a unit of work of that type, it sends the unit to that queue as a message.</PARAGRAPH>
<PARAGRAPH>Another use of a message queue is to regulate the use of a scarce resource, such as the buffers in a pool of buffers. Each resource unit is represented by a message. In order to obtain a unit, you receive one message from the queue. To release a unit for other processes to use, you send the unit message back to the queue.</PARAGRAPH>
<PARAGRAPH>The latter scheme can be used to compensate for a performance problem. The speed of communication through a queue is limited by the fact that every message is copied twice: when a message is sent, it is copied from the sender's buffer to some reserved memory space; when the message is received, it is copied into the buffer supplied by the receiving process or thread. When messages are small (or few in number), copying is not a serious problem.</PARAGRAPH>
<PARAGRAPH>When messages are large, copying can be avoided as follows. Allocate a pool of message buffers. Set up a queue of small messages, each message representing a &ldquo;ticket&rdquo; to use a particular buffer. In order to obtain a buffer, a process receives a message from this queue. The process fills the buffer, then it sends the buffer without copying, by sending only the &ldquo;ticket&rdquo; on another message queue. The process that receives the &ldquo;ticket&rdquo; uses the data in the buffer without needing to copy it, and releases the buffer by sending the &ldquo;ticket&rdquo; to the original queue.&space;</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="32730">POSIX Message Queues</TITLE><PARAGRAPH>The POSIX real-time extensions (detailed in IEEE standard 1003.1b) include support for messages queues. These functions are discussed in the following topics and demonstrated in example programs.<INDEXTARGET ID="TIP_2e.ipcmsgq5"><!-- POSTPROCESSDATA: TIP_2e.ipcmsgq5|message queue:POSIX facilities --></PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Managing Message Queues</TITLE><PARAGRAPH>The POSIX functions for creating, controlling, closing, and removing message queues are summarized in <XREF IDREF="27856" TYPE="TABLE">Table&nbsp;6-2</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="6-2"><PREFIX>Table 6-2 </PREFIX><XREFTARGET ID="27856"> <EMPHASIS>(continued)        </EMPHASIS>POSIX Functions for Managing Message Queues</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="81"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Purpose and Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>mq_open(3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Create a queue if it does not exist, and gain access to it.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>mq_getattr(3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Get information about an open message queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>mq_setattr(3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Change the blocking/nonblocking attribute of an open message queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>mq_close(3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Give up access to a queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><REFPAGE>mq_unlink(3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Remove a message queue from the system when the last process to have it 
open, closes it.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<SECTION3 LBL="" HELPID = ""><TITLE>Creating a Message Queue</TITLE><PARAGRAPH>The <FUNCTION>mq_open()</FUNCTION> function has two purposes. It is used to gain access to a queue that exists, and it can create a queue that does not exist. To create a new queue, call <FUNCTION>mq_open()</FUNCTION> with four arguments as follows (using the names given in the reference page): </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><VARIABLE>mq_name</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>The pathname that the queue will have.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><VARIABLE>oflag</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>A set of flags that includes O_CREAT and may include O_EXCL.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><VARIABLE>mode</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>The access permissions the queue will have.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH><VARIABLE>mq_attr</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Either NULL or the address of an <VARIABLE>mq_attr</VARIABLE> structure specifying the 
queue attributes of maximum message size and maximum messages.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The name of a queue has the same form as a disk filename, and in fact a queue is implemented as a file. This implementation is permitted, but not required, by the POSIX standard. Other implementations might not use it.</PARAGRAPH>
<PARAGRAPH>Once created, a queue is a persistent object that survives until removed. If you want the program to create a queue, use it, and then remove it during termination, you can call <FUNCTION>mq_unlink()</FUNCTION> to remove the queue.</PARAGRAPH>
<PARAGRAPH>The file can retain some queued messages when the queue is not open, so that some queued data can persist beyond the termination of the programs that use the queue. The queued data cannot be trusted after a reboot, because the data might not have been written to disk before the system came down. You should not depend on the state of the message queue after a reboot.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Opening an Existing Queue</TITLE><PARAGRAPH>It is more common to open an existing queue. When the program expects the queue to exist, it omits the O_CREAT flag bit. An error is returned if the queue does not exist, or if the queue exists but the effective user ID or group ID of the program does not allow access to it.</PARAGRAPH>
<PARAGRAPH>The program can specify the O_RDONLY, O_WRONLY, or O_RDWR flag to show its intended use of the queue. Access is controlled by the access permissions of the queue, just as for a file.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Specifying Blocking or Nonblocking Access</TITLE><PARAGRAPH>An important flag when opening a queue is the O_NONBLOCK flag. When the program specifies O_NONBLOCK, it wants an immediate return with an error code (EAGAIN) when it sends a message to a full queue or requests a message from an empty queue. When the program omits O_NONBLOCK, it specifies that it is willing to be suspended in these situations.</PARAGRAPH>
<PARAGRAPH>The O_NONBLOCK flag applies to all operations using the queue descriptor returned by <FUNCTION>mq_open()</FUNCTION>. (The same queue, opened under a different descriptor, can have different blocking behavior.) The blocking behavior can be changed by applying <FUNCTION>mq_setattr()</FUNCTION> to the queue descriptor. If the program normally wants to allow suspension, but in a particular situation wants to avoid suspension, it can apply <FUNCTION>mq_setattr()</FUNCTION> to change the blocking state, and then set it back again.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Using Message Queues</TITLE><PARAGRAPH>The POSIX functions for using an open queue are summarized in <XREF IDREF="46602" TYPE="TABLE">Table&nbsp;6-3</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="6-3"><PREFIX>Table 6-3 </PREFIX><XREFTARGET ID="46602"> <EMPHASIS>(continued)        </EMPHASIS>POSIX Functions for Using Message Queues</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="99"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Purpose and Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>mq_send(3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Send a message to a queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>mq_receive(3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Receive a message from a queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>mq_notify(3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Request asynchronous notification of a message on a queue.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<SECTION3 LBL="" HELPID = ""><TITLE>Sending a Message</TITLE><PARAGRAPH>To send a message to a queue, call <FUNCTION>mq_send()</FUNCTION> specifying the queue, the address and length of the message data, and an integer specifying the priority class of the message. Messages on the queue are retained in arrival sequence within priority classes.</PARAGRAPH>
<PARAGRAPH>The message is copied out of the caller's buffer, so the buffer can be reused immediately after a successful send. The <FUNCTION>mq_send()</FUNCTION> function blocks if the queue is full, unless the O_NONBLOCK attribute is in effect for the queue.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Receiving a Message</TITLE><PARAGRAPH>To receive a message, call <FUNCTION>mq_receive()</FUNCTION> specifying the queue, the address and size of a buffer, and the address of an integer to receive the message's priority. The size of the buffer must be at least as large as the maximum size allowed by that queue. You can learn this size using <FUNCTION>mq_getattr()</FUNCTION> (see <XREF IDREF="94186" TYPE="TEXT">Example&nbsp;6-4</XREF> for an example of this).</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>mq_receive()</FUNCTION> function blocks if the queue is empty, unless O_NONBLOCK is in effect for the queue. The message returned is always the oldest message in the highest priority class.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using Asynchronous Notification</TITLE><PARAGRAPH>Some applications are designed so that each process or thread does nothing but process messages. In a design of this kind, it makes sense for a process or thread to suspend itself when no messages are available on its queue.</PARAGRAPH>
<PARAGRAPH>Other applications are designed so that one process or thread performs multiple tasks besides handling messages, or handles messages from multiple queues. In this kind of program, a process cannot suspend itself on a single message queue. Instead, it needs to do other work and only request a message when a message is available. One way to do this is to set the O_NONBLOCK flag, and to periodically poll for a message by calling <FUNCTION>mq_receive()</FUNCTION> and testing its return code. However, this is inefficient.</PARAGRAPH>
<PARAGRAPH>The POSIX message facility offers the ability to receive an asynchronous notification in the event that a message is posted to an empty queue and no process or thread is suspended waiting for that message. You do this by calling <FUNCTION>mq_notify()</FUNCTION> passing a queue and a <VARIABLE>sigevent_t</VARIABLE> structure. (The <VARIABLE>sigevent_t</VARIABLE> is declared in <FILENAME>sys/signal.h</FILENAME>, which is included by <FILENAME>mqueue.h</FILENAME>.)</PARAGRAPH>
<PARAGRAPH>The <VARIABLE>sigevent_t</VARIABLE> structure allows you to specify either a signal or a callback function. However, only the signal notification (SIGEV_SIGNAL) request is supported by the POSIX message queue implementation.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Example Programs</TITLE><PARAGRAPH>The following programs demonstrate the use of POSIX message queues:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="32185" TYPE="TEXT">Example&nbsp;6-1</XREF> on <XREF IDREF="32185" TYPE="TEXT">page&nbsp;146</XREF> demonstrates the use of <FUNCTION>mq_getattr()</FUNCTION> to query the attributes of a queue.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="15110" TYPE="TEXT">Example&nbsp;6-2</XREF> on <XREF IDREF="15110" TYPE="TEXT">page&nbsp;147</XREF> demonstrates the use of <FUNCTION>mq_open()</FUNCTION> to create or access a message queue.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="11640" TYPE="TEXT">Example&nbsp;6-3</XREF> on <XREF IDREF="11640" TYPE="TEXT">page&nbsp;149</XREF> demonstrates the use of <FUNCTION>mq_send()</FUNCTION> to put messages onto a message queue.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="94186" TYPE="TEXT">Example&nbsp;6-4</XREF> on <XREF IDREF="94186" TYPE="TEXT">page&nbsp;151</XREF> demonstrates the use of <FUNCTION>mq_receive()</FUNCTION> to take messages from a message queue.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The four example programs have a consistent design and use consistent command-line arguments. Each accepts optional arguments that allow you to exercise most features of each function, including most error return codes. The following is a simple example of use. First, a queue is created:</PARAGRAPH>
<CODE>
$ mq_open -p 0664 -b 128 -m 32 -c -x /var/tmp/Q32x128
flags: 0x0  maxmsg: 32  msgsize: 128  curmsgs: 0
</CODE>
<PARAGRAPH>An attempt is made to send a message that is larger than the queue maximum size:</PARAGRAPH>
<CODE>
$ mq_send -b 129 /var/tmp/Q32x128
mq_send(): Inappropriate message buffer length
</CODE>
<PARAGRAPH>A message of appropriate size is sent. Its presence on the queue is verified using <FUNCTION>mq_getattr()</FUNCTION>:</PARAGRAPH>
<CODE>
$ mq_send -b 128 -p 7 /var/tmp/Q32x128
$ mq_attr /var/tmp/Q32x128
flags: 0x0  maxmsg: 32  msgsize: 128  curmsgs: 1
</CODE>
<PARAGRAPH>An attempt is made to send a message with an illegal priority (32 is the highest allowed):</PARAGRAPH>
<CODE>
$ mq_send -p 99 /var/tmp/Q32x128
mq_send(): Invalid argument
</CODE>
<PARAGRAPH>A message is sent with a valid priority:</PARAGRAPH>
<CODE>
$ mq_send -p 19 /var/tmp/Q32x128
$ mq_attr /var/tmp/Q32x128
flags: 0x0  maxmsg: 32  msgsize: 128  curmsgs: 2
</CODE>
<PARAGRAPH>The two messages are received. The one with higher priority is received first:</PARAGRAPH>
<CODE>
$ mq_receive -c 2 /var/tmp/Q32x128
1: priority 19  len 63 text 00001 Fri Jun 14 09:19:12 1996
2: priority 7  len 128 text 00001 Fri Jun 14 09:17:15 1996
</CODE>
<PARAGRAPH>Another message is requested. Since the O_NONBLOCK flag is used, the absence of any message is reported as an error code, rather than suspending the process:</PARAGRAPH>
<CODE>
$ mq_receive -n /var/tmp/Q32x128
mq_receive(): Resource temporarily unavailable
</CODE>
<SECTION3 LBL="" HELPID = ""><TITLE>Example&nbsp;of&nbsp;mq_getattr()</TITLE><PARAGRAPH>The program <COMMAND>mq_attr</COMMAND> in <XREF IDREF="32185" TYPE="TEXT">Example&nbsp;6-1</XREF> uses <FUNCTION>mq_getattr()</FUNCTION> to get and display the queue attributes. Only one command-line argument is accepted: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>path</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The file pathname of the queue must be given following all options.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<CODE><CAPTION LBL="6-1"><PREFIX>Example 6-1 </PREFIX><XREFTARGET ID="32185">Program&nbsp;to&nbsp;Demonstrate&nbsp;mq_getattr()&nbsp;and&nbsp;mq_setattr()</CAPTION>/*
||&nbsp;Program&nbsp;to&nbsp;test&nbsp;mq_getattr(3),&nbsp;displaying&nbsp;queue&nbsp;information.
||&nbsp;&nbsp;&nbsp;&nbsp;mq_attr&nbsp;&lt;path>
||&nbsp;&nbsp;&nbsp;&nbsp;&lt;path>&nbsp;&nbsp;&nbsp;pathname&nbsp;of&nbsp;the&nbsp;queue,&nbsp;which&nbsp;must&nbsp;exist
*/
#include&nbsp;&lt;mqueue.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;message&nbsp;queue&nbsp;stuff&nbsp;*/
#include&nbsp;&lt;errno.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;errno&nbsp;and&nbsp;perror&nbsp;*/
#include&nbsp;&lt;fcntl.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;O_RDONLY&nbsp;*/
#include&nbsp;&lt;stdio.h>
int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;**argv)
{
&nbsp;&nbsp;&nbsp;mqd_t&nbsp;mqd;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;queue&nbsp;descriptor&nbsp;*/
&nbsp;&nbsp;&nbsp;struct&nbsp;mq_attr&nbsp;obuf;&nbsp;/*&nbsp;output&nbsp;attr&nbsp;struct&nbsp;for&nbsp;getattr&nbsp;*/
&nbsp;&nbsp;&nbsp;if&nbsp;(argc&nbsp;&lt;&nbsp;2)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("A&nbsp;pathname&nbsp;of&nbsp;a&nbsp;message&nbsp;queue&nbsp;is&nbsp;required\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;mqd&nbsp;=&nbsp;mq_open(argv[1],O_RDONLY);
&nbsp;&nbsp;&nbsp;if&nbsp;(-1&nbsp;!=&nbsp;mqd)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!&nbsp;mq_getattr(mqd,&amp;obuf)&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("flags:&nbsp;0x%x&nbsp;&nbsp;maxmsg:&nbsp;%d&nbsp;&nbsp;msgsize:&nbsp;%d&nbsp;&nbsp;curmsgs:&nbsp;%d\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obuf.mq_flags,&nbsp;obuf.mq_maxmsg,&nbsp;obuf.mq_msgsize,&nbsp;obuf.mq_curmsgs);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("mq_getattr()");
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("mq_open()");
}
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Example of mq_open()</TITLE><PARAGRAPH>The program <COMMAND>mq_open</COMMAND> in <XREF IDREF="15110" TYPE="TEXT">Example&nbsp;6-2</XREF> allows you to create a message queue from the command line. The following command-line arguments are supported: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>path</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The file pathname of the queue must be given, following all options.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>-p <VARIABLE>perms</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Access permissions to set, for example, <COMMAND>-p 0664</COMMAND>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>-b <VARIABLE>bytes</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The maximum message size this queue allows, for example, <COMMAND>-b 256</COMMAND>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>-m <VARIABLE>msgs</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>The maximum number of messages that can be pending on this queue, 
for example, <COMMAND>-m 64</COMMAND>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>-c </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Use the O_CREAT flag to create the queue if it doesn't exist.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>-x </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Use the O_EXCL flag to require that the queue not exist.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<CODE><CAPTION LBL="6-2"><PREFIX>Example 6-2 </PREFIX><XREFTARGET ID="15110">Program to Demonstrate mq_open()</CAPTION>/*
||&nbsp;Program&nbsp;to&nbsp;test&nbsp;mq_open(3).
||&nbsp;&nbsp;&nbsp;&nbsp;mq_open&nbsp;&nbsp;[-p&nbsp;&lt;perms>]&nbsp;[-b&nbsp;&lt;bytes>]&nbsp;[-m&nbsp;&lt;msgs>]&nbsp;[-c]&nbsp;[-x]&nbsp;&lt;path>
||&nbsp;&nbsp;&nbsp;&nbsp;-p&nbsp;&lt;perms>&nbsp;&nbsp;access&nbsp;mode&nbsp;to&nbsp;use&nbsp;when&nbsp;creating,&nbsp;default&nbsp;0600
||&nbsp;&nbsp;&nbsp;&nbsp;-b&nbsp;&lt;bytes>&nbsp;&nbsp;maximum&nbsp;message&nbsp;size&nbsp;to&nbsp;set,&nbsp;default&nbsp;MQ_DEF_MSGSIZE
||&nbsp;&nbsp;&nbsp;&nbsp;-m&nbsp;&lt;msgs>&nbsp;&nbsp;&nbsp;maximum&nbsp;messages&nbsp;on&nbsp;the&nbsp;queue,&nbsp;default&nbsp;MQ_DEF_MAXMSG
||&nbsp;&nbsp;&nbsp;&nbsp;-f&nbsp;&lt;flags>&nbsp;&nbsp;flags&nbsp;to&nbsp;use&nbsp;with&nbsp;mq_open,&nbsp;including:
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;O_CREAT
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;O_EXCL
||&nbsp;&nbsp;&nbsp;&nbsp;&lt;path>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;pathname&nbsp;of&nbsp;the&nbsp;queue,&nbsp;required
||&nbsp;Numeric&nbsp;arguments&nbsp;can&nbsp;be&nbsp;given&nbsp;in&nbsp;any&nbsp;form&nbsp;supported&nbsp;by&nbsp;strtoul(3).
*/
#include&nbsp;&lt;mqueue.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;message&nbsp;queue&nbsp;stuff&nbsp;*/
#define&nbsp;MQ_DEF_MSGSIZE&nbsp;1024
#define&nbsp;MQ_DEF_MAXMSG&nbsp;16
#include&nbsp;&lt;unistd.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;for&nbsp;getopt()&nbsp;*/
#include&nbsp;&lt;errno.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;errno&nbsp;and&nbsp;perror&nbsp;*/
#include&nbsp;&lt;fcntl.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;O_flags&nbsp;*/
#include&nbsp;&lt;stdio.h>
int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;**argv)
{
&nbsp;&nbsp;&nbsp;int&nbsp;perms&nbsp;=&nbsp;0600;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;permissions&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;oflags&nbsp;=&nbsp;O_RDWR;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;flags:&nbsp;O_CREAT&nbsp;+&nbsp;O_EXCL&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;rd=0,&nbsp;wr=0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;-r&nbsp;and&nbsp;-w&nbsp;options&nbsp;*/
&nbsp;&nbsp;&nbsp;mqd_t&nbsp;mqd;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;returned&nbsp;msg&nbsp;queue&nbsp;descriptor&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;c;
&nbsp;&nbsp;&nbsp;char&nbsp;*path;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;->first&nbsp;non-option&nbsp;argument&nbsp;*/
&nbsp;&nbsp;&nbsp;struct&nbsp;mq_attr&nbsp;buf;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;buffer&nbsp;for&nbsp;stat&nbsp;info&nbsp;*/
&nbsp;&nbsp;&nbsp;buf.mq_msgsize&nbsp;=&nbsp;MQ_DEF_MSGSIZE;
&nbsp;&nbsp;&nbsp;buf.mq_maxmsg&nbsp;=&nbsp;MQ_DEF_MAXMSG;
&nbsp;&nbsp;&nbsp;while&nbsp;(&nbsp;-1&nbsp;!=&nbsp;(c&nbsp;=&nbsp;getopt(argc,argv,"p:b:m:cx"))&nbsp;)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(c)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'p':&nbsp;/*&nbsp;permissions&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perms&nbsp;=&nbsp;(int)&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'b':&nbsp;/*&nbsp;message&nbsp;size&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.mq_msgsize&nbsp;=&nbsp;(int)&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'m':&nbsp;/*&nbsp;max&nbsp;messages&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.mq_maxmsg&nbsp;=&nbsp;(int)&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'c':&nbsp;/*&nbsp;use&nbsp;O_CREAT&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oflags&nbsp;|=&nbsp;O_CREAT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'x':&nbsp;/*&nbsp;use&nbsp;O_EXCL&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oflags&nbsp;|=&nbsp;O_EXCL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;/*&nbsp;unknown&nbsp;or&nbsp;missing&nbsp;argument&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;switch&nbsp;*/
&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;while&nbsp;*/
&nbsp;&nbsp;&nbsp;if&nbsp;(optind&nbsp;&lt;&nbsp;argc)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path&nbsp;=&nbsp;argv[optind];&nbsp;/*&nbsp;first&nbsp;non-option&nbsp;argument&nbsp;*/
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;printf("Queue&nbsp;pathname&nbsp;required\n");&nbsp;return&nbsp;-1;&nbsp;}
&nbsp;&nbsp;&nbsp;mqd&nbsp;=&nbsp;mq_open(path,oflags,perms,&amp;buf);
&nbsp;&nbsp;&nbsp;if&nbsp;(-1&nbsp;!=&nbsp;mqd)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;!&nbsp;mq_getattr(mqd,&amp;buf)&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("flags:&nbsp;0x%x&nbsp;&nbsp;maxmsg:&nbsp;%d&nbsp;&nbsp;msgsize:&nbsp;%d&nbsp;&nbsp;curmsgs:&nbsp;%d\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.mq_flags,&nbsp;buf.mq_maxmsg,&nbsp;buf.mq_msgsize,&nbsp;buf.mq_curmsgs);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("mq_getattr()");
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("mq_open()");
}
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Example&nbsp;of&nbsp;mq_send()</TITLE><PARAGRAPH>The <COMMAND>mq_send</COMMAND> program in <XREF IDREF="11640" TYPE="TEXT">Example&nbsp;6-3</XREF> allows you to send from 1 to 9999 messages to a queue from the command line. The following command line arguments are accepted: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>path</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>The file pathname of the queue must be given following all options.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-b <VARIABLE>bytes</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Size of each message, for example <COMMAND>-b 0x200</COMMAND>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-c <VARIABLE>count</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Number of messages to send. The default is 1.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-p <VARIABLE>priority </VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Numeric priority of message to send. Numbers from 0 to 32 are allowed by 
<FUNCTION>mq_send()</FUNCTION>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-n </PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Use the O_NONBLOCK flag with <FUNCTION>mq_open()</FUNCTION>.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The <VARIABLE>count</VARIABLE> argument is limited to 99,999 so that the message text will not exceed 32 bytes, the (arbitrary) minimum message size the program defines.</PARAGRAPH>
<CODE><CAPTION LBL="6-3"><PREFIX>Example 6-3 </PREFIX><XREFTARGET ID="11640">Program&nbsp;to&nbsp;Demonstrate&nbsp;mq_send()</CAPTION>/*
||&nbsp;Program&nbsp;to&nbsp;test&nbsp;mq_send(3)
||&nbsp;&nbsp;&nbsp;&nbsp;mq_send&nbsp;[-p&nbsp;&lt;priority>]&nbsp;[-b&nbsp;&lt;bytes>]&nbsp;[-c&nbsp;&lt;count>]&nbsp;[-n]&nbsp;&lt;path>
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-p&nbsp;&lt;priority>&nbsp;&nbsp;priority&nbsp;code&nbsp;to&nbsp;use,&nbsp;default&nbsp;0
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-b&nbsp;&lt;bytes>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size&nbsp;of&nbsp;the&nbsp;message,&nbsp;default&nbsp;64,&nbsp;min&nbsp;32
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-c&nbsp;&lt;count>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number&nbsp;of&nbsp;messages&nbsp;to&nbsp;send,&nbsp;default&nbsp;1,&nbsp;max&nbsp;9999
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;O_NONBLOCK&nbsp;flag&nbsp;in&nbsp;open
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;path>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path&nbsp;to&nbsp;queue,&nbsp;required
||&nbsp;The&nbsp;program&nbsp;sends&nbsp;&lt;count>&nbsp;messages&nbsp;of&nbsp;&lt;bytes>&nbsp;each&nbsp;at&nbsp;&lt;priority>.
||&nbsp;Each&nbsp;message&nbsp;is&nbsp;an&nbsp;ASCII&nbsp;string&nbsp;containing&nbsp;the&nbsp;time&nbsp;and&nbsp;date&nbsp;and
||&nbsp;a&nbsp;serial&nbsp;number&nbsp;1..&lt;count>.&nbsp;The&nbsp;minimum&nbsp;message&nbsp;is&nbsp;32&nbsp;bytes.
*/
#include&nbsp;&lt;mqueue.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;message&nbsp;queue&nbsp;stuff&nbsp;*/
#include&nbsp;&lt;unistd.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;for&nbsp;getopt()&nbsp;*/
#include&nbsp;&lt;errno.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;errno&nbsp;and&nbsp;perror&nbsp;*/
#include&nbsp;&lt;time.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;time(2)&nbsp;and&nbsp;ctime_r(3)&nbsp;*/
#include&nbsp;&lt;fcntl.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;O_WRONLY&nbsp;*/
#include&nbsp;&lt;stdlib.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;calloc(3)&nbsp;*/
#include&nbsp;&lt;stdio.h>
int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;**argv)
{
&nbsp;&nbsp;&nbsp;char&nbsp;*path;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;->&nbsp;first&nbsp;non-option&nbsp;argument&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;oflags&nbsp;=&nbsp;O_WRONLY;&nbsp;&nbsp;/*&nbsp;open&nbsp;flags,&nbsp;O_NONBLOCK&nbsp;may&nbsp;be&nbsp;added&nbsp;*/
&nbsp;&nbsp;&nbsp;mqd_t&nbsp;mqd;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;queue&nbsp;descriptor&nbsp;from&nbsp;mq_open&nbsp;*/
&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;msg_prio&nbsp;=&nbsp;0;&nbsp;/*&nbsp;message&nbsp;priority&nbsp;to&nbsp;use&nbsp;*/
&nbsp;&nbsp;&nbsp;size_t&nbsp;msglen&nbsp;=&nbsp;64;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;message&nbsp;size&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;count&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;number&nbsp;of&nbsp;messages&nbsp;to&nbsp;send&nbsp;*/
&nbsp;&nbsp;&nbsp;char&nbsp;*msgptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;->&nbsp;allocated&nbsp;message&nbsp;space&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;c;
&nbsp;&nbsp;&nbsp;while&nbsp;(&nbsp;-1&nbsp;!=&nbsp;(c&nbsp;=&nbsp;getopt(argc,argv,"p:b:c:n"))&nbsp;)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(c)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'p':&nbsp;/*&nbsp;priority&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg_prio&nbsp;=&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'b':&nbsp;/*&nbsp;bytes&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msglen&nbsp;=&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(msglen&lt;32)&nbsp;msglen&nbsp;=&nbsp;32;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'c':&nbsp;/*&nbsp;count&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(count&nbsp;>&nbsp;99999)&nbsp;count&nbsp;=&nbsp;99999;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'n':&nbsp;/*&nbsp;use&nbsp;nonblock&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oflags&nbsp;|=&nbsp;O_NONBLOCK;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;/*&nbsp;unknown&nbsp;or&nbsp;missing&nbsp;argument&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if&nbsp;(optind&nbsp;&lt;&nbsp;argc)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path&nbsp;=&nbsp;argv[optind];&nbsp;/*&nbsp;first&nbsp;non-option&nbsp;argument&nbsp;*/
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;printf("Queue&nbsp;pathname&nbsp;required\n");&nbsp;return&nbsp;-1;&nbsp;}
&nbsp;&nbsp;&nbsp;msgptr&nbsp;=&nbsp;calloc(1,msglen);
&nbsp;&nbsp;&nbsp;mqd&nbsp;=&nbsp;mq_open(path,oflags);
&nbsp;&nbsp;&nbsp;if&nbsp;(-1&nbsp;!=&nbsp;mqd)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;stime[26];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;time_t&nbsp;tm&nbsp;=&nbsp;time(NULL);&nbsp;/*&nbsp;current&nbsp;time&nbsp;value&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void)ctime_r&nbsp;(&amp;tm,stime);&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;formatted&nbsp;time&nbsp;string&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stime[24]&nbsp;=&nbsp;'\0'&nbsp;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;drop&nbsp;annoying&nbsp;\n&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(&nbsp;c=1;&nbsp;c&lt;=count;&nbsp;++c)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(msgptr,"%05d&nbsp;%s",c,stime);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;mq_send(mqd,msgptr,msglen,msg_prio)&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("mq_send()");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("mq_open(O_WRONLY)");
}
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Example&nbsp;of&nbsp;mq_receive()</TITLE><PARAGRAPH>The <COMMAND>mq_receive</COMMAND> program in <XREF IDREF="94186" TYPE="TEXT">Example&nbsp;6-4</XREF> allows you to receive and display messages from a queue. These command-line arguments are accepted: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH><VARIABLE>path</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>The file pathname of the queue must be given following all options.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-c <VARIABLE>count</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Number of messages to send. The default is 1.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-q </PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Tells program not to display a line for each message received.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-n </PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Use the O_NONBLOCK flag with <FUNCTION>mq_open()</FUNCTION>.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>You can use the <COMMAND>-q</COMMAND> option to keep the program from displaying messages. Do this when receiving a large number of messages, for example, to test performance.</PARAGRAPH>
<CODE><CAPTION LBL="6-4"><PREFIX>Example 6-4 </PREFIX><XREFTARGET ID="94186">Program&nbsp;to&nbsp;Demonstrate&nbsp;mq_receive()</CAPTION>/*
||&nbsp;Program&nbsp;to&nbsp;test&nbsp;mq_receive(3)
||&nbsp;&nbsp;&nbsp;&nbsp;mq_receive&nbsp;[-c&nbsp;&lt;count>]&nbsp;[-n]&nbsp;[-q]&nbsp;&lt;path>
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-c&nbsp;&lt;count>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number&nbsp;of&nbsp;messages&nbsp;to&nbsp;request,&nbsp;default&nbsp;1
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;O_NONBLOCK&nbsp;flag&nbsp;on&nbsp;open
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quiet,&nbsp;do&nbsp;not&nbsp;display&nbsp;messages
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;path>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path&nbsp;to&nbsp;message&nbsp;queue,&nbsp;required
||&nbsp;The&nbsp;program&nbsp;calls&nbsp;mq_receive&nbsp;&lt;count>&nbsp;times&nbsp;or&nbsp;until&nbsp;an&nbsp;error&nbsp;occurs.
*/
#include&nbsp;&lt;mqueue.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;message&nbsp;queue&nbsp;stuff&nbsp;*/
#include&nbsp;&lt;unistd.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;for&nbsp;getopt()&nbsp;*/
#include&nbsp;&lt;errno.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;errno&nbsp;and&nbsp;perror&nbsp;*/
#include&nbsp;&lt;fcntl.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;O_RDONLY&nbsp;*/
#include&nbsp;&lt;stdlib.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;calloc(3)&nbsp;*/
#include&nbsp;&lt;stdio.h>
int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;**argv)
{
&nbsp;&nbsp;&nbsp;char&nbsp;*path;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;->&nbsp;first&nbsp;non-option&nbsp;argument&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;oflags&nbsp;=&nbsp;O_RDONLY;&nbsp;&nbsp;/*&nbsp;open&nbsp;flags,&nbsp;O_NONBLOCK&nbsp;may&nbsp;be&nbsp;added&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;quiet&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;-q&nbsp;option&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;count&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;number&nbsp;of&nbsp;messages&nbsp;to&nbsp;request&nbsp;*/
&nbsp;&nbsp;&nbsp;mqd_t&nbsp;mqd;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;queue&nbsp;descriptor&nbsp;from&nbsp;mq_open&nbsp;*/
&nbsp;&nbsp;&nbsp;char&nbsp;*msgptr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;->&nbsp;allocated&nbsp;message&nbsp;space&nbsp;*/
&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;msg_prio;&nbsp;&nbsp;/*&nbsp;received&nbsp;message&nbsp;priority&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;c,&nbsp;ret;
&nbsp;&nbsp;&nbsp;struct&nbsp;mq_attr&nbsp;obuf;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;output&nbsp;of&nbsp;mq_getattr():&nbsp;mq_msgsize&nbsp;*/
&nbsp;&nbsp;&nbsp;while&nbsp;(&nbsp;-1&nbsp;!=&nbsp;(c&nbsp;=&nbsp;getopt(argc,argv,"c:nq"))&nbsp;)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(c)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'c':&nbsp;/*&nbsp;count&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'q':&nbsp;/*&nbsp;quiet&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quiet&nbsp;=&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'n':&nbsp;/*&nbsp;nonblock&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oflags&nbsp;|=&nbsp;O_NONBLOCK;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;/*&nbsp;unknown&nbsp;or&nbsp;missing&nbsp;argument&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if&nbsp;(optind&nbsp;&lt;&nbsp;argc)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path&nbsp;=&nbsp;argv[optind];&nbsp;/*&nbsp;first&nbsp;non-option&nbsp;argument&nbsp;*/
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;printf("Queue&nbsp;pathname&nbsp;required\n");&nbsp;return&nbsp;-1;&nbsp;}
&nbsp;&nbsp;&nbsp;mqd&nbsp;=&nbsp;mq_open(path,oflags);
&nbsp;&nbsp;&nbsp;if&nbsp;(-1&nbsp;!=&nbsp;mqd)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!&nbsp;(mq_getattr(mqd,&amp;obuf))&nbsp;)&nbsp;/*&nbsp;get&nbsp;max&nbsp;message&nbsp;size&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msgptr&nbsp;=&nbsp;calloc(1,obuf.mq_msgsize);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(&nbsp;c=1;&nbsp;c&lt;=count;&nbsp;++c)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;mq_receive(mqd,msgptr,obuf.mq_msgsize,&amp;msg_prio);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ret&nbsp;>=&nbsp;0)&nbsp;/*&nbsp;got&nbsp;a&nbsp;message&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!quiet)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;isascii(*msgptr)&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%d:&nbsp;priority&nbsp;%ld&nbsp;&nbsp;len&nbsp;%d&nbsp;text&nbsp;%-32.32s\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c,&nbsp;msg_prio,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msgptr);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%d:&nbsp;priority&nbsp;%ld&nbsp;&nbsp;len&nbsp;%d&nbsp;(nonascii)\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c,&nbsp;&nbsp;msg_prio,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;/*&nbsp;an&nbsp;error&nbsp;on&nbsp;receive,&nbsp;stop&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("mq_receive()");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;for&nbsp;c&nbsp;&lt;=&nbsp;count&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;if&nbsp;getattr&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("mq_getattr()");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;if&nbsp;open&nbsp;*/
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("mq_open(O_WRONLY)");
} &space;
</CODE>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="34344">System V Message Queues</TITLE><PARAGRAPH>IRIX contains an implementation of message queues compatible with UNIX System&nbsp;V Release 4 (SVR4). These message queue functions are demonstrated in example programs in this section.<INDEXTARGET ID="TIP_2e.ipcmsgq6"><!-- POSTPROCESSDATA: TIP_2e.ipcmsgq6|message queue:SVR4 facilities --></PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE>Managing SVR4 Message Queues</TITLE><PARAGRAPH>The functions used to create and control SVR4 message queues are summarized in <XREF IDREF="49473" TYPE="TABLE">Table&nbsp;6-4</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="6-4"><PREFIX>Table 6-4 </PREFIX><XREFTARGET ID="49473"> <EMPHASIS>(continued)        </EMPHASIS>SVR4 Functions for Managing Message Queues</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="99"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Purpose and Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>msgget(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Create a message queue if it does not exist, and gain access to it.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>msgctl(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Query the status of a queue, change its owner ID or access permissions, 
or remove it from the system.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Unlike a POSIX message queue, whose name is also a filename, the external name of an SVR4 message queue is an integer held in an IPC name table (see <XREF IDREF="10403" TYPE="TITLE">&ldquo;SVR4 IPC Name Space&rdquo;</XREF>). You specify this key when creating the message queue, and again whenever you access it for use.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Creating a Message Queue</TITLE><PARAGRAPH>The <FUNCTION>msgget()</FUNCTION> function has two purposes. It is used to gain access to a queue that exists, and it can create a queue that does not exist. To create a new queue, call <FUNCTION>msgget()</FUNCTION> with the following arguments: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>key</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>An integer key that is not defined at this time.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><VARIABLE>msgflag</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>A set of flags that includes IPC_CREAT and may include IPC_EXCL. 
This value also contains the access permission bits.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>For example, a call to create a queue might be written as follows:</PARAGRAPH>
<CODE>
ret = msgget(PROJ_KEY,IPC_CREAT+IPC_EXCL+0660);
</CODE>
<PARAGRAPH>This example relies on a constant PROJ_KEY to supply the key. Another option is to use the <FUNCTION>ftok()</FUNCTION> library function (see the <REFPAGE>ftok(3C)</REFPAGE> reference page).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Accessing an Existing Queue</TITLE><PARAGRAPH>When the program expects the queue to exist, it calls <FUNCTION>msgget()</FUNCTION> passing the expected key value and omitting the IPC_CREAT flag. If the queue does not exist, or if the effective user and group ID of the process are not allowed access to the queue, an error is returned. The program receives read-only or read-write access depending on the access permissions of the queue, just as with a file.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Modifying a Message Queue</TITLE><PARAGRAPH>You can use <FUNCTION>msgctl()</FUNCTION> to modify four attributes of a queue after creating or accessing it:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>the user ID and group ID that owns the queue</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the access permissions</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>the limit on the total size of all queued messages</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The size limit on a new queue is set to the system limit (32,768 bytes as of IRIX       6.2). This determines how many messages can be waiting, unreceived, on the queue. That in turn determines how far the message-sending process can get ahead of the message-reading process. You can lower the limit to limit the sending process or thread more closely to the speed of the receiving process or thread.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Removing a Message Queue</TITLE><PARAGRAPH>You can remove a message queue using the <COMMAND>ipcrm</COMMAND> command (see the <REFPAGE>ipcrm(1)</REFPAGE> reference page), or by calling <FUNCTION>msgctl()</FUNCTION> and passing the IPC_RMID command code. In many cases, a message queue is meant for use within the scope of one program only, and you do not want the queue to persist after the termination of that program. Call <FUNCTION>msgctl()</FUNCTION> to remove the queue as part of termination.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Using SVR4 Message Queues</TITLE><PARAGRAPH>The SVR4 functions for using message queues are summarized in <XREF IDREF="97265" TYPE="TABLE">Table&nbsp;6-5</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="6-5"><PREFIX>Table 6-5 </PREFIX><XREFTARGET ID="97265"> <EMPHASIS>(continued)        </EMPHASIS>SVR4 Functions for Using Message Queues</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="99"><PARAGRAPH>Function Name</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Purpose and Operation</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>msgsnd(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Send a message to a queue.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="99"><PARAGRAPH><REFPAGE>msgrcv(2)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="105" WIDTH="288"><PARAGRAPH>Receive a message from a queue.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<SECTION3 LBL="" HELPID = ""><TITLE>Sending a Message</TITLE><PARAGRAPH>To send a message to a queue, call <FUNCTION>msgsnd()</FUNCTION> and specify the queue, the address and length of the message data, and a flag number that can contain IPC_NOWAIT. The message buffer contains an integer specifying the &ldquo;type&rdquo; of the message. Messages on the queue are retained in arrival sequence within types.</PARAGRAPH>
<PARAGRAPH>The message is copied out of the caller's buffer, so the buffer can be reused immediately after a successful send. If the queue is full, the <FUNCTION>msgsnd()</FUNCTION> function blocks unless the IPC_NOWAIT flag is passed.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Receiving a Message</TITLE><PARAGRAPH>To receive a message, call <FUNCTION>msgrcv()</FUNCTION> and specify the queue, the address and size of a buffer, a number for the desired message type, and a flag value. If the queue is empty, the <FUNCTION>msgrcv()</FUNCTION> function blocks unless the IPC_NOWAIT flag is passed. If the message buffer is not as large as the message, an error is returned unless the IPC_NOERROR flag is passed. Then the message is simply truncated to fit the buffer.</PARAGRAPH>
<PARAGRAPH>The type value can be 0, to specify &ldquo;any type,&rdquo; or it can be a specific (positive) type number to select the first number of that type. Finally, it can be a negative value to specify &ldquo;any type less than or equal.&rdquo;</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>Example Programs</TITLE><PARAGRAPH>The following programs demonstrate the use of SVR4 message queues:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="49425" TYPE="TEXT">Example&nbsp;6-5</XREF> demonstrates the use of <FUNCTION>msgget()</FUNCTION> to create or access a queue.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="23686" TYPE="TEXT">Example&nbsp;6-6</XREF> demonstrates the use of <FUNCTION>msgctl()</FUNCTION> to query or modify a queue.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="43282" TYPE="TEXT">Example&nbsp;6-7</XREF> demonstrates the use of <FUNCTION>msgsnd()</FUNCTION> to put messages onto a queue.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="80770" TYPE="TEXT">Example&nbsp;6-8</XREF> demonstrates the use of <FUNCTION>msgrcv()</FUNCTION> to take messages from a queue.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The four example programs have a consistent design and use consistent command-line argument letters. Each accepts optional arguments that allow you to exercise all the features of one function, including most error return codes. The following is a simple example of use. First, <COMMAND>ipcs</COMMAND> is used to show no queues exist.</PARAGRAPH>
<CODE>
$ ipcs -q
IPC status from /dev/kmem as of Wed Jun 12 10:36:38 1996
T     ID     KEY        MODE       OWNER    GROUP
Message Queues:
</CODE>
<PARAGRAPH>Then a queue is created with key 9 and <COMMAND>ipcs</COMMAND> used to verify the operation.</PARAGRAPH>
<CODE>
$ msgget -k 9 -c
msqid = 0x0032. owner = 1110.20, perms = 100600, max bytes = 32768
0 msgs = 0 bytes on queue
$ ipcs -q
IPC status from /dev/kmem as of Thu Jun 20 09:32:25 1996
T     ID     KEY        MODE       OWNER    GROUP
Message Queues:
q     50 0x00000009 --rw-------  cortesi     user
</CODE>
<PARAGRAPH>The use of the IPC_EXCL flag is tested:</PARAGRAPH>
<CODE>
$ msgget -k 9 -c -x
msgget(): File exists
</CODE>
<PARAGRAPH>A message is sent to the queue, addressing the queue by its ID.</PARAGRAPH>
<CODE>
$ msgsnd -i 50 -t 17
$ msgctl -i 50
owner = 1110.20, perms = 100600, max bytes = 32768
1 msgs = 64 bytes on queue
</CODE>
<PARAGRAPH>The maximum queue size is changed, this time addressing the queue by its key.</PARAGRAPH>
<CODE>
$ msgctl -k 9 -b 1024
owner = 1110.20, perms = 100600, max bytes = 1024
1 msgs = 64 bytes on queue
</CODE>
<PARAGRAPH>A second message is sent:</PARAGRAPH>
<CODE>
$ msgsnd -i 50 -t 18
$ msgctl -i 50
owner = 1110.20, perms = 100600, max bytes = 1024
2 msgs = 128 bytes on queue
</CODE>
<PARAGRAPH>The first and second messages are received:</PARAGRAPH>
<CODE>
$ msgrcv -k 9
1: type 17  len 64 text 00001 Thu Jun 20 09:32:55 1996  
$ msgrcv -i 50
1: type 18  len 64 text 00001 Thu Jun 20 09:33:18 1996 
</CODE>
<PARAGRAPH>Another message receipt is attempted, first with IPC_NOWAIT:</PARAGRAPH>
<CODE>
$ msgrcv -i 50 -n
msgrcv(): No message of desired type
</CODE>
<PARAGRAPH>Another message is attempted without IPC_NOWAIT. While <COMMAND>msgrcv</COMMAND> is suspended, the message queue is removed.</PARAGRAPH>
<CODE>
$ msgrcv -k 9 &amp;
12477
$ ipcrm -q 50
$ msgrcv(): Identifier removed
</CODE>
<SECTION3 LBL="" HELPID = ""><TITLE>Example of msgget</TITLE><PARAGRAPH>The program <COMMAND>msgget</COMMAND> in <XREF IDREF="49425" TYPE="TEXT">Example&nbsp;6-5</XREF> allows you to create a message queue from the command line. The following command-line arguments are supported: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-k <VARIABLE>key</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Numeric identifier of a message queue, for example <COMMAND>-k 99</COMMAND>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-p <VARIABLE>perms</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Access permissions to set, for example <COMMAND>-p 0664</COMMAND>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-x </PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Use the IPC_EXCL flag with <FUNCTION>msgget()</FUNCTION>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-c </PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Use the IPC_CREAT flag with <FUNCTION>msgget()</FUNCTION>.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>If the <COMMAND>-k</COMMAND> argument is omitted, the program uses a private key and thus creates a message queue that can be used from this program only. (This is not useful, since the program does nothing with the queue before it terminates.)</PARAGRAPH>
<CODE><CAPTION LBL="6-5"><PREFIX>Example 6-5 </PREFIX><XREFTARGET ID="49425">Program to Demonstrate msgget()</CAPTION>/*
||&nbsp;Program&nbsp;to&nbsp;test&nbsp;msgget(2).
||&nbsp;&nbsp;&nbsp;&nbsp;msgget&nbsp;[-k&nbsp;&lt;key>]&nbsp;[-p&nbsp;&lt;perms>]&nbsp;[-x]&nbsp;[-c]
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-k&nbsp;&lt;key>&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;key&nbsp;to&nbsp;use,&nbsp;default&nbsp;==&nbsp;0&nbsp;==&nbsp;IPC_PRIVATE
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-p&nbsp;&lt;perms>&nbsp;&nbsp;permissions&nbsp;to&nbsp;use,&nbsp;default&nbsp;600
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;IPC_EXCL
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;IPC_CREAT
*/
#include&nbsp;&lt;sys/msg.h>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;msg&nbsp;queue&nbsp;stuff,&nbsp;ipc.h,&nbsp;types.h&nbsp;*/
#include&nbsp;&lt;unistd.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;for&nbsp;getopt()&nbsp;*/
#include&nbsp;&lt;errno.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;errno&nbsp;and&nbsp;perror&nbsp;*/
#include&nbsp;&lt;stdio.h>
int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;**argv)
{
&nbsp;&nbsp;&nbsp;key_t&nbsp;key&nbsp;=&nbsp;IPC_PRIVATE;&nbsp;&nbsp;&nbsp;/*&nbsp;key&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;perms&nbsp;=&nbsp;0600;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;permissions&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;msgflg&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;flags:&nbsp;CREAT&nbsp;+&nbsp;EXCL&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;msqid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;returned&nbsp;msg&nbsp;queue&nbsp;id&nbsp;*/
&nbsp;&nbsp;&nbsp;struct&nbsp;msqid_ds&nbsp;buf;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;buffer&nbsp;for&nbsp;stat&nbsp;info&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;c;
&nbsp;&nbsp;&nbsp;while&nbsp;(&nbsp;-1&nbsp;!=&nbsp;(c&nbsp;=&nbsp;getopt(argc,argv,"k:p:xc"))&nbsp;)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(c)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'k':&nbsp;/*&nbsp;key&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key&nbsp;=&nbsp;(key_t)&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'p':&nbsp;/*&nbsp;permissions&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perms&nbsp;=&nbsp;(int)&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'c':
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msgflg&nbsp;|=&nbsp;IPC_CREAT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'x':
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msgflg&nbsp;|=&nbsp;IPC_EXCL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;/*&nbsp;unknown&nbsp;or&nbsp;missing&nbsp;argument&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;msqid&nbsp;=&nbsp;msgget&nbsp;(key,&nbsp;msgflg|perms);
&nbsp;&nbsp;&nbsp;if&nbsp;(-1&nbsp;!=&nbsp;msqid)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("msqid&nbsp;=&nbsp;0x%04x.&nbsp;",msqid);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(-1&nbsp;!=&nbsp;msgctl(msqid,IPC_STAT,&amp;buf))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("owner&nbsp;=&nbsp;%d.%d,&nbsp;perms&nbsp;=&nbsp;%04o,&nbsp;max&nbsp;bytes&nbsp;=&nbsp;%d\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.msg_perm.uid,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.msg_perm.gid,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.msg_perm.mode,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.msg_qbytes);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%d&nbsp;msgs&nbsp;=&nbsp;%d&nbsp;bytes&nbsp;on&nbsp;queue\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.msg_qnum,&nbsp;buf.msg_cbytes);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("\nmsgctl()");
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("msgget()");
}
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Example of msgctl</TITLE><PARAGRAPH>The program <COMMAND>msgctl</COMMAND> in <XREF IDREF="23686" TYPE="TEXT">Example&nbsp;6-6</XREF> allows you to display the state of a queue, or to change the permissions, owner ID, group ID, or maximum size of a queue. The following command-line arguments are supported: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-k <VARIABLE>key</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Numeric identifier of a message queue, for example, <COMMAND>-k 99</COMMAND>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-i <VARIABLE>id</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Message queue ID, alternative to specifying the key; for example, <COMMAND>-i 80</COMMAND>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-p <VARIABLE>perms</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Access permissions to set, for example, <COMMAND>-p 0664</COMMAND>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-b <VARIABLE>bytes</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Maximum size of the message queue, for example, <COMMAND>-b 0x1000</COMMAND>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-u <VARIABLE>uid</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Numeric user ID to set as owner.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-g <VARIABLE>gid</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Numeric group ID to set as owner.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<CODE><CAPTION LBL="6-6"><PREFIX>Example 6-6 </PREFIX><XREFTARGET ID="23686">Program to Demonstrate msgctl()</CAPTION>/*
||&nbsp;Program&nbsp;to&nbsp;test&nbsp;msgctl(2).
||&nbsp;&nbsp;&nbsp;&nbsp;msgctl&nbsp;{-k&nbsp;&lt;key>&nbsp;-i&nbsp;&lt;id>}&nbsp;[-b&nbsp;&lt;bytes>]&nbsp;[-p&nbsp;&lt;perms>]&nbsp;[-u&nbsp;&lt;uid>]&nbsp;[-g&nbsp;&lt;gid>]
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-k&nbsp;&lt;key>&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;key&nbsp;to&nbsp;use,&nbsp;or..
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-i&nbsp;&lt;id>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..the&nbsp;mq&nbsp;id
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-b&nbsp;&lt;bytes>&nbsp;&nbsp;new&nbsp;max&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;set&nbsp;in&nbsp;msg_qbytes
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-p&nbsp;&lt;perms>&nbsp;&nbsp;new&nbsp;permissions&nbsp;to&nbsp;assign&nbsp;in&nbsp;msg_perm.mode
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-u&nbsp;&lt;uid>&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;user&nbsp;id&nbsp;(numeric)&nbsp;for&nbsp;msg_perm.uid
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-g&nbsp;&lt;gid>&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;group&nbsp;id&nbsp;(numeric)&nbsp;for&nbsp;msg_perm.gid
*/
#include&nbsp;&lt;sys/msg.h>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;msg&nbsp;queue&nbsp;stuff,&nbsp;ipc.h,&nbsp;types.h&nbsp;*/
#include&nbsp;&lt;unistd.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;for&nbsp;getopt()&nbsp;*/
#include&nbsp;&lt;errno.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;errno&nbsp;and&nbsp;perror&nbsp;*/
#include&nbsp;&lt;stdio.h>
int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;**argv)
{
&nbsp;&nbsp;&nbsp;key_t&nbsp;key;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;key&nbsp;for&nbsp;msgget..&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;msqid&nbsp;=&nbsp;-1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;..specified&nbsp;or&nbsp;received&nbsp;msg&nbsp;queue&nbsp;id&nbsp;*/
&nbsp;&nbsp;&nbsp;long&nbsp;perms&nbsp;=&nbsp;-1L;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;-1L&nbsp;is&nbsp;not&nbsp;valid&nbsp;for&nbsp;any&nbsp;of&nbsp;these&nbsp;*/
&nbsp;&nbsp;&nbsp;long&nbsp;bytes&nbsp;=&nbsp;-1L;
&nbsp;&nbsp;&nbsp;long&nbsp;uid&nbsp;=&nbsp;-1L;
&nbsp;&nbsp;&nbsp;long&nbsp;gid&nbsp;=&nbsp;-1L;
&nbsp;&nbsp;&nbsp;struct&nbsp;msqid_ds&nbsp;buf;
&nbsp;&nbsp;&nbsp;int&nbsp;c;
&nbsp;&nbsp;&nbsp;while&nbsp;(&nbsp;-1&nbsp;!=&nbsp;(c&nbsp;=&nbsp;getopt(argc,argv,"k:i:b:p:u:g:"))&nbsp;)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(c)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'k':&nbsp;/*&nbsp;key&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key&nbsp;=&nbsp;(key_t)&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'i':&nbsp;/*&nbsp;id&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msqid&nbsp;=&nbsp;(int)&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'p':&nbsp;/*&nbsp;permissions&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perms&nbsp;=&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'b':&nbsp;/*&nbsp;bytes&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bytes&nbsp;=&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'u':&nbsp;/*&nbsp;uid&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uid&nbsp;=&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'g':&nbsp;/*&nbsp;gid&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gid&nbsp;=&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;/*&nbsp;unknown&nbsp;or&nbsp;missing&nbsp;argument&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if&nbsp;(-1&nbsp;==&nbsp;msqid)&nbsp;/*&nbsp;no&nbsp;id&nbsp;given,&nbsp;try&nbsp;key&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msqid&nbsp;=&nbsp;msgget&nbsp;(key,&nbsp;0);
&nbsp;&nbsp;&nbsp;if&nbsp;(-1&nbsp;!=&nbsp;msqid)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(-1&nbsp;!=&nbsp;msgctl(msqid,IPC_STAT,&amp;buf))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((perms!=-1L)||(bytes!=-1L)||(uid!=-1L)||(gid!=-1L))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;put&nbsp;new&nbsp;values&nbsp;in&nbsp;buf&nbsp;fields&nbsp;as&nbsp;requested&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(perms&nbsp;!=&nbsp;-1L)&nbsp;buf.msg_perm.mode&nbsp;=&nbsp;(mode_t)perms;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(uid&nbsp;&nbsp;&nbsp;!=&nbsp;-1L)&nbsp;buf.msg_perm.uid&nbsp;&nbsp;=&nbsp;(uid_t)uid;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(gid&nbsp;&nbsp;&nbsp;!=&nbsp;-1L)&nbsp;buf.msg_perm.gid&nbsp;&nbsp;=&nbsp;(gid_t)gid;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(bytes&nbsp;!=&nbsp;-1L)&nbsp;buf.msg_qbytes&nbsp;=&nbsp;(ulong_t)bytes;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(-1&nbsp;==&nbsp;msgctl(msqid,IPC_SET,&amp;buf))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("\nmsgctl(IPC_SET)");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("owner&nbsp;=&nbsp;%d.%d,&nbsp;perms&nbsp;=&nbsp;%04o,&nbsp;max&nbsp;bytes&nbsp;=&nbsp;%d\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.msg_perm.uid,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.msg_perm.gid,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.msg_perm.mode,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.msg_qbytes);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%d&nbsp;msgs&nbsp;=&nbsp;%d&nbsp;bytes&nbsp;on&nbsp;queue\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf.msg_qnum,&nbsp;buf.msg_cbytes);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("\nmsgctl(IPC_STAT)");
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("msgget()");
}
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Example of msgsnd</TITLE><PARAGRAPH>The <COMMAND>msgsnd</COMMAND> program in <XREF IDREF="43282" TYPE="TEXT">Example&nbsp;6-7</XREF> allows you to send one or more messages of specified length and type to a message queue. The following command-line arguments are supported: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-k <VARIABLE>key</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Numeric identifier of a message queue, for example, <COMMAND>-k 99</COMMAND>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-i <VARIABLE>id</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Message queue ID, alternative to specifying the key; for example, <COMMAND>-i 80</COMMAND>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-c <VARIABLE>count</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Number of messages to send. The default is 1.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-t <VARIABLE>type</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Numeric type of message to send. Types less than 1 are rejected by 
<FUNCTION>msgsnd()</FUNCTION>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-b <VARIABLE>bytes</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Size of each message, for example, <COMMAND>-b 0x200</COMMAND>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-n </PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Use the IPC_NOWAIT flag with <FUNCTION>msgsnd()</FUNCTION>.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The program sends as many messages as you specify, each with the specified type and size. The first 32 bytes of each message is a printable string containing a sequence number and the date and time. The message is padded out to the specified size with binary 0.</PARAGRAPH>
<CODE><CAPTION LBL="6-7"><PREFIX>Example 6-7 </PREFIX><XREFTARGET ID="43282">Program to Demonstrate msgsnd()</CAPTION>/*
||&nbsp;Program&nbsp;to&nbsp;test&nbsp;msgsnd(2)
||&nbsp;&nbsp;&nbsp;&nbsp;msgsnd&nbsp;{-k&nbsp;&lt;key>&nbsp;-i&nbsp;&lt;id>}&nbsp;[-t&nbsp;&lt;type>]&nbsp;[-b&nbsp;&lt;bytes>]&nbsp;[-c&nbsp;&lt;count>]&nbsp;[-n]
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-k&nbsp;&lt;key>&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;key&nbsp;to&nbsp;use,&nbsp;or..
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-i&nbsp;&lt;id>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..the&nbsp;mq&nbsp;id
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-t&nbsp;&lt;type>&nbsp;&nbsp;&nbsp;the&nbsp;type&nbsp;of&nbsp;each&nbsp;message,&nbsp;default&nbsp;=&nbsp;1
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-b&nbsp;&lt;bytes>&nbsp;&nbsp;the&nbsp;size&nbsp;of&nbsp;each&nbsp;message,&nbsp;default&nbsp;=&nbsp;64,&nbsp;min&nbsp;32
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-c&nbsp;&lt;count>&nbsp;&nbsp;the&nbsp;number&nbsp;of&nbsp;messages&nbsp;to&nbsp;send,&nbsp;default&nbsp;=&nbsp;1,&nbsp;max&nbsp;99999
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;IPC_NOWAIT&nbsp;flag
||&nbsp;The&nbsp;program&nbsp;sends&nbsp;&lt;count>&nbsp;messages&nbsp;of&nbsp;&lt;type>,&nbsp;&lt;bytes>&nbsp;each&nbsp;on&nbsp;the&nbsp;queue.
||&nbsp;Each&nbsp;message&nbsp;is&nbsp;an&nbsp;ASCII&nbsp;string&nbsp;containing&nbsp;the&nbsp;time&nbsp;and&nbsp;date,&nbsp;and
||&nbsp;a&nbsp;serial&nbsp;number&nbsp;1..&lt;count>,&nbsp;minimum&nbsp;message&nbsp;is&nbsp;32&nbsp;bytes.
*/
#include&nbsp;&lt;sys/msg.h>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;msg&nbsp;queue&nbsp;stuff,&nbsp;ipc.h,&nbsp;types.h&nbsp;*/
#include&nbsp;&lt;unistd.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;for&nbsp;getopt()&nbsp;*/
#include&nbsp;&lt;errno.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;errno&nbsp;and&nbsp;perror&nbsp;*/
#include&nbsp;&lt;time.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;time(2)&nbsp;and&nbsp;ctime_r(3)&nbsp;*/
#include&nbsp;&lt;stdio.h>
int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;**argv)
{
&nbsp;&nbsp;&nbsp;key_t&nbsp;key;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;key&nbsp;for&nbsp;msgget..&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;msqid&nbsp;=&nbsp;-1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;..specified&nbsp;or&nbsp;received&nbsp;msg&nbsp;queue&nbsp;id&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;msgflg&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;flag,&nbsp;0&nbsp;or&nbsp;IPC_NOWAIT&nbsp;*/
&nbsp;&nbsp;&nbsp;long&nbsp;type&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;message&nbsp;type&nbsp;--&nbsp;0&nbsp;is&nbsp;not&nbsp;valid&nbsp;to&nbsp;msgsnd()&nbsp;*/
&nbsp;&nbsp;&nbsp;size_t&nbsp;bytes&nbsp;=&nbsp;64;&nbsp;&nbsp;&nbsp;/*&nbsp;message&nbsp;text&nbsp;size&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;count&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;number&nbsp;to&nbsp;send&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;c;
&nbsp;&nbsp;&nbsp;struct&nbsp;msgspace&nbsp;{&nbsp;long&nbsp;type;&nbsp;char&nbsp;text[32];&nbsp;}&nbsp;*msg;
&nbsp;&nbsp;&nbsp;while&nbsp;(&nbsp;-1&nbsp;!=&nbsp;(c&nbsp;=&nbsp;getopt(argc,argv,"k:i:t:b:c:n"))&nbsp;)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(c)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'k':&nbsp;/*&nbsp;key&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key&nbsp;=&nbsp;(key_t)&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'i':&nbsp;/*&nbsp;id&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msqid&nbsp;=&nbsp;(int)&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'t':&nbsp;/*&nbsp;type&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'b':&nbsp;/*&nbsp;bytes&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bytes&nbsp;=&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(bytes&lt;32)&nbsp;bytes&nbsp;=&nbsp;32;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'c':&nbsp;/*&nbsp;count&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(count&nbsp;>&nbsp;99999)&nbsp;count&nbsp;=&nbsp;99999;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'n':&nbsp;/*&nbsp;nowait&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msgflg&nbsp;|=&nbsp;IPC_NOWAIT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;/*&nbsp;unknown&nbsp;or&nbsp;missing&nbsp;argument&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;msg&nbsp;=&nbsp;(struct&nbsp;msgspace&nbsp;*)calloc(1,sizeof(long)+bytes);&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;if&nbsp;(-1&nbsp;==&nbsp;msqid)&nbsp;/*&nbsp;no&nbsp;id&nbsp;given,&nbsp;try&nbsp;key&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msqid&nbsp;=&nbsp;msgget&nbsp;(key,&nbsp;0);
&nbsp;&nbsp;&nbsp;if&nbsp;(-1&nbsp;!=&nbsp;msqid)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;time_t&nbsp;tm&nbsp;=&nbsp;time(NULL);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;stime[26];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void)ctime_r&nbsp;(&amp;tm,stime);&nbsp;/*&nbsp;format&nbsp;timestamp&nbsp;for&nbsp;msg&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stime[24]&nbsp;=&nbsp;'\0';&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;drop&nbsp;annoying&nbsp;\n&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(&nbsp;c=1;&nbsp;c&lt;=count;&nbsp;++c)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg->type&nbsp;=&nbsp;type;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprintf(msg->text,"%05d&nbsp;%s",c,stime);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(-1&nbsp;==&nbsp;msgsnd(msqid,msg,bytes,msgflg))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("msgsnd()");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("msgget()");
}
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Example of msgrcv</TITLE><PARAGRAPH>The program <COMMAND>msgrcv</COMMAND> in <XREF IDREF="80770" TYPE="TEXT">Example&nbsp;6-8</XREF> allows you to receive messages from a specified queue. The following arguments are used in more than one program: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-k <VARIABLE>key</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Numeric identifier of a message queue, for example <COMMAND>-k 99</COMMAND>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-i <VARIABLE>id</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Message queue ID, alternative to specifying the key; for example, <COMMAND>-i 80</COMMAND>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-c <VARIABLE>count</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Number of messages to attempt to receive.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-b <VARIABLE>bytes</VARIABLE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Maximum size of a message, for example, <COMMAND>-b 0x200</COMMAND>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-n </PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Use the IPC_NOWAIT flag with <FUNCTION>msgrcv()</FUNCTION>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-e </PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Use the MSG_NOERROR flag with <FUNCTION>msgrcv()</FUNCTION>, to truncate messages longer 
than <VARIABLE>bytes</VARIABLE>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="54"><PARAGRAPH>-q </PARAGRAPH>
</CELL>
<CELL LEFT="60" WIDTH="333"><PARAGRAPH>Be quiet, do not display the received message. Use for performance testing.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>As each message is received, it is displayed. A sequence number and the message type are always displayed; the first 32 bytes of the text are displayed if it begins with ASCII.</PARAGRAPH>
<CODE><CAPTION LBL="6-8"><PREFIX>Example 6-8 </PREFIX><XREFTARGET ID="80770">Program to Demonstrate msgrcv()</CAPTION>/*
||&nbsp;Program&nbsp;to&nbsp;test&nbsp;msgrcv(2)
||&nbsp;&nbsp;&nbsp;&nbsp;msgrcv&nbsp;{-k&nbsp;&lt;key>&nbsp;-i&nbsp;&lt;id>}&nbsp;[-t&nbsp;&lt;type>]&nbsp;[-b&nbsp;&lt;bytes>]&nbsp;[-c&nbsp;&lt;count>]
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-n]&nbsp;[-e]&nbsp;[-q]
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-k&nbsp;&lt;key>&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;key&nbsp;to&nbsp;use,&nbsp;or..
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-i&nbsp;&lt;id>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;..the&nbsp;mq&nbsp;id
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-t&nbsp;&lt;type>&nbsp;&nbsp;&nbsp;the&nbsp;type&nbsp;of&nbsp;message,&nbsp;default&nbsp;=&nbsp;0&nbsp;(any&nbsp;msg)
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-b&nbsp;&lt;bytes>&nbsp;&nbsp;the&nbsp;max&nbsp;size&nbsp;to&nbsp;receive,&nbsp;default&nbsp;=&nbsp;64
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-c&nbsp;&lt;count>&nbsp;&nbsp;the&nbsp;number&nbsp;of&nbsp;messages&nbsp;to&nbsp;receive,&nbsp;default&nbsp;=&nbsp;1
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;IPC_NOWAIT&nbsp;flag
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;use&nbsp;MSG_NOERROR&nbsp;flag&nbsp;(truncate&nbsp;long&nbsp;msg)
||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quiet,&nbsp;do&nbsp;not&nbsp;display&nbsp;received&nbsp;message
||&nbsp;The&nbsp;program&nbsp;calls&nbsp;msgrcv&nbsp;&lt;count>&nbsp;times&nbsp;or&nbsp;until&nbsp;an&nbsp;error&nbsp;occurs,
||&nbsp;each&nbsp;time&nbsp;requesting&nbsp;a&nbsp;message&nbsp;of&nbsp;type&nbsp;&lt;type>&nbsp;and&nbsp;max&nbsp;size&nbsp;&lt;bytes>.
*/
#include&nbsp;&lt;sys/msg.h>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;msg&nbsp;queue&nbsp;stuff,&nbsp;ipc.h,&nbsp;types.h&nbsp;*/
#include&nbsp;&lt;unistd.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;for&nbsp;getopt()&nbsp;*/
#include&nbsp;&lt;errno.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;errno&nbsp;and&nbsp;perror&nbsp;*/
#include&nbsp;&lt;ctype.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;isascii()&nbsp;*/
#include&nbsp;&lt;stdio.h>
int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;**argv)
{
&nbsp;&nbsp;&nbsp;key_t&nbsp;key;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;key&nbsp;for&nbsp;msgget..&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;msqid&nbsp;=&nbsp;-1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;..specified&nbsp;or&nbsp;received&nbsp;msg&nbsp;queue&nbsp;id&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;msgflg&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;flag,&nbsp;0,&nbsp;IPC_NOWAIT,&nbsp;MSG_NOERROR&nbsp;*/
&nbsp;&nbsp;&nbsp;long&nbsp;type&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;message&nbsp;type&nbsp;*/
&nbsp;&nbsp;&nbsp;size_t&nbsp;bytes&nbsp;=&nbsp;64;&nbsp;&nbsp;&nbsp;/*&nbsp;message&nbsp;size&nbsp;limit&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;count&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;number&nbsp;to&nbsp;receive&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;quiet&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;quiet&nbsp;flag&nbsp;*/
&nbsp;&nbsp;&nbsp;int&nbsp;c;
&nbsp;&nbsp;&nbsp;struct&nbsp;msgspace&nbsp;{&nbsp;long&nbsp;type;&nbsp;char&nbsp;text[32];&nbsp;}&nbsp;*msg;
&nbsp;&nbsp;&nbsp;while&nbsp;(&nbsp;-1&nbsp;!=&nbsp;(c&nbsp;=&nbsp;getopt(argc,argv,"k:i:t:b:c:enq"))&nbsp;)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(c)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'k':&nbsp;/*&nbsp;key&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key&nbsp;=&nbsp;(key_t)&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'i':&nbsp;/*&nbsp;id&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msqid&nbsp;=&nbsp;(int)&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'t':&nbsp;/*&nbsp;type&nbsp;--&nbsp;can&nbsp;be&nbsp;negative&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;strtol(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'b':&nbsp;/*&nbsp;bytes&nbsp;--&nbsp;no&nbsp;minimum&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bytes&nbsp;=&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'c':&nbsp;/*&nbsp;count&nbsp;-&nbsp;no&nbsp;maximum&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;strtoul(optarg,&nbsp;NULL,&nbsp;0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'n':&nbsp;/*&nbsp;nowait&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msgflg&nbsp;|=&nbsp;IPC_NOWAIT;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'e':&nbsp;/*&nbsp;noerror&nbsp;--&nbsp;allow&nbsp;truncation&nbsp;of&nbsp;msgs&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msgflg&nbsp;|=&nbsp;MSG_NOERROR;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;'q':&nbsp;/*&nbsp;quiet&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quiet&nbsp;=&nbsp;1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;/*&nbsp;unknown&nbsp;or&nbsp;missing&nbsp;argument&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;if&nbsp;(-1&nbsp;==&nbsp;msqid)&nbsp;/*&nbsp;no&nbsp;id&nbsp;given,&nbsp;try&nbsp;key&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msqid&nbsp;=&nbsp;msgget&nbsp;(key,&nbsp;0);
&nbsp;&nbsp;&nbsp;msg&nbsp;=&nbsp;(struct&nbsp;msgspace&nbsp;*)calloc(1,sizeof(long)+bytes);&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;if&nbsp;(-1&nbsp;!=&nbsp;msqid)
&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(&nbsp;c=1;&nbsp;c&lt;=count;&nbsp;++c)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ret&nbsp;=&nbsp;msgrcv(msqid,msg,bytes,type,msgflg);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ret&nbsp;>=&nbsp;0)&nbsp;/*&nbsp;got&nbsp;a&nbsp;message&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!quiet)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(isascii(msg->text[0]))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%d:&nbsp;type&nbsp;%ld&nbsp;&nbsp;len&nbsp;%d&nbsp;text&nbsp;%-32.32s\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c,&nbsp;&nbsp;&nbsp;msg->type,&nbsp;&nbsp;ret,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg->text);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%d:&nbsp;type&nbsp;%ld&nbsp;len&nbsp;%d&nbsp;(nonascii)\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c,&nbsp;&nbsp;&nbsp;msg->type,&nbsp;&nbsp;ret);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;/*&nbsp;an&nbsp;error,&nbsp;end&nbsp;loop&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("msgrcv()");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;for&nbsp;c&lt;=count&nbsp;*/
&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;good&nbsp;msgget&nbsp;*/
&nbsp;&nbsp;&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror("msgget()");
} &space;
</CODE>
<PARAGRAPH>&space;</PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
</CHAPTER>
