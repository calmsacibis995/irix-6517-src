<!-- Produced by version 3.14 (11/22/96) of SGI Frame/SGML translator -->
<CHAPTER LBL="16"><TITLE><XREFTARGET ID="31062">Internationalizing Your Application</TITLE><PARAGRAPH>Internationalization is the process of generalizing an application so that it can easily be customized&mdash;or <INDEXTARGET ID="TIP_6.intl1"><!-- POSTPROCESSDATA: TIP_6.intl1|internationalization --><ITALICS>localized</ITALICS>&mdash;to run in more than one language environment. You can provide internationalized software that will produce output in a user's native language, format data (such as currency values and dates) according to local standards, and tailor software to a specific culture.</PARAGRAPH>
<PARAGRAPH>This chapter describes how to create such an application. It contains the following major sections:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="10407" TYPE="TITLE">&ldquo;Overview of Internationalization&rdquo;</XREF> presents an introduction to internationalization and defines some common terms.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="52537" TYPE="TEXT"></XREF><XREF IDREF="52537" TYPE="TITLE">&ldquo;Using Locales&rdquo;</XREF> explains how to set the current locale and limitations of the locale system.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="21113" TYPE="TITLE">&ldquo;Character Sets, Codesets, and Encodings&rdquo;</XREF> describes various ways of encoding characters, the traditional ASCII being just one of these. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>&space;<XREF IDREF="93180" TYPE="TITLE">&ldquo;Cultural Items&rdquo;</XREF> discusses the ways in which different cultures affect the way a string can be viewed, for example in outputting or collating.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="65867" TYPE="TITLE">&ldquo;Locale-Specific Behavior&rdquo;</XREF> covers native language support (NLS) and the NLS database, regular expressions, and cultural data.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="42715" TYPE="TITLE">&ldquo;Strings and Message Catalogs&rdquo;</XREF>describes how to create and use catalogs of messages to send diagnostic information to users in various locales.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="11835" TYPE="TITLE">&ldquo;Internationalization Support in X11R6&rdquo;</XREF> describes internationalization support provided by X11, Release 6 (including features from X11R5).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="64330" TYPE="TITLE">&ldquo;Internationalization Support in Motif&rdquo;</XREF> points to information describing how to internationalize a Motif application.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="98616" TYPE="TITLE">&ldquo;Translating User Input&rdquo;</XREF> discusses the translation of keyboard events into programmatic character strings for a variety of keyboards. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="19057" TYPE="TITLE">&ldquo;GUI Concerns&rdquo;</XREF> discusses internationalizing applications that use graphical user interfaces (GUIs)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="35985" TYPE="TITLE">&ldquo;Popular Encodings&rdquo;</XREF> presents some common non-ASCII encodings.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>For a list of ISO 3166 country names and abbreviations, see <XREF IDREF="53705" TYPE="TITLE">Appendix&nbsp;A, &ldquo;ISO 3166 Country Names and Abbreviations.&rdquo;</XREF> You can find detailed information about fonts in <XREF IDREF="49176" TYPE="TITLE">Chapter&nbsp;15, &ldquo;Working With Fonts.&rdquo;</XREF> Also, you can find additional information about internationalizing an application in the <DOCTITLE>IRIX Interactive Desktop Integration Guide</DOCTITLE>.</PARAGRAPH>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="10407">Overview of Internationalization</TITLE><PARAGRAPH>Internationalized software can be made to produce output in a user's native language, to format data (such as dates and currency values) according to the user's local customs, and to otherwise make the software easier to use for users from a culture other than that of the original software developer. As computers become more widely used in non-American cultures, it becomes increasingly important that developers stop relying on the conventions of American programming and the English language in their programs. This chapter provides information on how to make your applications more widely accessible.</PARAGRAPH>
<PARAGRAPH>This section presents the following topics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="78630" TYPE="TITLE">&ldquo;Some Definitions of Internationalization&rdquo;</XREF> covers locales, internationalization, localization, nationalized software, and multilingual software.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="42395" TYPE="TITLE">&ldquo;Areas of Concern in Internationalizing Software&rdquo;</XREF> points out a few concerns to watch for when internationalizing your software. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="88979" TYPE="TITLE">&ldquo;Standards&rdquo;</XREF> covers standard-compliant features.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="99065" TYPE="TITLE">&ldquo;Internationalizing Your Application: The Basic Steps&rdquo;</XREF> lists the procedures to use when internationalizing an icon.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="43446" TYPE="TITLE">&ldquo;Additional Reading on Internationalization&rdquo;</XREF> provides references you can consult for additional information about internationalization.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="78630">Some Definitions of Internationalization</TITLE><PARAGRAPH>This section defines some of the terms used in this chapter.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Locale</TITLE><PARAGRAPH><INDEXTARGET ID="TIP_6.intl2"><!-- POSTPROCESSDATA: TIP_6.intl2|locales:definedinternationalization:locales. <ITALICS>See </ITALICS>locales --><ITALICS>Locale</ITALICS> refers to a set of local customs that determine many aspects of software input and output formatting, including natural language, culture, character sets and encodings, and formatting and sorting rules. The locale of a program is the set of such parameters that are currently selected. For information on the method for selecting locales, see <XREF IDREF="43446" TYPE="TITLE">&ldquo;Additional Reading on Internationalization&rdquo;</XREF> below.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Internationalization (i18n)</TITLE><PARAGRAPH><INDEXTARGET ID="TIP_6.intl3"><!-- POSTPROCESSDATA: TIP_6.intl3|internationalization:definedi18n. <ITALICS>See </ITALICS>internationalization --><ITALICS>Internationalization</ITALICS> is the process of making a program capable of running in multiple locales without recompiling. To put it another way, an internationalized program is one that can be easily localized without changing the program itself. (See <XREF IDREF="66057" TYPE="TITLE">&ldquo;Localization (l10n),&rdquo;</XREF> below, for an explanation of the term &ldquo;localization.&rdquo;)</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>The word &ldquo;internationalization&rdquo; consists of an <ITALICS>i</ITALICS> followed by 18 letters followed by an <ITALICS>n</ITALICS>. It is thus often abbreviated &ldquo;i18n&rdquo; in informal writing. On similar principles, &ldquo;localization&rdquo; is often abbreviated &ldquo;l10n.&rdquo;</NOTE>
<PARAGRAPH>A program written for a specific locale may be difficult to run in a different environment. Rewriting such a program to operate in each desired environment would be tedious and costly.</PARAGRAPH>
<PARAGRAPH>Your goal as a developer should thus be to write <ITALICS>locale-independent</ITALICS> programs, programs that make no assumptions about languages, local customs, or coded character sets. Such internationalized applications can run in a user's native environment following native conventions with native messages, without recompiling or relinking. A single copy of an internationalized program can be used by a world of different users.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="66057">Localization (l10n)</TITLE><PARAGRAPH><INDEXTARGET ID="TIP_6.intl4"><!-- POSTPROCESSDATA: TIP_6.intl4|localization:definedl10n. <ITALICS>See </ITALICS>localization --><ITALICS>Localization</ITALICS> is the act of providing an internationalized application with the environment and data it needs to operate in a particular locale. For example, adding German system messages to IRIX is a part of localizing IRIX for the German locale.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Nationalized Software</TITLE><PARAGRAPH><INDEXTARGET ID="TIP_6.intl5"><!-- POSTPROCESSDATA: TIP_6.intl5|nationalized software --><ITALICS>Nationalized</ITALICS> programs run in only one language and are governed by one set of customs; in other words, in a nationalized program the locale is built into the application. Even if the application doesn't use ASCII or English, as long as it is a single-language program it is nationalized, not internationalized. Most older UNIX programs can be thought of as being nationalized for the United States.</PARAGRAPH>
<PARAGRAPH>Consider two applications, <COMMAND>hello</COMMAND> and <COMMAND>bonjour</COMMAND>. The application<COMMAND>&space;hello</COMMAND> always produces the output</PARAGRAPH>
<EXAMPLE>
Hello, world.
</EXAMPLE>
<PARAGRAPH>and <COMMAND>bonjour</COMMAND> always produces</PARAGRAPH>
<EXAMPLE>
Bonjour, tout le monde.
</EXAMPLE>
<PARAGRAPH>Neither <COMMAND>hello</COMMAND> nor <COMMAND>bonjour</COMMAND> are internationalized; they are both nationalized.</PARAGRAPH>
<PARAGRAPH>There are no special requirements for writing or porting nationalized applications, whether they are text or graphics programs. Terminal-based programs work on suitable terminals, including internationalized terminal emulators. &ldquo;Suitable&rdquo; means that the terminal supports any necessary fonts and understands the encoding of the application output. Graphics programs simply do as they have always done. Applications using existing interfaces to operate in non-English or non-ASCII environments should continue to compile and run under an internationalized operating system.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Multilingual Software</TITLE><PARAGRAPH>A <ITALICS>multilingual</ITALICS> program is one that uses several different locales at the same time. Examples are described in <XREF IDREF="49439" TYPE="TITLE">&ldquo;Multilingual Support&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="42395">Areas of Concern in Internationalizing Software</TITLE><PARAGRAPH>Few developers will have to pay attention to more than a few items described in this section. Most will need to catalog their strings. Some will need to use library routines for character sorting or locale-dependent date, time, or number formatting. A few whose applications use the eighth bit of 8-bit characters inappropriately will need to stop doing so. The few applications that do arithmetic to manipulate characters will need to be cleaned up. Some GUI designers will have to spend just a little more time thinking. But for the large majority of developers, there isn't much to do.</PARAGRAPH>
<PARAGRAPH>The information presented in the following sections addresses internationalization issues pertinent to a developer; some sections, however, may not be relevant to your applications.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="88979">Standards</TITLE><PARAGRAPH>IRIX internationalization includes these standards-compliant features, among others:<INDEXTARGET ID="TIP_6.intl6"><!-- POSTPROCESSDATA: TIP_6.intl6|internationalization:standards --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>ANSI C and POSIX (ISO 9945-1): Locale</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><DOCTITLE>X/OPEN Portability Guide, Issue 4</DOCTITLE> (XPG/4): XPG/4 message catalogs, interpretation of locale strings</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>UNIX System V Release 4: Multi-National Language Support (MNLS) message catalogs</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>X11R5 and X11R6: Input methods, text rendering, resource files</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="99065">Internationalizing Your Application: The Basic Steps</TITLE><PARAGRAPH>To internationalize your icon, follow these steps:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Call <BOLD>setlocale()</BOLD> as soon as possible to put the process into the desired locale. See <XREF IDREF="56535" TYPE="TITLE">&ldquo;Setting the Current Locale&rdquo;</XREF> for instructions.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Make your application 8-bit clean. (An application is 8-bit clean if it does not use the high bit of any data byte to convey special information.) See <XREF IDREF="19794" TYPE="TITLE">&ldquo;Eight-Bit Cleanliness&rdquo;</XREF> for instructions.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>If you're writing a multilingual application, you must do one of two things:</PARAGRAPH>
<BULLETLISTIND><BULLETIND><PARAGRAPH>fork, and then call <BOLD>setlocale()</BOLD> differently in each process</PARAGRAPH>
</BULLETIND>
<BULLETIND><PARAGRAPH>&space;call <BOLD>setlocale()</BOLD> repeatedly as necessary to change from language to language</PARAGRAPH>
</BULLETIND>
</BULLETLISTIND>
<PARAGRAPH>See <XREF IDREF="49439" TYPE="TITLE">&ldquo;Multilingual Support&rdquo;</XREF> for more information.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Use wide character (WC) or multibyte (MB) characters and strings to allow for more than one byte per character (this is needed for Asian languages, which often require two or even four bytes per character). See <XREF IDREF="47047" TYPE="TITLE">&ldquo;Character Representation&rdquo;</XREF> for more information.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Do not rely on ASCII and English sorting rules. Locale-specific collation should be performed with <BOLD>strcoll()</BOLD> and <BOLD>strxfm()</BOLD>. (These are table-driven functions; the tables are supplied as part of locale support.) See <XREF IDREF="55382" TYPE="TITLE">&ldquo;Collating Strings&rdquo;</XREF> for more information.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Use the <BOLD>localeconv()</BOLD> function to find out about general details of numeric formatting. Use <FUNCTION>strfmon()</FUNCTION> to format currency amounts in particular. See <XREF IDREF="92734" TYPE="TITLE">&ldquo;Specifying Numbers and Money&rdquo;</XREF> for more information.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Use <BOLD>strftime()</BOLD> to format dates and times (<BOLD>strftime()</BOLD> gives a host of options for displaying locale-specific dates and times.) See <XREF IDREF="89878" TYPE="TITLE">&ldquo;Formatting Dates and Times&rdquo;</XREF> for more information.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Avoid arithmetic on character values. Use the macros in <FILENAME>ctype.h</FILENAME> to get information about a given character. (These macros are table-driven and locale-sensitive.) If you prefer, you can use the functions that correspond to these macros instead. <XREF IDREF="29929" TYPE="TITLE">&ldquo;Character Classification and ctype&rdquo;</XREF> provides more detailed information on these macros and functions.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>If you do your own regular expression parsing and matching, use the XPG/4 extensions to traditional regular expression syntax for internationalized software. See <XREF IDREF="45624" TYPE="TITLE">&ldquo;Regular Expressions&rdquo;</XREF> for more information.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Where possible, use the XPG/4, rather than the MNLS interface in order to maximize portability. See <XREF IDREF="42715" TYPE="TITLE">&ldquo;Strings and Message Catalogs&rdquo;</XREF> for more information.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Provide a catalog for your locale. See <XREF IDREF="70472" TYPE="TITLE">&ldquo;SVR4 MNLS Message Catalogs&rdquo;</XREF> for more information.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>The File Typing Rule (FTR) strings that are used to customize the IRIX Interactive desktop can be Internationalized. See <XREF IDREF="31603" TYPE="TITLE">&ldquo;Internationalizing File Typing Rule Strings With MNLS&rdquo;</XREF> for more information.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Use message catalogs for <BOLD>printf()</BOLD> format strings that take linguistic parameters, and allow localizers to localize the format strings as well as text strings. See <XREF IDREF="15279" TYPE="TITLE">&ldquo;Variably Ordered Referencing of printf() Arguments&rdquo;</XREF> for more information.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>If you're using Xlib, initialize Xlib's internationalization state after calling <BOLD>setlocale()</BOLD>. See <XREF IDREF="47944" TYPE="TITLE">&ldquo;Initialization for Xlib Programming&rdquo;</XREF> for more information.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Specify a default fontset suitable for the default locale. Make sure that the application accepts localized fontset specifications via resources (or message catalogs) or command-line options. See <XREF IDREF="70975" TYPE="TITLE">&ldquo;Fontsets&rdquo;</XREF> for more information.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Use X11R5 and X11R6 text rendering routines that understand multibyte and wide character strings, not the X11R4 text rendering routines <BOLD>XDrawText()</BOLD>, <BOLD>XDrawString()</BOLD>, and <BOLD>XDrawImageString()</BOLD>. See <XREF IDREF="20370" TYPE="TITLE">&ldquo;Text Rendering Routines&rdquo;</XREF> for more information.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Use X11R5 and X11R6 MB and WC versions of width and extents interrogation routines. See <XREF IDREF="50793" TYPE="TITLE">&ldquo;New Text Extents Functions&rdquo;</XREF> for more information.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>If you are writing a toolkit text object, or if you can't use a toolkit to manage event processing for you, then you have to deal with input methods. Follow the instructions in <XREF IDREF="98616" TYPE="TITLE">&ldquo;Translating User Input&rdquo;</XREF>.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Use resources to label any object that employs some sort of text label. Your application's app-defaults file should specify every reasonable string resource. See <XREF IDREF="74006" TYPE="TITLE">&ldquo;X Resources for Strings&rdquo;</XREF> for more information.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Use dynamic layout objects that calculate layout depending on the natural (localized) size of the objects involved. Some IRIS IM widgets providing these services are XmForm, XmPanedWindow, and XmRowColumn. See <XREF IDREF="17649" TYPE="TITLE">&ldquo;Dynamic Layout&rdquo;</XREF> for more information. If you can't use dynamic layout objects, refer to <XREF IDREF="35180" TYPE="TITLE">&ldquo;Layout&rdquo;</XREF> for instructions.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Make sure that all icons and other pictographic representations used by your application are localizable. See <XREF IDREF="17042" TYPE="TITLE">&ldquo;Icons&rdquo;</XREF> for more information.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="43446">Additional Reading on Internationalization</TITLE><PARAGRAPH>For more information on internationalization, refer to:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>O'Reilly Volume 1, <DOCTITLE>Xlib Programming Manual</DOCTITLE>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><DOCTITLE>X Window System</DOCTITLE>, by Robert Scheifler and Jim Gettys</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><DOCTITLE>X/Open Portability Guide</DOCTITLE>&space;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><DOCTITLE>OSF/Motif Style Guide</DOCTITLE></PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="52537">Using Locales</TITLE><PARAGRAPH>An internationalized system is capable of presenting and receiving data understandably in a number of different formats, cultures, languages, and character sets. An application running in an internationalized system must indicate how it wants the system to behave. IRIX uses the concept of a locale to convey that information.<INDEXTARGET ID="TIP_6.intl7"><!-- POSTPROCESSDATA: TIP_6.intl7|locales --></PARAGRAPH>
<PARAGRAPH>A process can have only one locale at a time. Most internationalization interfaces rely on the locale of the current process being set properly; the locale governs the behavior of certain library routines.</PARAGRAPH>
<PARAGRAPH>This section covers the following topics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="56535" TYPE="TITLE">&ldquo;Setting the Current Locale&rdquo;</XREF> explains categories, locales, strings, location of locale-specific data, and locale naming conventions.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="40340" TYPE="TITLE">&ldquo;Limitations of the Locale System&rdquo;</XREF> describes multilingual support, misuses of locales, and encoding.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>You can find additional information in <XREF IDREF="65867" TYPE="TITLE">&ldquo;Locale-Specific Behavior&rdquo;</XREF>, which describes native language support, regular expressions, and cultural data.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="56535">Setting the Current Locale</TITLE><PARAGRAPH>Applications begin in the <INDEXTARGET ID="TIP_6.intl8"><!-- POSTPROCESSDATA: TIP_6.intl8|locales:setting currentlocales:<ITALICS>setlocale()</ITALICS>internationalization:setting locale<ITALICS>setlocale()</ITALICS> --><VARIABLE>C</VARIABLE> locale. (<VARIABLE>C</VARIABLE> is the name used to indicate the system default locale; it usually corresponds to American English.) Applications should therefore call <FUNCTION>setlocale()</FUNCTION> as soon as possible to put the process into the desired locale. The syntax for <FUNCTION>setlocale()</FUNCTION> is:</PARAGRAPH>
<CODE>
#include &lt;locale.h>
char *setlocale(int category, const char *locale);
</CODE>
<PARAGRAPH>The call almost always looks either like this:</PARAGRAPH>
<CODE>
if (setlocale(LC_ALL, "") == NULL)
&space;   exit_with_error();
</CODE>
<PARAGRAPH>or like this:</PARAGRAPH>
<EXAMPLE>
if (setlocale(LC_ALL, "") == NULL)
&space;   setlocale(LC_ALL, "C");
</EXAMPLE>
<PARAGRAPH>Details of the two parameters are given in the next two sections.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Using Locale Categories</TITLE><PARAGRAPH>Applications need not perform every aspect of their work in the same locale. Although this approach is not recommended, an application could (for example) perform most of its activities in the English locale but use French sorting rules. You can use locale categories to do this kind of locale-mixing. (Mixing locale categories is not the same as multilingual support&mdash;see <INDEXTARGET ID="TIP_6.intl9"><!-- POSTPROCESSDATA: TIP_6.intl9|locales:categories --><XREF IDREF="49439" TYPE="TITLE">&ldquo;Multilingual Support.&rdquo;</XREF>)</PARAGRAPH>
<PARAGRAPH>The <INDEXTARGET ID="TIP_6.intl10"><!-- POSTPROCESSDATA: TIP_6.intl10|LC_ALLLC_COLLATELC_CTYPELC_MESSAGESLC_MONETARY --><VARIABLE>category</VARIABLE> argument is a symbolic constant that tells <FUNCTION>setlocale()</FUNCTION> which items in a locale to change. <INDEXTARGET ID="TIP_6.intl11"><!-- POSTPROCESSDATA: TIP_6.intl11|LC_NUMERICLC_TIME --><XREF IDREF="89492" TYPE="TABLE">Table&nbsp;16-1</XREF> lists the available category choices.<XREFTARGET ID="24348"><FUNCTION></FUNCTION></PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="16-1"><PREFIX>Table 16-1 </PREFIX><XREFTARGET ID="89492">Locale Categories</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="81"><PARAGRAPH>Category</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Affects</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>LC_ALL</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>All categories below</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>LC_COLLATE</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Regular expressions, <FUNCTION>strcoll()</FUNCTION>, and <FUNCTION>strxfrm()</FUNCTION></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>LC_CTYPE</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Regular expressions and ctype routines (such as <FUNCTION>islower()</FUNCTION>)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>LC_MESSAGES</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH><FUNCTION>gettxt()</FUNCTION>, <FUNCTION>pfmt()</FUNCTION>, and <FUNCTION>nl_langinfo()</FUNCTION></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>LC_MONETARY</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH><FUNCTION>localeconv()</FUNCTION> and <FUNCTION>strfmon()</FUNCTION>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>LC_NUMERIC</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH>Decimal-point character for formatted I/O and nonmonetary formatting 
information returned by <FUNCTION>localeconv()</FUNCTION></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="306"><PARAGRAPH><FUNCTION>ascftime()</FUNCTION>, <FUNCTION>cftime()</FUNCTION>, <FUNCTION>getdate()</FUNCTION>, and <FUNCTION>strftime()</FUNCTION></PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Categories correspond to databases that contain relevant information for each defined locale. The locations of these databases are given in the <XREF IDREF="88353" TYPE="TITLE">&ldquo;Location of Locale-Specific Data&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Setting the Locale</TITLE><PARAGRAPH>The <INDEXTARGET ID="TIP_6.intl12"><!-- POSTPROCESSDATA: TIP_6.intl12|internationalization:<ITALICS>setlocal()</ITALICS><ITALICS>setlocal()</ITALICS> --><FUNCTION>setlocale()</FUNCTION> function attempts to set the locale of the specified category to the specified locale. You should almost always pass the empty string as the <VARIABLE>locale</VARIABLE> parameter to conform to user preferences.</PARAGRAPH>
<PARAGRAPH>On success, <FUNCTION>setlocale()</FUNCTION> returns the new value of the category. If <FUNCTION>setlocale()</FUNCTION> couldn't set the category to the value requested, it returns NULL and does not change locale.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Empty String</TITLE><PARAGRAPH>An empty string passed as the <INDEXTARGET ID="TIP_6.intl13"><!-- POSTPROCESSDATA: TIP_6.intl13|localization:empty stringslocales:empty stringsempty strings --><VARIABLE>locale</VARIABLE> parameter is special. It specifies that the locale should be chosen based on environment variables. This is the way a user specifies a preferred locale, and that preference should almost always be honored. The variables are checked hierarchically, depending on category, as shown in <XREF IDREF="30326" TYPE="TABLE">Table&nbsp;16-2</XREF>; for instance, if the category is LC_COLLATE, an empty-string locale parameter indicates that the locale should be chosen based on the value of the environment variable LC_COLLATE&mdash;or, if that value is undefined, the value of the environment variable LANG, which should contain the name of the locale that the user wishes to work in.</PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="16-2"><PREFIX>Table 16-2 </PREFIX><XREFTARGET ID="30326">Category Environment Variables</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="81"><PARAGRAPH>Category</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="144"><PARAGRAPH>First Environment Variable</PARAGRAPH>
</CELL>
<CELL LEFT="240" WIDTH="144"><PARAGRAPH>Second Environment Variable</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>LC_COLLATE</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="144"><PARAGRAPH>LC_COLLATE</PARAGRAPH>
</CELL>
<CELL LEFT="240" WIDTH="144"><PARAGRAPH>LANG</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>LC_CTYPE</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="144"><PARAGRAPH>LC_CTYPE</PARAGRAPH>
</CELL>
<CELL LEFT="240" WIDTH="144"><PARAGRAPH>LANG</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>LC_MESSAGES</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="144"><PARAGRAPH>LC_MESSAGES</PARAGRAPH>
</CELL>
<CELL LEFT="240" WIDTH="144"><PARAGRAPH>LANG</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>LC_MONETARY</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="144"><PARAGRAPH>LC_MONETARY</PARAGRAPH>
</CELL>
<CELL LEFT="240" WIDTH="144"><PARAGRAPH>LANG</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>LC_NUMERIC</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="144"><PARAGRAPH>LC_NUMERIC</PARAGRAPH>
</CELL>
<CELL LEFT="240" WIDTH="144"><PARAGRAPH>LANG</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="144"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="240" WIDTH="144"><PARAGRAPH>LANG</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Specifying the category LC_ALL attempts to set each category individually to the value of the appropriate environment variable.</PARAGRAPH>
<PARAGRAPH>If no non-null environment variable is available, <FUNCTION>setlocale()</FUNCTION> returns the name of the current locale.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Nonempty Strings in Calls to setlocale()</TITLE><PARAGRAPH>Here are the possibilities for specifying the <INDEXTARGET ID="TIP_6.intl14"><!-- POSTPROCESSDATA: TIP_6.intl14|localization:nonempty stringslocales:nonempty strings --><VARIABLE>locale</VARIABLE> parameter: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>NULL </PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="299"><PARAGRAPH>Specifying a null pointer argument&mdash;not the same as the empty 
string&mdash;causes <FUNCTION>setlocale()</FUNCTION> to return the name of the current locale.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>&ldquo;C&rdquo;</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="299"><PARAGRAPH>Specifying a locale value of the single-character string &ldquo;C&rdquo; requests 
whatever locale the system uses as a default. (Note that this is a 
string and not just a character.)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH>Other strings</PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="299"><PARAGRAPH>Request a particular locale by specifying its name. This overrides 
any user preferences and should only be done with good reason.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="88353">Location of Locale-Specific Data</TITLE><PARAGRAPH>Except for XPG/4 message catalogs, locale-specific data (that is, the &ldquo;compiled&rdquo; files containing the collation information, monetary information, and so on) are located in <INDEXTARGET ID="TIP_6.intl15"><!-- POSTPROCESSDATA: TIP_6.intl15|locales:data locationlocales:location of data --><FILENAME>/usr/lib/locale/&lt;</FILENAME>locale><FILENAME>/</FILENAME>&lt;category>, where &lt;locale> and &lt;category> are the names of the locale and category, respectively. For example, the database for the LC_COLLATE category of the French locale <VARIABLE>fr</VARIABLE> would be in <FILENAME>/usr/lib/locale/fr/LC_COLLATE</FILENAME>.</PARAGRAPH>
<PARAGRAPH>There will probably be multiple locales symbolically linked to each other, usually in cases where a specific locale name points to the more general case. For example, <FILENAME>/usr/lib/locale/POSIX</FILENAME> might point to <FILENAME>/usr/lib/locale/C</FILENAME>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Locale Naming Conventions</TITLE><PARAGRAPH>A locale string is of the form<INDEXTARGET ID="TIP_6.intl16"><!-- POSTPROCESSDATA: TIP_6.intl16|locales:naming conventions --></PARAGRAPH>
<EXAMPLE>
<VARIABLE>language</VARIABLE>[_<VARIABLE>territory</VARIABLE>[.<VARIABLE>encoding</VARIABLE>]][@<VARIABLE>modifier</VARIABLE>]...
</EXAMPLE>
<PARAGRAPH>where</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><INDEXTARGET ID="TIP_6.intl17"><!-- POSTPROCESSDATA: TIP_6.intl17|internationalization:languages:in locale stringslocales:languages --><VARIABLE>language</VARIABLE> is the two-letter ISO 639 abbreviation for the language name.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><INDEXTARGET ID="TIP_6.intl18"><!-- POSTPROCESSDATA: TIP_6.intl18|internationalization:territorieslocales:territories --><VARIABLE>territory</VARIABLE> is the two-uppercase-letter ISO 3166 abbreviation for the territory name. (For a list of these abbreviations, see the table in <XREF IDREF="53705" TYPE="TITLE">Appendix&nbsp;A, &ldquo;ISO 3166 Country Names and Abbreviations.&rdquo;</XREF>)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><INDEXTARGET ID="TIP_6.intl19"><!-- POSTPROCESSDATA: TIP_6.intl19|internationalization:encodings:aboutlocales:encoding --><VARIABLE>encoding</VARIABLE> is the name of the character encoding (mapping between numbers and characters). For western languages, this is typically the codeset, such as 8859-1 or ASCII. For Asian languages, where an encoding may encode multiple codesets, the encodings themselves have names, such as UJIS or EUC (these encodings are described later in this section). <XREF IDREF="21113" TYPE="TITLE">&ldquo;Character Sets, Codesets, and Encodings&rdquo;</XREF> discusses codesets and encodings.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><INDEXTARGET ID="TIP_6.intl20"><!-- POSTPROCESSDATA: TIP_6.intl20|locales:modifiers --><VARIABLE>modifier</VARIABLE>s are not actually part of the locale name definition; they give more specific information about the desired localized behavior of an application. For example, under X11R5 or X11R6, a user can select an input method with modifiers. (To use the <COMMAND>xwnmo</COMMAND> Input Method server provided by Silicon Graphics, for example, add <FUNCTION>@im=_XWNMO</FUNCTION> to the locale string.) No standards exist for this part of a locale string.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Language data is implementation specific; databases for the language <VARIABLE>en</VARIABLE> (English) might contain British cultural data in England and American cultural data in the United States. If other than the default settings are required, the territory field may be used. For example, the above cases could be more strictly defined by setting LANG to <VARIABLE>en_GB</VARIABLE> or <VARIABLE>en_US</VARIABLE>. Full rigor might lead to <VARIABLE>en_GB.ISO 8859-1</VARIABLE> for England and <VARIABLE>en_US.ISO 8859-1 </VARIABLE>for the USA.</PARAGRAPH>
<PARAGRAPH>ANSI C has defined a special locale value of <INDEXTARGET ID="TIP_6.intl21"><!-- POSTPROCESSDATA: TIP_6.intl21|locales:C locale valueC local value --><VARIABLE>C</VARIABLE>. The <VARIABLE>C</VARIABLE> locale is guaranteed to work on all compliant systems and provides the user with the system's default locale. This default is typically American English and ASCII, but need not be. POSIX has also defined a special locale value, <VARIABLE>POSIX</VARIABLE>, which is identical to the <VARIABLE>C</VARIABLE> locale.</PARAGRAPH>
<PARAGRAPH>The length of the locale string may not exceed NL_LANGMAX characters (NL_LANGMAX is defined in <FILENAME>/usr/include/limits.h</FILENAME>). However, XPG/4 recommends that this string (not counting modifiers) not exceed 14 characters.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="40340">Limitations of the Locale System</TITLE><PARAGRAPH>This section explains multilingual support, misuse of locales, and the absence of filesystem information for encoding types.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="49439">Multilingual Support</TITLE><PARAGRAPH>There can be only one locale at a time associated with any given process in an internationalized system. Therefore, although multilingual applications&mdash;which give the appearance of using more than one locale at a time&mdash;can be created, internationalization does not provide inherent support for them. Here are two examples of multilingual programs:<INDEXTARGET ID="TIP_6.intl22"><!-- POSTPROCESSDATA: TIP_6.intl22|internationalization:multilingual supportmultilingual support --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>An application creates and maintains windows on four different displays, operated by four different users. The program has a single controlling process, which is associated with only one locale at any given time. However, the application can switch back and forth between locales as it switches between users, so the four users may each use a different locale.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>In a sophisticated editing system with a complex user interface, a user may wish to operate the interface in one language while entering or editing text in another. For instance, a user whose first language is German may wish to compose a Japanese document, using Japanese input and text manipulation, but with the user interface operating in German. (There is no standard interface for such behavior.)</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>In writing a multilingual application, the first task is identifying the locales for the program to run in and when they apply. (There is no standard method for performing this task.) Once the application has chosen the desired locales, it must do one of the following:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>fork, and then call <FUNCTION>setlocale()</FUNCTION> differently in each process</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>call <FUNCTION>setlocale()</FUNCTION> repeatedly as necessary to change from language to language</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Misuse of Locales</TITLE><PARAGRAPH>The LANG environment variable and the locale variables provide the freedom to configure a locale, but they do not protect the user from creating a nonsensical combination of settings. For example, you are allowed to set LANG to <ITALICS>fr</ITALICS> (French) and LC_COLLATE to <ITALICS>ja_JP.EUC</ITALICS> (Japanese). In such a case, string routines would assume text encoded in 8859-1&mdash;except for the sorting routines, which might assume French text and Japanese sorting rules. This would likely result in arbitrary-seeming behavior.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>No Filesystem Information for Encoding Types</TITLE><PARAGRAPH>The IRIX filesystem does not contain information about what encoding should be associated with any given data. Thus, applications must assume that data presented to an application in some locale is properly encoded for that locale. In other words, a file is interpreted differently depending on locale; there is no way to ask the file what it thinks its encoding is.<INDEXTARGET ID="TIP_6.intl23"><!-- POSTPROCESSDATA: TIP_6.intl23|internationalization:encodings:and filesystem --></PARAGRAPH>
<PARAGRAPH>For example, you may have created a file while in a Japanese locale using EUC. Later, you might try printing it while in a French locale. The results will likely resemble a random collection of Latin 1 characters.</PARAGRAPH>
<PARAGRAPH>This problem applies to almost all stored strings. Most strings are uninterpreted sequences of nonzero bytes. This includes, for example, filenames. You can, if you want to, name your files using Chinese characters in a Chinese locale, but the names will look odd to anyone who runs <COMMAND>/bin/ls</COMMAND> on the same filesystem using a non-Chinese locale.</PARAGRAPH>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="21113">Character Sets, Codesets, and Encodings</TITLE><PARAGRAPH>One major difference between nationalized and internationalized software is the availability in internationalized software of a wide variety of methods for encoding characters. Developers of internationalized software no longer have the convenience of always being able to assume ASCII. Three terms that describe groupings of characters are the following: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><INDEXTARGET ID="TIP_6.intl24"><!-- POSTPROCESSDATA: TIP_6.intl24|internationalization:character sets:definedinternationalization:codesets:definedcharacter sets. <ITALICS>See </ITALICS>internationalization, character sets --><ITALICS>character set</ITALICS></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="333"><PARAGRAPH>An abstract collection of characters.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><ITALICS>codeset</ITALICS></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="333"><PARAGRAPH>A character set with exactly one associated numerical encoding for each 
character. The English alphabet is a character set; ASCII is a codeset.<INDEXTARGET ID="TIP_6.intl25"><!-- POSTPROCESSDATA: TIP_6.intl25|codesets. <ITALICS>See </ITALICS>internationalization, codesets --></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="63"><PARAGRAPH><INDEXTARGET ID="TIP_6.intl26"><!-- POSTPROCESSDATA: TIP_6.intl26|internationalization:encodings:definedencodings. <ITALICS>See </ITALICS>internationalization, encodings --><ITALICS>encoding</ITALICS></PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="333"><PARAGRAPH>A set of characters and associated numbers; however, this term is more 
general than &ldquo;codeset.&rdquo; A single encoding may include multiple codesets; 
<ITALICS>Extended UNIX Code (EUC</ITALICS>), for instance, is an encoding that provides for 
four codesets in one data stream.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>This section describes these topics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="19794" TYPE="TITLE">&ldquo;Eight-Bit Cleanliness&rdquo;</XREF> explains how to make 8-bit clean characters.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="47047" TYPE="TITLE">&ldquo;Character Representation&rdquo;</XREF> discuses multibyte and wide characters.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="55810" TYPE="TITLE">&ldquo;Multibyte Characters&rdquo;</XREF> covers using and handling multibyte characters, conversions to constant-size characters, and the number of bytes in a character and string.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="25088" TYPE="TITLE">&ldquo;Wide Characters&rdquo;</XREF> explains <COMMAND>wchar</COMMAND> strings, support routines, and conversion to multibyte characters.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="52862" TYPE="TITLE">&ldquo;Reading Input Data&rdquo;</XREF> covers nonuser-originated data.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>For information on installing and using fonts with an application, refer to <XREF IDREF="49176" TYPE="TITLE">Chapter&nbsp;15, &ldquo;Working With Fonts.&rdquo;</XREF></PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="19794">Eight-Bit Cleanliness</TITLE><PARAGRAPH>A program is <INDEXTARGET ID="TIP_6.intl27"><!-- POSTPROCESSDATA: TIP_6.intl27|internationalization:codesets:ASCIIinternationalization:eight-bit cleanliness8-bit clean codesets --><ITALICS>8-bit clean</ITALICS> if it does not use the high bit of any data byte to convey special information. ASCII characters are specified by the low seven bits of a byte, so some programs use the high bit of a data byte as a flag; such programs are not 8-bit clean. Internationalized programs must be 8-bit clean, because they cannot expect data to be in the form of ASCII bytes; non-ASCII character sets usually use all eight bits of each byte to specify the character. But a program must go out of its way to manipulate bytes based on the value of the high bit, and since changing data without cause is seldom desirable, most programs are already 8-bit clean.</PARAGRAPH>
<PARAGRAPH>The old <COMMAND>csh</COMMAND> (before this problem was fixed in the IRIX 5.0 release) was a good example of a program that was not 8-bit clean; it used the high bit in input strings to distinguish aliases from unaliased commands. An effect of this misuse was that <COMMAND>csh</COMMAND> stripped the eighth bit from all characters. For example, the user command</PARAGRAPH>
<EXAMPLE>
echo I know an architect named Ma&ntilde;osa
</EXAMPLE>
<PARAGRAPH>Produced the response</PARAGRAPH>
<EXAMPLE>
I know an architect named Maqosa
</EXAMPLE>
<PARAGRAPH>Another example is the specification of Internet messages, which calls for 7-bit data. Thus, if <COMMAND>sendmail</COMMAND> fails to strip the 8th bit from a character prior to sending it, it violates a protocol; if it does strip the bit, it could garble a non-ASCII message (this protocol problem is being addressed).</PARAGRAPH>
<PARAGRAPH>One of the simplest things to do to remove the American bias from a program is to replace the ASCII assumption with the assumption that the Latin 1 codeset will be used. This approach is not true internationalization, but it can make the application usable in most of Western Europe. Latin 1 uses only one byte per character, unlike some other codesets, so 8-bit clean ASCII software should work without modification using the Latin&nbsp;1 codeset.</PARAGRAPH>
<PARAGRAPH>Ensuring that code is 8-bit clean is the single most important aspect of internationalizing software.</PARAGRAPH>
<PARAGRAPH>Another caveat about 8-bit characters applies only to a particular set of circumstances: If you are not using a multibyte character type (see the next section), you should not declare characters as type <INDEXTARGET ID="TIP_6.intl28"><!-- POSTPROCESSDATA: TIP_6.intl28|internationalization:signed chars --><VARIABLE>signed char</VARIABLE>. (The default in IRIX C is for <VARIABLE>char</VARIABLE> to imply <VARIABLE>unsigned char</VARIABLE>.) If you try to cast a <VARIABLE>signed char</VARIABLE> to an <VARIABLE>int</VARIABLE> (as you must do to use the <FUNCTION>ctype()</FUNCTION> functions) and the character's high bit is set (as it may be in an 8-bit character set), the high bit is interpreted as a sign bit and extends into the full width of the int.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="47047">Character Representation</TITLE><PARAGRAPH>Western languages usually require only one byte for each character. Asian languages, however, often require two or even four bytes per character, and some Asian encodings allow a variable number of bytes per character.<INDEXTARGET ID="TIP_6.intl29"><!-- POSTPROCESSDATA: TIP_6.intl29|multibyte characters. <ITALICS>See </ITALICS>internationalization, multibyte charactersinternationalization:multibyte characters --></PARAGRAPH>
<PARAGRAPH>The two kinds of encodings that allow more than one byte per character are<INDEXTARGET ID="TIP_6.intl30"><!-- POSTPROCESSDATA: TIP_6.intl30|internationalization:encodings:<ITALICS>wchar</ITALICS>internationalization:wide characters:aboutinternationalization:encodings:multibyte --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>multibyte (MB) characters are of variable size</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>wide characters (WC or wchar characters) are a fixed number of bytes long) </PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>The application developer must decide where to use WC and MB characters and strings:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Multibyte strings are almost the default: string I/O uses MB, MB code works for ASCII and ISO&nbsp;8859, and MB characters use less space than do wide characters. However, manipulating individual characters within a multibyte string is difficult.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>Traditional strings are merely a special case of multibyte strings, where every character happens to be one byte long and there is only one codeset. All MB code, including conversion to and from wchars, works for traditional ASCII, or ISO 8859, strings.<INDEXTARGET ID="TIP_6.intl31"><!-- POSTPROCESSDATA: TIP_6.intl31|internationalization:codesets:ASCIIASCII strings. <ITALICS>See </ITALICS>internationalization:codesets, ASCII --></NOTE>
</BULLET>
<BULLET><PARAGRAPH>Applications that do heavy string manipulation typically use WC strings for such activity, because manipulating individual WC characters in a string is much simpler than doing the same thing with MB characters. So wide characters are used as necessary to provide programming ease or runtime speed; however, they take up more space than MB characters. </PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>WC is system dependent&mdash;applications should not use it for I/O strings or communication.</NOTE>
</BULLET>
</BULLETLIST>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="55810">Multibyte Characters</TITLE><PARAGRAPH>A multibyte character is a series of bytes. The character itself contains information on how many bytes long it is. Multibyte characters are referenced as strings (and are therefore of type <INDEXTARGET ID="TIP_6.intl32"><!-- POSTPROCESSDATA: TIP_6.intl32|internationalization:multibyte characters:using --><VARIABLE>char *</VARIABLE>); before parsing, a string is indistinguishable from a multibyte character. The zero byte is still used as a string (and MB character) terminator.</PARAGRAPH>
<PARAGRAPH>A string of MB characters can be considered a null-terminated array of bytes, exactly like a traditional string. A multibyte string may contain characters from multiple codesets. Usually, this is done by incorporating special bytes that indicate that the next character (and only the next character) will be in a different codeset. Very little application code should ever need to be aware of that, though; you should use the available library routines to find out information about multibyte strings rather than look at the underlying byte structure, because that structure varies from one encoding to another. For one example of an encoding that allows characters from multiple codesets, see <XREF IDREF="31663" TYPE="TITLE">&ldquo;EUC&rdquo;</XREF>.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Use of Multibyte Strings </TITLE><PARAGRAPH>Multibyte strings are very easy to pass around. They efficiently use space (both data and disk space), since &ldquo;extra&rdquo; bytes are used only for characters that require them. MB strings can be read and written without regard to their contents, as long as the strings remain intact. Displaying MB strings on a terminal is done with the usual routines: <FUNCTION>printf()</FUNCTION>, <FUNCTION>puts()</FUNCTION>, and so on. Many programs (such as <COMMAND>cat</COMMAND>) need never concern themselves with the multibyte nature of MB strings, since they operate on bytes rather than on characters; so MB strings are often used for string I/O.</PARAGRAPH>
<PARAGRAPH>Manipulation of individual characters in an MB string can be difficult, since finding a particular character or position in a string is nontrivial (see <XREF IDREF="59943" TYPE="TITLE">&ldquo;Handling Multibyte Characters,&rdquo;</XREF> below). Therefore, it is common to convert to WC strings for that kind of work.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="59943">Handling Multibyte Characters</TITLE><PARAGRAPH>Usually, multibyte characters are handled just like <VARIABLE>char</VARIABLE> strings. Editing such strings, however, requires some care.</PARAGRAPH>
<PARAGRAPH>You cannot tell how many bytes are in a particular character until you look at the character. You cannot look at the <VARIABLE>n</VARIABLE>th character in a string without looking at all the previous <VARIABLE>n</VARIABLE> - 1 characters, because you cannot tell where a character starts without knowing where the previous character ends. Given a byte, you don't know its position within a character. Thus, we say the string has <ITALICS>state</ITALICS> or is <ITALICS>context-sensitive</ITALICS>; that is, the interpretation we assign to any given byte depends on where we are in a character.</PARAGRAPH>
<PARAGRAPH>This analysis of characters is locale-dependent, and therefore must be done by routines that understand locale.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Conversion to Constant-Size Characters</TITLE><PARAGRAPH>Multibyte characters and strings are convertible to wchars using <INDEXTARGET ID="TIP_6.intl33"><!-- POSTPROCESSDATA: TIP_6.intl33|internationalization:multibyte characters:converting --><FUNCTION>mbtowc()</FUNCTION> for individual characters and <FUNCTION>mbstowcs()</FUNCTION> for strings (see the <REFPAGE>mbtowc(3)</REFPAGE> and <REFPAGE>mbstowcs()</REFPAGE> reference pages).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Finding the Number of Bytes in a Character</TITLE><PARAGRAPH>To find out how many bytes make up a given single MB character, use <INDEXTARGET ID="TIP_6.intl34"><!-- POSTPROCESSDATA: TIP_6.intl34|internationalization:multibyte characters:size of --><FUNCTION>mblen()</FUNCTION>, as shown in <XREF IDREF="89825" TYPE="TEXT">Example&nbsp;16-1</XREF> (see also the <REFPAGE>mblen(3)</REFPAGE> reference page).</PARAGRAPH>
<CODE><CAPTION LBL="16-1"><PREFIX>Example 16-1 </PREFIX><XREFTARGET ID="89825">Find Number of Bytes in an MB Character</CAPTION>#include &lt;stdlib.h>
. . .
size_t n;
int len;
char *pStr;
. . .
len = mblen(pStr, n); /* examine no more than n bytes */
</CODE>
<PARAGRAPH>It is the application's responsibility to ensure that <VARIABLE>pStr</VARIABLE> points to the beginning of a character, not to the middle of a character.</PARAGRAPH>
<PARAGRAPH>The maximum number of bytes in a multibyte character is MB_LEN_MAX, which is defined in <FILENAME>limits.h</FILENAME>. The maximum number of bytes in a character under the current locale is given by the macro MB_CUR_MAX, defined in <FILENAME>stdlib.h</FILENAME>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>How Many Bytes in an MB String?</TITLE><PARAGRAPH>Since <INDEXTARGET ID="TIP_6.intl35"><!-- POSTPROCESSDATA: TIP_6.intl35|internationalization:multibyte characters:string length --><FUNCTION>strlen()</FUNCTION> simply counts bytes before the first NULL, it tells you how many bytes are in an MB string.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>How Many Characters in an MB String?</TITLE><PARAGRAPH>When <FUNCTION>mbstowcs()</FUNCTION> converts MB strings to WC strings, it returns the number of characters converted. This is the simplest way to count characters in an MB string.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>Many code segments that deal with individual characters within a string are better served by wide character strings. Because counting often involves conversion, such segments are often better served by working with a WC string, then converting back. </NOTE>
<PARAGRAPH>Getting the length without performing the conversion is straightforward, but not as simple. <FUNCTION>mbtowc()</FUNCTION> converts one character and returns the number of bytes used, but returns the same information without conversion if a NULL is passed as the address of the WC destination. Thus</PARAGRAPH>
<CODE>
len = mblen(pStr, n);
</CODE>
<PARAGRAPH>is equivalent to</PARAGRAPH>
<CODE>
len = mbtowc((wchar_t *) NULL, pStr, n);
</CODE>
<PARAGRAPH>In fact, <FUNCTION>mblen()</FUNCTION> calls <FUNCTION>mbtowc()</FUNCTION> to perform its count. Therefore, counting characters in an MB string without converting would look like the code in <XREF IDREF="98223" TYPE="TEXT">Example&nbsp;16-2</XREF>.</PARAGRAPH>
<CODE><CAPTION LBL="16-2"><PREFIX>Example 16-2 </PREFIX><XREFTARGET ID="98223">Counting MB Characters Without Conversion</CAPTION>int cLen;
char *tStr = pStr;
numChars = 0;
cLen = mbtowc((wchar_t *) NULL, tStr, MB_CUR_MAX);
while&nbsp;(cLen&nbsp;>&nbsp;0)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;tStr&nbsp;+=&nbsp;cLen;
&nbsp;&nbsp;&nbsp;&nbsp;numChars++;
&nbsp;&nbsp;&nbsp;&nbsp;cLen&nbsp;=&nbsp;mbtowc((wchar_t&nbsp;*)&nbsp;NULL,&nbsp;tStr,&nbsp;MB_CUR_MAX);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(cLen&nbsp;==&nbsp;-1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numChars&nbsp;=&nbsp;cLen;&nbsp;/*&nbsp;invalid&nbsp;MB&nbsp;character&nbsp;*/
}
</CODE>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="25088">Wide Characters</TITLE><PARAGRAPH>A wide character (<INDEXTARGET ID="TIP_6.intl36"><!-- POSTPROCESSDATA: TIP_6.intl36|internationalization:encodings:<ITALICS>wchar</ITALICS>wide characters. <ITALICS>See </ITALICS>internationalization, wide charactersinternationalization:wide characters --><ITALICS>WC</ITALICS> or <ITALICS>wchar</ITALICS>) is a data object of type <VARIABLE>wchar_t</VARIABLE>, which is guaranteed to be able to hold the system's largest numerical code for a character. <VARIABLE>wchar_t</VARIABLE> is defined in <FILENAME>stdlib.h</FILENAME>. Under IRIX 4.0.x, <FUNCTION>sizeof(wchar_t)</FUNCTION> was 1. In IRIX 5.1 and above, it is 4. All wchars on a system are the same size, independent of locale, encoding, or any other factors.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Uses for wchar Strings</TITLE><PARAGRAPH>The single advantage of WC strings is that all characters are the same size. Thus, a string can be treated as an array, and a program can simply index into the array in order to modify its contents. Most applications' <VARIABLE>char</VARIABLE> manipulation routines work with little modification other than a type change to <VARIABLE>wchar_t</VARIABLE>, with appropriate attention to byte count and <FUNCTION>sizeof()</FUNCTION>.</PARAGRAPH>
<PARAGRAPH>So, when applications have significant string editing to perform, they typically keep the strings in WC format while doing that editing. Those WC strings may or may not be converted to or from MB strings at other points in the application.</PARAGRAPH>
<PARAGRAPH>Wide characters are often large and are not as space efficient as multibyte strings. Applications that do not need to perform string editing probably shouldn't use<VARIABLE>&space;wchar</VARIABLE>s. If an application intends to both maintain and edit large numbers of strings, then the developer needs to make size and complexity trade-off decisions.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Support Routines for Wide Characters</TITLE><PARAGRAPH>Analogs to the routines defined in <FILENAME>string.h</FILENAME> and <FILENAME>stdio.h</FILENAME> are supplied in <FILENAME>libw.a</FILENAME> and defined in <FILENAME>widec.h</FILENAME>. This includes routines such as <FUNCTION>getwchar()</FUNCTION>, <FUNCTION>putwchar()</FUNCTION>, <FUNCTION>putws()</FUNCTION>, <FUNCTION>wscpy()</FUNCTION>, <FUNCTION>wslen()</FUNCTION>, and <FUNCTION>wsrchr()</FUNCTION> (see the <REFPAGE>wcstring(3)</REFPAGE> reference page).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Conversion to MB Characters</TITLE><PARAGRAPH>Wide characters and strings are convertible to MB strings via <INDEXTARGET ID="TIP_6.intl37"><!-- POSTPROCESSDATA: TIP_6.intl37|internationalization:wide characters:converting --><FUNCTION>wctomb()</FUNCTION> and <FUNCTION>wcstombs()</FUNCTION>, respectively.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="52862">Reading Input Data</TITLE><PARAGRAPH>Input can be divided into two categories: user events and other data. This section deals with nonuser-originated data, which is assumed to come from file descriptors or streams. User events are discussed in <INDEXTARGET ID="TIP_6.intl38"><!-- POSTPROCESSDATA: TIP_6.intl38|internationalization:file I/O --><XREF IDREF="98616" TYPE="TITLE">&ldquo;Translating User Input&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>It is generally fair to assume that unless otherwise specified, data read by an application is encoded suitably for the current locale. Text strings typically are in MB format.</PARAGRAPH>
<PARAGRAPH>Streams can be read in WC format by using routines defined in <FILENAME>widec.h</FILENAME>.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="93180">Cultural Items</TITLE><PARAGRAPH>This section discusses several aspects of a locale that may differ between locales. It includes these topics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="55382" TYPE="TITLE">&ldquo;Collating Strings&rdquo;</XREF> describes string collation.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="92734" TYPE="TITLE">&ldquo;Specifying Numbers and Money&rdquo;</XREF> explains some monetary formats, and the <FUNCTION>printf()</FUNCTION> and <FUNCTION>localeconv()</FUNCTION> functions.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="89878" TYPE="TITLE">&ldquo;Formatting Dates and Times&rdquo;</XREF> covers using <FUNCTION>strftime()</FUNCTION> to format of dates and times.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="29929" TYPE="TITLE">&ldquo;Character Classification and ctype&rdquo;</XREF> discusses associations between character codes, and using macros and functions from <FILENAME>/usr/lib/ctype.h</FILENAME>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="45624" TYPE="TITLE">&ldquo;Regular Expressions&rdquo;</XREF> presents information for developers who do their own regular expression parsing and matching.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Also see <XREF IDREF="97000" TYPE="TITLE">&ldquo;Cultural Data&rdquo;</XREF> for additional information.</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="55382">Collating Strings</TITLE><PARAGRAPH>Different locales can have different rules governing collation of strings, even within identical encodings.<INDEXTARGET ID="TIP_6.intl39"><!-- POSTPROCESSDATA: TIP_6.intl39|internationalization:sorting ruleslocales:sorting rules --></PARAGRAPH>
<PARAGRAPH>In English, sorting rules are extremely simple: each character sorts to exactly one unique place. Under ASCII (C locale), the characters are even in numeric order. However, neither of those statements is necessarily true for other languages and other codesets. It should be noted that the sorting in en_US locale is different from sorting in C locale. As a result, en_US is not equal to C locale. Furthermore:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Sorting order for a language may be completely unrelated to the (numerical) order of the characters in a given encoding.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Even with a correctly sorted list of the characters in a character set, you may not be able to sort words properly.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Locales using identically encoded character sets may use very different sorting rules.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Programs using ASCII can do simple arithmetic on characters and directly calculate sorting relationships; such programs frequently rely on truisms such as the fact that</PARAGRAPH>
<EXAMPLE>
'a' &lt; 'b'
</EXAMPLE>
<PARAGRAPH>in ASCII. But internationalized programs cannot rely on ASCII and English sorting rules. Consider some non-English collation rule types:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><ITALICS>One-to-Two</ITALICS> mappings collate certain characters as if they were two. For example, the German <ITALICS>&szlig;</ITALICS> collates as if it were &ldquo;ss.&rdquo;</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><ITALICS>Many-to-One</ITALICS> mappings collate a string of characters as if they were one. For example, Spanish sorts &ldquo;ch&rdquo; as one character, following &ldquo;c&rdquo; and preceding &ldquo;d.&rdquo; In Spanish, the following list is in correct alphabetical order: <ITALICS>calle</ITALICS>, <ITALICS>creo</ITALICS>, <ITALICS>chocolate</ITALICS>, <ITALICS>decir</ITALICS>.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><ITALICS>Don't-Care Character</ITALICS> rules collate certain characters as if they were not present. For example, if &ldquo;-&rdquo; were a don't-care character, &ldquo;co-op&rdquo; and &ldquo;coop&rdquo; would sort identically.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><ITALICS>First-Vowel</ITALICS> rules sort words based first on the first vowel of the word, then by consonants (which may precede or follow the vowel in question).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><ITALICS>Primary/Secondary</ITALICS> sorts consider some characters as equals until there is a tie. For example, in French, a, &aacute;, &agrave;, and &acirc; all sort to the same primary location. If two strings (such as &ldquo;tache&rdquo; and &ldquo;t&acirc;che&rdquo;) collate to the same primary order, then the secondary sort distinguishes them.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Special case sorts exist for some Asian languages. For example, Japanese <ITALICS>kanji</ITALICS> has no strict sorting rules. <ITALICS>Kanji</ITALICS> strings can be sorted by the strokes that make up the characters, by the <ITALICS>kana</ITALICS> (phonetic) spellings of the characters, or by other agreed-upon rules.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>It should be clear that a programmer cannot hope to collate strings by simple arithmetic or by traditional methods.</PARAGRAPH>
<PARAGRAPH>Locale-specific collation should be performed with <INDEXTARGET ID="TIP_6.intl40"><!-- POSTPROCESSDATA: TIP_6.intl40|locales:collation --><FUNCTION>strcoll()</FUNCTION> and <FUNCTION>strxfrm()</FUNCTION>. These are table-driven functions; the tables are supplied as part of locale support. The value of LC_COLLATE determines which ordering table to use. (See the <REFPAGE>strcoll(3)</REFPAGE> and <REFPAGE>strxfrm(3)</REFPAGE> reference pages.)</PARAGRAPH>
<PARAGRAPH><FUNCTION>strcoll()</FUNCTION> has the same interface as <FUNCTION>strcmp()</FUNCTION> and can be directly substituted into code that uses <FUNCTION>strcmp()</FUNCTION>. However, <FUNCTION>strcoll()</FUNCTION> can consume more CPU time, so where it is used in a time-critical loop you may have to redesign.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="92734">Specifying Numbers and Money</TITLE><PARAGRAPH>Format of simple numbers differs from locale to locale. Characters used for decimal radix and group separators vary. Grouping rules may also vary. Even though we assume that decimal numbers are universal, there are some eighteen varying aspects of numeric formatting defined by a locale. Many of these are details of monetary formatting.<INDEXTARGET ID="TIP_6.intl41"><!-- POSTPROCESSDATA: TIP_6.intl41|internationalization:numerical formatsinternationalization:monetary formatslocales:numerical formatslocales:monetary formats --></PARAGRAPH>
<PARAGRAPH>For example, Germany uses a comma to denote a decimal radix and a period to denote a group separator. English reverses these. India groups digits by two except for the last three digits before the decimal radix. Many locales have particular formats used for money, some of which are shown in <XREF IDREF="26942" TYPE="TABLE">Table&nbsp;16-3</XREF>. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="16-3"><PREFIX>Table 16-3 </PREFIX><XREFTARGET ID="26942">Some Monetary Formats</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Country</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="126"><PARAGRAPH>Positive Format</PARAGRAPH>
</CELL>
<CELL LEFT="215" WIDTH="126"><PARAGRAPH>Negative Format</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>India</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="126"><PARAGRAPH>Rs1,02,34,567.89</PARAGRAPH>
</CELL>
<CELL LEFT="215" WIDTH="126"><PARAGRAPH>Rs(1,02,34,567.89)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Italy</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="126"><PARAGRAPH>L.10.234.567</PARAGRAPH>
</CELL>
<CELL LEFT="215" WIDTH="126"><PARAGRAPH>-L.10.234.567</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Japan</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="126"><PARAGRAPH>&yen;10,234,567</PARAGRAPH>
</CELL>
<CELL LEFT="215" WIDTH="126"><PARAGRAPH>-&yen;10,234,567</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Netherlands</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="126"><PARAGRAPH>F10.234.567,89</PARAGRAPH>
</CELL>
<CELL LEFT="215" WIDTH="126"><PARAGRAPH>F-10.234.567,89</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Norway</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="126"><PARAGRAPH>Kr10.234.567,89</PARAGRAPH>
</CELL>
<CELL LEFT="215" WIDTH="126"><PARAGRAPH>Kr10.234.567,89-</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Switzerland</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="126"><PARAGRAPH>SFr10,234,567.89</PARAGRAPH>
</CELL>
<CELL LEFT="215" WIDTH="126"><PARAGRAPH>SFr10,234,567.89C</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<SECTION3 LBL="" HELPID = ""><TITLE>Using printf()</TITLE><PARAGRAPH><INDEXTARGET ID="TIP_6.intl42"><!-- POSTPROCESSDATA: TIP_6.intl42|internationalization:<ITALICS>printf()</ITALICS> --><FUNCTION>printf()</FUNCTION> function, detailed in the <REFPAGE>printf(3S)</REFPAGE> reference page, examines LC_NUMERIC and chooses the appropriate decimal radix. If none is available, it tries to use ASCII period. No further locale-specific formatting is done directly by <FUNCTION>printf()</FUNCTION>. However, see <XREF IDREF="15279" TYPE="TITLE">&ldquo;Variably Ordered Referencing of printf() Arguments,&rdquo;</XREF> for a way to handle locale-specific ordering of syntactic elements in messages.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using localeconv()</TITLE><PARAGRAPH>The <INDEXTARGET ID="TIP_6.intl43"><!-- POSTPROCESSDATA: TIP_6.intl43|internationalization:<ITALICS>localeconv()</ITALICS> --><FUNCTION>localeconv()</FUNCTION> function, detailed in the <REFPAGE>localeconv(3C)</REFPAGE> reference page, can be called to find out about numeric formatting data, including the decimal radix (inappropriately called <VARIABLE>decimal_point</VARIABLE>), the grouping separator (inappropriately called <VARIABLE>thousands_sep</VARIABLE>), the grouping rules, and a great deal of monetary formatting information.</PARAGRAPH>
<PARAGRAPH>The <FUNCTION>localeconv()</FUNCTION> function leaves actual use of formatting information other than the decimal radix to the application.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using strfmon()</TITLE><PARAGRAPH>The <FUNCTION>strfmon()</FUNCTION> function, detailed in the <REFPAGE>strfmon(3S)</REFPAGE> reference page, is new with IRIX version&nbsp;6.2. Like <FUNCTION>sprintf()</FUNCTION>, <FUNCTION>strfmon()</FUNCTION> takes an output area, a format string that contains conversion specifications, and one or more argument values to be converted. It creates an output string containing fixed data and converted values.</PARAGRAPH>
<PARAGRAPH>Only two conversion types are supported: <VARIABLE>%i</VARIABLE> to convert a double value to international currency representation, and <VARIABLE>%n</VARIABLE> to convert a double value to national currency representation. You can use <FUNCTION>strfmon()</FUNCTION> to format currency values as strings, and then use <FUNCTION>printf()</FUNCTION> or other functions to write the formatted strings.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="89878">Formatting Dates and Times</TITLE><PARAGRAPH>All of these dates can mean the same thing to different people:<INDEXTARGET ID="TIP_6.intl44"><!-- POSTPROCESSDATA: TIP_6.intl44|internationalization:date formatsinternationalization:time formatslocales:date formatslocales:time formats --></PARAGRAPH>
<EXAMPLE>
92.1.4
4/1/92
1/4/92
</EXAMPLE>
<PARAGRAPH>All of these can mean the same time to different people:</PARAGRAPH>
<EXAMPLE>
2:30 PM
14:30
14h30
</EXAMPLE>
<PARAGRAPH>Dates and times can be easily formatted by using <FUNCTION>strftime()</FUNCTION>, which gives a host of options for displaying locale-specific dates and times. The <FUNCTION>ascftime()</FUNCTION> and <FUNCTION>cftime()</FUNCTION> functions give further options, but should be avoided because they do not conform to ANSI and XPG/4 specifications. The old <FUNCTION>asctime()</FUNCTION> and <FUNCTION>ctime()</FUNCTION> functions are now obsolete; use <FUNCTION>strftime()</FUNCTION> instead. For more information, see the <REFPAGE>strftime(3C)</REFPAGE> reference page.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="29929">Character Classification and ctype</TITLE><PARAGRAPH>The <INDEXTARGET ID="TIP_6.intl45"><!-- POSTPROCESSDATA: TIP_6.intl45|internationalization:<ITALICS>ctype</ITALICS>internationalization:character classification<ITALICS>ctype</ITALICS>:character classification --><FILENAME>ctype.h</FILENAME> header file is described in the <REFPAGE>ctype(3C)</REFPAGE> reference page and defines macros to determine various kinds of information about a given character: <FUNCTION>isalpha()</FUNCTION>, <FUNCTION>isupper()</FUNCTION>, <FUNCTION>islower()</FUNCTION>, <FUNCTION>isdigit()</FUNCTION>, <FUNCTION>isxdigit()</FUNCTION>, <FUNCTION>isalnum()</FUNCTION>, <FUNCTION>isspace()</FUNCTION>, <FUNCTION>ispunct()</FUNCTION>, <FUNCTION>isprint()</FUNCTION>, <FUNCTION>isgraph()</FUNCTION>, <FUNCTION>iscntrl()</FUNCTION>, and <FUNCTION>isascii()</FUNCTION>.</PARAGRAPH>
<PARAGRAPH>When programmers knew that a character set was ASCII, some convenient assumptions could be made about characters and letters. It was common for programmers to do arithmetic with the ASCII code values in order to perform some simple operations. For example, raising a character to upper case could be done by subtracting the difference between the code for <VARIABLE>a</VARIABLE> and the code for <VARIABLE>A</VARIABLE>. Numeric characters could be identified by inspection: if they fell between <VARIABLE>0</VARIABLE> and <VARIABLE>9</VARIABLE>, they were numeric; otherwise, they weren't. You could tell if a character was (for instance) printable, a letter, or a symbol by comparing to known encoding values. Macros for such activity have long been available in <FILENAME>ctype.h</FILENAME>, but lots of programs did character arithmetic anyway. Since character encoding and linguistic semantics are completely independent, such arithmetic in an internationalized program leads to unpleasant results.</PARAGRAPH>
<PARAGRAPH>Furthermore, characters exist outside of ASCII that break some non-arithmetic assumptions. Consider the German character <ITALICS>&szlig;</ITALICS> which is a lowercase alphabetic character (letter), yet has no uppercase. Consider also French (as written in France), where the uppercase of <ITALICS>&eacute;</ITALICS> is <ITALICS>E</ITALICS>, not <ITALICS>&Eacute;</ITALICS>.</PARAGRAPH>
<PARAGRAPH>Clearly, the programmer of an internationalized application has no way of directly computing all the character associations that were available in English under ASCII.</PARAGRAPH>
<PARAGRAPH>Strict avoidance of arithmetic on character values should remove any trouble in this area. The macros in <FILENAME>ctype.h</FILENAME> are table-driven and are therefore locale-sensitive. If you think of characters as abstract characters rather than as the numbers used to represent them, you can avoid pitfalls in this area.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="45624">Regular Expressions</TITLE><PARAGRAPH>XPG/4 specifies some extensions to traditional regular expression syntax for internationalized software. Few application developers do their own regular expression parsing and matching, however, so we do not include full details here. Briefly, the extensions provide the ability to specify matches based on:<INDEXTARGET ID="TIP_6.intl46"><!-- POSTPROCESSDATA: TIP_6.intl46|internationalization:regular expressionsinternationalization:XPG/3:regular expressions --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>character class (such as <ITALICS>alpha</ITALICS>, <ITALICS>digit</ITALICS>, <ITALICS>punct</ITALICS>, or <ITALICS>space</ITALICS>)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>equivalence class (for instance, <ITALICS>a</ITALICS>, <ITALICS>&aacute;</ITALICS>, <ITALICS>&agrave;</ITALICS>, <ITALICS>&acirc;</ITALICS>, <ITALICS>A</ITALICS>, <ITALICS>&Aacute;</ITALICS>, <ITALICS>&Agrave;</ITALICS>, and <ITALICS>&Acirc;</ITALICS> may be equivalent)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>collating symbols (allowing you to match the Spanish <ITALICS>ch</ITALICS> as one element because it is a single collating token)</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>generalization of range specifications of the form <ITALICS>[c</ITALICS><SUBSCRIPT>1</SUBSCRIPT><ITALICS>-c</ITALICS><SUBSCRIPT>2</SUBSCRIPT><ITALICS>]</ITALICS> to include the above</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>If you are processing expressions, see the description of internationalized regular expression grammar in <XREF IDREF="49962" TYPE="TITLE">&ldquo;Using Regular Expressions.&rdquo;</XREF></PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="65867">Locale-Specific Behavior</TITLE><PARAGRAPH>You can internationalize an application so it can span a range of language and cultural environments. This section covers some locale-specific topics you should consider when internationalizing an application. Topics include<INDEXTARGET ID="TIP_6.intl47"><!-- POSTPROCESSDATA: TIP_6.intl47|internationalization:locale-specific behavior --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="29972" TYPE="TITLE">&ldquo;Overview of Locale-Specific Behavior&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="69295" TYPE="TITLE">&ldquo;Native Language Support and the NLS Database&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="49962" TYPE="TITLE">&ldquo;Using Regular Expressions&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="97000" TYPE="TITLE">&ldquo;Cultural Data&rdquo;</XREF></PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Much of the information in this section is from the <DOCTITLE>X/Open Portability Guide</DOCTITLE>. For additional information on locale-specific behavior, refer to the <DOCTITLE>X/Open Portability Guide</DOCTITLE>, <DOCTITLE>Volume 3</DOCTITLE>, &ldquo;XSI<DOCTITLE>&space;Supplementary Definitions</DOCTITLE>.&rdquo;</PARAGRAPH>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="29972">Overview of Locale-Specific Behavior</TITLE><PARAGRAPH>This section covers</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="10307" TYPE="TITLE">&ldquo;Local Customs&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="79523" TYPE="TITLE">&ldquo;Regular Expressions&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="64791" TYPE="TITLE">&ldquo;ANSI X3.159-198X Standard for C&rdquo;</XREF></PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="10307">Local Customs</TITLE><PARAGRAPH>To meet the requirements of local customs, the X/Open Native Language System (NLS) interface provides a set of library functions that allow cultural data appropriate to the user to be determined at run-time.<INDEXTARGET ID="TIP_6.intl48"><!-- POSTPROCESSDATA: TIP_6.intl48|internationalization:customs --></PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="79523">Regular Expressions</TITLE><PARAGRAPH>Regular expressions provide pattern-matching facilities for text. A variety of regular expression support libraries are supplied with IRIX. Most of them parse regular expressions in terms of machine collating sequences, the English language, and the ASCII coded character set.<INDEXTARGET ID="TIP_6.intl49"><!-- POSTPROCESSDATA: TIP_6.intl49|internationalization:regular expressions --></PARAGRAPH>
<PARAGRAPH>When a program deals with internationalized input text, it is important to extend regular expression facilities to cover internationalized strings and coded character sets. It is difficult to write regular expressions that apply to more than one language, or to languages with accented/multi-character collating elements because of limitations in syntax.</PARAGRAPH>
<PARAGRAPH>Application programs can use the <COMMAND>wsregexp</COMMAND> function library, documented in the <REFPAGE>wsregexp(3W)</REFPAGE> reference page, to support internationalized regular expression behavior.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="64791">ANSI X3.159-198X Standard for C</TITLE><PARAGRAPH>The American National Standards Committee X3J11 standard for the C programming language includes a number of library functions that are defined to operate internationally; that is, they modify their operation in a manner appropriate to the user's native language and cultural environment.<INDEXTARGET ID="TIP_6.intl50"><!-- POSTPROCESSDATA: TIP_6.intl50|internationalization:library functions --></PARAGRAPH>
<PARAGRAPH>The X/Open definition includes the international functions in <INDEXTARGET ID="TIP_6.intl51"><!-- POSTPROCESSDATA: TIP_6.intl51|internationalization:ANSI compatible functions --><XREF IDREF="82734" TYPE="TABLE">Table&nbsp;16-4</XREF> as defined in <DOCTITLE>Draft ANSI X3.159, Programming Language C</DOCTITLE>. ANSI functions that are enhanced by the X/Open definition are marked with an asterisk. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="16-4"><PREFIX>Table 16-4 </PREFIX><XREFTARGET ID="82734">ANSI Compatible Functions</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="166"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>Function (continued)</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH><FUNCTION>atof() </FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH><FUNCTION>scanf() </FUNCTION>* </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH><FUNCTION>fprintf()</FUNCTION> * </PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH><FUNCTION>setlocale()</FUNCTION>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH><FUNCTION>fscanf()</FUNCTION> * </PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH><FUNCTION>sprintf()</FUNCTION> * </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH><FUNCTION>isalnum()</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH><FUNCTION>sscanf() </FUNCTION>* </PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH><FUNCTION>isalpha()</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH><FUNCTION>strcoll()</FUNCTION>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH><FUNCTION>isgraph()</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH><FUNCTION>sterror()</FUNCTION>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH><FUNCTION>islower() </FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH><FUNCTION>strftime()</FUNCTION>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH><FUNCTION>isprint() </FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH><FUNCTION>strtod()</FUNCTION>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH><FUNCTION>ispunct() </FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH><FUNCTION>strxfrm()</FUNCTION></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH><FUNCTION>isspace() </FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH><FUNCTION>tolower()</FUNCTION></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH><FUNCTION>isupper()</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH><FUNCTION>toupper()</FUNCTION></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH><FUNCTION>printf()</FUNCTION> * </PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH><DOCTITLE>Draft ANSI X3.159, Programming Language C</DOCTITLE> also defines a number of multi-byte functions, and an additional function for manipulating monetary values. At this stage, the X/Open definition is only guaranteed to work correctly for single-byte 8-bit characters, and thus does not include the multi-byte functions.</PARAGRAPH>
<PARAGRAPH>In addition, X/Open defines internationalized regular expression compile and match functions, native language message-handling functions, and native language versions of the error-handling functions (see <XREF IDREF="37044" TYPE="TABLE">Table&nbsp;16-5</XREF>). </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="16-5"><PREFIX>Table 16-5 </PREFIX><XREFTARGET ID="37044">X/Open Additional Functions</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="166"><PARAGRAPH>Function</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH>Function (continued)</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH><FUNCTION>catclose()</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH><FUNCTION>regexp()</FUNCTION>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH><FUNCTION>catgets()</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH><FUNCTION>vfprintf()</FUNCTION>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH><FUNCTION>catopen()</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH><FUNCTION>vprintf()</FUNCTION>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH><FUNCTION>nl_langinfo()</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH><FUNCTION>vsprintf()</FUNCTION>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="166"><PARAGRAPH><FUNCTION>perror()</FUNCTION>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="166"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="69295">Native Language Support and the NLS Database</TITLE><PARAGRAPH>The X/Open NLS interface defines the functional capabilities of a generic database that holds various language-dependent entities. This section describes those entities:<INDEXTARGET ID="TIP_6.intl52"><!-- POSTPROCESSDATA: TIP_6.intl52|internationalization:native language support --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="32372" TYPE="TITLE">&ldquo;Configuration Data&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="58633" TYPE="TITLE">&ldquo;Collating Sequence Tables&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="67162" TYPE="TITLE">&ldquo;Character Classification Tables&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="96306" TYPE="TITLE">&ldquo;Shift Tables&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="76748" TYPE="TITLE">&ldquo;Language Information&rdquo;</XREF></PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="32372">Configuration Data</TITLE><PARAGRAPH>Configuration data identify the languages supported on a system in terms of the recognized settings of language, territory, and codeset. Each valid combination of these settings has its own set of collating sequence, character classification and shift tables, language information data, and message catalogs.<INDEXTARGET ID="TIP_6.intl53"><!-- POSTPROCESSDATA: TIP_6.intl53|internationalization:configuration data --></PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="58633">Collating Sequence Tables</TITLE><PARAGRAPH>Collating sequence tables define the collating sequence for each supported language. The binary values of characters in the associated coded character set are used as indices into the table, individual entries of which indicate the relative position of that character in the language collating sequence. The interface definition supports the following capabilities:<INDEXTARGET ID="TIP_6.intl54"><!-- POSTPROCESSDATA: TIP_6.intl54|internationalization:collating sequence tables --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>one-to-one character mappings</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>one-to-two character mappings, where certain characters require treatment as if they were two characters</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><VARIABLE>n</VARIABLE>-to-one character mappings, where certain character sequences require treatment as if they represented a single character in the collating sequence. The maximum value of <VARIABLE>N</VARIABLE> is defined separately for each supported language, where <VARIABLE>N</VARIABLE> is a number in the range [1,{NL_NMAX}].</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>don't care characters, where certain characters are ignored by the collating sequence</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>These capabilities extend to providing support for the relative ordering of collating elements within an equivalent class (for example, where two characters are first compared for equality ignoring accents, and if equal, are then ordered by accent sequence).</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="67162">Character Classification Tables</TITLE><PARAGRAPH>These contain the lookup tables for character classification. Each character code from the defined coded character set is used as an index into the relevant language lookup table. Each entry language lookup table contains a series of flags identifying the truth or falsehood of a particular language assertion, such as<INDEXTARGET ID="TIP_6.intl55"><!-- POSTPROCESSDATA: TIP_6.intl55|internationalization:character classification tables --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>upper-case alphabetic character</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>lower-case alphabetic character</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>punctuation character</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>control character</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>space character</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="96306">Shift Tables</TITLE><PARAGRAPH>Shift tables contain the corresponding upper- and lower-case combinations for each character defined in a coded character set. Thus, the upshifted or downshifted value of a character can be determined by accessing the relevant character entry in the shift table.<INDEXTARGET ID="TIP_6.intl56"><!-- POSTPROCESSDATA: TIP_6.intl56|internationalization:shift tables --></PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="76748">Language Information</TITLE><PARAGRAPH>Language information (or <INDEXTARGET ID="TIP_6.intl57"><!-- POSTPROCESSDATA: TIP_6.intl57|internationalization:language information --><ITALICS>langinfo</ITALICS>) contains message text specific to a particular localization. The library function <FUNCTION>nl_langinfo()</FUNCTION> provides a procedural interface to this data, allowing applications to discover cultural and language-specific information at run-time. Individual items of <ITALICS>langinfo</ITALICS> data are identified by constants in <DOCTITLE>Volume 2, XSI System Interfaces and Headers, &lt;langinfo.h></DOCTITLE>.</PARAGRAPH>
<PARAGRAPH>Information specific to a culture or language includes the following:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Date and time formats</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Days of the week and months of the year</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Abbreviated names of days and months</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Radix character</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Separator for thousands</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Affirmative and negative responses to yes/no questions</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Currency symbol and its position within a currency value</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="49962">Using Regular Expressions</TITLE><PARAGRAPH>Regular expression are used widely throughout the services and are powerful mechanisms for locating and manipulating patterns in text. In order to be compatible with a variety of historic UNIX systems, the IRIX Developer's Option includes the unique regular expression library sets listed in <INDEXTARGET ID="TIP_6.intl58"><!-- POSTPROCESSDATA: TIP_6.intl58|internationalization:regular expressions --><XREF IDREF="96907" TYPE="TABLE">Table&nbsp;16-6</XREF>. Note that only the last, wsregexp, supports internationalization. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="16-6"><PREFIX>Table 16-6 </PREFIX><XREFTARGET ID="96907">Regular Expression Libraries in IRIX</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Library 
Documentation</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>&lbreak;Type of Support Provided</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>regcmp(3G)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Function <FUNCTION>regcmp()</FUNCTION> compiles a pattern string; <FUNCTION>regex()</FUNCTION> applies the pattern to a 
target string. Syntax is said to be that of <COMMAND>ed</COMMAND> but &ldquo;syntax and semantics have been 
changed slightly&rdquo; in unspecified ways.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>regcmp(1)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Command applies <FUNCTION>regcmp()</FUNCTION> against a file of pattern strings, generating C code 
for literal strings that can be included in a source program to preclude having 
to compile patterns at run-time.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>REGEX(3)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Function <FUNCTION>re_comp()</FUNCTION> compiles a pattern string; <FUNCTION>re_exec()</FUNCTION> applies the 
last-compiled pattern against a target string. No means of storing compiled 
patterns. No documentation of supported syntax, but cross-references <REFPAGE>ed(1)</REFPAGE>, 
with which it may or may not be compatible.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>regexp(5)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Function <FUNCTION>compile()</FUNCTION> compiles a pattern string; <FUNCTION>step()</FUNCTION> or <FUNCTION>advance()</FUNCTION> applies a 
stored pattern against a target string. Unusual interface compiles these 
functions directly into your source module, using macro functions you must 
define. Pattern syntax clearly documented.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH><REFPAGE>wsregexp(3W)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Function <FUNCTION>wsrecompile()</FUNCTION> compiles a pattern string; <FUNCTION>wsrestep()</FUNCTION> or <FUNCTION>wsrematch()</FUNCTION> 
applies a pattern against a target. Both pattern and target strings are wide 
characters. Expression syntax is that of regexp augmented with 
internationalization expressions.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="54063">Internationalized Regular Expressions</TITLE><PARAGRAPH>A few utilities distributed with IRIX, in particular <COMMAND>grep</COMMAND> (see the <REFPAGE>grep(1)</REFPAGE> reference page) support internationalized regular expressions, which provide additional syntax for matching character classes, sequences, or ranges. The internationalized regular expressions supported by the <INDEXTARGET ID="TIP_6.intl59"><!-- POSTPROCESSDATA: TIP_6.intl59|internationalization:character expressions --><FUNCTION>wsregexp</FUNCTION> library are as shown in <XREF IDREF="24245" TYPE="TABLE">Table&nbsp;16-7</XREF>. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="16-7"><PREFIX>Table 16-7 </PREFIX><XREFTARGET ID="24245">Character Expressions in Internationalized Regular Expressions</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="50"><PARAGRAPH>Expression</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="334"><PARAGRAPH>Description</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH><ITALICS>c</ITALICS>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="334"><PARAGRAPH>The single character <ITALICS>c</ITALICS> where <ITALICS>c</ITALICS> is not a special character.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>[[:<ITALICS>class</ITALICS>:]]</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="334"><PARAGRAPH>A character class expression. Any character of type <FUNCTION>class</FUNCTION>, as defined by category 
<FUNCTION>LC_CTYPE</FUNCTION> in the program's locale (for example, see<FUNCTION> isalpha()</FUNCTION>). For <ITALICS>class</ITALICS>, substitute 
one of the following:</PARAGRAPH>
<PARAGRAPH><ITALICS>alpha</ITALICS>, a letter</PARAGRAPH>
<PARAGRAPH><ITALICS>upper</ITALICS>, an upper-case letter</PARAGRAPH>
<PARAGRAPH><ITALICS>lower</ITALICS>, a lower-case letter</PARAGRAPH>
<PARAGRAPH><ITALICS>digit</ITALICS>, a decimal digit</PARAGRAPH>
<PARAGRAPH><ITALICS>xdigit</ITALICS>, a hexadecimal digit</PARAGRAPH>
<PARAGRAPH><ITALICS>alnum</ITALICS>, an alphanumeric (letter or digit)</PARAGRAPH>
<PARAGRAPH><ITALICS>space</ITALICS>, a character that produces white space in displayed text</PARAGRAPH>
<PARAGRAPH><ITALICS>punct</ITALICS>, a punctuation character</PARAGRAPH>
<PARAGRAPH><ITALICS>print</ITALICS>, a printing character</PARAGRAPH>
<PARAGRAPH><ITALICS>graph</ITALICS>, a character with a visible representation</PARAGRAPH>
<PARAGRAPH><ITALICS>cntrl</ITALICS>, a control character</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>[[=<ITALICS>c</ITALICS>=]]</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="334"><PARAGRAPH>An equivalence class. Any collation element defined as having the same relative 
order in the current collation sequence as <ITALICS>c</ITALICS>. As an example, if <ITALICS>A</ITALICS> and <ITALICS>a</ITALICS> belong to the 
same equivalence class, then both <ITALICS>[[=A=]b]</ITALICS> and <ITALICS>[[=a=]b]</ITALICS> are equivalent to <ITALICS>[Aab]</ITALICS>.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>[[.<ITALICS>cc</ITALICS>.]]</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="334"><PARAGRAPH>A collating symbol. Multi-character collating elements must be represented as 
collating symbols to distinguish them from single-character collating elements. As 
an example, if the string <ITALICS>ch</ITALICS> is a valid collating element, then <ITALICS>[[.ch.]]</ITALICS> is treated as an 
element matching the same string of characters, while <ITALICS>ch</ITALICS> is treated as a simple list 
of <ITALICS>c</ITALICS> and <ITALICS>h</ITALICS>. If the string is not a valid collating element in the current collating 
sequence definition, the symbol is treated as an invalid expression.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="50"><PARAGRAPH>[<ITALICS>c</ITALICS>-<ITALICS>c</ITALICS>]</PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="334"><PARAGRAPH>Any collation element in the character expression range <ITALICS>c-c</ITALICS>, where <ITALICS>c</ITALICS> can identify a 
collating symbol or an equivalence class. If the hyphen character, -, appears 
immediately after an opening square bracket, or immediately prior to a closing 
square bracket, it has no special meaning.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Within square brackets, a period (.) that is not part of a <ITALICS>[[.c.]]</ITALICS> sequence, a colon (:) that is not part of a <ITALICS>[[:class:]]</ITALICS> sequence, and an equals sign (=) that is not part of a <ITALICS>[[=c=]]</ITALICS> sequence matches itself.</PARAGRAPH>
<PARAGRAPH><INDEXTARGET ID="TIP_6.intl60"><!-- POSTPROCESSDATA: TIP_6.intl60|internationalization:regular expressions, examples --><XREF IDREF="48232" TYPE="TABLE">Table&nbsp;16-8</XREF> shows examples of simple regular expressions. </PARAGRAPH>
<TABLE COLUMNS="2"><CAPTION LBL="16-8"><PREFIX>Table 16-8 </PREFIX><XREFTARGET ID="48232">Examples of Internationalized Regular Expressions</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="94"><PARAGRAPH>Pattern</PARAGRAPH>
</CELL>
<CELL LEFT="100" WIDTH="216"><PARAGRAPH>Definition</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="94"><PARAGRAPH>[[=a=]]bcd</PARAGRAPH>
</CELL>
<CELL LEFT="100" WIDTH="216"><PARAGRAPH>any form of <ITALICS>a</ITALICS> followed by <ITALICS>bcd</ITALICS>&space;</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="94"><PARAGRAPH>[[.ch.]-e]</PARAGRAPH>
</CELL>
<CELL LEFT="100" WIDTH="216"><PARAGRAPH>any element that collates between <ITALICS>ch</ITALICS> and <ITALICS>e</ITALICS></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="94"><PARAGRAPH>[[:lower:]]</PARAGRAPH>
</CELL>
<CELL LEFT="100" WIDTH="216"><PARAGRAPH>any lower case letter</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="97000">Cultural Data</TITLE><PARAGRAPH>The items of cultural data listed in <INDEXTARGET ID="TIP_6.intl61"><!-- POSTPROCESSDATA: TIP_6.intl61|locales:date formatslocales:cultural datalocale-specific behavior:datelocale-specific behavior:timeinternationalization:cultural data --><XREF IDREF="57531" TYPE="TABLE">Table&nbsp;16-9</XREF> are defined in the C locale. </PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="16-9"><PREFIX>Table 16-9 </PREFIX><XREFTARGET ID="57531">Cultural Data Names, Categories, and Settings</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="72"><PARAGRAPH>Item</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>Category</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>Setting for the C Locale</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>D_T_FMT</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"%a %b %c %H:%M:%S %Y"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>D_FMT</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"%m/%d/%y"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>T_FMT</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"%H:%M:%S"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>AM_STR</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"AM"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>PM_STR</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"PM"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>DAY_1</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Sunday"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>DAY_2</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Monday"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>DAY_3</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Tuesday"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>DAY_4</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Wednesday"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>DAY_5</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Thursday"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>DAY_6</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Friday"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>DAY_7</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Saturday"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>ABDAY_1</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Sun"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>ABDAY_2</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Mon"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>ABDAY_3</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Tue"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>ABDAY_4</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Wed"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>ABDAY_5</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Thu"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>ABDAY_6</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Fri"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>ABDAY_7</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Sat"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>MON_1 </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"January"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>MON_2</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"February"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>MON_3</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"March"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>MON_4</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"April"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>MON_5</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"May"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>MON_6</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"June"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>MON_7</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"July"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>MON_8</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"August"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>MON_9</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"September"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>MON_10</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"October"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>MON_11</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"November"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>MON_12</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"December"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>ABMON_1</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Jan"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>ABMON_2</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Feb"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>ABMON_3</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Mar"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>ABMON_4</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Apr"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>ABMON_5</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"May"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>ABMON_6</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Jun"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>ABMON_7</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Jul"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>ABMON_8</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Aug"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>ABMON_9</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Sep"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>ABMON_10</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Oct"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>ABMON_11</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Nov"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>ABMON_12</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_TIME</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"Dec"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>RADIXCHAR</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_NUMERIC</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"."</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>THOUSEP</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_NUMERIC</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>" "</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>YESSTR</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_ALL</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"yes"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>NOSTR</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_ALL</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>"no"</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>CRNCYSTR</PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="90"><PARAGRAPH>LC_MONENTARY</PARAGRAPH>
</CELL>
<CELL LEFT="175" WIDTH="144"><PARAGRAPH>" "</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>NLS Interfaces</TITLE><PARAGRAPH>The NLS interfaces listed here are utilities and library functions.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>NLS Utilities</TITLE><PARAGRAPH>The list below identifies the minimum set of utilities that provide 8-bit transparency on all X/Open compliant systems. The definitions of these commands, in terms of their syntax and parameters, are not changed by the operation of NLS. </PARAGRAPH>
<TABLE COLUMNS="6"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH><COMMAND>ar</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>date</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>kill</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>pg</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="220" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>tail</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="275" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>uulog</COMMAND></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>awk</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>diff</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>lex</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>pr</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="220" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>tar</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="275" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>uuname</COMMAND></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>cancel</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>echo</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>ln</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>ps</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="220" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>tee</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="275" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>uupick</COMMAND></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>cat</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>ed</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>lp</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>pwd</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="220" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>test</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="275" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>uustat</COMMAND></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>cc</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>egrep</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>lpstat</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>red</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="220" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>tr</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="275" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>uuto</COMMAND></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>cd</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>expr</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>ls</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>rm</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="220" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>true</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="275" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>uux</COMMAND></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>chgrp</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>false</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>mail</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>rmdir</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="220" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>tty</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="275" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>wait</COMMAND></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>chmod</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>fgrep</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>mailx</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>sed</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="220" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>umask</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="275" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>wc</COMMAND></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>chown</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>find</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>mkdir</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>sh</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="220" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>uname</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="275" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>who</COMMAND></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>cmp</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>gencat</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>mv</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>sleep</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="220" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>uniq</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="275" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND></COMMAND></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>cp</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>grep</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>pack</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>sort</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="220" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>unpack</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="275" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND></COMMAND></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>cpio</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="55" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>iconv</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="110" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>pcat</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="165" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>stty</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="220" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND>uucp</COMMAND></PARAGRAPH>
</CELL>
<CELL LEFT="275" WIDTH="49"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><COMMAND></COMMAND></PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>The <COMMAND>cc</COMMAND>, <COMMAND>yacc</COMMAND>, and <COMMAND>lex</COMMAND> commands provide 8-bit transparency for characters contained in character strings, character constants, and comment strings. An 8-bit character string enables a programmer to define default messages in languages other than English. The support of 8-bit characters in identifier names is implementation defined.</PARAGRAPH>
<PARAGRAPH>The 8-bit operation of commands that communicate with other systems cannot be guaranteed in all circumstances. For example, intersystem mail may be restricted to 7-bit data by the underlying network, 8-bit data and filenames may not be portable to noninternationalized systems, and so forth. Under these circumstances, it is recommended that you use only characters defined in the ASCII 7-bit range of characters for data transfer between machines, and you use only characters defined in the Portable Filename Character Set for naming remote files.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>NLS Library Functions</TITLE><PARAGRAPH>The list below shows library functions usable by internationalized application programs </PARAGRAPH>
<TABLE COLUMNS="4"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="76"><PARAGRAPH><FUNCTION>atof()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>isgraph()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>scanf()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>toupper()</FUNCTION></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>catclose()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>islower()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>setlocale()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>vfprintf()</FUNCTION></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>catgets()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>isprint()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>sprintf()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>vprintf()</FUNCTION></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>catopen()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>ispunct()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>sscanf()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>vsprintf()</FUNCTION></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>fprint()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>isspace()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>strcoll()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION></FUNCTION></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>fscanf()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>isupper()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>strerror()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION></FUNCTION></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>gcvt()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>nl_langinfo()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>strftime()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION></FUNCTION></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>isalnum()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>perror()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>strtod()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION></FUNCTION></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>isalpha()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>printf()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>strxfrm()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION></FUNCTION></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>iscntrl()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="85" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>regexp()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="170" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION>tolower()</FUNCTION></PARAGRAPH>
</CELL>
<CELL LEFT="255" WIDTH="76"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><FUNCTION></FUNCTION></PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>Also, all functions defined in the <DOCTITLE>X/Open Portability Guide, Volume 2, XSI System Interfaces and Headers</DOCTITLE>, and <DOCTITLE>X/Open Portability Guide, Volume 3, XSI Curses Interface</DOCTITLE>, provide 8-bit transparency on X/Open compliant systems.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE>XSI Curses Interface</TITLE><PARAGRAPH>The XSI curses interface is internationalized. For more information, see the <DOCTITLE>X/Open Portability Guide, Volume 3, XSI Curses Interface</DOCTITLE>.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="42715">Strings and Message Catalogs</TITLE><PARAGRAPH>Message catalogs are compiled databases of strings. While a major role of message catalogs is to provide communications text in locale-specific natural language, the strings can be used for any purpose. The idea is that an application uses only strings from a catalog, thus allowing localizers to supply catalogs suitable for a given locale.<INDEXTARGET ID="TIP_6.intl62"><!-- POSTPROCESSDATA: TIP_6.intl62|internationalization:message catalogsinternationalization:strings --><INDEXTARGET ID="TIP_6.intl63"><!-- POSTPROCESSDATA: TIP_6.intl63|message catalogs --></PARAGRAPH>
<PARAGRAPH>Two different and incompatible interfaces to message catalogs exist in IRIX: <INDEXTARGET ID="TIP_6.intl64"><!-- POSTPROCESSDATA: TIP_6.intl64|message catalogs:incompatibilities --><ITALICS>MNLS</ITALICS> and <ITALICS>XPG/4</ITALICS>. Developers working on SVR4 or other AT&amp;T code, or related base-system utilities, probably use MNLS. Developers working on independent projects probably use XPG/4. Neither is a solid standard, but XPG/4 is closer to being a standard than MNLS. Thus applications developers who have to choose between the two interfaces are encouraged to use XPG/4 to maximize their portability. XPG/4 seems to be popular in Europe.<INDEXTARGET ID="TIP_6.intl65"><!-- POSTPROCESSDATA: TIP_6.intl65|catalogs. <ITALICS>See </ITALICS>message catalogs --></PARAGRAPH>
<PARAGRAPH>This section covers the following topics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="58269" TYPE="TITLE">&ldquo;XPG/4 Message Catalogs&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="70472" TYPE="TITLE">&ldquo;SVR4 MNLS Message Catalogs&rdquo;</XREF></PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="15279" TYPE="TITLE">&ldquo;Variably Ordered Referencing of printf() Arguments&rdquo;</XREF></PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="58269">XPG/4 Message Catalogs</TITLE><PARAGRAPH>The XPG/4 message catalog interface requires that a catalog be opened before it is read, and requires that catalog references specify a catalog descriptor.<INDEXTARGET ID="TIP_6.intl66"><!-- POSTPROCESSDATA: TIP_6.intl66|message catalogs:XPG/3:aboutinternationalization:XPG/3:message catalogs. <ITALICS>See </ITALICS>message catalogs --></PARAGRAPH>
<PARAGRAPH>Since catalog references include a default to be used in case of failure, applications will work normally without a catalog when in the default locale. This means catalog generation is exclusively the task of localizers. But in order to inform the localizer as to what strings to translate and how they should comprise a catalog, the application developer should provide a catalog for the developer's locale.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Opening and Closing XPG/4 Catalogs</TITLE><PARAGRAPH><FUNCTION>catopen()</FUNCTION> locates and opens a message catalog file:</PARAGRAPH>
<CODE>
#include &lt;nl_types.h>
nl_catd catopen(char *name, int unused);
</CODE>
<PARAGRAPH>The argument <INDEXTARGET ID="TIP_6.intl67"><!-- POSTPROCESSDATA: TIP_6.intl67|message catalogs:openingmessage catalogs:closing --><VARIABLE>name</VARIABLE> is used to locate the catalog. Usually, this is a simple, relative pathname that is combined with environment variables to indicate the path to the catalog (see <XREF IDREF="69643" TYPE="TITLE">&ldquo;XPG/4 Catalog Location&rdquo;</XREF> for details). However, the catalog assumes names that begin with &ldquo;/ &rdquo; are absolute pathnames. Use of a hard-coded pathname like this is strongly discouraged; it doesn't allow the user to specify the catalog's locale through environment variables.</PARAGRAPH>
<PARAGRAPH>When an application is finished using a message catalog, it should close the catalog and free the descriptor using <FUNCTION>catclose()</FUNCTION>:</PARAGRAPH>
<EXAMPLE>
int catclose(nl_catd);
</EXAMPLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using an XPG/4 Catalog</TITLE><PARAGRAPH>Catalogs contain sets of numbered messages. The application developer must know the contents of the catalog in order to specify the set and number of a message to be obtained.<INDEXTARGET ID="TIP_6.intl68"><!-- POSTPROCESSDATA: TIP_6.intl68|message catalogs:XPG/3:using --></PARAGRAPH>
<PARAGRAPH><FUNCTION>catgets()</FUNCTION> is used to retrieve strings from a message catalog (see the <REFPAGE>catopen(3)</REFPAGE> and <REFPAGE>catgets(3)</REFPAGE> reference pages). <XREF IDREF="76198" TYPE="TEXT">Example&nbsp;16-3</XREF> shows a program that reads the first message from the first message set in the appropriate catalog, and displays the result. <INDEXTARGET ID="TIP_6.intl69"><!-- POSTPROCESSDATA: TIP_6.intl69|message catalogs:reading --></PARAGRAPH>
<CODE><CAPTION LBL="16-3"><PREFIX>Example 16-3 </PREFIX><XREFTARGET ID="76198">Reading an XPG/4 Catalog</CAPTION>#include &lt;stdio.h>
#include &lt;locale.h>
#include &lt;nl_types.h>
&nbsp;
#define SET1      1
#define WRLD_MSG  1
&nbsp;
int main(){
&space;   nl_catd msgd;
&space;   char *message;
&space;   setlocale(LC_ALL, ""); 
&nbsp;
msgd = catopen("hw",0);
&space;   message = catgets(msgd, SET1, WRLD_MSG,"Hello, world\n");
&space;   printf(message);
&space;   catclose(msgd);
}
</CODE>
<PARAGRAPH>The previous example uses <FUNCTION>printf()</FUNCTION> instead of <FUNCTION>puts()</FUNCTION> in order to make a point: the format string of <FUNCTION>printf()</FUNCTION> came from a catalog. Note the crucial difference between these two statements:</PARAGRAPH>
<CODE>
printf(catgets(msgd, set, num, defaultStr));
printf("%s", catgets(msgd, set, num, defaultStr));
</CODE>
<PARAGRAPH>In the first statement, the catalog provides the <FUNCTION>printf()</FUNCTION> formatting string, possibly containing conversion specifications and escape sequences. In the second statement, the string from the catalog is treated as data and not interpreted for conversion specifications. For further discussion of issues relating to this important distinction, see <XREF IDREF="15279" TYPE="TITLE">&ldquo;Variably Ordered Referencing of printf() Arguments.&rdquo;</XREF></PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="69643">XPG/4 Catalog Location</TITLE><PARAGRAPH>XPG/4 message catalogs are located using the environment variable NLSPATH. The default NLSPATH is <INDEXTARGET ID="TIP_6.intl70"><!-- POSTPROCESSDATA: TIP_6.intl70|message catalogs:locatingNLSPATHmessage catalogs:NLSPATH --><FILENAME>/usr/lib/locale/%L/LC_MESSAGES/%N</FILENAME>, where <VARIABLE>%L</VARIABLE> is filled in by the LANG environment variable and <VARIABLE>%N</VARIABLE> is filled in by the <VARIABLE>name</VARIABLE> argument to <FUNCTION>catopen()</FUNCTION>. NLSPATH can specify multiple pathnames in ordered precedence, much like the PATH variable. The following is a sample NLSPATH assignment:</PARAGRAPH>
<CODE>
NLSPATH=/usr/lib/locale/%L/LC_MESSAGES/%N:/usr/local/lib/locale/%L/LC_MESSAGES/&lbreak;%N:/usr/defaults/%N 
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Creating XPG/4 Message Catalogs</TITLE><PARAGRAPH>Message catalogs are of this general form (these forms are detailed in the <INDEXTARGET ID="TIP_6.intl71"><!-- POSTPROCESSDATA: TIP_6.intl71|message catalogs:XPG/3:creating --><REFPAGE>gencat(1)</REFPAGE> reference page):</PARAGRAPH>
<CODE>
$set <ITALICS>n</ITALICS>&space;<ITALICS>comment</ITALICS>&space;
<ITALICS>a</ITALICS>&space;<ITALICS>message-a</ITALICS>\n
<ITALICS>b</ITALICS>&space;<ITALICS>message-b</ITALICS>\n
<ITALICS>c</ITALICS>&space;<ITALICS>message-c</ITALICS>\n
$quote "
<ITALICS>d</ITALICS> " <ITALICS>message-d</ITALICS> "
$this is a comment
</CODE>
<PARAGRAPH>Each message is identified by a <ITALICS>message number</ITALICS> and a <ITALICS>set</ITALICS>. Sets are often used to separate messages into more easily usable groups, such as error messages, help messages, directives, and so on. Alternatively, you could use a different set for each source file, containing all of that source file's messages.</PARAGRAPH>
<PARAGRAPH><FUNCTION>$set</FUNCTION>&space;<VARIABLE>n</VARIABLE> specifies the beginning of set <VARIABLE>n</VARIABLE>, where <VARIABLE>n</VARIABLE> is a set identifier in the range from 1 to NL_SETMAX. All messages following the <FUNCTION>$set</FUNCTION> statement belong to set <VARIABLE>n</VARIABLE> until either a <FUNCTION>$delset</FUNCTION> or another <FUNCTION>$set</FUNCTION> is reached. You can skip set numbers (for example, you can have a set 3 without having a set 2), but the set numbers that you use must be listed in ascending numerical order (and every set must have a number). Any string following the set identifier on the same line is considered a comment.</PARAGRAPH>
<PARAGRAPH><FUNCTION>$delset</FUNCTION>&space;<VARIABLE>n</VARIABLE> deletes the set <VARIABLE>n</VARIABLE> from a message catalog.</PARAGRAPH>
<PARAGRAPH><FUNCTION>$quote</FUNCTION>&space;<VARIABLE>c</VARIABLE> specifies a quote character, <VARIABLE>c</VARIABLE>, which can be used to surround message text so that trailing spaces or null (empty) messages are visible in a message source line. By default, there is no quote character and messages are separated by newlines. To continue a message onto a second line, add a backslash to the end of the first line:</PARAGRAPH>
<CODE>
$set 1
1 Hello, world.
2 here is a long \
string.\n
3 Hello again.
<ITALICS>n</ITALICS>&space;<ITALICS>message-text-n</ITALICS>
</CODE>
<PARAGRAPH>Message #2 in set #1 is &ldquo;here is a long string.\n&rdquo;.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Compiling XPG/4 Message Catalogs</TITLE><PARAGRAPH>After creating the message catalog sources, you need to compile them into binary form using <INDEXTARGET ID="TIP_6.intl72"><!-- POSTPROCESSDATA: TIP_6.intl72|message catalogs:XPG/3:compiling --><COMMAND>gencat</COMMAND>, which has the following syntax:</PARAGRAPH>
<CODE>
gencat <ITALICS>catfile</ITALICS>&space;<ITALICS>msgfile</ITALICS> [<ITALICS>msgfile</ITALICS> ...]
</CODE>
<PARAGRAPH>where <VARIABLE>catfile</VARIABLE> is the target message catalog and <VARIABLE>msgfile</VARIABLE> is the message source file (see the <REFPAGE>gencat(1)</REFPAGE> reference page). If an old <VARIABLE>catfile</VARIABLE> exists, <COMMAND>gencat</COMMAND> attempts to merge new entries with the old. <COMMAND>gencat</COMMAND> &ldquo;resolves&rdquo; set and message number conflicts with new information replacing the old.</PARAGRAPH>
<PARAGRAPH>The <VARIABLE>catfile</VARIABLE> then needs to be placed in a location where <FUNCTION>catopen()</FUNCTION> can find it; see the <XREF IDREF="69643" TYPE="TITLE">&ldquo;XPG/4 Catalog Location&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="70472">SVR4 MNLS Message Catalogs</TITLE><PARAGRAPH>There are many ways to use strings from MNLS message catalogs. You can get strings directly and then use them, or you can use output routines that search catalogs.<INDEXTARGET ID="TIP_6.intl73"><!-- POSTPROCESSDATA: TIP_6.intl73|message catalogs:MNLS:usinginternationalization:MNLS:message catalogs. <ITALICS>See </ITALICS>message catalogs, MNLS --><INDEXTARGET ID="TIP_6.intl74"><!-- POSTPROCESSDATA: TIP_6.intl74|MNLS:message catalogs --></PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Putting MNLS Strings Into a Catalog</TITLE><PARAGRAPH>An MNLS catalog source file contains a list of strings separated by new lines. For an empty string, an empty line is used. Strings are referenced by line number in the original source file.<INDEXTARGET ID="TIP_6.intl75"><!-- POSTPROCESSDATA: TIP_6.intl75|message catalogs:MNLS:strings --></PARAGRAPH>
<PARAGRAPH>Applications access the catalog by line number, so it's very important not to change the line numbers of existing catalog entries. This means that, when you want to add a new string to an existing catalog source, you should always append it to the end of the file&mdash;if you put it in the middle of the file, then you change the line number for subsequent strings. </PARAGRAPH>
<PARAGRAPH>The following tools can help you compile MNLS message catalogs: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>exstr(1) </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Searches a C source file for literal strings and lists them, or replaces 
them with MNLS function calls.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>mkmsgs(1) </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Creates a message catalog for a particular locale, converting source text 
lines to the form used by exstr.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="72"><PARAGRAPH>srchtxt(1) </PARAGRAPH>
</CELL>
<CELL LEFT="80" WIDTH="315"><PARAGRAPH>Displays selected strings from a message catalog.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>When a file of strings is ready to be compiled, simply run <COMMAND>mkmsgs</COMMAND> and put the results in the directory <FILENAME>/usr/lib/locale/</FILENAME><VARIABLE>localename</VARIABLE><FILENAME>/LC_MESSAGES</FILENAME>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using MNLS in Shell Scripts</TITLE><PARAGRAPH>One difference between MNLS and XPG/4 catalog functions is that the MNLS catalog can be used from commands, and hence it can be used to internationalize a shell script. The following table summarizes MNLS functions that have both a command line and a function library version: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="85"><PARAGRAPH><REFPAGE>gettxt(1)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="301"><PARAGRAPH>Retrieve a string from the catalog.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="85"><PARAGRAPH><REFPAGE>lfmt(1)</REFPAGE>&space;</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="301"><PARAGRAPH>Retrieve a format string, insert arguments, display to <FILENAME>stderr</FILENAME> and to 
system log or textport.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="85"><PARAGRAPH><REFPAGE>pfmt(1</REFPAGE>) </PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="301"><PARAGRAPH>Retrieve a format string, insert arguments, display to <FILENAME>stderr</FILENAME>.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="71066">Specifying MNLS Catalogs</TITLE><PARAGRAPH>MNLS message catalogs do not need to be specifically opened. The catalog of choice can be set explicitly once, or it can be specified every time a string is needed.<INDEXTARGET ID="TIP_6.intl76"><!-- POSTPROCESSDATA: TIP_6.intl76|message catalogs:specifying, MNLS --></PARAGRAPH>
<PARAGRAPH>To specify the default message catalog to be used by subsequent calls to MNLS functions that reference catalogs, use <INDEXTARGET ID="TIP_6.intl77"><!-- POSTPROCESSDATA: TIP_6.intl77|MNLS:<ITALICS>Also see</ITALICS> message catalogs --><FUNCTION>setcat()</FUNCTION>:</PARAGRAPH>
<CODE>
#include &lt;pfmt.h>
char *setcat(const char *catalog);
</CODE>
<PARAGRAPH><VARIABLE>catalog</VARIABLE> is limited to 14 characters, and may contain no character equal to zero or to the ASCII codes for slash (<ITALICS>/</ITALICS>) or colon (<ITALICS>:</ITALICS>). (See the <REFPAGE>setcat(3)</REFPAGE> reference page.)</PARAGRAPH>
<PARAGRAPH><FUNCTION>setcat()</FUNCTION> doesn't check to see if the catalog name is valid; it just stores the string for future reference. For an example of use, see the following topic. The catalog indicated by the string must be found in the directory <FILENAME>/usr/lib/locale/</FILENAME><VARIABLE>localename</VARIABLE><FILENAME>/LC_MESSAGES</FILENAME>. </PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="46749">Getting Strings From MNLS Message Catalogs</TITLE><PARAGRAPH>MNLS message catalogs do not need to be specifically opened. The catalog of choice can be set explicitly once, or it can be specified in each reference call. Strings are read from a catalog via <FUNCTION>gettxt()</FUNCTION> (see the <REFPAGE>gettxt(3)</REFPAGE> reference page):</PARAGRAPH>
<CODE>
#include &lt;unistd.h>
char *gettxt(const char *msgid, const char *defaultStr);
</CODE>
<PARAGRAPH><VARIABLE>msgid</VARIABLE> is a string containing two fields separated by a colon:</PARAGRAPH>
<EXAMPLE>
msgfilename:msgnumber
</EXAMPLE>
<PARAGRAPH>The <VARIABLE>msgfilename</VARIABLE> is a catalog name as described previously in the <XREF IDREF="71066" TYPE="TITLE">&ldquo;Specifying MNLS Catalogs&rdquo;</XREF>. For example, to get message 10 from the <FILENAME>MQ</FILENAME> catalog, you could use either:</PARAGRAPH>
<EXAMPLE>
char *str = gettxt("MQ:10", "Hello, world.\n");
</EXAMPLE>
<PARAGRAPH>or</PARAGRAPH>
<CODE>
setcat("MQ");
str = gettxt(":10", "Hello, world.\n");
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using pfmt()</TITLE><PARAGRAPH><INDEXTARGET ID="TIP_6.intl78"><!-- POSTPROCESSDATA: TIP_6.intl78|internationalization:<ITALICS>pfmt()</ITALICS>internationalization:MNLS:<ITALICS>pfmt()</ITALICS>message catalogs:MNLS:<ITALICS>pfmt()</ITALICS> --><FUNCTION>pfmt()</FUNCTION> is one of the most important routines dealing with MNLS catalogs, because it is used to produce most system diagnostic messages. <FUNCTION>pfmt()</FUNCTION> formats like <FUNCTION>printf()</FUNCTION> and produces standard error message formats (see the <REFPAGE>pfmt(3)</REFPAGE> reference page for the function, or <REFPAGE>pfmt(1)</REFPAGE> for shell use). It can usually be used in place of <FUNCTION>perror()</FUNCTION>. For example,</PARAGRAPH>
<EXAMPLE>
pfmt(stderr, MM_ERROR, "MQ:64:Permission denied");
</EXAMPLE>
<PARAGRAPH>would produce, by default (such as when the Mozambique locale is unavailable),</PARAGRAPH>
<EXAMPLE>
ERROR: Permission denied.
</EXAMPLE>
<PARAGRAPH>The syntax of <FUNCTION>pfmt()</FUNCTION> is</PARAGRAPH>
<CODE>
#include &lt;pfmt.h>
int pfmt(FILE *stream, long flags, char *format, ... );
</CODE>
<PARAGRAPH>The <VARIABLE>flags</VARIABLE> are used to indicate severity, type, or control details to <FUNCTION>pfmt()</FUNCTION>. The format string includes information specifying which message from which catalog to look for. Flag details are discussed in the following section. The format is discussed in the <XREF IDREF="4Head" TYPE="TITLE">&ldquo;Format Strings for pfmt()&rdquo;</XREF>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="80731">Labels, Severity, and Flags</TITLE><PARAGRAPH><INDEXTARGET ID="TIP_6.intl79"><!-- POSTPROCESSDATA: TIP_6.intl79|message catalogs:MNLS:<ITALICS>pfmt()</ITALICS> flags --><FUNCTION>pfmt()</FUNCTION> flags are composed of several groups; specify no more than one from each group. Specify multiple flags by using OR. The groups are as follows: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH>output format control</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>MM_NOSTD, MM_STD</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH>catalog access control</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>MM_NOGET, MM_GET</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH>severity</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>MM_HALT, MM_ERROR, MM_WARNING, MM_INFO</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="135"><PARAGRAPH>action message specification</PARAGRAPH>
</CELL>
<CELL LEFT="140" WIDTH="252"><PARAGRAPH>MM_ACTION</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH><FUNCTION>pfmt()</FUNCTION> prints messages in the form <ITALICS>label:severity:text</ITALICS>. <ITALICS>Severity</ITALICS> is specified in the <VARIABLE>flags</VARIABLE>. The <ITALICS>text</ITALICS> comes from a message catalog (or a default) as specified in the <VARIABLE>format</VARIABLE>, and the <ITALICS>label</ITALICS> is specified earlier by the application.</PARAGRAPH>
<PARAGRAPH>In the example above, if no label has been set, we get only the output:</PARAGRAPH>
<EXAMPLE>
ERROR: Permission denied.
</EXAMPLE>
<PARAGRAPH>Typically, an application sets the label once early in its life; subsequent error messages have the label prepended. For example</PARAGRAPH>
<CODE>
setlabel("UX:myprog");
...
pfmt(stderr, MM_ERROR, "MQ:64:Permission denied");
</CODE>
<PARAGRAPH>would produce (by default)</PARAGRAPH>
<EXAMPLE>
UX:myprog: ERROR: Permission denied.
</EXAMPLE>
<PARAGRAPH>For details, consult the <REFPAGE>pfmt(3)</REFPAGE> and <REFPAGE>setlabel(3)</REFPAGE> reference pages.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="4Head">Format Strings for pfmt()</TITLE><PARAGRAPH><INDEXTARGET ID="TIP_6.intl80"><!-- POSTPROCESSDATA: TIP_6.intl80|message catalogs:MNLS:<ITALICS>pfmt()</ITALICS> format strings --><FUNCTION>pfmt()</FUNCTION> format strings are of this form:</PARAGRAPH>
<EXAMPLE>
[[<VARIABLE>catalog</VARIABLE>:]<VARIABLE>messagenum</VARIABLE>:]<VARIABLE>defaultstring</VARIABLE>&space;
</EXAMPLE>
<PARAGRAPH>The <VARIABLE>catalog</VARIABLE> field is in the format described in <XREF IDREF="71066" TYPE="TITLE">&ldquo;Specifying MNLS Catalogs&rdquo;</XREF>. <VARIABLE>messagenum</VARIABLE> is the message number in the catalog to use as the format. <VARIABLE>defaultstring</VARIABLE> specifies the string to use if the catalog lookup fails for any reason.</PARAGRAPH>
<PARAGRAPH>An important feature of <FUNCTION>pfmt()</FUNCTION> is its ability to refer to format arguments in format-specified order just as <FUNCTION>printf()</FUNCTION> does. See <XREF IDREF="15279" TYPE="TITLE">&ldquo;Variably Ordered Referencing of printf() Arguments&rdquo;</XREF> for details.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using fmtmsg()</TITLE><PARAGRAPH><INDEXTARGET ID="TIP_6.intl81"><!-- POSTPROCESSDATA: TIP_6.intl81|internationalization:<ITALICS>fmtmsg()</ITALICS>message catalogs:MNLS:<ITALICS>fmtmsg()</ITALICS>internationalization:MNLS:<ITALICS>fmtmsg()</ITALICS> --><FUNCTION>fmtmsg()</FUNCTION> is a comprehensive formatter using the MNLS catalogs and &ldquo;standard&rdquo; formats. You probably won't need to use it; most applications should get by with <FUNCTION>pfmt()</FUNCTION>, <FUNCTION>gettxt()</FUNCTION>, and <FUNCTION>printf()</FUNCTION>. Consult the <REFPAGE>fmtmsg(3)</REFPAGE> reference page for details.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="31603">Internationalizing File Typing Rule Strings With MNLS</TITLE><PARAGRAPH>You can internationalize the strings defined in the LEGEND and MENUCMD rules in the File Typing Rule (FTR) file. To internationalize these rules, precede the string with the following:<INDEXTARGET ID="TIP_6.intl82"><!-- POSTPROCESSDATA: TIP_6.intl82|internationalization:file typing rulesfile typing rulesmessage catalogs:file typing rules --></PARAGRAPH>
<EXAMPLE>
:[<VARIABLE>catalogname</VARIABLE>:]<VARIABLE>msgnumber</VARIABLE>: 
</EXAMPLE>
<PARAGRAPH><VARIABLE>catalogname</VARIABLE> is optional and should be a valid MNLS catalog; <VARIABLE>msgnumber</VARIABLE> is the line number in <FILENAME>catalogname</FILENAME>. If you omit <VARIABLE>catalogname</VARIABLE>, the <FILENAME>uxsgidesktop</FILENAME> catalog is used by default.</PARAGRAPH>
<PARAGRAPH>You can use these rules to create your own FTR catalog. For example, an entry looks like this:<INDEXTARGET ID="TIP_6.intl83"><!-- POSTPROCESSDATA: TIP_6.intl83|LEGENDMENUCMDfile typing rules:LEGENDfile typing rules:MENUCMD --></PARAGRAPH>
<EXAMPLE>
LEGEND :mycatalog:7:Archive 8mm Tape Drive 
</EXAMPLE>
<PARAGRAPH>This entry uses line 7 from the catalog, <FILENAME>mycatalog</FILENAME>, as the LEGEND for this FTR. If <FILENAME>mycatalog</FILENAME> is not available, or line 7 is not accessible from <FILENAME>mycatalog</FILENAME>, &ldquo;Archive 8mm Tape Drive&rdquo; is used as the LEGEND.</PARAGRAPH>
<EXAMPLE>
LEGEND :7:Archive 8mm Tape Drive 
</EXAMPLE>
<PARAGRAPH>This entry uses line 7 from the <FILENAME>uxsgidesktop</FILENAME> catalog, if available. Otherwise, &ldquo;Archive 8mm Tape Drive&rdquo; is used. </PARAGRAPH>
<PARAGRAPH>The next example,</PARAGRAPH>
<EXAMPLE>
MENUCMD \`mycatalog:9:Eject Tape\' /usr/sbin/eject /dev/tape
</EXAMPLE>
<PARAGRAPH>displays line 9 from <FILENAME>mycatalog</FILENAME>, if available. Otherwise &ldquo;Eject Tape&rdquo; is displayed on the menu that pops up when you click an icon that uses this FTR.</PARAGRAPH>
<PARAGRAPH>You can internationalize strings in the command part of MENUCMD and CMD rules by using <COMMAND>gettxt</COMMAND> or any other convenient policy detailed in this section. For example</PARAGRAPH>
<EXAMPLE>
CMD OPEN xconfirm -t "Tape tool not available"
</EXAMPLE>
<PARAGRAPH>can be internationalized to</PARAGRAPH>
<EXAMPLE>
CMD OPEN xconfirm -t "`gettxt mycatalog:376 'Tape tool not available'`"
</EXAMPLE>
<PARAGRAPH>In this example, <COMMAND>gettxt</COMMAND> is invoked to access line 376 from the catalog, <FILENAME>mycatalog</FILENAME>, and the string returned by <COMMAND>gettxt</COMMAND> is passed to <COMMAND>xconfirm</COMMAND> for display. If line 376 from <FILENAME>mycatalog</FILENAME> is not accessible, then <COMMAND>gettxt</COMMAND> returns the string &ldquo;Tape tool not available.&rdquo;</PARAGRAPH>
<PARAGRAPH>For more information about FTRs, see the <ITALICS>IRIX Interactive Desktop Integration Guide</ITALICS>. </PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="15279">Variably Ordered Referencing of printf() Arguments</TITLE><PARAGRAPH><INDEXTARGET ID="TIP_6.intl84"><!-- POSTPROCESSDATA: TIP_6.intl84|internationalization:<ITALICS>printf()</ITALICS><ITALICS>printf()</ITALICS> message catalogs<ITALICS>printf()</ITALICS> --><FUNCTION>printf()</FUNCTION> and its variants can now refer to arguments in any specified order. Consider the following scenario: an application has chosen &ldquo;house&rdquo; from a list of objects and &ldquo;white&rdquo; from a list of colors. The application wishes to display this choice. The code might look like this:</PARAGRAPH>
<CODE>
char *obj, *color;
... /* make choices */ ...
printf("%s %s\n", color, obj);
</CODE>
<PARAGRAPH>The <FUNCTION>printf()</FUNCTION> call produces this:</PARAGRAPH>
<CODE>
white house
</CODE>
<PARAGRAPH>Even once we make sure that <VARIABLE>obj</VARIABLE> and <VARIABLE>color</VARIABLE> are localized strings, we are not quite finished. If our locale is Spanish, the <FUNCTION>printf()</FUNCTION> yields:</PARAGRAPH>
<EXAMPLE>
blanca casa
</EXAMPLE>
<PARAGRAPH>That is incorrect grammar; in Spanish, it should be:</PARAGRAPH>
<EXAMPLE>
casa blanca
</EXAMPLE>
<PARAGRAPH>The solution to this problem is <ITALICS>variably ordered referencing</ITALICS> of <FUNCTION>printf()</FUNCTION> arguments. The syntax of <FUNCTION>printf()</FUNCTION> format strings has been expanded to deal with this.</PARAGRAPH>
<PARAGRAPH>The original definition of <FUNCTION>printf()</FUNCTION> is that each conversion specification %<VARIABLE>T</VARIABLE> (where <VARIABLE>T</VARIABLE>&nbsp;represents any of the <FUNCTION>printf()</FUNCTION> conversion characters) is implicitly matched to an argument value by position. In order to deal with variably ordered strings, <FUNCTION>printf()</FUNCTION> allows an argument position index <VARIABLE>D</VARIABLE> to appear in the conversion specification following the %, so that where a format string contains %<VARIABLE>T</VARIABLE>, it can now contain %<VARIABLE>D</VARIABLE>$<VARIABLE>T</VARIABLE>. The value <VARIABLE>D</VARIABLE>, set off by a currency symbol ($), selects the argument from the argument list to be used. This means you can write</PARAGRAPH>
<EXAMPLE>
printf("2nd parameter is %2$s; the 1st is %1$s", p1, p2)
</EXAMPLE>
<PARAGRAPH>The <ITALICS>second</ITALICS> parameter is printed <ITALICS>first</ITALICS>, with the first parameter printed second. For example:</PARAGRAPH>
<CODE>
char *store = "Macy's";
char *obj = "a cup";
printf("At %1$s, I bought %2$s.\n", store, obj);
printf("I bought %2$s at %1$s.\n", store, obj);
</CODE>
<PARAGRAPH>This code displays</PARAGRAPH>
<CODE>
At Macy's, I bought a cup.
I bought a cup at Macy's.
</CODE>
<PARAGRAPH>In English, we are able to come up with strings suitable for either word order; in some other language, we might not be so lucky. Nor can we predict which order such languages might prefer. So the developer has no way of knowing how to create traditional <FUNCTION>printf()</FUNCTION> format strings suitable for all languages.</PARAGRAPH>
<PARAGRAPH>Developers should therefore use message catalogs for their <FUNCTION>printf()</FUNCTION> format strings that take linguistic parameters, and allow localizers to localize the format strings as well as text strings. This means that the localizer has much greater ability to create intelligible text. An internationalized version of the above code appears in <XREF IDREF="45456" TYPE="TEXT">Example&nbsp;16-4</XREF>.</PARAGRAPH>
<CODE><CAPTION LBL="16-4"><PREFIX>Example 16-4 </PREFIX><XREFTARGET ID="45456">Internationalized Code</CAPTION>/* internationalized (XPG/4) version */
char *form = catgets(msgd, set, formNum,
&space;                  "At %1$s, I bought %2$s.\n");
char *store = catgets(msgd, set, storeNum, "Macy's");
char *obj = catgets(msgd, set, objNum, "a cup");
printf(form, store, obj);
</CODE>
<PARAGRAPH>The unlocalized (default) version would produce</PARAGRAPH>
<EXAMPLE>
At Macy's, I bought a cup.
</EXAMPLE>
<PARAGRAPH>A localized version might produce</PARAGRAPH>
<EXAMPLE>
Compr&eacute; una tasa en Macy's.
</EXAMPLE>
<PARAGRAPH>In practice, variably ordered format strings are found only in message catalogs and not in default strings. The default string usually simply uses the parameters in the order they're given, without the new variable-order format strings. </PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="11835">Internationalization Support in X11R6</TITLE><PARAGRAPH>X11R6 internationalization support is provided on the X client side; that is, the application must take care of such support instead of relying on the X server. No server changes are necessary, and the protocol is unchanged. Full backward compatibility is preserved, so a new internationalized application can run on an old server. <INDEXTARGET ID="TIP_6.intl85"><!-- POSTPROCESSDATA: TIP_6.intl85|internationalization:X Window System:changesX Window System:internationalization changesinternationalization: X Window System:about --></PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>X11R6 internationalization refers to features in X11R5 and X11R6.</NOTE>
<PARAGRAPH>X uses existing internationalization standards to do its internationalization support; there are no X-specific interfaces to set and change locale. Internationalized X&nbsp;applications receive no help from X when attempting multilingual support. No locales or special process states are peculiar to X.</PARAGRAPH>
<PARAGRAPH>This section covers the following topics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="53382" TYPE="TITLE">&ldquo;Limitations of X11R6 in Supporting Internationalization&rdquo;</XREF> discusses vertical text, character sets, and Xlib interface changes.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="10254" TYPE="TITLE">&ldquo;Resource Names&rdquo;</XREF> covers encoding of resource names.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="76711" TYPE="TITLE">&ldquo;Getting X Internationalization Started&rdquo;</XREF> describes initialization of Xlib and toolkit programming.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="70975" TYPE="TITLE">&ldquo;Fontsets&rdquo;</XREF> explains specifying, creating, and using fontsets.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="20370" TYPE="TITLE">&ldquo;Text Rendering Routines&rdquo;</XREF> discusses the <COMMAND>XmbDrawText()</COMMAND>, <COMMAND>XmbDrawString()</COMMAND>, and <COMMAND>XmbDrawImageString()</COMMAND> functions.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="50793" TYPE="TITLE">&ldquo;New Text Extents Functions&rdquo;</XREF> describes a few new extents-related functions, including <COMMAND>XFontSetExtents</COMMAND>.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="53382">Limitations of X11R6 in Supporting Internationalization<INDEXTARGET ID="TIP_6.intl86"><!-- POSTPROCESSDATA: TIP_6.intl86|internationalization:X Window System:limitationsX Window System:limitations --></TITLE><PARAGRAPH>Since X is locale-independent, there are some limitations on its ability to support internationalization. The X protocol and Xlib specification, together with ANSI&nbsp;C and POSIX restrictions, have led to certain choices being made in X11R6. These are described in the following paragraphs.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Vertical Text</TITLE><PARAGRAPH>There is no built-in support for vertical text. Applications may draw strings vertically only by laying out the text manually.<INDEXTARGET ID="TIP_6.intl87"><!-- POSTPROCESSDATA: TIP_6.intl87|internationalization:X Window System:vertical text --></PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Character Sets</TITLE><PARAGRAPH>In previous releases of X, there was no general support for character sets other than Latin&nbsp;1. X11R6, however, does allow other character sets.<INDEXTARGET ID="TIP_6.intl88"><!-- POSTPROCESSDATA: TIP_6.intl88|internationalization:X Window System:character setsinternationalization:character sets:and X --></PARAGRAPH>
<PARAGRAPH>X11R6 includes the definition of the <ITALICS>X Portable Character Set</ITALICS>, which is required to exist in all locales supported by Xlib. There is no encoding defined for this set; it is only a character set. The set&mdash;which is similar to printable ASCII plus the newline and tab&mdash;consists of these characters:</PARAGRAPH>
<CODE>
abcdefghijklmnoqrstuvwxyz
ABCDEFGHIJKLMNOPQRSTUVWXYZ
0123456789
!"#$%&amp;'()*+,-./:;&lt;=>?@[\]^_`{|}~
&lt;space> &lt;tab> &lt;newline>
</CODE>
<PARAGRAPH>The <ITALICS>Host Portable Character Encoding</ITALICS> is the encoding of the X Portable Character Set on the Xlib host. This encoding is part of X, and is thus independent of locale&mdash;the coding remains the same for all locales supported by the host.</PARAGRAPH>
<PARAGRAPH>Strings used or returned by Xlib routines are either in the Host Portable Character Encoding or a locale-specific encoding. The Xlib reference pages specify which encodings are used where. Some string constructs (such as <VARIABLE>TextProperty</VARIABLE>) contain information regarding their own encoding.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Xlib Interface Change</TITLE><PARAGRAPH>Full use of X11R6's internationalization features means calling some new routines supplied in the X11R6 Xlib. While all old Xlib applications work with the new Xlib, developers should change their code in places. These are described below.<INDEXTARGET ID="TIP_6.intl89"><!-- POSTPROCESSDATA: TIP_6.intl89|internationalization:X Window System:<ITALICS>Xlib </ITALICS>changes<ITALICS>Xlib </ITALICS>changes --></PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="10254">Resource Names</TITLE><PARAGRAPH>Resource names are compiled into programs. Because of that, their encoding must be known independent of locale. Trying to add a level of indirection here results in a problem: you're always left with something compiled that can't be localized. Resource names therefore use the X Portable Character Set. The names may be anything; at least they'll mean something to the application author. (If the names were numbers, for example, they would be meaningless to everybody.)<INDEXTARGET ID="TIP_6.intl90"><!-- POSTPROCESSDATA: TIP_6.intl90|internationalization:X Window System:resource names --></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="76711">Getting X Internationalization Started</TITLE><PARAGRAPH>Xlib's internationalization state, like that of <FILENAME>libc</FILENAME>, needs to be initialized.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Initialization for Toolkit Programming</TITLE><PARAGRAPH>If you're using Xt (with a widget set such as IRIS IM, Motif, or XaW), then don't use <FUNCTION>setlocale()</FUNCTION>. Instead, use</PARAGRAPH>
<EXAMPLE>
XtSetLanguageProc(NULL, NULL, NULL)
</EXAMPLE>
<PARAGRAPH>If you're using a toolkit other than Xt, call <FUNCTION>setlocale()</FUNCTION> as early as possible after execution begins. </PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="47944">Initialization for Xlib Programming</TITLE><PARAGRAPH>Initialize Xlib's internationalization state after calling <INDEXTARGET ID="TIP_6.intl91"><!-- POSTPROCESSDATA: TIP_6.intl91|internationalization:initializing <ITALICS>Xlib</ITALICS> --><FUNCTION>setlocale()</FUNCTION>. Xlib is being initialized, not a server or server-specific object, so a server connection is not necessary.</PARAGRAPH>
<CODE><CAPTION LBL="16-5"><PREFIX>Example 16-5 </PREFIX>Initializing Xlib for a Locale</CAPTION>if ( setlocale(LC_ALL, "") == NULL )
&space;   exit_with_error();
if ( ! XSupportsLocale() )
&space;   exit_with_other_error();
if ( XSetLocaleModifiers("") == NULL)
&space;   give_warning();
</CODE>
<PARAGRAPH><FUNCTION>XSetLocaleModifiers()</FUNCTION> is required only for input. Just as passing an empty string to <FUNCTION>setlocale()</FUNCTION> honors the user's environment, so does passing an empty string to <FUNCTION>XSetLocaleModifiers()</FUNCTION>.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="70975">Fontsets</TITLE><PARAGRAPH>In X11R5 and X11R6, unlike previous releases of X, a string may contain characters from more than one codeset. There are several methods for determining which codeset a given character is in; which method is appropriate depends on the locale and the encoding used.<INDEXTARGET ID="TIP_6.intl92"><!-- POSTPROCESSDATA: TIP_6.intl92|internationalization:X Window System:fontsetsfontsets --></PARAGRAPH>
<PARAGRAPH>For information on installing and using fontsets with an application, refer to <XREF IDREF="49176" TYPE="TITLE">Chapter&nbsp;15, &ldquo;Working With Fonts.&rdquo;</XREF></PARAGRAPH>
<PARAGRAPH>Such multiple-codeset strings usually cannot be rendered using a single font. A <ITALICS>fontset</ITALICS> is a collection of fonts suitable for rendering all codesets represented in a locale's encoding. A fontset includes information to indicate which locale it was created in. Applications create fontsets for their own use; when a program creates a fontset, it is told which of the requested fonts are unavailable.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Example: EUC in Japanese</TITLE><PARAGRAPH>To render strings encoded in EUC in Japanese, an application would need fonts encoded in 8859-1, JIS X 208, and JIS X 201. The application doesn't need to know which characters in a string go with which font, since it doesn't deal with locale specifics. So it creates a fontset that is made from a list of user-specified fonts (under the assumption that the localizer has provided an appropriate list). Rendering is then done using that fontset. The locale-aware rendering system chooses the appropriate fonts for each character being rendered, from the supplied list. You can find additional information about EUC in <INDEXTARGET ID="TIP_6.intl93"><!-- POSTPROCESSDATA: TIP_6.intl93|internationalization:X Window System:EUC encoding --><INDEXTARGET ID="TIP_6.intl94"><!-- POSTPROCESSDATA: TIP_6.intl94|EUC encoding:Japanese --><XREF IDREF="56941" TYPE="TITLE">&ldquo;Asian Languages.&rdquo;</XREF></PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Specifying a Fontset</TITLE><PARAGRAPH>A fontset specification is just a string, enumerating XLFD names of fonts. (See <INDEXTARGET ID="TIP_6.intl95"><!-- POSTPROCESSDATA: TIP_6.intl95|internationalization:X Window System:fontsetsXLFD font names. <ITALICS>See </ITALICS>internationalization, X Window System, fontsets --><INDEXTARGET ID="TIP_6.intl96"><!-- POSTPROCESSDATA: TIP_6.intl96|fontsets:specifying --><ITALICS>X Logical Font Description Conventions</ITALICS>, an MIT X Consortium standard, as well as <XREF IDREF="70596" TYPE="TITLE">&ldquo;Font Names&rdquo;</XREF>.) This string can include wild card characters. For example, a specification of 16-point &ldquo;fixed&rdquo; fonts might be as follows:</PARAGRAPH>
<EXAMPLE>
char *fontSetSpecString = "*fixed-medium-r-normal*150*";
</EXAMPLE>
<PARAGRAPH>Based on the fonts available, a particular server might expand this to a string such as:</PARAGRAPH>
<CODE>
-jis-fixed-medium-r-normal--16-150-75-75-c-160-jisx0208.1983-0
-sony-fixed-medium-r-normal--16-150-75-75-c-80-iso8859-1
-sony-fixed-medium-r-normal--16-150-75-75-c-80-jisx0201.1976-0
</CODE>
<PARAGRAPH>Specifying the fontset by simply enumerating the fonts is perfectly acceptable:</PARAGRAPH>
<CODE>
char *fontSetSpecString =
"-jis-fixed-medium-r-normal*150-75-75*jisx0208.1983-0,\
-sony-fixed-medium-r-normal*150-75-75*iso8859-1,\
-sony-fixed-medium-r-normal*150-75-75*jisx0201.1976-0";
</CODE>
<PARAGRAPH>A German locale would work with only the ISO font; a Japanese locale might use all three; a Chinese locale would have trouble with this fontset.<INDEXTARGET ID="TIP_6.intl97"><!-- POSTPROCESSDATA: TIP_6.intl97|EUC encoding:GermanEUC encoding:Chinese --></PARAGRAPH>
<PARAGRAPH>The developer should specify a default fontset suitable for the default locale. Furthermore, developers should ensure that the application accepts localized fontset specifications via resources (or message catalogs) or command line options. Localizers are responsible for providing default fontset specifications suitable for their locales.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Creating a Fontset</TITLE><PARAGRAPH>Creating fontsets in X is simply a matter of providing a string that names the fonts, as described above.<INDEXTARGET ID="TIP_6.intl98"><!-- POSTPROCESSDATA: TIP_6.intl98|fontsets:creating --></PARAGRAPH>
<CODE><CAPTION LBL="16-6"><PREFIX>Example 16-6 </PREFIX>Creating a Fontset</CAPTION>XFontSet fontset;
char *base_name;  /* should get from resource */
char **missingCharsetList;
int missingCharsetCount;
char *defaultStringForMissingCharsets; 
base_name = "*fixed-medium-r*150*"; /* use resources! */ 
fontset = XCreateFontSet(display, base_name,
&space;                      &amp;missingCharsetList,
&space;                      &amp;missingCharsetCount,
&space;                      &amp;defaultStringForMissingCharsets);
</CODE>
<PARAGRAPH>The locale in effect at create time is bound to the fontset. Fontsets are freed with <FUNCTION>XFreeFontSet()</FUNCTION>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using a Fontset</TITLE><PARAGRAPH>Fontsets are used when rendering text with X11R6 <INDEXTARGET ID="TIP_6.intl99"><!-- POSTPROCESSDATA: TIP_6.intl99|fontsets:using --><FUNCTION>Xmb</FUNCTION> or <FUNCTION>Xwc</FUNCTION> text rendering routines. These routines are described in <XREF IDREF="20370" TYPE="TITLE">&ldquo;Text Rendering Routines.&rdquo;</XREF>&space;</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="20370">Text Rendering Routines</TITLE><PARAGRAPH>X11R6 includes text rendering routines that understand multibyte and wide-character strings. These routines are analogous to the X11R4 text rendering routines <INDEXTARGET ID="TIP_6.intl100"><!-- POSTPROCESSDATA: TIP_6.intl100|multibyte characters. <ITALICS>See </ITALICS>internationalization, multibyte charactersinternationalization:multibyte characters:about --><INDEXTARGET ID="TIP_6.intl101"><!-- POSTPROCESSDATA: TIP_6.intl101|text rendering routines --><FUNCTION>XDrawText()</FUNCTION>, <FUNCTION>XDrawString()</FUNCTION>, and <FUNCTION>XDrawImageString()</FUNCTION>. The old routines continue to operate, but do not take fontsets, and don't know how to handle characters longer than one byte.</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><FUNCTION>XmbDrawText()</FUNCTION> and <FUNCTION>XwcDrawText()</FUNCTION> take lists of <VARIABLE>TextItems</VARIABLE>, each of which contains (among other things) a string. The strings are rendered using fontsets. These routines allow complex spacing and fontset shifts between strings.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><FUNCTION>XmbDrawString()</FUNCTION> and <FUNCTION>XwcDrawString()</FUNCTION> render a string using a fontset. These routines render in foreground only and use the raster operation from the current graphics context.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><FUNCTION>XmbDrawImageString()</FUNCTION> and <FUNCTION>XwcDrawImageString</FUNCTION> also render a string using a fontset. These routines fill the background rectangle of the entire string with the background, then render the string in the foreground color, ignoring the currently active raster operation.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Consult the appropriate reference pages for more details on these routines.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="50793">New Text Extents Functions</TITLE><PARAGRAPH>X11R6 provides MB and WC versions of <FUNCTION>width</FUNCTION> and <FUNCTION>extents</FUNCTION> interrogation routines, supplying the maximum amount of space required to draw any character in a given fontset. These routines depend on fontsets to interpret strings and use locale-specific data.</PARAGRAPH>
<PARAGRAPH>The <INDEXTARGET ID="TIP_6.intl102"><!-- POSTPROCESSDATA: TIP_6.intl102|internationalization:<ITALICS>XFontSetExtents()</ITALICS>internationalization:X Window System:<ITALICS>XFontSetExtents</ITALICS><ITALICS>XFontSetExtents</ITALICS> --><VARIABLE>XFontSetExtents</VARIABLE> structure contains the two kinds of extents a string can have:</PARAGRAPH>
<CODE>
typedef struct {
&space;   XRectangle max_ink_extent;
&space;   XRectangle max_logical_extent;
} XFontSetExtents;
</CODE>
<PARAGRAPH><VARIABLE>max_ink_extent</VARIABLE> gives the maximum boundaries needed to render the drawable characters of a fontset. It considers only the parts of glyphs that would be drawn, and gives distances relative to a constant origin. <VARIABLE>max_logical_extent</VARIABLE> gives the maximum extent of the <ITALICS>occupied space</ITALICS> of drawable characters of a fontset. The occupied space of a character is a rectangle specifying the minimum distance from other graphical features; other graphics generated by a client should not intersect this rectangle. <VARIABLE>max_logical_extent</VARIABLE> is used to compute interline spacing and the minimum amount of space needed for a given number of characters.</PARAGRAPH>
<PARAGRAPH>Here are descriptions of a few of the new extents-related functions (consult the appropriate reference pages for details):</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><FUNCTION>XExtentsOfFontSet()</FUNCTION> returns an <VARIABLE>XFontSetExtents</VARIABLE> structure for a fontset.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><FUNCTION>XmbTextEscapement()</FUNCTION> and <FUNCTION>XwcTextEscapement()</FUNCTION> take a string and return the distance in pixels (in the current drawing direction) to the origin of the next character after the string, if the string were drawn. Escapement is always positive, regardless of direction.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><FUNCTION>XmbTextExtents()</FUNCTION> and <FUNCTION>XwcTextExtents()</FUNCTION> take a string and return information detailing the overall rectangle bounding the string's image and the space the string occupies (for spacing purposes).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><FUNCTION>XmbTextPerCharExtents()</FUNCTION> and <FUNCTION>XwcTextPerCharExtents()</FUNCTION> take a string and return ink and logical extents for each character in the string. Use this for redrawing portions of strings or for word justification. If the fontset might include context-dependent drawing, the client cannot assume that it can redraw individual characters and get the same rendering.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><FUNCTION>XContextDependentDrawing()</FUNCTION> returns a Boolean telling whether a fontset might include context-dependent drawing.</PARAGRAPH>
</BULLET>
</BULLETLIST>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="64330">Internationalization Support in Motif</TITLE><PARAGRAPH>Your applications can use Motif's internationalization capabilities. Refer to the chapter titled &ldquo;Internationalization&rdquo; in the <INDEXTARGET ID="TIP_6.intl103"><!-- POSTPROCESSDATA: TIP_6.intl103|locale:Motifinternationalization:MotifMotif:internationalization --><DOCTITLE>OSF/Motif Programmer's Guide</DOCTITLE> for information about the following topics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>issues in internationalized applications</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>compound strings, fonts, and text display</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>localizing applications</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>advanced topics in internationalization</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>There are some important points to remember when you internationalize and localize your application: </PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>At the top of your <FUNCTION>main</FUNCTION> program, issue the call</PARAGRAPH>
<EXAMPLE>
<SCREENDISPLAY>XtSetLanguageProc(NULL, NULL, NULL);</SCREENDISPLAY>
</EXAMPLE>
</BULLET>
<BULLET><PARAGRAPH>Translate your app-defaults and install it in <FILENAME>/usr/lib/X11/$LANG/app-defaults</FILENAME>. </PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Motif uses font sets and font lists to display text. Specify a font list in your application defaults file using the following format:</PARAGRAPH>
<EXAMPLE>
<SCREENDISPLAY>*fontList: </SCREENDISPLAY><VARIABLE>font-list-string</VARIABLE><SCREENDISPLAY>:</SCREENDISPLAY>
</EXAMPLE>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Be sure to separate elements in the <ITALICS>font-list-string</ITALICS> as follows:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Separate single fonts with a comma (,).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Separate elements within a font set with a semicolon (;).</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>End the string with a colon (:).</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>An example of specifying a Japanese <ITALICS>fontList</ITALICS> is as follows:</PARAGRAPH>
<EXAMPLE>
*fontList: 7x14;--mincho-*--14-*;--14-*:
</EXAMPLE>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="98616">Translating User Input</TITLE><PARAGRAPH>This section explains the translation of physical user events into programmatic character strings or special keyboard data (such as &ldquo;backspace&rdquo;). This kind of work should be done by toolkits. If you can use a toolkit to manage event processing for you, do so, and blissfully ignore this section. If you are writing a toolkit text object, or are writing a truly extraordinary application, then this section is for you.<INDEXTARGET ID="TIP_6.intl104"><!-- POSTPROCESSDATA: TIP_6.intl104|internationalization:user input:toolkit text objectinternationalization:user input:application programminginternationalization:user input:text objects --></PARAGRAPH>
<PARAGRAPH>This section on translating user input covers these topics:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="45256" TYPE="TITLE">&ldquo;About User Input and Input Methods&rdquo;</XREF> presents an overview of user input and input methods.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="68556" TYPE="TITLE">&ldquo;About X Keyboard Support&rdquo;</XREF> covers X keyboard support, including keys, keycodes, keysyms, and composed characters.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="51546" TYPE="TITLE">&ldquo;Input Methods (IMs)&rdquo;</XREF> describes how input methods are opened and closed.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="17963" TYPE="TITLE">&ldquo;IM Styles&rdquo;</XREF> discusses the use and naming of IM styles.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="60412" TYPE="TITLE">&ldquo;Input Contexts (ICs)&rdquo;</XREF> explains an IM styles, IC values, pre-edit and status attributes, and creating and using ICs.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="11933" TYPE="TITLE">&ldquo;Events Under IM Control&rdquo;</XREF> describes differences in processing events under IM control including <COMMAND>XFilterEvent()</COMMAND> and <COMMAND>LookupString</COMMAND> routines. </PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="45256">About User Input and Input Methods</TITLE><PARAGRAPH>Just as internationalized programs cannot assume that data is in ASCII, they cannot assume that user input will use any specific keyboard. Keyboards change from country to country and language to language; internationalized software should never assume that a certain position on the keyboard is bound to a certain character, or that a given character will be available as a single keystroke on all keyboards.<INDEXTARGET ID="TIP_6.intl105"><!-- POSTPROCESSDATA: TIP_6.intl105|internationalization:user inputinternationalization:input methods:aboutinput methods. <ITALICS>See </ITALICS>internationalization, input methods --></PARAGRAPH>
<PARAGRAPH>No useful physical keyboard&mdash;not even one specifically designed for multilingual work&mdash;could possibly contain a key for every character we would ever wish to type. Certainly there are characters commonly used in other areas of the world that are not present on most USA keyboards. So methods have been invented that provide for input of almost any known character on even the most na&iuml;ve keyboards. These schemes are referred to as <ITALICS>input methods</ITALICS> (IMs).</PARAGRAPH>
<PARAGRAPH>Input methods vary significantly in design, use, and behavior, but there is a single API that developers use to access them. The object is for the application simply to ask for an IM and let the system check the locale and choose the appropriate IM.</PARAGRAPH>
<PARAGRAPH>Some IMs are complex; others are very simple. The API is designed to be a low-level interface, like Xlib. Usually, only toolkit text object authors must deal with the IM interfaces. However, some applications developers are unable to use toolkit objects, so the concepts are described here.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Reuse Sample Code</TITLE><PARAGRAPH>A sample program demonstrating some of the concepts in this section is given in Chapter&nbsp;11 of the <ITALICS>Xlib Programming Manual, Volume One</ITALICS>. Looking carefully at that code may be easier than starting from scratch.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>GL Input</TITLE><PARAGRAPH>The old GL function <INDEXTARGET ID="TIP_6.intl106"><!-- POSTPROCESSDATA: TIP_6.intl106|internationalization:GL input --><FUNCTION>qdevice()</FUNCTION> has a hard-coded view of a keyboard (see <FILENAME>/usr/include/gl/device.h</FILENAME> for details). Some flexibility, particularly for Europe, is available if you queue KEYBD instead of individual keys, but the GL has no general solution to non-ASCII input. There is no supported way to input Chinese (for instance) to the old GL.</PARAGRAPH>
<PARAGRAPH>OpenGL does not contain input code but leaves that to the operating environment, which in IRIX means X.</PARAGRAPH>
<PARAGRAPH>In short, support for internationalized input means a departure from <FUNCTION>qread()</FUNCTION>. Under IRIX, that means using mixed-model input, all the more reason to use a toolkit.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="68556">About X Keyboard Support</TITLE><PARAGRAPH>This section provides some background that may help make the following sections easier to understand.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Keys, Keycodes, and Keysyms</TITLE><PARAGRAPH>When a client connects to the X server, the server announces its range of <INDEXTARGET ID="TIP_6.intl107"><!-- POSTPROCESSDATA: TIP_6.intl107|internationalization:X Window System:keyboard support --><ITALICS>keycodes</ITALICS> and exports a table of <ITALICS>keysyms</ITALICS>. Each key event the client receives has a single byte <VARIABLE>keycode</VARIABLE>, which directly represents a physical key, and a single byte <VARIABLE>state</VARIABLE>, which represents currently engaged modifier keys, such as Shift or Alt.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>The mapping of state bits to modifiers is done by another table acquired from the server. </NOTE>
<PARAGRAPH>Keysyms are well defined, and there has been an attempt to have a keysym for every engraving one might possibly find on any keyboard, anywhere. (An <ITALICS>engraving</ITALICS> is the image imprinted on a physical key.) These are contained in <FILENAME>/usr/include/X11/keysymdef.h</FILENAME>. Keysyms represent the engravings on the actual keys, but not their meanings. The server's idea of the keysym table can be changed by clients, and clients may receive <VARIABLE>KeyMap</VARIABLE> events when this remapping happens, but such events don't happen often.</PARAGRAPH>
<PARAGRAPH>When a client receives a Key event, it asks Xlib to use the keycode to index into its keysym table to find a list of keysyms. (This list is usually very short. Most keys have only one or two engravings on them.) Using the state byte, Xlib chooses a keysym from the list to find out what was engraved on the key the user pressed.</PARAGRAPH>
<PARAGRAPH>At this point, the client can choose to act on the keysym itself (if, for instance, it was a backspace) or it can ask for a character string represented by the keysym (or both). Generating such a string is tricky; it is discussed in <XREF IDREF="51546" TYPE="TITLE">&ldquo;Input Methods (IMs),&rdquo;</XREF> below.</PARAGRAPH>
<PARAGRAPH>Details on X keyboard support can be found in <ITALICS>X Window System, Third Edition</ITALICS>, from Digital Press. Details on input methods are also available in that book, as well as in the <ITALICS>Xlib Programming Manual, Volume One</ITALICS>.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Composed Characters</TITLE><PARAGRAPH>There are two ways to compose characters that do not exist on a keyboard: explicit and implicit. It is common for an application to be modal and switch between the two. For example, Japanese input of kana is often done via implicit composition. <INDEXTARGET ID="TIP_6.intl108"><!-- POSTPROCESSDATA: TIP_6.intl108|internationalization:composing characters --></PARAGRAPH>
<PARAGRAPH>Users switch between a mode where input is interpreted as romaji (Latin characters) and a mode where input is translated to kana.</PARAGRAPH>
<PARAGRAPH>Furthermore, both styles may operate simultaneously. While an application is supporting implicit composition of certain characters, other characters may be composable via explicit composition.</PARAGRAPH>
<PARAGRAPH>Not every keystroke produces a character, even if the associated keysym normally implies character text. The event-to-string translation routines figure out what result a given set of keystrokes should produce (see <XREF IDREF="24219" TYPE="TITLE">&ldquo;Using XLookupString(), XwcLookupString(), and XmbLookupString()&rdquo;</XREF> in this section).</PARAGRAPH>
<PARAGRAPH>Character composition from the user's aspect is discussed in the <REFPAGE>compose(5)</REFPAGE> and <REFPAGE>composetable(5)</REFPAGE> reference pages.</PARAGRAPH>
<HANGLIST><HANGPAIR><HANGITEM>Explicit Composition</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Explicit composition is requested when the user presses the Compose key and then types a key sequence that corresponds to the desired character. For example, to compose the character &ntilde; under some keymaps, you might press the Compose key and then type <SCREENDISPLAY>~n</SCREENDISPLAY>.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>The <REFPAGE>xmodmap(1)</REFPAGE> reference page tells how to map the XK_Multi_key keysym onto whatever key you want to use as Compose. </NOTE>
</HANGBODY>
</HANGPAIR>
<HANGPAIR><HANGITEM>Implicit Composition</HANGITEM>
<HANGBODY><PARAGRAPH>&lbreak;Implicit composition mimics many existing European typewriters that have &ldquo;dead&rdquo; keys: keys that type a character but do not advance the carriage. When a special &ldquo;dead&rdquo; key is struck, the system attempts to compose a character using the next character struck. For example, on a keyboard that had a diaeresis (&die;) and an O, but no &Ouml;, you would strike <SCREENDISPLAY>&die;</SCREENDISPLAY> and then <SCREENDISPLAY>O</SCREENDISPLAY> to compose &Ouml;.</PARAGRAPH>
<PARAGRAPH>Implicit composition support usually comes with some specified way to leave characters uncomposed.</PARAGRAPH>
</HANGBODY>
</HANGPAIR>
</HANGLIST>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Supported Keyboards</TITLE><PARAGRAPH>IRIX currently supports 16 keyboard layouts: American, Belgian, Czech, Danish, English, French, German, Italian, Norwegian, Polish, Portuguese, Russian, Spanish, Swedish, Swiss and Turkish. The American keyboard needs only ASCII. </PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="51546">Input Methods (IMs)</TITLE><PARAGRAPH>Input methods (IMs) are ways to translate keyboard-input events into text strings. You would use a different input method, for instance, to type on a USA keyboard in Chinese than to type on the same keyboard in English. Nobody would build a keyboard suitable for direct input of the tens of thousands of distinct Chinese characters.<INDEXTARGET ID="TIP_6.intl109"><!-- POSTPROCESSDATA: TIP_6.intl109|internationalization:input methods --></PARAGRAPH>
<PARAGRAPH>IMs come in two flavors, <ITALICS>front-end</ITALICS> and <ITALICS>back-end</ITALICS>. Both types can use identical application programming interfaces, so you lose no generality by using back-end methods for our examples here.</PARAGRAPH>
<PARAGRAPH>To use an IM, follow these steps:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Open the IM.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Find out what the IM can do.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Agree upon capabilities to use.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Create input contexts with preferences and window(s) specified (see <XREF IDREF="60412" TYPE="TITLE">&ldquo;Input Contexts (ICs)&rdquo;</XREF>).</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Set the input context focus.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Process events.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>Although all applications go through the same setup when establishing input methods, the results can vary widely. In a Japanese locale, you might end up with networked communications with an input method server and a <ITALICS>kanji</ITALICS> translation server, with circuitous paths for Key events. But in a Swiss locale for example, it is likely that nothing would occur besides a flag or two being set in Xlib. Since operating in non-Asian locales ends up bypassing almost all of the things that might make input methods expensive, Western users are not noticeably penalized for using Asia-ready applications.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Opening an Input Method</TITLE><PARAGRAPH><INDEXTARGET ID="TIP_6.intl110"><!-- POSTPROCESSDATA: TIP_6.intl110|internationalization:input methods:opening --><FUNCTION>XOpenIM()</FUNCTION> opens an input method appropriate for the locale and modifiers in effect when it is called (see the <REFPAGE>XOpenIM(3X11)</REFPAGE> reference page). The locale is bound to that IM and cannot be changed. (But you could open another IM if you wanted to switch later.) Strings returned by <FUNCTION>XmbLookupString()</FUNCTION> and <FUNCTION>XwcLookupString()</FUNCTION> are encoded in the locale that was current when the IM was opened, regardless of current input context.</PARAGRAPH>
<PARAGRAPH>The syntax is</PARAGRAPH>
<CODE>
XIM XOpenIM(Display *dpy, XrmDataBase db, char *res_name,
&space;           char *res_class);
</CODE>
<PARAGRAPH>The <VARIABLE>res_name</VARIABLE> is the resource name of the application, <VARIABLE>res_class</VARIABLE> is the resource class, and <VARIABLE>db</VARIABLE> is the resource database that the input method should use for looking up resources private to itself. Any of these can be NULL. The fragment in <XREF IDREF="88358" TYPE="TEXT">Example&nbsp;16-7</XREF> shows how easy it is to open an input method.</PARAGRAPH>
<CODE><CAPTION LBL="16-7"><PREFIX>Example 16-7 </PREFIX><XREFTARGET ID="88358">Opening an IM</CAPTION>XIM im;
im = XOpenIM(dpy, NULL, NULL, NULL);
if (im == NULL)
&space;   exit_with_error();
</CODE>
<PARAGRAPH><FUNCTION>XOpenIM()</FUNCTION> finds the IM appropriate for the current locale. If <FUNCTION>XSupportsLocale()</FUNCTION> has returned good status (see <XREF IDREF="47944" TYPE="TITLE">&ldquo;Initialization for Xlib Programming&rdquo;</XREF>) and <FUNCTION>XOpenIM()</FUNCTION> fails, something is amiss with the administration of the system.</PARAGRAPH>
<PARAGRAPH><FUNCTION>XSetLocaleModifiers()<INDEXTARGET ID="TIP_6.intl111"><!-- POSTPROCESSDATA: TIP_6.intl111|<ITALICS>XSetLocaleModifiers()</ITALICS> --></FUNCTION> determines configure locale modifiers. The local host X locale modifiers announcer (the XMODIFIERS environment variable) is appended to the modifier list to provide default values on the locale host. The modifier list argument is a null-terminated string containing zero or more concatenated expressions of this form:</PARAGRAPH>
<CODE>
<SCREENDISPLAY>@</SCREENDISPLAY><VARIABLE>category</VARIABLE><SCREENDISPLAY>=</SCREENDISPLAY><VARIABLE>value</VARIABLE>
</CODE>
<PARAGRAPH>For example, if you want to connect Input Method Server <COMMAND>xwnmo</COMMAND>, set modifiers <COMMAND>_XWNMO</COMMAND> as follows:</PARAGRAPH>
<EXAMPLE>
XSetLocaleModifiers("@im=_XWNMO");
</EXAMPLE>
<PARAGRAPH>Or, set environment variable XMODIFIERS to the string <SCREENDISPLAY>@im=_XWNMO</SCREENDISPLAY> and execute</PARAGRAPH>
<EXAMPLE>
XSetLocaleModifiers("");
</EXAMPLE>
<NOTE><PREFIX>Note</PREFIX>The library routines are not prepared for the possibility of <FUNCTION>XSupportsLocale()</FUNCTION> succeeding and <FUNCTION>XOpenIM()</FUNCTION> failing, so it's up to application developers to deal with such an eventuality. (This circumstance could occur, for example, if the IM died after <FUNCTION>XSupportsLocale()</FUNCTION> was called.) This topic is under some debate in the MIT X consortium. If <FUNCTION>XSetLocaleModifiers()</FUNCTION> is wrong, <FUNCTION>XOpenIM()</FUNCTION> will fail.</NOTE>
<PARAGRAPH>Most of the complexity associated with IM use comes from configuring an input context to work with the IM. Input contexts are discussed in <XREF IDREF="60412" TYPE="TITLE">&ldquo;Input Contexts (ICs)&rdquo;</XREF>.</PARAGRAPH>
<PARAGRAPH>To close an input method, call <FUNCTION>XCloseIM()</FUNCTION>.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="17963">IM Styles</TITLE><PARAGRAPH>If the application requests it, an input method can often supply status information about itself. For example, a Japanese IM may be able to indicate whether it is in Japanese input mode or romaji input mode. An input method can also supply pre-edit information, partial feedback about characters in the process of being composed. The way an IM deals with status and pre-edit information is referred to as an IM style. This section describes styles and their naming.<INDEXTARGET ID="TIP_6.intl112"><!-- POSTPROCESSDATA: TIP_6.intl112|internationalization:input methods:status --></PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Root Window</TITLE><PARAGRAPH>The <INDEXTARGET ID="TIP_6.intl113"><!-- POSTPROCESSDATA: TIP_6.intl113|internationalization:input methods:root window style --><ITALICS>Root Window</ITALICS> style has a pre-edit area and a status area in a window owned by the IM as a descendant of the root. The application does not manage the pre-edit data, the pre-edit area, the status data, or the status area. Everything is left to the input method to do in its own window, as illustrated in <XREF IDREF="81313" TYPE="GRAPHIC">Figure&nbsp;16-1</XREF>.</PARAGRAPH>
<!-- RASTERCONVERT: TIP_6.intl.cgm -->
<PARAGRAPH><FIGURE><GRAPHIC FILE="TIP_6.intl-1.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="16-1"><PREFIX>Figure 16-1 </PREFIX><XREFTARGET ID="81313">Root Window Input</CAPTION>
</FIGURE>
</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Off-the-Spot</TITLE><PARAGRAPH>The <INDEXTARGET ID="TIP_6.intl114"><!-- POSTPROCESSDATA: TIP_6.intl114|internationalization:input methods:Off-the-Spot styleOff-the-Spot style --><ITALICS>Off-the-Spot</ITALICS> style places a pre-edit area and a status area in the window being used, usually in reserved space away from the place where input appears. The application manages the pre-edit area and status area, but allows the IM to update the data there. (The application provides information regarding foreground and background colors, fonts, and so on.) A window using Off-the-Spot input style might look like that shown in <XREF IDREF="68750" TYPE="GRAPHIC">Figure&nbsp;16-2</XREF>. </PARAGRAPH>
<!-- RASTERCONVERT: TIP_6.intl.cgm2 -->
<PARAGRAPH><FIGURE><GRAPHIC FILE="TIP_6.intl-2.gif" POSITION="INLINE" SCALE="FALSE"><CAPTION LBL="16-2"><PREFIX>Figure 16-2 </PREFIX><XREFTARGET ID="68750">Off-the-Spot Input</CAPTION>
</FIGURE>
</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Over-the-Spot</TITLE><PARAGRAPH>The <INDEXTARGET ID="TIP_6.intl115"><!-- POSTPROCESSDATA: TIP_6.intl115|internationalization:input methods:Over-the-Spot styleOver-the-Spot style --><ITALICS>Over-the-Spot</ITALICS> style involves the IM creating a small, pre-edit window over the point of insertion. The window is owned and managed by the IM as a descendant of the root, but it gives the user the impression that input is being entered in the right place; in fact, the pre-edit window often has no borders and is invisible to the user, giving the appearance of On-the-Spot input. The application manages the status area as in Off-the-Spot, but specifies the location of the editing so that the IM can place pre-edit data over that spot.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>On-the-Spot</TITLE><PARAGRAPH><INDEXTARGET ID="TIP_6.intl116"><!-- POSTPROCESSDATA: TIP_6.intl116|internationalization:input methods:On-the-Spot styleOn-the-Spot style --><ITALICS>On-the-Spot</ITALICS> input is by far the most complex for the application developer. The IM delivers all pre-edit data via callbacks to the application, which must perform in-place editing&mdash;complete with insertion and deletion and so on. This approach usually involves a great deal of string and text rendering support at the input generation level, above and beyond the effort required for completed input. Since this may mean a lot of updating of surrounding data or other display management, everything is left to the application. There is little chance an IM could ever know enough about the application to be able to help it provide user feedback. The IM therefore provides status and edit information via callbacks.</PARAGRAPH>
<PARAGRAPH>Done well, this style can be the most intuitive one for a user.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Setting IM Styles</TITLE><PARAGRAPH>A style describes how an IM presents its pre-edit and status information to the user. An IM supplies information detailing its presentation capabilities. The information comes in the form of flags combined with OR. The flags to use with each style are as follows: <INDEXTARGET ID="TIP_6.intl117"><!-- POSTPROCESSDATA: TIP_6.intl117|internationalization:input methods:setting styles --></PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>Root Window</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="315"><PARAGRAPH>XIMPreeditNothing | XIMStatusNothing</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>Off-the-Spot</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="315"><PARAGRAPH>XIMPreeditArea | XIMStatusArea</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>Over-the-Spot</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="315"><PARAGRAPH>XIMPreeditPosition | XIMStatusArea</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="81"><PARAGRAPH>On-the-Spot</PARAGRAPH>
</CELL>
<CELL LEFT="90" WIDTH="315"><PARAGRAPH>XIMPreeditCallbacks | XIMStatusCallbacks</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>For example, if you wanted a style variable to match an Over-the-Spot IM style, you could write:</PARAGRAPH>
<EXAMPLE>
XIMStyle over = XIMPreeditPosition | XIMStatusArea;
</EXAMPLE>
<PARAGRAPH>If an IM returns <VARIABLE>XIMStatusNone</VARIABLE> (not to be confused with <VARIABLE>XIMStatusNothing</VARIABLE>), it means the IM will not supply status information.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using Styles</TITLE><PARAGRAPH>An input method supports one or more styles. It's up to the application to find a style that is supported by both the IM and the application. If several exist, the application must choose. If none exist, the application is in trouble.<INDEXTARGET ID="TIP_6.intl118"><!-- POSTPROCESSDATA: TIP_6.intl118|internationalization:input methods:using styles --></PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="60412">Input Contexts (ICs)</TITLE><PARAGRAPH>An input method may be serving multiple clients, or one client with multiple windows, or one client with multiple input styles on one window. The specification of style and client/IM communication is done via <INDEXTARGET ID="TIP_6.intl119"><!-- POSTPROCESSDATA: TIP_6.intl119|internationalization:input contexts --><ITALICS>input contexts</ITALICS>. An input context is simply a collection of parameters that together describe how to go about receiving and examining input under a given set of circumstances.</PARAGRAPH>
<PARAGRAPH>To set up and use an input context:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>Decide what styles your application can support.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Query the IM to find out what styles it supports.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Find a match.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Determine information that the IC needs in order to work with your application.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Create the IC.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>Employ the IC.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<SECTION3 LBL="" HELPID = ""><TITLE>Find an IM Style</TITLE><PARAGRAPH>The IM may be able to support multiple styles&mdash;for example, both Off-the-Spot and Root Window. The application may be able to do, in order of preference, Over-the-Spot, Off-the-Spot, and Root Window. The application should determine that the best match in this case is Off-the-Spot.<INDEXTARGET ID="TIP_6.intl120"><!-- POSTPROCESSDATA: TIP_6.intl120|internationalization:input contexts:styles --></PARAGRAPH>
<PARAGRAPH>First, discover what the IM can do, then set up a variable describing what the application can do, as shown in <XREF IDREF="66087" TYPE="TEXT">Example&nbsp;16-8</XREF>.</PARAGRAPH>
<CODE><CAPTION LBL="16-8"><PREFIX>Example 16-8 </PREFIX><XREFTARGET ID="66087">Finding What a Client Can Do</CAPTION>XIMStyles *IMcando;
XIMStyle  clientCanDo; /* note type difference */
XIMStyle  styleWeWillUse = NULL;
XGetImValues(im, XNQueryInputStyle, &amp;IMcando, NULL);
clientCanDo =
/*none*/ XIMPreeditNone | XIMStatusNone |
/*over*/ XIMPreeditPosition | XIMStatusArea |
/*off*/  XIMPreeditArea | XIMStatusArea |
/*root*/ XIMPreeditNothing | XIMStatusNothing;
</CODE>
<PARAGRAPH>A client should always be able to handle the case of <FUNCTION>XIMPreeditNone&nbsp;|&nbsp;XIMStatusNone</FUNCTION>, which is likely in a Western locale. To the application, this is not very different from a <VARIABLE>RootWindow</VARIABLE> style, but it comes with less overhead.</PARAGRAPH>
<PARAGRAPH>Once you know what the application can handle, look through the IM styles for a match, as shown in <XREF IDREF="50944" TYPE="TEXT">Example&nbsp;16-9</XREF>.</PARAGRAPH>
<CODE><CAPTION LBL="16-9"><PREFIX>Example 16-9 </PREFIX><XREFTARGET ID="50944">Setting the Desired IM Style</CAPTION>for(i=0; i &lt; IMcando->count_styles; i++) {
&space;   XIMStyle tmpStyle;
&space;   tmpStyle = IMcando->support_styles[i];
&space;   if ( ((tmpStyle &amp; clientCanDo) == tmpStyle) )
&space;           styleWeWillUse = tmpStyle;
}
if (styleWeWillUse = NULL)
&space;   exit_with_error();
XFree(IMcando);
/* styleWeWillUse is set, which is what we were after */
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="62196">IC Values</TITLE><PARAGRAPH>There are several pieces of information an input method may require, depending on the input context and style chosen by the application. The input method can acquire any such information it needs from the input context, ignoring any information that does not affect the style or IM.<INDEXTARGET ID="TIP_6.intl121"><!-- POSTPROCESSDATA: TIP_6.intl121|internationalization:input contexts:values --></PARAGRAPH>
<PARAGRAPH>A full description of every item of information available to the IM is supplied in <ITALICS>X Window System, Third Edition</ITALICS>. The following is a brief list: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><VARIABLE>XNClientWindow</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>Specifies to the IM which client window it can display data in 
or create child windows in. Set once and cannot be changed.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><VARIABLE>XNFilterEvents</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>An additional event mask for event selection on the client 
window.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><VARIABLE>XNFocusWindow</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>The window to receive processed (composed) Key events.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><VARIABLE>XNGeometryCallback</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>A geometry handler that is called if the client allows an IM to 
change the geometry of the window.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><VARIABLE>XNInputStyle</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>Specifies the style for this IC.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><VARIABLE>XNResourceClass</VARIABLE>, 
<VARIABLE>XNResourceName</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>The resource class and name to use when the IM looks up 
resources that vary by IC.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="108"><PARAGRAPH><VARIABLE>XNStatusAttributes</VARIABLE>, 
<VARIABLE>XNPreeditAttributes</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="279"><PARAGRAPH>The attributes to be used for any status and pre-edit areas 
(nested, variable-length lists).</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Pre-Edit and Status Attributes</TITLE><PARAGRAPH>When an IM is going to provide state, it needs some simple X information with which to do its work. For example, if an IM is going to draw status information in a client window in an Off-the-Spot style, it needs to know where the area is, what color and font to render text in, and so on. The application gives this data to the IC for use by the IM.</PARAGRAPH>
<PARAGRAPH>As with the <XREF IDREF="62196" TYPE="TITLE">&ldquo;IC Values&rdquo;</XREF> section, full details are available in <ITALICS>X Window System, Third&nbsp;Edition</ITALICS>. </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH><VARIABLE>XNArea</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="270"><PARAGRAPH>A rectangle to be used as a status or pre-edit area.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><VARIABLE>XNAreaNeeded</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="270"><PARAGRAPH>The rectangle desired by the attribute writer. Either the 
application or the IM may provide this information, 
depending on circumstances.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><VARIABLE>XNBackgroundPixmap</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="270"><PARAGRAPH>A pixmap to be used for the background of windows the IM 
creates.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><VARIABLE>XNColormap</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="270"><PARAGRAPH>The colormap to use.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><VARIABLE>XNCursor</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="270"><PARAGRAPH>The cursor to use.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><VARIABLE>XNFontSet</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="270"><PARAGRAPH>The fontset to use for rendering text.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH><VARIABLE>XNForeground</VARIABLE>, 
<VARIABLE>XNBackground</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="270"><PARAGRAPH>The colors to use for rendering.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><VARIABLE>XNLineSpacing</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="270"><PARAGRAPH>The line spacing to be used in the pre-edit window if more 
than one line is used.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><VARIABLE>XNSpotLocation</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="270"><PARAGRAPH>Specifies where the next insertion point is, for use by 
<VARIABLE>XIMPreeditPosition</VARIABLE> styles.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="117"><PARAGRAPH><VARIABLE>XNStdColormap</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="125" WIDTH="270"><PARAGRAPH>Specifies that the IM should use <FUNCTION>XGetRGBColormaps()</FUNCTION> with 
the supplied property (passed as an Atom) in order to find 
out which colormap to use.</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Creating an Input Context</TITLE><PARAGRAPH>Creating an input context is a simple matter of calling <INDEXTARGET ID="TIP_6.intl122"><!-- POSTPROCESSDATA: TIP_6.intl122|internationalization:input contexts:creating --><FUNCTION>XCreateIC()</FUNCTION> with a variable-length list of parameters specifying IC values. <XREF IDREF="89320" TYPE="TEXT">Example&nbsp;16-10</XREF> shows a simple example that works for the root window. </PARAGRAPH>
<CODE><CAPTION LBL="16-10"><PREFIX>Example 16-10 </PREFIX><XREFTARGET ID="89320">Creating an Input Context With XCreateIC() </CAPTION>XVaNestedList arglist;
XIC ic;
arglist = XVaCreateNestedList(0, XNFontSet, fontset,
&space;                          XNForeground,
&space;                          WhitePixel(dpy, screen),
&space;                          XNBackground,
&space;                          BlackPixel(dpy, screen),
&space;                          NULL);
ic = XCreateIC(im, XNInputStyle, styleWeWillUse,
&space;             XNClientWindow, window, XNFocusWindow, window,
&space;             XNStatusAttributes, arglist,
&space;             XNPreeditAttributes, arglist, NULL);
XFree(arglist);
if (ic == NULL)
&space;   exit_with_error();
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Using the IC</TITLE><PARAGRAPH>A multi-window application may choose to use several input contexts. But for simplicity, assume that the application just wants to get to the internationalized input using one method in one window.<INDEXTARGET ID="TIP_6.intl123"><!-- POSTPROCESSDATA: TIP_6.intl123|internationalization:input contexts:using --></PARAGRAPH>
<PARAGRAPH>Using the IC is a matter of making sure you check events the IC wants, and of setting IC&nbsp;focus. If you are setting up a window for the first time, you know the event mask you want, and you can use it directly. If you are attaching an IC to a previously configured window, you should query the window and add in the new event mask.</PARAGRAPH>
<CODE><CAPTION LBL="16-11"><PREFIX>Example 16-11 </PREFIX>Using the IC</CAPTION>unsigned long imEventMask;
XGetWindowAttributes(dpy, win, &amp;winAtts);
XGetICValues(ic, XNFilterEvents, &amp;imEventMask, NULL);
imEventMask |= winAtts.your_event_mask;
XSelectInput(dpy, window, imEventMask);
XSetICFocus(ic);
</CODE>
<PARAGRAPH>At this point, the window is ready to be used. </PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="11933">Events Under IM Control</TITLE><PARAGRAPH>Processing events under input method control is almost the same in X11R6 as it was under R4 and before. There are two essential differences: the <INDEXTARGET ID="TIP_6.intl124"><!-- POSTPROCESSDATA: TIP_6.intl124|internationalization:input methods:event handling --><FUNCTION>XFilterEvent()</FUNCTION> and <FUNCTION>X*LookupString()</FUNCTION> routines.</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Using XFilterEvent()</TITLE><PARAGRAPH>Every event received by your application should be fed to the IM via <INDEXTARGET ID="TIP_6.intl125"><!-- POSTPROCESSDATA: TIP_6.intl125|internationalization:input methods:<ITALICS>XFilterEvent()</ITALICS><ITALICS>XFilterEvent()</ITALICS> --><FUNCTION>XFilterEvent()</FUNCTION>, which returns a value telling you whether or not to disregard the event. IMs asks you to disregard the event if they have extracted the data and plan on giving it to you later, possibly in some other form. All events (not just <VARIABLE>KeyPress</VARIABLE> and <VARIABLE>KeyRelease</VARIABLE> events) go to <FUNCTION>XFilterEvent()</FUNCTION>.</PARAGRAPH>
<PARAGRAPH>If you compacted the event processing into a single routine, a typical event loop would look something like the code in <XREF IDREF="42123" TYPE="TEXT">Example&nbsp;16-12</XREF>.</PARAGRAPH>
<CODE><CAPTION LBL="16-12"><PREFIX>Example 16-12 </PREFIX><XREFTARGET ID="42123">Event Loop</CAPTION>Xevent event;
while (TRUE) {
&space;   XNextEvent(dpy, &amp;event);
&space;   if (XFilterEvent(&amp;event, None))
&space;       continue;
&space;   DealWithEvent(&amp;event);
}
</CODE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="24219">Using XLookupString(), XwcLookupString(), and XmbLookupString()</TITLE><PARAGRAPH>When using an input method, you should replace calls to <INDEXTARGET ID="TIP_6.intl126"><!-- POSTPROCESSDATA: TIP_6.intl126|internationalization:input methods:stringsinternationalization:input methods:<ITALICS>XLookupString()</ITALICS><ITALICS>XmbLookupString()</ITALICS><ITALICS>XwcLookupString()</ITALICS><ITALICS>XLookupString()&lt;Default Para Fon</ITALICS> --><FUNCTION>XLookupString()</FUNCTION> with calls to <FUNCTION>XwcLookupString()</FUNCTION> or <FUNCTION>XmbLookupString()</FUNCTION>. The <FUNCTION>MB</FUNCTION> and <FUNCTION>WC</FUNCTION> versions have very similar interfaces. The examples below arbitrarily use <FUNCTION>XmbLookupString()</FUNCTION>, but apply to both versions.</PARAGRAPH>
<PARAGRAPH>There are two new situations to deal with:</PARAGRAPH>
<ORDEREDLIST><LIST><PARAGRAPH>The string returned may be long.</PARAGRAPH>
</LIST>
<LIST><PARAGRAPH>There may be an interesting keysym returned, an interesting set of characters returned, both, or neither.</PARAGRAPH>
</LIST>
</ORDEREDLIST>
<PARAGRAPH>Dealing with the former is a matter of maintaining an arena, as in <XREF IDREF="72133" TYPE="TEXT">Example&nbsp;16-13</XREF>.</PARAGRAPH>
<PARAGRAPH>To tell the application what to pay attention to for a given event, <FUNCTION>XmbLookupString()</FUNCTION> returns a status value in a passed parameter, equal to one of the following: </PARAGRAPH>
<TABLE COLUMNS="2"><TABLEBODY><ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH><VARIABLE>XLookupKeysym</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="306"><PARAGRAPH>Indicates that the keysym should be checked.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><VARIABLE>XLookupChars</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="306"><PARAGRAPH>Indicates that a string has been typed or composed.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><VARIABLE>XLookupBoth</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="306"><PARAGRAPH>Means both of the above.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><VARIABLE>XLookupNone</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="306"><PARAGRAPH>Means neither is ready for processing.</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="90"><PARAGRAPH></PARAGRAPH>
<PARAGRAPH><VARIABLE>XBufferOverflow</VARIABLE></PARAGRAPH>
</CELL>
<CELL LEFT="95" WIDTH="306"><PARAGRAPH>Means the supplied buffer is too small&mdash;call <FUNCTION>XmbLookupString()</FUNCTION> 
again with a bigger buffer</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH><FUNCTION>XmbLookupString()</FUNCTION> also returns the length of the string in question. Note that <FUNCTION>XmbLookupString()</FUNCTION> returns the length of the string in bytes, while <FUNCTION>XwcLookupString()</FUNCTION> returns the length of the string in characters.</PARAGRAPH>
<PARAGRAPH>The example below should help show how these functions work. Most event processors perform a switch on the event type; assume you have done that and have received a <VARIABLE>KeyPress</VARIABLE> event.</PARAGRAPH>
<CODE><CAPTION LBL="16-13"><PREFIX>Example 16-13 </PREFIX><XREFTARGET ID="72133">KeyPress Event</CAPTION>case KeyPress:
{
&nbsp;&nbsp;&nbsp;&nbsp;Keysym&nbsp;keysym;
&nbsp;&nbsp;&nbsp;&nbsp;Status&nbsp;status;
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;buflength;
&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;bufsize&nbsp;=&nbsp;16;
&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;char&nbsp;*buf&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf&nbsp;==&nbsp;NULL)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf&nbsp;=&nbsp;malloc(bufsize);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf&nbsp;&lt;&nbsp;0)&nbsp;StopSequence();
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;buflength&nbsp;=&nbsp;XmbLookupString(ic,&nbsp;&amp;event,&nbsp;buf,&nbsp;bufsize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;keysym,&nbsp;&amp;status);
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;first,&nbsp;check&nbsp;to&nbsp;see&nbsp;if&nbsp;that&nbsp;worked&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(status&nbsp;==&nbsp;XBufferOverflow)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf&nbsp;=&nbsp;realloc(buf,&nbsp;(bufsize&nbsp;=&nbsp;buflength));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buflength&nbsp;=&nbsp;XmbLookupString(ic,&nbsp;&amp;event,&nbsp;buf,&nbsp;bufsize,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;keysym,&nbsp;&amp;status);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;We&nbsp;have&nbsp;a&nbsp;valid&nbsp;status.&nbsp;Check&nbsp;that&nbsp;*/
&nbsp;&nbsp;&nbsp;&nbsp;switch(status)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;XLookupKeysym:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DealWithKeysym(keysym);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;XLookupBoth:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DealWithKeysym(keysym);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;**FALL INTO** charcter case */
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;XLookupChars:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DealWithString(buf,&nbsp;buflength);
&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;XLookupNone:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;/*&nbsp;end&nbsp;switch(status)&nbsp;*/
} /* end case KeyPress segment */
break; /* we are in a switch(event.type) statement */ 
</CODE>
</SECTION3>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="19057">GUI Concerns</TITLE><PARAGRAPH>It shouldn't be significantly more difficult to internationalize an application with a graphical user interface than an application without such an interface, but there are a few further issues that must be addressed:<INDEXTARGET ID="TIP_6.intl127"><!-- POSTPROCESSDATA: TIP_6.intl127|internationalization:GUIs --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="74006" TYPE="TITLE">&ldquo;X Resources for Strings&rdquo;</XREF> covers labeling objects using X resources.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="35180" TYPE="TITLE">&ldquo;Layout&rdquo;</XREF> describes creating layouts that are usable after localization.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="17042" TYPE="TITLE">&ldquo;Icons&rdquo;</XREF> explains some concerns for localizing icons.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="74006">X Resources for Strings</TITLE><PARAGRAPH>Resource lookup mechanisms in Xlib as well as in toolkits monitor locale environment variables when locating resource files. For string constants that are used within toolkit objects, resources provide a simpler solution than do message catalogs.<INDEXTARGET ID="TIP_6.intl128"><!-- POSTPROCESSDATA: TIP_6.intl128|internationalization:X Window System:string resources --></PARAGRAPH>
<PARAGRAPH>These are some common objects that should definitely get their text from resources:<INDEXTARGET ID="TIP_6.intl129"><!-- POSTPROCESSDATA: TIP_6.intl129|internationalization:GUIs:object labels --></PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH>Labels</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Buttons</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Menu items</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH>Dialog notices and questions</PARAGRAPH>
</BULLET>
</BULLETLIST>
<PARAGRAPH>Any object that employs some sort of text label should be labeled via resources. Since the localizer wants to provide strings for the local version of the application, the <INDEXTARGET ID="TIP_6.intl130"><!-- POSTPROCESSDATA: TIP_6.intl130|internationalization:GUIs:text labels --><FILENAME>app-defaults</FILENAME> file for the application should specify every reasonable string resource. Reference pages should identify all localizable string resources.</PARAGRAPH>
<PARAGRAPH>Localizers of an application provide a separate resource file for each locale that the application runs in.</PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="35180">Layout</TITLE><PARAGRAPH>Layout management is of special interest when you cannot predict how large a button or other label might be. The nature of the problem of layout composition and management does not change, but one must construct the layout management without full knowledge of the final appearance.<INDEXTARGET ID="TIP_6.intl131"><!-- POSTPROCESSDATA: TIP_6.intl131|internationalization:GUIs:layout --><INDEXTARGET ID="TIP_6.intl132"><!-- POSTPROCESSDATA: TIP_6.intl132|internationalization:GUIs:composition --></PARAGRAPH>
<PARAGRAPH>It's worth noting that localization efforts can be assumed to be &ldquo;reasonable&rdquo; in some sense. For example, X resources have always allowed a user to specify an extremely large font for buttons, but applications correctly choose to let such users live with the results. But it's not always that clear what is reasonable and what isn't; you don't always know what will be difficult to translate succinctly in some locale. So while you need not provide for all combinations of resource specifications, you must make the application localizable.</PARAGRAPH>
<PARAGRAPH>Three main approaches to the layout problem are described below: dynamic layout, constant layout, and localized layout</PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="17649">Dynamic Layout</TITLE><PARAGRAPH>Most toolkits provide <ITALICS>form</ITALICS>, <ITALICS>pane</ITALICS>, <ITALICS>rowcolumn</ITALICS>, or other layout objects that calculate layout depending on the &ldquo;natural&rdquo; (localized) size of the objects involved. Most use some hints provided by the developer that can regulate this layout. For example, some IRIS IM widgets providing these services are <VARIABLE>XmForm</VARIABLE>, <VARIABLE>XmPanedWindow</VARIABLE>, and <VARIABLE>XmRowColumn</VARIABLE>.</PARAGRAPH>
<PARAGRAPH>Dynamic layout is probably the simplest way to prevent localization difficulties.</PARAGRAPH>
<NOTE><PREFIX>Note</PREFIX>The IRIS IM product is the Silicon Graphics port of the OSF/Motif product, and should not be confused with IM, the abbreviation for Input Methods. </NOTE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Constant Layout</TITLE><PARAGRAPH>Under certain circumstances, an application may insist on having a predefined layout. When this is so, the application must provide objects that are constructed to allow localization. A &ldquo;Quit&rdquo; button that just barely allows room for the Latin 1 string &ldquo;Quit&rdquo; is not likely to suffice when localizers attempt to fit their translations into that small space.</PARAGRAPH>
<PARAGRAPH>In order to enforce constant layout, the developer incurs the heavy responsibility of making sure the objects are localizable. This means a lot of investigation; the &ldquo;there, that ought to be enough&rdquo; approach is chancy at best.</PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>Localized Layout</TITLE><PARAGRAPH>Some toolkits provide for layout control by run-time reading of strings or other data files. Applications that use such toolkits can easily finesse the layout issue by providing the capability for localization of the layout, as well as localization of the contents of the layout. This provides each localizer maximum freedom in presenting the application to the local users. The application developer is responsible for providing localizers with instructions and the mechanisms necessary to produce layout data.<INDEXTARGET ID="TIP_6.intl133"><!-- POSTPROCESSDATA: TIP_6.intl133|internationalization:GUIs:localized layout --></PARAGRAPH>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE>IRIS IM Localization With editres</TITLE><PARAGRAPH>IRIX provides an interactive method of laying out widgets for IRIS IM and Xaw (the Athena Widget Set): a utility called <INDEXTARGET ID="TIP_6.intl134"><!-- POSTPROCESSDATA: TIP_6.intl134|internationalization:GUIs:<ITALICS>editres</ITALICS><ITALICS>editres</ITALICS> --><COMMAND>editres</COMMAND>. With <COMMAND>editres</COMMAND>, you can construct and edit resources and see how your widgets will look on the screen; the program even generates a usable app-defaults file for you. But note that if you hard-code any resources into your IRIS IM code, you won't be able to edit them using this method.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="17042">Icons</TITLE><PARAGRAPH>Icons attempt to be fairly generic representations of their antecedents. Unfortunately, it is very difficult for a designer to know what is generic or recognizable in other cultures. Therefore, it is important that any pictographic representations used by an application be localizable.<INDEXTARGET ID="TIP_6.intl135"><!-- POSTPROCESSDATA: TIP_6.intl135|internationalization:GUIs:iconsinternationalization:icons --></PARAGRAPH>
<PARAGRAPH>Graphic representations can be stored as strings representing X bitmaps, as names of data files containing pictographs, or in whatever manner the developer thinks best, so long as the developer provides a way for the localizer to produce and deliver localized pictographs.</PARAGRAPH>
</SECTION2>
</SECTION1>
<SECTION1 LBL="" HELPID = ""><TITLE><XREFTARGET ID="35985">Popular Encodings</TITLE><PARAGRAPH>This section discusses three encodings that are commonly used:</PARAGRAPH>
<BULLETLIST><BULLET><PARAGRAPH><XREF IDREF="18506" TYPE="TITLE">&ldquo;The ISO 8859 Family&rdquo;</XREF> explains the ISO 8859 family of encodings.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="56941" TYPE="TITLE">&ldquo;Asian Languages&rdquo;</XREF> describes Asian language encodings.</PARAGRAPH>
</BULLET>
<BULLET><PARAGRAPH><XREF IDREF="72092" TYPE="TITLE">&ldquo;Unicode&rdquo;</XREF> covers the ISO 10646 and Unicode.</PARAGRAPH>
</BULLET>
</BULLETLIST>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="18506">The ISO 8859 Family</TITLE><PARAGRAPH>American English is easily representable in 7-bit ASCII. Most other languages are not. For example, the character &eacute; is not in ASCII.<INDEXTARGET ID="TIP_6.intl136"><!-- POSTPROCESSDATA: TIP_6.intl136|internationalization:encodings:ISO 8859 --></PARAGRAPH>
<PARAGRAPH>Most Western European languages are representable in 8-bit ISO 8859-1, which is commonly known as Latin 1. Latin 1 is a superset of ASCII that includes characters used by several Western European languages (such as &ouml;, &pound;, &ntilde;, &ccedil;, &iquest;).<XREFTARGET ID="15634"><INDEXTARGET ID="TIP_6.intl137"><!-- POSTPROCESSDATA: TIP_6.intl137|internationalization:encodings:Latin 1internationalization:encodings:European languages --></PARAGRAPH>
<PARAGRAPH>ISO 8859 comes in nine parts, many of which overlap; all are supersets of ASCII. <INDEXTARGET ID="TIP_6.intl138"><!-- POSTPROCESSDATA: TIP_6.intl138|languages, ISO. <ITALICS>See </ITALICS>internationalization, encodingslanguages, Latin. <ITALICS>See </ITALICS>internationalization, encodingsinternationalization:languages:Latin --></PARAGRAPH>
<PARAGRAPH>The ISO 8859 Character Sets are shown in <XREF IDREF="62878" TYPE="TABLE">Table&nbsp;16-10</XREF>.</PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="16-10"><PREFIX>Table 16-10 </PREFIX><XREFTARGET ID="62878">ISO 8859 Character Sets</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="64"><PARAGRAPH>Character Set</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="72"><PARAGRAPH>Common Name</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="250"><PARAGRAPH>Languages Supported</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="64"><PARAGRAPH>8859-1</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="72"><PARAGRAPH>Latin 1</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="250"><PARAGRAPH>Danish, Dutch, English, Faeroese, Finnish, French, German, 
Icelandic, Irish, Italian, Norwegian, Portuguese, Spanish, 
Swedish</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="64"><PARAGRAPH>8859-2</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="72"><PARAGRAPH>Latin 2</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="250"><PARAGRAPH>Albanian, Czech, English, German, Hungarian, Polish, 
Rumanian, Serbo-Croatian, Slovak, Slovene</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="64"><PARAGRAPH>8859-3</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="72"><PARAGRAPH>Latin 3</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="250"><PARAGRAPH>Afrikaans, Catalan, Dutch, English, Esperanto, German, 
Italian, Maltese, Spanish, Turkish</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="64"><PARAGRAPH>8859-4</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="72"><PARAGRAPH>Latin 4</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="250"><PARAGRAPH>Danish, English, Estonian, Finnish, German, Greenlandic, 
Lapp, Latvian, Lithuanian, Norwegian, Swedish</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="64"><PARAGRAPH>8859-5</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="72"><PARAGRAPH>Latin/Cyrillic</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="250"><PARAGRAPH>Bulgarian, Byelorussian, English, Macedonian, Russian, 
Serbo-Croatian, Ukrainian</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="64"><PARAGRAPH>8859-6</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="72"><PARAGRAPH>Latin/Arabic</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="250"><PARAGRAPH>Arabic, English (see ISO 8859-6 specification)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="64"><PARAGRAPH>8859-7</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="72"><PARAGRAPH>Latin/Greek</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="250"><PARAGRAPH>English, Greek (see ISO 8859-7 specification)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="64"><PARAGRAPH>8859-8</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="72"><PARAGRAPH>Latin/Hebrew</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="250"><PARAGRAPH>English, Hebrew (see ISO 8859-8 specification)</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="64"><PARAGRAPH>8859-9</PARAGRAPH>
</CELL>
<CELL LEFT="70" WIDTH="72"><PARAGRAPH>Latin 5</PARAGRAPH>
</CELL>
<CELL LEFT="150" WIDTH="250"><PARAGRAPH>Danish, Dutch, English, Finnish, French, German, Irish, 
Italian, Norwegian, Portuguese, Spanish, Swedish, Turkish</PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
<PARAGRAPH>IRIX contains over 500 Latin 1 fonts, as well as a few fonts for each of the other 8859-encoded character sets, except 8859-6 and 8859-8. Currently, IRIX contains no fonts for use with the 8859-6 or 8859-8 character sets.<INDEXTARGET ID="TIP_6.intl139"><!-- POSTPROCESSDATA: TIP_6.intl139|internationalization:languages:Japanese --></PARAGRAPH>
<PARAGRAPH>To get the list of ISO-8859 fonts, enter the following:</PARAGRAPH>
<CODE>
xlsfonts
</CODE>
<PARAGRAPH>Or you can restrict the amount of output, for example, by typing</PARAGRAPH>
<CODE>
xlsfonts `*8859-2'
</CODE>
<PARAGRAPH>To see the encoding, use the <COMMAND>xfd</COMMAND> command. For example:</PARAGRAPH>
<CODE>
xfd -fn -sgi-screen-medium-r-normal--9-90-72-72-m-60-iso8859-1
</CODE>
<PARAGRAPH>For more information on <COMMAND>xlsfonts</COMMAND> and <COMMAND>xfd</COMMAND>, and installing and using fonts, refer to <XREF IDREF="49176" TYPE="TITLE">Chapter&nbsp;15, &ldquo;Working With Fonts.&rdquo;</XREF></PARAGRAPH>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="56941">Asian Languages</TITLE><PARAGRAPH>Asian languages are commonly ideographic and employ large numbers of characters for their representation. For example, Japanese and Korean can be practically encoded in 16 bits. Daily-use Chinese can be, also, but archives and scholars frequently need more, so Chinese is often encoded with up to four bytes per character.<INDEXTARGET ID="TIP_6.intl140"><!-- POSTPROCESSDATA: TIP_6.intl140|internationalization:encodings:Asian languagesinternationalization:languages:Asian --></PARAGRAPH>
<SECTION3 LBL="" HELPID = ""><TITLE>Some Standards</TITLE><PARAGRAPH>Various Asian character sets have been developed, some of which are considered standard. Encodings for these sets are less standardized. Asian character sets usually require larger-than-byte character types like those described in <INDEXTARGET ID="TIP_6.intl141"><!-- POSTPROCESSDATA: TIP_6.intl141|internationalization:languages:Asian --><XREF IDREF="55810" TYPE="TITLE">&ldquo;Multibyte Characters.&rdquo;</XREF>&space;<XREF IDREF="62552" TYPE="TABLE">Table&nbsp;16-11</XREF> lists some of these standard character sets. Note that some of these character sets have multiple associated codesets, usually designated by appending the year the codeset was adopted to the character set name. (For example, JIS X 208-1983 is different from JIS X 208-1990.)</PARAGRAPH>
<TABLE COLUMNS="3"><CAPTION LBL="16-11"><PREFIX>Table 16-11 </PREFIX><XREFTARGET ID="62552"> <EMPHASIS>(continued)        </EMPHASIS>Character Sets for Asian Languages</CAPTION>
<TABLEHEADING><CELL LEFT="0" WIDTH="110"><PARAGRAPH>Language</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="110"><PARAGRAPH>Character Set Standards</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="110"><PARAGRAPH>Support</PARAGRAPH>
</CELL>
</TABLEHEADING>
<TABLEBODY><ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>Japanese</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="110"><PARAGRAPH>JIS X 0201.1976-0</PARAGRAPH>
<PARAGRAPH>&nbsp;</PARAGRAPH>
<PARAGRAPH>JIS X 0208.1983-0</PARAGRAPH>
<PARAGRAPH>&nbsp;</PARAGRAPH>
<PARAGRAPH>&nbsp;</PARAGRAPH>
<PARAGRAPH>JIS X 0212.1990-0</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="110"><PARAGRAPH><ITALICS>Katakana</ITALICS>&nbsp;</PARAGRAPH>
<PARAGRAPH><ITALICS>Kanji</ITALICS>, <ITALICS>kana</ITALICS>, Latin, Greek, 
Cyrillic, symbols, others</PARAGRAPH>
<PARAGRAPH>&nbsp;</PARAGRAPH>
<PARAGRAPH>Supplemental <ITALICS>kanji</ITALICS>, others</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>Chinese</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="110"><PARAGRAPH>GB 2312.1980-0</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="110"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>Korean</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="110"><PARAGRAPH>KSC 5601.1987-0</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="110"><PARAGRAPH>Hangul</PARAGRAPH>
</CELL>
</ROW>
<ROW><CELL LEFT="0" WIDTH="110"><PARAGRAPH>Taiwan</PARAGRAPH>
</CELL>
<CELL LEFT="115" WIDTH="110"><PARAGRAPH>CNS 11643</PARAGRAPH>
</CELL>
<CELL LEFT="230" WIDTH="110"><PARAGRAPH></PARAGRAPH>
</CELL>
</ROW>
</TABLEBODY>
</TABLE>
</SECTION3>
<SECTION3 LBL="" HELPID = ""><TITLE><XREFTARGET ID="31663">EUC</TITLE><PARAGRAPH>EUC is <INDEXTARGET ID="TIP_6.intl142"><!-- POSTPROCESSDATA: TIP_6.intl142|internationalization:encodings:EUC --><ITALICS>Extended UNIX Code</ITALICS>, an encoding methodology that supports concurrent use of four codesets in one encoding. It employs two special &ldquo;shift state&rdquo; bytes:</PARAGRAPH>
<CODE>
ss1 = 0x8e
ss2 = 0x8f
</CODE>
<PARAGRAPH>These are used to identify codesets within a string. The EUC encoding scheme uses the following patterns to indicate which codeset is in use at any given time:</PARAGRAPH>
<CODE>
Codeset #0: 0<ITALICS>xxxxxxx</ITALICS>
Codeset #1: 1<ITALICS>xxxxxxx</ITALICS> [ 1<ITALICS>xxxxxxx</ITALICS> ...]
Codeset #2: ss1 1<ITALICS>xxxxxxx</ITALICS> [ 1<ITALICS>xxxxxxx</ITALICS> ...]
Codeset #3: ss2 1<ITALICS>xxxxxxx</ITALICS> [ 1<ITALICS>xxxxxxx</ITALICS> ...]
</CODE>
<PARAGRAPH>So if <VARIABLE>ss1</VARIABLE> appears in a string, it means that the next character&mdash;however many bytes long it is&mdash;should be interpreted as a character from codeset #2. If there are multiple characters in a row from codeset #2, each one is preceded by <VARIABLE>ss1</VARIABLE>. Similarly, <VARIABLE>ss2</VARIABLE> indicates that the following character belongs to codeset #3. If any other byte whose high bit is 1 appears in the string (without being preceded by <VARIABLE>ss1</VARIABLE> or <VARIABLE>ss2</VARIABLE>), it is interpreted as all or part of a character from codeset&nbsp;#1.</PARAGRAPH>
<PARAGRAPH>In EUC, codeset #1 is always ASCII. The other codesets are implementation- or user-defined. This is why EUC cannot support Latin 1 in Asian locales.</PARAGRAPH>
<PARAGRAPH>EUC implementations exist (but are not standardized) for all ideographic Asian languages.</PARAGRAPH>
</SECTION3>
</SECTION2>
<SECTION2 LBL="" HELPID = ""><TITLE><XREFTARGET ID="72092">Unicode</TITLE><PARAGRAPH>The Unicode Consortium has developed a character code system called Unicode. Unicode 2.0 covers most of the modern languages, scripts, CJK (Chinese-Japanese- Korean) scripts, and scientific and mathematical symbols. Each character is represented by a fixed width of 16 bits. Unicode 2.0 implements the characters that are coded in the Basic Multilingual Plane of ISO-10646. For more detailed information, see Unicode Standard, Version 2.0, published by Addison-Wesley; ISBN&nbsp;0-201-48345-9.<INDEXTARGET ID="TIP_6.intl143"><!-- POSTPROCESSDATA: TIP_6.intl143|internationalization:encodings:ISO 10646internationalization:encodings:Unicodeinternationalization:Unicode --></PARAGRAPH>
</SECTION2>
</SECTION1>
</CHAPTER>
