<!-- Produced by version 4.3 (11/99) of SGI Frame/SGIDOCBK SGML translator -->
<CHAPTER ID="LE73050-PARENT"><TITLE ID="LE73050-TITLE">System Administration in a Multiuser Environment</TITLE><PARA>This chapter describes how to configure and maintain the system to support your users. It includes a discussion of administering user accounts, configuring user environments, and enabling communication between users.</PARA>
<SECTION  ID="LE15895-PARENT"><TITLE  ID="LE15895-TITLE">User Account Administration</TITLE><PARA>Creating and deleting user accounts are two of the most common system administration tasks. It is recommended that you read and understand this section before you set up or change user accounts. The graphical System Manager tool (available on graphics workstations only) is the most convenient tool for these tasks. The System Manager is described in the <CITETITLE><LINK BOOK="PerSysAdmin" EXTREF="96534">Personal System Administration Guide</LINK>
</CITETITLE>. The command-line method for performing these tasks is described here.</PARA>
<SECTION  ID="LE24351-PARENT"><TITLE  ID="LE24351-TITLE">User ID Numbers</TITLE><PARA><INDEXTERM ID="ITch05-0"><PRIMARY>user ID number</PRIMARY>
</INDEXTERM>
Each user account has a user ID number. These numbers are unique on each workstation and should be unique throughout your entire site. <INDEXTERM ID="ITch05-1"><PRIMARY>user ID number</PRIMARY>
<SECONDARY><FILENAME>/etc/passwd</FILENAME>
</SECONDARY>
</INDEXTERM>
A user ID number for an account is kept in the third field of the <FILENAME>/etc/passwd</FILENAME> file.</PARA>
<PARA>After you close a user account, do not reuse that account's user ID number. It is possible that files somewhere on a system could still be owned by the ID number, or files may be placed on the system from an old backup tape. These files would be compromised by associating a new user with an old ID number. In general, the rule is that the ID number is the permanent property of the user to whom it is assigned. For more information on user ID numbers, see the <COMMAND>passwd(4)</COMMAND> man page.</PARA>
</SECTION>
<SECTION><TITLE>Group ID Numbers</TITLE><PARA><INDEXTERM ID="ITch05-2"><PRIMARY>group ID number</PRIMARY>
</INDEXTERM>
Each user account belongs to a group of users on the system. Users with similar interests or jobs can belong to the same group. For example, members of the publications department might belong to group <LITERAL>pub</LITERAL>. The benefit to this arrangement is that it allows groups of related users to share files and resources without sharing those files or resources with the entire system community.</PARA>
<PARA>Each group has a group ID number. These numbers are unique on each system and should be unique throughout the entire site. As with user IDs, you should not reuse group IDs.</PARA>
<PARA>When you create a file, it is assigned your group ID. You can change the group ID of a file with the <COMMAND>chgrp(1)</COMMAND> command. By manipulating the permissions field of the file, the owner (or someone with the effective user ID of the owner) can grant read, write, or execute privileges to other group members.</PARA>
<PARA>Information about groups is kept in the <FILENAME>/etc/group</FILENAME> file. <INDEXTERM ID="ITch05-3"><PRIMARY>group ID number</PRIMARY>
<SECONDARY><FILENAME>/etc/group</FILENAME>
</SECONDARY>
</INDEXTERM>
A sample entry from this file is shown and explained below:</PARA>
<LITERALLAYOUT>
raccoons::101:norton,ralph
</LITERALLAYOUT>
<PARA>Each entry is one line; each line has the following fields:</PARA>
<DEFLIST><DEFLISTENTRY><TERM>group name </TERM>
<LISTITEM><PARA>The group name can be any length, though some commands truncate the name to eight characters. The first character must be alphabetic.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM>password </TERM>
<LISTITEM><PARA>The password field may contain an encrypted password. An empty field, as in the above example, indicates that no password is required. The <COMMAND>passwd(1M)</COMMAND> command cannot be used to create or modify a group password. To place a password on a group, you must use the <COMMAND>passwd</COMMAND> command to encrypt a password. Use a test user account created specifically for this purpose and then delete the test account. Then, copy that encrypted password verbatim from the <FILENAME>/etc/passwd</FILENAME> file into the <FILENAME>/etc/group</FILENAME> entry you want to protect with the password. Users specifically listed as group members in the <FILENAME>/etc/group</FILENAME> file entry are not required to give the password, but other users are so required when they attempt to change groups to the protected group with the <COMMAND>newgrp</COMMAND> command. Password protection, though, is rarely used on user groups.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM>group ID </TERM>
<LISTITEM><PARA>The group ID is a number from 0 to 60,000. The number must not include a comma. Numbers below 100 are reserved for system accounts.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM>login names </TERM>
<LISTITEM><PARA>The login names of group members are in a comma-separated list.</PARA>
</LISTITEM>
</DEFLISTENTRY>
</DEFLIST>
<PARA>For complete information on user groups, see the <COMMAND>group(4)</COMMAND> man page.</PARA>
</SECTION>
<SECTION><TITLE>Adding User Accounts Using Shell Commands </TITLE><PARA><INDEXTERM ID="ITch05-4"><PRIMARY>adding</PRIMARY>
<SECONDARY>new users</SECONDARY>
</INDEXTERM>
Occasionally, you may have to add a user account manually; in other words, without using the automated tools such as the System Manager. All administrators should understand the process in case a problem develops with some part of the automated tools or if you want to design your own scripts and programs for administering user accounts at your site. Be sure to check your work with the <COMMAND>pwck</COMMAND> command. </PARA>
<PARA><XREF LINKEND="LE32120-TITLE"> describes how you manually add user accounts.</PARA><PROCEDURE  ID="LE32120-PARENT"><TITLE  ID="LE32120-TITLE">Adding User Accounts</TITLE>
<STEP><PARA>Edit the <FILENAME>/etc/passwd</FILENAME> file.</PARA>
</STEP>
<STEP><PARA>Edit the <FILENAME>/etc/group</FILENAME> file.</PARA>
</STEP>
<STEP><PARA>Create the user's home directory and startup files.</PARA>
</STEP>
<STEP><PARA>Verify the new account.</PARA>
</STEP>
</PROCEDURE>
<PARA>These steps are described in the following four sections.</PARA>
<SECTION><TITLE>Editing the /etc/passwd File to Add a User Account</TITLE><PARA><XREF LINKEND="LE36189-TITLE"> describes how to edit the <FILENAME>/etc/passwd</FILENAME> file:</PARA>
<PROCEDURE  ID="LE36189-PARENT"><TITLE  ID="LE36189-TITLE">Editing the /etc/passwd File</TITLE>
<STEP><PARA>Log in as <LITERAL>root</LITERAL>. </PARA>
</STEP>
<STEP><PARA>Edit the file <FILENAME>/etc/passwd</FILENAME> with your preferred text editor. </PARA>
<PARA><INDEXTERM ID="ITch05-5"><PRIMARY>password file</PRIMARY>
<SECONDARY>layout of</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-6"><PRIMARY><FILENAME>/etc/password</FILENAME>
</PRIMARY>
<SECONDARY><FILENAME>layout of</FILENAME>
</SECONDARY>
</INDEXTERM>
The file <FILENAME>/etc/passwd</FILENAME> has one line for each account on the system. Each line contains seven fields, and each field is separated by a colon. The lines look similar to this:</PARA>
<LITERALLAYOUT>
ralph:+:103:101:Ralph Cramden:/usr/people/ralph:/bin/csh
</LITERALLAYOUT>
</STEP>
<STEP><PARA>Copy one of the lines (for example, the last line in the file) and add it after the last account entry in the file.</PARA>
</STEP>
<STEP><PARA>Change the first field (<LITERAL>ralph</LITERAL> in this example) to the name of the new account; for example, <LITERAL>alice</LITERAL>.</PARA>
</STEP>
<STEP><PARA>Remove any characters between the first colon after the account name and the second colon. Deleting these characters removes the password from an account. Either you or the new user can add a password later.</PARA>
</STEP>
<STEP><PARA>The next field (in this case &ldquo;103&rdquo;) is the user ID of the new account. Change it to a number 1 greater than the current highest user ID on your system. You should not use user ID numbers between 0 and 100, as these are reserved for system use. </PARA>
</STEP>
<STEP><PARA>The next field (in this case &ldquo;101&rdquo;) is the group ID number of the new account. Check the file <FILENAME>/etc/group</FILENAME> and pick a suitable group ID for the new user account. The <FILENAME>/etc/group</FILENAME> file lists all the groups on the system by group ID, followed by a list of the current users who belong to that group.</PARA>
</STEP>
<STEP><PARA>Change the next field (in this case <LITERAL>Ralph Cramden</LITERAL>) to the name of the new user, in this case <LITERAL>Alice Cramden</LITERAL>. If you want, you can add an office and phone number to this field. After the user's name, add a comma, then the office location, another comma, and the phone number. For example:</PARA>
<LITERALLAYOUT>
:Alice Cramden, Brooklyn, (212) 555-1212:
</LITERALLAYOUT>
<PARA>Actually, you can put any information you want in these fields. The fields are interpreted by the <COMMAND>finger(1)</COMMAND> program as &ldquo;user name, office, phone number.&rdquo;</PARA>
</STEP>
<STEP><PARA>The next field (in this case <FILENAME>/usr/people/ralph</FILENAME>) is the location of the user's home directory. Change this field to reflect the name of the new user's account. In this example, you would change <FILENAME>/usr/people/ralph</FILENAME> to <FILENAME>/usr/people/alice</FILENAME>. </PARA>
</STEP>
<STEP><PARA>The last field (in this example <FILENAME>/bin/csh</FILENAME>) is the user's login shell. For most users, the C shell (<FILENAME>/bin/csh</FILENAME>), Korn Shell (<FILENAME>/bin/sh</FILENAME>), or Bourne shell (<FILENAME>/bin/bsh</FILENAME>) is appropriate. Leave this field unchanged, unless you want to use a different or special shell. Special shells are discussed in <XREF LINKEND="LE64438-TITLE">.. Once you have selected a shell, you are finished editing <FILENAME>/etc/passwd</FILENAME>. </PARA>
</STEP>
<STEP><PARA>Write the changes you made and exit the file.</PARA>
</STEP>
</PROCEDURE>
</SECTION>
<SECTION><TITLE>Editing the /etc/group File to Add a User</TITLE><PARA><XREF LINKEND="LE18771-TITLE">, which is optional, adds the new user to the file <FILENAME>/etc/group</FILENAME>. However, users can be a member of a group without being listed in the <FILENAME>/etc/group</FILENAME> file. If you want to maintain a list of groups to which users belong, edit this file.</PARA>
<PROCEDURE  ID="LE18771-PARENT"><TITLE  ID="LE18771-TITLE">Editing the /etc/group File</TITLE>
<STEP><PARA>Open the <FILENAME>/etc/group</FILENAME> file with your preferred text editor. You should see some lines similar to this:<INDEXTERM ID="ITch05-7"><PRIMARY>group file</PRIMARY>
<SECONDARY>layout of</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-8"><PRIMARY><FILENAME>/etc/group</FILENAME>
</PRIMARY>
<SECONDARY><FILENAME>layout of</FILENAME>
</SECONDARY>
</INDEXTERM>
&ensp;</PARA>
<PROGRAMLISTING>
sys::0:root,bin,sys,adm
root::0:root
daemon::1:root,daemon
bin::2:root,bin,daemon
adm::3:root,adm,daemon
mail::4:root
uucp::5:uucp
rje::8:rje,shqer
lp:*:9:
nuucp::10:nuucp
bowling:*:101:ralph
other:*:102:
</PROGRAMLISTING>
</STEP>
<STEP><PARA>Place the name of the new account (in this example <LITERAL>alice</LITERAL>) after any of the groups. Separate the account name from any other account names with a comma, but not with blank spaces. For example:</PARA>
<LITERALLAYOUT>
bowling:*:101:ralph,alice
</LITERALLAYOUT>
<PARA>Although adding account names to the <FILENAME>/etc/group</FILENAME> file is optional, it is a good way to keep track of who belongs to the various system groups.</PARA>
<PARA>Also, you can assign an account to more than one group by placing the account name after the names of the various groups in <FILENAME>/etc/group</FILENAME>. The user can change group affiliations with the <COMMAND>newgrp</COMMAND> and <COMMAND>multgrps</COMMAND> commands.</PARA>
</STEP>
<STEP><PARA>Write your changes and exit the file.</PARA>
</STEP>
</PROCEDURE>
</SECTION>
<SECTION><TITLE>Setting Up a Home Directory for a New User</TITLE><PARA>To create the new user's home directory and copy shell startup files over to that directory, follow the steps in <XREF LINKEND="LE26360-TITLE">:</PARA><PROCEDURE  ID="LE26360-PARENT"><TITLE  ID="LE26360-TITLE">Setting Up a Home Directory</TITLE>
<STEP><PARA>Use the <COMMAND>mkdir(1)</COMMAND> command to create the user's home directory. For example, to create a home directory for the user <LITERAL>alice</LITERAL>:</PARA>
<LITERALLAYOUT>
<USERINPUT>mkdir /usr/people/alice</USERINPUT>
</LITERALLAYOUT>
<PARA>Make the directory owned by user <LITERAL>alice</LITERAL>, who is in group <LITERAL>bowling</LITERAL>:</PARA>
<LITERALLAYOUT>
<USERINPUT>chown alice /usr/people/alice</USERINPUT>
<USERINPUT>chgrp bowling /usr/people/alice</USERINPUT>
</LITERALLAYOUT>
<PARA>Make sure the new home directory has the appropriate access permissions for your site. For a site with relaxed security:</PARA>
<LITERALLAYOUT>
<USERINPUT>chmod 755 /usr/people/alice</USERINPUT>
</LITERALLAYOUT>
<PARA>For more information, see the man pages for <COMMAND>chown(1)</COMMAND>, <COMMAND>chgrp(1)</COMMAND>, and <COMMAND>chmod(1)</COMMAND>.</PARA>
</STEP>
<STEP><PARA>Copy the shell startup files to the new user's home directory.</PARA>
<PARA>If the new account uses the C shell:</PARA>
<LITERALLAYOUT>
<USERINPUT>cp /etc/stdcshrc /usr/people/alice/.cshrc</USERINPUT>
<USERINPUT>cp /etc/stdlogin /usr/people/alice/.login</USERINPUT>
</LITERALLAYOUT>
<PARA>If the new account uses the Korn or Bourne shell:</PARA>
<LITERALLAYOUT>
<USERINPUT>cp /etc/stdprofile /usr/people/alice/.profile</USERINPUT>
</LITERALLAYOUT>
</STEP>
<STEP><PARA>You can make these shell startup files owned by the user, or leave them owned by <LITERAL>root</LITERAL>. Neither approach affects how the user logs in to the system, although if the files are owned by <LITERAL>root</LITERAL>, the user is less likely to alter them accidentally and thereby be unable to log in.</PARA>
<PARA>To give a user complete access to his or her shell startup files, use the <COMMAND>chmod</COMMAND> command. For C shell:</PARA>
<LITERALLAYOUT>
<USERINPUT>chmod 755 /usr/people/alice/.cshrc /usr/people/alice/.login</USERINPUT>
</LITERALLAYOUT>
<PARA>For Korn or Bourne shell:</PARA>
<LITERALLAYOUT>
<USERINPUT>chmod 755 /usr/people/alice/.profile</USERINPUT>
</LITERALLAYOUT>
<PARA>Remember to check for any other user files that may be owned by <LITERAL>root</LITERAL> in the user's directory and change those too. </PARA>
</STEP>
<STEP><PARA>It is a good idea to immediately create a password for the new user. Enter the following command:</PARA>
<PROGRAMLISTING>
<USERINPUT>passwd alice</USERINPUT>
</PROGRAMLISTING>
<PARA>Then follow the prompts to create a password. Let the user know their assigned password and advise them to change it to a password of their own choosing. Refer to <CITETITLE><LINK BOOK="IA_BakSecAcc" EXTREF="70848">IRIX Admin: Backup, Security, and Accounting</LINK>
</CITETITLE> for advice to give users on choosing passwords.</PARA>
</STEP>
</PROCEDURE>
</SECTION>
<SECTION><TITLE>Verifying a New Account</TITLE><PARA>Issue the <COMMAND>pwck</COMMAND> command to check your work. This command performs a simple check of the <FILENAME>/etc/passwd</FILENAME> file and makes sure that no user ID numbers have been reused and that all fields have reasonable entries. If your work has been done correctly, you should see output similar to that in <XREF LINKEND="LE21959-TITLE">:</PARA><EXAMPLE  ID="LE21959-PARENT"><TITLE  ID="LE21959-TITLE">pwck Output</TITLE><PROGRAMLISTING>
sysadm:*:0:0:System V Administration:/usr/admin:/bin/sh
&ensp;       Login directory not found
auditor::11:0:Audit Activity Owner:/auditor:/bin/sh
&ensp;       Login directory not found
dbadmin::12:0:Security Database Owner:/dbadmin:/bin/sh
&ensp;       Login directory not found
tour::995:997:IRIS Space Tour:/usr/people/tour:/bin/csh
&ensp;       Login directory not found
4Dgifts::999:998:4Dgifts Acct:/usr/people/4Dgifts:/bin/csh
&ensp;       First char in logname not lower case alpha
&ensp;       1 Bad character(s) in logname
&ensp;       Login directory not found
nobody:*:-2:-2::/dev/null:/dev/null
&ensp;       Invalid UID
&ensp;       Invalid GID
</PROGRAMLISTING>
</EXAMPLE>
<PARA>These messages are normal and expected from <COMMAND>pwck</COMMAND>. All errors generated by <COMMAND>pwck</COMMAND> are described in detail in the <COMMAND>pwck(1M)</COMMAND> man page.</PARA>
</SECTION>
</SECTION>
<SECTION  ID="LE52493-PARENT"><TITLE  ID="LE52493-TITLE">Adding User Groups Using Shell Commands</TITLE><PARA><INDEXTERM ID="ITch05-9"><PRIMARY>adding</PRIMARY>
<SECONDARY>a group</SECONDARY>
</INDEXTERM>
Follow the steps in <XREF LINKEND="LE23214-TITLE"> to add a group to the system manually:</PARA><PROCEDURE  ID="LE23214-PARENT"><TITLE  ID="LE23214-TITLE">Adding a Group to the System</TITLE>
<STEP><PARA>Log in as <LITERAL>root</LITERAL>.</PARA>
</STEP>
<STEP><PARA>Edit the file <FILENAME>/etc/group</FILENAME>. The file contains a list of groups on the system, one group per line. Each line contains the name of the group, an optional password, the group ID number, and the user accounts that belong to that group.</PARA>
<PARA>For example, to create a group called <LITERAL>raccoons</LITERAL>, with a group ID of 103, place this line at the end of the file:</PARA>
<LITERALLAYOUT>
<USERINPUT>raccoons:*:103:</USERINPUT>
</LITERALLAYOUT>
</STEP>
<STEP><PARA>If there are users who should belong to the group, add their names in the last field. Each name should be separated by a comma, for example:</PARA>
<LITERALLAYOUT>
<USERINPUT>raccoons:*:103:ralph,norton</USERINPUT>
</LITERALLAYOUT>
</STEP>
<STEP><PARA>Write and exit the file. Make sure the group IDs in the file <FILENAME>/etc/passwd</FILENAME> file match those in the <FILENAME>/etc/group</FILENAME> file. </PARA>
</STEP>
</PROCEDURE>
<PARA>For more information on user groups, see the <COMMAND>group(4)</COMMAND> man page.</PARA>
</SECTION>
<SECTION><TITLE>Changing a User's Group</TITLE><PARA>To change a user's group affiliation, perform the steps in <XREF LINKEND="LE18012-TITLE">:</PARA><PROCEDURE  ID="LE18012-PARENT"><TITLE  ID="LE18012-TITLE">Changing a User's Group</TITLE>
<STEP><PARA>Log in as<LITERAL>&ensp;root</LITERAL>.</PARA>
</STEP>
<STEP><PARA>Edit the file <FILENAME>/etc/group</FILENAME>. Place the user's account name on the line corresponding to the desired group. If the account name appears as a member of another group, remove that reference unless you want the account to be a member of both groups. </PARA>
</STEP>
<STEP><PARA>Write and exit the file <FILENAME>/etc/group</FILENAME>.</PARA>
</STEP>
<STEP><PARA>Edit the file <FILENAME>/etc/passwd</FILENAME>.</PARA>
</STEP>
<STEP><PARA>Find the user's entry in the file.</PARA>
</STEP>
<STEP><PARA>Change the old group ID on that line to the new group ID. The group ID is the fourth field (after the account name, password, and user ID).</PARA>
</STEP>
<STEP><PARA>Write and exit the file.</PARA>
</STEP>
</PROCEDURE>
<PARA>The user's group affiliation is now changed. Remind the user to change the group ownership on his or her files. If you prefer, you can perform this task yourself as <LITERAL>root</LITERAL> using the <COMMAND>find</COMMAND> and <COMMAND>chgrp</COMMAND> commands. See <XREF LINKEND="LE37780-TITLE"> for more information.</PARA></SECTION>
<SECTION  ID="LE92874-PARENT"><TITLE  ID="LE92874-TITLE">Deleting a User from the System</TITLE><PARA><INDEXTERM ID="ITch05-10"><PRIMARY>deleting a user</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-11"><PRIMARY>sysadm</PRIMARY>
<SECONDARY><COMMAND>deluser</COMMAND>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-12"><PRIMARY>user accounts</PRIMARY>
<SECONDARY>deleting</SECONDARY>
</INDEXTERM>
This procedure deletes the user's home directory and all the files in and below that directory. If you want only to close or disable a user account but preserve the user's files and other information, see <XREF LINKEND="LE96751-TITLE">..</PARA><PARA>To delete a user's account completely, follow the steps in <XREF LINKEND="LE35746-TITLE">:</PARA><PROCEDURE  ID="LE35746-PARENT"><TITLE  ID="LE35746-TITLE">Deleting a User's Account</TITLE>
<STEP><PARA>Log in as <LITERAL>root</LITERAL>. </PARA>
</STEP>
<STEP><PARA>If you think you might need a copy of the user's files later on, make a backup copy of the directory, for example, on cartridge tape using <COMMAND>tar(1)</COMMAND> or <COMMAND>cpio(1)</COMMAND>.</PARA>
</STEP>
<STEP><PARA>Edit the <FILENAME>/etc/passwd</FILENAME> file and replace the encrypted password (or &ldquo;+&rdquo; sign if you are using shadow passwords) with the following string:</PARA>
<LITERALLAYOUT>
<USERINPUT>*ACCOUNT CLOSED*</USERINPUT>
</LITERALLAYOUT>
<PARA>It is imperative that the asterisks shown in this example be used as shown. An asterisk in the encrypted password field disallows all logins on that account. Alternately, you can lock an account by using fewer than 13 characters in the password field, but it is better to use the asterisks and an identifiable lock message.</PARA>
</STEP>
<STEP><PARA>Use <COMMAND>find(1)</COMMAND> to locate all files on the system that are owned by the user and remove them or change their ownership. Information on the use of <COMMAND>find</COMMAND> is provided in <XREF LINKEND="LE37780-TITLE">, and in the <COMMAND>find(1)</COMMAND> man page.</PARA>
</STEP>
</PROCEDURE>
</SECTION>
<SECTION><TITLE>Deleting a Group from the System</TITLE><PARA>To delete a group from the system, follow the steps in <XREF LINKEND="LE17477-TITLE">:</PARA><PROCEDURE  ID="LE17477-PARENT"><TITLE  ID="LE17477-TITLE">Deleting a Group from a System</TITLE>
<STEP><PARA>Edit the <FILENAME>/etc/group</FILENAME> file and change the desired entry to a new but unused name. For example, you might change the group <LITERAL>bigproject</LITERAL> to <LITERAL>bigproject.closed</LITERAL>.</PARA>
</STEP>
<STEP><PARA>Edit the <FILENAME>/etc/passwd</FILENAME> file and remove the group from the user entries wherever it exists.</PARA>
</STEP>
<STEP><PARA>Use <COMMAND>find</COMMAND> to find all files and directories with the old group affiliation and change the affiliation to a group that is still in use with the <COMMAND>chgrp</COMMAND> command.</PARA>
</STEP>
</PROCEDURE>
</SECTION>
<SECTION  ID="LE96751-PARENT"><TITLE  ID="LE96751-TITLE">Locking a User Account</TITLE><PARA><INDEXTERM ID="ITch05-13"><PRIMARY>user accounts</PRIMARY>
<SECONDARY>closing</SECONDARY>
</INDEXTERM>
To close an account so that nobody can log in to it or use the <COMMAND>su</COMMAND> command to become that user's ID number, follow the steps in <XREF LINKEND="LE39181-TITLE">:</PARA><PROCEDURE  ID="LE39181-PARENT"><TITLE  ID="LE39181-TITLE">Locking a User's Account</TITLE>
<STEP><PARA>Log in as <LITERAL>root</LITERAL>.</PARA>
</STEP>
<STEP><PARA>Edit the file <FILENAME>/etc/passwd</FILENAME>. Find the user's account entry. </PARA>
</STEP>
<STEP><PARA>Make the entry a comment by placing a number sign at the beginning of the line. For example:</PARA>
<LITERALLAYOUT>
# ralph:+:103:101:Ralph Cramden:/usr/people/ralph:/bin/csh
</LITERALLAYOUT>
</STEP>
<STEP><PARA>As an added measure of security, you can replace the encrypted password (the second field in the entry) with a string that cannot be interpreted as a valid password. For example:</PARA>
<LITERALLAYOUT>
# ralph:*:103:101:Ralph Cramden:/usr/people/ralph:/bin/csh
</LITERALLAYOUT>
<PARA>Using the asterisk has the added benefit of reminding you that you deliberately closed the account.</PARA>
</STEP>
<STEP><PARA>If necessary, you can also close off the user's home directory with the following commands:</PARA>
<LITERALLAYOUT>
<USERINPUT>chown root /usr/people/ralph</USERINPUT>
<USERINPUT>chgrp bin /usr/people/ralph</USERINPUT>
<USERINPUT>chmod 700 /usr/people/ralph</USERINPUT>
</LITERALLAYOUT>
</STEP>
</PROCEDURE>
<PARA>The user's account is now locked, and only <LITERAL>root</LITERAL> has access to the user's home account. If you expect that the user will again require access to the system in the near future, close an account in the manner described below rather than removing it from the system completely (as described in <XREF LINKEND="LE92874-TITLE">,).</PARA></SECTION>
<SECTION><TITLE>About Changing User Groups with newgrp and multgrps</TITLE><PARA><INDEXTERM ID="ITch05-14"><PRIMARY>groups</PRIMARY>
<SECONDARY>temporarily changing</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-15"><PRIMARY>changing</PRIMARY>
<SECONDARY>groups temporarily</SECONDARY>
</INDEXTERM>
Normally users are members of only one group at a time. However, users can change groups using the <COMMAND>newgrp</COMMAND> command. Changing groups is sometimes useful for performing administrative tasks.</PARA>
<PARA><INDEXTERM ID="ITch05-16"><PRIMARY>super user</PRIMARY>
<SECONDARY>groups</SECONDARY>
</INDEXTERM>
The superuser can belong to any group listed in the <FILENAME>/etc/groups</FILENAME> file. Other users must be listed as members of a group in order to temporarily change groups with <COMMAND>newgrp</COMMAND>. Refer to the <COMMAND>newgrp(1)</COMMAND> man page for more information.</PARA>
<PARA>You can belong to multiple groups simultaneously by invoking the <COMMAND><INDEXTERM ID="ITch05-17"><PRIMARY>multgrps command</PRIMARY>
</INDEXTERM>
multgrps</COMMAND> command. In this case, files you create have their group IDs set to the group you were in before you issued the <COMMAND>multgrps</COMMAND> command. You have group access permissions to any file whose group ID matches any of the groups you are in. Refer to the <COMMAND>multgrps(1)</COMMAND> man page for more information.</PARA>
<PARA>You can change groups only to a group you are affiliated with in the <FILENAME>/etc/groups</FILENAME> file. To determine which groups you belong to, use the <INDEXTERM ID="ITch05-18"><PRIMARY>groups</PRIMARY>
<SECONDARY>determining membership</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-19"><PRIMARY><COMMAND>id</COMMAND>
 command</PRIMARY>
</INDEXTERM>
<COMMAND>id(1)</COMMAND> command.</PARA>
</SECTION>
<SECTION  ID="LE14885-PARENT"><TITLE  ID="LE14885-TITLE">Changing User Information</TITLE><PARA>This section tells you how to change the values for an individual user's login information. You cannot use these commands for a login you installed as an NIS-type entry. If the login account is an NIS type, you must change the master password file on the network server. See the <CITETITLE><LINK BOOK="NIS_AG" EXTREF="59080">NIS Administrator's Guide</LINK>
</CITETITLE> for more information about NIS.</PARA>
<PARA><INDEXTERM ID="ITch05-20"><PRIMARY>changing</PRIMARY>
<SECONDARY>user information</SECONDARY>
</INDEXTERM>
This section covers the following procedures:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA><XREF LINKEND="LE58101-TITLE"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE88361-TITLE"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE52363-TITLE"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE35230-TITLE"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE49835-TITLE"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE50387-TITLE"></PARA></LISTITEM>
<LISTITEM><PARA><XREF LINKEND="LE36368-TITLE"></PARA></LISTITEM>
</ITEMIZEDLIST>
<SECTION  ID="LE58101-PARENT"><TITLE  ID="LE58101-TITLE">Changing a User's Login Name</TITLE><PARA>To change a user's login name, perform the steps in <XREF LINKEND="LE36341-TITLE">:</PARA><PROCEDURE  ID="LE36341-PARENT"><TITLE  ID="LE36341-TITLE">Changing a User's Login Name</TITLE>
<STEP><PARA>Edit the <FILENAME>/etc/passwd</FILENAME> file and change the entry for the user's login to reflect the new login name. For example, to change the login name <LITERAL>ralph</LITERAL> to <LITERAL>cramden</LITERAL>, find the line:</PARA>
<LITERALLAYOUT>
ralph:x:103:101:Ralph Cramden:/usr/people/ralph:/bin/csh
</LITERALLAYOUT>
<PARA>Change the name field and the default directory field as follows:</PARA>
<LITERALLAYOUT>
<USERINPUT>cramden</USERINPUT><LITERAL>:x:103:101:Ralph Cramden:/usr/people/</LITERAL><USERINPUT>cramden</USERINPUT><LITERAL>:/bin/csh</LITERAL>
</LITERALLAYOUT>
<PARA>For consistency's sake, the home directory should always have the same name as the user account. If your system has shadow passwords enabled, you see the letter <LITERAL>x</LITERAL> in place of the encoded password in the user's entry. For more information on shadow passwords, see the <CITETITLE><LINK BOOK="IA_BakSecAcc" EXTREF="70848">IRIX Admin: Backup, Security, and Accounting</LINK>
</CITETITLE> guide. </PARA>
<PARA>When you save and exit the file, you may see an error message that the file is read-only or that write permission is denied. This is a protection that IRIX puts on the <FILENAME>/etc/passwd</FILENAME> file. Use the command:</PARA>
<LITERALLAYOUT>
<USERINPUT>:w!</USERINPUT>
</LITERALLAYOUT>
<PARA>in the <COMMAND>vi</COMMAND> editor to override this protection. If you are using <COMMAND>jot</COMMAND>, the file can be saved with no difficulty. For complete information, see the <COMMAND>vi(1)</COMMAND> man page or the appropriate man page for the editor that you use.</PARA>
</STEP>
<STEP><PARA>If your system has shadow passwords enabled, edit the <FILENAME>/etc/shadow</FILENAME> file next. Look for the line that begins with the user name you want to change. In this example, the line looks like this:</PARA>
<LITERALLAYOUT>
ralph:XmlGDVKQYet5c:::::::
</LITERALLAYOUT>
<PARA>Change the name in the entry to &ldquo;cramden&rdquo; as follows:</PARA>
<LITERALLAYOUT>
<USERINPUT>cramden</USERINPUT>:XmlGDVKQYet5c:::::::
</LITERALLAYOUT>
<PARA>When you have made the change, save and exit the file. As with <FILENAME>/etc/passwd</FILENAME>, if you are using <COMMAND>vi(1)</COMMAND>, you may encounter an error message.</PARA>
</STEP>
<STEP><PARA>Go to the directory that contains the user's home directory and change the name of the home directory to match the user's new login name. Use the command:</PARA>
<LITERALLAYOUT>
<USERINPUT>mv ralph cramden</USERINPUT>
</LITERALLAYOUT>
</STEP>
<STEP><PARA>Since IRIX identifies the files owned by the user by the user ID number rather than by the login name, there should be no need to change the ownership.</PARA>
</STEP>
</PROCEDURE>
</SECTION>
<SECTION  ID="LE88361-PARENT"><TITLE  ID="LE88361-TITLE">Changing a User's Password with the passwd Command<INDEXTERM ID="ITch05-21"><PRIMARY>sysadm</PRIMARY>
<SECONDARY><COMMAND>chgloginid</COMMAND>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-22"><PRIMARY>sysadm</PRIMARY>
<SECONDARY><COMMAND>chgpasswd</COMMAND>
</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-23"><PRIMARY>sysadm</PRIMARY>
<SECONDARY>Command&gt;chgshell</SECONDARY>
</INDEXTERM>
</TITLE><PARA><INDEXTERM ID="ITch05-24"><PRIMARY>changing</PRIMARY>
<SECONDARY>passwords</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-25"><PRIMARY>user accounts</PRIMARY>
<SECONDARY>changing passwords</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-26"><PRIMARY>passwords</PRIMARY>
<SECONDARY>changing</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-27"><PRIMARY>passwords</PRIMARY>
<SECONDARY>forgotten</SECONDARY>
</INDEXTERM>
Occasionally, a user forgets his or her password. To solve the problem, assign that user a temporary password, then have the user change the temporary password to something else.</PARA>
<PARA>To assign a new password, perform the steps in <XREF LINKEND="LE37915-TITLE">:</PARA><PROCEDURE  ID="LE37915-PARENT"><TITLE  ID="LE37915-TITLE">Assigning a New Password</TITLE>
<STEP><PARA>Log in as <LITERAL>root</LITERAL>.</PARA>
</STEP>
<STEP><PARA>Use the <COMMAND>passwd</COMMAND> command to change the password for the user's account.</PARA>
<PARA>For example, if the user ralph forgets his password, enter:</PARA>
<LITERALLAYOUT>
<USERINPUT>passwd ralph</USERINPUT>
</LITERALLAYOUT>
</STEP>
<STEP><PARA>Follow the screen prompts:</PARA>
<LITERALLAYOUT>
New password: <USERINPUT>2themoon</USERINPUT>
Re-enter new password: <USERINPUT>2themoon</USERINPUT>
</LITERALLAYOUT>
<NOTE><PARA>Although a password appears in the example for clarity, it is not actually displayed on the screen.</PARA>
</NOTE>
<PARA>Because you are logged in as the superuser (<LITERAL>root</LITERAL>), you are not prompted for an old password.</PARA>
</STEP>
</PROCEDURE>
<PARA>The user's password is now changed to <LITERAL>2themoon</LITERAL>. The user should immediately change the password to something else.</PARA>
</SECTION>
<SECTION  ID="LE52363-PARENT"><TITLE  ID="LE52363-TITLE">Changing a User's Login ID Number</TITLE><PARA>It is not recommended to change user login ID numbers. These numbers are crucial in maintaining ownership information and responsibility for files and processes. However, if for some reason you must change a user's login ID number, perform the following steps in <XREF LINKEND="LE39557-TITLE">:</PARA><PROCEDURE  ID="LE39557-PARENT"><TITLE  ID="LE39557-TITLE">Changing a User's Login ID Number</TITLE>
<STEP><PARA>Make a complete backup tape of the user's home directory and any working directories the user may have on the system.</PARA>
</STEP>
<STEP><PARA>Lock the user's account by placing a number sign (#) at the beginning of the line, and an asterisk (*) in the password field of the <FILENAME>/etc/passwd</FILENAME> file. Do not delete the entry, as you want to keep it as a record that the old user ID number was used and should not be reused. When you are finished, the entry should look like this:</PARA>
<LITERALLAYOUT>
<USERINPUT>#</USERINPUT><LITERAL>&ensp;ralph:</LITERAL><USERINPUT>*</USERINPUT><LITERAL>:103:101:Ralph Cramden:/usr/people/ralph:/bin/csh</LITERAL>
</LITERALLAYOUT>
</STEP>
<STEP><PARA>Completely remove the user's home directory, all subdirectories, and any working directories the user may have.</PARA>
</STEP>
<STEP><PARA>Use the following command from your system's <LITERAL>root</LITERAL> directory to find any other files the user may own on the system and display the filenames on the console:</PARA>
<LITERALLAYOUT>
<USERINPUT>find / -user </USERINPUT><REPLACEABLE>name</REPLACEABLE><USERINPUT>&ensp;-print</USERINPUT>
</LITERALLAYOUT>
<PARA>Archive and remove any files that are found.</PARA>
</STEP>
<STEP><PARA>Create a new user account using the instructions provided in this chapter. It may have the same name as the old account, but it is better to change names at the same time, to avoid confusion. Use the new user ID number.</PARA>
</STEP>
<STEP><PARA>Restore the home directory, working directories, and any other files you located from the backup you made. If necessary, use the <COMMAND>chown</COMMAND> and <COMMAND>chgrp</COMMAND> commands to set the new user ID correctly.</PARA>
</STEP>
</PROCEDURE>
</SECTION>
<SECTION  ID="LE35230-PARENT"><TITLE  ID="LE35230-TITLE">Changing a User's Default Group</TITLE><PARA>A user can be a member of many different groups on your system, but only one group is the default group. This is the group that the user begins with at login time. </PARA>
<PARA>To change the default group at login time, simply edit the <FILENAME>/etc/passwd</FILENAME> file at the appropriate line. For example:</PARA>
<LITERALLAYOUT>
cramden:+:103:101:Ralph Cramden:/usr/people/cramden:/bin/csh
</LITERALLAYOUT>
<PARA>To change the default group from 101 to 105, simply change the field in the passwd file entry as follows:</PARA>
<LITERALLAYOUT>
cramden:+:103:<USERINPUT>105</USERINPUT>:Ralph Cramden:/usr/people/cramden:/bin/csh
</LITERALLAYOUT>
<PARA>Be certain before you make any change, however, that group 105 is a valid group in your <FILENAME>/etc/groups</FILENAME> file and that the user is a member of the group. For more information on creating groups, see <XREF LINKEND="LE52493-TITLE">..</PARA></SECTION>
<SECTION  ID="LE49835-PARENT"><TITLE  ID="LE49835-TITLE">Changing a User's Comments Field</TITLE><PARA>The fifth field in each entry in <FILENAME>/etc/passwd</FILENAME> is for comments about the user account. This field typically contains the user's name and possibly his or her telephone number or desk location.</PARA>
<PARA>To change this information, simply edit the <FILENAME>/etc/passwd</FILENAME> file and change the information. (Note only that you cannot use a colon (:) within the comments, since IRIX interprets these as ending the comments field.) For example, consider this entry:</PARA>
<LITERALLAYOUT>
cramden:x:103:101:Ralph Crumdin:/usr/people/cramden:/bin/csh
</LITERALLAYOUT>
<PARA>When Ralph requests to have the misspelling of his name corrected, change the line to read:</PARA>
<LITERALLAYOUT>
cramden:x:103:101:Ralph Cramden:/usr/people/cramden:/bin/csh
</LITERALLAYOUT>
</SECTION>
<SECTION  ID="LE50387-PARENT"><TITLE  ID="LE50387-TITLE">Changing a User's Default Home Directory</TITLE><PARA>The sixth field in an <FILENAME>/etc/passwd</FILENAME> entry specifies the user's home directory. This is the directory that the user is placed in at login time, and the directory that is entered in the shell variable <LITERAL>$HOME</LITERAL>. The procedure for changing the home directory of a user is quite simple. Follow the steps in <XREF LINKEND="LE24469-TITLE">:</PARA><PROCEDURE  ID="LE24469-PARENT"><TITLE  ID="LE24469-TITLE">Changing a User's Default Home Directory</TITLE>
<STEP><PARA>Log in as <LITERAL>root</LITERAL>.</PARA>
</STEP>
<STEP><PARA>Edit the <FILENAME>/etc/passwd</FILENAME> file and look for the user entry you want to change. For example:</PARA>
<LITERALLAYOUT>
cramden:x:103:101:Ralph Cramden:/usr/people/cramden:/bin/csh
</LITERALLAYOUT>
<PARA>In this example, the home directory is <FILENAME>/usr/people/cramden</FILENAME>. To change the home directory to a recently added filesystem called <FILENAME>disk2</FILENAME>, change the entry to read:</PARA>
<LITERALLAYOUT>
cramden:x:103:101:Ralph Cramden:<USERINPUT>/disk2/cramden</USERINPUT>:/bin/csh
</LITERALLAYOUT>
<PARA>When you have made your changes, write and exit the file.</PARA>
</STEP>
<STEP><PARA>Create the directory in the new filesystem and move all of the files and subdirectories to their new locations. When this is done, remove the old home directory and the process is finished.</PARA>
</STEP>
<STEP><PARA>Be sure that you notify your users well in advance if you plan to change their home directories. Most users have personal aliases and programs that may depend on the location of their home directories. As with all major changes to your system's layout, changing home directories should not be done for trivial reasons, as it seriously inconveniences users.</PARA>
</STEP>
</PROCEDURE>
<PARA>For complete information on shell variables, see the man pages for the shell you are using (typically <COMMAND>csh</COMMAND>, <COMMAND>bsh</COMMAND>, <COMMAND>tcsh</COMMAND>, or <COMMAND>ksh</COMMAND>). Home directories are typically placed in <FILENAME>/usr/people</FILENAME>, but there is no reason why you cannot select another directory. Some administrators select a different directory to preserve filesystem space on the <FILENAME>/usr</FILENAME> filesystem, or simply because the users have a strong preference for another directory name.</PARA>
</SECTION>
<SECTION  ID="LE36368-PARENT"><TITLE  ID="LE36368-TITLE">Changing a User's Default Shell <INDEXTERM ID="ITch05-28"><PRIMARY>changing</PRIMARY>
<SECONDARY>default shell</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-29"><PRIMARY>default shell</PRIMARY>
<SECONDARY>changing</SECONDARY>
</INDEXTERM>
</TITLE><PARA>To change the default shell, follow the steps in <XREF LINKEND="LE27133-TITLE">:</PARA><PROCEDURE  ID="LE27133-PARENT"><TITLE  ID="LE27133-TITLE">Changing a User's Default Shell</TITLE>
<STEP><PARA>Log in as <LITERAL>root</LITERAL>.</PARA>
</STEP>
<STEP><PARA>Edit the <FILENAME>/etc/passwd</FILENAME> file to change the field that names the user's default shell. For example, in the <FILENAME>passwd</FILENAME> entry:</PARA>
<LITERALLAYOUT>
ralph:x:103:101:Ralph Cramden:/usr/people/ralph:/bin/csh
</LITERALLAYOUT>
<PARA>The default shell is <FILENAME>/bin/csh</FILENAME>. To change Ralph's shell to <FILENAME>/bin/ksh</FILENAME>, edit the line to look like this:</PARA>
<LITERALLAYOUT>
ralph:x:103:101:Ralph Cramden:/usr/bin/ralph:/bin/ksh
</LITERALLAYOUT>
</STEP>
<STEP><PARA>Save and exit the <FILENAME>/etc/passwd</FILENAME> file. When the user next logs in, the new default shell will be used.</PARA>
<PARA>Note that you can use any executable program as the default shell. IRIX simply executes the given program when a user logs in. Note also that using a program other than a command shell such as <COMMAND>csh</COMMAND> or <COMMAND>sh</COMMAND> can cause problems for the user. When the program identified as the default shell in the <FILENAME>passwd</FILENAME> file exits, the user is logged out. For example, if you use <FILENAME>/bin/mail</FILENAME> as the default shell, when the user exits <COMMAND>mail</COMMAND>, he or she is logged out and cannot perform any other work.</PARA>
</STEP>
</PROCEDURE>
</SECTION>
</SECTION>
</SECTION>
<SECTION><TITLE>About the User Environment</TITLE><PARA><INDEXTERM ID="ITch05-30"><PRIMARY>user accounts</PRIMARY>
<SECONDARY>user environment</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-31"><PRIMARY>user environment</PRIMARY>
<SECONDARY>description</SECONDARY>
</INDEXTERM>
A user's environment is determined by certain shell startup files. For C shell users, these are the files <FILENAME>/etc/cshrc</FILENAME> and, in their home directories, <FILENAME>.cshrc</FILENAME> and <FILENAME>.login</FILENAME>. For Korn and Bourne shell users, these are the <FILENAME>/etc/profile</FILENAME> file and the <FILENAME>.profile</FILENAME> file in their home directories.</PARA>
<PARA>Shell startup files configure a user's login environment and control aspects of subshells created during a login session.</PARA>
<SECTION><TITLE>About Login Shells</TITLE><PARA><INDEXTERM ID="ITch05-32"><PRIMARY>user accounts</PRIMARY>
<SECONDARY>login shells</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-33"><PRIMARY>user environment</PRIMARY>
<SECONDARY>login shells</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-34"><PRIMARY>login shells</PRIMARY>
</INDEXTERM>
The following login shells are provided with IRIX:</PARA>
<DEFLIST><DEFLISTENTRY><TERM><FILENAME>/bin/csh</FILENAME> </TERM>
<LISTITEM><PARA><INDEXTERM ID="ITch05-35"><PRIMARY><FILENAME>/bin/csh</FILENAME>
</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-36"><PRIMARY>C-shell</PRIMARY>
</INDEXTERM>
The C shell provides a history mechanism (that is, it remembers commands you enter); job control (you can stop processes, place them in background, and return them to foreground); and the ability to use wildcard characters to specify filenames. Users can construct sophisticated commands and scripts using a C programming language-like syntax. For a complete description of this shell, see the <COMMAND>csh(1)</COMMAND> man page.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM><FILENAME>/bin/sh</FILENAME>, <FILENAME>/bin/ksh</FILENAME> </TERM>
<LISTITEM><PARA>The former <FILENAME>/bin/sh</FILENAME> shell is now a symbolic link to the Korn shell, <FILENAME>/sbin/sh</FILENAME>. The Korn shell is an expansion of the best features of the Bourne shell and the C shell, and allows for command line editing, job control, programming from the shell prompt in the shell language, and other features. For a complete description of this shell, see the <COMMAND>sh(1)</COMMAND> man page. In particular, refer to the section &ldquo;Compatibility Issues&rdquo; for information on Bourne and Korn shell compatibility. Refer to the discussion on <FILENAME>/bin/bsh</FILENAME> below for information on the Bourne shell.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM><FILENAME>/bin/bsh</FILENAME> </TERM>
<LISTITEM><PARA><INDEXTERM ID="ITch05-37"><PRIMARY><FILENAME>/bin/sh</FILENAME>
</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-38"><PRIMARY>Bourne shell</PRIMARY>
</INDEXTERM>
The Bourne is a simpler shell than <COMMAND>csh</COMMAND>. The Bourne shell does not contain any kind of history mechanism and uses a different syntax from <COMMAND>csh</COMMAND>. It does make use of wildcard characters and is smaller and faster to invoke than <COMMAND>csh</COMMAND>. For a complete description of this shell, see the <COMMAND>bsh(1)</COMMAND> man page.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM><FILENAME>/bin/rsh</FILENAME> </TERM>
<LISTITEM><PARA><INDEXTERM ID="ITch05-39"><PRIMARY>restricted shell</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-40"><PRIMARY><FILENAME>/bin/rsh</FILENAME>
</PRIMARY>
</INDEXTERM>
This is a restricted shell, which limits the commands a user can type. The <COMMAND>rsh</COMMAND> command syntax is identical to <COMMAND>bsh</COMMAND>, except that users cannot:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA>Change directories.</PARA>
</LISTITEM>
<LISTITEM><PARA>Use the <COMMAND>ls(1)</COMMAND> command.</PARA>
</LISTITEM>
<LISTITEM><PARA>Set the shell search path (<LITERAL>$PATH</LITERAL>).</PARA>
</LISTITEM>
<LISTITEM><PARA>Specify path or command names containing / .</PARA>
</LISTITEM>
<LISTITEM><PARA>Redirect output (&gt; and &gt;&gt;).</PARA>
<PARA>The restrictions of <FILENAME>/bin/rsh</FILENAME> are enforced after <FILENAME>.profile</FILENAME> has been executed.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</LISTITEM>
</DEFLISTENTRY>
</DEFLIST>
<PARA>For complete information about these shells, see the <COMMAND>ksh(1)</COMMAND>, <COMMAND>csh(1)</COMMAND>, and <COMMAND>bsh(1)</COMMAND> man pages. The <COMMAND>rsh</COMMAND> restricted shell is described on the <COMMAND>ksh(1)</COMMAND> man page.</PARA>
<NOTE><PARA>Two shells called <COMMAND>rsh</COMMAND> are shipped with IRIX. <FILENAME>/usr/lib/rsh</FILENAME> is the restricted shell. The other shell, in <FILENAME>/usr/bsd/rsh</FILENAME>, is the Berkeley remote shell. Be careful not to confuse the two.</PARA>
</NOTE>
<PARA>The various startup files that configure these shells are described in the next sections.</PARA>
</SECTION>
<SECTION><TITLE>About C Shell Configuration Files</TITLE><PARA><INDEXTERM ID="ITch05-41"><PRIMARY>C-shell</PRIMARY>
<SECONDARY>startup files</SECONDARY>
</INDEXTERM>
When a C shell user logs in to the system, three startup files are executed in the following order:</PARA>
<ORDEREDLIST><LISTITEM><PARA>The <FILENAME>/etc/cshrc</FILENAME> file.</PARA>
<PARA>This is an ASCII text file that contains commands and shell procedures, and sets environment variables that are appropriate for all users on the system. This file is executed by the <COMMAND>login</COMMAND> process.</PARA>
<PARA>A sample <FILENAME>/etc/cshrc</FILENAME> is shown below:</PARA>
<PROGRAMLISTING>
# default settings for all users
# loaded &lt;&lt;before&gt;&gt; $HOME/.cshrc
umask 022
if ($?prompt) cat /etc/motd
set mail=$MAIL
if ( { /bin/mail -e } ) then
&ensp;echo 'You have mail.'
endif
</PROGRAMLISTING>
<PARA>In the example, several commands are executed:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA>The message of the day is displayed if a prompt exists.</PARA>
</LISTITEM>
<LISTITEM><PARA>The location of the user's mail file is set.</PARA>
</LISTITEM>
<LISTITEM><PARA>A message informs the user if he or she has mail.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</LISTITEM>
<LISTITEM><PARA>The individual user's <FILENAME>.cshrc</FILENAME>.</PARA>
<PARA>This file is similar to <FILENAME>/etc/cshrc</FILENAME> but is kept in the user's home directory. The <FILENAME>.cshrc</FILENAME> file can contain additional commands and variables that further customize a user's environment. For example, use this file to set the shell prompt for the user. The <FILENAME>.cshrc</FILENAME> file is executed whenever a user spawns a subshell. A sample <FILENAME>.cshrc</FILENAME> is shown below:</PARA>
<PROGRAMLISTING>
set prompt  = "Get back to work: "
set filec
set history = 20
</PROGRAMLISTING>
<PARA>In this example, the user's prompt is set, automatic filename completion is turned on, and the length of the history of recently issued commands is set to 20. </PARA>
</LISTITEM>
<LISTITEM><PARA>The <FILENAME>.login</FILENAME> file.</PARA>
<PARA>This is an executable command file that resides in the user's home directory. The <FILENAME>.login</FILENAME> also customizes the user's environment, but is only executed once, at login time. For this reason, use this file to set environment variables and to run shell script programs that need be done only once per login session. A sample <FILENAME>.login</FILENAME> is shown below:</PARA>
<PROGRAMLISTING>
eval `tset -s -Q`
umask 022
stty line 1 erase '^H' kill '^U' intr '^C' echoe
setenv DISPLAY wheeler:0 
setenv SHELL csh
setenv VISUAL /usr/bin/vi
setenv EDITOR /usr/bin/emacs
setenv ROOT /
set path = (. ~/bin /usr/bsd /bin /usr/bin /usr/sbin \ /usr/bin/X11 /usr/demos /usr/local/bin)
</PROGRAMLISTING>
<PARA>In this example, the user's terminal is further initialized with <COMMAND>tset</COMMAND>, then the file creation mask is set to 022. Some useful key bindings are set, using the command <COMMAND>stty</COMMAND>. The user's default display is set to be on the console screen of the system called wheeler. Several important environment variables are set for commonly used utilities and the filesystem point of reference. Finally, the default path is expanded to include the user's own binary directory and other system directories.</PARA>
</LISTITEM>
</ORDEREDLIST>
<PARA>For information on the shell programming commands used in these examples, see the <COMMAND>csh(1)</COMMAND> man page.</PARA>
</SECTION>
<SECTION><TITLE>Bourne and Korn Shell Configuration Files</TITLE><PARA><INDEXTERM ID="ITch05-42"><PRIMARY>Bourne shell</PRIMARY>
<SECONDARY>startup files</SECONDARY>
</INDEXTERM>
When a Bourne or Korn shell user logs in to the system, two startup files are executed in the following order:</PARA>
<ORDEREDLIST><LISTITEM><PARA>The <FILENAME>/etc/profile</FILENAME> file executes.</PARA>
<PARA>This is an ASCII text file that contains commands and shell procedures and sets environment variables that are appropriate for all users on the system. This file is executed by the <COMMAND>login</COMMAND> process.</PARA>
<PARA>A sample <FILENAME>/etc/profile</FILENAME> is shown below:</PARA>
<PROGRAMLISTING>
# Ignore keyboard interrupts.
trap "" 2 3
# Set the umask so that newly created files and directories will be 
# readable by others, but writable only by the user.
umask 022
case "$0" in
*su )
# Special processing for ``su -'' could go here.
;;
-* )
# This is a first time login.
#
# Allow the user to break the Message-Of-The-Day only.
trap "trap '' 2" 2
cat -s /etc/motd
trap "" 2
# Check for mail.
if /bin/mail -e
then
echo "you have mail"
fi
;;
esac
trap 2 3
</PROGRAMLISTING>
<PARA>In the example, several commands are executed:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA>Keyboard interrupts are trapped.</PARA>
</LISTITEM>
<LISTITEM><PARA>The user's <COMMAND>umask</COMMAND> is set to 022&mdash;full permission for the user, read and execute permission for members of the user's group and others on the system.</PARA>
</LISTITEM>
<LISTITEM><PARA>If the user is logging in for the first time, the message of the day (<FILENAME>/etc/motd</FILENAME>) is displayed, and the user is notified if he or she has mail.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</LISTITEM>
<LISTITEM><PARA>The individual user's <FILENAME>.profile</FILENAME> executes.</PARA>
<PARA>This file is similar to <FILENAME>/etc/profile</FILENAME>, but is kept in the user's home directory. The <FILENAME>.profile</FILENAME> file can contain additional commands and variables that further customize a user's environment. It is executed whenever a user spawns a subshell.</PARA>
<PARA>A sample <FILENAME>.profile</FILENAME> is shown below:</PARA>
<PROGRAMLISTING>
# Set the interrupt character to Ctrl+C and do clean backspacing. 
stty intr '' echoe 
# Set the TERM environment variable 
eval `tset -s -Q` 
# List files in columns if standard out is a terminal. 
ls() { if [ -t ]; then /bin/ls -C $*; else /bin/ls $*; fi } 
PATH=:/bin:/usr/bin:/usr/sbin:/usr/bsd:$HOME/bin:. 
EDITOR=/usr/bin/vi 
PS1="IRIX&gt; " 
export EDITOR PATH PS1 
</PROGRAMLISTING>
<PARA>In this example:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA>The interrupt character is set to <KEYCAP>Ctrl+C</KEYCAP>.</PARA>
</LISTITEM>
<LISTITEM><PARA>The <LITERAL>TERM</LITERAL> environment variable is set with <COMMAND>tset</COMMAND>.</PARA>
</LISTITEM>
<LISTITEM><PARA>A function called <COMMAND>ls</COMMAND> is defined so that when the user enters <COMMAND>ls</COMMAND> to list files in a directory, and the command is issued from a terminal or window, the <COMMAND>ls</COMMAND> command is invoked with the <LITERAL>-C</LITERAL> option.</PARA>
</LISTITEM>
<LISTITEM><PARA>The environment variables <LITERAL>PATH</LITERAL> and <LITERAL>EDITOR</LITERAL> are set.</PARA>
</LISTITEM>
<LISTITEM><PARA>The user's prompt (PS1) is set to <LITERAL>IRIX&gt;</LITERAL>.</PARA>
</LISTITEM>
</ITEMIZEDLIST>
</LISTITEM>
</ORDEREDLIST>
<PARA>For information on the shell programming commands used in these examples, see the <COMMAND>ksh(1)</COMMAND> and <COMMAND>bsh(1)</COMMAND> man pages.</PARA>
</SECTION>
<SECTION><TITLE>Configurable Shell Environment Variables</TITLE><PARA><INDEXTERM ID="ITch05-43"><PRIMARY>user environment</PRIMARY>
<SECONDARY>environment variables</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-44"><PRIMARY>environment variables</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-45"><PRIMARY>shell variables</PRIMARY>
</INDEXTERM>
Every shell uses a series of variables that hold information about the shell and about the login account from which it originated. These variables provide information to other processes as well as to the shell itself.</PARA>
<PARA>Collectively, these environment variables make up the shell's <FIRSTTERM>environment</FIRSTTERM>. The basic concepts of environment variables and an environment are the same for all types of IRIX shells, although the exact method of creating and manipulating the variables differs.</PARA>
<PARA>A basic set of environment variables includes where in the IRIX filesystem to search for commands (<LITERAL>PATH</LITERAL>), the location of the home directory of the user's account (<LITERAL>HOME</LITERAL>), the present working directory (<LITERAL>PWD</LITERAL>), the name of the <COMMAND>terminfo</COMMAND> description used to communicate with the user's display screen or terminal (<LITERAL>TERM</LITERAL>), and other variables.</PARA>
<PARA>When a process (shell) begins, the <COMMAND>exec</COMMAND> system call passes it an array of strings, called the <FIRSTTERM>environment</FIRSTTERM>. Other processes use this information. For example, user trixie's terminal is defined as an <LITERAL>iris-ansi</LITERAL> (<LITERAL>TERM=iris-ansi</LITERAL>). When the user invokes the default visual editor <COMMAND>vi</COMMAND>, <COMMAND>vi</COMMAND> checks this environment variable, then looks up the characteristics of an <COMMAND>iris-ansi</COMMAND> terminal.</PARA>
<SECTION><TITLE>Viewing the Shell Environment</TITLE><PARA>Because <COMMAND>login</COMMAND> is a process, the array of environment strings is made available to it. <INDEXTERM ID="ITch05-46"><PRIMARY>shell environment</PRIMARY>
<SECONDARY>examining</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-47"><PRIMARY>environment variables</PRIMARY>
<SECONDARY>examining</SECONDARY>
</INDEXTERM>
To look at your current shell environment, use the <COMMAND>printenv</COMMAND> command. <XREF LINKEND="LE21271-TITLE"> illustrates a typical C shell environment:</PARA><EXAMPLE  ID="LE21271-PARENT"><TITLE  ID="LE21271-TITLE">C Shell Environment</TITLE><PROGRAMLISTING>
LOGNAME=trixie
PWD=/usr/people/trixie
HOME=/usr/people/trixie
PATH=.:/usr/people/trixie/bin:/usr/bsd:/bin:/etc:/usr/sbin:
/usr/bin: /usr/local/bin:
SHELL=/bin/csh
MAIL=/var/mail/trixie
TERM=iris-ansi
PAGER=more
TZ=EST5EDT
EDITOR=emacs
DISPLAY=myhost:0
VISUAL=vi
</PROGRAMLISTING>
</EXAMPLE>
</SECTION>
<SECTION><TITLE>Default Environment Variables</TITLE><PARA><INDEXTERM ID="ITch05-48"><PRIMARY>environment variables</PRIMARY>
<SECONDARY>setting</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-49"><PRIMARY>shell variables</PRIMARY>
<SECONDARY>setting</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-50"><PRIMARY>setting environment variables</PRIMARY>
</INDEXTERM>
For C shell users, these variables are set in the <FILENAME>/etc/cshrc</FILENAME>, .<FILENAME>cshrc</FILENAME>, or <FILENAME>.login</FILENAME> startup file. For Korn and Bourne shell users, these variables are set in either the <FILENAME>/etc/profile</FILENAME> or <FILENAME>.profile</FILENAME> startup files.</PARA>
<PARA>The default environment variables that are assigned for C shell users, if no others are set in any of the startup files, are:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA><LITERAL>HOME</LITERAL></PARA>
</LISTITEM>
<LISTITEM><PARA><LITERAL>PATH</LITERAL></PARA>
</LISTITEM>
<LISTITEM><PARA><LITERAL>LOGNAME</LITERAL></PARA>
</LISTITEM>
<LISTITEM><PARA><LITERAL>SHELL</LITERAL></PARA>
</LISTITEM>
<LISTITEM><PARA><LITERAL>MAIL</LITERAL></PARA>
</LISTITEM>
<LISTITEM><PARA><LITERAL>TZ</LITERAL>&ensp;</PARA>
</LISTITEM>
<LISTITEM><PARA><LITERAL>USER</LITERAL></PARA>
</LISTITEM>
<LISTITEM><PARA><LITERAL>TERM</LITERAL></PARA>
</LISTITEM>
</ITEMIZEDLIST>
</SECTION>
<SECTION><TITLE>Defining New Environment Variables</TITLE><PARA>New variables can be defined and the values of existing variables can be changed at any time with the <COMMAND>setenv</COMMAND> command (C shell only). For example, to change the <LITERAL>PAGER</LITERAL> variable under C shell, enter:</PARA>
<LITERALLAYOUT>
<USERINPUT>setenv PAGER pg</USERINPUT>
</LITERALLAYOUT>
<PARA>This sets the value of the <LITERAL>PAGER</LITERAL> environment variable to the command <COMMAND>pg</COMMAND>. The <LITERAL>PAGER</LITERAL> variable is used by <COMMAND>mail</COMMAND>.</PARA>
<PARA>Bourne and Korn shell users set environment variables like this:</PARA>
<LITERALLAYOUT>
<USERINPUT>$ PAGER=pg ; export PAGER</USERINPUT>
</LITERALLAYOUT>
<PARA>Environment variables can be set on the command line, or in either of the shell startup files <FILENAME>/etc/profile</FILENAME> or <FILENAME>$HOME/.profile</FILENAME>.</PARA>
</SECTION>
</SECTION>
<SECTION><TITLE>Changing the Prompt in IRIX</TITLE><PARA>You may want to change the prompt that is displayed by the IRIX system. For example, you might want to embed the machine name and current working directory in a shell prompt. How you accomplish this depends on the login shell you are using.</PARA>
<PARA>Under the C shell and <FILENAME>tcsh</FILENAME>, enter the following series of commands to change the prompt to indicate the machine and the current working directory:</PARA>
<PROGRAMLISTING>
set prompt=&rdquo;`hostname -s`:`echo $cwd`% &ldquo;
alias cd `cd \!*;set prompt=&rdquo;`hostname -s`:`echo $cwd`% &ldquo;`
</PROGRAMLISTING>
<PARA>Under the Korn shell, you would enter the following commands:</PARA>
<PROGRAMLISTING>
PS1=`hostname``:${PWD}% `
export PS1
</PROGRAMLISTING>
</SECTION>
<SECTION  ID="LE18140-PARENT"><TITLE  ID="LE18140-TITLE">About Default File Permissions (umask)</TITLE><PARA><INDEXTERM ID="ITch05-51"><PRIMARY><COMMAND>umask</COMMAND>
</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-52"><PRIMARY>default permissions</PRIMARY>
<SECONDARY>setting</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-53"><PRIMARY>access permissions</PRIMARY>
<SECONDARY>setting</SECONDARY>
</INDEXTERM>
A system default called <COMMAND>umask</COMMAND> controls the access permissions of any files or directories that you create. The system default for IRIX, without <COMMAND>umask</COMMAND> set, is 022, which sets the following permissions:</PARA>
<DEFLIST><DEFLISTENTRY><TERM>user </TERM>
<LISTITEM><PARA>Full access: read, write, and, if applicable, execute permission. Directories can be executed; that is, you can change directories into any of your own directories and copy files from them.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM>group </TERM>
<LISTITEM><PARA>Anyone in the same group can read and, if applicable, execute other group members' files. Execute permission is turned on for directories. Write permission is turned off.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM>other </TERM>
<LISTITEM><PARA>All other users on the system have the same access permissions as group access.</PARA>
</LISTITEM>
</DEFLISTENTRY>
</DEFLIST>
<PARA>The system default <COMMAND>umask</COMMAND> of 022 is the same as running <COMMAND>chmod 644</COMMAND> on files that you create and <COMMAND>chmod 755</COMMAND> on directories and executable files that you create. Setting your <COMMAND>umask</COMMAND> does not affect existing files and directories. Like <COMMAND>chmod</COMMAND>, <COMMAND>umask</COMMAND> uses a three-digit argument to set file permissions. However, the argument to <COMMAND>umask</COMMAND> works the opposite as the argument to <COMMAND>chmod</COMMAND>. The argument to <COMMAND>umask</COMMAND> lowers the access permissions from a maximum of 666 (full access for files) and 777 (full access for directories). </PARA>
</SECTION>
<SECTION><TITLE>Changing Default File Permissions with umask</TITLE><PARA>To change the default permission, use the <COMMAND>umask</COMMAND> shell command.</PARA>
<PARA>The following command leaves permission unchanged for user, group, and other when you create files and directories:</PARA>
<LITERALLAYOUT>
<USERINPUT>umask 000</USERINPUT>
</LITERALLAYOUT>
<PARA>This command reduces access for other users by 1 (it removes execute permission):</PARA>
<LITERALLAYOUT>
<USERINPUT>umask 001</USERINPUT>
</LITERALLAYOUT>
<PARA>This command reduces access for group by 1 (no execute permission) and for others by 2 (no write permission, but execute is allowed):</PARA>
<LITERALLAYOUT>
<USERINPUT>umask 012</USERINPUT>
</LITERALLAYOUT>
<PARA>This command removes write and execute permission for group and removes all permissions for others:</PARA>
<LITERALLAYOUT>
<USERINPUT>umask 037</USERINPUT>
</LITERALLAYOUT>
<PARA>For more information, see the <COMMAND>umask(1)</COMMAND> man page.</PARA>
</SECTION>
<SECTION  ID="LE64438-PARENT"><TITLE  ID="LE64438-TITLE">Special Login Shells</TITLE><PARA><INDEXTERM ID="ITch05-54"><PRIMARY>user environment</PRIMARY>
<SECONDARY>special shells</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-55"><PRIMARY>special login shells</PRIMARY>
</INDEXTERM>
You may want to assign an account a login shell other than one of the system defaults. Reasons for doing this include:</PARA>
<ITEMIZEDLIST><LISTITEM><PARA>The need for special-use accounts that require restricted or very specific access to the system</PARA>
</LISTITEM>
<LISTITEM><PARA>A user request for a special shell</PARA>
</LISTITEM>
</ITEMIZEDLIST>
<PARA>You can specify any program as the login shell for an account. For example, you can use a third-party application program as the login shell. Users with this application as a shell log in to the system and are immediately placed in the application. All interaction with the system is through the application, and when the users quit the application, they are automatically logged out. To restrict access to the system, you can also use a custom shell that you create.</PARA>
<PARA>Another example is the <LITERAL>nuucp</LITERAL> account, which uses <FILENAME>/usr/lib/uucp/uucico</FILENAME> as a login shell.</PARA>
<PARA>Many users have favorite shells, for example the <COMMAND>bash</COMMAND> shell, that they might want you to install. As with any other software, make sure it comes from a reputable source. (<COMMAND>bash</COMMAND> shell is public domain software.) You may want to back up the system completely before installing the shell, then monitor the system closely for a while to be sure there are no problems with the shell.</PARA>
<PARA>For security reasons, you should not blindly accept compiled binaries and install them as login shells on the system (or anywhere else on the system, for that matter). Start with the source code for the shell, make sure there are no security holes in the code, then compile it for your site.</PARA>
<PARA>Note that special shells should be located in a filesystem that is always mounted before users log in to the system. If the filesystem that contains a login shell is not mounted, people who use that shell cannot log in to their accounts.</PARA>
</SECTION>
</SECTION>
<SECTION><TITLE>Sending Messages</TITLE><PARA><INDEXTERM ID="ITch05-56"><PRIMARY>communication</PRIMARY>
<SECONDARY>user</SECONDARY>
</INDEXTERM>
There are several ways to communicate with users in the IRIX system, including electronic mail, the message of the day, the remote login message, <COMMAND>news</COMMAND>, <COMMAND>write</COMMAND>, and <COMMAND>wall</COMMAND>.</PARA>
<SECTION><TITLE>Electronic Mail</TITLE><PARA><INDEXTERM ID="ITch05-57"><PRIMARY>mail</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-58"><PRIMARY>electronic mail</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-59"><PRIMARY>communication</PRIMARY>
<SECONDARY>user</SECONDARY>
</INDEXTERM>
Users can send messages to one another using one of the electronic mail programs provided with IRIX. Command-line as well as GUI implementations of various mail applications are available. For a complete discussion of configuring electronic mail, see the <CITETITLE><LINK BOOK="IA_NetwkMail" EXTREF="97829">IRIX Admin: Networking and Mail</LINK>
</CITETITLE> guide.</PARA>
</SECTION>
<SECTION><TITLE>Message-of-the-Day Facility</TITLE><PARA><INDEXTERM ID="ITch05-60"><PRIMARY>message of the day file</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-61"><PRIMARY><FILENAME>/etc/motd</FILENAME>
</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-62"><PRIMARY>communication</PRIMARY>
<SECONDARY>user</SECONDARY>
</INDEXTERM>
You can communicate items of broad interest to all users with the <FILENAME>/etc/motd</FILENAME> file. The contents of <FILENAME>/etc/motd</FILENAME> are displayed on the user's terminal as part of the login process. The login process executes <FILENAME>/etc/cshrc</FILENAME> (for the C shell), which commonly contains the command:</PARA>
<LITERALLAYOUT>
<USERINPUT>cat /etc/motd</USERINPUT>
</LITERALLAYOUT>
<PARA>Any text contained in <FILENAME>/etc/motd</FILENAME> is displayed for each user every time the user logs in. For this information to have any impact on users, you must take pains to use it sparingly and to remove outdated announcements.</PARA>
<PARA>A typical use for the message of the day facility might be:</PARA>
<LITERALLAYOUT>
5/30: The system will be unavailable from 6-11 pm Thursday, 5/30, while we install additional hardware
</LITERALLAYOUT>
<PARA>Be sure to remove the message when it is no longer important.</PARA>
<PARA>The f<INDEXTERM ID="ITch05-63"><PRIMARY>message of the day (/etc/motd)</PRIMARY>
</INDEXTERM>
ile <FILENAME>/etc/motd</FILENAME> contains the <FIRSTTERM>message of the day</FIRSTTERM>. This message is displayed on a user's screen, either by <FILENAME>/etc/profile</FILENAME> if the user runs Bourne shell, or by <FILENAME>/etc/cshrc</FILENAME> if the user runs C shell, when the user first logs in to the system.</PARA>
<PARA>You can place announcements of system activity in the <FILENAME>motd</FILENAME> file. For example, you should warn users of scheduled maintenance, changes in billing rates, new hardware and software, and any changes in the system or site configuration that affect them.</PARA>
<PARA>Since users see this message every time they log in, change it frequently to keep it from becoming stale. If users see the same message repeatedly, they lose interest in reading the message of the day and can miss an important announcement.</PARA>
<PARA>Make sure you remove outdated announcements. If nothing new is happening on the system, trim the file to a short welcome-to-the-system message.</PARA>
<PARA>A typical <FILENAME>motd</FILENAME> file looks something like the message in <XREF LINKEND="LE22854-TITLE"></PARA><EXAMPLE  ID="LE22854-PARENT"><TITLE  ID="LE22854-TITLE">Welcome-to-the-System Message</TITLE><PROGRAMLISTING>
Upcoming Events: ---------------
&nbsp;
26 November -- The system will be down from 8pm until Midnight for a software upgrade. We are installing FareSaver+, Release 3.2.2d.
&nbsp;
Watch this space for further details.

28 November through 31 November -- We will be operating with a minimal staff during the holiday. Please be patient if you need computer services. Use the admin beeper (767-3465) if there is a serious problem.
</PROGRAMLISTING>
</EXAMPLE>
<PARA>The <FILENAME>motd</FILENAME> file is used more frequently on servers than on workstations, but can be handy for networked workstations with guest accounts. You can also send electronic mail to all people who use the system, but this method consumes more disk space, and users may accidentally skip over the mail in their mailboxes.</PARA>
</SECTION>
<SECTION><TITLE>Remote Login Message</TITLE><PARA><INDEXTERM ID="ITch05-64"><PRIMARY>remote login message</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-65"><PRIMARY><FILENAME>if/etc/issue</FILENAME>
</PRIMARY>
</INDEXTERM>
The <FILENAME>/etc/issue</FILENAME> file is the equivalent of the <FILENAME>/etc/motd</FILENAME> file for users who log in over a serial line or the network. If <FILENAME>/etc/issue</FILENAME> does not exist, or is empty, no message is displayed.</PARA>
<PARA><INDEXTERM ID="ITch05-66"><PRIMARY>remote login message</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-67"><PRIMARY><FILENAME>/etc/issue</FILENAME>
</PRIMARY>
</INDEXTERM>
The <FILENAME>/etc/issue</FILENAME> message is displayed before the login prompt is given to someone attempting to log in to a system over a serial line or the network. If <FILENAME>/etc/issue</FILENAME> does not exist, or is empty, no message is displayed. This is essentially different from <FILENAME>/etc/motd</FILENAME> because it is displayed <EMPHASIS>before</EMPHASIS> the login prompt. This message is often used to notify potential users of rules about using the equipment; for example, a disclaimer that the workstation or server is reserved for employees of a particular corporation and that intruders will be prosecuted for unauthorized use.</PARA>
</SECTION>
<SECTION><TITLE>Sending Messages with the news Command</TITLE><PARA><INDEXTERM ID="ITch05-68"><PRIMARY>news system</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-69"><PRIMARY><FILENAME>/usr/news</FILENAME>
</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-70"><PRIMARY>communication</PRIMARY>
<SECONDARY>user</SECONDARY>
</INDEXTERM>
You can set up a simple electronic bulletin board facility with the <FILENAME>/usr/news</FILENAME> directory and the <COMMAND>news</COMMAND> command. With <COMMAND>news</COMMAND>, you can post messages of interest about the system. This is not the same system as the publicly distributed Usenet system. Place announcements of interest about the system in the directory <FILENAME>/usr/news</FILENAME>. Use one file per announcement, and name each file something descriptive, such as <FILENAME>downtime</FILENAME> and <FILENAME>new-network</FILENAME>. Use the <COMMAND>news</COMMAND> command to display the items.</PARA>
<PARA>You can automatically invoke <COMMAND>news</COMMAND> from a shell startup file, for example from the <FILENAME>/etc/cshrc</FILENAME> file. It is a good idea to check for new news items only from a shell startup file, since users may not be ready to read news immediately upon logging in. For example:</PARA>
<LITERALLAYOUT>
<USERINPUT>news -s</USERINPUT>
</LITERALLAYOUT>
<PARA>With the <LITERAL>-s</LITERAL> argument, <COMMAND>news</COMMAND> indicates how many articles there are since you last read news.</PARA>
<PARA>When you read news with the <COMMAND>news</COMMAND> command, you can do the following:</PARA>
<DEFLIST TERMLENGTH="NEXTLINE"><DEFLISTENTRY><TERM>Read everything </TERM>
<LISTITEM><PARA>To read all news posted since the last time you read articles, enter the <COMMAND>news</COMMAND> command with no arguments: </PARA>
<LITERALLAYOUT>
<USERINPUT>news</USERINPUT>&ensp;
</LITERALLAYOUT>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM>Select some items </TERM>
<LISTITEM><PARA>To read selected articles, enter the <COMMAND>news</COMMAND> command with the names of one or more items as arguments:</PARA>
<LITERALLAYOUT>
<USERINPUT>news downtime new-network</USERINPUT>&ensp;
</LITERALLAYOUT>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM>Read and delete </TERM>
<LISTITEM><PARA>After you run the <COMMAND>news</COMMAND> command, you can stop any item from printing by pressing <USERINPUT>Ctrl+C</USERINPUT> or <USERINPUT>Break</USERINPUT>. Pressing <USERINPUT>Ctrl+C</USERINPUT> or <USERINPUT>Break</USERINPUT> twice stops the program.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM>Ignore everything </TERM>
<LISTITEM><PARA>If you are too busy to read announcements at the moment, you can read them later. Items remain in <FILENAME>/usr/news</FILENAME> until the administrator (<LITERAL>root</LITERAL>) removes them. The list of news items is still displayed each time you log in.</PARA>
</LISTITEM>
</DEFLISTENTRY>
<DEFLISTENTRY><TERM>Flush all items </TERM>
<LISTITEM><PARA>There are two ways to catch up with all current news items:</PARA>
<LITERALLAYOUT>
<USERINPUT>touch .news_time</USERINPUT>
</LITERALLAYOUT>
<PARA>&ensp;This updates the time-accessed and time-modified fields of the <FILENAME>.news_time</FILENAME> file and thus the <COMMAND>news</COMMAND> program no longer considers there are articles for you to read.</PARA>
<PARA>This command prints all current articles, but sends the output to <FILENAME>/dev/null</FILENAME> so you do not see the articles:</PARA>
<PARA><USERINPUT>news &gt; /dev/null</USERINPUT></PARA>
<PARA>This brings you up to date without reading any outstanding articles.</PARA>
</LISTITEM>
</DEFLISTENTRY>
</DEFLIST>
</SECTION>
<SECTION><TITLE>Sending Messages with the write Command</TITLE><PARA><INDEXTERM ID="ITch05-71"><PRIMARY><COMMAND>write</COMMAND>
 command</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-72"><PRIMARY>communication</PRIMARY>
<SECONDARY>user</SECONDARY>
</INDEXTERM>
Use the <COMMAND>write</COMMAND> command to write messages to a user on the system. For example:</PARA>
<LITERALLAYOUT>
<USERINPUT>write ralph</USERINPUT>
</LITERALLAYOUT>
<PARA>User <LITERAL>ralph</LITERAL> sees this on his screen:</PARA>
<LITERALLAYOUT>
Message from root on brooklyn (console) [ Tue Feb 26 16:47:47 ] ... 
</LITERALLAYOUT>
<PARA>You can wait for <LITERAL>ralph</LITERAL> to respond, or you can begin typing your message. If the other user responds, you see a similar message on your screen.</PARA>
<PARA>Type your message. As you press Enter, each line of your message is displayed on the other user's screen.</PARA>
<PARA>Usually a <COMMAND>write</COMMAND> session is a dialogue, where each user takes turns writing. It is considered good etiquette to finish your turn with a punctuation mark on a line by itself, for example:</PARA>
<PROGRAMLISTING>
I noticed that you are using over 50 meg of disk space. Is there anything I can do to help you reduce that?
&gt;
</PROGRAMLISTING>
<PARA>Entering the greater-than symbol indicates you are through with your paragraph and are waiting for user <LITERAL>ralph</LITERAL> to respond. The other user should choose a different punctuation character to indicate when he or she is through.</PARA>
<PARA>You can prevent other users from writing to you with <COMMAND>write</COMMAND> by making your terminal or window unwritable. <INDEXTERM ID="ITch05-73"><PRIMARY><COMMAND>mesg</COMMAND>
 command</PRIMARY>
</INDEXTERM>
Use the <COMMAND>mesg</COMMAND> command:</PARA>
<LITERALLAYOUT>
<USERINPUT>mesg n</USERINPUT>
</LITERALLAYOUT>
<PARA>The <LITERAL>n</LITERAL> argument makes your terminal or window unwritable, and the <LITERAL>y</LITERAL> argument makes it writable. The superuser can write to any terminal or window, even if the user has made his or her terminal unwritable with <COMMAND>mesg n</COMMAND>.</PARA>
<PARA>The <COMMAND>talk</COMMAND> utility is similar to <COMMAND>write</COMMAND>, and is preferred by some users. For more information, refer to the <COMMAND>talk(1)</COMMAND> and <COMMAND>write(1)</COMMAND> man pages.</PARA>
</SECTION>
<SECTION><TITLE>Sending Messages with the wall Command</TITLE><PARA><INDEXTERM ID="ITch05-74"><PRIMARY><COMMAND>wall</COMMAND>
 command</PRIMARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-75"><PRIMARY>communication</PRIMARY>
<SECONDARY>user</SECONDARY>
</INDEXTERM>
<INDEXTERM ID="ITch05-76"><PRIMARY>write to all users</PRIMARY>
</INDEXTERM>
The superuser can use the <COMMAND>wall</COMMAND> command to write to all the users who are logged in on the system. This useful when you need to announce that you are bringing the system down.</PARA>
<PARA>To use <COMMAND>wall</COMMAND>, enter:</PARA>
<LITERALLAYOUT>
<USERINPUT>wall</USERINPUT>
</LITERALLAYOUT>
<PARA>Enter your message. Press <USERINPUT>Ctrl+D</USERINPUT> when you are finished, and <COMMAND>wall</COMMAND> sends the message. </PARA>
<PARA>You can also compose the message in a file, for example <FILENAME>messagefile</FILENAME>, then send it using <COMMAND>wall</COMMAND>:</PARA>
<LITERALLAYOUT>
<USERINPUT>wall &lt; messagefile</USERINPUT>
</LITERALLAYOUT>
<PARA>The <COMMAND>wall</COMMAND> command is not affected by a user's <COMMAND>mesg</COMMAND> setting. That is, a user cannot stop <COMMAND>wall</COMMAND> from displaying on his or her screen. On a graphics display with multiple windows, the message is displayed in all windows.</PARA>
</SECTION>
</SECTION>
</CHAPTER>
