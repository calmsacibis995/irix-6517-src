/*
 *   libdprof.c
 *   jlr@sgi.com
 */

#include <signal.h>
#include <stdlib.h>
#include <sys/time.h>
#include <stdio.h>
#include <sys/prctl.h>
#include <stdarg.h>
#include <unistd.h>
#include <sys/types.h>
#include <malloc.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <mutex.h>
#include <abi_mutex.h>
#include <sys/hwperftypes.h>
#include <sys/hwperfmacros.h>
#include <procfs/procfs.h>
#include <sys/resource.h>
#include <invent.h>

extern int _fdata[],_edata[];

#if _MIPS_SZPTR == 32
#define TOPOFSTACK 0x7fff8000L
#endif

#if _MIPS_SZPTR == 64
#define TOPOFSTACK 0x10000000000
#endif

/* histogram data structures */
typedef struct 
{ unsigned read_count,write_count; } ref_stat_t;

typedef struct 
{ __uint64_t page_number ; ref_stat_t ref_stat; } page_stat_t;

typedef struct 
{ __uint64_t num_ints; unsigned long is_sampling, thread_num, num_pages;
  page_stat_t *page_stat; } mem_stat_t;

typedef struct { __uint64_t page_num, thread_num, hits_num; } page_max_t;

typedef struct 
{ __uint64_t total_page_count; page_max_t *page_max_info; } pmax_t;

enum trigger { itimer, r10kperf };

static int npages = 4096; /* reserved for arena */
static void *__dprof_arena;

#define d __dprof_d

struct dprof_info {
  pmax_t pmax,smax,dmax;
  enum trigger method;
  mem_stat_t *mem_info;
  unsigned long count;
  FILE *outputfile;
  FILE *placefile;
  int shift_count, verbose, is_sampling;
  long event, frequency;
  __uint64_t counts[2];
  __uint64_t pcmin, pcmax;
  __uint64_t damin, damax;
  __uint64_t stack_min, stack_max, data_min, data_max;
  abilock_t lock;
  int threads_per_mem;
  unsigned long first_done;
  ref_stat_t *data_hist,*stack_hist;
  __uint64_t data_count,stack_count;
} *d;



static void  memory_reference(__uint64_t, int, mem_stat_t *);
static void *realloc_check(void *p, size_t n);
static void totally_sort(mem_stat_t);
static void show_mem_stats(mem_stat_t);
static void show_data_and_stack(void);
static void collect_and_combine_mem_stats(mem_stat_t);
static void collect_and_combine_data_and_stack_stats(mem_stat_t);
static void dprof_handler(int sig, int code , sigcontext_t *sc);
static void toggle_sampling(int sig, int code , sigcontext_t *sc);
static int IsLoadStore(unsigned inst);
static int IsBranch(unsigned inst);
static int MemOp(__uint64_t,int);
static int RegWritten(unsigned);
void __ateachexit(void ());
static void do_limits(void);

static void
initialize_values(void){
  d->method = itimer;
  d->count=1;
  d->outputfile = stdout;
  d->placefile = NULL;
  d->shift_count = 14;
  d->verbose = 0;
  d->is_sampling = 1;
  d->event = 0;
  d->frequency = 10000;
  d->counts[0] = 0;
  d->counts[1] = 0;
  d->pcmin=0;
  d->pcmax=0xffffffffffffffff;
  d->damin=0;
  d->damax=0xffffffffffffffff;
  init_lock(&d->lock);
  d->threads_per_mem = 2;
  d->first_done = 0;
  do_limits();
}

static void 
die(void){
  kill(-getpid(),SIGKILL);
  exit(1);
}

static void
do_limits(void){
  struct rlimit64 rlp;
  inventory_t *invent;
  for ( invent = getinvent () ; invent != 0 ; invent = getinvent () ){
    if( invent->inv_class == INV_MEMORY && invent->inv_type == INV_MAIN_MB )
      break;
  }

  if ( getrlimit64(RLIMIT_STACK, &rlp) < 0 ){
    perror("getrlimit(RLIMIT_STACK, &rlp) failed\n");
    die();
  }
  d->stack_max = TOPOFSTACK;
  d->stack_min = d->stack_max - rlp.rlim_cur;
  if ( getrlimit64(RLIMIT_DATA, &rlp) < 0 ){
    perror("getrlimit(RLIMIT_DATA, &rlp) failed\n");
    die();
  }
  d->data_min = (long long)_fdata;
  /*d->data_max = d->data_min + rlp.rlim_cur;*/
  d->data_max = d->data_min +  (( __uint64_t)invent->inv_state)*1024*1024;

  d->stack_count = 0;
  d->data_count = 0;
} 

static int
page_max_compare(  page_max_t *a, page_max_t *b)
{
  return (int)( a->page_num -  b->page_num ) ; 
}

static void
__sianara(void){ 
  int i;
  __uint64_t start_page,end_page,new_page,start_thread,new_thread;
  __uint64_t hits;
  fprintf(d->placefile,"threads  %d ",d->count);
  fprintf(d->placefile,"# This dplace file was automatically generated by dprof.\n");
  fprintf(d->placefile,"memories %d # running %d thread%s / memory\n",
	  (d->count+d->threads_per_mem-1)/d->threads_per_mem,d->threads_per_mem,
          d->threads_per_mem>1?"s":"");
  for(i=0;i<d->count;i++)
    fprintf(d->placefile,"run thread %d on memory %d\n",i,
	    i/d->threads_per_mem );

  start_page = d->dmax.page_max_info[0].page_num;
  end_page = start_page;
  start_thread = d->dmax.page_max_info[0].thread_num;
  hits = d->dmax.page_max_info[0].hits_num;
  for(i=1;i<d->dmax.total_page_count;i++){
    new_page = d->dmax.page_max_info[i].page_num; 
    new_thread = d->dmax.page_max_info[i].thread_num;
    if ( start_thread != new_thread || new_page != end_page+1 
	 || (i==(d->dmax.total_page_count-1)) ){
      fprintf(d->placefile,
	      "place range 0x%010llx to 0x%010llx on memory %3lld",
	      start_page<<d->shift_count,
	      (1+end_page)<<d->shift_count,
	      start_thread/d->threads_per_mem);
      fprintf(d->placefile," # %10lld memory events\n",hits);
      start_thread = new_thread;
      start_page = new_page;
      end_page = start_page;
      hits = d->dmax.page_max_info[i].hits_num;
    } else {
      end_page = new_page;
      hits += d->dmax.page_max_info[i].hits_num; 
    }

  }

  start_page = d->smax.page_max_info[0].page_num;
  end_page = start_page;
  start_thread = d->smax.page_max_info[0].thread_num;
  hits = d->smax.page_max_info[0].hits_num;
 
  for(i=1;i<d->smax.total_page_count;i++){
    new_page = d->smax.page_max_info[i].page_num; 
    new_thread = d->smax.page_max_info[i].thread_num;
    if ( start_thread != new_thread || new_page != end_page+1 
	 || (i==(d->smax.total_page_count-1)) ){
      fprintf(d->placefile,
	      "place range 0x%010llx to 0x%010llx on memory %3lld",
	      start_page<<d->shift_count,
	      (1+end_page)<<d->shift_count,
	      start_thread/d->threads_per_mem);
      fprintf(d->placefile," # %10lld memory events\n",hits);
      start_thread = new_thread;
      start_page = new_page;
      end_page = start_page;
      hits = d->smax.page_max_info[i].hits_num;
    } else {
      end_page = new_page;
      hits += d->smax.page_max_info[i].hits_num; 
    }

  }

  /* sort by page numbers */
  qsort(d->pmax.page_max_info,d->pmax.total_page_count ,sizeof(page_max_t),
	(int (*)(const void *, const void *)) page_max_compare );

  start_page = d->pmax.page_max_info[0].page_num;
  end_page = start_page;
  start_thread = d->pmax.page_max_info[0].thread_num;
  hits = d->pmax.page_max_info[0].hits_num;
 
  for(i=1;i<d->pmax.total_page_count;i++){
    new_page = d->pmax.page_max_info[i].page_num; 
    new_thread = d->pmax.page_max_info[i].thread_num;
    if ( start_thread != new_thread || new_page != end_page+1 
	 || (i==(d->pmax.total_page_count-1))  ){
      fprintf(d->placefile,
	      "place range 0x%010llx to 0x%010llx on memory %3lld",
	      start_page<<d->shift_count,
	      (1+end_page)<<d->shift_count,
	      start_thread/d->threads_per_mem);
      fprintf(d->placefile," # %10lld memory events\n",hits);
      start_thread = new_thread;
      start_page = new_page;
      end_page = start_page;
      hits = d->pmax.page_max_info[i].hits_num;
    } else {
      end_page = new_page;
      hits += d->pmax.page_max_info[i].hits_num; 
    }

  }
  
}
static void
__hasta_la_vista(void){ 
  sigset(SIGPROF,SIG_IGN);
  totally_sort(*d->mem_info); 
  spin_lock(&d->lock);
  fflush(d->outputfile);
  if ( d->first_done == 0 ){
    d->first_done = 1;
    sleep(1);
    fflush(d->outputfile);
    fprintf(d->outputfile,"--------------------------------------------------\n");
    fprintf(d->outputfile,"   address\tthread\t     reads\t    writes\n");
    fprintf(d->outputfile,"--------------------------------------------------\n");
  }
  show_data_and_stack();
  show_mem_stats(*d->mem_info);
  if (d->placefile){
    collect_and_combine_data_and_stack_stats(*d->mem_info);
    collect_and_combine_mem_stats(*d->mem_info);
  }
  fflush(d->outputfile);
  release_lock(&d->lock);
}

extern int _fdata[],_ftext[];

static void
do_args(void){
  char *c;
  
  c = getenv("__DPROF_OUTPUTFILE_");
  if ( NULL == c ){
    fprintf(stderr,"dprof parameter error.\n");
    exit(1);
  }
  if ( !strcmp(c,"stdout" ) ) d->outputfile = stdout;
  else if ( !strcmp(c,"stderr" ) ) d->outputfile = stderr;
  else {
    d->outputfile = fopen(c,"w");
    if ( NULL == d->outputfile ){
      fprintf(stderr,"dprof: cannot open '%s' for writing\n",c);
      exit(1);
    }
  }

  c = getenv("__DPROF_PLACEFILE_");
  if ( NULL == c ){
    fprintf(stderr,"dprof parameter error.\n");
    exit(1);
  }
  if ( !strcmp(c,"/dev/null" ) ) d->placefile = NULL;
  else if ( !strcmp(c,"stdout" ) ) d->placefile = stdout;
  else if ( !strcmp(c,"stderr" ) ) d->placefile = stderr;
  else {
    d->placefile = fopen(c,"w");
    if ( NULL == d->placefile ){
      fprintf(stderr,"dprof: cannot open '%s' for writing\n",c);
      exit(1);
    }
  }

  c = getenv("__DPROF_GRANULARITY_");
  if ( NULL == c ){
    fprintf(stderr,"dprof parameter error.\n");
    exit(1);
  }
  if ( !strcmp(c,"line" ) ) d->shift_count = 7;
  else if ( !strcmp(c,"hex" ) ) d->shift_count = 6;
  else if ( !strcmp(c,"oct" ) ) d->shift_count = 5;
  else if ( !strcmp(c,"quad" ) ) d->shift_count = 4;
  else if ( !strcmp(c,"double" ) ) d->shift_count = 3;
  else if ( !strcmp(c,"int" ) ) d->shift_count = 2;
  else if ( !strcmp(c,"word" ) ) d->shift_count = 2;
  else d->shift_count = 14;
  
  if(  d->shift_count != 14 && d->placefile != NULL ){
    fprintf(stderr,"dprof parameter error.\n");
    fprintf(stderr,"placement file cannot be generated without page sampling.\n");
    exit(1);
  }

  c = getenv("__DPROF_PC_MIN_");
  if ( NULL == c ){
    fprintf(stderr,"dprof parameter error.\n");
    exit(1);
  }
  d->pcmin = strtoull(c,(char **)NULL,10);
  if ( 0 == d->pcmin ) d->pcmin = (__uint64_t)_ftext;

  c = getenv("__DPROF_PC_MAX_");
  if ( NULL == c ){
    fprintf(stderr,"dprof parameter error.\n");
    exit(1);
  }
  d->pcmax = strtoull(c,(char **)NULL,10);

  c = getenv("__DPROF_DA_MIN_");
  if ( NULL == c ){
    fprintf(stderr,"dprof parameter error.\n");
    exit(1);
  }
  d->damin = strtoull(c,(char **)NULL,10);
  if ( 0 == d->damin ) d->damin = (__uint64_t)_fdata;

  c = getenv("__DPROF_DA_MAX_");
  if ( NULL == c ){
    fprintf(stderr,"dprof parameter error.\n");
    exit(1);
  }
  d->damax = strtoull(c,(char **)NULL,10);

  c = getenv("__DPROF_THREADS_PER_MEM_");
  if ( NULL == c ){
    fprintf(stderr,"dprof parameter error.\n");
    exit(1);
  }
  d->threads_per_mem = strtoull(c,(char **)NULL,10);

  c = getenv("__DPROF_METHOD_");
  if ( NULL == c ){
    fprintf(stderr,"dprof parameter error.\n");
    exit(1);
  }
  if ( !strcmp(c,"itimer" ) ){
    d->method = itimer;
  } 
  else if ( !strcmp(c,"hwpc") ){
    d->method = r10kperf;
  }

  c = getenv("__DPROF_FREQUENCY_");
  if ( NULL == c ){
    fprintf(stderr,"dprof parameter error.\n");
    exit(1);
  }
  d->frequency = strtol(c,(char **)NULL,0);

  c = getenv("__DPROF_COUNTER_");
  if ( NULL == c ){
    fprintf(stderr,"dprof parameter error.\n");
    exit(1);
  }
  d->event = strtol(c,(char **)NULL,0); 

  c = getenv("__DPROF_SIGUSR_");
  if ( NULL == c ){
    fprintf(stderr,"dprof parameter error.\n");
    exit(1);
  }
  if ( !strcmp(c,"on") ) d->is_sampling = 0;

  c = getenv("__DPROF_VERBOSE_");
  if ( NULL == c ){
    fprintf(stderr,"dprof parameter error.\n");
    exit(1);
  }
  if ( !strcmp(c,"on") ) d->verbose = 1;

}

static void 
do_memory(void){
  int fd;
  unsigned int *mapped;
  void *ac;
  /* set up arena */
  if ((fd = open("/dev/zero", O_RDWR)) < 0) {
    perror("Can't open /dev/zero");
    exit(1);
  }
  mapped = (unsigned int *)mmap(NULL,16384,PROT_READ|PROT_WRITE,
				MAP_SHARED|MAP_AUTORESRV,fd,0);
  if ( NULL == mapped ){
    perror("mmap of /dev/zero failed");
    exit(1);
  }

  d = (struct dprof_info *) mapped;

  mapped = (unsigned int *)mmap(NULL,npages*16384,PROT_READ|PROT_WRITE,
				MAP_PRIVATE|MAP_LOCAL|MAP_AUTORESRV,fd,16384);
  if ( NULL == mapped ){
    perror("mmap of /dev/zero failed");
    exit(1);
  }
  __dprof_arena = (void *) mapped;
  ac = acreate(__dprof_arena,npages*16384,MEM_NOAUTOGROW,0,0);
  if ( NULL == ac ){
    perror("Arena creation failed.\n");
    exit(1);
  }


  
}



static void 
do_trigger(void){

  if ( d->method == itimer ){
    struct itimerval timer;
    timer.it_interval.tv_sec = 0;
    timer.it_interval.tv_usec = 100000; /* ten times per second */
    timer.it_interval.tv_usec = (int)d->frequency;
    timer.it_value = timer.it_interval;
    if(d->is_sampling) sigset(SIGPROF,dprof_handler);
    else sigset(SIGPROF,SIG_IGN);
    setitimer(ITIMER_PROF,&timer,0);
  }
  else if ( d->method == r10kperf ){
    hwperf_profevctrarg_t evctr_args;
    int i;
    int event0 = (int)d->event, event1 = -1;
    int freq0 = 0 ,freq1 = 0;
    char pfile[] = "/proc/xxxxxd";
    int   pid = getpid();
    int   fd;
    if ( d->event >= 0 && d->event < 16 ){ 
      event0 = (int)d->event; 
      freq0 = (int)d->frequency;
      event1 = 16;
      freq1 = 0;
    }
    else if ( d->event >=16 && d->event < 32 ) {
      event0 = 0;
      freq0 = 0;
      event1 = (int)d->event;
      freq1 = (int)d->frequency;
    }
    else
      {
	fprintf(stderr,"dprof: event[%d] not in range [0-31]\n",d->event);
	exit(1);
      }
    sprintf(pfile, "/proc/%05d", pid);
    if ((fd = open(pfile, O_RDWR)) < 0) {
      fprintf(stderr,"dprof: Can't open '%s'\n",pfile);
      exit(1);
    }
    if (event0 != -1) {
      for (i = 0; i < HWPERF_EVENTMAX; i++) {
	if (i == event0) {
	  evctr_args.hwp_evctrargs.hwp_evctrl[i].hwperf_creg.hwp_mode = 
	    HWPERF_CNTEN_U;
	  evctr_args.hwp_evctrargs.hwp_evctrl[i].hwperf_creg.hwp_ie = 1;
	  evctr_args.hwp_evctrargs.hwp_evctrl[i].hwperf_creg.hwp_ev = i;
	  evctr_args.hwp_ovflw_freq[i] = freq0;
	} else {
	  evctr_args.hwp_evctrargs.hwp_evctrl[i].hwperf_spec = 0;
	  evctr_args.hwp_ovflw_freq[i] = 0;
	}
      }
    } else {
      for (i = 0; i < HWPERF_EVENTMAX; i++) {
	evctr_args.hwp_evctrargs.hwp_evctrl[i].hwperf_spec = 0;
	evctr_args.hwp_ovflw_freq[i] = 0;
      }
    }
     
    if (event1 != -1) {
      for (i = HWPERF_CNT1BASE; i < HWPERF_EVENTMAX; i++) {
	if (i == event1) {
	  evctr_args.hwp_evctrargs.hwp_evctrl[i].hwperf_creg.hwp_mode =
	    HWPERF_CNTEN_U;
	  evctr_args.hwp_evctrargs.hwp_evctrl[i].hwperf_creg.hwp_ie = 1;
	  evctr_args.hwp_evctrargs.hwp_evctrl[i].hwperf_creg.hwp_ev =
	    event1 - HWPERF_CNT1BASE;
	  evctr_args.hwp_ovflw_freq[i] = freq1;
	} else {
	  evctr_args.hwp_evctrargs.hwp_evctrl[i].hwperf_spec = 0;
	  evctr_args.hwp_ovflw_freq[i] = 0;
	}
      }
    } else {
      for (i = HWPERF_CNT1BASE; i < HWPERF_EVENTMAX; i++) {
	evctr_args.hwp_evctrargs.hwp_evctrl[i].hwperf_spec = 0;
	evctr_args.hwp_ovflw_freq[i] = 0;
      }
    }

    evctr_args.hwp_ovflw_sig = SIGPROF;
    if(d->is_sampling) sigset(SIGPROF,dprof_handler);
    else sigset(SIGPROF,SIG_IGN);
    if (ioctl(fd, PIOCENEVCTRS, (void *)&evctr_args) < 0) {
      perror("dprof: prioctl PIOCENEVCTRS returns error");
      exit(1);
    }
  }
  if( !d->is_sampling ) sigset(SIGUSR1,toggle_sampling);
  d->mem_info->is_sampling = d->is_sampling;
}

static void
show_options( void ){
  fprintf(d->outputfile,"------------------------------------\n");
  fprintf(d->outputfile,"dprof parameters:\n");
  fprintf(d->outputfile,"pcmin = 0x%016llx\n",d->pcmin);
  fprintf(d->outputfile,"pcmax = 0x%016llx\n",d->pcmax);
  fprintf(d->outputfile,"damin = 0x%016llx\n",d->damin);
  fprintf(d->outputfile,"damax = 0x%016llx\n",d->damax);
  if ( d->method == itimer ){
    fprintf(d->outputfile,"dprof method = itimer\n");
    fprintf(d->outputfile,"frequency = %d\n",d->frequency);
  }
  else if ( d->method == r10kperf ){
    fprintf(d->outputfile,"dprof method = r10kperf\n");
    fprintf(d->outputfile,"frequency = %d\n",d->frequency);
    fprintf(d->outputfile,"event = %d\n",d->event);
  }
  if ( d->placefile){
    fprintf(d->outputfile,"generating dprof output with %d thread%s per memory\n",
	    d->threads_per_mem,d->threads_per_mem>1?"s":"");
  }
  fprintf(d->outputfile,"------------------------------------\n");
}

void
__dprof_sproc_child (void)
{

  int i;
  ref_stat_t zero = {0,0};
  d->mem_info->thread_num = test_then_add(&d->count, 1);
  if(d->verbose)fprintf(d->outputfile,"There are now %d threads\n",
			d->count);
  d->mem_info->num_pages = 0;  
  d->mem_info->num_ints = 0;
  d->mem_info->page_stat = (page_stat_t *)0;
  for( i=0 ; i < d->stack_count ; i++)    d->stack_hist[i] = zero;
  for( i=0 ; i < d->data_count ; i++)    d->data_hist[i] = zero;
  d->stack_count = 0;
  d->data_count = 0;

}
void
__init_dprof(void){
  sigset(SIGPROF,SIG_IGN);
  do_memory();
  initialize_values();
  do_args();
  d->stack_hist = (ref_stat_t *)
    realloc_check((void *)0,
		  ((d->stack_max-d->stack_min)>>d->shift_count)*sizeof(ref_stat_t));

  d->data_hist = (ref_stat_t *)
    realloc_check((void *)0,
		  ((d->data_max-d->data_min)>>d->shift_count)*sizeof(ref_stat_t));

  d->mem_info = (mem_stat_t *)amalloc(sizeof( mem_stat_t ),__dprof_arena);

  if( 0 == d->mem_info ){
    perror("amalloc failed");
    exit(1);
  }
  d->mem_info->thread_num = 0;
  d->mem_info->num_pages = 0;
  d->mem_info->num_ints = 0;
  d->mem_info->page_stat = (page_stat_t *)0;

  if( atsproc_child(__dprof_sproc_child) < 0 ){
    perror("atsproc_child");
    die();
  }
  if( atfork_child(__dprof_sproc_child) < 0 ){
    perror("atfork_child");
    die();
  }



  do_trigger();
  if (d->verbose) show_options();
  /* register thread exit routine */
  __ateachexit(__hasta_la_vista);
  if (d->placefile) atexit(__sianara);

}

static void 
toggle_sampling(int sig , int code , sigcontext_t *sc)
{
  d->mem_info->is_sampling ^= 1;
  if(!d->mem_info->is_sampling) sigset(SIGPROF,SIG_IGN);
  else sigset(SIGPROF,dprof_handler);

}
static void 
dprof_handler(int sig , int code , sigcontext_t *sc)
{
  __uint64_t PC;
  unsigned int mask,inst;
  unsigned int reg_mask = 0;
  unsigned int reg,isls;
  short offset;
  sigset(SIGPROF,SIG_IGN);
  d->mem_info->num_ints++;
  PC = sc->sc_pc;
  if ( PC < d->pcmin || PC > d->pcmax){
    if ( d->mem_info->is_sampling ) sigset(SIGPROF,dprof_handler);
    return; 
  }
  
  for(;;) {
    /* walk forward with the hope of finding a valid
     * load or store instruction keeping track of which
     * gp registers get written.
     * abort if we:
     *  1) hit a branch
     *  2) reach a load or store whose address is based on
     *     a gp register that has been modified.
     */
    inst = *(unsigned *)PC;
    isls = IsLoadStore(inst);
    if ( reg = RegWritten(inst) ) reg_mask |= (1<<reg);

    if ( isls > 3 ){		/* Normal load or store (i31,i30,i29) > 3 */
      reg = (inst >> 21 )& 31;
      offset = (short)(inst&65535);
      if ( !(reg_mask & (1<<reg)) )
	MemOp((__uint64_t)(sc->sc_regs[reg]+offset), isls&1 );
      break;
    } else if ( isls == 2 ){	/* cop1x instruction */
      int reg1;
      reg = (inst >> 21 )& 31;
      reg1 = (inst >> 16 )& 31;
      if ( !((reg_mask & (1<<reg)) ||(reg_mask & (1<<reg1)))  )
	MemOp((__uint64_t)(sc->sc_regs[reg]+sc->sc_regs[reg1]),
	      (inst&0x8)>>3); 
      break;

    }
    if ( IsBranch(inst) ) break;
    PC +=4;
  } 
  if ( d->mem_info->is_sampling ) sigset(SIGPROF,dprof_handler);
}

static int 
RegWritten(unsigned inst){
  int DestReg,Special;
  int OpCode = inst >> 29;
  if ( OpCode == 1 || OpCode == 3 || OpCode == 4 ){
    DestReg = (inst >> 16 )&0x1f;
    return DestReg;
  }
  if ( 0  == (inst>>26) ){
    Special = (inst&0x3f);
    DestReg = (inst >> 11 )&0x1f;
    if ( (Special & 0x38 ) == 0x08 )
      if ( (Special&0x7) != 2 || (Special&0x7) != 3 ) return 0;
    return DestReg;
  }
  return 0;
}

static int
IsLoadStore(unsigned inst)
{
  int OpCode= inst >> 29;
  if ( OpCode> 3 ) return(OpCode); /* normal */
  if ( OpCode == 2 && 3 == ((inst>>26)&7) && ((inst>>3)&7) < 2 )
    return(OpCode); /* cop1x */
  return(0);
}

static int
IsBranch(unsigned inst)
{
  int OpCode= inst >> 29;
  int k = (inst >> 26)&0x7;
  if ( (k>=4) && ( OpCode == 2 || OpCode == 0 ) )  return 1; /*normal branch*/
  if ( OpCode == 0 ){
    if ( k == 0 && ((inst&0x3e) == 0x8) ) return 1; /* special */
    if ( k == 1 && ((inst&0x80000) == 0) ) return 1;/* regimm */
  }
  return(0);
}


static int 
MemOp(__uint64_t addr, int type ){
  __uint64_t index;
  if( ( ( addr < (__uint64_t)__dprof_arena ) || ( addr >=
						  ( (16384*npages)+(__uint64_t) __dprof_arena ) ) ) &&
      addr >= d->damin && addr <= d->damax ){
    if( addr >= d->stack_min && addr < d->stack_max ){
      index = (d->stack_max-addr)>>d->shift_count;
      if( index >= d->stack_count ) d->stack_count = index+1;
    
      if( type )
	d->stack_hist[index].write_count++;
      else 
	d->stack_hist[index].read_count++;
	
    } else if ( addr >= d->data_min && addr < d->data_max ){
      index = (addr - d->data_min)>>d->shift_count;
      if( index >= d->data_count ) d->data_count = index+1;

      if(type) d->data_hist[index].write_count++;
      else 
	d->data_hist[index].read_count++;
      
    } else
      memory_reference((__uint64_t)(addr>>d->shift_count),type, d->mem_info);
  }
  return 0;
}



static int
page_compare(page_stat_t *a, page_stat_t *b)
{
  return (int)( a->page_number -  b->page_number ) ; 
}

/*
static int
mem_ref_compare(ref_stat_t *a, ref_stat_t *b)
{
  return (int)( (int)( b->read_count + b->write_count) -
	       (int) ( a->read_count + a->write_count)) ; 
}
*/

static void *
realloc_check(void *p, size_t n)
{
  void *np = arealloc(p,n,__dprof_arena);
  if ( 0 == np ){
    fprintf(stderr,"No more space to realloc().\n");
    exit(1);
  }
  return np;
}

static void
memory_reference(__uint64_t page, int op, mem_stat_t *mem_info)
{
  int i,found = 0;
	
  for(i=0;i<mem_info->num_pages;i++){
    if ( page == mem_info->page_stat[i].page_number ){
      found = 1;
      break;
    }
  }
	
  if (0 == found ){		/* a new page: get space and set thread list */
    mem_info->num_pages++;
    mem_info->page_stat =  
      (page_stat_t *) realloc_check(
				    mem_info->page_stat,
				    mem_info->num_pages * 
				    sizeof(page_stat_t) );
    mem_info->page_stat[i].page_number = page;
    mem_info->page_stat[i].ref_stat.read_count = 1-op;
    mem_info->page_stat[i].ref_stat.write_count = op;
							       
  } else 
    { 
      mem_info->page_stat[i].ref_stat.read_count += 1-op;
      mem_info->page_stat[i].ref_stat.write_count += op;
    }
	
}

static void
totally_sort(mem_stat_t mem_info)
{
  /* sort by page numbers */
  qsort(mem_info.page_stat,mem_info.num_pages,sizeof(page_stat_t),
	(int (*)(const void *, const void *)) page_compare );
	
}


static void
collect_and_combine_mem_stats(mem_stat_t mem_info)
{
  
  static int first_time = 0;
  int i,j,found;
  __uint64_t page;
  if ( 0 == first_time ){
    first_time = 1;
    d->pmax.total_page_count = mem_info.num_pages;
    d->pmax.page_max_info = (page_max_t *)
      malloc(d->pmax.total_page_count*sizeof(page_max_t));
    if ( NULL == d->pmax.page_max_info ){
      fprintf(stderr,"No space for summary\n");
      exit(1);
    }
    for(i=0;i<d->pmax.total_page_count;i++){
      d->pmax.page_max_info[i].page_num = mem_info.page_stat[i].page_number;
      d->pmax.page_max_info[i].thread_num = mem_info.thread_num;
      d->pmax.page_max_info[i].hits_num = 
	mem_info.page_stat[i].ref_stat.read_count + 
	mem_info.page_stat[i].ref_stat.write_count ;
    }
    return;
  } else {
    for(j=0;j<mem_info.num_pages;j++){
      found = 0;
      page = mem_info.page_stat[j].page_number;
      for(i=0;i<d->pmax.total_page_count;i++){
	if ( page == d->pmax.page_max_info[i].page_num ){
	  found = 1;
	  break;
	}
      }
	
      if (0 == found ){		/* a new page: get space and set thread list */
	d->pmax.total_page_count++;
	d->pmax.page_max_info = (page_max_t *)
	  realloc( d->pmax.page_max_info ,
		   d->pmax.total_page_count*sizeof(page_max_t));
	if ( NULL == d->pmax.page_max_info ){
	  fprintf(stderr,"No space for summary\n");
	  exit(1);
	}
	d->pmax.page_max_info[i].page_num = mem_info.page_stat[j].page_number;
	d->pmax.page_max_info[i].thread_num = mem_info.thread_num;
	d->pmax.page_max_info[i].hits_num = 
	  mem_info.page_stat[j].ref_stat.read_count + 
	  mem_info.page_stat[j].ref_stat.write_count ;
      } else if ( mem_info.page_stat[j].ref_stat.read_count + 
		  mem_info.page_stat[j].ref_stat.write_count >
		  d->pmax.page_max_info[i].hits_num )
	{
	  d->pmax.page_max_info[i].page_num = mem_info.page_stat[j].page_number;
	  d->pmax.page_max_info[i].thread_num = mem_info.thread_num;
	  d->pmax.page_max_info[i].hits_num = 
	    mem_info.page_stat[j].ref_stat.read_count + 
	    mem_info.page_stat[j].ref_stat.write_count ;
	}
    }
  }
}

static void
collect_and_combine_data_and_stack_stats(mem_stat_t mem_info)
{
  
  static int first_time = 0;
  int found;
  __uint64_t i,j,page;
  if ( 0 == first_time ){
    first_time = 1;
    d->smax.total_page_count = d->stack_count;
    d->smax.page_max_info = (page_max_t *)
      malloc(d->smax.total_page_count*sizeof(page_max_t));
    if ( NULL == d->smax.page_max_info ){
      fprintf(stderr,"No space for summary\n");
      exit(1);
    }
    for(i=0;i<d->smax.total_page_count;i++){
      j = d->smax.total_page_count - 1 - i;
      d->smax.page_max_info[j].page_num =   ((d->stack_max>>d->shift_count) - 
					     (__uint64_t)i);
      d->smax.page_max_info[j].thread_num = mem_info.thread_num;
      d->smax.page_max_info[j].hits_num = 
	d->stack_hist[i].read_count + 	d->stack_hist[i].write_count ;
    }

    d->dmax.total_page_count = d->data_count;
    d->dmax.page_max_info = (page_max_t *)
      malloc(d->dmax.total_page_count*sizeof(page_max_t));
    if ( NULL == d->dmax.page_max_info ){
      fprintf(stderr,"No space for summary\n");
      exit(1);
    }
    for(i=0;i<d->dmax.total_page_count;i++){
      j = d->dmax.total_page_count - 1 - i;
      d->dmax.page_max_info[j].page_num =   ((d->data_min>>d->shift_count) +
					     (__uint64_t)i);
      d->dmax.page_max_info[j].thread_num = mem_info.thread_num;
      d->dmax.page_max_info[j].hits_num = 
	d->data_hist[i].read_count + 	d->data_hist[i].write_count ;
    }
   
  } else {
    
    for(i=0;i<d->smax.total_page_count;i++){
      j = d->smax.total_page_count - 1 - i;
      if ( d->stack_hist[i].read_count + 
	   d->stack_hist[i].write_count >
	   d->smax.page_max_info[j].hits_num )
	{
	  d->smax.page_max_info[j].thread_num = mem_info.thread_num;
	  d->smax.page_max_info[j].hits_num = 
	    d->stack_hist[i].read_count + 
	    d->stack_hist[i].write_count ;
	}
    }
    for(i=0;i<d->dmax.total_page_count;i++){
      j = d->dmax.total_page_count - 1 - i;
      if ( d->data_hist[i].read_count + 
	   d->data_hist[i].write_count >
	   d->dmax.page_max_info[j].hits_num )
	{
	  d->dmax.page_max_info[j].thread_num = mem_info.thread_num;
	  d->dmax.page_max_info[j].hits_num = 
	    d->data_hist[i].read_count + 
	    d->data_hist[i].write_count ;
	}
    }
  }
}

static void
show_data_and_stack(void)
{
  long i;
  unsigned long thread = d->mem_info->thread_num;
  for(i=0;i<=d->data_count;i++){
    if(d->data_hist[i].read_count || d->data_hist[i].write_count)
      fprintf(d->outputfile,"0x%010llx\t%3d\t%10d\t%10d\n",
	      d->data_min + (((__uint64_t)i)<<d->shift_count),
	      thread,
	      d->data_hist[i].read_count,
	      d->data_hist[i].write_count );
  }
  for(i=(long)d->stack_count;i>=0;i--){
    if(d->stack_hist[i].read_count || d->stack_hist[i].write_count)
      fprintf(d->outputfile,"0x%010llx\t%3d\t%10d\t%10d\n",
	      d->stack_max - (((__uint64_t)i)<<d->shift_count),
	      thread,
	      d->stack_hist[i].read_count,
	      d->stack_hist[i].write_count );
  }
}

static void
show_mem_stats(mem_stat_t mem_info)
{
  int i;
  for(i=0;i<mem_info.num_pages;i++){
    fprintf(d->outputfile,"0x%010llx\t%3d\t%10d\t%10d\n",
	    mem_info.page_stat[i].page_number<<d->shift_count,
	    mem_info.thread_num,
	    mem_info.page_stat[i].ref_stat.read_count,
	    mem_info.page_stat[i].ref_stat.write_count );
  }
  if ( d->verbose ) 
    fprintf(d->outputfile,"%12lld interrupts received by thread %d\n",
	    mem_info.num_ints,mem_info.thread_num);
  /* show timers */
  if ( d->verbose && d->method == r10kperf ){
    hwperf_cntr_t   cnts; 
    char pfile[32];
    int j,fd;
    for (i = 0; i < HWPERF_EVENTMAX; i++) cnts.hwp_evctr[i] = 0;
    sprintf(pfile, "/proc/%05d", getpid());
    if ((fd = open(pfile, O_RDWR)) < 0) {
      perror("dprof: Can't open /proc/pid");
      exit(1);
    }
    if (ioctl(fd, PIOCGETEVCTRS, (void *)&cnts) < 0) {
      perror("dprof: prioctl PIOCGETEVCTRS returns error");
      exit(1);
    }
    for (i = 0, j = 0 ; i < HWPERF_EVENTMAX; i++){
      if (cnts.hwp_evctr[i]){
	__uint64_t this_count = cnts.hwp_evctr[i];
	if ( mem_info.thread_num )  d->counts[j]+= cnts.hwp_evctr[i];
	else this_count -= d->counts[j];
	j++;
	fprintf(d->outputfile,"event %2d = %20lld\n",
		i, (__uint64_t) this_count );
      }
    }
  }
  fprintf(d->outputfile,"\n");
}
