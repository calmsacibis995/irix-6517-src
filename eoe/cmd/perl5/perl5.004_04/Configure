#! /bin/sh
#
# If these # comments don't work, trim them. Don't worry about any other
# shell scripts, Configure will trim # comments from them for you.
#
# (If you are trying to port this package to a machine without sh,
# I would suggest you have a look at the prototypical config_h.SH file
# and edit it to reflect your system. Some packages may include samples
# of config.h for certain machines, so you might look for one of those.)
#
# Yes, you may rip this off to use in other distribution packages. This
# script belongs to the public domain and cannot be copyrighted.
#
# (Note: this Configure script was generated automatically. Rather than
# working with this copy of Configure, you may wish to get metaconfig.
# The dist-3.0 package (which contains metaconfig) was posted in
# comp.sources.misc so you may fetch it yourself from your nearest
# archive site. Check with Archie if you don't know where that can be.)
#

# $Id: Head.U,v 3.0.1.8 1995/07/25 13:40:02 ram Exp $
#
# Generated on Sat Feb  1 00:26:40 EST 1997 [metaconfig 3.0 PL60]

cat >/tmp/c1$$ <<EOF
ARGGGHHHH!!!!!

SCO csh still thinks true is false.  Write to SCO today and tell them that next
year Configure ought to "rm /bin/csh" unless they fix their blasted shell. :-)

(Actually, Configure ought to just patch csh in place.  Hmm.  Hmmmmm.  All
we'd have to do is go in and swap the && and || tokens, wherever they are.)

[End of diatribe. We now return you to your regularly scheduled programming...]
EOF
cat >/tmp/c2$$ <<EOF

OOPS!  You naughty creature!  You didn't run Configure with sh!
I will attempt to remedy the situation by running sh for you...
EOF

true || cat /tmp/c1$$ /tmp/c2$$
true || exec sh $0 $argv:q

(exit $?0) || cat /tmp/c2$$
(exit $?0) || exec sh $0 $argv:q
rm -f /tmp/c1$$ /tmp/c2$$

: compute my invocation name
me=$0
case "$0" in
*/*)
	me=`echo $0 | sed -e 's!.*/\(.*\)!\1!' 2>/dev/null`
	test "$me" || me=$0
	;;
esac

: Proper PATH separator
p_=:
: On OS/2 this directory should exist if this is not floppy only system :-]
if test -d c:/. -a -n "$OS2_SHELL"; then
	p_=\;
	PATH=`cmd /c "echo %PATH%" | tr '\\\\' / `
	OS2_SHELL=`cmd /c "echo %OS2_SHELL%" | tr '\\\\' / | tr '[A-Z]' '[a-z]'`
fi

: Proper PATH setting
paths='/bin /usr/bin /usr/local/bin /usr/ucb /usr/local /usr/lbin'
paths="$paths /opt/bin /opt/local/bin /opt/local /opt/lbin"
paths="$paths /usr/5bin /etc /usr/gnu/bin /usr/new /usr/new/bin /usr/nbin"
paths="$paths /opt/gnu/bin /opt/new /opt/new/bin /opt/nbin"
paths="$paths /sys5.3/bin /sys5.3/usr/bin /bsd4.3/bin /bsd4.3/usr/ucb"
paths="$paths /bsd4.3/usr/bin /usr/bsd /bsd43/bin /usr/ccs/bin"
paths="$paths /etc /usr/lib /usr/ucblib /lib /usr/ccs/lib"
paths="$paths /sbin /usr/sbin /usr/libexec"

for p in $paths
do
	case "$p_$PATH$p_" in
	*$p_$p$p_*) ;;
	*) test -d $p && PATH=$PATH$p_$p ;;
	esac
done

PATH=.$p_$PATH
export PATH

: This should not matter in scripts, but apparently it does, sometimes
case "$CDPATH" in
'')	;;
*)	CDPATH='' ;;
esac

: Sanity checks
if test ! -s config.sh -a ! -t 0; then
	echo "Say 'sh $me', not 'sh <$me'"
	exit 1
fi

: Test and see if we are running under ksh, either blatantly or in disguise.
if (PATH=.; alias -x) >/dev/null 2>&1; then
    : running under ksh.  Is this a good thing?
    if test -d /usr/lpp -a -f /usr/bin/bsh -a -f /usr/bin/uname ; then
        if test X`/usr/bin/uname -v` = X4 ; then
            : on AIX 4, /bin/sh is really ksh, and it causes us problems.
            : Avoid it
		cat <<'EOM'
(Feeding myself to /usr/bin/bsh to avoid AIX 4's /bin/sh.)
EOM
		unset ENV
            exec /usr/bin/bsh $0 "$@"
	fi
    else
        if test ! -f /hp-ux ; then
	: Warn them if they use ksh on other systems
		cat <<EOM
(I see you are using the Korn shell.  Some ksh's blow up on $me,
especially on older exotic systems.  If yours does, try the Bourne 
shell instead.)
EOM
		unset ENV
        fi
    fi
else
    : Not running under ksh.  Maybe we should be?
    : On HP-UX, large Configure scripts may exercise a bug in /bin/sh
    if test -f /hp-ux -a -f /bin/ksh; then
        cat <<'EOM'
(Feeding myself to ksh to avoid nasty sh bug in "here document" expansion.)
EOM
        unset ENV
        exec /bin/ksh $0 "$@"
    fi
fi

: Configure runs within the UU subdirectory
test -d UU || mkdir UU
cd UU && rm -f ./*

dynamic_ext=''
extensions=''
known_extensions=''
static_ext=''
useopcode=''
useposix=''
d_bsd=''
d_eunice=''
d_xenix=''
eunicefix=''
Mcc=''
awk=''
bash=''
bison=''
byacc=''
cat=''
chgrp=''
chmod=''
chown=''
comm=''
compress=''
cp=''
cpio=''
cpp=''
csh=''
date=''
echo=''
egrep=''
emacs=''
expr=''
find=''
flex=''
gcc=''
grep=''
gzip=''
inews=''
ksh=''
less=''
line=''
lint=''
ln=''
lp=''
lpr=''
ls=''
mail=''
mailx=''
mkdir=''
more=''
mv=''
nroff=''
perl=''
pg=''
pmake=''
pr=''
rm=''
rmail=''
sed=''
sendmail=''
shar=''
sleep=''
smail=''
sort=''
submit=''
tail=''
tar=''
tbl=''
test=''
touch=''
tr=''
troff=''
uname=''
uniq=''
uuname=''
vi=''
zcat=''
zip=''
full_sed=''
libswanted=''
hint=''
myuname=''
osname=''
osvers=''
Author=''
Date=''
Header=''
Id=''
Locker=''
Log=''
RCSfile=''
Revision=''
Source=''
State=''
ar=''
archobjs=''
exe_ext=''
firstmakefile=''
lib_ext=''
obj_ext=''
path_sep=''
afs=''
alignbytes=''
archlib=''
archlibexp=''
d_archlib=''
installarchlib=''
archname=''
myarchname=''
baserev=''
bin=''
binexp=''
installbin=''
bincompat3=''
d_bincompat3=''
byteorder=''
cc=''
gccversion=''
ccflags=''
cppflags=''
ldflags=''
lkflags=''
locincpth=''
optimize=''
cf_email=''
cf_by=''
cf_time=''
contains=''
cpp_stuff=''
cpplast=''
cppminus=''
cpprun=''
cppstdin=''
d_access=''
d_alarm=''
d_attribut=''
d_bcmp=''
d_bcopy=''
d_bzero=''
d_casti32=''
castflags=''
d_castneg=''
d_chown=''
d_chroot=''
d_chsize=''
d_closedir=''
d_void_closedir=''
d_const=''
cryptlib=''
d_crypt=''
d_csh=''
full_csh=''
d_cuserid=''
d_dbl_dig=''
d_difftime=''
d_dlerror=''
d_dlopen=''
d_dlsymun=''
d_dosuid=''
d_suidsafe=''
d_dup2=''
d_fchmod=''
d_fchown=''
d_fcntl=''
d_fd_macros=''
d_fd_set=''
d_fds_bits=''
d_fgetpos=''
d_flexfnam=''
d_flock=''
d_fork=''
d_fsetpos=''
d_ftime=''
d_gettimeod=''
d_Gconvert=''
d_getgrps=''
d_setgrps=''
d_gethent=''
aphostname=''
d_gethname=''
d_phostname=''
d_uname=''
d_getlogin=''
d_getpgid=''
d_getpgrp2=''
d_bsdgetpgrp=''
d_getpgrp=''
d_getppid=''
d_getprior=''
d_gnulibc=''
d_htonl=''
d_inetaton=''
d_isascii=''
d_killpg=''
d_link=''
d_locconv=''
d_lockf=''
d_lstat=''
d_mblen=''
d_mbstowcs=''
d_mbtowc=''
d_memcmp=''
d_memcpy=''
d_memmove=''
d_memset=''
d_mkdir=''
d_mkfifo=''
d_mktime=''
d_msg=''
d_msgctl=''
d_msgget=''
d_msgrcv=''
d_msgsnd=''
d_nice=''
d_open3=''
d_fpathconf=''
d_pathconf=''
d_pause=''
d_pipe=''
d_poll=''
d_portable=''
d_readdir=''
d_rewinddir=''
d_seekdir=''
d_telldir=''
d_readlink=''
d_rename=''
d_rmdir=''
d_safebcpy=''
d_safemcpy=''
d_sanemcmp=''
d_select=''
d_sem=''
d_semctl=''
d_semget=''
d_semop=''
d_setegid=''
d_seteuid=''
d_setlinebuf=''
d_setlocale=''
d_setpgid=''
d_setpgrp2=''
d_bsdpgrp=''
d_bsdsetpgrp=''
d_setpgrp=''
d_setprior=''
d_setregid=''
d_setresgid=''
d_setresuid=''
d_setreuid=''
d_setrgid=''
d_setruid=''
d_setsid=''
d_sfio=''
usesfio=''
d_shm=''
d_shmat=''
d_shmatprototype=''
shmattype=''
d_shmctl=''
d_shmdt=''
d_shmget=''
d_sigaction=''
d_sigsetjmp=''
d_oldsock=''
d_socket=''
d_sockpair=''
sockethdr=''
socketlib=''
d_statblks=''
d_stdio_cnt_lval=''
d_stdio_ptr_lval=''
d_stdiobase=''
d_stdstdio=''
stdio_base=''
stdio_bufsiz=''
stdio_cnt=''
stdio_ptr=''
d_index=''
d_strchr=''
d_strcoll=''
d_strctcpy=''
d_strerrm=''
d_strerror=''
d_sysernlst=''
d_syserrlst=''
d_strtod=''
d_strtol=''
d_strtoul=''
d_strxfrm=''
d_symlink=''
d_syscall=''
d_sysconf=''
d_system=''
d_tcgetpgrp=''
d_tcsetpgrp=''
d_time=''
timetype=''
clocktype=''
d_times=''
d_truncate=''
d_tzname=''
d_umask=''
d_vfork=''
usevfork=''
d_voidsig=''
signal_t=''
d_volatile=''
d_charvspr=''
d_vprintf=''
d_wait4=''
d_waitpid=''
d_wcstombs=''
d_wctomb=''
dlext=''
cccdlflags=''
ccdlflags=''
dlsrc=''
ld=''
lddlflags=''
usedl=''
fpostype=''
gidtype=''
groupstype=''
h_fcntl=''
h_sysfile=''
db_hashtype=''
db_prefixtype=''
i_db=''
i_dbm=''
i_rpcsvcdbm=''
d_dirnamlen=''
direntrytype=''
i_dirent=''
i_dld=''
i_dlfcn=''
i_fcntl=''
i_float=''
i_gdbm=''
i_grp=''
i_limits=''
i_locale=''
i_malloc=''
i_math=''
i_memory=''
i_ndbm=''
i_neterrno=''
i_niin=''
i_sysin=''
d_pwage=''
d_pwchange=''
d_pwclass=''
d_pwcomment=''
d_pwexpire=''
d_pwquota=''
i_pwd=''
i_sfio=''
i_stddef=''
i_stdlib=''
i_string=''
strings=''
i_sysdir=''
i_sysfile=''
d_voidtty=''
i_bsdioctl=''
i_sysfilio=''
i_sysioctl=''
i_syssockio=''
i_sysndir=''
i_sysparam=''
i_sysresrc=''
i_sysselct=''
i_sysstat=''
i_systimes=''
i_systypes=''
i_sysun=''
i_syswait=''
i_sgtty=''
i_termio=''
i_termios=''
i_systime=''
i_systimek=''
i_time=''
timeincl=''
i_unistd=''
i_utime=''
i_values=''
i_stdarg=''
i_varargs=''
i_varhdr=''
i_vfork=''
intsize=''
longsize=''
shortsize=''
libc=''
libperl=''
shrpenv=''
useshrplib=''
glibpth=''
libpth=''
loclibpth=''
plibpth=''
xlibpth=''
libs=''
lns=''
lseektype=''
make=''
make_set_make=''
d_mymalloc=''
freetype=''
mallocobj=''
mallocsrc=''
malloctype=''
usemymalloc=''
installman1dir=''
man1dir=''
man1direxp=''
man1ext=''
installman3dir=''
man3dir=''
man3direxp=''
man3ext=''
huge=''
large=''
medium=''
models=''
small=''
split=''
modetype=''
mydomain=''
myhostname=''
phostname=''
c=''
n=''
d_eofnblk=''
eagain=''
o_nonblock=''
rd_nodata=''
groupcat=''
hostcat=''
passcat=''
d_oldarchlib=''
oldarchlib=''
oldarchlibexp=''
orderlib=''
ranlib=''
package=''
spackage=''
pager=''
patchlevel=''
subversion=''
perladmin=''
perlpath=''
prefix=''
prefixexp=''
installprivlib=''
privlib=''
privlibexp=''
prototype=''
randbits=''
installscript=''
scriptdir=''
scriptdirexp=''
selecttype=''
sh=''
sig_name=''
sig_num=''
installsitearch=''
sitearch=''
sitearchexp=''
installsitelib=''
sitelib=''
sitelibexp=''
sizetype=''
so=''
sharpbang=''
shsharp=''
spitshell=''
ssizetype=''
startperl=''
startsh=''
stdchar=''
sysman=''
uidtype=''
nm_opt=''
nm_so_opt=''
runnm=''
usenm=''
useperlio=''
incpath=''
mips=''
mips_type=''
usrinc=''
defvoidused=''
voidflags=''
CONFIG=''

define='define'
undef='undef'
smallmach='pdp11 i8086 z8000 i80286 iAPX286'
rmlist=''

: We must find out about Eunice early
eunicefix=':'
if test -f /etc/unixtovms; then
	eunicefix=/etc/unixtovms
fi
if test -f /etc/unixtovms.exe; then
	eunicefix=/etc/unixtovms.exe
fi

: list of known cpp symbols, sorted alphabetically
al="AMIX BIT_MSF BSD BSD4_3 BSD_NET2 CMU CRAY DGUX DOLPHIN DPX2"
al="$al GO32 GOULD_PN HP700 I386 I80960 I960 Lynx M68000 M68K MACH"
al="$al MIPSEB MIPSEL MSDOS MTXINU MULTIMAX MVS"
al="$al M_COFF M_I186 M_I286 M_I386 M_I8086 M_I86 M_I86SM"
al="$al M_SYS3 M_SYS5 M_SYSIII M_SYSV M_UNIX M_XENIX"
al="$al NeXT OCS88 OSF1 PARISC PC532 PORTAR POSIX"
al="$al PWB R3000 RES RISC6000 RT Sun386i SVR3 SVR4"
al="$al SYSTYPE_BSD SYSTYPE_SVR4 SYSTYPE_SYSV Tek4132 Tek4300"
al="$al UMAXV USGr4 USGr4_2 UTEK UTS UTek UnicomPBB UnicomPBD Utek"
al="$al VMS Xenix286"
al="$al _AIX _AIX32 _AIX370 _AM29000 _COFF _CRAY _CX_UX _EPI"
al="$al _IBMESA _IBMR2 _M88K _M88KBCS_TARGET"
al="$al _MIPSEB _MIPSEL _M_COFF _M_I86 _M_I86SM _M_SYS3"
al="$al _M_SYS5 _M_SYSIII _M_SYSV _M_UNIX _M_XENIX _NLS _PGC_ _R3000"
al="$al _SYSTYPE_BSD _SYSTYPE_BSD43 _SYSTYPE_SVR4"
al="$al _SYSTYPE_SYSV _SYSV3 _U370 _UNICOS"
al="$al __386BSD__ __BIG_ENDIAN __BIG_ENDIAN__ __BSD_4_4__"
al="$al __DGUX__ __DPX2__ __H3050R __H3050RX"
al="$al __LITTLE_ENDIAN __LITTLE_ENDIAN__ __MACH__"
al="$al __MIPSEB __MIPSEB__ __MIPSEL __MIPSEL__"
al="$al __Next__ __OSF1__ __PARAGON__ __PGC__ __PWB __STDC__"
al="$al __SVR4_2__ __UMAXV__"
al="$al ____386BSD____ __alpha __alpha__ __amiga"
al="$al __bsd4_2 __bsd4_2__ __bsdi__ __convex__"
al="$al __host_mips__"
al="$al __hp9000s200 __hp9000s300 __hp9000s400 __hp9000s500"
al="$al __hp9000s500 __hp9000s700 __hp9000s800"
al="$al __hppa __hpux __hp_osf __i286 __i286__ __i386 __i386__"
al="$al __i486 __i486__ __i860 __i860__ __ibmesa __ksr1__ __linux__"
al="$al __m68k __m68k__ __m88100__ __m88k __m88k__"
al="$al __mc68000 __mc68000__ __mc68020 __mc68020__"
al="$al __mc68030 __mc68030__ __mc68040 __mc68040__"
al="$al __mc88100 __mc88100__ __mips __mips__"
al="$al __motorola__ __osf__ __pa_risc __sparc__ __stdc__"
al="$al __sun __sun__ __svr3__ __svr4__ __ultrix __ultrix__"
al="$al __unix __unix__ __uxpm__ __uxps__ __vax __vax__"
al="$al _host_mips _mips _unix"
al="$al a29k aegis aix aixpc alliant alpha am29000 amiga ansi ardent"
al="$al apollo ardent att386 att3b"
al="$al bsd bsd43 bsd4_2 bsd4_3 bsd4_4 bsdi bull"
al="$al cadmus clipper concurrent convex cray ctix"
al="$al dmert encore gcos gcx gimpel gould"
al="$al hbullx20 hcx host_mips hp200 hp300 hp700 hp800"
al="$al hp9000 hp9000s300 hp9000s400 hp9000s500"
al="$al hp9000s700 hp9000s800 hp9k8 hppa hpux"
al="$al i186 i286 i386 i486 i8086"
al="$al i80960 i860 iAPX286 ibm ibm032 ibmrt interdata is68k"
al="$al ksr1 linux luna luna88k m68k m88100 m88k"
al="$al mc300 mc500 mc68000 mc68010 mc68020 mc68030"
al="$al mc68040 mc68060 mc68k mc68k32 mc700"
al="$al mc88000 mc88100 merlin mert mips mvs n16"
al="$al ncl_el ncl_mr"
al="$al news1500 news1700 news1800 news1900 news3700"
al="$al news700 news800 news900 ns16000 ns32000"
al="$al ns32016 ns32332 ns32k nsc32000 os osf"
al="$al parisc pc532 pdp11 plexus posix pyr"
al="$al riscix riscos scs sequent sgi sinix sony sony_news"
al="$al sonyrisc sparc sparclite spectrum stardent stratos"
al="$al sun sun3 sun386 svr4 sysV68 sysV88"
al="$al titan tower tower32 tower32_200 tower32_600 tower32_700"
al="$al tower32_800 tower32_850 tss u370 u3b u3b2 u3b20 u3b200"
al="$al u3b20d u3b5 ultrix unix unixpc unos vax venix vms"
al="$al xenix z8000"

groupstype=''
i_whoami=''
: default library list
libswanted=''
: set useposix=false in your hint file to disable the POSIX extension.
useposix=true
: set useopcode=false in your hint file to disable the Opcode extension.
useopcode=true
: Define several unixisms.  These can be used in hint files.
exe_ext='' 
: Extra object files, if any, needed on this platform.
archobjs=''
: Possible local include directories to search.
: Set locincpth to "" in a hint file to defeat local include searches.
locincpth="/usr/local/include /opt/local/include /usr/gnu/include"
locincpth="$locincpth /opt/gnu/include /usr/GNU/include /opt/GNU/include"
:
: no include file wanted by default
inclwanted=''

: change the next line if compiling for Xenix/286 on Xenix/386
xlibpth='/usr/lib/386 /lib/386'

: Possible local library directories to search.
loclibpth="/usr/local/lib /opt/local/lib /usr/gnu/lib"
loclibpth="$loclibpth /opt/gnu/lib /usr/GNU/lib /opt/GNU/lib"

: general looking path for locating libraries
glibpth="/shlib /usr/shlib /usr/lib/pa1.1 /usr/lib/large"
glibpth="$glibpth /lib /usr/lib $xlibpth"
glibpth="$glibpth /lib/large /usr/lib/small /lib/small"
glibpth="$glibpth /usr/ccs/lib /usr/ucblib /usr/local/lib"

: Private path used by Configure to find libraries.  Its value
: is prepended to libpth. This variable takes care of special
: machines, like the mips.  Usually, it should be empty.
plibpth=''

: full support for void wanted by default
defvoidused=15

: List of libraries we want.
libswanted='sfio net socket inet nsl nm ndbm gdbm dbm db malloc dl'
libswanted="$libswanted dld ld sun m c cposix posix ndir dir crypt"
libswanted="$libswanted ucb bsd BSD PW x"
: We probably want to search /usr/shlib before most other libraries.
: This is only used by the lib/ExtUtils/MakeMaker.pm routine extliblist.
glibpth=`echo " $glibpth " | sed -e 's! /usr/shlib ! !'`
glibpth="/usr/shlib $glibpth"
: Do not use vfork unless overridden by a hint file.
usevfork=false

: Find the basic shell for Bourne shell scripts
case "$sh" in
'')
	: SYSTYPE is for some older MIPS systems. 
	: I do not know if it is still needed.
	case "$SYSTYPE" in
	*bsd*|sys5*) xxx="/$SYSTYPE/bin/sh";;
	*) xxx='/bin/sh';;
	esac
	if test -f "$xxx"; then
		sh="$xxx"
	else
		: Build up a list and do a single loop so we can 'break' out.
		pth=`echo $PATH | sed -e "s/$p_/ /g"`
		for xxx in sh bash ksh pdksh ash; do
			for p in $pth; do
				try="$try ${p}/${xxx}"
			done
		done
		for xxx in $try; do
			if test -f "$xxx"; then
				sh="$xxx";
				echo "Your Bourne shell appears to be in $sh."
				break
			elif test -f "$xxx.exe"; then
				sh="$xxx";
				echo "Hmm.  Your Bourne shell appears to be in $sh."
				break
			fi
		done
	fi
	;;
esac

case "$sh" in
'')	cat <<EOM >&2
$me:  Fatal Error:  I can't find a Bourne Shell anywhere.  
Usually it's in /bin/sh.  How did you even get this far?
Please contact me (Chip Salzenberg) at chip@perl.com and 
we'll try to straigten this all out.
EOM
	exit 1
	;;
esac

: see if sh knows # comments
if `$sh -c '#' >/dev/null 2>&1`; then
	shsharp=true
	spitshell=cat
	echo " "
	xcat=/bin/cat
	test -f $xcat || xcat=/usr/bin/cat
	echo "#!$xcat" >try
	$eunicefix try
	chmod +x try
	./try > today
	if test -s today; then
		sharpbang='#!'
	else
		echo "#! $xcat" > try
		$eunicefix try
		chmod +x try
		./try > today
		if test -s today; then
			sharpbang='#! '
		else
			echo "Okay, let's see if #! works on this system..."
			echo "It's just a comment."
			sharpbang=': use '
		fi
	fi
else
	echo "Your $sh doesn't grok # comments--I will strip them later on."
	shsharp=false
	cd ..
	echo "exec grep -v '^[ 	]*#'" >spitshell
	chmod +x spitshell
	$eunicefix spitshell
	spitshell=`pwd`/spitshell
	cd UU
	echo "I presume that if # doesn't work, #! won't work either!"
	sharpbang=': use '
fi
rm -f try today

: figure out how to guarantee sh startup
case "$startsh" in
'') startsh=${sharpbang}${sh} ;;
*)
esac
cat >try <<EOSS
$startsh
set abc
test "$?abc" != 1
EOSS

chmod +x try
$eunicefix try
if ./try; then
	: echo "Yup, it does."
else
	echo "Hmm.  '$startsh' didn't work."
	echo "You may have to fix up the shell scripts to make sure sh runs them."
fi
rm -f try

: script used to extract .SH files with variable substitutions
cat >extract <<EOS
$startsh
EOS
cat >>extract <<'EOS'
CONFIG=true
echo "Doing variable substitutions on .SH files..."
if test -f MANIFEST; then
	shlist=`awk '{print $1}' <MANIFEST | grep '\.SH'`
	: Pick up possible extension manifests.
	for dir in ext/* ; do
		if test -f $dir/MANIFEST; then
			xxx=`awk '{print $1}' < $dir/MANIFEST | 
				sed -n "/\.SH$/ s@^@$dir/@p"`
			shlist="$shlist $xxx"
		fi
	done
	set x $shlist
else
	echo "(Looking for .SH files under the current directory.)"
	set x `find . -name "*.SH" -print`
fi
shift
case $# in
0) set x *.SH; shift;;
esac
if test ! -f $1; then
	shift
fi
for file in $*; do
	case "$file" in
	*/*)
		dir=`expr X$file : 'X\(.*\)/'`
		file=`expr X$file : 'X.*/\(.*\)'`
		(cd $dir && . ./$file)
		;;
	*)
		. ./$file
		;;
	esac
done
if test -f config_h.SH; then
	if test ! -f config.h; then
	: oops, they left it out of MANIFEST, probably, so do it anyway.
	. ./config_h.SH
	fi
fi
EOS

: produce awk script to parse command line options
cat >options.awk <<'EOF'
BEGIN {
	optstr = "dD:eEf:hKOrsSU:V";	# getopt-style specification

	len = length(optstr);
	for (i = 1; i <= len; i++) {
		c = substr(optstr, i, 1);
		if (i < len) a = substr(optstr, i + 1, 1); else a = "";
		if (a == ":") {
			arg[c] = 1;
			i++;
		}
		opt[c] = 1;
	}
}
{
	expect = 0;
	str = $0;
	if (substr(str, 1, 1) != "-") {
		printf("'%s'\n", str);
		next;
	}
	len = length($0);
	for (i = 2; i <= len; i++) {
		c = substr(str, i, 1);
		if (!opt[c]) {
			printf("-%s\n", substr(str, i));
			next;
		}
		printf("-%s\n", c);
		if (arg[c]) {
			if (i < len)
				printf("'%s'\n", substr(str, i + 1));
			else
				expect = 1;
			next;
		}
	}
}
END {
	if (expect)
		print "?";
}
EOF

: process the command line options
set X `for arg in "$@"; do echo "X$arg"; done |
	sed -e s/X// | awk -f options.awk`
eval "set $*"
shift
rm -f options.awk

: set up default values
fastread=''
reuseval=false
config_sh=''
alldone=''
error=''
silent=''
extractsh=''
override=''
knowitall=''

rm -f optdef.sh
cat >optdef.sh <<EOS
$startsh
EOS

: option parsing
while test $# -gt 0; do
	case "$1" in
	-d) shift; fastread=yes;;
	-e) shift; alldone=cont;;
	-f)
		shift
		cd ..
		if test -r "$1"; then
			config_sh="$1"
		else
			echo "$me: cannot read config file $1." >&2
			error=true
		fi
		cd UU
		shift;;
	-h) shift; error=true;;
	-r) shift; reuseval=true;;
	-s) shift; silent=true;;
	-E) shift; alldone=exit;;
	-K) shift; knowitall=true;;
	-O) shift; override=true;;
	-S) shift; extractsh=true;;
	-D)
		shift
		case "$1" in
		*=)
			echo "$me: use '-U symbol=', not '-D symbol='." >&2
			echo "$me: ignoring -D $1" >&2
			;;
		*=*) echo "$1" | \
				sed -e "s/'/'\"'\"'/g" -e "s/=\(.*\)/='\1'/" >> optdef.sh;;
		*) echo "$1='define'" >> optdef.sh;;
		esac
		shift
		;;
	-U)
		shift
		case "$1" in
		*=) echo "$1" >> optdef.sh;;
		*=*)
			echo "$me: use '-D symbol=val', not '-U symbol=val'." >&2
			echo "$me: ignoring -U $1" >&2
			;;
		*) echo "$1='undef'" >> optdef.sh;;
		esac
		shift
		;;
	-V) echo "$me generated by metaconfig 3.0 PL60." >&2
		exit 0;;
	--) break;;
	-*) echo "$me: unknown option $1" >&2; shift; error=true;;
	*) break;;
	esac
done

case "$error" in
true)
	cat >&2 <<EOM
Usage: $me [-dehrsEKOSV] [-f config.sh] [-D symbol] [-D symbol=value]
                 [-U symbol] [-U symbol=]
  -d : use defaults for all answers.
  -e : go on without questioning past the production of config.sh.
  -f : specify an alternate default configuration file.
  -h : print this help message and exit (with an error status).
  -r : reuse C symbols value if possible (skips costly nm extraction).
  -s : silent mode, only echoes questions and essential information.
  -D : define symbol to have some value:
         -D symbol         symbol gets the value 'define'
         -D symbol=value   symbol gets the value 'value'
  -E : stop at the end of questions, after having produced config.sh.
  -K : do not use unless you know what you are doing.
  -O : let -D and -U override definitions from loaded configuration file.
  -S : perform variable substitutions on all .SH files (can mix with -f)
  -U : undefine symbol:
         -U symbol    symbol gets the value 'undef'
         -U symbol=   symbol gets completely empty
  -V : print version number and exit (with a zero status).
EOM
	exit 1
	;;
esac

exec 4>&1
case "$silent" in
true) exec 1>/dev/null;;
esac

: run the defines and the undefines, if any, but leave the file out there...
touch optdef.sh
. ./optdef.sh

case "$extractsh" in
true)
	case "$config_sh" in
	'') config_sh='config.sh'; config='./config.sh';;
	/*) config="$config_sh";;
	*) config="./$config_sh";;
	esac
	echo " "
	echo "Fetching answers from $config_sh..."
	cd ..
	. $config
	test "$override" && . ./optdef.sh
	echo " "
	. ./UU/extract
	rm -rf UU
	echo "Done."
	exit 0
	;;
esac

: set package name
package=perl5
first=`echo $package | sed -e 's/^\(.\).*/\1/'`
last=`echo $package | sed -e 's/^.\(.*\)/\1/'`
case "`echo AbyZ | tr '[:lower:]' '[:upper:]' 2>/dev/null`" in
ABYZ) spackage=`echo $first | tr '[:lower:]' '[:upper:]'`$last;;
*) spackage=`echo $first | tr '[a-z]' '[A-Z]'`$last;;
esac

: Eunice requires " " instead of "", can you believe it
echo " "
: Here we go...
echo "Beginning of configuration questions for $package."

trap 'echo " "; test -d ../UU && rm -rf X $rmlist; exit 1' 1 2 3 15

: Some greps do not return status, grrr.
echo "grimblepritz" >grimble
if grep blurfldyick grimble >/dev/null 2>&1 ; then
	contains=contains
elif grep grimblepritz grimble >/dev/null 2>&1 ; then
	contains=grep
else
	contains=contains
fi
rm -f grimble
: the following should work in any shell
case "$contains" in
contains*)
	echo " "
	echo "AGH!  Grep doesn't return a status.  Attempting remedial action."
	cat >contains <<'EOSS'
grep "$1" "$2" >.greptmp && cat .greptmp && test -s .greptmp
EOSS
chmod +x contains
esac

: first determine how to suppress newline on echo command
echo " "
echo "Checking echo to see how to suppress newlines..."
(echo "hi there\c" ; echo " ") >.echotmp
if $contains c .echotmp >/dev/null 2>&1 ; then
	echo "...using -n."
	n='-n'
	c=''
else
	cat <<'EOM'
...using \c
EOM
	n=''
	c='\c'
fi
echo $n "The star should be here-->$c"
echo '*'
rm -f .echotmp

: Now test for existence of everything in MANIFEST
echo " "
if test -f ../MANIFEST; then
	echo "First let's make sure your kit is complete.  Checking..." >&4
	awk '$1 !~ /PACK[A-Z]+/ {print $1}' ../MANIFEST | split -50
	rm -f missing
	for filelist in x??; do
		(cd ..; ls `cat UU/$filelist` >/dev/null 2>>UU/missing)
	done
	if test -s missing; then
		cat missing >&4
		cat >&4 <<'EOM'

THIS PACKAGE SEEMS TO BE INCOMPLETE.

You have the option of continuing the configuration process, despite the
distinct possibility that your kit is damaged, by typing 'y'es.  If you
do, don't blame me if something goes wrong.  I advise you to type 'n'o
and contact the author (chip@perl.com).

EOM
		echo $n "Continue? [n] $c" >&4
		read ans
		case "$ans" in
		y*)
			echo "Continuing..." >&4
			rm -f missing
			;;
		*)
			echo "ABORTING..." >&4
			kill $$
			;;
		esac
	else
		echo "Looks good..." >&4
	fi
else
	echo "There is no MANIFEST file.  I hope your kit is complete !"
fi
rm -f missing x??

: compute the number of columns on the terminal for proper question formatting
case "$COLUMNS" in
'') COLUMNS='80';;
esac

: set up the echo used in my read
myecho="case \"\$xxxm\" in
'') echo $n \"\$rp $c\" >&4;;
*) case \"\$rp\" in
	'') echo $n \"[\$xxxm] $c\";;
	*)
		if test \`echo \"\$rp [\$xxxm]  \" | wc -c\` -ge $COLUMNS; then
			echo \"\$rp\" >&4
			echo $n \"[\$xxxm] $c\" >&4
		else
			echo $n \"\$rp [\$xxxm] $c\" >&4
		fi
		;;
	esac;;
esac"

: now set up to do reads with possible shell escape and default assignment
cat <<EOSC >myread
$startsh
xxxm=\$dflt
$myecho
ans='!'
case "\$fastread" in
yes) case "\$dflt" in
	'') ;;
	*) ans='';
		case "\$silent-\$rp" in
		true-) ;;
		*) echo " " >&4;;
		esac;;
	esac;;
*) case "\$silent" in
	true) case "\$rp" in
		'') ans='';;
		esac;;
	esac;;
esac
while expr "X\$ans" : "X!" >/dev/null; do
	read answ
	set x \$xxxm
	shift
	aok=''; eval ans="\\"\$answ\\"" && aok=y
	case  "\$answ" in
	"\$ans")
		case "\$ans" in
		\\&*)
			set x \`expr "X\$ans" : "X&\(.*\)\$"\`
			shift
			case "\$1" in
			-d)
				fastread=yes
				echo "(OK, I'll run with -d after this question.)" >&4
				;;
			-*)
				echo "*** Sorry, \$1 not supported yet." >&4
				;;
			esac
			$myecho
			ans=!
			;;
		"!")
			sh 1>&4
			echo " "
			$myecho
			;;
		!*)
			set x \`expr "X\$ans" : "X!\(.*\)\$"\`
			shift
			sh 1>&4 -c "\$*"
			echo " "
			$myecho
			;;
		esac;;
	*)
		case "\$aok" in
		y)
			echo "*** Substitution done -- please confirm."
			xxxm="\$ans"
			ans=\`echo $n "\$ans$c" | tr '\012' ' '\`
			xxxm="\$ans"
			ans=!
			;;
		*)
			echo "*** Error -- try again."
			ans=!
			;;
		esac
		$myecho
		;;
	esac
	case "\$ans\$xxxm\$nostick" in
	'')
		ans=!
		$myecho
		;;
	esac
done
case "\$ans" in
'') ans="\$xxxm";;
esac
EOSC

: create .config dir to save info across Configure sessions
test -d ../.config || mkdir ../.config
cat >../.config/README <<EOF
This directory created by Configure to save information that should
persist across sessions.

You may safely delete it if you wish.
EOF

: general instructions
needman=true
firsttime=true
user=`(logname) 2>/dev/null`
case "$user" in "")
	user=`whoami 2>&1` ;;
esac
if $contains "^$user\$" ../.config/instruct >/dev/null 2>&1; then
	firsttime=false
	echo " "
	rp='Would you like to see the instructions?'
	dflt=n
	. ./myread
	case "$ans" in
	[yY]*) ;;
	*) needman=false;;
	esac
fi
if $needman; then
	cat <<EOH
 
This installation shell script will examine your system and ask you questions
to determine how the perl5 package should be installed. If you get
stuck on a question, you may use a ! shell escape to start a subshell or
execute a command.  Many of the questions will have default answers in square
brackets; typing carriage return will give you the default.

On some of the questions which ask for file or directory names you are allowed
to use the ~name construct to specify the login directory belonging to "name",
even if you don't have a shell which knows about that.  Questions where this is
allowed will be marked "(~name ok)".

EOH
	rp=''
	dflt='Type carriage return to continue'
	. ./myread
	cat <<'EOH'

The prompter used in this script allows you to use shell variables and
backticks in your answers.  You may use $1, $2, etc...  to refer to the words
in the default answer, as if the default line was a set of arguments given to a
script shell.  This means you may also use $* to repeat the whole default line,
so you do not have to re-type everything to add something to the default.

Everytime there is a substitution, you will have to confirm.  If there is an
error (e.g. an unmatched backtick), the default answer will remain unchanged
and you will be prompted again.

If you are in a hurry, you may run 'Configure -d'.  This will bypass nearly all
the questions and use the computed defaults (or the previous answers if there
was already a config.sh file). Type 'Configure -h' for a list of options.
You may also start interactively and then answer '& -d' at any prompt to turn
on the non-interactive behavior for the remainder of the execution.

EOH
	. ./myread
	cat <<EOH

Much effort has been expended to ensure that this shell script will run on any
Unix system.  If despite that it blows up on yours, your best bet is to edit
Configure and run it again.  If you can't run Configure for some reason,
you'll have to generate a config.sh file by hand.  Whatever problems you
have, let me (chip@perl.com) know how I blew it.

This installation script affects things in two ways:

1) it may do direct variable substitutions on some of the files included
   in this kit.
2) it builds a config.h file for inclusion in C programs.  You may edit
   any of these files as the need arises after running this script.

If you make a mistake on a question, there is no easy way to back up to it
currently.  The easiest thing to do is to edit config.sh and rerun all the SH
files.  Configure will offer to let you do this before it runs the SH files.

EOH
	dflt='Type carriage return to continue'
	. ./myread
	case "$firsttime" in
	true) echo $user >>../.config/instruct;;
	esac
fi

: find out where common programs are
echo " "
echo "Locating common programs..." >&4
cat <<EOSC >loc
$startsh
case \$# in
0) exit 1;;
esac
thing=\$1
shift
dflt=\$1
shift
for dir in \$*; do
	case "\$thing" in
	.)
	if test -d \$dir/\$thing; then
		echo \$dir
		exit 0
	fi
	;;
	*)
	for thisthing in \$dir/\$thing; do
		: just loop through to pick last item
	done
	if test -f \$thisthing; then
		echo \$thisthing
		exit 0
	elif test -f \$dir/\$thing.exe; then
		: on Eunice apparently
		echo \$dir/\$thing
		exit 0
	fi
	;;
	esac
done
echo \$dflt
exit 1
EOSC
chmod +x loc
$eunicefix loc
loclist="
awk
cat
comm
cp
echo
expr
find
grep
ls
mkdir
rm
sed
sort
touch
tr
uniq
"
trylist="
Mcc
byacc
cpp
csh
date
egrep
gzip
less
line
ln
more
nroff
perl
pg
sendmail
test
uname
zip
"
pth=`echo $PATH | sed -e "s/$p_/ /g"`
pth="$pth /lib /usr/lib"
for file in $loclist; do
	xxx=`./loc $file $file $pth`
	eval $file=$xxx
	eval _$file=$xxx
	case "$xxx" in
	/*)
		echo $file is in $xxx.
		;;
	?:[\\/]*)
		echo $file is in $xxx.
		;;
	*)
		echo "I don't know where '$file' is, and my life depends on it." >&4
		echo "Go find a public domain implementation or fix your PATH setting!" >&4
		exit 1
		;;
	esac
done
echo " "
echo "Don't worry if any of the following aren't found..."
say=offhand
for file in $trylist; do
	xxx=`./loc $file $file $pth`
	eval $file=$xxx
	eval _$file=$xxx
	case "$xxx" in
	/*)
		echo $file is in $xxx.
		;;
	?:[\\/]*)
		echo $file is in $xxx.
		;;
	*)
		echo "I don't see $file out there, $say."
		say=either
		;;
	esac
done
case "$egrep" in
egrep)
	echo "Substituting grep for egrep."
	egrep=$grep
	;;
esac
case "$ln" in
ln)
	echo "Substituting cp for ln."
	ln=$cp
	;;
esac
case "$test" in
test)
	echo "Hopefully test is built into your sh."
	;;
*)
	if `sh -c "PATH= test true" >/dev/null 2>&1`; then
		echo "Using the test built into your sh."
		test=test
		_test=test
	fi
	;;
esac
case "$echo" in
echo)
	echo "Hopefully echo is built into your sh."
	;;
'') ;;
*)
	echo " "
echo "Checking compatibility between $echo and builtin echo (if any)..." >&4
	$echo $n "hi there$c" >foo1
	echo $n "hi there$c" >foo2
	if cmp foo1 foo2 >/dev/null 2>&1; then
		echo "They are compatible.  In fact, they may be identical."
	else
		case "$n" in
		'-n') n='' c='\c';;
		*) n='-n' c='';;
		esac
		cat <<FOO
They are not compatible!  You are probably running ksh on a non-USG system.
I'll have to use $echo instead of the builtin, since Bourne shell doesn't
have echo built in and we may have to run some Bourne shell scripts.  That
means I'll have to use '$n$c' to suppress newlines now.  Life is ridiculous.

FOO
		$echo $n "The star should be here-->$c"
		$echo "*"
	fi
	$rm -f foo1 foo2
	;;
esac

: determine whether symbolic links are supported
echo " "
$touch blurfl
if $ln -s blurfl sym > /dev/null 2>&1 ; then
	echo "Symbolic links are supported." >&4
	lns="$ln -s"
else
	echo "Symbolic links are NOT supported." >&4
	lns="$ln"
fi
$rm -f blurfl sym

: see whether [:lower:] and [:upper:] are supported character classes
echo " "
up='[A-Z]'
low='[a-z]'
case "`echo AbyZ | $tr '[:lower:]' '[:upper:]' 2>/dev/null`" in
ABYZ)
	echo "Good, your tr supports [:lower:] and [:upper:] to convert case." >&4
	up='[:upper:]'
	low='[:lower:]'
	;;
*)
	echo "Your tr only supports [a-z] and [A-Z] to convert case." >&4
	;;
esac
: set up the translation script tr, must be called with ./tr of course
cat >tr <<EOSC
$startsh
case "\$1\$2" in
'[A-Z][a-z]') exec $tr '$up' '$low';;
'[a-z][A-Z]') exec $tr '$low' '$up';;
esac
exec $tr "\$@"
EOSC
chmod +x tr
$eunicefix tr

: Try to determine whether config.sh was made on this system
case "$config_sh" in
'')
myuname=`( ($uname -a) 2>/dev/null || hostname) 2>&1`
myuname=`echo $myuname | $sed -e 's/^[^=]*=//' -e 's/\///g' | \
	./tr '[A-Z]' '[a-z]' | tr '\012' ' '`
newmyuname="$myuname"
dflt=n
case "$knowitall" in
'')
	if test -f ../config.sh; then
		if $contains myuname= ../config.sh >/dev/null 2>&1; then
			eval "`grep myuname= ../config.sh`"
		fi
		if test "X$myuname" = "X$newmyuname"; then
			dflt=y
		fi
	fi
	;;
*) dflt=y;;
esac

: Get old answers from old config file if Configure was run on the
: same system, otherwise use the hints.
hint=default
cd ..
if test -f config.sh; then
	echo " "
	rp="I see a config.sh file.  Shall I use it to set the defaults?"
	. UU/myread
	case "$ans" in
	n*|N*) echo "OK, I'll ignore it."; mv config.sh config.sh.old;;
	*)  echo "Fetching default answers from your old config.sh file..." >&4
		tmp_n="$n"
		tmp_c="$c"
		tmp_sh="$sh"
		. ./config.sh
		cp config.sh UU
		n="$tmp_n"
		c="$tmp_c"
		: Older versions did not always set $sh.  Catch re-use of such
		: an old config.sh.
		case "$sh" in
		'') sh="$tmp_sh" ;;
		esac
		hint=previous
		;;
	esac
fi
if test ! -f config.sh; then
	$cat <<EOM

First time through, eh?  I have some defaults handy for the following systems:

EOM
	cd hints; ls -C *.sh | $sed 's/\.sh/   /g' >&4
	dflt=''
	: Half the following guesses are probably wrong... If you have better
	: tests or hints, please send them to chip@perl.com
	: The metaconfig authors would also appreciate a copy...
	$test -f /irix && osname=irix
	$test -f /xenix && osname=sco_xenix
	$test -f /dynix && osname=dynix
	$test -f /dnix && osname=dnix
	$test -f /lynx.os && osname=lynxos
	$test -f /unicos && osname=unicos && osvers=`$uname -r`
	$test -f /unicosmk.ar && osname=unicosmk && osvers=`$uname -r`
	$test -f /bin/mips && /bin/mips && osname=mips
	$test -d /NextApps && set X `hostinfo | grep 'NeXT Mach.*:' | \
		$sed -e 's/://' -e 's/\./_/'` && osname=next && osvers=$4
	$test -d /usr/apollo/bin && osname=apollo
	$test -f /etc/saf/_sactab && osname=svr4
	$test -d /usr/include/minix && osname=minix
	if $test -d /MachTen; then
		osname=machten 
		if $test -x /sbin/version; then
			osvers=`/sbin/version | $awk '{print $2}' | 
			$sed -e 's/[A-Za-z]$//'`
		elif $test -x /usr/etc/version; then
			osvers=`/usr/etc/version | $awk '{print $2}' | 
			$sed -e 's/[A-Za-z]$//'`
		else
			osvers="$2.$3"
		fi
	fi
	if $test -f $uname; then
		set X $myuname
		shift

		case "$5" in
		fps*) osname=fps ;;
		mips*)
			case "$4" in
			umips) osname=umips ;;
			*) osname=mips ;;
			esac;;
		[23]100) osname=mips ;;
		next*) osname=next ;;
		i386*)
			if $test -f /etc/kconfig; then
				osname=isc
				if test "$lns" = "ln -s"; then
					osvers=4
				elif $contains _SYSV3 /usr/include/stdio.h > /dev/null 2>&1 ; then
					osvers=3
				elif $contains _POSIX_SOURCE /usr/include/stdio.h > /dev/null 2>&1 ; then
					osvers=2
				fi
			fi
			;;
		esac

		case "$1" in
		aix) osname=aix
			tmp=`( (oslevel) 2>/dev/null || echo "not found") 2>&1`
			case "$tmp" in
			'not found') osvers="$4"."$3" ;;
			'<3240'|'<>3240') osvers=3.2.0 ;;
			'=3240'|'>3240'|'<3250'|'<>3250') osvers=3.2.4 ;;
			'=3250'|'>3250') osvers=3.2.5 ;;
			*) osvers=$tmp;;
			esac
			;;
		*dc.osx) osname=dcosx
			osvers="$3"
			;;
		dnix) osname=dnix
			osvers="$3"
			;;
		domainos) osname=apollo
			osvers="$3"
			;;
		dgux) osname=dgux 
			osvers="$3"
			;;
		dynixptx*) osname=dynixptx
			osvers="$3"
			;;
		freebsd) osname=freebsd 
			osvers="$3" ;;
		genix) osname=genix ;;
		hp*) osname=hpux 
			case "$3" in
			*.08.*) osvers=9 ;;
			*.09.*) osvers=9 ;;
			*.10.*) osvers=10 ;;
			*)	osvers="$3" ;;
			esac
			;;
		irix*) osname=irix
			case "$3" in
			4*) osvers=4 ;;
			5*) osvers=5 ;;
			*)	osvers="$3" ;;
			esac
			;;
		linux) osname=linux
			case "$3" in
			*)	osvers="$3" ;;
			esac
			;;
		netbsd*) osname=netbsd 
			osvers="$3"
			;;
		news-os) osvers="$3"
			case "$3" in
			4*) osname=newsos4 ;;
			*) osname=newsos ;;
			esac
			;;
		bsd386) osname=bsd386
			osvers=`$uname -r`
			;;
		powerux | power_ux | powermax_os | powermaxos | \
		powerunix | power_unix) osname=powerux
			osvers="$3"
			;;
		next*) osname=next ;;
		solaris) osname=solaris
			case "$3" in
			5*) osvers=`echo $3 | $sed 's/^5/2/g'` ;;
			*)	osvers="$3" ;;
			esac
			;;
		sunos) osname=sunos
			case "$3" in
			5*) osname=solaris
				osvers=`echo $3 | $sed 's/^5/2/g'` ;;
			*)	osvers="$3" ;;
			esac
			;;
		titanos) osname=titanos
			case "$3" in
			1*) osvers=1 ;;
			2*) osvers=2 ;;
			3*) osvers=3 ;;
			4*) osvers=4 ;;
			*)	osvers="$3" ;;
			esac
			;;
		ultrix) osname=ultrix
			osvers="$3"
			;;
		osf1|mls+)	case "$5" in
				alpha)
					osname=dec_osf
					osvers=`echo "$3" | sed 's/^[vt]//'`
					;;
			hp*)	osname=hp_osf1	;;
			mips)	osname=mips_osf1 ;;
			esac
			;;
		uts) osname=uts 
			osvers="$3"
			;;
		qnx) osname=qnx
			osvers="$4"
			;;
		$2) case "$osname" in
			*isc*) ;;
			*freebsd*) ;;
			svr*)
				: svr4.x or possibly later
				case "svr$3" in	
				${osname}*)
					osname=svr$3
					osvers=$4
					;;
				esac
				case "$osname" in
				svr4.0)
					: Check for ESIX
					if test -f /stand/boot ; then
						eval `grep '^INITPROG=[a-z/0-9]*$' /stand/boot`
						if test -n "$INITPROG" -a -f "$INITPROG"; then
			isesix=`strings -a $INITPROG|grep 'ESIX SYSTEM V/386 Release 4.0'`
							if test -n "$isesix"; then
								osname=esix4
							fi
						fi
					fi
					;;
				esac
				;;
			*)	if test -f /etc/systemid; then
					osname=sco
					set `echo $3 | $sed 's/\./ /g'` $4
					if $test -f sco_$1_$2_$3.sh; then
						osvers=$1.$2.$3
					elif $test -f sco_$1_$2.sh; then
						osvers=$1.$2
					elif $test -f sco_$1.sh; then
						osvers=$1
					fi
				else
					case "$osname" in
					'') : Still unknown.  Probably a generic Sys V.
						osname="sysv"
						osvers="$3"
						;;
					esac
				fi
				;;
			esac
			;;
		*)	case "$osname" in
			'') : Still unknown.  Probably a generic BSD.
				osname="$1"
				osvers="$3"
				;;
			esac
			;;
		esac
	else
		if test -f /vmunix -a -f newsos4.sh; then
			(what /vmunix | ../UU/tr '[A-Z]' '[a-z]') > ../UU/kernel.what 2>&1
			if $contains news-os ../UU/kernel.what >/dev/null 2>&1; then
				osname=newsos4
			fi
			$rm -f ../UU/kernel.what
		elif test -d c:/.; then
			set X $myuname
			osname=os2
			osvers="$5"
		fi
	fi
	
	: Now look for a hint file osname_osvers, unless one has been
	: specified already.
	case "$hintfile" in
	''|' ')
		file=`echo "${osname}_${osvers}" | $sed -e 's@\.@_@g' -e 's@_$@@'`
		: Also try without trailing minor version numbers.
		xfile=`echo $file | $sed -e 's@_[^_]*$@@'`
		xxfile=`echo $xfile | $sed -e 's@_[^_]*$@@'`
		xxxfile=`echo $xxfile | $sed -e 's@_[^_]*$@@'`
		xxxxfile=`echo $xxxfile | $sed -e 's@_[^_]*$@@'`
		case "$file" in
		'') dflt=none ;;
		*)  case "$osvers" in
			'') dflt=$file
				;;
			*)  if $test -f $file.sh ; then
					dflt=$file
				elif $test -f $xfile.sh ; then
					dflt=$xfile
				elif $test -f $xxfile.sh ; then
					dflt=$xxfile
				elif $test -f $xxxfile.sh ; then
					dflt=$xxxfile
				elif $test -f $xxxxfile.sh ; then
					dflt=$xxxxfile
				elif $test -f "${osname}.sh" ; then
					dflt="${osname}"
				else
					dflt=none
				fi
				;;
			esac
			;;
		esac
		;;
	*)
		dflt=`echo $hintfile | $sed 's/\.sh$//'`
		;;
	esac

	$cat <<EOM

You may give one or more space-separated answers, or "none" if appropriate.
If your OS version has no hints, DO NOT give a wrong version -- say "none".

EOM
	rp="Which of these apply, if any?"
	. ../UU/myread
	tans=$ans
	for file in $tans; do
		if $test -f $file.sh; then
			. ./$file.sh
			$cat $file.sh >> ../UU/config.sh
		elif $test X$tans = X -o X$tans = Xnone ; then
			: nothing
		else
			: Give one chance to correct a possible typo.
			echo "$file.sh does not exist"
			dflt=$file
			rp="hint to use instead?"
			. ../UU/myread
			for file in $ans; do
				if $test -f "$file.sh"; then
					. ./$file.sh
					$cat $file.sh >> ../UU/config.sh
				elif $test X$ans = X -o X$ans = Xnone ; then
					: nothing
				else
					echo "$file.sh does not exist -- ignored."
				fi
			done
		fi
	done

	hint=recommended
	: Remember our hint file for later.
	if $test -f "$file.sh" ; then
		hintfile="$file"
	else
		hintfile=''
	fi

	cd ..
fi
cd UU
;;
*)
	echo " "
	echo "Fetching default answers from $config_sh..." >&4
	tmp_n="$n"
	tmp_c="$c"
	cd ..
	cp $config_sh config.sh 2>/dev/null
	chmod +w config.sh
	. ./config.sh
	cd UU
	cp ../config.sh .
	n="$tmp_n"
	c="$tmp_c"
	hint=previous
	;;
esac
test "$override" && . ./optdef.sh
myuname="$newmyuname"

: Restore computed paths
for file in $loclist $trylist; do
	eval $file="\$_$file"
done

cat << EOM

Configure uses the operating system name and version to set some defaults.
The default value is probably right if the name rings a bell. Otherwise,
since spelling matters for me, either accept the default or answer "none"
to leave it blank.

EOM
case "$osname" in
	''|' ')
		case "$hintfile" in
		''|' '|none) dflt=none ;;
		*)  dflt=`echo $hintfile | $sed -e 's/\.sh$//' -e 's/_.*$//'` ;;
		esac
		;;
	*) dflt="$osname" ;;
esac
rp="Operating system name?"
. ./myread
case "$ans" in
none)  osname='' ;;
*) osname=`echo "$ans" | $sed -e 's/[ 	][	]*/_/g' | ./tr '[A-Z]' '[a-z]'`;;
esac
echo " "
case "$osvers" in
	''|' ')
		case "$hintfile" in
		''|' '|none) dflt=none ;;
		*)	dflt=`echo $hintfile | $sed -e 's/\.sh$//' -e 's/^[^_]*//'`
			dflt=`echo $dflt | $sed -e 's/^_//' -e 's/_/./g'`
			case "$dflt" in
			''|' ') dflt=none ;;
			esac
			;;
		esac
		;;
	*) dflt="$osvers" ;;
esac
rp="Operating system version?"
. ./myread
case "$ans" in
none)  osvers='' ;;
*) osvers="$ans" ;;
esac



: who configured the system
cf_time=`LC_ALL=C; export LC_ALL; $date 2>&1`
cf_by=`(logname) 2>/dev/null`
case "$cf_by" in "")
	cf_by=`(whoami) 2>/dev/null`
	case "$cf_by" in "")
		cf_by=unknown ;;
	esac ;;
esac

: determine the architecture name
echo " "
if xxx=`./loc arch blurfl $pth`; $test -f "$xxx"; then
	tarch=`arch`"-$osname"
elif xxx=`./loc uname blurfl $pth`; $test -f "$xxx" ; then
	if uname -m > tmparch 2>&1 ; then
		tarch=`$sed -e 's/ *$//' -e 's/ /_/g' \
			-e 's/$/'"-$osname/" tmparch`
	else
		tarch="$osname"
	fi
	$rm -f tmparch
else
	tarch="$osname"
fi
case "$myarchname" in
''|"$tarch") ;;
*)
	echo "(Your architecture name used to be $myarchname.)"
	archname=''
	;;
esac
case "$archname" in
'') dflt="$tarch";;
*) dflt="$archname";;
esac
rp='What is your architecture name'
. ./myread
archname="$ans"
myarchname="$tarch"

: is AFS running?
echo " "
case "$afs" in
$define|true)	afs=true ;;
$undef|false)	afs=false ;;
*)	if test -d /afs; then
		afs=true
	else
		afs=false
	fi
	;;
esac
if $afs; then
	echo "AFS may be running... I'll be extra cautious then..." >&4
else
	echo "AFS does not seem to be running..." >&4
fi

: decide how portable to be.  Allow command line overrides.
case "$d_portable" in
"$undef") ;;
*)	d_portable="$define" ;;
esac

: set up shell script to do ~ expansion
cat >filexp <<EOSS
$startsh
: expand filename
case "\$1" in
 ~/*|~)
	echo \$1 | $sed "s|~|\${HOME-\$LOGDIR}|"
	;;
 ~*)
	if $test -f /bin/csh; then
		/bin/csh -f -c "glob \$1"
		failed=\$?
		echo ""
		exit \$failed
	else
		name=\`$expr x\$1 : '..\([^/]*\)'\`
		dir=\`$sed -n -e "/^\${name}:/{s/^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:\([^:]*\).*"'\$'"/\1/" -e p -e q -e '}' </etc/passwd\`
		if $test ! -d "\$dir"; then
			me=\`basename \$0\`
			echo "\$me: can't locate home directory for: \$name" >&2
			exit 1
		fi
		case "\$1" in
		*/*)
			echo \$dir/\`$expr x\$1 : '..[^/]*/\(.*\)'\`
			;;
		*)
			echo \$dir
			;;
		esac
	fi
	;;
*)
	echo \$1
	;;
esac
EOSS
chmod +x filexp
$eunicefix filexp

: now set up to get a file name
cat <<EOS >getfile
$startsh
EOS
cat <<'EOSC' >>getfile
tilde=''
fullpath=''
already=''
skip=''
none_ok=''
exp_file=''
nopath_ok=''
orig_rp="$rp"
orig_dflt="$dflt"

case "$fn" in
*\(*)
	expr $fn : '.*(\(.*\)).*' | tr ',' '\012' >getfile.ok
	fn=`echo $fn | sed 's/(.*)//'`
	;;
esac

case "$fn" in
*:*)
	loc_file=`expr $fn : '.*:\(.*\)'`
	fn=`expr $fn : '\(.*\):.*'`
	;;
esac

case "$fn" in
*~*) tilde=true;;
esac
case "$fn" in
*/*) fullpath=true;;
esac
case "$fn" in
*+*) skip=true;;
esac
case "$fn" in
*n*) none_ok=true;;
esac
case "$fn" in
*e*) exp_file=true;;
esac
case "$fn" in
*p*) nopath_ok=true;;
esac

case "$fn" in
*f*) type='File';;
*d*) type='Directory';;
*l*) type='Locate';;
esac

what="$type"
case "$what" in
Locate) what='File';;
esac

case "$exp_file" in
'')
	case "$d_portable" in
	"$define") ;;
	*) exp_file=true;;
	esac
	;;
esac

cd ..
while test "$type"; do
	redo=''
	rp="$orig_rp"
	dflt="$orig_dflt"
	case "$tilde" in
	true) rp="$rp (~name ok)";;
	esac
	. UU/myread
	if test -f UU/getfile.ok && \
		$contains "^$ans\$" UU/getfile.ok >/dev/null 2>&1
	then
		value="$ans"
		ansexp="$ans"
		break
	fi
	case "$ans" in
	none)
		value=''
		ansexp=''
		case "$none_ok" in
		true) type='';;
		esac
		;;
	*)
		case "$tilde" in
		'') value="$ans"
			ansexp="$ans";;
		*)
			value=`UU/filexp $ans`
			case $? in
			0)
				if test "$ans" != "$value"; then
					echo "(That expands to $value on this system.)"
				fi
				;;
			*) value="$ans";;
			esac
			ansexp="$value"
			case "$exp_file" in
			'') value="$ans";;
			esac
			;;
		esac
		case "$fullpath" in
		true)
			case "$ansexp" in
			/*) value="$ansexp" ;;
			*)
				redo=true
				case "$already" in
				true)
				echo "I shall only accept a full path name, as in /bin/ls." >&4
				echo "Use a ! shell escape if you wish to check pathnames." >&4
					;;
				*)
				echo "Please give a full path name, starting with slash." >&4
					case "$tilde" in
					true)
				echo "Note that using ~name is ok provided it expands well." >&4
						already=true
						;;
					esac
				esac
				;;
			esac
			;;
		esac
		case "$redo" in
		'')
			case "$type" in
			File)
				if test -f "$ansexp"; then
					type=''
				elif test -r "$ansexp" || (test -h "$ansexp") >/dev/null 2>&1
				then
					echo "($value is not a plain file, but that's ok.)"
					type=''
				fi
				;;
			Directory)
				if test -d "$ansexp"; then
					type=''
				fi
				;;
			Locate)
				if test -d "$ansexp"; then
					echo "(Looking for $loc_file in directory $value.)"
					value="$value/$loc_file"
					ansexp="$ansexp/$loc_file"
				fi
				if test -f "$ansexp"; then
					type=''
				fi
				case "$nopath_ok" in
				true)	case "$value" in
					*/*) ;;
					*)	echo "Assuming $value will be in people's path."
						type=''
						;;
					esac
					;;
				esac
				;;
			esac

			case "$skip" in
			true) type='';
			esac

			case "$type" in
			'') ;;
			*)
				if test "$fastread" = yes; then
					dflt=y
				else
					dflt=n
				fi
				rp="$what $value doesn't exist.  Use that name anyway?"
				. UU/myread
				dflt=''
				case "$ans" in
				y*) type='';;
				*) echo " ";;
				esac
				;;
			esac
			;;
		esac
		;;
	esac
done
cd UU
ans="$value"
rp="$orig_rp"
dflt="$orig_dflt"
rm -f getfile.ok
EOSC

: determine root of directory hierarchy where package will be installed.
case "$prefix" in
'')
	dflt=`./loc . /usr/local /usr/local /local /opt /usr`
	;;
*)
	dflt="$prefix"
	;;
esac
$cat <<EOM

By default, $package will be installed in $dflt/bin, manual
pages under $dflt/man, etc..., i.e. with $dflt as prefix for
all installation directories. Typically set to /usr/local, but you
may choose /usr if you wish to install $package among your system
binaries. If you wish to have binaries under /bin but manual pages
under /usr/local/man, that's ok: you will be prompted separately
for each of the installation directories, the prefix being only used
to set the defaults.

EOM
fn=d~
rp='Installation prefix to use?'
. ./getfile
oldprefix=''
case "$prefix" in
'') ;;
*)
	case "$ans" in
	"$prefix") ;;
	*) oldprefix="$prefix";;
	esac
	;;
esac
prefix="$ans"
prefixexp="$ansexp"

: set the prefixit variable, to compute a suitable default value
prefixit='case "$3" in
""|none)
	case "$oldprefix" in
	"") eval "$1=\"\$$2\"";;
	*)
		case "$3" in
		"") eval "$1=";;
		none)
			eval "tp=\"\$$2\"";
			case "$tp" in
			""|" ") eval "$1=\"\$$2\"";;
			*) eval "$1=";;
			esac;;
		esac;;
	esac;;
*)
	eval "tp=\"$oldprefix-\$$2-\""; eval "tp=\"$tp\"";
	case "$tp" in
	--|/*--|\~*--) eval "$1=\"$prefix/$3\"";;
	/*-$oldprefix/*|\~*-$oldprefix/*)
		eval "$1=\`echo \$$2 | sed \"s,^$oldprefix,$prefix,\"\`";;
	*) eval "$1=\"\$$2\"";;
	esac;;
esac'

: determine where private library files go
: Usual default is /usr/local/lib/perl5.  Also allow things like 
: /opt/perl/lib, since /opt/perl/lib/perl5 would be redundant.
case "$prefix" in
*perl*) set dflt privlib lib ;;
*)	 set dflt privlib lib/$package ;;
esac
eval $prefixit
$cat <<EOM

There are some auxiliary files for $package that need to be put into a
private library directory that is accessible by everyone.

EOM
fn=d~+
rp='Pathname where the private library files will reside?'
. ./getfile
if $test "X$privlibexp" != "X$ansexp"; then
	installprivlib=''
fi
privlib="$ans"
privlibexp="$ansexp"
if $afs; then
	$cat <<EOM

Since you are running AFS, I need to distinguish the directory in which
private files reside from the directory in which they are installed (and from
which they are presumably copied to the former directory by occult means).

EOM
	case "$installprivlib" in
	'') dflt=`echo $privlibexp | sed 's#^/afs/#/afs/.#'`;;
	*) dflt="$installprivlib";;
	esac
	fn=de~
	rp='Where will private files be installed?'
	. ./getfile
	installprivlib="$ans"
else
	installprivlib="$privlibexp"
fi

: set the base revision
baserev=5.0

: get the patchlevel
echo " "
echo "Getting the current patchlevel..." >&4
if $test -r ../patchlevel.h;then
	patchlevel=`awk '/PATCHLEVEL/ {print $3}' ../patchlevel.h`
	subversion=`awk '/SUBVERSION/ {print $3}' ../patchlevel.h`
else
	patchlevel=0
	subversion=0
fi
$echo $n "(You have $package" $c
case "$package" in
"*$baserev")	;;
*)		$echo $n " $baserev" $c ;;
esac
$echo $n " patchlevel $patchlevel" $c
test 0 -eq "$subversion" || $echo $n " subversion $subversion" $c
echo ".)"

: set the prefixup variable, to restore leading tilda escape
prefixup='case "$prefixexp" in
"$prefix") ;;
*) eval "$1=\`echo \$$1 | sed \"s,^$prefixexp,$prefix,\"\`";;
esac'

: determine where public architecture dependent libraries go
set archlib archlib
eval $prefixit
case "$archlib" in
'')
    case "$privlib" in
    '')	dflt=`./loc . "." $prefixexp/lib /usr/local/lib /usr/lib /lib`
	set dflt
	eval $prefixup
	;;
    *)	if test 0 -eq "$subversion"; then
	    version=`LC_ALL=C; export LC_ALL; \
		     echo $baserev $patchlevel | \
		     $awk '{ printf "%.3f\n", $1 + $2/1000.0 }'`
	else
	    version=`LC_ALL=C; export LC_ALL; \
		     echo $baserev $patchlevel $subversion | \
		     $awk '{ printf "%.5f\n", $1 + $2/1000.0 + $3/100000.0 }'`
	fi
	dflt="$privlib/$archname/$version"
	;;
    esac
    ;;
*)
    dflt="$archlib"
    ;;
esac
cat <<EOM

$spackage contains architecture-dependent library files.  If you are
sharing libraries in a heterogeneous environment, you might store
these files in a separate location.  Otherwise, you can just include
them with the rest of the public library files.

EOM
fn=d+~
rp='Where do you want to put the public architecture-dependent libraries?'
. ./getfile
archlib="$ans"
archlibexp="$ansexp"

if $afs; then
	$cat <<EOM

Since you are running AFS, I need to distinguish the directory in
which architecture-dependent library files reside from the directory
in which they are installed (and from which they are presumably copied
to the former directory by occult means).

EOM
	case "$installarchlib" in
	'') dflt=`echo $archlibexp | sed 's#^/afs/#/afs/.#'`;;
	*) dflt="$installarchlib";;
	esac
	fn=de~
	rp='Where will architecture-dependent library files be installed?'
	. ./getfile
	installarchlib="$ans"
else
	installarchlib="$archlibexp"
fi
if $test X"$archlib" = X"$privlib"; then
	d_archlib="$undef"
else
	d_archlib="$define"
fi

: set up the script used to warn in case of inconsistency
cat <<EOS >whoa
$startsh
EOS
cat <<'EOSC' >>whoa
dflt=y
echo " "
echo "*** WHOA THERE!!! ***" >&4
echo "    The $hint value for \$$var on this machine was \"$was\"!" >&4
rp="    Keep the $hint value?"
. ./myread
case "$ans" in
y) td=$was; tu=$was;;
esac
EOSC

: function used to set $1 to $val
setvar='var=$1; eval "was=\$$1"; td=$define; tu=$undef;
case "$val$was" in
$define$undef) . ./whoa; eval "$var=\$td";;
$undef$define) . ./whoa; eval "$var=\$tu";;
*) eval "$var=$val";;
esac'

$cat <<EOM

Perl 5.004 can be compiled for binary compatibility with 5.003.
If you decide to do so, you will be able to continue using any
extensions that were compiled for Perl 5.003.  However, binary
compatibility forces Perl to expose some of its internal symbols
in the same way that 5.003 did.  So you may have symbol conflicts
if you embed a binary-compatible Perl in other programs.

EOM
case "$d_bincompat3" in
"$undef") dflt=n ;;
*) dflt=y ;;
esac
rp='Binary compatibility with Perl 5.003?'
. ./myread
case "$ans" in
y*) val="$define" ;;
*)  val="$undef" ;;
esac
set d_bincompat3
eval $setvar
case "$d_bincompat3" in
"$define") bincompat3=y ;;
*) bincompat3=n ;;
esac

: make some quick guesses about what we are up against
echo " "
$echo $n "Hmm...  $c"
echo exit 1 >bsd
echo exit 1 >usg
echo exit 1 >v7
echo exit 1 >osf1
echo exit 1 >eunice
echo exit 1 >xenix
echo exit 1 >venix
echo exit 1 >os2
d_bsd="$undef"
$cat /usr/include/signal.h /usr/include/sys/signal.h >foo 2>/dev/null
if test -f /osf_boot || $contains 'OSF/1' /usr/include/ctype.h >/dev/null 2>&1
then
	echo "Looks kind of like an OSF/1 system, but we'll see..."
	echo exit 0 >osf1
elif test `echo abc | tr a-z A-Z` = Abc ; then
	xxx=`./loc addbib blurfl $pth`
	if $test -f $xxx; then
	echo "Looks kind of like a USG system with BSD features, but we'll see..."
		echo exit 0 >bsd
		echo exit 0 >usg
	else
		if $contains SIGTSTP foo >/dev/null 2>&1 ; then
			echo "Looks kind of like an extended USG system, but we'll see..."
		else
			echo "Looks kind of like a USG system, but we'll see..."
		fi
		echo exit 0 >usg
	fi
elif $contains SIGTSTP foo >/dev/null 2>&1 ; then
	echo "Looks kind of like a BSD system, but we'll see..."
	d_bsd="$define"
	echo exit 0 >bsd
else
	echo "Looks kind of like a Version 7 system, but we'll see..."
	echo exit 0 >v7
fi
case "$eunicefix" in
*unixtovms*)
	$cat <<'EOI'
There is, however, a strange, musty smell in the air that reminds me of
something...hmm...yes...I've got it...there's a VMS nearby, or I'm a Blit.
EOI
	echo exit 0 >eunice
	d_eunice="$define"
: it so happens the Eunice I know will not run shell scripts in Unix format
	;;
*)
	echo " "
	echo "Congratulations.  You aren't running Eunice."
	d_eunice="$undef"
	;;
esac
: Detect OS2.  The p_ variable is set above in the Head.U unit.
case "$p_" in
:) ;;
*)
	$cat <<'EOI'
I have the feeling something is not exactly right, however...don't tell me...
lemme think...does HAL ring a bell?...no, of course, you're only running OS/2!
EOI
	echo exit 0 >os2
	;;
esac
if test -f /xenix; then
	echo "Actually, this looks more like a XENIX system..."
	echo exit 0 >xenix
	d_xenix="$define"
else
	echo " "
	echo "It's not Xenix..."
	d_xenix="$undef"
fi
chmod +x xenix
$eunicefix xenix
if test -f /venix; then
	echo "Actually, this looks more like a VENIX system..."
	echo exit 0 >venix
else
	echo " "
	if ./xenix; then
		: null
	else
		echo "Nor is it Venix..."
	fi
fi
chmod +x bsd usg v7 osf1 eunice xenix venix os2
$eunicefix bsd usg v7 osf1 eunice xenix venix os2
$rm -f foo

: see if setuid scripts can be secure
$cat <<EOM

Some kernels have a bug that prevents setuid #! scripts from being
secure.  Some sites have disabled setuid #! scripts because of this.

First let's decide if your kernel supports secure setuid #! scripts.
(If setuid #! scripts would be secure but have been disabled anyway,
don't say that they are secure if asked.)

EOM

val="$undef"
if $test -d /dev/fd; then
	echo "#!$ls" >reflect
	chmod +x,u+s reflect
	./reflect >flect 2>&1
	if $contains "/dev/fd" flect >/dev/null; then
		echo "Congratulations, your kernel has secure setuid scripts!" >&4
		val="$define"
	else
		$cat <<EOM
If you are not sure if they are secure, I can check but I'll need a
username and password different from the one you are using right now.
If you don't have such a username or don't want me to test, simply
enter 'none'.

EOM
		rp='Other username to test security of setuid scripts with?'
		dflt='none'
		. ./myread
		case "$ans" in
		n|none)
			case "$d_suidsafe" in
			'')	echo "I'll assume setuid scripts are *not* secure." >&4
				dflt=n;;
			"$undef")
				echo "Well, the $hint value is *not* secure." >&4
				dflt=n;;
			*)	echo "Well, the $hint value *is* secure." >&4
				dflt=y;;
			esac
			;;
		*)
			$rm -f reflect flect
			echo "#!$ls" >reflect
			chmod +x,u+s reflect
			echo >flect
			chmod a+w flect
			echo '"su" will (probably) prompt you for '"$ans's password."
			su $ans -c './reflect >flect'
			if $contains "/dev/fd" flect >/dev/null; then
				echo "Okay, it looks like setuid scripts are secure." >&4
				dflt=y
			else
				echo "I don't think setuid scripts are secure." >&4
				dflt=n
			fi
			;;
		esac
		rp='Does your kernel have *secure* setuid scripts?'
		. ./myread
		case "$ans" in
		[yY]*)	val="$define";;
		*)	val="$undef";;
		esac
	fi
else
	echo "I don't think setuid scripts are secure (no /dev/fd directory)." >&4
	echo "(That's for file descriptors, not floppy disks.)"
	val="$undef"
fi
set d_suidsafe
eval $setvar

$rm -f reflect flect

: now see if they want to do setuid emulation
echo " "
val="$undef"
case "$d_suidsafe" in
"$define")
	val="$undef"
	echo "No need to emulate SUID scripts since they are secure here." >& 4
	;;
*)
	$cat <<EOM
Some systems have disabled setuid scripts, especially systems where
setuid scripts cannot be secure.  On systems where setuid scripts have
been disabled, the setuid/setgid bits on scripts are currently
useless.  It is possible for $package to detect those bits and emulate
setuid/setgid in a secure fashion.  This emulation will only work if
setuid scripts have been disabled in your kernel.

EOM
	case "$d_dosuid" in
	"$define") dflt=y ;;
	*) dflt=n ;;
	esac
	rp="Do you want to do setuid/setgid emulation?"
	. ./myread
	case "$ans" in
	[yY]*)	val="$define";;
	*)	val="$undef";;
	esac
	;;
esac
set d_dosuid
eval $setvar

: determine where site specific libraries go.
set sitelib sitelib
eval $prefixit
case "$sitelib" in
'')	dflt="$privlib/site_perl" ;;
*)	dflt="$sitelib" ;;
esac
$cat <<EOM

The installation process will also create a directory for
site-specific extensions and modules.  Some users find it convenient
to place all local files in this directory rather than in the main
distribution directory.

EOM
fn=d~+
rp='Pathname for the site-specific library files?'
. ./getfile
if $test "X$sitelibexp" != "X$ansexp"; then
	installsitelib=''
fi
sitelib="$ans"
sitelibexp="$ansexp"
if $afs; then
	$cat <<EOM

Since you are running AFS, I need to distinguish the directory in
which site-specific files reside from the directory in which they are
installed (and from which they are presumably copied to the former
directory by occult means).

EOM
	case "$installsitelib" in
	'') dflt=`echo $sitelibexp | sed 's#^/afs/#/afs/.#'`;;
	*) dflt="$installsitelib";;
	esac
	fn=de~
	rp='Where will site-specific files be installed?'
	. ./getfile
	installsitelib="$ans"
else
	installsitelib="$sitelibexp"
fi

: determine where site specific architecture-dependent libraries go.
xxx=`echo $sitelib/$archname | sed 's!^$prefix!!'`
: xxx is usuually lib/site_perl/archname.
set sitearch sitearch none
eval $prefixit
case "$sitearch" in
'')	dflt="$sitelib/$archname" ;;
*)	dflt="$sitearch" ;;
esac
$cat <<EOM

The installation process will also create a directory for
architecture-dependent site-specific extensions and modules.

EOM
fn=nd~+
rp='Pathname for the site-specific architecture-dependent library files?'
. ./getfile
if $test "X$sitearchexp" != "X$ansexp"; then
	installsitearch=''
fi
sitearch="$ans"
sitearchexp="$ansexp"
if $afs; then
	$cat <<EOM

Since you are running AFS, I need to distinguish the directory in
which site-specific architecture-dependent library files reside from
the directory in which they are installed (and from which they are
presumably copied to the former directory by occult means).

EOM
	case "$installsitearch" in
	'') dflt=`echo $sitearchexp | sed 's#^/afs/#/afs/.#'`;;
	*) dflt="$installsitearch";;
	esac
	fn=de~
	rp='Where will site-specific architecture-dependent files be installed?'
	. ./getfile
	installsitearch="$ans"
else
	installsitearch="$sitearchexp"
fi

: determine where old public architecture dependent libraries might be
case "$oldarchlib" in
'')	case "$privlib" in
	'') ;;
	*)	dflt="$privlib/$archname"
		;;
	esac
	;;
*)	dflt="$oldarchlib" 
	;;
esac
if $test ! -d "$dflt/auto"; then
	dflt=none
fi
cat <<EOM

In 5.001, Perl stored architecture-dependent library files in a directory
with a name such as $privlib/$archname, 
and this directory contained files from the standard extensions and 
files from any additional extensions you might have added.  Starting 
with version 5.002, all the architecture-dependent standard extensions 
will go into a version-specific directory such as
$archlib, 
while locally-added extensions will go into
$sitearch.

If you wish Perl to continue to search the old architecture-dependent
library for your local extensions, give the path to that directory.
If you do not wish to use your old architecture-dependent library
files, answer 'none'.

EOM
fn=dn~
rp='Directory for your old 5.001 architecture-dependent libraries?'
. ./getfile
oldarchlib="$ans"
oldarchlibexp="$ansexp"
case "$oldarchlib" in
''|' ') val="$undef" ;;
*) val="$define" ;;
esac
set d_oldarchlib
eval $setvar

: determine where public executables go
echo " "
set dflt bin bin
eval $prefixit
fn=d~
rp='Pathname where the public executables will reside?'
. ./getfile
if $test "X$ansexp" != "X$binexp"; then
	installbin=''
fi
bin="$ans"
binexp="$ansexp"
if $afs; then
	$cat <<EOM

Since you are running AFS, I need to distinguish the directory in which
executables reside from the directory in which they are installed (and from
which they are presumably copied to the former directory by occult means).

EOM
	case "$installbin" in
	'') dflt=`echo $binexp | sed 's#^/afs/#/afs/.#'`;;
	*) dflt="$installbin";;
	esac
	fn=de~
	rp='Where will public executables be installed?'
	. ./getfile
	installbin="$ans"
else
	installbin="$binexp"
fi

: determine where manual pages are on this system
echo " "
case "$sysman" in
'') 
	syspath='/usr/man/man1 /usr/man/mann /usr/man/manl /usr/man/local/man1'
	syspath="$syspath /usr/man/u_man/man1 /usr/share/man/man1"
	syspath="$syspath /usr/catman/u_man/man1 /usr/man/l_man/man1"
	syspath="$syspath /usr/local/man/u_man/man1 /usr/local/man/l_man/man1"
	syspath="$syspath /usr/man/man.L /local/man/man1 /usr/local/man/man1"
	sysman=`./loc . /usr/man/man1 $syspath`
	;;
esac
if $test -d "$sysman"; then
	echo "System manual is in $sysman." >&4
else
	echo "Could not find manual pages in source form." >&4
fi

: see what memory models we can support
case "$models" in
'')
	$cat >pdp11.c <<'EOP'
main() {
#ifdef pdp11
	exit(0);
#else
	exit(1);
#endif
}
EOP
	(cc -o pdp11 pdp11.c) >/dev/null 2>&1
	if $test -f pdp11 && ./pdp11 2>/dev/null; then
		dflt='unsplit split'
	else
		tans=`./loc . X /lib/small /lib/large /usr/lib/small /usr/lib/large /lib/medium /usr/lib/medium /lib/huge`
		case "$tans" in
		X) dflt='none';;
		*) if $test -d /lib/small || $test -d /usr/lib/small; then
				dflt='small'
			else
				dflt=''
			fi
			if $test -d /lib/medium || $test -d /usr/lib/medium; then
				dflt="$dflt medium"
			fi
			if $test -d /lib/large || $test -d /usr/lib/large; then
				dflt="$dflt large"
			fi
			if $test -d /lib/huge || $test -d /usr/lib/huge; then
				dflt="$dflt huge"
			fi
		esac
	fi;;
*) dflt="$models";;
esac
$cat <<EOM
 
Some systems have different model sizes.  On most systems they are called
small, medium, large, and huge.  On the PDP11 they are called unsplit and
split.  If your system doesn't support different memory models, say "none".
If you wish to force everything to one memory model, say "none" here and
put the appropriate flags later when it asks you for other cc and ld flags.
Venix systems may wish to put "none" and let the compiler figure things out.
(In the following question multiple model names should be space separated.)

EOM
rp="Which memory models are supported?"
. ./myread
models="$ans"

case "$models" in
none)
	small=''
	medium=''
	large=''
	huge=''
	unsplit=''
	split=''
	;;
*split)
	case "$split" in
	'') if $contains '\-i' $sysman/ld.1 >/dev/null 2>&1 || \
			 $contains '\-i' $sysman/cc.1 >/dev/null 2>&1; then
			dflt='-i'
		else
			dflt='none'
		fi;;
	*) dflt="$split";;
	esac
	rp="What flag indicates separate I and D space?"
	. ./myread
	tans="$ans"
	case "$tans" in
	none) tans='';;
	esac
	split="$tans"
	unsplit='';;
*large*|*small*|*medium*|*huge*)
	case "$models" in
	*large*)
		case "$large" in
		'') dflt='-Ml';;
		*) dflt="$large";;
		esac
	rp="What flag indicates large model?"
	. ./myread
	tans="$ans"
	case "$tans" in
	none) tans='';
	esac
	large="$tans";;
	*) large='';;
	esac
	case "$models" in
	*huge*) case "$huge" in
		'') dflt='-Mh';;
		*) dflt="$huge";;
		esac
		rp="What flag indicates huge model?"
		. ./myread
		tans="$ans"
		case "$tans" in
		none) tans='';
		esac
		huge="$tans";;
	*) huge="$large";;
	esac
	case "$models" in
	*medium*) case "$medium" in
		'') dflt='-Mm';;
		*) dflt="$medium";;
		esac
		rp="What flag indicates medium model?"
		. ./myread
		tans="$ans"
		case "$tans" in
		none) tans='';
		esac
		medium="$tans";;
	*) medium="$large";;
	esac
	case "$models" in
	*small*) case "$small" in
		'') dflt='none';;
		*) dflt="$small";;
		esac
		rp="What flag indicates small model?"
		. ./myread
		tans="$ans"
		case "$tans" in
		none) tans='';
		esac
		small="$tans";;
	*) small='';;
	esac
	;;
*)
	echo "Unrecognized memory models--you may have to edit Makefile.SH" >&4
	;;
esac

: see if we need a special compiler
echo " "
if ./usg; then
	case "$cc" in
	'') case "$Mcc" in
		/*) dflt='Mcc';;
		*) case "$large" in
			-M*) dflt='cc';;
			*)	if $contains '\-M' $sysman/cc.1 >/dev/null 2>&1 ; then
					if $contains '\-M' $sysman/cpp.1 >/dev/null 2>&1; then
						dflt='cc'
					else
						dflt='cc -M'
					fi
				else
					dflt='cc'
				fi;;
			esac;;
		esac;;
	*)  dflt="$cc";;
	esac
	$cat <<'EOM'
On some systems the default C compiler will not resolve multiple global
references that happen to have the same name.  On some such systems the "Mcc"
command may be used to force these to be resolved.  On other systems a "cc -M"
command is required.  (Note that the -M flag on other systems indicates a
memory model to use!) If you have the Gnu C compiler, you might wish to use
that instead.

EOM
	rp="What command will force resolution on this system?"
	. ./myread
	cc="$ans"
else
	case "$cc" in
	'') dflt=cc;;
	*) dflt="$cc";;
	esac
	rp="Use which C compiler?"
	. ./myread
	cc="$ans"
fi
echo " "
echo "Checking for GNU cc in disguise and/or its version number..." >&4
$cat >gccvers.c <<EOM
#include <stdio.h>
int main() {
#ifdef __GNUC__
#ifdef __VERSION__
	printf("%s\n", __VERSION__);
#else
	printf("%s\n", "1");
#endif
#endif
	exit(0);
}
EOM
if $cc -o gccvers gccvers.c >/dev/null 2>&1; then
	gccversion=`./gccvers`
	case "$gccversion" in
	'') echo "You are not using GNU cc." ;;
	*)  echo "You are using GNU cc $gccversion." ;;
	esac
else
	echo " "
	echo "*** WHOA THERE!!! ***" >&4
	echo "    Your C compiler \"$cc\" doesn't seem to be working!" >&4
	case "$knowitall" in
	'')
	echo "    You'd better start hunting for one and let me know about it." >&4
		exit 1
		;;
	esac
fi
$rm -f gccvers*
case "$gccversion" in
1*) cpp=`./loc gcc-cpp $cpp $pth` ;;
esac

: What should the include directory be ?
echo " "
$echo $n "Hmm...  $c"
dflt='/usr/include'
incpath=''
mips_type=''
if $test -f /bin/mips && /bin/mips; then
	echo "Looks like a MIPS system..."
	$cat >usr.c <<'EOCP'
#ifdef SYSTYPE_BSD43
/bsd43
#endif
EOCP
	if $cc -E usr.c > usr.out && $contains / usr.out >/dev/null 2>&1; then
		dflt='/bsd43/usr/include'
		incpath='/bsd43'
		mips_type='BSD 4.3'
	else
		mips_type='System V'
	fi
	$rm -f usr.c usr.out
	echo "and you're compiling with the $mips_type compiler and libraries."
	xxx_prompt=y
	echo "exit 0" >mips
else
	echo "Doesn't look like a MIPS system."
	xxx_prompt=n
	echo "exit 1" >mips
fi
chmod +x mips
$eunicefix mips
echo " "
case "$usrinc" in
'') ;;
*) dflt="$usrinc";;
esac
case "$xxx_prompt" in
y)	fn=d/
	rp='Where are the include files you want to use?'
	. ./getfile
	usrinc="$ans"
	;;
*)	usrinc="$dflt"
	;;
esac

: Set private lib path
case "$plibpth" in
'') if ./mips; then
		plibpth="$incpath/usr/lib /usr/local/lib /usr/ccs/lib"
	fi;;
esac
case "$libpth" in
' ') dlist='';;
'') dlist="$loclibpth $plibpth $glibpth";;
*) dlist="$libpth";;
esac

: Now check and see which directories actually exist, avoiding duplicates
libpth=''
for xxx in $dlist
do
    if $test -d $xxx; then
		case " $libpth " in
		*" $xxx "*) ;;
		*) libpth="$libpth $xxx";;
		esac
    fi
done
$cat <<'EOM'

Some systems have incompatible or broken versions of libraries.  Among
the directories listed in the question below, please remove any you
know not to be holding relevant libraries, and add any that are needed.
Say "none" for none.

EOM
case "$libpth" in
'') dflt='none';;
*)
	set X $libpth
	shift
	dflt=${1+"$@"}
	;;
esac
rp="Directories to use for library searches?"
. ./myread
case "$ans" in
none) libpth=' ';;
*) libpth="$ans";;
esac

: Define several unixisms. Hints files or command line options
: can be used to override them.
case "$ar" in
'') ar='ar';;
esac
case "$lib_ext" in
'') lib_ext='.a';;
esac
case "$obj_ext" in
'') obj_ext='.o';;
esac
case "$path_sep" in
'') path_sep=':';;
esac
: Which makefile gets called first.  This is used by make depend.
case "$firstmakefile" in
'') firstmakefile='makefile';;
esac

: compute shared library extension
case "$so" in
'')
	if xxx=`./loc libc.sl X $libpth`; $test -f "$xxx"; then
		dflt='sl'
	else
		dflt='so'
	fi
	;;
*) dflt="$so";;
esac
$cat <<EOM

On some systems, shared libraries may be available.  Answer 'none' if
you want to suppress searching of shared libraries for the remaining
of this configuration.

EOM
rp='What is the file extension used for shared libraries?'
. ./myread
so="$ans"

: Looking for optional libraries
echo " "
echo "Checking for optional libraries..." >&4
case "$libs" in
' '|'') dflt='';;
*) dflt="$libs";;
esac
case "$libswanted" in
'') libswanted='c_s';;
esac
for thislib in $libswanted; do
	
	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`; $test -f "$xxx"; then
		echo "Found -l$thislib (shared)."
		case " $dflt " in
		*"-l$thislib "*);;
		*) dflt="$dflt -l$thislib";;
		esac
	elif xxx=`./loc lib$thislib.$so X $libpth` ; $test -f "$xxx"; then
		echo "Found -l$thislib (shared)."
		case " $dflt " in
		*"-l$thislib "*);;
		*) dflt="$dflt -l$thislib";;
		esac
	elif xxx=`./loc lib$thislib$lib_ext X $libpth`; $test -f "$xxx"; then
		echo "Found -l$thislib."
		case " $dflt " in
		*"-l$thislib "*);;
		*) dflt="$dflt -l$thislib";;
		esac
	elif xxx=`./loc $thislib$lib_ext X $libpth`; $test -f "$xxx"; then
		echo "Found -l$thislib."
		case " $dflt " in
		*"-l$thislib "*);;
		*) dflt="$dflt -l$thislib";;
		esac
	elif xxx=`./loc lib${thislib}_s$lib_ext X $libpth`; $test -f "$xxx"; then
		echo "Found -l${thislib}_s."
		case " $dflt " in
		*"-l$thislib "*);;
		*) dflt="$dflt -l${thislib}_s";;
		esac
	elif xxx=`./loc Slib$thislib$lib_ext X $xlibpth`; $test -f "$xxx"; then
		echo "Found -l$thislib."
		case " $dflt " in
		*"-l$thislib "*);;
		*) dflt="$dflt -l$thislib";;
		esac
	else
		echo "No -l$thislib."
	fi
done
set X $dflt
shift
dflt="$*"
case "$libs" in
'') dflt="$dflt";;
*) dflt="$libs";;
esac
case "$dflt" in
' '|'') dflt='none';;
esac

$cat <<EOM
 
Some versions of Unix support shared libraries, which make executables smaller
but make load time slightly longer.

On some systems, mostly System V Release 3's, the shared library is included
by putting the option "-lc_s" as the last thing on the cc command line when
linking.  Other systems use shared libraries by default.  There may be other
libraries needed to compile $package on your machine as well.  If your system
needs the "-lc_s" option, include it here.  Include any other special libraries
here as well.  Say "none" for none.
EOM

echo " "
rp="Any additional libraries?"
. ./myread
case "$ans" in
none) libs=' ';;
*) libs="$ans";;
esac

: see how we invoke the C preprocessor
echo " "
echo "Now, how can we feed standard input to your C preprocessor..." >&4
cat <<'EOT' >testcpp.c
#define ABC abc
#define XYZ xyz
ABC.XYZ
EOT
cd ..
echo 'cat >.$$.c; '"$cc"' -E ${1+"$@"} .$$.c; rm .$$.c' >cppstdin
chmod 755 cppstdin
wrapper=`pwd`/cppstdin
ok='false'
cd UU

if $test "X$cppstdin" != "X" && \
	$cppstdin $cppminus <testcpp.c >testcpp.out 2>&1 && \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1
then
	echo "You used to use $cppstdin $cppminus so we'll use that again."
	case "$cpprun" in
	'') echo "But let's see if we can live without a wrapper..." ;;
	*)
		if $cpprun $cpplast <testcpp.c >testcpp.out 2>&1 && \
			$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1
		then
			echo "(And we'll use $cpprun $cpplast to preprocess directly.)"
			ok='true'
		else
			echo "(However, $cpprun $cpplast does not work, let's see...)"
		fi
		;;
	esac
else
	case "$cppstdin" in
	'') ;;
	*)
		echo "Good old $cppstdin $cppminus does not seem to be of any help..."
		;;
	esac
fi

if $ok; then
	: nothing
elif echo 'Maybe "'"$cc"' -E" will work...'; \
	$cc -E <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yup, it does."
	x_cpp="$cc -E"
	x_minus='';
elif echo 'Nope...maybe "'"$cc"' -E -" will work...'; \
	$cc -E - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yup, it does."
	x_cpp="$cc -E"
	x_minus='-';
elif echo 'Nope...maybe "'"$cc"' -P" will work...'; \
	$cc -P <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yipee, that works!"
	x_cpp="$cc -P"
	x_minus='';
elif echo 'Nope...maybe "'"$cc"' -P -" will work...'; \
	$cc -P - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "At long last!"
	x_cpp="$cc -P"
	x_minus='-';
elif echo 'No such luck, maybe "'$cpp'" will work...'; \
	$cpp <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "It works!"
	x_cpp="$cpp"
	x_minus='';
elif echo 'Nixed again...maybe "'$cpp' -" will work...'; \
	$cpp - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Hooray, it works!  I was beginning to wonder."
	x_cpp="$cpp"
	x_minus='-';
elif echo 'Uh-uh.  Time to get fancy.  Trying a wrapper...'; \
	$wrapper <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	x_cpp="$wrapper"
	x_minus=''
	echo "Eureka!"
else
	dflt=''
	rp="No dice.  I can't find a C preprocessor.  Name one:"
	. ./myread
	x_cpp="$ans"
	x_minus=''
	$x_cpp <testcpp.c >testcpp.out 2>&1
	if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
		echo "OK, that will do." >&4
	else
echo "Sorry, I can't get that to work.  Go find one and rerun Configure." >&4
		exit 1
	fi
fi

case "$ok" in
false)
	cppstdin="$x_cpp"
	cppminus="$x_minus"
	cpprun="$x_cpp"
	cpplast="$x_minus"
	set X $x_cpp
	shift
	case "$1" in
	"$cpp")
		echo "Perhaps can we force $cc -E using a wrapper..."
		if $wrapper <testcpp.c >testcpp.out 2>&1; \
			$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1
		then
			echo "Yup, we can."
			cppstdin="$wrapper"
			cppminus='';
		else
			echo "Nope, we'll have to live without it..."
		fi
		;;
	esac
	case "$cpprun" in
	"$wrapper")
		cpprun=''
		cpplast=''
		;;
	esac
	;;
esac

case "$cppstdin" in
"$wrapper") ;;
*) $rm -f $wrapper;;
esac
$rm -f testcpp.c testcpp.out

: determine optimize, if desired, or use for debug flag also
case "$optimize" in
' '|$undef) dflt='none';;
'') dflt='-O';;
*) dflt="$optimize";;
esac
$cat <<EOH

Some C compilers have problems with their optimizers.  By default, $package
compiles with the -O flag to use the optimizer.  Alternately, you might want
to use the symbolic debugger, which uses the -g flag (on traditional Unix
systems).  Either flag can be specified here.  To use neither flag, specify
the word "none".

EOH
rp="What optimizer/debugger flag should be used?"
. ./myread
optimize="$ans"
case "$optimize" in
'none') optimize=" ";;
esac

dflt=''
: We will not override a previous value, but we might want to
: augment a hint file
case "$hint" in
none|recommended)
	case "$gccversion" in
	1*) dflt='-fpcc-struct-return' ;;
	esac
	case "$optimize" in
	*-g*) dflt="$dflt -DDEBUGGING";;
	esac
	case "$gccversion" in
	2*) if test -d /etc/conf/kconfig.d &&
			$contains _POSIX_VERSION $usrinc/sys/unistd.h >/dev/null 2>&1
		then
			dflt="$dflt -posix"
		fi
		;;
	esac
	;;
esac

case "$mips_type" in
*BSD*|'') inclwanted="$locincpth $usrinc";;
*) inclwanted="$locincpth $inclwanted $usrinc/bsd";;
esac
for thisincl in $inclwanted; do
	if $test -d $thisincl; then
		if $test x$thisincl != x$usrinc; then
			case "$dflt" in
			*$thisincl*);;
			*) dflt="$dflt -I$thisincl";;
			esac
		fi
	fi
done

inctest='if $contains $2 $usrinc/$1 >/dev/null 2>&1; then
	xxx=true;
elif $contains $2 $usrinc/sys/$1 >/dev/null 2>&1; then
	xxx=true;
else
	xxx=false;
fi;
if $xxx; then
	case "$dflt" in
	*$2*);;
	*) dflt="$dflt -D$2";;
	esac;
fi'

if ./osf1; then
	set signal.h __LANGUAGE_C__; eval $inctest
else
	set signal.h LANGUAGE_C; eval $inctest
fi

case "$hint" in
none|recommended) dflt="$ccflags $dflt" ;;
*) dflt="$ccflags";;
esac

case "$dflt" in
''|' ') dflt=none;;
esac
$cat <<EOH

Your C compiler may want other flags.  For this question you should include
-I/whatever and -DWHATEVER flags and any other flags used by the C compiler,
but you should NOT include libraries or ld flags like -lwhatever.  If you
want $package to honor its debug switch, you should include -DDEBUGGING here.
Your C compiler might also need additional flags, such as -D_POSIX_SOURCE,
-DHIDEMYMALLOC or -DCRIPPLED_CC.

To use no flags, specify the word "none".

EOH
set X $dflt
shift
dflt=${1+"$@"}
rp="Any additional cc flags?"
. ./myread
case "$ans" in
none) ccflags='';;
*) ccflags="$ans";;
esac

: the following weeds options from ccflags that are of no interest to cpp
cppflags="$ccflags"
case "$gccversion" in
1*) cppflags="$cppflags -D__GNUC__"
esac
case "$mips_type" in
'');;
*BSD*) cppflags="$cppflags -DSYSTYPE_BSD43";;
esac
case "$cppflags" in
'');;
*)
	echo " "
	echo "Let me guess what the preprocessor flags are..." >&4
	set X $cppflags
	shift
	cppflags=''
	$cat >cpp.c <<'EOM'
#define BLURFL foo

BLURFL xx LFRULB
EOM
	previous=''
	for flag in $*
	do
		case "$flag" in
		-*) ftry="$flag";;
		*) ftry="$previous $flag";;
		esac
		if $cppstdin -DLFRULB=bar $cppflags $ftry $cppminus <cpp.c \
			>cpp1.out 2>/dev/null && \
			$cpprun -DLFRULB=bar $ftry $cpplast <cpp.c \
			>cpp2.out 2>/dev/null && \
			$contains 'foo.*xx.*bar' cpp1.out >/dev/null 2>&1 && \
			$contains 'foo.*xx.*bar' cpp2.out >/dev/null 2>&1
		then
			cppflags="$cppflags $ftry"
			previous=''
		else
			previous="$flag"
		fi
	done
	set X $cppflags
	shift
	cppflags=${1+"$@"}
	case "$cppflags" in
	*-*)  echo "They appear to be: $cppflags";;
	esac
	$rm -f cpp.c cpp?.out
	;;
esac

: flags used in final linking phase

case "$ldflags" in
'') if ./venix; then
		dflt='-i -z'
	else
		dflt=''
	fi
	case "$ccflags" in
	*-posix*) dflt="$dflt -posix" ;;
	esac
	;;
*) dflt="$ldflags";;
esac

: Try to guess additional flags to pick up local libraries.
for thislibdir in $libpth; do
	case " $loclibpth " in
	*" $thislibdir "*)
		case "$dflt " in 
		*"-L$thislibdir "*) ;;
		*)  dflt="$dflt -L$thislibdir" ;;
		esac
		;;
	esac
done

case "$dflt" in
'') dflt='none' ;;
esac

$cat <<EOH

Your C linker may need flags.  For this question you should
include -L/whatever and any other flags used by the C linker, but you
should NOT include libraries like -lwhatever.

Make sure you include the appropriate -L/path flags if your C linker
does not normally search all of the directories you specified above,
namely
	$libpth
To use no flags, specify the word "none".

EOH

rp="Any additional ld flags (NOT including libraries)?"
. ./myread
case "$ans" in
none) ldflags='';;
*) ldflags="$ans";;
esac
rmlist="$rmlist pdp11"

: coherency check
echo " "
echo "Checking your choice of C compiler, libs, and flags for coherency..." >&4
set X $cc $optimize $ccflags $ldflags -o try try.c $libs
shift
$cat >try.msg <<EOM
I've tried to compile and run a simple program with:

	$*
	./try

and I got the following output:

EOM
$cat > try.c <<'EOF'
#include <stdio.h>
main() { exit(0); }
EOF
dflt=y
if sh -c "$cc $optimize $ccflags -o try try.c $ldflags $libs" >>try.msg 2>&1; then
	if sh -c './try' >>try.msg 2>&1; then
		dflt=n
	else
		echo "The program compiled OK, but exited with status $?." >>try.msg
		rp="You have a problem.  Shall I abort Configure (and explain the problem)"
		dflt=y
	fi
else
	echo "I can't compile the test program." >>try.msg
	rp="You have a BIG problem.  Shall I abort Configure (and explain the problem)"
	dflt=y
fi
case "$dflt" in
y)
	$cat try.msg >&4
	case "$knowitall" in
	'')
		echo "(The supplied flags might be incorrect with this C compiler.)"
		;;
	*) dflt=n;;
	esac
	echo " "
	. ./myread
	case "$ans" in
	n*|N*) ;;
	*)	echo "Ok.  Stopping Configure." >&4
		exit 1
		;;
	esac
	;;
n) echo "OK, that should do.";;
esac
$rm -f try try.* core

echo " "
echo "Checking for GNU C Library..." >&4
cat >gnulibc.c <<EOM
int
main()
{
  return __libc_main();
}
EOM
if $cc $ccflags $ldflags -o gnulibc gnulibc.c $libs >/dev/null 2>&1 && \
    ./gnulibc | $contains '^GNU C Library' >/dev/null 2>&1; then
	val="$define"
	echo "You are using the GNU C Library"
else
	val="$undef"
	echo "You are not using the GNU C Library"
fi
$rm -f gnulibc*
set d_gnulibc
eval $setvar

: see if nm is to be used to determine whether a symbol is defined or not
case "$usenm" in
'')
	case "$d_gnulibc" in
	$define)
		dflt=n
		;;
	*)
		dflt=`egrep 'inlibc|csym' ../Configure | wc -l 2>/dev/null`
		if $test $dflt -gt 20; then
			dflt=y
		else
			dflt=n
		fi
		;;
	esac
	;;
*)
	case "$usenm" in
	true) dflt=y;;
	*) dflt=n;;
	esac
	;;
esac
$cat <<EOM

I can use 'nm' to extract the symbols from your C libraries. This is a time
consuming task which may generate huge output on the disk (up to 3 megabytes)
but that should make the symbols extraction faster. The alternative is to skip
the 'nm' extraction part and to compile a small test program instead to
determine whether each symbol is present. If you have a fast C compiler and/or
if your 'nm' output cannot be parsed, this may be the best solution.
You shouldn't let me use 'nm' if you have the GNU C Library.

EOM
rp='Shall I use nm to extract C symbols from the libraries?'
. ./myread
case "$ans" in
n|N) usenm=false;;
*) usenm=true;;
esac

runnm=$usenm
case "$reuseval" in
true) runnm=false;;
esac

: nm options which may be necessary
case "$nm_opt" in
'') if $test -f /mach_boot; then
		nm_opt=''	# Mach
	elif $test -d /usr/ccs/lib; then
		nm_opt='-p'	# Solaris (and SunOS?)
	elif $test -f /dgux; then
		nm_opt='-p'	# DG-UX
	elif $test -f /lib64/rld; then
		nm_opt='-p'	# 64-bit Irix
	else
		nm_opt=''
	fi;;
esac

: nm options which may be necessary for shared libraries but illegal
: for archive libraries.  Thank you, Linux.
case "$nm_so_opt" in
'')	case "$myuname" in
	*linux*)
		if nm --help | $grep 'dynamic' > /dev/null 2>&1; then
			nm_so_opt='--dynamic'
		fi
		;;
	esac
	;;
esac

case "$runnm" in
true)
: get list of predefined functions in a handy place
echo " "
case "$libc" in
'') libc=unknown
	case "$libs" in
	*-lc_s*) libc=`./loc libc_s$lib_ext $libc $libpth`
	esac
	;;
esac
libnames='';
case "$libs" in
'') ;;
*)  for thislib in $libs; do
	case "$thislib" in
	-lc|-lc_s)
		: Handle C library specially below.
		;;
	-l*)
		thislib=`echo $thislib | $sed -e 's/^-l//'`
		if try=`./loc lib$thislib.$so.'*' X $libpth`; $test -f "$try"; then
			:
		elif try=`./loc lib$thislib.$so X $libpth`; $test -f "$try"; then
			:
		elif try=`./loc lib$thislib$lib_ext X $libpth`; $test -f "$try"; then
			:
		elif try=`./loc $thislib$lib_ext X $libpth`; $test -f "$try"; then
			:
		elif try=`./loc lib$thislib X $libpth`; $test -f "$try"; then
			:
		elif try=`./loc $thislib X $libpth`; $test -f "$try"; then
			:
		elif try=`./loc Slib$thislib$lib_ext X $xlibpth`; $test -f "$try"; then
			:
		else
			try=''
		fi
		libnames="$libnames $try"
		;;
	*) libnames="$libnames $thislib" ;;
	esac
	done
	;;
esac
xxx=normal
case "$libc" in
unknown)
	set /lib/libc.$so
	for xxx in $libpth; do
		$test -r $1 || set $xxx/libc.$so
		: The messy sed command sorts on library version numbers.
		$test -r $1 || \
			set `echo blurfl; echo $xxx/libc.$so.[0-9]* | \
				tr ' ' '\012' | egrep -v '\.[A-Za-z]*$' | $sed -e '
				h
				s/[0-9][0-9]*/0000&/g
				s/0*\([0-9][0-9][0-9][0-9][0-9]\)/\1/g
				G
				s/\n/ /' | \
		 	sort | $sed -e 's/^.* //'`
		eval set \$$#
	done
	$test -r $1 || set /usr/ccs/lib/libc.$so
  	$test -r $1 || set /lib/libsys_s$lib_ext
  	;;
*)
	set blurfl
	;;
esac
if $test -r "$1"; then
	echo "Your (shared) C library seems to be in $1."
	libc="$1"
elif $test -r /lib/libc && $test -r /lib/clib; then
	echo "Your C library seems to be in both /lib/clib and /lib/libc."
	xxx=apollo
	libc='/lib/clib /lib/libc'
	if $test -r /lib/syslib; then
		echo "(Your math library is in /lib/syslib.)"
		libc="$libc /lib/syslib"
	fi
elif $test -r "$libc" || (test -h "$libc") >/dev/null 2>&1; then
	echo "Your C library seems to be in $libc, as you said before."
elif $test -r $incpath/usr/lib/libc$lib_ext; then
	libc=$incpath/usr/lib/libc$lib_ext;
	echo "Your C library seems to be in $libc.  That's fine."
elif $test -r /lib/libc$lib_ext; then
	libc=/lib/libc$lib_ext;
	echo "Your C library seems to be in $libc.  You're normal."
else
	if tans=`./loc libc$lib_ext blurfl/dyick $libpth`; $test -r "$tans"; then
		:
	elif tans=`./loc libc blurfl/dyick $libpth`; $test -r "$tans"; then
		libnames="$libnames "`./loc clib blurfl/dyick $libpth`
	elif tans=`./loc clib blurfl/dyick $libpth`; $test -r "$tans"; then
		:
	elif tans=`./loc Slibc$lib_ext blurfl/dyick $xlibpth`; $test -r "$tans"; then
		:
	elif tans=`./loc Mlibc$lib_ext blurfl/dyick $xlibpth`; $test -r "$tans"; then
		:
	else
		tans=`./loc Llibc$lib_ext blurfl/dyick $xlibpth`
	fi
	if $test -r "$tans"; then
		echo "Your C library seems to be in $tans, of all places."
		libc=$tans
	else
		libc='blurfl'
	fi
fi
if $test $xxx = apollo -o -r "$libc" || (test -h "$libc") >/dev/null 2>&1; then
	dflt="$libc"
	cat <<EOM

If the guess above is wrong (which it might be if you're using a strange
compiler, or your machine supports multiple models), you can override it here.

EOM
else
	dflt=''
	echo $libpth | tr ' ' '\012' | sort | uniq > libpath
	cat >&4 <<EOM
I can't seem to find your C library.  I've looked in the following places:

EOM
	$sed 's/^/	/' libpath
	cat <<EOM

None of these seems to contain your C library. I need to get its name...

EOM
fi
fn=f
rp='Where is your C library?'
. ./getfile
libc="$ans"

echo " "
echo $libc $libnames | tr ' ' '\012' | sort | uniq > libnames
set X `cat libnames`
shift
xxx=files
case $# in 1) xxx=file; esac
echo "Extracting names from the following $xxx for later perusal:" >&4
echo " "
$sed 's/^/	/' libnames >&4
echo " "
$echo $n "This may take a while...$c" >&4

: Linux may need the special Dynamic option to nm for shared libraries.
: In general, this is stored in the nm_so_opt variable.
: Unfortunately, that option may be fatal on non-shared libraries.
for nm_libs_ext in $*; do
    case $nm_libs_ext in
	*$so*)	nm $nm_so_opt $nm_opt $nm_libs_ext 2>/dev/null ;;
	*)		nm $nm_opt $nm_libs_ext 2>/dev/null ;;
	esac
done > libc.tmp

$echo $n ".$c"
$grep fprintf libc.tmp > libc.ptf
xscan='eval "<libc.ptf $com >libc.list"; $echo $n ".$c" >&4'
xrun='eval "<libc.tmp $com >libc.list"; echo "done" >&4'
xxx='[ADTSIW]'
if com="$sed -n -e 's/__IO//' -e 's/^.* $xxx  *_[_.]*//p' -e 's/^.* $xxx  *//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^__*//' -e 's/^\([a-zA-Z_0-9$]*\).*xtern.*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e '/|UNDEF/d' -e '/FUNC..GL/s/^.*|__*//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^.* D __*//p' -e 's/^.* D //p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^_//' -e 's/^\([a-zA-Z_0-9]*\).*xtern.*text.*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^.*|FUNC |GLOB .*|//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$grep '|' | $sed -n -e '/|COMMON/d' -e '/|DATA/d' \
				-e '/ file/d' -e 's/^\([^ 	]*\).*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^.*|FUNC |GLOB .*|//p' -e 's/^.*|FUNC |WEAK .*|//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^__//' -e '/|Undef/d' -e '/|Proc/s/ .*//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^.*|Proc .*|Text *| *//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e '/Def. Text/s/.* \([^ ]*\)\$/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^[-0-9a-f ]*_\(.*\)=.*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/.*\.text n\ \ \ \.//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
else
	nm -p $* 2>/dev/null >libc.tmp
	$grep fprintf libc.tmp > libc.ptf
	if com="$sed -n -e 's/^.* [ADTSIW]  *_[_.]*//p' -e 's/^.* [ADTSIW] //p'";\
		eval $xscan; $contains '^fprintf$' libc.list >/dev/null 2>&1
	then
		nm_opt='-p'
		eval $xrun
	else
		echo " "
		echo "nm didn't seem to work right. Trying ar instead..." >&4
		com=''
		if ar t $libc > libc.tmp; then
			for thisname in $libnames; do
				ar t $thisname >>libc.tmp
			done
			$sed -e 's/\.o$//' < libc.tmp > libc.list
			echo "Ok." >&4
		else
			echo "ar didn't seem to work right." >&4
			echo "Maybe this is a Cray...trying bld instead..." >&4
			if bld t $libc | $sed -e 's/.*\///' -e 's/\.o:.*$//' > libc.list
			then
				for thisname in $libnames; do
					bld t $libnames | \
					$sed -e 's/.*\///' -e 's/\.o:.*$//' >>libc.list
					ar t $thisname >>libc.tmp
				done
				echo "Ok." >&4
			else
				echo "That didn't work either.  Giving up." >&4
				exit 1
			fi
		fi
	fi
fi
nm_extract="$com"
if $test -f /lib/syscalls.exp; then
	echo " "
	echo "Also extracting names from /lib/syscalls.exp for good ole AIX..." >&4
	$sed -n 's/^\([^ 	]*\)[ 	]*syscall$/\1/p' /lib/syscalls.exp >>libc.list
fi
;;
esac
$rm -f libnames libpath

: determine filename position in cpp output
echo " "
echo "Computing filename position in cpp output for #include directives..." >&4
echo '#include <stdio.h>' > foo.c
$cat >fieldn <<EOF
$startsh
$cppstdin $cppflags $cppminus <foo.c 2>/dev/null | \
$grep '^[ 	]*#.*stdio\.h' | \
while read cline; do
	pos=1
	set \$cline
	while $test \$# -gt 0; do
		if $test -r \`echo \$1 | $tr -d '"'\`; then
			echo "\$pos"
			exit 0
		fi
		shift
		pos=\`expr \$pos + 1\`
	done
done
EOF
chmod +x fieldn
fieldn=`./fieldn`
$rm -f foo.c fieldn
case $fieldn in
'') pos='???';;
1) pos=first;;
2) pos=second;;
3) pos=third;;
*) pos="${fieldn}th";;
esac
echo "Your cpp writes the filename in the $pos field of the line."

: locate header file
$cat >findhdr <<EOF
$startsh
wanted=\$1
name=''
if test -f $usrinc/\$wanted; then
	echo "$usrinc/\$wanted"
	exit 0
fi
awkprg='{ print \$$fieldn }'
echo "#include <\$wanted>" > foo\$\$.c
$cppstdin $cppminus $cppflags < foo\$\$.c 2>/dev/null | \
$grep "^[ 	]*#.*\$wanted" | \
while read cline; do
	name=\`echo \$cline | $awk "\$awkprg" | $tr -d '"'\`
	case "\$name" in
	*/\$wanted) echo "\$name"; exit 0;;
	*) name='';;
	esac;
done;
$rm -f foo\$\$.c;
case "\$name" in
'') exit 1;;
esac
EOF
chmod +x findhdr

: define an alternate in-header-list? function
inhdr='echo " "; td=$define; tu=$undef; yyy=$@;
cont=true; xxf="echo \"<\$1> found.\" >&4";
case $# in 2) xxnf="echo \"<\$1> NOT found.\" >&4";;
*) xxnf="echo \"<\$1> NOT found, ...\" >&4";;
esac;
case $# in 4) instead=instead;; *) instead="at last";; esac;
while $test "$cont"; do
	xxx=`./findhdr $1`
	var=$2; eval "was=\$$2";
	if $test "$xxx" && $test -r "$xxx";
	then eval $xxf;
	eval "case \"\$$var\" in $undef) . ./whoa; esac"; eval "$var=\$td";
		cont="";
	else eval $xxnf;
	eval "case \"\$$var\" in $define) . ./whoa; esac"; eval "$var=\$tu"; fi;
	set $yyy; shift; shift; yyy=$@;
	case $# in 0) cont="";;
	2) xxf="echo \"but I found <\$1> $instead.\" >&4";
		xxnf="echo \"and I did not find <\$1> either.\" >&4";;
	*) xxf="echo \"but I found <\$1\> instead.\" >&4";
		xxnf="echo \"there is no <\$1>, ...\" >&4";;
	esac;
done;
while $test "$yyy";
do set $yyy; var=$2; eval "was=\$$2";
	eval "case \"\$$var\" in $define) . ./whoa; esac"; eval "$var=\$tu";
	set $yyy; shift; shift; yyy=$@;
done'

: see if dld is available
set dld.h i_dld
eval $inhdr

: is a C symbol defined?
csym='tlook=$1;
case "$3" in
-v) tf=libc.tmp; tc=""; tdc="";;
-a) tf=libc.tmp; tc="[0]"; tdc="[]";;
*) tlook="^$1\$"; tf=libc.list; tc="()"; tdc="()";;
esac;
tx=yes;
case "$reuseval-$4" in
true-) ;;
true-*) tx=no; eval "tval=\$$4"; case "$tval" in "") tx=yes;; esac;;
esac;
case "$tx" in
yes)
	case "$runnm" in
	true)
		if $contains $tlook $tf >/dev/null 2>&1;
		then tval=true;
		else tval=false;
		fi;;
	*)
		echo "main() { extern short $1$tdc; printf(\"%hd\", $1$tc); }" > t.c;
		if $cc $ccflags $ldflags -o t t.c $libs >/dev/null 2>&1;
		then tval=true;
		else tval=false;
		fi;
		$rm -f t t.c;;
	esac;;
*)
	case "$tval" in
	$define) tval=true;;
	*) tval=false;;
	esac;;
esac;
eval "$2=$tval"'

: define an is-in-libc? function
inlibc='echo " "; td=$define; tu=$undef;
sym=$1; var=$2; eval "was=\$$2";
tx=yes;
case "$reuseval$was" in
true) ;;
true*) tx=no;;
esac;
case "$tx" in
yes)
	set $sym tres -f;
	eval $csym;
	case "$tres" in
	true)
		echo "$sym() found." >&4;
		case "$was" in $undef) . ./whoa; esac; eval "$var=\$td";;
	*)
		echo "$sym() NOT found." >&4;
		case "$was" in $define) . ./whoa; esac; eval "$var=\$tu";;
	esac;;
*)
	case "$was" in
	$define) echo "$sym() found." >&4;;
	*) echo "$sym() NOT found." >&4;;
	esac;;
esac'

: see if dlopen exists
xxx_runnm="$runnm"
runnm=false
set dlopen d_dlopen
eval $inlibc
runnm="$xxx_runnm"

: determine which dynamic loading, if any, to compile in
echo " "
dldir="ext/DynaLoader"
case "$usedl" in
$define|y|true)
	dflt='y'
	usedl="$define"
	;;
$undef|n|false)
	dflt='n'
	usedl="$undef"
	;;
*) 
	dflt='n'
	case "$d_dlopen" in
	    $define) dflt='y' ;;
	esac
	case "$i_dld" in
	    $define) dflt='y' ;;
	esac
	: Does a dl_xxx.xs file exist for this operating system
	$test -f ../$dldir/dl_${osname}.xs && dflt='y'
	;;
esac
rp="Do you wish to use dynamic loading?"
. ./myread
usedl="$ans"
case "$ans" in
y*) usedl="$define"
	case "$dlsrc" in
	'')
		if $test -f ../$dldir/dl_${osname}.xs ; then
			dflt="$dldir/dl_${osname}.xs"
		elif $test "$d_dlopen" = "$define" ; then
			dflt="$dldir/dl_dlopen.xs"
		elif $test "$i_dld" = "$define" ; then
			dflt="$dldir/dl_dld.xs"
		else
			dflt=''
		fi
		;;
	*)	dflt="$dldir/$dlsrc"
		;;
	esac
    echo "The following dynamic loading files are available:"
	: Can not go over to $dldir because getfile has path hard-coded in.
    cd ..; ls -C $dldir/dl*.xs; cd UU
    rp="Source file to use for dynamic loading"
    fn="fne"
    . ./getfile
	usedl="$define"
	: emulate basename
	dlsrc=`echo $ans | $sed -e 's@.*/\([^/]*\)$@\1@'`

    $cat << EOM

Some systems may require passing special flags to $cc -c to
compile modules that will be used to create a shared library.
To use no flags, say "none".

EOM
    case "$cccdlflags" in
    '')	case "$gccversion" in
		'') case "$osname" in
			hpux)	dflt='+z' ;;
			next)	dflt='none' ;;
			svr4*|esix*)	dflt='-Kpic' ;;
			irix*)	dflt='-KPIC' ;;
			solaris) case "$ccflags" in
				*-DDEBUGGING*)	dflt='-KPIC' ;;
				*)		dflt='-Kpic' ;;
				esac ;;
			sunos)	dflt='-pic' ;;
			*)	dflt='none' ;;
		    esac ;;
		*)  case "$osname/$ccflags" in
			solaris/*-DDEBUGGING*)	dflt='-fPIC' ;;
			*)			dflt='-fpic' ;;
		    esac ;;
	    esac ;;
    *)	dflt="$cccdlflags" ;;
    esac
    rp="Any special flags to pass to $cc -c to compile shared library modules?"
    . ./myread
    case "$ans" in
    none) cccdlflags=' ' ;;
    *) cccdlflags="$ans" ;;
    esac

    cat << EOM

Some systems use ld to create libraries that can be dynamically loaded,
while other systems (such as those using ELF) use $cc.

EOM
	case "$ld" in
	'')	$cat >try.c <<'EOM'
/* Test for whether ELF binaries are produced */
#include <fcntl.h>
#include <stdlib.h>
main() {
	char b[4];
	int i = open("a.out",O_RDONLY);
	if(i == -1) 
		exit(1); /* fail */
	if(read(i,b,4)==4 && b[0]==127 && b[1]=='E' && b[2]=='L' && b[3]=='F')
		exit(0); /* succeed (yes, it's ELF) */
	else
		exit(1); /* fail */
}
EOM
		if $cc $ccflags try.c >/dev/null 2>&1 && ./a.out; then
			cat <<EOM
You appear to have ELF support.  I'll use $cc to build dynamic libraries.
EOM
			dflt="$cc"
		else
			echo "I'll use ld to build dynamic libraries."
			dflt='ld'
		fi
		rm -f try.c a.out
		;;
	*)	dflt="$ld"
		;;
	esac

    rp="What command should be used to create dynamic libraries?"
    . ./myread
	ld="$ans"

    cat << EOM

Some systems may require passing special flags to $ld to create a
library that can be dynamically loaded.  If your ld flags include
-L/other/path options to locate libraries outside your loader's normal
search path, you may need to specify those -L options here as well.  To
use no flags, say "none".

EOM
    case "$lddlflags" in
    '') case "$osname" in
			hpux)  dflt='-b' ;;
			linux|irix*)	dflt='-shared' ;;
			next)  dflt='none' ;;
			solaris) dflt='-G' ;;
			sunos) dflt='-assert nodefinitions' ;;
			svr4*|esix*) dflt="-G $ldflags" ;;
	        *)     dflt='none' ;;
			esac
			;;
    *) dflt="$lddlflags" ;;
    esac

: Try to guess additional flags to pick up local libraries.
for thisflag in $ldflags; do
	case "$thisflag" in
	-L*)
		case " $dflt " in
		*" $thisflag "*) ;;
		*) dflt="$dflt $thisflag" ;;
		esac
		;;
	esac
done

case "$dflt" in
'') dflt='none' ;;
esac

    rp="Any special flags to pass to $ld to create a dynamically loaded library?"
    . ./myread
    case "$ans" in
    none) lddlflags=' ' ;;
    *) lddlflags="$ans" ;;
    esac

	cat <<EOM

Some systems may require passing special flags to $cc to indicate that
the resulting executable will use dynamic linking.  To use no flags,
say "none".

EOM
    case "$ccdlflags" in
    '') case "$osname" in
		hpux)	dflt='-Wl,-E' ;;
		linux)	dflt='-rdynamic' ;;
		next)	dflt='none' ;;
		sunos)	dflt='none' ;;
		*)	dflt='none' ;;
	    esac ;;
    *)  dflt="$ccdlflags" ;;
    esac
    rp="Any special flags to pass to $cc to use dynamic loading?"
    . ./myread
    case "$ans" in
    none) ccdlflags=' ' ;;
    *) ccdlflags="$ans" ;;
    esac
    ;;
*)  usedl="$undef"
	ld='ld'
    dlsrc='dl_none.xs'
    lddlflags=''
    ccdlflags=''
    ;;
esac

also=''
case "$usedl" in
$undef)
	# No dynamic loading being used, so don't bother even to prompt.
	useshrplib='false'
	;;
*)	case "$useshrplib" in
	'')	case "$osname" in
		svr4*|dgux|dynixptx|esix|powerux)
			dflt=y
			also='Building a shared libperl is required for dynamic loading to work on your system.'
			;;
		next*)
			case "$osvers" in
			4*)	dflt=y
				also='Building a shared libperl is needed for MAB support.'
				;;
			*)	dflt=n
				;;
			esac
			;;
		sunos)
			dflt=n
			also='Building a shared libperl will definitely not work on SunOS 4.'
			;;
		*)	dflt=n
			;;
		esac
		;;
	$define|true|[Yy]*)
		dflt=y
		;;
	*)	dflt=n
		;;
	esac
	$cat << EOM

The perl executable is normally obtained by linking perlmain.c with
libperl${lib_ext}, any static extensions (usually just DynaLoader), and
any other libraries needed on this system (such as -lm, etc.).  Since
your system supports dynamic loading, it is probably possible to build
a shared libperl.$so.  If you will have more than one executable linked
to libperl.$so, this will significantly reduce the size of each
executable, but it may have a noticeable affect on performance.  The
default is probably sensible for your system.
$also

EOM
	rp="Build a shared libperl.$so (y/n)"
	. ./myread
	case "$ans" in
	true|$define|[Yy]*)
		useshrplib='true'
		# Why does next4 have to be so different?
		case "${osname}${osvers}" in
		next4*)	xxx='DYLD_LIBRARY_PATH' ;;
		*)		xxx='LD_LIBRARY_PATH' ;;
		esac
		$cat <<EOM >&4

To build perl, you must add the current working directory to your
$xxx environtment variable before running make.  You can do
this with
   $xxx=\`pwd\`; export $xxx
for Bourne-style shells, or
   setenv $xxx \`pwd\`
for Csh-style shells.  You *MUST* do this before running make.

EOM
		;;
	*)	useshrplib='false' ;;
	esac
	;;
esac

case "$useshrplib" in
true)
	case "$libperl" in
	'')
		# Figure out a good name for libperl.so.  Since it gets stored in
		# a version-specific architecture-dependent library, the version
		# number isn't really that important, except for making cc/ld happy.
		#
		# A name such as libperl.so.3.1
		majmin="libperl.$so.$patchlevel.$subversion"
		# A name such as libperl.so.301
		majonly=`echo $patchlevel $subversion |
			$awk '{printf "%d%02d", $1, $2}'`
		majonly=libperl.$so.$majonly
		# I'd prefer to keep the os-specific stuff here to a minimum, and
		# rely on figuring it out from the naming of libc.
		case "${osname}${osvers}" in
		next4*)
			dflt=libperl.5.$so
			# XXX How handle the --version stuff for MAB?
			;;
		linux*)  # ld won't link with a bare -lperl otherwise.
			dflt=libperl.$so
			;;
		*)	# Try to guess based on whether libc has major.minor.
			case "$libc" in
			*libc.$so.[0-9]*.[0-9]*) dflt=$majmin ;;
			*libc.$so.[0-9]*) dflt=$majonly ;;
			*)	dflt=libperl.$so ;;
			esac
			;;
		esac
		;;
	*)	dflt=$libperl
		;;
	esac
	cat << EOM

I need to select a good name for the shared libperl.  If your system uses
library names with major and minor numbers, then you might want something
like $majmin.  Alternatively, if your system uses a single version
number for shared libraries, then you might want to use $majonly.
Or, your system might be quite happy with a simple libperl.$so.

Since the shared libperl will get installed into a version-specific
architecture-dependent directory, the version number of the shared perl
library probably isn't important, so the default should be o.k.

EOM
	rp='What name do you want to give to the shared libperl?'
	. ./myread
	libperl=$ans
	echo "Ok, I'll use $libperl"
	;;
*)
	libperl="libperl${lib_ext}"
	;;
esac

# Detect old use of shrpdir via undocumented Configure -Dshrpdir
case "$shrpdir" in
'') ;;
*)	$cat >&4 <<EOM
WARNING:  Use of the shrpdir variable for the installation location of
the shared $libperl is not supported.  It was never documented and
will not work in this version.  Let me (chip@perl.com) know of any
problems this may cause.

EOM
	case "$shrpdir" in
	"$archlibexp/CORE")
		$cat >&4 <<EOM
But your current setting of $shrpdir is
the default anyway, so it's harmless.
EOM
		;;
	*)
		$cat >&4 <<EOM
Further, your current attempted setting of $shrpdir
conflicts with the value of $archlibexp/CORE
that installperl will use.
EOM
		;;
	esac
	;;
esac

# How will the perl executable find the installed shared $libperl?
# Add $xxx to ccdlflags.
# If we can't figure out a command-line option, use $shrpenv to
# set env LD_RUN_PATH.  The main perl makefile uses this.
shrpdir=$archlibexp/CORE
xxx=''
tmp_shrpenv=''
if "$useshrplib"; then
    case "$osname" in 
	aix)
		# We'll set it in Makefile.SH...
		;;
	solaris|netbsd)
		xxx="-R $shrpdir"
		;;
	freebsd)
		xxx="-Wl,-R$shrpdir"
		;;
	linux|irix*|dec_osf)
		xxx="-Wl,-rpath,$shrpdir"
		;;
	next)
		# next doesn't like the default...
		;;
	*)
		tmp_shrpenv="env LD_RUN_PATH=$shrpdir"
		;;
	esac
	case "$xxx" in
	'') ;;
	*)	
		# Only add $xxx if it isn't already in ccdlflags.
		case " $ccdlflags " in
		*" $xxx "*)	;;
		*)	ccdlflags="$ccdlflags $xxx"
			cat <<EOM >&4

Adding $xxx to the flags
passed to $ld so that the perl executable will find the 
installed shared $libperl.

EOM
			;;
		esac
		;;
	esac
fi
# Respect a hint or command-line value.
case "$shrpenv" in
'') shrpenv="$tmp_shrpenv" ;;
esac

: determine where manual pages go
set man1dir man1dir none
eval $prefixit
$cat <<EOM

$spackage has manual pages available in source form.
EOM
case "$nroff" in
nroff)
	echo "However, you don't have nroff, so they're probably useless to you."
	case "$man1dir" in
	'') man1dir="none";;
	esac;;
esac
echo "If you don't want the manual sources installed, answer 'none'."
case "$man1dir" in
' ') dflt=none
	;;
'')
	lookpath="$prefixexp/man/man1 $prefixexp/man/l_man/man1"
	lookpath="$lookpath $prefixexp/man/p_man/man1"
	lookpath="$lookpath $prefixexp/man/u_man/man1"
	lookpath="$lookpath $prefixexp/man/man.1"
	: If prefix contains 'perl' then we want to keep the man pages
	: under the prefix directory.  Otherwise, look in a variety of
	: other possible places.  This is debatable, but probably a
	: good compromise.  Well, apparently not.
	: Experience has shown people expect man1dir to be under prefix,
	: so we now always put it there.  Users who want other behavior
	: can answer interactively or use a command line option.
	: Does user have System V-style man paths.
	case "$sysman" in
	*/?_man*)	dflt=`./loc . $prefixexp/l_man/man1 $lookpath` ;;
	*)	dflt=`./loc . $prefixexp/man/man1 $lookpath` ;;
	esac
	set dflt
	eval $prefixup
	;;
*)  dflt="$man1dir"
	;;
esac
echo " "
fn=dn+~
rp="Where do the main $spackage manual pages (source) go?"
. ./getfile
if $test "X$man1direxp" != "X$ansexp"; then
	installman1dir=''
fi
man1dir="$ans"
man1direxp="$ansexp"
case "$man1dir" in
'') man1dir=' '
	installman1dir='';;
esac
if $afs; then
	$cat <<EOM

Since you are running AFS, I need to distinguish the directory in which
manual pages reside from the directory in which they are installed (and from
which they are presumably copied to the former directory by occult means).

EOM
	case "$installman1dir" in
	'') dflt=`echo $man1direxp | sed 's#^/afs/#/afs/.#'`;;
	*) dflt="$installman1dir";;
	esac
	fn=de~
	rp='Where will man pages be installed?'
	. ./getfile
	installman1dir="$ans"
else
	installman1dir="$man1direxp"
fi

: What suffix to use on installed man pages

case "$man1dir" in
' ')
	man1ext='0'
	;;
*)
	rp="What suffix should be used for the main $spackage man pages?"
	case "$man1ext" in
	'')	case "$man1dir" in
		*1)  dflt=1 ;;
		*1p) dflt=1p ;;
		*1pm) dflt=1pm ;;
		*l) dflt=l;;
		*n) dflt=n;;
		*o) dflt=o;;
		*p) dflt=p;;
		*C) dflt=C;;
		*L) dflt=L;;
		*L1) dflt=L1;;
		*) dflt=1;;
		esac
		;;
	*)	dflt="$man1ext";;
	esac
	. ./myread
	man1ext="$ans"
	;;
esac

: see if we can have long filenames
echo " "
rmlist="$rmlist /tmp/cf$$"
$test -d /tmp/cf$$ || mkdir /tmp/cf$$
first=123456789abcdef
second=/tmp/cf$$/$first
$rm -f $first $second
if (echo hi >$first) 2>/dev/null; then
	if $test -f 123456789abcde; then
		echo 'You cannot have filenames longer than 14 characters.  Sigh.' >&4
		val="$undef"
	else
		if (echo hi >$second) 2>/dev/null; then
			if $test -f /tmp/cf$$/123456789abcde; then
				$cat <<'EOM'
That's peculiar... You can have filenames longer than 14 characters, but only
on some of the filesystems.  Maybe you are using NFS.  Anyway, to avoid problems
I shall consider your system cannot support long filenames at all.
EOM
				val="$undef"
			else
				echo 'You can have filenames longer than 14 characters.' >&4
				val="$define"
			fi
		else
			$cat <<'EOM'
How confusing! Some of your filesystems are sane enough to allow filenames
longer than 14 characters but some others like /tmp can't even think about them.
So, for now on, I shall assume your kernel does not allow them at all.
EOM
			val="$undef"
		fi
	fi
else
	$cat <<'EOM'
You can't have filenames longer than 14 chars.  You can't even think about them!
EOM
	val="$undef"
fi 
set d_flexfnam
eval $setvar
$rm -rf /tmp/cf$$ 123456789abcde*

: determine where library module manual pages go
set man3dir man3dir none
eval $prefixit
$cat <<EOM

$spackage has manual pages for many of the library modules.
EOM

case "$nroff" in
nroff)
	$cat <<'EOM'
However, you don't have nroff, so they're probably useless to you.
You can use the supplied perldoc script instead.
EOM
	case "$man3dir" in
	'') man3dir="none";;
	esac;;
esac

case "$d_flexfnam" in
undef)
	$cat <<'EOM'
However, your system can't handle the long file names like File::Basename.3. 
You can use the supplied perldoc script instead.
EOM
	case "$man3dir" in
	'') man3dir="none";;
	esac;;
esac

echo "If you don't want the manual sources installed, answer 'none'."
: We dont use /usr/local/man/man3 because some man programs will
: only show the /usr/local/man/man3 contents, and not the system ones,
: thus man less will show the perl module less.pm, but not the system
: less command.  We might also conflict with TCL man pages.
: However, something like /opt/perl/man/man3 is fine.
case "$man3dir" in
'')	case "$prefix" in 
	*perl*) dflt=`echo $man1dir | 
			$sed -e 's/man1/man3/g' -e 's/man\.1/man\.3/g'` ;;
	*)	dflt="$privlib/man/man3" ;;
	esac
	;;
' ') dflt=none;;
*)	dflt="$man3dir" ;;
esac
echo " "

fn=dn+~
rp="Where do the $spackage library man pages (source) go?"
. ./getfile
if test "X$man3direxp" != "X$ansexp"; then
	installman3dir=''
fi

man3dir="$ans"
man3direxp="$ansexp"
case "$man3dir" in
'') man3dir=' '
	installman3dir='';;
esac
if $afs; then
	$cat <<EOM

Since you are running AFS, I need to distinguish the directory in which
manual pages reside from the directory in which they are installed (and from
which they are presumably copied to the former directory by occult means).

EOM
	case "$installman3dir" in
	'') dflt=`echo $man3direxp | sed 's#^/afs/#/afs/.#'`;;
	*) dflt="$installman3dir";;
	esac
	fn=de~
	rp='Where will man pages be installed?'
	. ./getfile
	installman3dir="$ans"
else
	installman3dir="$man3direxp"
fi

: What suffix to use on installed man pages

case "$man3dir" in
' ')
	man3ext='0'
	;;
*)
	rp="What suffix should be used for the $spackage library man pages?"
	case "$man3ext" in
	'')	case "$man3dir" in
		*3)  dflt=3 ;;
		*3p) dflt=3p ;;
		*3pm) dflt=3pm ;;
		*l) dflt=l;;
		*n) dflt=n;;
		*o) dflt=o;;
		*p) dflt=p;;
		*C) dflt=C;;
		*L) dflt=L;;
		*L3) dflt=L3;;
		*) dflt=3;;
		esac
		;;
	*)	dflt="$man3ext";;
	esac
	. ./myread
	man3ext="$ans"
	;;
esac

: see if we have to deal with yellow pages, now NIS.
if $test -d /usr/etc/yp || $test -d /etc/yp; then
	if $test -f /usr/etc/nibindd; then
		echo " "
		echo "I'm fairly confident you're on a NeXT."
		echo " "
		rp='Do you get the hosts file via NetInfo?'
		dflt=y
		case "$hostcat" in
		nidump*) ;;
		'') ;;
		*) dflt=n;;
		esac
		. ./myread
		case "$ans" in
		y*) hostcat='nidump hosts .';;
		*)	case "$hostcat" in
			nidump*) hostcat='';;
			esac
			;;
		esac
	fi
	case "$hostcat" in
	nidump*) ;;
	*)
		case "$hostcat" in
		*ypcat*) dflt=y;;
		'') if $contains '^\+' /etc/passwd >/dev/null 2>&1; then
				dflt=y
			else
				dflt=n
			fi;;
		*) dflt=n;;
		esac
		echo " "
		rp='Are you getting the hosts file via yellow pages?'
		. ./myread
		case "$ans" in
		y*) hostcat='ypcat hosts';;
		*) hostcat='cat /etc/hosts';;
		esac
		;;
	esac
fi

: now get the host name
echo " "
echo "Figuring out host name..." >&4
case "$myhostname" in
'') cont=true
	echo 'Maybe "hostname" will work...'
	if tans=`sh -c hostname 2>&1` ; then
		myhostname=$tans
		phostname=hostname
		cont=''
	fi
	;;
*) cont='';;
esac
if $test "$cont"; then
	if ./xenix; then
		echo 'Oh, dear.  Maybe "/etc/systemid" is the key...'
		if tans=`cat /etc/systemid 2>&1` ; then
			myhostname=$tans
			phostname='cat /etc/systemid'
			echo "Whadyaknow.  Xenix always was a bit strange..."
			cont=''
		fi
	elif $test -r /etc/systemid; then
		echo "(What is a non-Xenix system doing with /etc/systemid?)"
	fi
fi
if $test "$cont"; then
	echo 'No, maybe "uuname -l" will work...'
	if tans=`sh -c 'uuname -l' 2>&1` ; then
		myhostname=$tans
		phostname='uuname -l'
	else
		echo 'Strange.  Maybe "uname -n" will work...'
		if tans=`sh -c 'uname -n' 2>&1` ; then
			myhostname=$tans
			phostname='uname -n'
		else
			echo 'Oh well, maybe I can mine it out of whoami.h...'
			if tans=`sh -c $contains' sysname $usrinc/whoami.h' 2>&1` ; then
				myhostname=`echo "$tans" | $sed 's/^.*"\(.*\)"/\1/'`
				phostname="sed -n -e '"'/sysname/s/^.*\"\\(.*\\)\"/\1/{'"' -e p -e q -e '}' <$usrinc/whoami.h"
			else
				case "$myhostname" in
				'') echo "Does this machine have an identity crisis or something?"
					phostname='';;
				*)
					echo "Well, you said $myhostname before..."
					phostname='echo $myhostname';;
				esac
			fi
		fi
	fi
fi
: you do not want to know about this
set $myhostname
myhostname=$1

: verify guess
if $test "$myhostname" ; then
	dflt=y
	rp='Your host name appears to be "'$myhostname'".'" Right?"
	. ./myread
	case "$ans" in
	y*) ;;
	*) myhostname='';;
	esac
fi

: bad guess or no guess
while $test "X$myhostname" = X ; do
	dflt=''
	rp="Please type the (one word) name of your host:"
	. ./myread
	myhostname="$ans"
done

: translate upper to lower if necessary
case "$myhostname" in
*[A-Z]*)
	echo "(Normalizing case in your host name)"
	myhostname=`echo $myhostname | ./tr '[A-Z]' '[a-z]'`
	;;
esac

case "$myhostname" in
*.*)
	dflt=`expr "X$myhostname" : "X[^.]*\(\..*\)"`
	myhostname=`expr "X$myhostname" : "X\([^.]*\)\."`
	echo "(Trimming domain name from host name--host name is now $myhostname)"
	;;
*) case "$mydomain" in
	'')
		{
			: If we use NIS, try ypmatch.
			: Is there some reason why this was not done before?
			test "X$hostcat" = "Xypcat hosts" &&
			ypmatch "$myhostname" hosts 2>/dev/null |\
				$sed -e 's/[	 ]*#.*//; s/$/ /' > hosts && \
			$test -s hosts
		} || {
			: Extract only the relevant hosts, reducing file size,
			: remove comments, insert trailing space for later use.
		     	$hostcat | $sed -n -e "s/[	 ]*#.*//; s/\$/ /
					/[	 ]$myhostname[	. ]/p" > hosts
		}
		tmp_re="[	. ]"
		$test x`$awk "/[0-9].*[	 ]$myhostname$tmp_re/ { sum++ }
			     END { print sum }" hosts` = x1 || tmp_re="[	 ]"
		dflt=.`$awk "/[0-9].*[	 ]$myhostname$tmp_re/ {for(i=2; i<=NF;i++) print \\\$i}" \
			hosts | $sort | $uniq | \
			$sed -n -e "s/$myhostname\.\([-a-zA-Z0-9_.]\)/\1/p"`
		case `$echo X$dflt` in
		X*\ *)	echo "(Several hosts in /etc/hosts matched hostname)"
			dflt=.
			;;
		X.) echo "(You do not have fully-qualified names in /etc/hosts)"
			;;
		esac
		case "$dflt" in
		.)
			tans=`./loc resolv.conf X /etc /usr/etc`
			if $test -f "$tans"; then
				echo "(Attempting domain name extraction from $tans)"
				: Why was there an Egrep here, when Sed works?
				: Look for either a search or a domain directive.
				dflt=.`$sed -n -e 's/	/ /g' \
				  -e 's/^search  *\([^ ]*\).*/\1/p' $tans \
				  | ./tr '[A-Z]' '[a-z]' 2>/dev/null`
				case "$dflt" in
				.) dflt=.`$sed -n -e 's/	/ /g' \
				     -e 's/^domain  *\([^ ]*\).*/\1/p' $tans \
				     | ./tr '[A-Z]' '[a-z]' 2>/dev/null`
  					;;
				esac
			fi
			;;
		esac
		case "$dflt" in
		.) echo "(No help from resolv.conf either -- attempting clever guess)"
			dflt=.`sh -c domainname 2>/dev/null`
			case "$dflt" in
			'') dflt='.';;
			.nis.*|.yp.*|.main.*) dflt=`echo $dflt | $sed -e 's/^\.[^.]*//'`;;
			esac
			;;
		esac
		case "$dflt" in
		.) echo "(Lost all hope -- silly guess then)"
			dflt='.uucp'
			;;
		esac
		$rm -f hosts
		;;
	*) dflt="$mydomain";;
	esac;;
esac
echo " "
rp="What is your domain name?"
. ./myread
tans="$ans"
case "$ans" in
'') ;;
.*) ;;
*) tans=".$tans";;
esac
mydomain="$tans"

: translate upper to lower if necessary
case "$mydomain" in
*[A-Z]*)
	echo "(Normalizing case in your domain name)"
	mydomain=`echo $mydomain | ./tr '[A-Z]' '[a-z]'`
	;;
esac

: a little sanity check here
case "$phostname" in
'') ;;
*)
	case `$phostname | ./tr '[A-Z]' '[a-z]'` in
	$myhostname$mydomain|$myhostname) ;;
	*)
		case "$phostname" in
		sed*)
			echo "(That doesn't agree with your whoami.h file, by the way.)"
			;;
		*)
			echo "(That doesn't agree with your $phostname command, by the way.)"
			;;
		esac
	;;
	esac
	;;
esac

$cat <<EOM

I need to get your e-mail address in Internet format if possible, i.e.
something like user@host.domain. Please answer accurately since I have
no easy means to double check it. The default value provided below
is most probably close to the reality but may not be valid from outside
your organization...

EOM
cont=x
while test "$cont"; do
	case "$cf_email" in
	'') dflt="$cf_by@$myhostname$mydomain";;
	*) dflt="$cf_email";;
	esac
	rp='What is your e-mail address?'
	. ./myread
	cf_email="$ans"
	case "$cf_email" in
	*@*.*) cont='' ;;
	*)
		rp='Address does not look like an Internet one.  Use it anyway?'
		case "$fastread" in
		yes) dflt=y ;;
		*) dflt=n ;;
		esac
		. ./myread
		case "$ans" in
		y*) cont='' ;;
		*) echo " " ;;
		esac
		;;
	esac
done

$cat <<EOM

If you or somebody else will be maintaining perl at your site, please
fill in the correct e-mail address here so that they may be contacted
if necessary. Currently, the "perlbug" program included with perl
will send mail to this address in addition to perlbug@perl.com. You may
enter "none" for no administrator.

EOM
case "$perladmin" in
'') dflt="$cf_email";;
*) dflt="$perladmin";;
esac
rp='Perl administrator e-mail address'
. ./myread
perladmin="$ans"

: figure out how to guarantee perl startup
case "$startperl" in
'')
	case "$sharpbang" in
	*!)
		$cat <<EOH

I can use the #! construct to start perl on your system. This will
make startup of perl scripts faster, but may cause problems if you
want to share those scripts and perl is not in a standard place
($binexp/perl) on all your platforms. The alternative is to force
a shell by starting the script with a single ':' character.

EOH
		dflt="$binexp/perl"
		rp='What shall I put after the #! to start up perl ("none" to not use #!)?'
		. ./myread
		case "$ans" in
		none)	startperl=": # use perl";;
		*)	startperl="#!$ans"
			if $test 30 -lt `echo "$ans" | wc -c`; then
				$cat >&4 <<EOM

WARNING:  Some systems limit the #! command to 32 characters.
If you experience difficulty running Perl scripts with #!, try
installing Perl in a directory with a shorter pathname.

EOM
			fi ;;
		esac
		;;
	*) startperl=": # use perl"
		;;
	esac
	;;
esac
echo "I'll use $startperl to start perl scripts."

: figure best path for perl in scripts
case "$perlpath" in
'')
	perlpath="$binexp/perl"
	case "$startperl" in
	*!*) ;;
	*)
		$cat <<EOH

I will use the "eval 'exec'" idiom to start Perl on your system.
I can use the full path of your Perl binary for this purpose, but
doing so may cause problems if you want to share those scripts and
Perl is not always in a standard place ($binexp/perl).

EOH
		dflt="$binexp/perl"
		rp="What path shall I use in \"eval 'exec'\"?"
		. ./myread
		perlpath="$ans"
		;;
	esac
	;;
esac
case "$startperl" in
*!*)	;;
*)	echo "I'll use $perlpath in \"eval 'exec'\"" ;;
esac

: determine where public executable scripts go
set scriptdir scriptdir
eval $prefixit
case "$scriptdir" in
'')
	dflt="$bin"
	: guess some guesses
	$test -d /usr/share/scripts && dflt=/usr/share/scripts
	$test -d /usr/share/bin && dflt=/usr/share/bin
	$test -d /usr/local/script && dflt=/usr/local/script
	$test -d $prefixexp/script && dflt=$prefixexp/script
	set dflt
	eval $prefixup
	;;
*)  dflt="$scriptdir"
	;;
esac
$cat <<EOM
 
Some installations have a separate directory just for executable scripts so
that they can mount it across multiple architectures but keep the scripts in
one spot.  You might, for example, have a subdirectory of /usr/share for this.
Or you might just lump your scripts in with all your other executables.
 
EOM
fn=d~
rp='Where do you keep publicly executable scripts?'
. ./getfile
if $test "X$ansexp" != "X$scriptdirexp"; then
	installscript=''
fi
scriptdir="$ans"
scriptdirexp="$ansexp"
if $afs; then
	$cat <<EOM

Since you are running AFS, I need to distinguish the directory in which
scripts reside from the directory in which they are installed (and from
which they are presumably copied to the former directory by occult means).

EOM
	case "$installscript" in
	'') dflt=`echo $scriptdirexp | sed 's#^/afs/#/afs/.#'`;;
	*) dflt="$installscript";;
	esac
	fn=de~
	rp='Where will public scripts be installed?'
	. ./getfile
	installscript="$ans"
else
	installscript="$scriptdirexp"
fi

cat <<EOM

Previous version of $package used the standard IO mechanisms as defined in
<stdio.h>.  Versions 5.003_02 and later of perl allow alternate IO
mechanisms via a "PerlIO" abstraction, but the stdio mechanism is still
the default and is the only supported mechanism.  This abstraction
layer can use AT&T's sfio (if you already have sfio installed) or
fall back on standard IO.  This PerlIO abstraction layer is
experimental and may cause problems with some extension modules.

If this doesn't make any sense to you, just accept the default 'n'.
EOM
case "$useperlio" in
$define|true|[yY]*)	dflt='y';;
*) dflt='n';;
esac
rp='Use the experimental PerlIO abstraction layer?'
. ./myread
case "$ans" in
y|Y) 
	val="$define"
	;;     
*)      
	echo "Ok, doing things the stdio way"
	val="$undef"
	;;
esac
set useperlio
eval $setvar 

: Check how to convert floats to strings.
echo " "
echo "Checking for an efficient way to convert floats to strings."
$cat >try.c <<'EOP'
#ifdef TRY_gconvert
#define Gconvert(x,n,t,b) gconvert((x),(n),(t),(b))
char *myname = "gconvert";
#endif
#ifdef TRY_gcvt
#define Gconvert(x,n,t,b) gcvt((x),(n),(b))
char *myname = "gcvt";
#endif
#ifdef TRY_sprintf
#define Gconvert(x,n,t,b) sprintf((b),"%.*g",(n),(x))
char *myname = "sprintf";
#endif

#include <stdio.h>

int
checkit(expect, got)
char *expect;
char *got;
{
    if (strcmp(expect, got)) {
		printf("%s oddity:  Expected %s, got %s\n",
			myname, expect, got);
		exit(1);
	}
}

int
main()
{ 
	char buf[64]; 
	buf[63] = '\0';

	/* This must be 1st test on (which?) platform */
	/* Alan Burlison <AlanBurlsin@unn.unisys.com> */
	Gconvert(0.1, 8, 0, buf);
	checkit("0.1", buf);

	Gconvert(1.0, 8, 0, buf); 
	checkit("1", buf);

	Gconvert(0.0, 8, 0, buf); 
	checkit("0", buf);

	Gconvert(-1.0, 8, 0, buf); 
	checkit("-1", buf);

	/* Some Linux gcvt's give 1.e+5 here. */
	Gconvert(100000.0, 8, 0, buf); 
	checkit("100000", buf);
	
	/* Some Linux gcvt's give -1.e+5 here. */
	Gconvert(-100000.0, 8, 0, buf); 
	checkit("-100000", buf);

	exit(0);
}
EOP
case "$d_Gconvert" in
gconvert*) xxx_list='gconvert gcvt sprintf' ;;
gcvt*) xxx_list='gcvt gconvert sprintf' ;;
sprintf*) xxx_list='sprintf gconvert gcvt' ;;
*) xxx_list='gconvert gcvt sprintf' ;;
esac

for xxx_convert in $xxx_list; do
	echo "Trying $xxx_convert"
	$rm -f try try.o
	if $cc $ccflags -DTRY_$xxx_convert $ldflags -o try \
		try.c $libs > /dev/null 2>&1 ; then
		echo "$xxx_convert" found. >&4
		if ./try; then
			echo "I'll use $xxx_convert to convert floats into a string." >&4
			break;
		else
			echo "...But $xxx_convert didn't work as I expected."
		fi
	else
		echo "$xxx_convert NOT found." >&4
	fi
done
		
case "$xxx_convert" in
gconvert) d_Gconvert='gconvert((x),(n),(t),(b))' ;;
gcvt) d_Gconvert='gcvt((x),(n),(b))' ;;
*) d_Gconvert='sprintf((b),"%.*g",(n),(x))' ;;
esac

: Initialize h_fcntl
h_fcntl=false

: Initialize h_sysfile
h_sysfile=false

: access call always available on UNIX
set access d_access
eval $inlibc

: locate the flags for 'access()'
case "$d_access" in
"$define")
	echo " "
	$cat >access.c <<'EOCP'
#include <sys/types.h>
#ifdef I_FCNTL
#include <fcntl.h>
#endif
#ifdef I_SYS_FILE
#include <sys/file.h>
#endif
#ifdef I_UNISTD
#include <unistd.h>
#endif
main() {
	exit(R_OK);
}
EOCP
	: check sys/file.h first, no particular reason here
	if $test `./findhdr sys/file.h` && \
		$cc $cppflags -DI_SYS_FILE access.c -o access >/dev/null 2>&1 ; then
		h_sysfile=true;
		echo "<sys/file.h> defines the *_OK access constants." >&4
	elif $test `./findhdr fcntl.h` && \
		$cc $cppflags -DI_FCNTL access.c -o access >/dev/null 2>&1 ; then
		h_fcntl=true;
		echo "<fcntl.h> defines the *_OK access constants." >&4
	elif $test `./findhdr unistd.h` && \
		$cc $cppflags -DI_UNISTD access.c -o access >/dev/null 2>&1 ; then
		echo "<unistd.h> defines the *_OK access constants." >&4
	else
		echo "I can't find the four *_OK access constants--I'll use mine." >&4
	fi
	;;
esac
$rm -f access*

: see if alarm exists
set alarm d_alarm
eval $inlibc

: Look for GNU-cc style attribute checking
echo " "
echo "Checking whether your compiler can handle __attribute__ ..." >&4
$cat >attrib.c <<'EOCP'
#include <stdio.h>
void croak (char* pat,...) __attribute__((format(printf,1,2),noreturn));
EOCP
if $cc $ccflags -c attrib.c >attrib.out 2>&1 ; then
	if $contains 'warning' attrib.out >/dev/null 2>&1; then
		echo "Your C compiler doesn't fully support __attribute__."
		val="$undef"
	else
		echo "Your C compiler supports __attribute__."
		val="$define"
	fi
else
	echo "Your C compiler doesn't seem to understand __attribute__ at all."
	val="$undef"
fi
set d_attribut
eval $setvar
$rm -f attrib*

: see if bcmp exists
set bcmp d_bcmp
eval $inlibc

: see if bcopy exists
set bcopy d_bcopy
eval $inlibc

: see if this is a unistd.h system
set unistd.h i_unistd
eval $inhdr

: see if getpgrp exists
set getpgrp d_getpgrp
eval $inlibc

echo "Checking to see which flavor of getpgrp is in use . . . "
case "$d_getpgrp" in
"$define")
	echo " "
	$cat >set.c <<EOP
#$i_unistd I_UNISTD
#include <sys/types.h>
#ifdef I_UNISTD
#  include <unistd.h>
#endif
main()
{
	if (getuid() == 0) {
		printf("(I see you are running Configure as super-user...)\n");
		setuid(1);
	}
#ifdef TRY_BSD_PGRP
	if (getpgrp(1) == 0)
		exit(0);
#else
	if (getpgrp() > 0)
		exit(0);
#endif
	exit(1);
}
EOP
	if $cc -DTRY_BSD_PGRP $ccflags $ldflags -o set set.c $libs >/dev/null 2>&1 && ./set; then
		echo "You have to use getpgrp(pid) instead of getpgrp()." >&4
		val="$define"
	elif $cc $ccflags $ldflags -o set set.c $libs >/dev/null 2>&1 && ./set; then
		echo "You have to use getpgrp() instead of getpgrp(pid)." >&4
		val="$undef"
	else
		echo "I can't seem to compile and run the test program."
		if ./usg; then
			xxx="a USG one, i.e. you use getpgrp()."
		else
			# SVR4 systems can appear rather BSD-ish.
			case "$i_unistd" in
			$undef)
				xxx="a BSD one, i.e. you use getpgrp(pid)."
				val="$define"
				;;
			$define)
				xxx="probably a USG one, i.e. you use getpgrp()."
				val="$undef"
				;;
			esac
		fi
		echo "Assuming your getpgrp is $xxx" >&4
	fi
	;;
*) val="$undef";;
esac
set d_bsdgetpgrp
eval $setvar
$rm -f set set.c

: see if setpgrp exists
set setpgrp d_setpgrp
eval $inlibc

echo "Checking to see which flavor of setpgrp is in use . . . "
case "$d_setpgrp" in
"$define")
	echo " "
	$cat >set.c <<EOP
#$i_unistd I_UNISTD
#include <sys/types.h>
#ifdef I_UNISTD
#  include <unistd.h>
#endif
main()
{
	if (getuid() == 0) {
		printf("(I see you are running Configure as super-user...)\n");
		setuid(1);
	}
#ifdef TRY_BSD_PGRP
	if (-1 == setpgrp(1, 1))
		exit(0);
#else
	if (setpgrp() != -1)
		exit(0);
#endif
	exit(1);
}
EOP
	if $cc -DTRY_BSD_PGRP $ccflags $ldflags -o set set.c $libs >/dev/null 2>&1 && ./set; then
		echo 'You have to use setpgrp(pid,pgrp) instead of setpgrp().' >&4
		val="$define"
	elif $cc $ccflags $ldflags -o set set.c $libs >/dev/null 2>&1 && ./set; then
		echo 'You have to use setpgrp() instead of setpgrp(pid,pgrp).' >&4
		val="$undef"
	else
		echo "I can't seem to compile and run the test program."
		if ./usg; then
			xxx="a USG one, i.e. you use setpgrp()."
		else
			# SVR4 systems can appear rather BSD-ish.
			case "$i_unistd" in
			$undef)
				xxx="a BSD one, i.e. you use setpgrp(pid,pgrp)."
				val="$define"
				;;
			$define)
				xxx="probably a USG one, i.e. you use setpgrp()."
				val="$undef"
				;;
			esac
		fi
		echo "Assuming your setpgrp is $xxx" >&4
	fi
	;;
*) val="$undef";;
esac
set d_bsdsetpgrp
eval $setvar
d_bsdpgrp=$d_bsdsetpgrp
$rm -f set set.c
: see if bzero exists
set bzero d_bzero
eval $inlibc

: check for lengths of integral types
echo " "
case "$intsize" in
'')
	echo "Checking to see how big your integers are..." >&4
	$cat >intsize.c <<'EOCP'
#include <stdio.h>
main()
{
	printf("intsize=%d;\n", sizeof(int));
	printf("longsize=%d;\n", sizeof(long));
	printf("shortsize=%d;\n", sizeof(short));
	fflush(stdout);
	exit(0);
}
EOCP
#	If $libs contains -lsfio, and sfio is mis-configured, then it
#	sometimes (apparently) runs and exits with a 0 status, but with no
#	output!.  Thus we check with test -s whether we actually got any 
#	output.  I think it has to do with sfio's use of _exit vs. exit,
#	but I don't know for sure.  --Andy Dougherty  1/27/97.
	if $cc $optimize $ccflags $ldflags -o intsize intsize.c $libs >/dev/null 2>&1 && 
	./intsize > intsize.out 2>/dev/null && test -s intsize.out ; then
		eval `$cat intsize.out`
		echo "Your integers are $intsize bytes long."
		echo "Your long integers are $longsize bytes long."
		echo "Your short integers are $shortsize bytes long."
	else
		$cat >&4 <<EOM

Help! I can't compile and run the intsize test program: please enlighten me!
(This is probably a misconfiguration in your system or libraries, and
you really ought to fix it.  Still, I'll try anyway.)

EOM
		dflt=4
		rp="What is the size of an integer (in bytes)?"
		. ./myread
		intsize="$ans"
		dflt=$intsize
		rp="What is the size of a long integer (in bytes)?"
		. ./myread
		longsize="$ans"
		dflt=2
		rp="What is the size of a short integer (in bytes)?"
		. ./myread
		shortsize="$ans"
	fi
	;;
esac
$rm -f intsize intsize.[co] intsize.out

: see if signal is declared as pointer to function returning int or void
echo " "
xxx=`./findhdr signal.h`
$test "$xxx" && $cppstdin $cppminus $cppflags < $xxx >$$.tmp 2>/dev/null
if $contains 'int.*\*[ 	]*signal' $$.tmp >/dev/null 2>&1 ; then
	echo "You have int (*signal())() instead of void." >&4
	val="$undef"
elif $contains 'void.*\*[ 	]*signal' $$.tmp >/dev/null 2>&1 ; then
	echo "You have void (*signal())() instead of int." >&4
	val="$define"
elif $contains 'extern[ 	]*[(\*]*signal' $$.tmp >/dev/null 2>&1 ; then
	echo "You have int (*signal())() instead of void." >&4
	val="$undef"
else
	case "$d_voidsig" in
	'')
	echo "I can't determine whether signal handler returns void or int..." >&4
		dflt=void
		rp="What type does your signal handler return?"
		. ./myread
		case "$ans" in
		v*) val="$define";;
		*) val="$undef";;
		esac;;
	"$define")
		echo "As you already told me, signal handler returns void." >&4;;
	*)
		echo "As you already told me, signal handler returns int." >&4;;
	esac
fi
set d_voidsig
eval $setvar
case "$d_voidsig" in
"$define") signal_t="void";;
*) signal_t="int";;
esac
$rm -f $$.tmp

: check for ability to cast large floats to 32-bit ints.
echo " "
echo 'Checking whether your C compiler can cast large floats to int32.' >&4
if $test "$intsize" -eq 4; then
	xxx=int
else
	xxx=long
fi
$cat >try.c <<EOCP
#include <sys/types.h>
#include <signal.h>
$signal_t blech() { exit(3); }
main()
{
	$xxx i32;
	double f;
	int result = 0;
	signal(SIGFPE, blech);

	f = (double) 0x7fffffff;
	f = 10 * f;
	i32  = ($xxx) f;

	if (i32 != ($xxx) f)
		result |= 1;
	exit(result);
}
EOCP
if $cc -o try $ccflags try.c >/dev/null 2>&1; then
	./try
	yyy=$?
else
	echo "(I can't seem to compile the test program--assuming it can't)"
	yyy=1
fi
case "$yyy" in
0)	val="$define"
	echo "Yup, it can."
	;;
*)	val="$undef"
	echo "Nope, it can't."
	;;
esac
set d_casti32
eval $setvar
$rm -f try try.*

: check for ability to cast negative floats to unsigned
echo " "
echo 'Checking whether your C compiler can cast negative float to unsigned.' >&4
$cat >try.c <<EOCP
#include <sys/types.h>
#include <signal.h>
$signal_t blech() { exit(7); }
$signal_t blech_in_list() { exit(4); }
unsigned long dummy_long(p) unsigned long p; { return p; }
unsigned int dummy_int(p) unsigned int p; { return p; }
unsigned short dummy_short(p) unsigned short p; { return p; }
main()
{
	double f = -123.;
	unsigned long along;
	unsigned int aint;
	unsigned short ashort;
	int result = 0;

	signal(SIGFPE, blech);
	along = (unsigned long)f;
	aint = (unsigned int)f;
	ashort = (unsigned short)f;
	if (along != (unsigned long)-123)
		result |= 1;
	if (aint != (unsigned int)-123)
		result |= 1;
	if (ashort != (unsigned short)-123)
		result |= 1;
	f = (double)0x40000000;
	f = f + f;
	along = 0;
	along = (unsigned long)f;
	if (along != 0x80000000)
		result |= 2;
	f -= 1.;
	along = 0;
	along = (unsigned long)f;
	if (along != 0x7fffffff)
		result |= 1;
	f += 2.;
	along = 0;
	along = (unsigned long)f;
	if (along != 0x80000001)
		result |= 2;
	if (result)
		exit(result);
	signal(SIGFPE, blech_in_list);
	f = 123.;
	along = dummy_long((unsigned long)f);
	aint = dummy_int((unsigned int)f);
	ashort = dummy_short((unsigned short)f);
	if (along != (unsigned long)123)
		result |= 4;
	if (aint != (unsigned int)123)
		result |= 4;
	if (ashort != (unsigned short)123)
		result |= 4;
	exit(result);

}
EOCP
if $cc -o try $ccflags try.c >/dev/null 2>&1; then
	./try
	castflags=$?
else
	echo "(I can't seem to compile the test program--assuming it can't)"
	castflags=7
fi
case "$castflags" in
0)	val="$define"
	echo "Yup, it can."
	;;
*)	val="$undef"
	echo "Nope, it can't."
	;;
esac
set d_castneg
eval $setvar
$rm -f try.*

: see if vprintf exists
echo " "
if set vprintf val -f d_vprintf; eval $csym; $val; then
	echo 'vprintf() found.' >&4
	val="$define"
	$cat >vprintf.c <<'EOF'
#include <varargs.h>

main() { xxx("foo"); }

xxx(va_alist)
va_dcl
{
	va_list args;
	char buf[10];

	va_start(args);
	exit((unsigned long)vsprintf(buf,"%s",args) > 10L);
}
EOF
	if $cc $ccflags vprintf.c -o vprintf >/dev/null 2>&1 && ./vprintf; then
		echo "Your vsprintf() returns (int)." >&4
		val2="$undef"
	else
		echo "Your vsprintf() returns (char*)." >&4
		val2="$define"
	fi
else
	echo 'vprintf() NOT found.' >&4
		val="$undef"
		val2="$undef"
fi
set d_vprintf
eval $setvar
val=$val2
set d_charvspr
eval $setvar

: see if chown exists
set chown d_chown
eval $inlibc

: see if chroot exists
set chroot d_chroot
eval $inlibc

: see if chsize exists
set chsize d_chsize
eval $inlibc

: check for const keyword
echo " "
echo 'Checking to see if your C compiler knows about "const"...' >&4
$cat >const.c <<'EOCP'
typedef struct spug { int drokk; } spug;
main()
{
	const char *foo;
	const spug y;
}
EOCP
if $cc -c $ccflags const.c >/dev/null 2>&1 ; then
	val="$define"
	echo "Yup, it does."
else
	val="$undef"
	echo "Nope, it doesn't."
fi
set d_const
eval $setvar

: see if crypt exists
echo " "
if set crypt val -f d_crypt; eval $csym; $val; then
	echo 'crypt() found.' >&4
	val="$define"
	cryptlib=''
else
	cryptlib=`./loc Slibcrypt$lib_ext "" $xlibpth`
	if $test -z "$cryptlib"; then
		cryptlib=`./loc Mlibcrypt$lib_ext "" $xlibpth`
	else
		cryptlib=-lcrypt
	fi
	if $test -z "$cryptlib"; then
		cryptlib=`./loc Llibcrypt$lib_ext "" $xlibpth`
	else
		cryptlib=-lcrypt
	fi
	if $test -z "$cryptlib"; then
		cryptlib=`./loc libcrypt$lib_ext "" $libpth`
	else
		cryptlib=-lcrypt
	fi
	if $test -z "$cryptlib"; then
		echo 'crypt() NOT found.' >&4
		val="$undef"
	else
		val="$define"
	fi
fi
set d_crypt
eval $setvar

: get csh whereabouts
case "$csh" in
'csh')	val="$undef" ;;
*)	val="$define" ;;
esac
set d_csh
eval $setvar
: Respect a hint or command line value for full_csh.
case "$full_csh" in
'') full_csh=$csh ;;
esac

: see if cuserid exists
set cuserid d_cuserid
eval $inlibc

: see if this is a limits.h system
set limits.h i_limits
eval $inhdr

: see if this is a float.h system
set float.h i_float
eval $inhdr

: See if number of significant digits in a double precision number is known
echo " "
$cat >dbl_dig.c <<EOM
#$i_limits I_LIMITS
#$i_float I_FLOAT
#ifdef I_LIMITS
#include <limits.h>
#endif
#ifdef I_FLOAT
#include <float.h>
#endif
#ifdef DBL_DIG
printf("Contains DBL_DIG");
#endif
EOM
$cppstdin $cppflags $cppminus < dbl_dig.c >dbl_dig.E 2>/dev/null
if $contains 'DBL_DIG' dbl_dig.E >/dev/null 2>&1; then
	echo "DBL_DIG found." >&4
	val="$define"
else
	echo "DBL_DIG NOT found." >&4
	val="$undef"
fi
$rm -f dbl_dig.?
set d_dbl_dig
eval $setvar

: see if difftime exists
set difftime d_difftime
eval $inlibc

: see if this is a dirent system
echo " "
if xinc=`./findhdr dirent.h`; $test "$xinc"; then
	val="$define"
	echo "<dirent.h> found." >&4
else
	val="$undef"
	if xinc=`./findhdr sys/dir.h`; $test "$xinc"; then
		echo "<sys/dir.h> found." >&4
		echo " "
	else
		xinc=`./findhdr sys/ndir.h`
	fi
	echo "<dirent.h> NOT found." >&4
fi
set i_dirent
eval $setvar

: Look for type of directory structure.
echo " "
$cppstdin $cppflags $cppminus < "$xinc" > try.c

case "$direntrytype" in
''|' ')
	case "$i_dirent" in
	$define) guess1='struct dirent' ;;
	*) guess1='struct direct'  ;;
	esac
	;;
*)	guess1="$direntrytype"
	;;
esac

case "$guess1" in
'struct dirent') guess2='struct direct' ;;
*) guess2='struct dirent' ;;
esac
		
if $contains "$guess1" try.c >/dev/null 2>&1; then
	direntrytype="$guess1"
	echo "Your directory entries are $direntrytype." >&4
elif $contains "$guess2" try.c >/dev/null 2>&1; then
	direntrytype="$guess2"
	echo "Your directory entries seem to be $direntrytype." >&4
else
	echo "I don't recognize your system's directory entries." >&4
	rp="What type is used for directory entries on this system?"
	dflt="$guess1"
	. ./myread
	direntrytype="$ans"
fi
$rm -f try.c


: see if the directory entry stores field length
echo " "
$cppstdin $cppflags $cppminus < "$xinc" > try.c
if $contains 'd_namlen' try.c >/dev/null 2>&1; then
	echo "Good, your directory entry keeps length information in d_namlen." >&4
	val="$define"
else
	echo "Your directory entry does not know about the d_namlen field." >&4
	val="$undef"
fi
set d_dirnamlen
eval $setvar
$rm -f try.c

: see if dlerror exists
xxx_runnm="$runnm"
runnm=false
set dlerror d_dlerror
eval $inlibc
runnm="$xxx_runnm"

: see if dlfcn is available
set dlfcn.h i_dlfcn
eval $inhdr

case "$usedl" in
$define|y|true)
	$cat << EOM

On a few systems, the dynamically loaded modules that perl generates and uses
will need a different extension then shared libs. The default will probably
be appropriate.

EOM
	case "$dlext" in
	'')	dflt="$so" ;;
	*)	dflt="$dlext" ;;
	esac
	rp='What is the extension of dynamically loaded modules'
	. ./myread
	dlext="$ans"
	;;
*)
	dlext="none"
	;;
esac

: Check if dlsym need a leading underscore
echo " "
val="$undef"

case "$dlsrc" in
dl_dlopen.xs)
	echo "Checking whether your dlsym() needs a leading underscore ..." >&4
	$cat >dyna.c <<'EOM'
fred () { }
EOM

$cat >fred.c<<EOM

#include <stdio.h>
#$i_dlfcn I_DLFCN
#ifdef I_DLFCN
#include <dlfcn.h>      /* the dynamic linker include file for Sunos/Solaris */
#else
#include <sys/types.h>
#include <nlist.h>
#include <link.h>
#endif

extern int fred() ;

main()
{
    void * handle ;
    void * symbol ;
#ifndef RTLD_LAZY
    int mode = 1 ;
#else
    int mode = RTLD_LAZY ;
#endif
    handle = dlopen("./dyna.$dlext", mode) ;
    if (handle == NULL) {
	printf ("1\n") ;
	fflush (stdout) ;
	exit(0);
    }
    symbol = dlsym(handle, "fred") ;
    if (symbol == NULL) {
	/* try putting a leading underscore */
	symbol = dlsym(handle, "_fred") ;
	if (symbol == NULL) {
	    printf ("2\n") ;
	    fflush (stdout) ;
	    exit(0);
	}
	printf ("3\n") ;
    }
    else
	printf ("4\n") ;
    fflush (stdout) ;
    exit(0);
}
EOM
	: Call the object file tmp-dyna.o in case dlext=o.
	if $cc $ccflags $cccdlflags -c dyna.c > /dev/null 2>&1 && 
		mv dyna${obj_ext} tmp-dyna${obj_ext} > /dev/null 2>&1 && 
		$ld $lddlflags -o dyna.$dlext tmp-dyna${obj_ext} > /dev/null 2>&1 && 
		$cc $ccflags $ldflags $cccdlflags $ccdlflags fred.c -o fred $libs > /dev/null 2>&1; then
		xxx=`./fred`
		case $xxx in
		1)	echo "Test program failed using dlopen." >&4
			echo "Perhaps you should not use dynamic loading." >&4;;
		2)	echo "Test program failed using dlsym." >&4
			echo "Perhaps you should not use dynamic loading." >&4;;
		3)	echo "dlsym needs a leading underscore" >&4
			val="$define" ;;
		4)	echo "dlsym doesn't need a leading underscore." >&4;;
		esac
	else
		echo "I can't compile and run the test program." >&4
	fi
	;;
esac
		
$rm -f fred fred.? dyna.$dlext dyna.? tmp-dyna.?

set d_dlsymun
eval $setvar

: see if dup2 exists
set dup2 d_dup2
eval $inlibc

: Locate the flags for 'open()'
echo " "
$cat >open3.c <<'EOCP'
#include <sys/types.h>
#ifdef I_FCNTL
#include <fcntl.h>
#endif
#ifdef I_SYS_FILE
#include <sys/file.h>
#endif
main() {
	if(O_RDONLY);
#ifdef O_TRUNC
	exit(0);
#else
	exit(1);
#endif
}
EOCP
: check sys/file.h first to get FREAD on Sun
if $test `./findhdr sys/file.h` && \
        $cc $ccflags "-DI_SYS_FILE" -o open3 $ldflags open3.c $libs >/dev/null 2>&1 ; then
	h_sysfile=true;
	echo "<sys/file.h> defines the O_* constants..." >&4
	if ./open3; then
		echo "and you have the 3 argument form of open()." >&4
		val="$define"
	else
		echo "but not the 3 argument form of open().  Oh, well." >&4
		val="$undef"
	fi
elif $test `./findhdr fcntl.h` && \
        $cc $ccflags "-DI_FCNTL" -o open3 $ldflags open3.c $libs >/dev/null 2>&1 ; then
	h_fcntl=true;
	echo "<fcntl.h> defines the O_* constants..." >&4
	if ./open3; then
		echo "and you have the 3 argument form of open()." >&4
		val="$define"
	else
		echo "but not the 3 argument form of open().  Oh, well." >&4
		val="$undef"
	fi
else
	val="$undef"
	echo "I can't find the O_* constant definitions!  You got problems." >&4
fi
set d_open3
eval $setvar
$rm -f open3*

: check for non-blocking I/O stuff
case "$h_sysfile" in
true) echo "#include <sys/file.h>" > head.c;;
*)
	case "$h_fcntl" in
	true) echo "#include <fcntl.h>" > head.c;;
	*) echo "#include <sys/fcntl.h>" > head.c;;
	esac
	;;
esac
echo " "
echo "Figuring out the flag used by open() for non-blocking I/O..." >&4
case "$o_nonblock" in
'')
	$cat head.c > try.c
	$cat >>try.c <<'EOCP'
main() {
#ifdef O_NONBLOCK
	printf("O_NONBLOCK\n");
	exit(0);
#endif
#ifdef O_NDELAY
	printf("O_NDELAY\n");
	exit(0);
#endif
#ifdef FNDELAY
	printf("FNDELAY\n");
	exit(0);
#endif
	exit(0);
}
EOCP
	if $cc $ccflags $ldflags try.c -o try >/dev/null 2>&1; then
		o_nonblock=`./try`
		case "$o_nonblock" in
		'') echo "I can't figure it out, assuming O_NONBLOCK will do.";;
		*) echo "Seems like we can use $o_nonblock.";;
		esac
	else
		echo "(I can't compile the test program; pray O_NONBLOCK is right!)"
	fi
	;;
*) echo "Using $hint value $o_nonblock.";;
esac
$rm -f try try.* .out core

echo " "
echo "Let's see what value errno gets from read() on a $o_nonblock file..." >&4
case "$eagain" in
'')
	$cat head.c > try.c
	$cat >>try.c <<EOCP
#include <errno.h>
#include <sys/types.h>
#include <signal.h>
#define MY_O_NONBLOCK $o_nonblock
extern int errno;
$signal_t blech(x) int x; { exit(3); }
EOCP
	$cat >> try.c <<'EOCP'
main()
{
	int pd[2];
	int pu[2];
	char buf[1];
	char string[100];

	pipe(pd);	/* Down: child -> parent */
	pipe(pu);	/* Up: parent -> child */
	if (0 != fork()) {
		int ret;
		close(pd[1]);	/* Parent reads from pd[0] */
		close(pu[0]);	/* Parent writes (blocking) to pu[1] */
		if (-1 == fcntl(pd[0], F_SETFL, MY_O_NONBLOCK))
			exit(1);
		signal(SIGALRM, blech);
		alarm(5);
		if ((ret = read(pd[0], buf, 1)) > 0)	/* Nothing to read! */
			exit(2);
		sprintf(string, "%d\n", ret);
		write(2, string, strlen(string));
		alarm(0);
#ifdef EAGAIN
		if (errno == EAGAIN) {
			printf("EAGAIN\n");
			goto ok;
		}
#endif
#ifdef EWOULDBLOCK
		if (errno == EWOULDBLOCK)
			printf("EWOULDBLOCK\n");
#endif
	ok:
		write(pu[1], buf, 1);	/* Unblocks child, tell it to close our pipe */
		sleep(2);				/* Give it time to close our pipe */
		alarm(5);
		ret = read(pd[0], buf, 1);	/* Should read EOF */
		alarm(0);
		sprintf(string, "%d\n", ret);
		write(3, string, strlen(string));
		exit(0);
	}

	close(pd[0]);			/* We write to pd[1] */
	close(pu[1]);			/* We read from pu[0] */
	read(pu[0], buf, 1);	/* Wait for parent to signal us we may continue */
	close(pd[1]);			/* Pipe pd is now fully closed! */
	exit(0);				/* Bye bye, thank you for playing! */
}
EOCP
	if $cc $ccflags $ldflags try.c -o try >/dev/null 2>&1; then
		echo "$startsh" >mtry
		echo "./try >try.out 2>try.ret 3>try.err || exit 4" >>mtry
		chmod +x mtry
		./mtry >/dev/null 2>&1
		case $? in
		0) eagain=`$cat try.out`;;
		1) echo "Could not perform non-blocking setting!";;
		2) echo "I did a successful read() for something that was not there!";;
		3) echo "Hmm... non-blocking I/O does not seem to be working!";;
		*) echo "Something terribly wrong happened during testing.";;
		esac
		rd_nodata=`$cat try.ret`
		echo "A read() system call with no data present returns $rd_nodata."
		case "$rd_nodata" in
		0|-1) ;;
		*)
			echo "(That's peculiar, fixing that to be -1.)"
			rd_nodata=-1
			;;
		esac
		case "$eagain" in
		'')
			echo "Forcing errno EAGAIN on read() with no data available."
			eagain=EAGAIN
			;;
		*)
			echo "Your read() sets errno to $eagain when no data is available."
			;;
		esac
		status=`$cat try.err`
		case "$status" in
		0) echo "And it correctly returns 0 to signal EOF.";;
		-1) echo "But it also returns -1 to signal EOF, so be careful!";;
		*) echo "However, your read() returns '$status' on EOF??";;
		esac
		val="$define"
		if test "$status" = "$rd_nodata"; then
			echo "WARNING: you can't distinguish between EOF and no data!"
			val="$undef"
		fi
	else
		echo "I can't compile the test program--assuming errno EAGAIN will do."
		eagain=EAGAIN
	fi
	set d_eofnblk
	eval $setvar
	;;
*)
	echo "Using $hint value $eagain."
	echo "Your read() returns $rd_nodata when no data is present."
	case "$d_eofnblk" in
	"$define") echo "And you can see EOF because read() returns 0.";;
	"$undef") echo "But you can't see EOF status from read() returned value.";;
	*)
		echo "(Assuming you can't see EOF status from read anyway.)"
		d_eofnblk=$undef
		;;
	esac
	;;
esac
$rm -f try try.* .out core head.c mtry

: see if fchmod exists
set fchmod d_fchmod
eval $inlibc

: see if fchown exists
set fchown d_fchown
eval $inlibc

: see if this is an fcntl system
set fcntl d_fcntl
eval $inlibc

: see if fgetpos exists
set fgetpos d_fgetpos
eval $inlibc

: see if flock exists
set flock d_flock
eval $inlibc

: see if fork exists
set fork d_fork
eval $inlibc

: see if pathconf exists
set pathconf d_pathconf
eval $inlibc

: see if fpathconf exists
set fpathconf d_fpathconf
eval $inlibc

: see if fsetpos exists
set fsetpos d_fsetpos
eval $inlibc

: see if gethostent exists
set gethostent d_gethent
eval $inlibc

: see if getlogin exists
set getlogin d_getlogin
eval $inlibc

: see if getpgid exists
set getpgid d_getpgid
eval $inlibc

: see if getpgrp2 exists
set getpgrp2 d_getpgrp2
eval $inlibc

: see if getppid exists
set getppid d_getppid
eval $inlibc

: see if getpriority exists
set getpriority d_getprior
eval $inlibc

: see if gettimeofday or ftime exists
set gettimeofday d_gettimeod
eval $inlibc
case "$d_gettimeod" in
"$undef")
	set ftime d_ftime 
	eval $inlibc
	;;
*)
	val="$undef"; set d_ftime; eval $setvar
	;;
esac
case "$d_gettimeod$d_ftime" in
"$undef$undef")
	echo " "
	echo 'No ftime() nor gettimeofday() -- timing may be less accurate.' >&4
	;;
esac

: see if this is a netinet/in.h or sys/in.h system
set netinet/in.h i_niin sys/in.h i_sysin
eval $inhdr

: see if htonl --and friends-- exists
val=''
set htonl val
eval $inlibc

: Maybe they are macros.
case "$val" in
$undef)
	$cat >htonl.c <<EOM
#include <stdio.h>
#include <sys/types.h>
#$i_niin I_NETINET_IN
#$i_sysin I_SYS_IN
#ifdef I_NETINET_IN
#include <netinet/in.h>
#endif
#ifdef I_SYS_IN
#include <sys/in.h>
#endif
#ifdef htonl
printf("Defined as a macro.");
#endif
EOM
	$cppstdin $cppflags $cppminus < htonl.c >htonl.E 2>/dev/null
	if $contains 'Defined as a macro' htonl.E >/dev/null 2>&1; then
		val="$define"
		echo "But it seems to be defined as a macro." >&4
	fi
	$rm -f htonl.?
	;;
esac
set d_htonl
eval $setvar

: see which of string.h or strings.h is needed
echo " "
strings=`./findhdr string.h`
if $test "$strings" && $test -r "$strings"; then
	echo "Using <string.h> instead of <strings.h>." >&4
	val="$define"
else
	val="$undef"
	strings=`./findhdr strings.h`
	if $test "$strings" && $test -r "$strings"; then
		echo "Using <strings.h> instead of <string.h>." >&4
	else
		echo "No string header found -- You'll surely have problems." >&4
	fi
fi
set i_string
eval $setvar
case "$i_string" in
"$undef") strings=`./findhdr strings.h`;;
*)	  strings=`./findhdr string.h`;;
esac

: index or strchr
echo " "
if set index val -f; eval $csym; $val; then
	if set strchr val -f d_strchr; eval $csym; $val; then
		if $contains strchr "$strings" >/dev/null 2>&1 ; then
			val="$define"
			vali="$undef"
			echo "strchr() found." >&4
		else
			val="$undef"
			vali="$define"
			echo "index() found." >&4
		fi
	else
		val="$undef"
		vali="$define"
		echo "index() found." >&4
	fi
else
	if set strchr val -f d_strchr; eval $csym; $val; then
		val="$define"
		vali="$undef"
		echo "strchr() found." >&4
	else
		echo "No index() or strchr() found!" >&4
		val="$undef"
		vali="$undef"
	fi
fi
set d_strchr; eval $setvar
val="$vali"
set d_index; eval $setvar

: check whether inet_aton exists
set inet_aton d_inetaton
eval $inlibc

: Look for isascii
echo " "
$cat >isascii.c <<'EOCP'
#include <stdio.h>
#include <ctype.h>
main() {
	int c = 'A';
	if (isascii(c))
		exit(0);
	else
		exit(1);
}
EOCP
if $cc $ccflags $ldflags -o isascii isascii.c $libs >/dev/null 2>&1 ; then
	echo "isascii() found." >&4
	val="$define"
else
	echo "isascii() NOT found." >&4
	val="$undef"
fi
set d_isascii
eval $setvar
$rm -f isascii*

: see if killpg exists
set killpg d_killpg
eval $inlibc

: see if link exists
set link d_link
eval $inlibc

: see if localeconv exists
set localeconv d_locconv
eval $inlibc

: see if lockf exists
set lockf d_lockf
eval $inlibc

: see if lstat exists
set lstat d_lstat
eval $inlibc

: see if mblen exists
set mblen d_mblen
eval $inlibc

: see if mbstowcs exists
set mbstowcs d_mbstowcs
eval $inlibc

: see if mbtowc exists
set mbtowc d_mbtowc
eval $inlibc

: see if memcmp exists
set memcmp d_memcmp
eval $inlibc

: see if memcpy exists
set memcpy d_memcpy
eval $inlibc

: see if memmove exists
set memmove d_memmove
eval $inlibc

: see if memset exists
set memset d_memset
eval $inlibc

: see if mkdir exists
set mkdir d_mkdir
eval $inlibc

: see if mkfifo exists
set mkfifo d_mkfifo
eval $inlibc

: see if mktime exists
set mktime d_mktime
eval $inlibc

: see if msgctl exists
set msgctl d_msgctl
eval $inlibc

: see if msgget exists
set msgget d_msgget
eval $inlibc

: see if msgsnd exists
set msgsnd d_msgsnd
eval $inlibc

: see if msgrcv exists
set msgrcv d_msgrcv
eval $inlibc

: see how much of the 'msg*(2)' library is present.
h_msg=true
echo " "
case "$d_msgctl$d_msgget$d_msgsnd$d_msgrcv" in
*"$undef"*) h_msg=false;;
esac
: we could also check for sys/ipc.h ...
if $h_msg && $test `./findhdr sys/msg.h`; then
	echo "You have the full msg*(2) library." >&4
	val="$define"
else
	echo "You don't have the full msg*(2) library." >&4
	val="$undef"
fi
set d_msg
eval $setvar

: see if this is a malloc.h system
set malloc.h i_malloc
eval $inhdr

: see if stdlib is available
set stdlib.h i_stdlib
eval $inhdr

: determine which malloc to compile in
echo " "
case "$usemymalloc" in
''|y*|true)	dflt='y' ;;
n*|false)	dflt='n' ;;
*)	dflt="$usemymalloc" ;;
esac
rp="Do you wish to attempt to use the malloc that comes with $package?"
. ./myread
usemymalloc="$ans"
case "$ans" in
y*|true)
	usemymalloc='y'
	mallocsrc='malloc.c'
	mallocobj='malloc.o'
	d_mymalloc="$define"
	case "$libs" in
	*-lmalloc*)
		: Remove malloc from list of libraries to use
		echo "Removing unneeded -lmalloc from library list" >&4
		set `echo X $libs | $sed -e 's/-lmalloc / /' -e 's/-lmalloc$//'`
		shift
		libs="$*"
		echo "libs = $libs" >&4
		;;
	esac
	;;
*)
	usemymalloc='n'
	mallocsrc=''
	mallocobj=''
	d_mymalloc="$undef"
	;;
esac

: compute the return types of malloc and free
echo " "
$cat >malloc.c <<END
#$i_malloc I_MALLOC
#$i_stdlib I_STDLIB
#include <stdio.h>
#include <sys/types.h>
#ifdef I_MALLOC
#include <malloc.h>
#endif
#ifdef I_STDLIB
#include <stdlib.h>
#endif
#ifdef TRY_MALLOC
void *malloc();
#endif
#ifdef TRY_FREE
void free();
#endif
END
case "$malloctype" in
'')
	if $cc $ccflags -c -DTRY_MALLOC malloc.c >/dev/null 2>&1; then
		malloctype='void *'
	else
		malloctype='char *'
	fi
	;;
esac
echo "Your system wants malloc to return '$malloctype', it would seem." >&4

case "$freetype" in
'')
	if $cc $ccflags -c -DTRY_FREE malloc.c >/dev/null 2>&1; then
		freetype='void'
	else
		freetype='int'
	fi
	;;
esac
echo "Your system uses $freetype free(), it would seem." >&4
$rm -f malloc.[co]
: see if nice exists
set nice d_nice
eval $inlibc

: see if pause exists
set pause d_pause
eval $inlibc

: see if pipe exists
set pipe d_pipe
eval $inlibc

: see if poll exists
set poll d_poll
eval $inlibc

: see if this is a pwd.h system
set pwd.h i_pwd
eval $inhdr

case "$i_pwd" in
$define)
	xxx=`./findhdr pwd.h`
	$cppstdin $cppflags $cppminus < $xxx >$$.h

	if $contains 'pw_quota' $$.h >/dev/null 2>&1; then
		val="$define"
	else
		val="$undef"
	fi
	set d_pwquota
	eval $setvar

	if $contains 'pw_age' $$.h >/dev/null 2>&1; then
		val="$define"
	else
		val="$undef"
	fi
	set d_pwage
	eval $setvar

	if $contains 'pw_change' $$.h >/dev/null 2>&1; then
		val="$define"
	else
		val="$undef"
	fi
	set d_pwchange
	eval $setvar

	if $contains 'pw_class' $$.h >/dev/null 2>&1; then
		val="$define"
	else
		val="$undef"
	fi
	set d_pwclass
	eval $setvar

	if $contains 'pw_expire' $$.h >/dev/null 2>&1; then
		val="$define"
	else
		val="$undef"
	fi
	set d_pwexpire
	eval $setvar

	if $contains 'pw_comment' $$.h >/dev/null 2>&1; then
		val="$define"
	else
		val="$undef"
	fi
	set d_pwcomment
	eval $setvar

	$rm -f $$.h
	;;
*)
	val="$undef"; 
	set d_pwquota; eval $setvar
	set d_pwage; eval $setvar
	set d_pwchange; eval $setvar
	set d_pwclass; eval $setvar
	set d_pwexpire; eval $setvar
	set d_pwcomment; eval $setvar
	;;
esac

: see if readdir and friends exist
set readdir d_readdir
eval $inlibc
set seekdir d_seekdir
eval $inlibc
set telldir d_telldir
eval $inlibc
set rewinddir d_rewinddir
eval $inlibc

: see if readlink exists
set readlink d_readlink
eval $inlibc

: see if rename exists
set rename d_rename
eval $inlibc

: see if rmdir exists
set rmdir d_rmdir
eval $inlibc

: see if memory.h is available.
val=''
set memory.h val
eval $inhdr

: See if it conflicts with string.h
case "$val" in
$define)
	case "$strings" in
	'') ;;
	*)
		$cppstdin $cppflags $cppminus < $strings > mem.h
		if $contains 'memcpy' mem.h >/dev/null 2>&1; then
			echo " "
			echo "We won't be including <memory.h>."
			val="$undef"
		fi
		$rm -f mem.h
		;;
	esac
esac
set i_memory
eval $setvar

: can bcopy handle overlapping blocks?
val="$undef"
case "$d_bcopy" in
"$define")
	echo " "
	echo "Checking to see if your bcopy() can do overlapping copies..." >&4
	$cat >foo.c <<EOCP
#$i_memory I_MEMORY
#$i_stdlib I_STDLIB
#$i_string I_STRING
#$i_unistd I_UNISTD
EOCP
	$cat >>foo.c <<'EOCP'
#include <stdio.h>

#ifdef I_MEMORY
#  include <memory.h>
#endif
#ifdef I_STDLIB
#  include <stdlib.h>
#endif
#ifdef I_STRING
#  include <string.h>
#else
#  include <strings.h>
#endif
#ifdef I_UNISTD
#  include <unistd.h>  /* Needed for NetBSD */
#endif
main()
{
char buf[128], abc[128];
char *b;
int len;
int off;
int align;

/* Copy "abcde..." string to char abc[] so that gcc doesn't
   try to store the string in read-only memory.  */
bcopy("abcdefghijklmnopqrstuvwxyz0123456789", abc, 36);

for (align = 7; align >= 0; align--) {
	for (len = 36; len; len--) {
		b = buf+align;
		bcopy(abc, b, len);
		for (off = 1; off <= len; off++) {
			bcopy(b, b+off, len);
			bcopy(b+off, b, len);
			if (bcmp(b, abc, len))
				exit(1);
		}
	}
}
exit(0);
}
EOCP
	if $cc $optimize $ccflags $ldflags foo.c \
		    -o safebcpy $libs >/dev/null 2>&1; then
		if ./safebcpy 2>/dev/null; then
			echo "Yes, it can."
			val="$define"
		else
			echo "It can't, sorry."
			case "$d_memmove" in
			"$define") echo "But that's Ok since you have memmove()." ;;
			esac
		fi
	else
		echo "(I can't compile the test program, so we'll assume not...)"
		case "$d_memmove" in
		"$define") echo "But that's Ok since you have memmove()." ;;
		esac
	fi
	;;
esac
$rm -f foo.* safebcpy core
set d_safebcpy
eval $setvar

: can memcpy handle overlapping blocks?
val="$undef"
case "$d_memcpy" in
"$define")
	echo " "
	echo "Checking to see if your memcpy() can do overlapping copies..." >&4
	$cat >foo.c <<EOCP
#$i_memory I_MEMORY
#$i_stdlib I_STDLIB
#$i_string I_STRING
#$i_unistd I_UNISTD
EOCP
	$cat >>foo.c <<'EOCP'
#include <stdio.h>

#ifdef I_MEMORY
#  include <memory.h>
#endif
#ifdef I_STDLIB
#  include <stdlib.h>
#endif
#ifdef I_STRING
#  include <string.h>
#else
#  include <strings.h>
#endif
#ifdef I_UNISTD
#  include <unistd.h>  /* Needed for NetBSD */
#endif
main()
{
char buf[128], abc[128];
char *b;
int len;
int off;
int align;

/* Copy "abcde..." string to char abc[] so that gcc doesn't
   try to store the string in read-only memory. */
memcpy(abc, "abcdefghijklmnopqrstuvwxyz0123456789", 36);

for (align = 7; align >= 0; align--) {
	for (len = 36; len; len--) {
		b = buf+align;
		memcpy(b, abc, len);
		for (off = 1; off <= len; off++) {
			memcpy(b+off, b, len);
			memcpy(b, b+off, len);
			if (memcmp(b, abc, len))
				exit(1);
		}
	}
}
exit(0);
}
EOCP
	if $cc $optimize $ccflags $ldflags foo.c \
		    -o safemcpy $libs >/dev/null 2>&1; then
		if ./safemcpy 2>/dev/null; then
			echo "Yes, it can."
			val="$define"
		else
			echo "It can't, sorry."
			case "$d_memmove" in
			"$define") echo "But that's Ok since you have memmove()." ;;
			esac
		fi
	else
		echo "(I can't compile the test program, so we'll assume not...)"
		case "$d_memmove" in
		"$define") echo "But that's Ok since you have memmove()." ;;
		esac
	fi
	;;
esac
$rm -f foo.* safemcpy core
set d_safemcpy
eval $setvar

: can memcmp be trusted to compare relative magnitude?
val="$undef"
case "$d_memcmp" in
"$define")
	echo " "
	echo "Checking to see if your memcmp() can compare relative magnitude..." >&4
	$cat >foo.c <<EOCP
#$i_memory I_MEMORY
#$i_stdlib I_STDLIB
#$i_string I_STRING
#$i_unistd I_UNISTD
EOCP
	$cat >>foo.c <<'EOCP'
#include <stdio.h>

#ifdef I_MEMORY
#  include <memory.h>
#endif
#ifdef I_STDLIB
#  include <stdlib.h>
#endif
#ifdef I_STRING
#  include <string.h>
#else
#  include <strings.h>
#endif
#ifdef I_UNISTD
#  include <unistd.h>  /* Needed for NetBSD */
#endif
main()
{
char a = -1;
char b = 0;
if ((a < b) && memcmp(&a, &b, 1) < 0)
	exit(1);
exit(0);
}
EOCP
	if $cc $optimize $ccflags $ldflags foo.c \
		    -o sanemcmp $libs >/dev/null 2>&1; then
		if ./sanemcmp 2>/dev/null; then
			echo "Yes, it can."
			val="$define"
		else
			echo "No, it can't (it uses signed chars)."
		fi
	else
		echo "(I can't compile the test program, so we'll assume not...)"
	fi
	;;
esac
$rm -f foo.* sanemcmp core
set d_sanemcmp
eval $setvar

: see if select exists
set select d_select
eval $inlibc

: see if semctl exists
set semctl d_semctl
eval $inlibc

: see if semget exists
set semget d_semget
eval $inlibc

: see if semop exists
set semop d_semop
eval $inlibc

: see how much of the 'sem*(2)' library is present.
h_sem=true
echo " "
case "$d_semctl$d_semget$d_semop" in
*"$undef"*) h_sem=false;;
esac
: we could also check for sys/ipc.h ...
if $h_sem && $test `./findhdr sys/sem.h`; then
	echo "You have the full sem*(2) library." >&4
	val="$define"
else
	echo "You don't have the full sem*(2) library." >&4
	val="$undef"
fi
set d_sem
eval $setvar

: see if setegid exists
set setegid d_setegid
eval $inlibc

: see if seteuid exists
set seteuid d_seteuid
eval $inlibc

: see if setlinebuf exists
set setlinebuf d_setlinebuf
eval $inlibc

: see if setlocale exists
set setlocale d_setlocale
eval $inlibc

: see if setpgid exists
set setpgid d_setpgid
eval $inlibc

: see if setpgrp2 exists
set setpgrp2 d_setpgrp2
eval $inlibc

: see if setpriority exists
set setpriority d_setprior
eval $inlibc

: see if setregid exists
set setregid d_setregid
eval $inlibc
set setresgid d_setresgid
eval $inlibc

: see if setreuid exists
set setreuid d_setreuid
eval $inlibc
set setresuid d_setresuid
eval $inlibc

: see if setrgid exists
set setrgid d_setrgid
eval $inlibc

: see if setruid exists
set setruid d_setruid
eval $inlibc

: see if setsid exists
set setsid d_setsid
eval $inlibc

: see if sfio.h is available
set sfio.h i_sfio
eval $inhdr


: see if sfio library is available
case "$i_sfio" in
$define)
	val=''
	set sfreserve val
	eval $inlibc
	;;
*)
	val="$undef"
	;;
esac
: Ok, but do we want to use it.
case "$val" in
$define)
	case "$usesfio" in
	true|$define|[yY]*) dflt='y';;
	*) dflt='n';;
	esac
	echo "$package can use the sfio library, but it is experimental."
	rp="You seem to have sfio available, do you want to try using it?"
	. ./myread
	case "$ans" in
	y|Y) ;;
	*)	echo "Ok, avoiding sfio this time.  I'll use stdio instead."
		val="$undef"
		: Remove sfio from list of libraries to use
		set `echo X $libs | $sed -e 's/-lsfio / /' -e 's/-lsfio$//'`
		shift
		libs="$*"
		echo "libs = $libs" >&4
		;;
	esac
	;;
*)	case "$usesfio" in
	true|$define|[yY]*)
		echo "Sorry, cannot find sfio on this machine" >&4
		echo "Ignoring your setting of usesfio=$usesfio" >&4
		;;
	esac
	;;
esac
set d_sfio
eval $setvar
case "$d_sfio" in
$define) usesfio='true';;
*) usesfio='false';;
esac

: see if shmctl exists
set shmctl d_shmctl
eval $inlibc

: see if shmget exists
set shmget d_shmget
eval $inlibc

: see if shmat exists
set shmat d_shmat
eval $inlibc
: see what shmat returns
case "$d_shmat" in
"$define")
	$cat >shmat.c <<'END'
#include <sys/shm.h>
void *shmat();
END
	if $cc $ccflags -c shmat.c >/dev/null 2>&1; then
		shmattype='void *'
	else
		shmattype='char *'
	fi
	echo "and it returns ($shmattype)." >&4
	: see if a prototype for shmat is available
	xxx=`./findhdr sys/shm.h`
	$cppstdin $cppflags $cppminus < $xxx > shmat.c 2>/dev/null
	if $contains 'shmat.*(' shmat.c >/dev/null 2>&1; then
		val="$define"
	else
		val="$undef"
	fi
	$rm -f shmat.[co]
	;;
*)
	val="$undef"
	;;
esac
set d_shmatprototype
eval $setvar

: see if shmdt exists
set shmdt d_shmdt
eval $inlibc

: see how much of the 'shm*(2)' library is present.
h_shm=true
echo " "
case "$d_shmctl$d_shmget$d_shmat$d_shmdt" in
*"$undef"*) h_shm=false;;
esac
: we could also check for sys/ipc.h ...
if $h_shm && $test `./findhdr sys/shm.h`; then
	echo "You have the full shm*(2) library." >&4
	val="$define"
else
	echo "You don't have the full shm*(2) library." >&4
	val="$undef"
fi
set d_shm
eval $setvar

echo " "
: see if we have sigaction
if set sigaction val -f d_sigaction; eval $csym; $val; then
	echo 'sigaction() found.' >&4
	val="$define"
else
	echo 'sigaction NOT found.' >&4
	val="$undef"
fi

$cat > set.c <<'EOP'
/* Solaris 2.5_x86 with SunWorks Pro C 3.0.1 doesn't have a complete
   sigaction structure if compiled with cc -Xc.  This compile test
   will fail then.  <doughera@lafcol.lafayette.edu>
*/
#include <stdio.h>
#include <sys/types.h>
#include <signal.h>
main()
{
    struct sigaction act, oact;
}
EOP

if $cc $ccflags $ldflags -o set set.c $libs >/dev/null 2>&1; then
	:
else
	echo "But you don't seem to have a useable struct sigaction." >&4
	val="$undef"
fi
set d_sigaction; eval $setvar
$rm -f set set.o set.c

: see if sigsetjmp exists
echo " "
case "$d_sigsetjmp" in
'')
	$cat >set.c <<'EOP'
#include <setjmp.h>
sigjmp_buf env;
int set = 1;
main()
{
	if (sigsetjmp(env,1))
		exit(set);
	set = 0;
	siglongjmp(env, 1);
	exit(1);
}
EOP
	if $cc $ccflags $ldflags -o set set.c $libs > /dev/null 2>&1 ; then
		if ./set >/dev/null 2>&1; then
			echo "POSIX sigsetjmp found." >&4
			val="$define"
		else
			$cat >&4 <<EOM
Uh-Oh! You have POSIX sigsetjmp and siglongjmp, but they do not work properly!!
I'll ignore them.
EOM
			val="$undef"
		fi
	else
		echo "sigsetjmp not found." >&4
		val="$undef"
	fi
	;;
*) val="$d_sigsetjmp"
	case "$d_sigsetjmp" in
	$define) echo "POSIX sigsetjmp found." >&4;;
	$undef) echo "sigsetjmp not found." >&4;;
	esac
	;;
esac
set d_sigsetjmp
eval $setvar
$rm -f set.c set

socketlib=''
sockethdr=''
: see whether socket exists
echo " "
$echo $n "Hmm... $c" >&4
if set socket val -f d_socket; eval $csym; $val; then
	echo "Looks like you have Berkeley networking support." >&4
	d_socket="$define"
	if set setsockopt val -f; eval $csym; $val; then
		d_oldsock="$undef"
	else
		echo "...but it uses the old 4.1c interface, rather than 4.2" >&4
		d_oldsock="$define"
	fi
else
	if $contains socklib libc.list >/dev/null 2>&1; then
		echo "Looks like you have Berkeley networking support." >&4
		d_socket="$define"
		: we will have to assume that it supports the 4.2 BSD interface
		d_oldsock="$undef"
	else
		echo "You don't have Berkeley networking in libc$lib_ext..." >&4
		if test -f /usr/lib/libnet$lib_ext; then
			( (nm $nm_opt /usr/lib/libnet$lib_ext | eval $nm_extract) ||  \
			ar t /usr/lib/libnet$lib_ext) 2>/dev/null >> libc.list
			if $contains socket libc.list >/dev/null 2>&1; then
			echo "...but the Wollongong group seems to have hacked it in." >&4
				socketlib="-lnet"
				sockethdr="-I/usr/netinclude"
				d_socket="$define"
				if $contains setsockopt libc.list >/dev/null 2>&1; then
					d_oldsock="$undef"
				else
					echo "...using the old 4.1c interface, rather than 4.2" >&4
					d_oldsock="$define"
				fi
			else
				echo "or even in libnet$lib_ext, which is peculiar." >&4
				d_socket="$undef"
				d_oldsock="$undef"
			fi
		else
			echo "or anywhere else I see." >&4
			d_socket="$undef"
			d_oldsock="$undef"
		fi
	fi
fi

: see if socketpair exists
set socketpair d_sockpair
eval $inlibc

: see if stat knows about block sizes
echo " "
xxx=`./findhdr sys/stat.h`
if $contains 'st_blocks;' "$xxx" >/dev/null 2>&1 ; then
	if $contains 'st_blksize;' "$xxx" >/dev/null 2>&1 ; then
		echo "Your stat() knows about block sizes." >&4
		val="$define"
	else
		echo "Your stat() doesn't know about block sizes." >&4
		val="$undef"
	fi
else
	echo "Your stat() doesn't know about block sizes." >&4
	val="$undef"
fi
set d_statblks
eval $setvar

: see if _ptr and _cnt from stdio act std
echo " "
if $contains '_IO_fpos_t' `./findhdr stdio.h` >/dev/null 2>&1 ; then
	echo "(Looks like you have stdio.h from Linux.)"
	case "$stdio_ptr" in
	'') stdio_ptr='((fp)->_IO_read_ptr)'
		ptr_lval=$define
		;;
	*)	ptr_lval=$d_stdio_ptr_lval;;
	esac
	case "$stdio_cnt" in
	'') stdio_cnt='((fp)->_IO_read_end - (fp)->_IO_read_ptr)'
		cnt_lval=$undef
		;;
	*)	cnt_lval=$d_stdio_cnt_lval;;
	esac
	case "$stdio_base" in
	'') stdio_base='((fp)->_IO_read_base)';;
	esac
	case "$stdio_bufsiz" in
	'') stdio_bufsiz='((fp)->_IO_read_end - (fp)->_IO_read_base)';;
	esac
else
	case "$stdio_ptr" in
	'') stdio_ptr='((fp)->_ptr)'
		ptr_lval=$define
		;;
	*)	ptr_lval=$d_stdio_ptr_lval;;
	esac
	case "$stdio_cnt" in
	'') stdio_cnt='((fp)->_cnt)'
		cnt_lval=$define
		;;
	*)	cnt_lval=$d_stdio_cnt_lval;;
	esac
	case "$stdio_base" in
	'') stdio_base='((fp)->_base)';;
	esac
	case "$stdio_bufsiz" in
	'') stdio_bufsiz='((fp)->_cnt + (fp)->_ptr - (fp)->_base)';;
	esac
fi
: test whether _ptr and _cnt really work
echo "Checking how std your stdio is..." >&4
$cat >try.c <<EOP
#include <stdio.h>
#define FILE_ptr(fp)	$stdio_ptr
#define FILE_cnt(fp)	$stdio_cnt
main() {
	FILE *fp = fopen("try.c", "r");
	char c = getc(fp);
	if (
		18 <= FILE_cnt(fp) &&
		strncmp(FILE_ptr(fp), "include <stdio.h>\n", 18) == 0
	)
		exit(0);
	exit(1);
}
EOP
val="$undef"
if $cc $ccflags $ldflags -o try try.c $libs >/dev/null 2>&1; then
	if ./try; then
		echo "Your stdio acts pretty std."
		val="$define"
	else
		echo "Your stdio isn't very std."
	fi
else
	echo "Your stdio doesn't appear very std."
fi
$rm -f try.c try
set d_stdstdio
eval $setvar

: Can _ptr be used as an lvalue?
case "$d_stdstdio$ptr_lval" in
$define$define) val=$define ;;
*) val=$undef ;;
esac
set d_stdio_ptr_lval
eval $setvar

: Can _cnt be used as an lvalue?
case "$d_stdstdio$cnt_lval" in
$define$define) val=$define ;;
*) val=$undef ;;
esac
set d_stdio_cnt_lval
eval $setvar


: see if _base is also standard
val="$undef"
case "$d_stdstdio" in
$define)
	$cat >try.c <<EOP
#include <stdio.h>
#define FILE_base(fp)	$stdio_base
#define FILE_bufsiz(fp)	$stdio_bufsiz
main() {
	FILE *fp = fopen("try.c", "r");
	char c = getc(fp);
	if (
		19 <= FILE_bufsiz(fp) &&
		strncmp(FILE_base(fp), "#include <stdio.h>\n", 19) == 0
	)
		exit(0);
	exit(1);
}
EOP
	if $cc $ccflags $ldflags -o try try.c $libs > /dev/null 2>&1; then
		if ./try; then
			echo "And its _base field acts std."
			val="$define"
		else
			echo "But its _base field isn't std."
		fi
	else
		echo "However, it seems to be lacking the _base field."
	fi
	$rm -f try.c try
	;;
esac
set d_stdiobase
eval $setvar

: see if strcoll exists
set strcoll d_strcoll
eval $inlibc

: check for structure copying
echo " "
echo "Checking to see if your C compiler can copy structs..." >&4
$cat >try.c <<'EOCP'
main()
{
	struct blurfl {
		int dyick;
	} foo, bar;

	foo = bar;
}
EOCP
if $cc -c try.c >/dev/null 2>&1 ; then
	val="$define"
	echo "Yup, it can."
else
	val="$undef"
	echo "Nope, it can't."
fi
set d_strctcpy
eval $setvar
$rm -f try.*

: see if strerror and/or sys_errlist[] exist
echo " "
if set strerror val -f d_strerror; eval $csym; $val; then
	echo 'strerror() found.' >&4
	d_strerror="$define"
	d_strerrm='strerror(e)'
	if set sys_errlist val -a d_syserrlst; eval $csym; $val; then	
		echo "(You also have sys_errlist[], so we could roll our own strerror.)" 
		d_syserrlst="$define"
	else
	echo "(Since you don't have sys_errlist[], sterror() is welcome.)"
		d_syserrlst="$undef"
	fi
elif xxx=`./findhdr string.h`; test "$xxx" || xxx=`./findhdr strings.h`; \
	$contains '#[ 	]*define.*strerror' "$xxx" >/dev/null 2>&1; then
	echo 'strerror() found in string header.' >&4
	d_strerror="$define"
	d_strerrm='strerror(e)'
	if set sys_errlist val -a d_syserrlst; eval $csym; $val; then	
		echo "(Most probably, strerror() uses sys_errlist[] for descriptions.)"
		d_syserrlst="$define"
	else
		echo "(You don't appear to have any sys_errlist[], how can this be?)"
		d_syserrlst="$undef"
	fi
elif set sys_errlist val -a d_syserrlst; eval $csym; $val; then
echo "strerror() not found, but you have sys_errlist[] so we'll use that." >&4
	d_strerror="$undef"
	d_syserrlst="$define"
	d_strerrm='((e)<0||(e)>=sys_nerr?"unknown":sys_errlist[e])'
else
	echo 'strerror() and sys_errlist[] NOT found.' >&4
	d_strerror="$undef"
	d_syserrlst="$undef"
	d_strerrm='"unknown"'
fi

: see if strtod exists
set strtod d_strtod
eval $inlibc

: see if strtol exists
set strtol d_strtol
eval $inlibc

: see if strtoul exists
set strtoul d_strtoul
eval $inlibc

: see if strxfrm exists
set strxfrm d_strxfrm
eval $inlibc

: see if symlink exists
set symlink d_symlink
eval $inlibc

: see if syscall exists
set syscall d_syscall
eval $inlibc

: see if sysconf exists
set sysconf d_sysconf
eval $inlibc

: see if system exists
set system d_system
eval $inlibc

: see if tcgetpgrp exists
set tcgetpgrp d_tcgetpgrp
eval $inlibc

: see if tcsetpgrp exists
set tcsetpgrp d_tcsetpgrp
eval $inlibc

: define an is-a-typedef? function
typedef='type=$1; var=$2; def=$3; shift; shift; shift; inclist=$@;
case "$inclist" in
"") inclist="sys/types.h";;
esac;
eval "varval=\$$var";
case "$varval" in
"")
	$rm -f temp.c;
	for inc in $inclist; do
		echo "#include <$inc>" >>temp.c;
	done;
	$cppstdin $cppflags $cppminus < temp.c >temp.E 2>/dev/null;
	if $contains $type temp.E >/dev/null 2>&1; then
		eval "$var=\$type";
	else
		eval "$var=\$def";
	fi;
	$rm -f temp.?;;
*) eval "$var=\$varval";;
esac'

: see if this is a sys/times.h system
set sys/times.h i_systimes
eval $inhdr

: see if times exists
echo " "
if set times val -f d_times; eval $csym; $val; then
	echo 'times() found.' >&4
	d_times="$define"
	inc=''
	case "$i_systimes" in
	"$define") inc='sys/times.h';;
	esac
	set clock_t clocktype long stdio.h sys/types.h $inc
	eval $typedef
	dflt="$clocktype"
	echo " "
	rp="What type is returned by times() on this system?"
	. ./myread
	clocktype="$ans"
else
	echo 'times() NOT found, hope that will do.' >&4
	d_times="$undef"
	clocktype='int'
fi

: see if truncate exists
set truncate d_truncate
eval $inlibc

: see if tzname[] exists
echo " "
if set tzname val -a d_tzname; eval $csym; $val; then
	val="$define"
	echo 'tzname[] found.' >&4
else
	val="$undef"
	echo 'tzname[] NOT found.' >&4
fi
set d_tzname
eval $setvar

: see if umask exists
set umask d_umask
eval $inlibc

: see how we will look up host name
echo " "
if false; then
	: dummy stub to allow use of elif
elif set uname val -f d_uname; eval $csym; $val; then
	if ./xenix; then
		$cat <<'EOM'
uname() was found, but you're running xenix, and older versions of xenix
have a broken uname(). If you don't really know whether your xenix is old
enough to have a broken system call, use the default answer.

EOM
		dflt=y
		case "$d_uname" in
		"$define") dflt=n;;
		esac
		rp='Is your uname() broken?'
		. ./myread
		case "$ans" in
		n*) d_uname="$define"; call=uname;;
		esac
	else
		echo 'uname() found.' >&4
		d_uname="$define"
		call=uname
	fi
fi
case "$d_gethname" in
'') d_gethname="$undef";;
esac
case "$d_uname" in
'') d_uname="$undef";;
esac
case "$d_phostname" in
'') d_phostname="$undef";;
esac

: backward compatibility for d_hvfork
if test X$d_hvfork != X; then
	d_vfork="$d_hvfork"
	d_hvfork=''
fi
: see if there is a vfork
val=''
set vfork val
eval $inlibc

: Ok, but do we want to use it. vfork is reportedly unreliable in 
: perl on Solaris 2.x, and probably elsewhere.
case "$val" in
$define)
	echo " "
	case "$usevfork" in
	false) dflt='n';;
	*) dflt='y';;
	esac
	rp="Some systems have problems with vfork().  Do you want to use it?"
	. ./myread
	case "$ans" in
	y|Y) ;;
	*)
		echo "Ok, we won't use vfork()."
		val="$undef"
		;;
	esac
	;;
esac
set d_vfork
eval $setvar
case "$d_vfork" in
$define) usevfork='true';;
*) usevfork='false';;
esac

: see if this is an sysdir system
set sys/dir.h i_sysdir
eval $inhdr

: see if this is an sysndir system
set sys/ndir.h i_sysndir
eval $inhdr

: see if closedir exists
set closedir d_closedir
eval $inlibc

case "$d_closedir" in
"$define")
	echo " "
	echo "Checking whether closedir() returns a status..." >&4
	cat > closedir.c <<EOM
#$i_dirent I_DIRENT		/**/
#$i_sysdir I_SYS_DIR		/**/
#$i_sysndir I_SYS_NDIR		/**/

#if defined(I_DIRENT)
#include <dirent.h>
#if defined(NeXT) && defined(I_SYS_DIR) /* NeXT needs dirent + sys/dir.h */
#include <sys/dir.h>
#endif
#else
#ifdef I_SYS_NDIR
#include <sys/ndir.h>
#else
#ifdef I_SYS_DIR
#ifdef hp9000s500
#include <ndir.h>	/* may be wrong in the future */
#else
#include <sys/dir.h>
#endif
#endif
#endif
#endif 
int main() { return closedir(opendir(".")); }
EOM
	if $cc $ccflags $ldflags -o closedir closedir.c $libs > /dev/null 2>&1; then
		if ./closedir > /dev/null 2>&1 ; then
			echo "Yes, it does."
			val="$undef"
		else
			echo "No, it doesn't."
			val="$define"
		fi
	else
		echo "(I can't seem to compile the test program--assuming it doesn't)"
		val="$define"
	fi
	;;
*)
	val="$undef";
	;;
esac
set d_void_closedir
eval $setvar
$rm -f closedir*
: check for volatile keyword
echo " "
echo 'Checking to see if your C compiler knows about "volatile"...' >&4
$cat >try.c <<'EOCP'
main()
{
	typedef struct _goo_struct goo_struct;
	goo_struct * volatile goo = ((goo_struct *)0);
	struct _goo_struct {
		long long_int;
		int reg_int;
		char char_var;
	};
	typedef unsigned short foo_t;
	char *volatile foo;
	volatile int bar;
	volatile foo_t blech;
	foo = foo;
}
EOCP
if $cc -c $ccflags try.c >/dev/null 2>&1 ; then
	val="$define"
	echo "Yup, it does."
else
	val="$undef"
	echo "Nope, it doesn't."
fi
set d_volatile
eval $setvar
$rm -f try.*

: see if there is a wait4
set wait4 d_wait4
eval $inlibc

: see if waitpid exists
set waitpid d_waitpid
eval $inlibc

: see if wcstombs exists
set wcstombs d_wcstombs
eval $inlibc

: see if wctomb exists
set wctomb d_wctomb
eval $inlibc

: preserve RCS keywords in files with variable substitution, grrr
Date='$Date'
Id='$Id'
Log='$Log'
RCSfile='$RCSfile'
Revision='$Revision'

: check for alignment requirements
echo " "
case "$alignbytes" in
'') echo "Checking alignment constraints..." >&4
	$cat >try.c <<'EOCP'
struct foobar {
	char foo;
	double bar;
} try;
main()
{
	printf("%d\n", (char *)&try.bar - (char *)&try.foo);
}
EOCP
	if $cc $ccflags try.c -o try >/dev/null 2>&1; then
		dflt=`./try`
	else
		dflt='8'
		echo "(I can't seem to compile the test program...)"
	fi
	;;
*) dflt="$alignbytes"
	;;
esac
rp="Doubles must be aligned on a how-many-byte boundary?"
. ./myread
alignbytes="$ans"
$rm -f try.c try

: check for ordering of bytes in a long
case "$byteorder" in
'')
	$cat <<'EOM'
  
In the following, larger digits indicate more significance.  A big-endian
machine like a Pyramid or a Motorola 680?0 chip will come out to 4321. A
little-endian machine like a Vax or an Intel 80?86 chip would be 1234. Other
machines may have weird orders like 3412.  A Cray will report 87654321. If
the test program works the default is probably right.
I'm now running the test program...
EOM
	$cat >try.c <<'EOCP'
#include <stdio.h>
main()
{
	int i;
	union {
		unsigned long l;
		char c[sizeof(long)];
	} u;

	if (sizeof(long) > 4)
		u.l = (0x08070605L << 32) | 0x04030201L;
	else
		u.l = 0x04030201L;
	for (i = 0; i < sizeof(long); i++)
		printf("%c", u.c[i]+'0');
	printf("\n");
	exit(0);
}
EOCP
	xxx_prompt=y
	if $cc $ccflags try.c -o try >/dev/null 2>&1 && ./try > /dev/null; then
		dflt=`./try`
		case "$dflt" in
		[1-4][1-4][1-4][1-4]|12345678|87654321)
			echo "(The test program ran ok.)"
			echo "byteorder=$dflt"
			xxx_prompt=n
			;;
		????|????????) echo "(The test program ran ok.)" ;;
		*) echo "(The test program didn't run right for some reason.)" ;;
		esac
	else
		dflt='4321'
		cat <<'EOM'
(I can't seem to compile the test program.  Guessing big-endian...)
EOM
	fi
	case "$xxx_prompt" in
	y)
		rp="What is the order of bytes in a long?"
		. ./myread
		byteorder="$ans"
		;;
	*)	byteorder=$dflt
		;;
	esac
	;;
esac
$rm -f try.c try

: how do we catenate cpp tokens here?
echo " "
echo "Checking to see how your cpp does stuff like catenate tokens..." >&4
$cat >cpp_stuff.c <<'EOCP'
#define RCAT(a,b)a/**/b
#define ACAT(a,b)a ## b
RCAT(Rei,ser)
ACAT(Cir,cus)
EOCP
$cppstdin $cppflags $cppminus <cpp_stuff.c >cpp_stuff.out 2>&1
if $contains 'Circus' cpp_stuff.out >/dev/null 2>&1; then
	echo "Oh!  Smells like ANSI's been here."
	echo "We can catify or stringify, separately or together!"
	cpp_stuff=42
elif $contains 'Reiser' cpp_stuff.out >/dev/null 2>&1; then
	echo "Ah, yes!  The good old days!"
	echo "However, in the good old days we don't know how to stringify and"
	echo "catify at the same time."
	cpp_stuff=1
else
	$cat >&4 <<EOM
Hmm, I don't seem to be able to catenate tokens with your cpp.  You're going
to have to edit the values of CAT[2-5] in config.h...
EOM
	cpp_stuff="/* Help! How do we handle cpp_stuff? */*/"
fi
$rm -f cpp_stuff.*

: see if this is a db.h system
set db.h i_db
eval $inhdr

case "$i_db" in
$define)
	: Check db version.  We can not use version 2.
	echo " "
	echo "Checking Berkeley DB version ..." >&4
	$cat >try.c <<EOCP
#$d_const HASCONST
#ifndef HASCONST
#define const
#endif
#include <sys/types.h>
#include <stdio.h>
#include <db.h>
main()
{
#ifdef DB_VERSION_MAJOR	/* DB version >= 2: not yet. */
    printf("You have Berkeley DB Version %d.%d\n",
		DB_VERSION_MAJOR, DB_VERSION_MINOR);
    printf("Perl currently only supports up to version 1.86.\n");
    exit(2);
#else
#if defined(_DB_H_) && defined(BTREEMAGIC) && defined(HASHMAGIC)
    exit(0);	/* DB version < 2: the coast is clear. */
#else
    exit(1);	/* <db.h> not Berkeley DB? */
#endif
#endif
}
EOCP
	if $cc $optimize $ccflags $ldflags -o try try.c $libs && ./try; then
		echo 'Looks OK.  (Perl supports up to version 1.86).' >&4
	else
		echo "I can't use Berkeley DB with your <db.h>.  I'll disable Berkeley DB." >&4
		i_db=$undef
		case " $libs " in
		*"-ldb "*)
			: Remove db from list of libraries to use
			echo "Removing unusable -ldb from library list" >&4
			set `echo X $libs | $sed -e 's/-ldb / /' -e 's/-ldb$//'`
			shift
			libs="$*"
			echo "libs = $libs" >&4
			;;
		esac
	fi
	$rm -f try.*
	;;
esac

case "$i_db" in
define)
	: Check the return type needed for hash 
	echo " "
	echo "Checking return type needed for hash for Berkeley DB ..." >&4
	$cat >try.c <<EOCP
#$d_const HASCONST
#ifndef HASCONST
#define const
#endif
#include <sys/types.h>
#include <db.h>
u_int32_t hash_cb (ptr, size)
const void *ptr;
size_t size;
{
}
HASHINFO info;
main()
{
	info.hash = hash_cb;
}
EOCP
	if $cc $ccflags -c try.c >try.out 2>&1 ; then
		if $contains warning try.out >>/dev/null 2>&1 ; then
			db_hashtype='int'
		else
			db_hashtype='u_int32_t'
		fi
	else
		: XXX Maybe we should just give up here.
		db_hashtype=u_int32_t
		echo "Help:  I can't seem to compile the db test program." >&4
		echo "Something's wrong, but I'll assume you use $db_hashtype." >&4
	fi
	$rm -f try.*
	echo "Your version of Berkeley DB uses $db_hashtype for hash."
	;;
*)	db_hashtype=u_int32_t
	;;
esac

case "$i_db" in
define)
	: Check the return type needed for prefix 
	echo " "
	echo "Checking return type needed for prefix for Berkeley DB ..." >&4
	cat >try.c <<EOCP
#$d_const HASCONST
#ifndef HASCONST
#define const
#endif
#include <sys/types.h>
#include <db.h>
size_t prefix_cb (key1, key2)
const DBT *key1;
const DBT *key2;
{
}
BTREEINFO info;
main()
{
	info.prefix = prefix_cb;
}
EOCP
	if $cc $ccflags -c try.c  >try.out 2>&1 ; then
		if $contains warning try.out >>/dev/null 2>&1 ; then
			db_prefixtype='int'
		else
			db_prefixtype='size_t'
		fi
	else
		db_prefixtype='size_t'
		: XXX Maybe we should just give up here.
		echo "Help:  I can't seem to compile the db test program." >&4
		echo "Something's wrong, but I'll assume you use $db_prefixtype." >&4
	fi
	$rm -f try.*
	echo "Your version of Berkeley DB uses $db_prefixtype for prefix."
	;;
*)	db_prefixtype='size_t'
	;;
esac

: check for void type
echo " "
echo "Checking to see how well your C compiler groks the void type..." >&4
echo " "
$cat >&4 <<EOM
  Support flag bits are:
    1: basic void declarations.
    2: arrays of pointers to functions returning void.
    4: operations between pointers to and addresses of void functions.
    8: generic void pointers.
EOM
echo " "
case "$voidflags" in
'')
	$cat >try.c <<'EOCP'
#if TRY & 1
void sub() {
#else
sub() {
#endif
	extern void moo();	/* function returning void */
	void (*goo)();		/* ptr to func returning void */
#if TRY & 8
	void *hue;		/* generic ptr */
#endif
#if TRY & 2
	void (*foo[10])();
#endif

#if TRY & 4
	if(goo == moo) {
		exit(0);
	}
#endif
	exit(0);
}
main() { sub(); }
EOCP
	if $cc $ccflags -c -DTRY=$defvoidused try.c >.out 2>&1 ; then
		voidflags=$defvoidused
	echo "It appears to support void to the level $package wants ($defvoidused)."
		if $contains warning .out >/dev/null 2>&1; then
			echo "However, you might get some warnings that look like this:"
			$cat .out
		fi
	else
echo "Hmm, your compiler has some difficulty with void. Checking further..." >&4
		if $cc $ccflags -c -DTRY=1 try.c >/dev/null 2>&1; then
			echo "It supports 1..."
			if $cc $ccflags -c -DTRY=3 try.c >/dev/null 2>&1; then
				echo "It also supports 2..."
				if $cc $ccflags -c -DTRY=7 try.c >/dev/null 2>&1; then
					voidflags=7
					echo "And it supports 4 but not 8 definitely."
				else
					echo "It doesn't support 4..."
					if $cc $ccflags -c -DTRY=11 try.c >/dev/null 2>&1; then
						voidflags=11
						echo "But it supports 8."
					else
						voidflags=3
						echo "Neither does it support 8."
					fi
				fi
			else
				echo "It does not support 2..."
				if $cc $ccflags -c -DTRY=13 try.c >/dev/null 2>&1; then
					voidflags=13
					echo "But it supports 4 and 8."
				else
					if $cc $ccflags -c -DTRY=5 try.c >/dev/null 2>&1; then
						voidflags=5
						echo "And it supports 4 but has not heard about 8."
					else
						echo "However it supports 8 but not 4."
					fi
				fi
			fi
		else
			echo "There is no support at all for void."
			voidflags=0
		fi
	fi
esac
: Only prompt user if support does not match the level we want
case "$voidflags" in
"$defvoidused") ;;
*)
	dflt="$voidflags";
	rp="Your void support flags add up to what?"
	. ./myread
	voidflags="$ans"
	;;
esac
$rm -f try.* .out

: see what type file positions are declared as in the library
set fpos_t fpostype long stdio.h sys/types.h
eval $typedef
echo " "
dflt="$fpostype"
rp="What is the type for file position used by fsetpos()?"
. ./myread
fpostype="$ans"

: Store the full pathname to the sed program for use in the C program
full_sed=$sed

: see what type gids are declared as in the kernel
set gid_t gidtype xxx stdio.h sys/types.h
eval $typedef
case "$gidtype" in
xxx)
	xxx=`./findhdr sys/user.h`
	set `grep 'groups\[NGROUPS\];' "$xxx" 2>/dev/null` unsigned short
	case $1 in
	unsigned) dflt="$1 $2" ;;
	*) dflt="$1" ;;
	esac
	;;
*) dflt="$gidtype";;
esac
echo " "
rp="What is the type for group ids returned by getgid()?"
. ./myread
gidtype="$ans"

: see if getgroups exists
set getgroups d_getgrps
eval $inlibc

: see if setgroups exists
set setgroups d_setgrps
eval $inlibc

: Find type of 2nd arg to 'getgroups()' and 'setgroups()'
echo " "
case "$d_getgrps$d_setgrps" in
*define*)
	case "$groupstype" in
	'') dflt="$gidtype" ;;
	*)  dflt="$groupstype" ;;
	esac
	$cat <<EOM
What is the type of the second argument to getgroups() and setgroups()?
Usually this is the same as group ids, $gidtype, but not always.

EOM
	rp='What type is the second argument to getgroups() and setgroups()?'
	. ./myread
	groupstype="$ans"
	;;
*)  groupstype="$gidtype";;
esac

: see what type lseek is declared as in the kernel
set off_t lseektype long stdio.h sys/types.h
eval $typedef
echo " "
dflt="$lseektype"
rp="What type is lseek's offset on this system declared as?"
. ./myread
lseektype="$ans"

echo " "
case "$make" in
'')
	make=`./loc make make $pth`
	case "$make" in
	/*)	echo make is in $make.  ;;
	?:[\\/]*)	echo make is in $make.  ;;
	*)	echo "I don't know where 'make' is, and my life depends on it." >&4
		echo "Go find a make program or fix your PATH setting!" >&4
		exit 1
		;;
	esac
	;;
*)	echo make is in $make. ;;
esac

$echo $n "Checking if your $make program sets \$(MAKE)... $c" >&4
case "$make_set_make" in
'')
	$sed 's/^X //' > testmake.mak << 'EOF'
Xall:
X 	@echo 'ac_maketemp="$(MAKE)"'
EOF
	: GNU make sometimes prints "make[1]: Entering...", which would confuse us.
	case "`$make -f testmake.mak 2>/dev/null`" in
	*ac_maketemp=*) make_set_make='#' ;;
	*)	make_set_make="MAKE=$make" ;;
	esac
	$rm -f testmake.mak
	;;
esac
case "$make_set_make" in
'#')	echo "Yup, it does." >&4 ;;
*)	echo "Nope, it doesn't." >&4 ;;
esac

: see what type is used for mode_t
set mode_t modetype int stdio.h sys/types.h
eval $typedef
dflt="$modetype"
echo " "
rp="What type is used for file modes?"
. ./myread
modetype="$ans"

: locate the preferred pager for this system
case "$pager" in
'')
	dflt=''
	case "$pg" in
	/*) dflt=$pg;;
	esac
	case "$more" in
	/*) dflt=$more;;
	esac
	case "$less" in
	/*) dflt=$less;;
	esac
	case "$dflt" in
	'') dflt=/usr/ucb/more;;
	esac
	;;
*) dflt="$pager";;
esac
echo " "
fn=f/
rp='What pager is used on your system?'
. ./getfile
pager="$ans"

: Cruising for prototypes
echo " "
echo "Checking out function prototypes..." >&4
$cat >prototype.c <<'EOCP'
main(int argc, char *argv[]) {
	exit(0);}
EOCP
if $cc $ccflags -c prototype.c >prototype.out 2>&1 ; then
	echo "Your C compiler appears to support function prototypes."
	val="$define"
else
	echo "Your C compiler doesn't seem to understand function prototypes."
	val="$undef"
fi
set prototype
eval $setvar
$rm -f prototype*

: check for size of random number generator
echo " "
case "$randbits" in
'')
	echo "Checking to see how many bits your rand function produces..." >&4
	$cat >try.c <<EOCP
#$i_unistd I_UNISTD
#$i_stdlib I_STDLIB
#include <stdio.h>
#ifdef I_UNISTD
#  include <unistd.h>
#endif
#ifdef I_STDLIB
#  include <stdlib.h>
#endif
EOCP
	$cat >>try.c <<'EOCP'
main()
{
	register int i;
	register unsigned long tmp;
	register unsigned long max = 0L;

	for (i = 1000; i; i--) {
		tmp = (unsigned long)rand();
		if (tmp > max) max = tmp;
	}
	for (i = 0; max; i++)
		max /= 2;
	printf("%d\n",i);
	fflush(stdout);
}
EOCP
	if $cc $ccflags $ldflags -o try try.c $libs >/dev/null 2>&1 ; then
		dflt=`try`
	else
		dflt='?'
		echo "(I can't seem to compile the test program...)"
	fi
	;;
*)
	dflt="$randbits"
	;;
esac
rp='How many bits does your rand() function produce?'
. ./myread
randbits="$ans"
$rm -f try.c try.o try

: see if ar generates random libraries by itself
echo " "
echo "Checking how to generate random libraries on your machine..." >&4
echo 'int bar1() { return bar2(); }' > bar1.c
echo 'int bar2() { return 2; }' > bar2.c
$cat > foo.c <<'EOP'
main() { printf("%d\n", bar1()); exit(0); }
EOP
$cc $ccflags -c bar1.c >/dev/null 2>&1
$cc $ccflags -c bar2.c >/dev/null 2>&1
$cc $ccflags -c foo.c >/dev/null 2>&1
ar rc bar$lib_ext bar2.o bar1.o >/dev/null 2>&1
if $cc $ccflags $ldflags -o foobar foo.o bar$lib_ext $libs > /dev/null 2>&1 &&
	./foobar >/dev/null 2>&1; then
	echo "ar appears to generate random libraries itself."
	orderlib=false
	ranlib=":"
elif ar ts bar$lib_ext >/dev/null 2>&1 &&
	$cc $ccflags $ldflags -o foobar foo.o bar$lib_ext $libs > /dev/null 2>&1 &&
	./foobar >/dev/null 2>&1; then
		echo "a table of contents needs to be added with 'ar ts'."
		orderlib=false
		ranlib="ar ts"
else
	case "$ranlib" in
	:) ranlib='';;
	'')
		ranlib=`./loc ranlib X /usr/bin /bin /usr/local/bin`
		$test -f $ranlib || ranlib=''
		;;
	esac
	if $test -n "$ranlib"; then
		echo "your system has '$ranlib'; we'll use that."
		orderlib=false
	else
		echo "your system doesn't seem to support random libraries"
		echo "so we'll use lorder and tsort to order the libraries."
		orderlib=true
		ranlib=":"
	fi
fi
$rm -f foo* bar* 

: see if sys/select.h has to be included
set sys/select.h i_sysselct
eval $inhdr

: see if we should include time.h, sys/time.h, or both
echo " "
echo "Testing to see if we should include <time.h>, <sys/time.h> or both." >&4
$echo $n "I'm now running the test program...$c"
$cat >try.c <<'EOCP'
#include <sys/types.h>
#ifdef I_TIME
#include <time.h>
#endif
#ifdef I_SYSTIME
#ifdef SYSTIMEKERNEL
#define KERNEL
#endif
#include <sys/time.h>
#endif
#ifdef I_SYSSELECT
#include <sys/select.h>
#endif
main()
{
	struct tm foo;
#ifdef S_TIMEVAL
	struct timeval bar;
#endif
#ifdef S_TIMEZONE
	struct timezone tzp;
#endif
	if (foo.tm_sec == foo.tm_sec)
		exit(0);
#ifdef S_TIMEVAL
	if (bar.tv_sec == bar.tv_sec)
		exit(0);
#endif
	exit(1);
}
EOCP
flags=''
for s_timezone in '-DS_TIMEZONE' ''; do
sysselect=''
for s_timeval in '-DS_TIMEVAL' ''; do
for i_systimek in '' '-DSYSTIMEKERNEL'; do
for i_time in '' '-DI_TIME'; do
for i_systime in '-DI_SYSTIME' ''; do
	case "$flags" in
	'') $echo $n ".$c"
		if $cc $ccflags \
		$i_time $i_systime $i_systimek $sysselect $s_timeval $s_timezone \
		try.c -o try >/dev/null 2>&1 ; then
			set X $i_time $i_systime $i_systimek $sysselect $s_timeval
			shift
			flags="$*"
			echo " "
			$echo $n "Succeeded with $flags$c"
		fi
		;;
	esac
done
done
done
done
done
timeincl=''
echo " "
case "$flags" in
*SYSTIMEKERNEL*) i_systimek="$define"
	timeincl=`./findhdr sys/time.h`
	echo "We'll include <sys/time.h> with KERNEL defined." >&4;;
*) i_systimek="$undef";;
esac
case "$flags" in
*I_TIME*) i_time="$define"
	timeincl=`./findhdr time.h`" $timeincl"
	echo "We'll include <time.h>." >&4;;
*) i_time="$undef";;
esac
case "$flags" in
*I_SYSTIME*) i_systime="$define"
	timeincl=`./findhdr sys/time.h`" $timeincl"
	echo "We'll include <sys/time.h>." >&4;;
*) i_systime="$undef";;
esac
$rm -f try.c try

: check for fd_set items
$cat <<EOM

Checking to see how well your C compiler handles fd_set and friends ...
EOM
$cat >fd_set.c <<EOCP
#$i_systime I_SYS_TIME
#$i_sysselct I_SYS_SELECT
#$d_socket HAS_SOCKET
#include <sys/types.h>
#ifdef HAS_SOCKET
#include <sys/socket.h> /* Might include <sys/bsdtypes.h> */
#endif
#ifdef I_SYS_TIME
#include <sys/time.h>
#endif
#ifdef I_SYS_SELECT
#include <sys/select.h>
#endif
main() {
	fd_set fds;

#ifdef TRYBITS
	if(fds.fds_bits);
#endif

#if defined(FD_SET) && defined(FD_CLR) && defined(FD_ISSET) && defined(FD_ZERO)
	exit(0);
#else
	exit(1);
#endif
}
EOCP
if $cc $ccflags -DTRYBITS fd_set.c -o fd_set >fd_set.out 2>&1 ; then
	d_fds_bits="$define"
	d_fd_set="$define"
	echo "Well, your system knows about the normal fd_set typedef..." >&4
	if ./fd_set; then
		echo "and you have the normal fd_set macros (just as I'd expect)." >&4
		d_fd_macros="$define"
	else
		$cat >&4 <<'EOM'
but not the normal fd_set macros!  Gaaack!  I'll have to cover for you.
EOM
		d_fd_macros="$undef"
	fi
else
	$cat <<'EOM'
Hmm, your compiler has some difficulty with fd_set.  Checking further...
EOM
	if $cc $ccflags fd_set.c -o fd_set >fd_set.out 2>&1 ; then
		d_fds_bits="$undef"
		d_fd_set="$define"
		echo "Well, your system has some sort of fd_set available..." >&4
		if ./fd_set; then
			echo "and you have the normal fd_set macros." >&4
			d_fd_macros="$define"
		else
			$cat <<'EOM'
but not the normal fd_set macros!  Gross!  More work for me...
EOM
			d_fd_macros="$undef"
		fi
	else
	echo "Well, you got zip.  That's OK, I can roll my own fd_set stuff." >&4
		d_fd_set="$undef"
		d_fds_bits="$undef"
		d_fd_macros="$undef"
	fi
fi
$rm -f fd_set*


: check for type of arguments to select.  This will only really
: work if the system supports prototypes and provides one for
: select.
case "$d_select" in
$define)
	: Make initial guess
	case "$selecttype" in
	''|' ')
		case "$d_fd_set" in
		$define) xxx='fd_set *' ;;
		*) xxx='int *' ;;
		esac
		;;
	*) 	xxx="$selecttype" 
		;;
	esac
	: backup guess
	case "$xxx" in
	'fd_set *') yyy='int *' ;;
	'int *') yyy='fd_set *' ;;
	esac

	$cat <<EOM

Checking to see what type of arguments are expected by select().
EOM
	$cat >try.c <<EOCP
#$i_systime I_SYS_TIME
#$i_sysselct I_SYS_SELECT
#$d_socket HAS_SOCKET
#include <sys/types.h>
#ifdef HAS_SOCKET
#include <sys/socket.h> /* Might include <sys/bsdtypes.h> */
#endif
#ifdef I_SYS_TIME
#include <sys/time.h>
#endif
#ifdef I_SYS_SELECT
#include <sys/select.h>
#endif
main()
{
	int width;
	Select_fd_set_t readfds;
	Select_fd_set_t writefds;
	Select_fd_set_t exceptfds;
	struct timeval timeout;
	select(width, readfds, writefds, exceptfds, &timeout);
	exit(0);
}
EOCP
	if $cc $ccflags -c -DSelect_fd_set_t="$xxx" try.c >/dev/null 2>&1 ; then
		selecttype="$xxx"
		echo "Your system uses $xxx for the arguments to select." >&4
	elif $cc $ccflags -c -DSelect_fd_set_t="$yyy" try.c >/dev/null 2>&1 ; then
		selecttype="$yyy"
		echo "Your system uses $yyy for the arguments to select." >&4
	else
		rp='What is the type for the 2nd, 3rd, and 4th arguments to select?'
		dflt="$xxx"
		. ./myread
		selecttype="$ans"
	fi
	$rm -f try.[co]
	;;
*)	selecttype='int *'
	;;
esac

: Trace out the files included by signal.h, then look for SIGxxx names.
: Remove SIGARRAYSIZE used by HPUX.
: Remove SIGTYP void lines used by OS2.
xxx=`echo '#include <signal.h>' |
	$cppstdin $cppminus $cppflags 2>/dev/null |
	$grep '^[ 	]*#.*include' | 
	$awk "{print \\$$fieldn}" | $sed 's!"!!g' | $sort | $uniq`
: Check this list of files to be sure we have parsed the cpp output ok.
: This will also avoid potentially non-existent files, such 
: as ../foo/bar.h
xxxfiles=''
for xx in $xxx /dev/null ; do
	$test -f "$xx" && xxxfiles="$xxxfiles $xx"
done
: If we have found no files, at least try signal.h
case "$xxxfiles" in
'')	xxxfiles=`./findhdr signal.h` ;;
esac
xxx=`awk '
$1 ~ /^#define$/ && $2 ~ /^SIG[A-Z0-9]*$/ && $2 !~ /SIGARRAYSIZE/ && $3 !~ /void/ {
	print substr($2, 4, 20)
}
$1 == "#" && $2 ~ /^define$/ && $3 ~ /^SIG[A-Z0-9]*$/ && $3 !~ /SIGARRAYSIZE/ && $4 !~ /void/ {
	print substr($3, 4, 20)
}' $xxxfiles`
: Append some common names just in case the awk scan failed.
xxx="$xxx ABRT ALRM BUS CHLD CLD CONT DIL EMT FPE HUP ILL INT IO IOT KILL"
xxx="$xxx LOST PHONE PIPE POLL PROF PWR QUIT SEGV STKFLT STOP SYS TERM TRAP"
xxx="$xxx TSTP TTIN TTOU URG USR1 USR2 USR3 USR4 VTALRM"
xxx="$xxx WINCH WIND WINDOW XCPU XFSZ"
: generate a few handy files for later
$cat > signal.c <<'EOP'
#include <sys/types.h>
#include <signal.h>
int main() {

/* Strange style to avoid deeply-nested #if/#else/#endif */
#ifndef NSIG
#  ifdef _NSIG
#    define NSIG (_NSIG)
#  endif
#endif

#ifndef NSIG
#  ifdef SIGMAX
#    define NSIG (SIGMAX+1)
#  endif
#endif

#ifndef NSIG
#  ifdef SIG_MAX
#    define NSIG (SIG_MAX+1)
#  endif
#endif

#ifndef NSIG
#  ifdef MAXSIG
#    define NSIG (MAXSIG+1)
#  endif
#endif

#ifndef NSIG
#  ifdef MAX_SIG
#    define NSIG (MAX_SIG+1)
#  endif
#endif

#ifndef NSIG
#  ifdef SIGARRAYSIZE
#    define NSIG (SIGARRAYSIZE+1) /* Not sure of the +1 */
#  endif
#endif

#ifndef NSIG
#  ifdef _sys_nsig
#    define NSIG (_sys_nsig) /* Solaris 2.5 */
#  endif
#endif

/* Default to some arbitrary number that's big enough to get most
   of the common signals.
*/
#ifndef NSIG
#    define NSIG 50
#endif

printf("NSIG %d\n", NSIG);

EOP
echo $xxx | $tr ' ' '\012' | $sort | $uniq | $awk '
{
	printf "#ifdef SIG"; printf $1; printf "\n"
	printf "printf(\""; printf $1; printf " %%d\\n\",SIG";
	printf $1; printf ");\n"
	printf "#endif\n"
}
END {
	printf "}\n";
}
' >>signal.c
$cat >signal.awk <<'EOP'
BEGIN { ndups = 0 }
$1 ~ /^NSIG$/ { nsig = $2 }
($1 !~ /^NSIG$/) && (NF == 2) {
    if ($2 > maxsig) { maxsig = $2 }
    if (sig_name[$2]) {
	dup_name[ndups] = $1
	dup_num[ndups] = $2
	ndups++ 
    }
    else {
	sig_name[$2] = $1
	sig_num[$2] = $2
    }

}
END { 
    if (nsig == 0) { nsig = maxsig + 1 }
	for (n = 1; n < nsig; n++) {
		if (sig_name[n]) {
			printf("%s %d\n", sig_name[n], sig_num[n])
		}
		else {
			printf("NUM%d %d\n", n, n) 
		}
	}
    for (n = 0; n < ndups; n++) {
		printf("%s %d\n", dup_name[n], dup_num[n])
    }
}
EOP
$cat >signal_cmd <<EOS
$startsh
$test -s signal.lst && exit 0
if $cc $ccflags $ldflags signal.c -o signal >/dev/null 2>&1; then
	./signal | $sort -n +1 | $uniq | $awk -f signal.awk >signal.lst
else
	echo "(I can't seem be able to compile the test program -- Guessing)"
	echo 'kill -l' >signal
	set X \`csh -f <signal\`
	$rm -f signal
	shift
	case \$# in
	0) set HUP INT QUIT ILL TRAP ABRT EMT FPE KILL BUS SEGV SYS PIPE ALRM TERM;;
	esac
	echo \$@ | $tr ' ' '\012' | \
		$awk '{ printf \$1; printf " %d\n", ++s; }' >signal.lst
fi
$rm -f signal.c signal signal.o
EOS
chmod a+x signal_cmd
$eunicefix signal_cmd

: generate list of signal names
echo " "
case "$sig_name" in
'')	sig_num='' ;;
esac
case "$sig_num" in
'')	sig_name='' ;;
esac
case "$sig_name" in
'')
	echo "Generating a list of signal names and numbers..." >&4
	./signal_cmd
	sig_name=`$awk '{printf "%s ", $1}' signal.lst`
	sig_name="ZERO $sig_name"
	sig_num=`$awk '{printf "%d ", $2}' signal.lst`
	sig_num="0 $sig_num"
	;;
esac
echo "The following signals are available:"
echo " "
echo $sig_name | $awk \
'BEGIN { linelen = 0 }
{
	for (i = 1; i <= NF; i++) {
		name = "SIG" $i " "
		linelen = linelen + length(name)
		if (linelen > 70) {
			printf "\n"
			linelen = length(name)
		}
		printf "%s", name
	}
	printf "\n"
}'
$rm -f signal signal.c signal.awk signal.lst signal_cmd 

: see what type is used for size_t
set size_t sizetype 'unsigned int' stdio.h sys/types.h
eval $typedef
dflt="$sizetype"
echo " "
rp="What type is used for the length parameter for string functions?"
. ./myread
sizetype="$ans"

: see what type is used for signed size_t
set ssize_t ssizetype int stdio.h sys/types.h
eval $typedef
dflt="$ssizetype"
$cat > ssize.c <<EOM
#include <stdio.h>
#include <sys/types.h>
#define Size_t $sizetype
#define SSize_t $dflt
main()
{
	if (sizeof(Size_t) == sizeof(SSize_t))
		printf("$dflt\n");
	else if (sizeof(Size_t) == sizeof(int))
		printf("int\n");
	else 
		printf("long\n");
	fflush(stdout);
	exit(0);
}
EOM
echo " "
#	If $libs contains -lsfio, and sfio is mis-configured, then it
#	sometimes (apparently) runs and exits with a 0 status, but with no
#	output!.  Thus we check with test -s whether we actually got any 
#	output.  I think it has to do with sfio's use of _exit vs. exit,
#	but I don't know for sure.  --Andy Dougherty  1/27/97.
if $cc $optimize $ccflags $ldflags -o ssize ssize.c $libs > /dev/null 2>&1  &&
		./ssize > ssize.out 2>/dev/null && test -s ssize.out ; then
	ssizetype=`$cat ssize.out`
	echo "I'll be using $ssizetype for functions returning a byte count." >&4
else
	$cat >&4 <<EOM

Help! I can't compile and run the ssize_t test program: please enlighten me!
(This is probably a misconfiguration in your system or libraries, and
you really ought to fix it.  Still, I'll try anyway.)

I need a type that is the same size as $sizetype, but is guaranteed to
be signed.  Common values are ssize_t, int and long.

EOM
	rp="What signed type is the same size as $sizetype?"
	. ./myread
	ssizetype="$ans"
fi
$rm -f ssize ssize.[co] ssize.out

: see what type of char stdio uses.
echo " "
if $contains 'unsigned.*char.*_ptr;' `./findhdr stdio.h` >/dev/null 2>&1 ; then
	echo "Your stdio uses unsigned chars." >&4
	stdchar="unsigned char"
else
	echo "Your stdio uses signed chars." >&4
	stdchar="char"
fi

: see if time exists
echo " "
if set time val -f d_time; eval $csym; $val; then
	echo 'time() found.' >&4
	val="$define"
	set time_t timetype long stdio.h sys/types.h
	eval $typedef
	dflt="$timetype"
	echo " "
	rp="What type is returned by time() on this system?"
	. ./myread
	timetype="$ans"
else
	echo 'time() not found, hope that will do.' >&4
	val="$undef"
	timetype='int';
fi
set d_time
eval $setvar

: see what type uids are declared as in the kernel
set uid_t uidtype xxx stdio.h sys/types.h
eval $typedef
case "$uidtype" in
xxx)
	xxx=`./findhdr sys/user.h`
	set `grep '_ruid;' "$xxx" 2>/dev/null` unsigned short
	case $1 in
	unsigned) dflt="$1 $2" ;;
	*) dflt="$1" ;;
	esac
	;;
*) dflt="$uidtype";;
esac
echo " "
rp="What is the type for user ids returned by getuid()?"
. ./myread
uidtype="$ans"

: see if dbm.h is available
: see if dbmclose exists
set dbmclose d_dbmclose
eval $inlibc

case "$d_dbmclose" in
$define)
	set dbm.h i_dbm
	eval $inhdr
	case "$i_dbm" in
	$define)
		val="$undef"
		set i_rpcsvcdbm
		eval $setvar
		;;
	*)	set rpcsvc/dbm.h i_rpcsvcdbm
		eval $inhdr
		;;
	esac
	;;
*)	echo "We won't be including <dbm.h>"
	val="$undef"
	set i_dbm
	eval $setvar
	val="$undef"
	set i_rpcsvcdbm
	eval $setvar
	;;
esac

: see if this is a sys/file.h system
val=''
set sys/file.h val
eval $inhdr

: do we need to include sys/file.h ?
case "$val" in
"$define")
	echo " "
	if $h_sysfile; then
		val="$define"
		echo "We'll be including <sys/file.h>." >&4
	else
		val="$undef"
		echo "We won't be including <sys/file.h>." >&4
	fi
	;;
*)
	h_sysfile=false
	;;
esac
set i_sysfile
eval $setvar

: see if fcntl.h is there
val=''
set fcntl.h val
eval $inhdr

: see if we can include fcntl.h
case "$val" in
"$define")
	echo " "
	if $h_fcntl; then
		val="$define"
		echo "We'll be including <fcntl.h>." >&4
	else
		val="$undef"
		if $h_sysfile; then
	echo "We don't need to include <fcntl.h> if we include <sys/file.h>." >&4
		else
			echo "We won't be including <fcntl.h>." >&4
		fi
	fi
	;;
*)
	h_fcntl=false
	val="$undef"
	;;
esac
set i_fcntl
eval $setvar

: see if this is an grp system
set grp.h i_grp
eval $inhdr

: see if locale.h is available
set locale.h i_locale
eval $inhdr

: see if this is a math.h system
set math.h i_math
eval $inhdr

: see if ndbm.h is available
set ndbm.h t_ndbm
eval $inhdr
case "$t_ndbm" in
$define)
	: see if dbm_open exists
	set dbm_open d_dbm_open
	eval $inlibc
	case "$d_dbm_open" in
	$undef)
		t_ndbm="$undef"
		echo "We won't be including <ndbm.h>"
		;;
	esac
	;;
esac
val="$t_ndbm"
set i_ndbm
eval $setvar

: see if net/errno.h is available
val=''
set net/errno.h val
eval $inhdr

: Unfortunately, it causes problems on some systems.  Arrgh.
case "$val" in
$define)
	cat > try.c <<'EOM'
#include <stdio.h>
#include <errno.h>
#include <net/errno.h>
int func()
{
	return ENOTSOCK;
}
EOM
	if $cc $ccflags -c try.c >/dev/null 2>&1; then
		echo "We'll be including <net/errno.h>." >&4
	else
		echo "We won't be including <net/errno.h>." >&4
		val="$undef"
	fi
	$rm -f try.* try
	;;
esac
set i_neterrno
eval $setvar

: get C preprocessor symbols handy
echo " "
$echo $n "Hmm... $c"
echo $al | $tr ' ' '\012' >Cppsym.know
$cat <<EOSS >Cppsym
$startsh
case "\$1" in
-l) list=true
	shift
	;;
esac
unknown=''
case "\$list\$#" in
1|2)
	for sym do
		if $contains "^\$1$" Cppsym.true >/dev/null 2>&1; then
			exit 0
		elif $contains "^\$1$" Cppsym.know >/dev/null 2>&1; then
			:
		else
			unknown="\$unknown \$sym"
		fi
	done
	set X \$unknown
	shift
	;;
esac
case \$# in
0) exit 1;;
esac
echo \$* | $tr ' ' '\012' | $sed -e 's/\(.*\)/\\
#ifdef \1\\
exit 0; _ _ _ _\1\\	 \1\\
#endif\\
/' >Cppsym\$\$
echo "exit 1; _ _ _" >>Cppsym\$\$
$cppstdin $cppminus <Cppsym\$\$ | $grep '^exit [01]; _ _'  >Cppsym2\$\$
case "\$list" in
true) $awk 'NF > 5 {print substr(\$6,2,100)}' <Cppsym2\$\$ ;;
*)
	sh Cppsym2\$\$
	status=\$?
	;;
esac
$rm -f Cppsym\$\$ Cppsym2\$\$
exit \$status
EOSS
chmod +x Cppsym
$eunicefix Cppsym
./Cppsym -l $al | $sort | $grep -v '^$' >Cppsym.true

: now check the C compiler for additional symbols
$cat >ccsym <<EOS
$startsh
$cat >tmp.c <<EOF
extern int foo;
EOF
for i in \`$cc -v -c tmp.c 2>&1\`
do
	case "\$i" in
	-D*) echo "\$i" | $sed 's/^-D//';;
	-A*) $test "$gccversion" && echo "\$i" | $sed 's/^-A\(.*\)(\(.*\))/\1=\2/';;
	esac
done
$rm -f try.c
EOS
chmod +x ccsym
$eunicefix ccsym
./ccsym | $sort | $uniq >ccsym.raw
$awk '/\=/ { print $0; next }
	{ print $0"=1" }' ccsym.raw >ccsym.list
$awk '{ print $0"=1" }' Cppsym.true >ccsym.true
$comm -13 ccsym.true ccsym.list >ccsym.own
$comm -12 ccsym.true ccsym.list >ccsym.com
$comm -23 ccsym.true ccsym.list >ccsym.cpp
also=''
symbols='symbols'
if $test -z ccsym.raw; then
	echo "Your C compiler doesn't seem to define any symbol!" >&4
	echo " "
	echo "However, your C preprocessor defines the following ones:"
	$cat Cppsym.true
else
	if $test -s ccsym.com; then
		echo "Your C compiler and pre-processor define these symbols:"
		$sed -e 's/\(.*\)=.*/\1/' ccsym.com
		also='also '
		symbols='ones'
		$test "$silent" || sleep 1
	fi
	if $test -s ccsym.cpp; then
		$test "$also" && echo " "
		echo "Your C pre-processor ${also}defines the following $symbols:"
		$sed -e 's/\(.*\)=.*/\1/' ccsym.cpp
		also='further '
		$test "$silent" || sleep 1
	fi
	if $test -s ccsym.own; then
		$test "$also" && echo " "
		echo "Your C compiler ${also}defines the following cpp variables:"
		$sed -e 's/\(.*\)=1/\1/' ccsym.own
		$sed -e 's/\(.*\)=.*/\1/' ccsym.own | $uniq >>Cppsym.true
		$test "$silent" || sleep 1
	fi
fi
$rm -f ccsym*

: see if this is a termio system
val="$undef"
val2="$undef"
val3="$undef"
if $test `./findhdr termios.h`; then
	set tcsetattr i_termios
	eval $inlibc
	val3="$i_termios"
fi
echo " "
case "$val3" in
"$define") echo "You have POSIX termios.h... good!" >&4;;
*) if ./Cppsym pyr; then
		case "`/bin/universe`" in
		ucb) if $test `./findhdr sgtty.h`; then
				val2="$define"
				echo "<sgtty.h> found." >&4
			else
				echo "System is pyramid with BSD universe."
				echo "<sgtty.h> not found--you could have problems." >&4
			fi;;
		*) if $test `./findhdr termio.h`; then
				val="$define"
				echo "<termio.h> found." >&4
			else
				echo "System is pyramid with USG universe."
				echo "<termio.h> not found--you could have problems." >&4
			fi;;
		esac
	elif ./usg; then
		if $test `./findhdr termio.h`; then
			echo "<termio.h> found." >&4
			val="$define"
		elif $test `./findhdr sgtty.h`; then
			echo "<sgtty.h> found." >&4
			val2="$define"
		else
echo "Neither <termio.h> nor <sgtty.h> found--you could have problems." >&4
		fi
	else
		if $test `./findhdr sgtty.h`; then
			echo "<sgtty.h> found." >&4
			val2="$define"
		elif $test `./findhdr termio.h`; then
			echo "<termio.h> found." >&4
			val="$define"
		else
echo "Neither <sgtty.h> nor <termio.h> found--you could have problems." >&4
		fi
	fi;;
esac
set i_termio; eval $setvar
val=$val2; set i_sgtty; eval $setvar
val=$val3; set i_termios; eval $setvar

: see if stdarg is available
echo " "
if $test `./findhdr stdarg.h`; then
	echo "<stdarg.h> found." >&4
	valstd="$define"
else
	echo "<stdarg.h> NOT found." >&4
	valstd="$undef"
fi

: see if varags is available
echo " "
if $test `./findhdr varargs.h`; then
	echo "<varargs.h> found." >&4
else
	echo "<varargs.h> NOT found, but that's ok (I hope)." >&4
fi

: set up the varargs testing programs
$cat > varargs.c <<EOP
#ifdef I_STDARG
#include <stdarg.h>
#endif
#ifdef I_VARARGS
#include <varargs.h>
#endif

#ifdef I_STDARG
int f(char *p, ...)
#else
int f(va_alist)
va_dcl
#endif
{
	va_list ap;
#ifndef I_STDARG
	char *p;
#endif
#ifdef I_STDARG
	va_start(ap,p);
#else
	va_start(ap);
	p = va_arg(ap, char *);
#endif
	va_end(ap);
}
EOP
$cat > varargs <<EOP
$startsh
if $cc -c $ccflags -D\$1 varargs.c >/dev/null 2>&1; then
	echo "true"
else
	echo "false"
fi
$rm -f varargs.o
EOP
chmod +x varargs

: now check which varargs header should be included
echo " "
i_varhdr=''
case "$valstd" in
"$define")
	if `./varargs I_STDARG`; then
		val='stdarg.h'
	elif `./varargs I_VARARGS`; then
		val='varargs.h'
	fi
	;;
*)
	if `./varargs I_VARARGS`; then
		val='varargs.h'
	fi
	;;
esac
case "$val" in
'')
echo "I could not find the definition for va_dcl... You have problems..." >&4
	val="$undef"; set i_stdarg; eval $setvar
	val="$undef"; set i_varargs; eval $setvar
	;;
*) 
	set i_varhdr
	eval $setvar
	case "$i_varhdr" in
	stdarg.h)
		val="$define"; set i_stdarg; eval $setvar
		val="$undef"; set i_varargs; eval $setvar
		;;
	varargs.h)
		val="$undef"; set i_stdarg; eval $setvar
		val="$define"; set i_varargs; eval $setvar
		;;
	esac
	echo "We'll include <$i_varhdr> to get va_dcl definition." >&4;;
esac
$rm -f varargs*

: see if stddef is available
set stddef.h i_stddef
eval $inhdr

: see if ioctl defs are in sgtty, termio, sys/filio or sys/ioctl
set sys/filio.h i_sysfilio
eval $inhdr
echo " "
if $test `./findhdr sys/ioctl.h`; then
	val="$define"
	echo '<sys/ioctl.h> found.' >&4
else
	val="$undef"
	if $test $i_sysfilio = "$define"; then
	    echo '<sys/ioctl.h> NOT found.' >&4
	else
		$test $i_sgtty = "$define" && xxx="sgtty.h"
		$test $i_termio = "$define" && xxx="termio.h"
		$test $i_termios = "$define" && xxx="termios.h"
echo "No <sys/ioctl.h> found, assuming ioctl args are defined in <$xxx>." >&4
	fi
fi
set i_sysioctl
eval $setvar

: see if this is a sys/param system
set sys/param.h i_sysparam
eval $inhdr

: see if sys/resource.h has to be included
set sys/resource.h i_sysresrc
eval $inhdr

: see if sys/stat.h is available
set sys/stat.h i_sysstat
eval $inhdr

: see if sys/types.h has to be included
set sys/types.h i_systypes
eval $inhdr

: see if this is a sys/un.h system
set sys/un.h i_sysun
eval $inhdr

: see if this is a syswait system
set sys/wait.h i_syswait
eval $inhdr

: see if this is an utime system
set utime.h i_utime
eval $inhdr

: see if this is a values.h system
set values.h i_values
eval $inhdr

: see if this is a vfork system
case "$d_vfork" in
"$define")
	set vfork.h i_vfork
	eval $inhdr
	;;
*)
	i_vfork="$undef"
	;;
esac

: see if gdbm.h is available
set gdbm.h t_gdbm
eval $inhdr
case "$t_gdbm" in
$define)
	: see if gdbm_open exists
	set gdbm_open d_gdbm_open
	eval $inlibc
	case "$d_gdbm_open" in
	$undef)
		t_gdbm="$undef"
		echo "We won't be including <gdbm.h>"
		;;
	esac
	;;
esac
val="$t_gdbm"
set i_gdbm
eval $setvar

echo " "
echo "Looking for extensions..." >&4
cd ../ext
: If we are using the old config.sh, known_extensions may contain
: old or inaccurate or duplicate values.
known_extensions=''
: We do not use find because it might not be available.
: We do not just use MANIFEST because the user may have dropped
: some additional extensions into the source tree and expect them
: to be built.
for xxx in * ; do
    case "$xxx" in
    DynaLoader) ;;
    *)	if $test -f $xxx/$xxx.xs; then
	    known_extensions="$known_extensions $xxx"
	else
	    if $test -d $xxx; then
		cd $xxx
		for yyy in * ; do
		    if $test -f $yyy/$yyy.xs; then
			known_extensions="$known_extensions $xxx/$yyy"
		    fi
		done
		cd ..
	    fi
	fi ;;
    esac
done
set X $known_extensions
shift
known_extensions="$*"
cd ../UU

: Now see which are supported on this system.
avail_ext=''
for xxx in $known_extensions ; do
    case "$xxx" in
    DB_File) case "$i_db" in 
	    $define) avail_ext="$avail_ext $xxx" ;;
	    esac
	    ;;
    GDBM_File) case "$i_gdbm" in 
	    $define) avail_ext="$avail_ext $xxx" ;;
	    esac
	    ;;
    NDBM_File) case "$i_ndbm" in 
	    $define) avail_ext="$avail_ext $xxx" ;;
	    esac
	    ;;
    ODBM_File) case "${i_dbm}${i_rpcsvcdbm}" in 
	    *"${define}"*) avail_ext="$avail_ext $xxx" ;;
	    esac
	    ;;
    POSIX) case "$useposix" in 
	    true|define|y) avail_ext="$avail_ext $xxx" ;;
	    esac
	    ;;
    Opcode) case "$useopcode" in 
	    true|define|y) avail_ext="$avail_ext $xxx" ;;
	    esac
	    ;;
    Socket) case "$d_socket" in 
	    $define) avail_ext="$avail_ext $xxx" ;;
	    esac
	    ;;
    *)      avail_ext="$avail_ext $xxx"
	    ;;
    esac
done

set X $avail_ext
shift
avail_ext="$*"

case $usedl in
$define)
	$cat <<EOM
A number of extensions are supplied with $package.  You may choose to
compile these extensions for dynamic loading (the default), compile
them into the $package executable (static loading), or not include
them at all.  Answer "none" to include no extensions.

EOM
	case "$dynamic_ext" in
	'') dflt="$avail_ext" ;;
	*)	dflt="$dynamic_ext" ;;
	esac
	case "$dflt" in
	'')	dflt=none;;
	esac
	rp="What extensions do you wish to load dynamically?"
	. ./myread
	case "$ans" in
	none) dynamic_ext=' ' ;;
	*) dynamic_ext="$ans" ;;
	esac

	case "$static_ext" in
	'')
		: Exclude those already listed in dynamic linking
		dflt=''
		for xxx in $avail_ext; do
			case " $dynamic_ext " in
			*" $xxx "*) ;;
			*) dflt="$dflt $xxx" ;;
			esac
		done
		set X $dflt
		shift
		dflt="$*"
		;;
	*)  dflt="$static_ext" 
		;;
	esac

	case "$dflt" in
	'')	dflt=none;;
	esac
	rp="What extensions do you wish to load statically?"
	. ./myread
	case "$ans" in
	none) static_ext=' ' ;;
	*) static_ext="$ans" ;;
	esac
	;;
*)
	$cat <<EOM
A number of extensions are supplied with $package.  Answer "none" 
to include no extensions. 

EOM
	case "$static_ext" in
	'') dflt="$avail_ext" ;;
	*)	dflt="$static_ext" ;;
	esac

	case "$dflt" in
	'')	dflt=none;;
	esac
	rp="What extensions do you wish to include?"
	. ./myread
	case "$ans" in
	none) static_ext=' ' ;;
	*) static_ext="$ans" ;;
	esac
	;;
esac

set X $dynamic_ext $static_ext
shift
extensions="$*"

: Remove build directory name from cppstdin so it can be used from
: either the present location or the final installed location.
echo " "
: Get out of the UU directory to get correct path name.
cd ..
case "$cppstdin" in
`pwd`/cppstdin)
	echo "Stripping down cppstdin path name"
	cppstdin=cppstdin
	;;
esac
cd UU

: end of configuration questions
echo " "
echo "End of configuration questions."
echo " "

: back to where it started
if test -d ../UU; then
	cd ..
fi

: configuration may be patched via a 'config.over' file
if $test -f config.over; then
	echo " "
	dflt=y
	rp='I see a config.over file.  Do you wish to load it?'
	. UU/myread
	case "$ans" in
	n*) echo "OK, I'll ignore it.";;
	*)	. ./config.over
		echo "Configuration override changes have been loaded."
		;;
	esac
fi

: in case they want portability, strip down executable paths
case "$d_portable" in
"$define")
	echo " "
	echo "Stripping down executable paths..." >&4
	for file in $loclist $trylist; do
		eval $file="\$file"
	done
	;;
esac

: create config.sh file
echo " "
echo "Creating config.sh..." >&4
$spitshell <<EOT >config.sh
$startsh
#
# This file was produced by running the Configure script.  It holds all
# the definitions figured out by Configure.  Should you modify any of
# these values, do not forget to propagate your changes by running
# "Configure -S"; or, equivalently, you may run each .SH file yourself.
#

# Configuration time: $cf_time
# Configured by: $cf_by
# Target system: $myuname

Author='$Author'
Date='$Date'
Header='$Header'
Id='$Id'
Locker='$Locker'
Log='$Log'
Mcc='$Mcc'
RCSfile='$RCSfile'
Revision='$Revision'
Source='$Source'
State='$State'
afs='$afs'
alignbytes='$alignbytes'
aphostname='$aphostname'
ar='$ar'
archlib='$archlib'
archlibexp='$archlibexp'
archname='$archname'
archobjs='$archobjs'
awk='$awk'
baserev='$baserev'
bash='$bash'
bin='$bin'
bincompat3='$bincompat3'
binexp='$binexp'
bison='$bison'
byacc='$byacc'
byteorder='$byteorder'
c='$c'
castflags='$castflags'
cat='$cat'
cc='$cc'
cccdlflags='$cccdlflags'
ccdlflags='$ccdlflags'
ccflags='$ccflags'
cf_by='$cf_by'
cf_email='$cf_email'
cf_time='$cf_time'
chgrp='$chgrp'
chmod='$chmod'
chown='$chown'
clocktype='$clocktype'
comm='$comm'
compress='$compress'
contains='$contains'
cp='$cp'
cpio='$cpio'
cpp='$cpp'
cpp_stuff='$cpp_stuff'
cppflags='$cppflags'
cpplast='$cpplast'
cppminus='$cppminus'
cpprun='$cpprun'
cppstdin='$cppstdin'
cryptlib='$cryptlib'
csh='$csh'
d_Gconvert='$d_Gconvert'
d_access='$d_access'
d_alarm='$d_alarm'
d_archlib='$d_archlib'
d_attribut='$d_attribut'
d_bcmp='$d_bcmp'
d_bcopy='$d_bcopy'
d_bincompat3='$d_bincompat3'
d_bsd='$d_bsd'
d_bsdgetpgrp='$d_bsdgetpgrp'
d_bsdpgrp='$d_bsdpgrp'
d_bsdsetpgrp='$d_bsdsetpgrp'
d_bzero='$d_bzero'
d_casti32='$d_casti32'
d_castneg='$d_castneg'
d_charvspr='$d_charvspr'
d_chown='$d_chown'
d_chroot='$d_chroot'
d_chsize='$d_chsize'
d_closedir='$d_closedir'
d_const='$d_const'
d_crypt='$d_crypt'
d_csh='$d_csh'
d_cuserid='$d_cuserid'
d_dbl_dig='$d_dbl_dig'
d_difftime='$d_difftime'
d_dirnamlen='$d_dirnamlen'
d_dlerror='$d_dlerror'
d_dlopen='$d_dlopen'
d_dlsymun='$d_dlsymun'
d_dosuid='$d_dosuid'
d_dup2='$d_dup2'
d_eofnblk='$d_eofnblk'
d_eunice='$d_eunice'
d_fchmod='$d_fchmod'
d_fchown='$d_fchown'
d_fcntl='$d_fcntl'
d_fd_macros='$d_fd_macros'
d_fd_set='$d_fd_set'
d_fds_bits='$d_fds_bits'
d_fgetpos='$d_fgetpos'
d_flexfnam='$d_flexfnam'
d_flock='$d_flock'
d_fork='$d_fork'
d_fpathconf='$d_fpathconf'
d_fsetpos='$d_fsetpos'
d_ftime='$d_ftime'
d_getgrps='$d_getgrps'
d_setgrps='$d_setgrps'
d_gethent='$d_gethent'
d_gethname='$d_gethname'
d_getlogin='$d_getlogin'
d_getpgid='$d_getpgid'
d_getpgrp2='$d_getpgrp2'
d_getpgrp='$d_getpgrp'
d_getppid='$d_getppid'
d_getprior='$d_getprior'
d_gettimeod='$d_gettimeod'
d_gnulibc='$d_gnulibc'
d_htonl='$d_htonl'
d_index='$d_index'
d_inetaton='$d_inetaton'
d_isascii='$d_isascii'
d_killpg='$d_killpg'
d_link='$d_link'
d_locconv='$d_locconv'
d_lockf='$d_lockf'
d_lstat='$d_lstat'
d_mblen='$d_mblen'
d_mbstowcs='$d_mbstowcs'
d_mbtowc='$d_mbtowc'
d_memcmp='$d_memcmp'
d_memcpy='$d_memcpy'
d_memmove='$d_memmove'
d_memset='$d_memset'
d_mkdir='$d_mkdir'
d_mkfifo='$d_mkfifo'
d_mktime='$d_mktime'
d_msg='$d_msg'
d_msgctl='$d_msgctl'
d_msgget='$d_msgget'
d_msgrcv='$d_msgrcv'
d_msgsnd='$d_msgsnd'
d_mymalloc='$d_mymalloc'
d_nice='$d_nice'
d_oldarchlib='$d_oldarchlib'
d_oldsock='$d_oldsock'
d_open3='$d_open3'
d_pathconf='$d_pathconf'
d_pause='$d_pause'
d_phostname='$d_phostname'
d_pipe='$d_pipe'
d_poll='$d_poll'
d_portable='$d_portable'
d_pwage='$d_pwage'
d_pwchange='$d_pwchange'
d_pwclass='$d_pwclass'
d_pwcomment='$d_pwcomment'
d_pwexpire='$d_pwexpire'
d_pwquota='$d_pwquota'
d_readdir='$d_readdir'
d_readlink='$d_readlink'
d_rename='$d_rename'
d_rewinddir='$d_rewinddir'
d_rmdir='$d_rmdir'
d_safebcpy='$d_safebcpy'
d_safemcpy='$d_safemcpy'
d_sanemcmp='$d_sanemcmp'
d_seekdir='$d_seekdir'
d_select='$d_select'
d_sem='$d_sem'
d_semctl='$d_semctl'
d_semget='$d_semget'
d_semop='$d_semop'
d_setegid='$d_setegid'
d_seteuid='$d_seteuid'
d_setlinebuf='$d_setlinebuf'
d_setlocale='$d_setlocale'
d_setpgid='$d_setpgid'
d_setpgrp2='$d_setpgrp2'
d_setpgrp='$d_setpgrp'
d_setprior='$d_setprior'
d_setregid='$d_setregid'
d_setresgid='$d_setresgid'
d_setresuid='$d_setresuid'
d_setreuid='$d_setreuid'
d_setrgid='$d_setrgid'
d_setruid='$d_setruid'
d_setsid='$d_setsid'
d_sfio='$d_sfio'
d_shm='$d_shm'
d_shmat='$d_shmat'
d_shmatprototype='$d_shmatprototype'
d_shmctl='$d_shmctl'
d_shmdt='$d_shmdt'
d_shmget='$d_shmget'
d_sigaction='$d_sigaction'
d_sigsetjmp='$d_sigsetjmp'
d_socket='$d_socket'
d_sockpair='$d_sockpair'
d_statblks='$d_statblks'
d_stdio_cnt_lval='$d_stdio_cnt_lval'
d_stdio_ptr_lval='$d_stdio_ptr_lval'
d_stdiobase='$d_stdiobase'
d_stdstdio='$d_stdstdio'
d_strchr='$d_strchr'
d_strcoll='$d_strcoll'
d_strctcpy='$d_strctcpy'
d_strerrm='$d_strerrm'
d_strerror='$d_strerror'
d_strtod='$d_strtod'
d_strtol='$d_strtol'
d_strtoul='$d_strtoul'
d_strxfrm='$d_strxfrm'
d_suidsafe='$d_suidsafe'
d_symlink='$d_symlink'
d_syscall='$d_syscall'
d_sysconf='$d_sysconf'
d_sysernlst='$d_sysernlst'
d_syserrlst='$d_syserrlst'
d_system='$d_system'
d_tcgetpgrp='$d_tcgetpgrp'
d_tcsetpgrp='$d_tcsetpgrp'
d_telldir='$d_telldir'
d_time='$d_time'
d_times='$d_times'
d_truncate='$d_truncate'
d_tzname='$d_tzname'
d_umask='$d_umask'
d_uname='$d_uname'
d_vfork='$d_vfork'
d_void_closedir='$d_void_closedir'
d_voidsig='$d_voidsig'
d_voidtty='$d_voidtty'
d_volatile='$d_volatile'
d_vprintf='$d_vprintf'
d_wait4='$d_wait4'
d_waitpid='$d_waitpid'
d_wcstombs='$d_wcstombs'
d_wctomb='$d_wctomb'
d_xenix='$d_xenix'
date='$date'
db_hashtype='$db_hashtype'
db_prefixtype='$db_prefixtype'
defvoidused='$defvoidused'
direntrytype='$direntrytype'
dlext='$dlext'
dlsrc='$dlsrc'
dynamic_ext='$dynamic_ext'
eagain='$eagain'
echo='$echo'
egrep='$egrep'
emacs='$emacs'
eunicefix='$eunicefix'
exe_ext='$exe_ext'
expr='$expr'
extensions='$extensions'
find='$find'
firstmakefile='$firstmakefile'
flex='$flex'
fpostype='$fpostype'
freetype='$freetype'
full_csh='$full_csh'
full_sed='$full_sed'
gcc='$gcc'
gccversion='$gccversion'
gidtype='$gidtype'
glibpth='$glibpth'
grep='$grep'
groupcat='$groupcat'
groupstype='$groupstype'
gzip='$gzip'
h_fcntl='$h_fcntl'
h_sysfile='$h_sysfile'
hint='$hint'
hostcat='$hostcat'
huge='$huge'
i_bsdioctl='$i_bsdioctl'
i_db='$i_db'
i_dbm='$i_dbm'
i_dirent='$i_dirent'
i_dld='$i_dld'
i_dlfcn='$i_dlfcn'
i_fcntl='$i_fcntl'
i_float='$i_float'
i_gdbm='$i_gdbm'
i_grp='$i_grp'
i_limits='$i_limits'
i_locale='$i_locale'
i_malloc='$i_malloc'
i_math='$i_math'
i_memory='$i_memory'
i_ndbm='$i_ndbm'
i_neterrno='$i_neterrno'
i_niin='$i_niin'
i_pwd='$i_pwd'
i_rpcsvcdbm='$i_rpcsvcdbm'
i_sfio='$i_sfio'
i_sgtty='$i_sgtty'
i_stdarg='$i_stdarg'
i_stddef='$i_stddef'
i_stdlib='$i_stdlib'
i_string='$i_string'
i_sysdir='$i_sysdir'
i_sysfile='$i_sysfile'
i_sysfilio='$i_sysfilio'
i_sysin='$i_sysin'
i_sysioctl='$i_sysioctl'
i_sysndir='$i_sysndir'
i_sysparam='$i_sysparam'
i_sysresrc='$i_sysresrc'
i_sysselct='$i_sysselct'
i_syssockio='$i_syssockio'
i_sysstat='$i_sysstat'
i_systime='$i_systime'
i_systimek='$i_systimek'
i_systimes='$i_systimes'
i_systypes='$i_systypes'
i_sysun='$i_sysun'
i_syswait='$i_syswait'
i_termio='$i_termio'
i_termios='$i_termios'
i_time='$i_time'
i_unistd='$i_unistd'
i_utime='$i_utime'
i_values='$i_values'
i_varargs='$i_varargs'
i_varhdr='$i_varhdr'
i_vfork='$i_vfork'
incpath='$incpath'
inews='$inews'
installarchlib='$installarchlib'
installbin='$installbin'
installman1dir='$installman1dir'
installman3dir='$installman3dir'
installprivlib='$installprivlib'
installscript='$installscript'
installsitearch='$installsitearch'
installsitelib='$installsitelib'
intsize='$intsize'
known_extensions='$known_extensions'
ksh='$ksh'
large='$large'
ld='$ld'
lddlflags='$lddlflags'
ldflags='$ldflags'
less='$less'
lib_ext='$lib_ext'
libc='$libc'
libperl='$libperl'
libpth='$libpth'
libs='$libs'
libswanted='$libswanted'
line='$line'
lint='$lint'
lkflags='$lkflags'
ln='$ln'
lns='$lns'
locincpth='$locincpth'
loclibpth='$loclibpth'
longsize='$longsize'
lp='$lp'
lpr='$lpr'
ls='$ls'
lseektype='$lseektype'
mail='$mail'
mailx='$mailx'
make='$make'
make_set_make='$make_set_make'
mallocobj='$mallocobj'
mallocsrc='$mallocsrc'
malloctype='$malloctype'
man1dir='$man1dir'
man1direxp='$man1direxp'
man1ext='$man1ext'
man3dir='$man3dir'
man3direxp='$man3direxp'
man3ext='$man3ext'
medium='$medium'
mips='$mips'
mips_type='$mips_type'
mkdir='$mkdir'
models='$models'
modetype='$modetype'
more='$more'
mv='$mv'
myarchname='$myarchname'
mydomain='$mydomain'
myhostname='$myhostname'
myuname='$myuname'
n='$n'
nm_opt='$nm_opt'
nm_so_opt='$nm_so_opt'
nroff='$nroff'
o_nonblock='$o_nonblock'
obj_ext='$obj_ext'
oldarchlib='$oldarchlib'
oldarchlibexp='$oldarchlibexp'
optimize='$optimize'
orderlib='$orderlib'
osname='$osname'
osvers='$osvers'
package='$package'
pager='$pager'
passcat='$passcat'
patchlevel='$patchlevel'
path_sep='$path_sep'
perl='$perl'
perladmin='$perladmin'
perlpath='$perlpath'
pg='$pg'
phostname='$phostname'
plibpth='$plibpth'
pmake='$pmake'
pr='$pr'
prefix='$prefix'
prefixexp='$prefixexp'
privlib='$privlib'
privlibexp='$privlibexp'
prototype='$prototype'
randbits='$randbits'
ranlib='$ranlib'
rd_nodata='$rd_nodata'
rm='$rm'
rmail='$rmail'
runnm='$runnm'
scriptdir='$scriptdir'
scriptdirexp='$scriptdirexp'
sed='$sed'
selecttype='$selecttype'
sendmail='$sendmail'
sh='$sh'
shar='$shar'
sharpbang='$sharpbang'
shmattype='$shmattype'
shortsize='$shortsize'
shrpenv='$shrpenv'
shsharp='$shsharp'
sig_name='$sig_name'
sig_num='$sig_num'
signal_t='$signal_t'
sitearch='$sitearch'
sitearchexp='$sitearchexp'
sitelib='$sitelib'
sitelibexp='$sitelibexp'
sizetype='$sizetype'
sleep='$sleep'
smail='$smail'
small='$small'
so='$so'
sockethdr='$sockethdr'
socketlib='$socketlib'
sort='$sort'
spackage='$spackage'
spitshell='$spitshell'
split='$split'
ssizetype='$ssizetype'
startperl='$startperl'
startsh='$startsh'
static_ext='$static_ext'
stdchar='$stdchar'
stdio_base='$stdio_base'
stdio_bufsiz='$stdio_bufsiz'
stdio_cnt='$stdio_cnt'
stdio_ptr='$stdio_ptr'
strings='$strings'
submit='$submit'
subversion='$subversion'
sysman='$sysman'
tail='$tail'
tar='$tar'
tbl='$tbl'
test='$test'
timeincl='$timeincl'
timetype='$timetype'
touch='$touch'
tr='$tr'
troff='$troff'
uidtype='$uidtype'
uname='$uname'
uniq='$uniq'
usedl='$usedl'
usemymalloc='$usemymalloc'
usenm='$usenm'
useopcode='$useopcode'
useperlio='$useperlio'
useposix='$useposix'
usesfio='$usesfio'
useshrplib='$useshrplib'
usevfork='$usevfork'
usrinc='$usrinc'
uuname='$uuname'
vi='$vi'
voidflags='$voidflags'
xlibpth='$xlibpth'
zcat='$zcat'
zip='$zip'
EOT

: add special variables
$test -f patchlevel.h && \
awk '/^#define/ {printf "%s=%s\n",$2,$3}' patchlevel.h >>config.sh
echo "CONFIG=true" >>config.sh

: propagate old symbols
if $test -f UU/config.sh; then
	<UU/config.sh sort | uniq >UU/oldconfig.sh
	sed -n 's/^\([a-zA-Z_0-9]*\)=.*/\1/p' config.sh config.sh UU/oldconfig.sh |\
	sort | uniq -u >UU/oldsyms
	set X `cat UU/oldsyms`
	shift
	case $# in
	0) ;;
	*)
		cat <<EOM
Hmm...You had some extra variables I don't know about...I'll try to keep 'em...
EOM
		echo "# Variables propagated from previous config.sh file." >>config.sh
		for sym in `cat UU/oldsyms`; do
			echo "    Propagating $hint variable "'$'"$sym..."
			eval 'tmp="$'"${sym}"'"'
			echo "$tmp" | \
				sed -e "s/'/'\"'\"'/g" -e "s/^/$sym='/" -e "s/$/'/" >>config.sh
		done
		;;
	esac
fi

: Finish up by extracting the .SH files
case "$alldone" in
exit)
	$rm -rf UU
	echo "Done."
	exit 0
	;;
cont)
	;;
'')
	dflt=''
	nostick=true
	$cat <<EOM

If you'd like to make any changes to the config.sh file before I begin
to configure things, do it as a shell escape now (e.g. !vi config.sh).

EOM
	rp="Press return or use a shell escape to edit config.sh:"
	. UU/myread
	nostick=''
	case "$ans" in
	'') ;;
	*) : in case they cannot read
		sh 1>&4 -c "$ans";;
	esac
	;;
esac

: if this fails, just run all the .SH files by hand
. ./config.sh

echo " "
exec 1>&4
. ./UU/extract

if $contains '^depend:' [Mm]akefile >/dev/null 2>&1; then
	dflt=y
	case "$silent" in
	true) ;;
	*)
		$cat <<EOM

Now you need to generate make dependencies by running "make depend".
You might prefer to run it in background: "make depend > makedepend.out &"
It can take a while, so you might not want to run it right now.

EOM
		;;
	esac
	rp="Run make depend now?"
	. UU/myread
	case "$ans" in
	y*)
		make depend && echo "Now you must run a make."
		;;
	*)
		echo "You must run 'make depend' then 'make'."
		;;
	esac
elif test -f [Mm]akefile; then
	echo " "
	echo "Now you must run a make."
else
	echo "Done."
fi

$rm -f kit*isdone ark*isdone
$rm -rf UU

: End of Configure

