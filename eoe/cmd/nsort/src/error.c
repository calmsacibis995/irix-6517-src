/*
 ****************************************************************************
 *    Copyright © 1996 Ordinal Technology Corp.  All Rights Reserved.       *
 *                                                                          *
 *    DO NOT DISCLOSE THIS SOURCE CODE OUTSIDE OF SILICON GRAPHICS, INC.    *
 *  This source code contains unpublished proprietary information of        *
 *  Ordinal Technology Corp.  The copyright notice above is not evidence    *
 *  of any actual or intended publication of this information.              *
 *      This source code is licensed to Silicon Graphics, Inc. for          *
 *  its personal use in developing and maintaining products for the IRIX    *
 *  operating system.  This source code may not be disclosed to any third   *
 *  party outside of Silicon Graphics, Inc. without the prior written       *
 *  consent of Ordinal Technology Corp.                                     *
 ****************************************************************************
 *
 *
 * error.c	- map error enum values to strings and display them
 *
 *	$Ordinal-Id: error.c,v 1.29 1996/11/06 23:04:46 charles Exp $
 */
#ident	"$Revision: 1.1 $"

#include "otcsort.h"
#include <stdarg.h>


/*
** The text of error messages generated by the parser
*/
const char *ErrorText[] =
{
    /* NoError = 0	*/	"Parser Error 0",
    /* StatementStart	*/	"A statement must start with '/' or '-'",
    /* ColonExpected	*/	"A ':' or '=' is expected after this keyword",
    /* CommaExpectedInList */	"A ',' is expected inside a list",
    /* UnexpectedInList */	"This is not expected inside this list",
    /* ParenExpectedBeginningList */ "A parenthesis '(' was expected after this keyword",
    /* ParenExpectedEndingList */ "A parenthesis ')' was expected after this keyword",
    /* AmbiguousIdentifier */	"This command name is not sufficiently selective.\nThe possible command names here are: ",
    /* UnexpectedKeyword */	"This word is not supported in this context.\nThe commands recognized here are: ",
    /* UnknownKeyword */	"This name is not known",
    /* NeedsEq		*/	"This keyword should be followed by '=' or ':'",
    /* NeedsPositiveInteger */	"A positive integer is expected here",
    /* OverflowInScale */	"This scaled number overflows a 64-bit integer",
    /* TypeMismatch	*/	"The type of this expression must match the type of the field",
    /* TypeWithoutLength*/	"This type needs a size:n specification",
    /* ExtendsBeyondEnd */	"This field extends beyond the end of the record",
    /* UnsignedWithoutType */	"The 'unsigned' qualifier is supported only for binary types",
    /* FieldNameNeedsEq */	"'=' or ':' is needed after 'name'",
    /* MethodNeedsEq	*/	"'=' or ':' is needed after 'method'",
    /* SpecificationNeedsEq */	"'=' or ':' is needed after 'specification'",
    /* FieldAlreadyNamed */	"This field has already been named",
    /* BadFieldName	*/	"A field name may contains letters, digits, and '_'",
    /* BadRecSize	*/	"Record sizes may range from 0 to 65534",
    /* BadRecSizeSpec	*/	"Record size must be followed by an integer or 'variable'",
    /* RecMustBeVarlen */	"This modifier is supported only on non fixed-length records",
    /* RecMaxlenNeedsInt */	"The integral maximum record length was expected here",
    /* RecMaxlenInvalid */	"The maximum record length may range from 1 to 65534",
    /* RecMinlenNeedsInt */	"The integral minimum record length was expected here",
    /* RecMinlenInvalid */	"The minimum record length may range from 0 to 65534",
    /* DelimNeeded	*/	"A character constant (e.g. ',') is expected after 'delimiter:'",
    /* TypeNotDelimitable */	"Delimiters are accepted only for string types",
    /* FieldAlreadyTyped */	"This field already has a type",
    /* FloatSize	*/	"The size of a single precision floating point field is 4 bytes",
    /* DoubleSize	*/	"The size of a double precision floating point field is 8 bytes",
    /* PackedUnimplemented */	"Packed decimal is not yet supported",
    /* PadNeeded	*/	"A character constant (e.g. ',') is expected after 'pad:'",
    /* PositionNeeded	*/	"An integer value is expected after 'position:'",
    /* DuplicateFieldName */	"Another field has already been given this name",
    /* FieldSizeNeeded	*/	"An integer value is expected after 'size:'",
    /* FieldBothSizeDelim */	"A field may not have both size: and delimiter: specifications",
    /* FieldAlreadySized */	"This field already has a size specification",
    /* FieldAlreadyDelimited */	"This field already has a delimiter",
    /* FieldSyntax	*/	"Syntax error in field description",
    /* PositionPositive	*/	"The position of a field start at 1, not 0",
    /* KeyFieldMissing	*/	"The field named in this key specification is undefined",
    /* KeyAlreadyTyped	*/	"This key already has a type defined for it",
    /* MMAP_ZERO_FAILED	*/	"mmap %d bytes of /dev/zero failed: %s",
    /* RedundantOrdering*/	"Both 'ascending' and 'descending' may not be specified for a single key",
    /* KeySyntax	*/	"Syntax error in key description",
    /* KeyNumber	*/	"An integer value is expected after 'number:'",
    /* KeyNumberInvalid	*/	"Key numbers may range from 1 through 255",
    /* KeyNumberDuplicate*/	"This number has already been specified for another key",
    /* DerivedNeedsValue */	"A derived fields needs a value=constant specifier",
    /* DerivedFieldMissing */	"The field named in this derived specification is undefined",
    /* NonNumericDerived */	"This derived field cannot have a numeric value",
    /* NonStringDerived */	"This derived field cannot have a string value",
    /* DerivedValueUnsupported*/"The value of a derived field may be an integer or a character string",
    /* SummarizedFieldMissing */"A field named in this summarize specification is undefined",
    /* DataFieldMissing	*/	"The field named in this data specification in undefined",
    /* MemoryNeeded	*/	"An integer number of kilobytes of memory to use was expected here",
    /* IOSizeUnaligned	*/	"The i/o transfer size for \"%s\" must be a multiple of %d bytes",
    /* IOSizeTooLarge	*/	"The maximum i/o transfer size for \"%s\" is %d bytes",
    /* AioCountTooLarge */	"This system may support only up to %d simultaneous asynchronous i/o's",
    /* OutputAlreadySpec */	"This sort already has \"%s\" as its output file",
    /* CpuReqNeeded	*/	"An integer number of processors to use was expected here",
    /* CpuReqTooBig	*/	"This system has only %d processors; %d of these are available to you",
    /* CpuReqRestricted	*/	"This system has only %d processors available; %d of them may be used by you",
    /* FormatSpec	*/	"A record format specification needs either size:N or delimiter:C",
    /* BadMethod	*/	"Known sorting methods are 'record' and 'pointer'",
    /* parseBadHashSpec	*/	"Known sorting method qualifiers are 'hash' and 'nohash'",
    /* VariableNeedsKey	*/	"A variable length record needs an explicit key definition",
    /* BadCharacterSpec	*/	"Unrecognized escape sequence in character constant",
    /* CharacterTooLarge*/	"Oversized escape sequence in character constant",
    /* MissingQuote	*/	"Trailing single quote (') missing",
    /* FilenameMissing */	"A filename was expected here",
    /* FilesysNameMissing */	"A file or filesystem name was expected here",
    /* SummarizeDuplicates */	"A summarizing sort may not specify that duplicate keys are to be kept",
    /* NotStatement	*/	"This is not a statement name",
    /* ExtraInsideStatement */	"Extra characters were found inside the statement",
    /* ExtraAfterStatement */	"Extra characters were found after the end of the statement",
    /* PrehashingInapplicable */"Prehashing is useful only for sorts which summarize or delete duplicates",
    /* RecordSortsOnlyFixlen */	"Record sorts are supported only for fixed-length records",
    /* RecordSortTooLarge */	"Record sorts are limited to no more than %d byte records",
    /* RecordTooLong */		"The record at %d in \"%s\" is longer than the maximum of %d",
    /* RecordTooShort */	"The record at %d in \"%s\" is shorter than the minimum of %d",
    /* DerivedTooFar	*/	"The derived field \"%s\" would exceed the maximum record length of %d",
    /* PartialRecord	*/	"Data format error: a partial record was found at the end of \"%s\"",
    /* DelimMissing	*/	"Data format error: the record at %d in \"%s\" does not have a delimiter",
    /* RadixPrehashIncompat */	"Radix sort with prehashing is not supported",
    /* FieldBeyondEnd */	"The field \"%s\" extends beyond the end of the record",
    /* PastMemoryLimit	*/	"There are only %d Kbytes of swap space available",
    /* SpecOpen		*/	"Specification file \"%s\" could not be opened: %s",
    /* SpecTooDeep	*/	"Loop detected: specification file \"%s\" including \"%s\"",
    /* InputOpen	*/	"Input file \"%s\" could not be opened: %s",
    /* OutputOpen	*/	"Output file \"%s\" could not be opened for writing: %s",
    /* FilesysNotFound	*/	"File or filesystem \"%s\" could not be accessed: %s",
    /* TempfileStat	*/	"Temp file \"%s\" could not be opened: %s",
    /* TempfileBadType	*/	"Temp file \"%s\" is not a directory or plain file",
    /* TempfileOpen	*/	"Temp file \"%s\" could not be opened for writing: %s",
    /* InputTooLarge	*/	"Input size exceeds that allowed by available memory",
    /* PinFailed	*/	"Memory pinning failed at %d of %d kbytes: %s",
    /* HashWithoutRadix	*/	"Hashing is supported only in radix sorts",
    /* MemLimitTooSmall	*/	"This sort requires at least %dM of memory",
    /* INVALID_CONTEXT	*/	"The Nsort context %d is not valid",
    /* INVALID_ARGUMENT	*/	"A parameter to an Nsort api function is not valid",
    /* UNMAP_FAIL	*/	"Failure %s unmapping 0x%x:0x%x",
    /* MALLOC_FAIL	*/	"Malloc() failed to allocate necessary memory",
    /* APIFILES		*/	"An api sort may not specify input or output files",
    /* INTERNAL_NO_MEM	*/	"This internal sort requires more memory than is available",
    /* KeyBeyondEnd */		"The key \"%s\" extends beyond the end of the record",
    /* ERROR_IGNORED */		"This sort has died due to a previous fatal error",
    /* CANCELLED */		"This sort has been cancelled",
    /* CANT_SEEK */		"The file %s is not seekable and cannot be used for %s i/o",
    /* INTSIZE	*/		"Binary integers may have a size of 1, 2, 4, or 8 bytes",
    /* SUMMARY_NEEDS_INT*/	"A summary field must be a 4 or 8 byte integer",
    /* LastError	*/	"*** last error ***"
};

const char *WarningText[] =
{
	/* warnings, runtime_error() does NOT exit */
    /* CloseFailed	*/	"The file \"%s\" was not closed: %s",
    /* UnlinkFailed	*/	"The temp file \"%s\" could not be removed: %s",
};

/*
 * print_token_context	- show where a token is, in a line of parsed input
 *
 */
void print_token_context(sort_t *sort, token_t *token)
{
    const char	*s = token->line;
    const char	*tokpos = s + token->charno;
    int		i;

    fprintf(stderr, "%.*s\n", strcspn(token->line, "\n"), token->line);
    for (i = 0; s != tokpos; s++)
    {
	if (*s == '\t')
	{
	    fprintf(stderr, "%.*s", 8 - (i % 8), "--------");
	    i += i % 8;
	}
	else
	{
	    fputc('-', stderr);
	    i++;
	}
    }
    fputs("^\n", stderr);
}

/*
 * parser_error	- decode an error number into a string
 *		  if the error is at a particular token then
 *		  point to that token in the input line
 *
 */
void parser_error(sort_t *sort, token_t *token, parse_error_t err, ...)
{
    va_list	ap;
    const char	*format = (err < 0) ? ErrorText[-err]
				    : WarningText[err - 1];

    /*
     * This will/ought to be optimized out if the error message arrays
     * are is up-to-date.
     */
    if ((sizeof(ErrorText) / sizeof(ErrorText[0])) != -NSORT_LAST_ERROR + 2 ||
	(sizeof(WarningText) / sizeof(WarningText[0])) != NSORT_LAST_WARNING)
	die("Error/warning text out of date: %d %d; %d %d",
	    sizeof(ErrorText) / sizeof(ErrorText[0]), -NSORT_LAST_ERROR,
	    sizeof(WarningText) / sizeof(WarningText[0]), NSORT_LAST_WARNING);

    fprintf(stderr, "** sort definition error");
    if (PARSE.title != NULL && PARSE.lineno != 0)
	fprintf(stderr, " in \"%s\": line %d", PARSE.title, token->lineno);
    fputc('\n', stderr);
    print_token_context(sort, token);

    va_start(ap, err);
    vfprintf(stderr, format, ap);
    va_end(ap);

    fputc('\n', stderr);

    /*
     * Hack to allow multi-line error messages control over line spacing,
     * so they may include additional output on the same line as the msg text.
     * Used for the Ambiguous/Unexpected_Keyword message in keyword_lookup()
     */
    if (strchr(format, '\n') == NULL)
	fputs("\n\n", stderr);

    sort->last_error = err;
    sort->n_errors++;
}

/*
 * runtime_error	- decode an error number into a string
 *			  return to caller if 'err' is only a warning
 *			  exit if the 'err' is a real, fatal, error
 *
 */
nsort_msg_t runtime_error(sort_t *sort, parse_error_t err, ...)
{
    va_list	ap;
    char	emsg[120];
    const char	*format = (err < 0) ? ErrorText[-err]
				    : WarningText[err - 1];

    /*
     * This will/ought to be optimized out if the error message arrays
     * are up-to-date.
     */
    if ((sizeof(ErrorText) / sizeof(ErrorText[0])) != (-NSORT_LAST_ERROR + 2) ||
	(sizeof(WarningText) / sizeof(WarningText[0])) != NSORT_LAST_WARNING)
	die("Error/warning text out of date: %d %d; %d %d",
	    sizeof(ErrorText) / sizeof(ErrorText[0]), -NSORT_LAST_ERROR,
	    sizeof(WarningText) / sizeof(WarningText[0]), NSORT_LAST_WARNING);

    va_start(ap, err);
    vsprintf(emsg, format, ap);
    va_end(ap);

    if (Print_task)
	fprintf(stderr, "runtime_error: pid %d raises %s\n", getpid(), emsg);

    sort->last_error = err;
    sort->n_errors++;

    if (sort->api_invoked)
    {
	do_cancel(sort);
	if (sort->client_pid == getpid())
	{
	    sort->api_phase = API_ERROR;
	    longjmp(sort->api_fail, err);
	}
	else
	{
	    return (err);
	}
    }

    fprintf(stderr, "** %s\n", emsg);

    if (err < 0)
    {
#if defined(DEBUG2)
	fprintf(stderr, "Pid %d waiting for 1 minute...", getpid());
	sleep(60);
	fputc('\n', stderr);
#endif
	ordinal_exit();
    }
    return (err);
}
