/*
 ****************************************************************************
 *    Copyright © 1996 Ordinal Technology Corp.  All Rights Reserved.       *
 *                                                                          *
 *    DO NOT DISCLOSE THIS SOURCE CODE OUTSIDE OF SILICON GRAPHICS, INC.    *
 *  This source code contains unpublished proprietary information of        *
 *  Ordinal Technology Corp.  The copyright notice above is not evidence    *
 *  of any actual or intended publication of this information.              *
 *      This source code is licensed to Silicon Graphics, Inc. for          *
 *  its personal use in developing and maintaining products for the IRIX    *
 *  operating system.  This source code may not be disclosed to any third   *
 *  party outside of Silicon Graphics, Inc. without the prior written       *
 *  consent of Ordinal Technology Corp.                                     *
 ****************************************************************************
 *
 *
 * $Ordinal-Id: genlist.c,v 1.21 1996/10/22 00:12:39 charles Exp $
 */
#ident	"$Revision: 1.1 $"

#include	"otcsort.h"
#include	"merge.h"

typedef struct gen_instruct
{
    unsigned	n_recs;
    unsigned	repeat;
    unsigned	level;
    unsigned	width;
    unsigned	n_lines;
} gen_instruct_t;

gen_instruct_t *gen_merge_ins(sort_t *sort, int n_recs, gen_instruct_t *gen)
{
    struct gen_instruct	*gi;
    unsigned		n_lines;
    unsigned		lower_width;
    unsigned		max_level;
    unsigned		lines_gened;
    unsigned		multi_ll_items = sort->ll_items * MAX_GEN_N_LINES;

    n_lines = ROUND_UP_DIV(n_recs, multi_ll_items);
    gi = gen;

    ARENACHECK;
    if (n_lines == 1)
    {
	/* calculate size of first list, this is the only list where
	 * the number of records may not be a multiple of sort->ll_items.
	 */
	gi->width = GEN_WIDTH;  /* set to max value to avoid immediate merge */
	gi->repeat = 1;
	gi->level = 0;
	gi->n_recs = n_recs;
	gi->n_lines = ROUND_UP_DIV(gi->n_recs, sort->ll_items);
	gi++;
    }
    else
    {
	/* Find the maximum level for the merge.  I.e., at least two of the
	 * lines generated by gen_line() will go through this many levels 
	 * of merge.  Some of the other lines MAY go through one fewer level.
	 * When the loop is exited, lower_width will be the width of the next
	 * lower merge level.  This will always be a power of GEN_WIDTH.
	 */
	for (max_level = 1, lower_width = 1; 
	     n_lines > lower_width * GEN_WIDTH; 
	     max_level++, lower_width *= GEN_WIDTH)
	{
	    continue;
	}
    
	/* calculate size of first list. for non-RADIX sorts this is
	 * the only list where the number of records may not be
	 * the maximum number of records per n_lines.
	 */
	gi->width = GEN_WIDTH;  /* set to max value to avoid immediate merge */
	gi->repeat = 1;
	gi->level = max_level;
	gi->n_recs = (n_recs - 1) % multi_ll_items + 1;
	gi->n_lines = ROUND_UP_DIV(gi->n_recs, sort->ll_items);
	lines_gened = 1;
	gi++;
	
	/* Determine the number of other lists that will participate in the
	 * first merge.  This is the only merge that may not be of width 
	 * GEN_WIDTH.
	 *
	 * Note that each GEN_WIDTH merge reduces the number of remaining
	 * lists by (GEN_WIDTH - 1).  The number of merges at the maximum
	 * level is given by the ceiling (rounded up) of 
	 *		(n_lines - lower_width) / (GEN_WIDTH - 1)
	 *	
	 * The following table gives the size of the first merge which may
	 * be lower than GEN_WIDTH.
	 *
	 *	(n_lines - lower_width) % (GEN_WIDTH - 1)	1st Width
	 *	
	 *				0			GEN_WIDTH
	 *				1			    2
	 *				2			    3
	 *				.			    .
	 *				.			    .
	 *				.			    .
	 *			  GEN_WIDTH - 2		      GEN_WIDTH - 1
	 *
	 * This above table is expressed as a formula as follows:
	 *
	 **********************************************************************
	 * The following table gives the size of the first merge which may
	 * be lower than GEN_WIDTH, for the gen_n_lines version
	 *
	 *	((n_lines - lower_width) / MAX_GEN_N_LINES)	1st Width
	 *			% (GEN_WIDTH - 1)
	 *	
	 *				0			GEN_WIDTH
	 *				1			    2
	 *				2			    3
	 *				.			    .
	 *				.			    .
	 *				.			    .
	 *			  GEN_WIDTH - 2		      GEN_WIDTH - 1
	 */	
	gi->level = max_level;
	gi->width = ((n_lines - lower_width) + GEN_WIDTH - 2) %
		    (GEN_WIDTH - 1) + 2;
	gi->repeat = gi->width - 1;
	gi->n_recs = multi_ll_items;
	gi->n_lines = ROUND_UP_DIV(multi_ll_items, sort->ll_items);
	lines_gened += gi->repeat;
	gi++;

	/* Determine the number of lines that will also enter the merge at the
	 * maximum level (and will all participate in GEN_WIDTH size merges).  
	 */	
	if (n_lines - lines_gened > lower_width - 1)
	{
	    gi->width = GEN_WIDTH;
	    gi->repeat = GEN_WIDTH *
				((n_lines - lower_width - (lines_gened - 1)) /
				 (GEN_WIDTH - 1));
	    gi->level = max_level;
	    gi->n_recs = multi_ll_items;
	    gi->n_lines = ROUND_UP_DIV(multi_ll_items, sort->ll_items);

	    lines_gened += gi->repeat;
	    gi++;
	}
	
	/* determine the number of lines (if any) that will enter the merge
	 * at the next lower (toward the root) level.
	 */	
	if (n_lines > lines_gened)
	{
	    gi->width = GEN_WIDTH;
	    gi->repeat = (n_lines - lines_gened);
	    gi->level = max_level - 1;
	    gi->n_recs = multi_ll_items;
	    gi->n_lines = ROUND_UP_DIV(multi_ll_items, sort->ll_items);
	    gi++;
	}
    }
    gi->repeat = 0;
    return (gi);
}

/*
 * gen_list	- make items out of records and sort them into a linelist
 */
item_line_t *gen_list(sort_t		*sort,
		      part_t		*part,
		      item_line_t	**ll_sproc)
{
    unsigned		level;
    byte		*rec;
    item_line_t		*ll_free, *ltemp;
#if defined(DEBUG1)
    int			recs_genned = 0;
#endif
    unsigned		i, j;
    unsigned		repeat;
    item_line_t		*ll;
#if defined(tokPREHASH)
    item_t		*item;
    item_line_t		*ll_next;
    item_line_t		*hash_head;
    item_t		*hash_tail;
    item_t		**hash_table;
#endif
    item_line_t		*list;
    merge_level_t	mlevel[MAX_GEN_LEVEL];
    unsigned		n_recs;
    gen_instruct_t	gen_ins[5], *gi;
    struct
    {
	node_t		node[GEN_WIDTH];
	leaf_t		leaf[GEN_WIDTH];
    } node_buf;
    merge_args_t	args;

    ARENACHECK;

    part->sort_time = get_cpu_time();

    args.node_buf = (node_t *)&node_buf;
    args.recode.summarize = sort->n_summarized;
    args.recode.n_soft = 0;
    args.recode.n_hard = 0;

    /* get free line-list of this sproc.
     */
    ll_free = *ll_sproc;

#if defined(tokPREHASH)
    if (sort->hash_table_size)
    {
	hash_table = sort->hash_tables + (part->sproc_id - 1) * sort->hash_table_size;
	memset(hash_table, 0, sort->hash_table_size * sizeof(item_t **));
	hash_head = NULL;
	hash_tail = NULL;
	n_recs = 0;
	for (rec = part->rec_start; rec < part->rec_end; )
	{
	    switch (sort->method)
	    {
	      case SortMethRecord:
		if (rec >= (byte *) part->local_ll)
		{
		    /*
		    ** The rec pointer has advanced to the end of an aligned
		    ** sizeof(item_line_t) region of free space in the 'low'
		    ** part of the partition. Use this space for a linelist.
		    */
		    ll = part->local_ll - 1;
		    part->local_ll++;
		}
		else
		{
		    ll = part->refuge_next;
		    part->refuge_next--;
		    ASSERT(ll >= part->refuge_start);
		}
		rec = build_hash_rs(sort, rec, &ll->item[0], part, hash_table, &hash_tail);
		break;

	      case SortMethPointer:
		/*
		** Pointer sort: item linelists will all be in the refuge.
		** For variable length pointer sorts we might be able to reuse
		** one of the 'length' blocks, if all of its lengths have been
		** used.  For fixed length sorts length_ll is set to
		** (item_line_t *) 1, both to cause a trap on access and so that
		** the comparison below will not succeed.
		*/
		if (part->lengths != NULL && part->lengths <= (u2 *) part->length_ll)
		{
		    ll = part->length_ll;
		    part->length_ll--;
		    ASSERT(ll >= part->refuge_end);
		}
		else
		{
		    ll = part->refuge_next;
		    part->refuge_next--;
		}
		ASSERT(ll >= part->refuge_start);
		if (sort->record.flags & RECORD_FIXED) 
		    rec = build_hash(sort, rec, &ll->item[0], part, hash_table, &hash_tail);
		else
		    rec = build_hash_vs(sort, rec, &ll->item[0], part, hash_table, &hash_tail);
	    }
	    if (hash_head == NULL)
		hash_head = ll;
	    /*
	     * Presume that the line was entirely filled with items.
	     * After we break out of the loop we'll adjust n_recs down
	     * by the number of items which were not put into the last line.
	     */
	    n_recs += sort->ll_items;
	}

	n_recs -= sort->ll_items - ((ptrdiff_t) hash_tail - (ptrdiff_t) &ll->item[0]) / sort->item_size;
	if (sort->statistics->hash_details)
	{
	    part->hash_empty = 0;
	    part->hash_used = 0;
	    j = 0;
	    for (i = 0; i < sort->hash_table_size; i++)
	    {
		if ((item = hash_table[i]) == NULL)
		{
		    part->hash_empty++;
		    continue;
		}
		part->hash_used++;
		while (item != NULL)
		{
		    j++;
		    item = (item_t *) item->ovc;
		    ASSERT(j <= n_recs);
		}
	    }
	    if (part->hash_used != 0)
		part->hash_avg_length = (j * 1000) / part->hash_used;
	}

	j = get_cpu_time();
	part->hash_time = j - part->sort_time;
	part->sort_time = j;

	/* The last line hashed is the only possible short one.
	 * If it is short it has to be relinked to be at the head of the list;
	 * the only gen_instruct whose n_recs is less than sort->ll_items
	 * is the first one.
	 */
	if (n_recs % sort->ll_items)
	{
	    ITEM_NEXTLINE(hash_tail) = hash_head;
	    ll_next = (item_line_t *) ROUND_DOWN(hash_tail, LL_BYTES);
	}
	else
	{
	    ll_next = hash_head;
	}
	rec = (byte *) ll_next;

    }
    else
#endif
    {
	n_recs = part->n_recs;
	rec = part->rec_start;
    }

    gen_merge_ins(sort, n_recs, gen_ins);

    /* initialize the state of each level
     */	
    for (level = 0; level < MAX_GEN_LEVEL; level++)
	mlevel[level].n_lists = 0;

    for (repeat = 0, gi = gen_ins; ; repeat++)
    {
	/* if we have completed the last iteration of the current 
	 * gen instruction, go on to next gen instruction.
	 */
	if (repeat == gi->repeat)
	{
	    gi++;
	    if (gi->repeat == 0) /* if this is the last gen instruction */
		break;
	    repeat = 0;
	}

	/* allocate the linelist into which to build the nodes.
	 * This may be 'local' (in the record area) if record editing is
	 * involved and enough records have been editing such that there
	 * is an aligned linelist-sized piece of unused record space.
	 */
	list = NULL;
#if defined(tokPREHASH)
	if (sort->hash_table_size)
	{
	    list = ll = ll_next;
	    /*
	     * The first line may be short (if (n_recs % sort->ll_items) != 0)
	     * Every later one will be full, as will be gen_ins.n_recs
	     */
	    for (j = 0; j < gi->n_lines; j++)
	    {
		if (j == 0)
		    i = sort->item_size * ((gi->n_recs - 1) % sort->ll_items + 1);
		else
		    i = sort->ll_item_space;
		ASSERT(item_math(ll_next, i)->ovc == EOL_OVC);
		ll_next = LINE_NEXTLINE(ll_next, i);

		/* The first hashed item line usually is not full,
		 * yet gen_n_lines will fill it and expects the next-itemline
		 * pointer to be at the expected place after the last full item.
		 * Copy the next-itemline pointer to the end of the item space
		 * so that gen_n_lines()'s merge_???_line can find the rest of
		 * the list.  The remaining lines' next-itemline ptrs are right.
		 */
		if (j == 0)
		    LINE_NEXTLINE(list, sort->ll_item_space) = ll_next;
	    }
	}
	else
#endif
	for (j = 0; j < gi->n_lines || list == NULL; j++)
	{
	    if (sort->method == SortMethRecord)
	    {
		if (rec >= (byte *) part->local_ll)
		{
		    /*
		    ** The rec pointer has advanced to the end of an aligned
		    ** sizeof(item_line_t) region of free space in the 'low'
		    ** part of the partition. Use this space for a line.
		    */
		    ll = part->local_ll - 1;
		    part->local_ll++;
		}
		else
		{
		    ll = part->refuge_next;
		    part->refuge_next--;
		    ASSERT(ll >= part->refuge_start);
		}
	    }
	    else	/* SortMethPointer */
	    {
		/*
		** Pointer sort: item linelists will all be in the refuge.
		** For variable length pointer sorts we might be able to reuse
		** one of the 'length' blocks, if all of its lengths have been
		** used.  For fixed length sorts length_ll is set to
		** (item_line_t *) 1, both to cause a trap on access and so that
		** the comparison below will not succeed.
		*/
		if (part->lengths != NULL &&
		    part->lengths <= (u2 *) part->length_ll)
		{
		    ll = part->length_ll;
		    part->length_ll--;
		    ASSERT(ll >= part->refuge_end);
		}
		else
		{
		    ll = part->refuge_next;
		    part->refuge_next--;
		}
		ASSERT(ll >= part->refuge_start);
	    }
#if defined(INITIAL_FREELIST)
	    *((item_line_t **) ll) = list;
#else
	    LINE_NEXTLINE(ll, sort->ll_item_space) = list;
#endif
	    list = ll;
	}

	/* generate a small (1 to MAX_GEN_N_LINES)-line line-list.
	*/
	part->genline_time -= get_cpu_time();
	if (gi->n_lines == 1 && !IN.ptr_input)
	    rec = gen_line(sort, gi->n_recs, rec, ll, part, &args);
	else
	    rec = gen_n_lines(sort, gi->n_recs, rec, list, part, &args, gi->n_lines);
	part->genline_time += get_cpu_time();
#if defined(DEBUG1)
	recs_genned += gi->n_recs;
#endif

	/* add line to merge level structure and perform merge(s) is
	 * there are sufficient lists.
	 */
	level = gi->level;
	mlevel[level].list[mlevel[level].n_lists] = ll;

	while (++mlevel[level].n_lists == gi->width)
	{
	    /* merge the lists at this level into one list for the next level.
	     */
	    args.n_inputs = gi->width;
	    args.in_list = mlevel[level].list;

	    mlevel[level - 1].list[mlevel[level - 1].n_lists] =
		(*sort->merge_line)(sort, &args, &ll_free, NULL);
	    
	    /* put the last lines of each list on free list.
	     */
	    for (j = 0; j < gi->width; j++)
	    {
		ASSERT(mlevel[level].list == args.in_list);
		ltemp = (item_line_t *)	/* XXX LINE_START() */
		    ((unsigned long) mlevel[level].list[j] & ~LL_MASK);
#if defined(INITIAL_FREELIST)
		*((item_line_t **) ltemp) = ll_free;
#else
		LINE_NEXTLINE(ltemp, sort->ll_item_space) = ll_free;
#endif
		ll_free = ltemp;
	    }

	    mlevel[level].n_lists = 0; /* reset count for this level */
	    level--;
	}
    }

#if defined(tokPREHASH)
    if (sort->hash_table_size)
	if (n_recs % sort->ll_items)
	    ASSERT(ll_next == (item_line_t *) ROUND_DOWN(hash_tail, LL_BYTES));
	else
	    ASSERT(ll_next == NULL || (ll_next == (item_line_t *) hash_tail && hash_tail->ovc == EOL_OVC && ITEM_NEXTLINE(hash_tail) == NULL));
#endif

    *ll_sproc = ll_free;

    part->sort_time = get_cpu_time() - part->sort_time;

    /*
     * Add this sproc's recode counts to the sums in the sort struct
     */
    {
	mpcount_t recodes;
	for (;;)
	{
	    recodes = TIMES.hard_recodes;

	    if (uscas(&TIMES.hard_recodes,
		      recodes,
		      recodes + args.recode.n_hard,
		      SYS.ua))
		break;
	}

	for (;;)
	{
	    recodes = TIMES.soft_recodes;

	    if (uscas(&TIMES.soft_recodes,
		      recodes,
		      recodes + args.recode.n_soft,
		      SYS.ua))
		break;
	}
    }

    ARENACHECK;

#if defined(DEBUG1)
    i = check_ll(sort, &mlevel[0].list[0]->item[0]);
    if (i != recs_genned && !sort->any_deletes)
	die("gen_list:%d records missing", recs_genned - i);
#endif

    return (mlevel[0].list[0]);
}

/*
 * last_resort	- sort a bucket of radix items, appending them to an ovc ll
 *
 */
item_t *radix_append_fixup(sort_t *sort,
			   recode_args_t *args,
			   item_t *tail_item,
			   item_t *start_sorted);
item_t *radix_append_fixup_rs(sort_t *sort,
			      recode_args_t *args,
			      item_t *tail_item,
			      item_t *start_sorted);

item_line_t *last_resort(sort_t		*sort,
			 bucket_t	*input,
			 list_desc_t	*output)
{
    unsigned		multi_ll_items = sort->ll_items * MAX_GEN_N_LINES;
    unsigned		level;
    item_line_t		*ltemp;
    item_line_t		*head;
    item_t		*item;
    item_t		*prev_tail = NULL;
    unsigned		final_merge;
#if defined(DEBUG1)
    int			recs_genned = 0;
#endif
    unsigned		i;
    unsigned		repeat;
    rad_line_t		*ll;
    typedef struct radix_merge_level
    {
	unsigned		n_lists;
	item_line_t		*list[GEN_WIDTH + 1];
    } radix_merge_level_t;
    radix_merge_level_t	mlevel[MAX_GEN_LEVEL];
    unsigned		n_recs;
    struct gen_instruct gen_ins[6], *gi;
    /* This node_buf is larger than normal because of sort_n_lines()/prev_tail
     */
    struct
    {
	node_t		node[GEN_WIDTH + 1];	/* (+ 1) is maybe not needed */
	leaf_t		leaf[GEN_WIDTH + 1];	/* (+ 1) is maybe not needed */
    } node_buf;
    merge_args_t	args;

    ARENACHECK;

    args.node_buf = (node_t *)&node_buf;
    args.recode.summarize = sort->n_summarized;
    args.recode.n_soft = 0;
    args.recode.n_hard = 0;

    /*
     * Bizarre/Interesting hack to handle deletes and ovc correction in radix
     * sorts. If this sort_n_lines() call is to be the last for this
     * last_resort() invocation, and there are some records which have
     * already been appended to the output list, then the caller will pass in
     * a non-null prev_tail (== next_item - 1). Here we'll "remove" next_item
     * from the existing output list by backing up one item size.
     *
     * The merge_args' node_buf must be slightly larger than normal (GEN_WIDTH)
     * to allow for this extra tree node.
     *
     * XXX Verify that memory reservation isn't exceeded -- ASSERTS somewhere
     */
    if (output->next_item != (byte *) &output->tail->item[0])
	prev_tail = (item_t *) output->next_item;

    /* Count the number of records in the input radix bucket.
     * All lines before the last are full; the last might be too.
     */
    n_recs = sort->ll_items * (input->line_count - 1) +
	   (unsigned) (input->next_item - FIRST_RADIX_ITEM(input->tail)) /
		 sort->item_size;

    if (n_recs <= multi_ll_items)
    {
	sort_n_lines(sort, n_recs, input->head, &output->free,
			   &args, &mlevel[0].list[0], output, NULL);
	goto cleanup;
    }

    gi = gen_merge_ins(sort, ROUND_UP_COUNT(n_recs, multi_ll_items), gen_ins);
    if (n_recs % multi_ll_items)
    {
	/* We've generated the merge instructions without a 'short' sort at
	 * the beginning.  Now we'll adjust it to match reality.
	 *  If the final merge instruction does more than 1 sort_n_lines() call,
	 * then we appened a duplicate of that instruction and reduce the
	 * repeat count by one.  The new duplicate will be for the 'short' sort.
	 *  Otherwise (if the final merge has a repeat count of 1) we'll just
	 * replace it with the short sort.
	 */
	if (gi[-1].repeat != 1)
	{
	    gi[-1].repeat--;
	    gi[0].level = gi[-1].level;
	    gi[0].width = gi[-1].width;		/* XXX what's correct here? */
	    gi[0].repeat = 1;
	    gi++;
	}

	ASSERT(gi[-1].repeat == 1);
	gi[-1].n_recs = n_recs % multi_ll_items;
	gi[-1].n_lines = ROUND_UP_DIV(gi[-1].n_recs, sort->ll_items);
	gi[0].repeat = 0;
    }
    ASSERT((byte *) &gi->n_lines < (byte *) gen_ins + sizeof(gen_ins));

#if defined(DEBUG2)
    if (Print_task)
    {
	fprintf(stderr, "n_recs repeat  level  width (n_recs: %d)\n", n_recs);
	for (gi = gen_ins, i = 0; gi->repeat; i += gi->n_recs*gi->repeat, gi++)
	    fprintf(stderr, "%6d %6d %6d %6d\n", gi->n_recs, gi->repeat,
						 gi->level, gi->width);
	if (i != n_recs)
	    die("last_resort: missing/extra recs: n_recs %d, instructs for %d",
		n_recs, i);

    }
#endif

    /* initialize the state of each level
     */	
    for (level = 0; level < MAX_GEN_LEVEL; level++)
	mlevel[level].n_lists = 0;

    for (ll = input->head, repeat = 0, gi = gen_ins; ; repeat++)
    {
	/* if we have completed the last iteration of the current 
	 * gen instruction, go on to next gen instruction.
	 */
	if (repeat == gi->repeat)
	{
	    gi++;
	    if (gi->repeat == 0) /* if this is the last gen instruction */
		break;
	    repeat = 0;
	}

	/* generate a small (1 to MAX_GEN_N_LINES)-line line-list.
	 */
	ll = sort_n_lines(sort, gi->n_recs, ll, &output->free, &args, &head,
				NULL, NULL);
#if defined(DEBUG1)
	recs_genned += gi->n_recs;
#endif

	/* add line to merge level structure and perform merge(s) is
	 * there are sufficient lists.
	 */
	level = gi->level;
	mlevel[level].list[mlevel[level].n_lists] = head;

	while (++mlevel[level].n_lists == gi->width)
	{
	    /* merge the lists at this level into one list for the next level.
	     */
	    args.n_inputs = gi->width;
	    args.in_list = mlevel[level].list;
	    final_merge = (level == 1) && (mlevel[0].n_lists == 0);
#if 0
	    if (final_merge && prev_tail)
	    {
		memmove(&mlevel[1].list[1], &mlevel[1].list[0], args.n_inputs * sizeof(item_line_t *));
		mlevel[1].list[0] = (item_line_t *) prev_tail;
		args.n_inputs++;
	    }
#endif

	    mlevel[level - 1].list[mlevel[level - 1].n_lists] =
		(*sort->merge_line)(sort, &args, &output->free,
						 final_merge ? output : NULL);
	    
	    /* put the last lines of each list on free list.
	     */
	    for (i = 0; i < gi->width; i++)
	    {
		ltemp = (item_line_t *)	/* LINE_START() */
			((unsigned long) mlevel[level].list[i] & ~LL_MASK);
#if defined(DEBUG2)
		if (Print_task)
		    fprintf(stderr,
			    "last_resort: returning tail %x to free list (free head was %x)\n",
			    ltemp, output->free);
#endif
#if defined(INITIAL_FREELIST)
		*((item_line_t **) ltemp) = output->free;
#else
		LINE_NEXTLINE(ltemp, sort->ll_item_space) = output->free;

#endif
		output->free = ltemp;
	    }

	    mlevel[level].n_lists = 0; /* now this level has no unmerged lists*/
	    level--;
	}
    }

cleanup:
    if (prev_tail)
	((sort->method == SortMethPointer) ? radix_append_fixup
					   : radix_append_fixup_rs)
		(sort, &args.recode, prev_tail, 
				     (prev_tail->ovc == NULL_OVC)
				      ? ITEM_NEXTLINE(prev_tail)->item
				      : prev_tail);


    /*
     * Add this sproc's recode counts to the sums in the sort struct
     */
    {
	mpcount_t recodes;
	for (;;)
	{
	    recodes = TIMES.hard_recodes;

	    if (uscas(&TIMES.hard_recodes,
		      recodes,
		      recodes + args.recode.n_hard,
		      SYS.ua))
		break;
	}

	for (;;)
	{
	    recodes = TIMES.soft_recodes;

	    if (uscas(&TIMES.soft_recodes,
		      recodes,
		      recodes + args.recode.n_soft,
		      SYS.ua))
		break;
	}
    }

    ARENACHECK;

#if defined(DEBUG1)
    check_ll(sort, &mlevel[0].list[0]->item[0]);
#endif

    return (mlevel[0].list[0]);
}
