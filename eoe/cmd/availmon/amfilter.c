/********************************************************************/
/*                                                                  */
/* Program :   amfilter                                             */
/* Purpose :   A filter used in /etc/syslog.conf to identify tags   */
/*             in messages generated by kernel or other facilities  */
/*             and notify them via amdiag.  This filter looks for   */
/*             CONFIG-ISSUE, SYS-DEGRADED, TOOK-ACTION, MAINT-NEEDED*/
/*             tags and notifies them to configured users.          */
/* Inputs  :   Message passed by syslogd via stdin                  */
/* Outputs :   Message passed to syslogd via stdout                 */
/*                                                                  */
/* ---------------------------------------------------------------- */
/* Please log any changes to this file below.                       */
/*                                                                  */
/* Modified Date     Modified Purpose     By     Comments/function  */
/* -------------     ----------------     --     -----------------  */
/* 10/9/97           Creation of file     sri    -                  */
/* 10/10/97          Added some checks    sri    error_exit         */
/*                                                                  */
/********************************************************************/

#include <stdio.h>
#include <string.h>
#include <time.h>
#include "defs.h"


/*                                                                  */
/* error routine                                                    */
/*                                                                  */

void errorexit(char *s, char *msg)
{
    if (msg)
        fprintf(stderr, "%s:%s\n", s, msg);
    else
        perror(s);

    exit(-1);
}

/*                                                                  */
/* main  entry point                                                */
/*                                                                  */

int main (int argc, char *argv)
{
    register int len;
    char         buf[MAXINPUTLINE];
    char         tmpdata[MAX_LINE_LEN] = "\0";
    int		 flag[MAX_TAGS];
    char         *tmpstring;
    char	 *tmpstring1;
    FILE	 *fp;
    time_t	 now = 0;
    int          i = 0;
    int          notifytags = 0;

    now = time(0);

    for ( i = 0; i < MAX_TAGS; i++ )
	flag[i] = 0;

    len = read(fileno(stdin), buf, MAXINPUTLINE-1);

    if ( len < 0 )
	errorexit("amfilter", "Input error.  No input received");

    buf[len] = '\0';

    /*                                                              */
    /*  The logic works like this :                                 */
    /*                                                              */
    /*  A syslog message can contain 1 or more tags delimited by a  */
    /*  : and enclosed in ().  We search for the first occurance of */
    /*  ( and from that point till we get a ), we take the string   */
    /*  In the obtained string, we again search for : and break     */
    /*  them TAG wise.                                              */
    /*                                                              */
    /*  I made use of strtok calls.  Since strtok modifies the      */
    /*  original string, we need to copy the string to a temporary  */
    /*  pointer for which I used strdup                             */
    /*                                                              */


    tmpstring = strdup(buf);

    if ( tmpstring == NULL )
        goto out;

    if ( *tmpstring == '(' ) {
	tmpstring1 = strtok(++tmpstring, ")");
	strcpy(tmpdata, tmpstring1);
    }
    else {
        strtok(tmpstring, "()");
        if ((tmpstring1 = strtok(NULL, "()")) != NULL) {
	    strcpy(tmpdata, tmpstring1);
        }
    } /* end if-else */

    tmpstring = strtok(tmpdata, ":");

    /*                                                              */
    /*  This is the second pass when we already got the required    */
    /*  list of tags.  We now search for : in the string.  I again  */
    /*  made use of strtok so that it will return me token by token */
    /*  which I compare with the original tags and if any of them   */
    /*  are found, I make the respective flag equal to 1.           */
    /*                                                              */ 

    while ( tmpstring != NULL ) {
        for ( i = 0; i < MAX_TAGS; i++ ) {
	    if ( strcmp(tmpstring, (char *) tags[i].tagname) == 0 ) {
	       flag[i] = 1;
	       notifytags++;
	       break;
	    } 
	} /* end for */
	tmpstring = strtok(NULL, ":");
    } /* end while */

    /*                                                              */
    /*  Free the pointer given to us by strdup                      */
    /*                                                              */

    free(tmpstring);

    /*                                                              */ 
    /*  If notifytags is greater than 0, then we found some tags    */
    /*  Prepare the summary file and invoke amdiag.                 */
    /*                                                              */

    if ( notifytags > 0 ) {
        tmpstring = tempnam(NULL, "am");
	if ( (fp = fopen(tmpstring, "w+")) != NULL) {
	    fprintf(fp, "TIME %d %s", now, ctime(&now));
	    fprintf(fp, "%s\n", buf);
            fprintf(fp, "\n");
	    for ( i = 0; i < MAX_TAGS; i++ ) {
		if (flag[i]) {
		    fprintf(fp,"\t%s: %s\n", tags[i].tagname, 
                                             tags[i].tagdescr); 
                }
	    }
	    fclose(fp);
	    sprintf(tmpdata, "/var/adm/avail/amdiag SYSLOG %s &", tmpstring);
	    system(tmpdata);
	}

        /*                                                          */ 
        /* free the pointer given to us by tempnam                  */
        /*                                                          */ 

        if (tmpstring != NULL)
	    free(tmpstring);
    }


    /*                                                              */
    /* print the message to stdout, flush stdout and exit           */
    /*                                                              */

out:
    printf("%s", buf);
    fflush(stdout);
    exit(0);

} /* end main */
