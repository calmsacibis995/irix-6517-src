/*
 * Routines to implement rtmond RPC protocol(s).  These routines are called
 * out of the RPC protocol decode routines generated by rpcgen.  The
 * RPC main(), the protocol decode routines, and the XDR routines are in
 * librtmon.  The main() routine's name is automatically edited by the
 * librtmon Makefile to be rtmond_rpc_main().  rtmond_rpc_main() is called
 * by rtmond's main() after it has initialized its state.
 */

#include <stddef.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/rtmon.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <rpc/rpc.h>
#define _RPCGEN_SVC
#include <rpcsvc/rtmond.h>

#include "rtmond.h"

static void
unimplemented(const char* op)
{
    Log(LOG_WARNING, NULL, "unimplemented RPC request: %s", op);
}

/*
 * Routines to implement the WindView rtmond RPC protocol.  These are now
 * only used by WindView.
 */
u_int *
wvproc_symtab_lookup_1(char **argp, struct svc_req *rqstp)
{
    static u_int res = RPC_PROCUNAVAIL;
    (void) argp;
    unimplemented("wvproc_symtab_lookup_1");
    svcerr_noproc(rqstp->rq_xprt);
    return &res;
}

u_int *
wvproc_task_spawn_1(taskSpawnRec *argp, struct svc_req *rqstp)
{
    static u_int res = RPC_PROCUNAVAIL;
    (void) argp;
    unimplemented("wvproc_task_spawn_1");
    svcerr_noproc(rqstp->rq_xprt);
    return &res;
}

u_int *
wvproc_call_function_1(callFuncRec *argp, struct svc_req *rqstp)
{
    static u_int res = RPC_PROCUNAVAIL;
    (void) argp;
    unimplemented("wvproc_call_function_1");
    svcerr_noproc(rqstp->rq_xprt);
    return &res;
}

/*
 * Request CPU event logging control: If ``state'' <= 0, then we're
 * requesting that an already existing data connection be suspended.  If
 * ``state'' > 0, then we're requesting a new data connection or that an
 * already existing and suspended connection be resumed.  For new data
 * connections no event filtering specification is supported, so we set
 * up to send all events.  Also, no protocol specification is supported,
 * so we give them the original flavor ...
 */
u_int *
wvproc_evt_log_control_1(evtLogRec *argp, struct svc_req *rqstp)
{
    static u_int res;
    char hostname[128];
    extern uint64_t windview_mask;

    strcpy(hostname, inet_ntoa(svc_getcaller(rqstp->rq_xprt)->sin_addr));
    IFTRACE(RPC)(NULL, "WV RPC: state %d, mode %d, port %d, hostname %s",
	argp->state, argp->mode, argp->portNo, hostname);
    if (argp->state > 0)
	res = add_processor_to_fd_list(argp->mode,
	    windview_mask,
	    RTMON_PROTOCOL1, hostname, argp->portNo);
    else
	res = pause_client(argp->mode, hostname, argp->portNo);
    return &res;
}


/*
 * Routines to implement new rtmond RPC protocol.  These are used by
 * everything else.
 */

u_int *
rtmond_get_ncpu_2(void *argp, struct svc_req *rqstp)
{
    static u_int ncpu;
    (void) argp; (void) rqstp;
    ncpu = (u_int) getncpu();
    IFTRACE(RPC)(NULL, "RPC get_ncpu: return %d", ncpu);
    return &ncpu;
}

/*
 * Request CPU event data stream connection (old style).
 */
u_int *
rtmond_get_connection_2(rtmond_get_connection_args *argp,
			struct svc_req *rqstp)
{
    static u_int res;
    char hostname[128];

    strcpy(hostname, inet_ntoa(svc_getcaller(rqstp->rq_xprt)->sin_addr));
    IFTRACE(RPC)(NULL,
	"RPC get_connection: cpu %d mask %x protocol %d host %s port %d",
	argp->cpu, argp->mask, argp->protocol, hostname, argp->port);
    res = add_processor_to_fd_list(argp->cpu, argp->mask,
	       argp->protocol, hostname, argp->port);
    return &res;
}

/*
 * Request CPU event data stream connection (new style).
 */
u_int *
rtmond_get_connection2_2(rtmond_get_connection2_args *argp,
			struct svc_req *rqstp)
{
    static u_int res;
    char hostname[128];

    strcpy(hostname, inet_ntoa(svc_getcaller(rqstp->rq_xprt)->sin_addr));
    IFTRACE(RPC)(NULL,
	"RPC get_connection2:"
	    " cpu-mask [%#llx %#llx]"
	    " event-mask %#llx"
	    " protocol %d"
	    " host %s"
	    " port %d"
	    " cookie %#llx"
	, argp->cpus[0], argp->cpus[1]
	, argp->mask
	, argp->protocol
	, hostname
	, argp->port
	, argp->cookie
    );
    res = add_client(hostname, argp->port, argp->protocol, argp->cookie,
	8*sizeof (argp->cpus), argp->cpus, argp->mask);
    return &res;
}

u_int *
rtmond_suspend_connection_2(rtmond_suspend_resume_args *argp,
			    struct svc_req *rqstp)
{
    static u_int res = RPC_PROCUNAVAIL;
    (void) argp;
    unimplemented("rtmond_suspend_connection_2");
    svcerr_noproc(rqstp->rq_xprt);
    return &res;
}

u_int *
rtmond_resume_connection_2(rtmond_suspend_resume_args *argp,
			   struct svc_req *rqstp)
{
    static u_int res = RPC_PROCUNAVAIL;
    (void) argp;
    unimplemented("rtmond_resume_connection_2");
    svcerr_noproc(rqstp->rq_xprt);
    return &res;
}
