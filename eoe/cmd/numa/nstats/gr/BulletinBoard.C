
/////////////////////////////////////////////////////////////
//
// source file for BulletinBoard
//
//    This file is generated by RapidApp 1.2
//
//    This class is derived from BulletinBoardUI which 
//    implements the user interface created in 
//    RapidApp. This class contains virtual
//    functions that are called from the user interface.
//
//    When you modify this source, limit your changes to 
//    modifying the sections between the
//    "//---- Start/End editable code block" markers
//
//    This will allow RapidApp to integrate changes more easily
//
//    This class is a ViewKit user interface "component".
//    For more information on how components are used, see the
//    "ViewKit Programmers' Manual", and the RapidApp
//    User's Guide.
/////////////////////////////////////////////////////////////

#include "BulletinBoard.h"
#include <Vk/VkEZ.h>
#include <Xm/BulletinB.h> 
#include <Xm/LabelG.h> 
#include <Xm/List.h> 
#include <Xm/ScrolledW.h> 
#include <Vk/VkResource.h>


// Externally defined classes referenced by this class:

#include <Vk/VkTickMarks.h>
#include <Vk/VkVuMeter.h>
#include <Vk/VkWindow.h>
#include <Vk/VkMenuBar.h>
#include <Vk/VkSubMenu.h>


extern void VkUnimplemented ( Widget, const char * );

///////////////////////////////////////////////////////////////////////////////
// The following non-container elements are created by BulletinBoardUI and are
// available as protected data members inherited by this class
//
//  XmLabelGadget		    _lNode
//  XmLabelGadget		    _lChange
//  XmLabelGadget		    _lMP
//  XmLabelGadget		    _lFP
//  XmLabelGadget		    _lCMS
//  XmLabelGadget		    _lCMF
//  XmLabelGadget		    _lCMT
//  XmLabelGadget		    _lUMS
//  XmLabelGadget		    _lUMF
//  XmLabelGadget		    _lUMT
//  XmLabelGadget		    _lAMS
//  XmLabelGadget		    _lAMF
//  XmLabelGadget		    _lAMT
//  XmLabelGadget		    _lCI
//  XmLabelGadget		    _valMP
//  XmLabelGadget		    _valFP
//  XmLabelGadget		    _valCMS
//  XmLabelGadget		    _valCMF
//  XmLabelGadget		    _valCMT
//  XmLabelGadget		    _valUMS
//  XmLabelGadget		    _valUMF
//  XmLabelGadget		    _valUMT
//  XmLabelGadget		    _valAMS
//  XmLabelGadget		    _label12
//  XmLabelGadget		    _label11
//  XmLabelGadget		    _label10
//  XmLabelGadget		    _label9
//  XmLabelGadget		    _label8
//  XmLabelGadget		    _label7
//  XmLabelGadget		    _label6
//  XmLabelGadget		    _label5
//  XmLabelGadget		    _label4
//  XmLabelGadget		    _valAMF
//  XmLabelGadget		    _valAMT
//  XmLabelGadget		    _valCI
//  XmLabelGadget		    _valMT
//  XmLabelGadget		    _label3
//  XmLabelGadget		    _label2
//  XmLabelGadget		    _label1
//  XmLabelGadget		    _label
//  XmList		    _scrolledList
//
// The following components are created by BulletinBoardUI and are
// available as protected data members inherited by this class
//
//  VkVuMeter		   *_meterMP
//  VkVuMeter		   *_meterFP
//  VkVuMeter		   *_meterCMS
//  VkVuMeter		   *_meterCMF
//  VkVuMeter		   *_meterCMT
//  VkVuMeter		   *_meterUMS
//  VkVuMeter		   *_meterUMF
//  VkVuMeter		   *_meterUMT
//  VkVuMeter		   *_meterAMS
//  VkVuMeter		   *_meterAMF
//  VkVuMeter		   *_meterAMT
//  VkVuMeter		   *_meterCI
//  VkTickMarks		   *_tickmarks
//
///////////////////////////////////////////////////////////////////////////////


//---- Start editable code block: headers and declarations
#include <assert.h>
#include <iostream.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/numa_stats.h>
#include <sys/syssgi.h>
#include <strings.h>
#include <sys/pmo.h>
#include <sys/time.h>
#include <signal.h>
#include <Vk/VkFormat.h>
#include <Xm/ToggleBG.h>

extern BulletinBoard *gBulletinBoard;

void timerHandler(int _signal);
//---- End editable code block: headers and declarations



//---- BulletinBoard Constructor

BulletinBoard::BulletinBoard(const char *name, Widget parent) : 
                   BulletinBoardUI(name, parent) 
{ 
    // This constructor calls BulletinBoardUI(parent, name)
    // which calls BulletinBoardUI::create() to create
    // the widgets for this component. Any code added here
    // is called after the component's interface has been built

    //---- Start editable code block: BulletinBoard constructor

    // Get number of nodes
    if (syssgi(SGI_NUMA_TESTS, NUMNODES_GET, -1, &numNodes) < 0) {
      perror("SGI_NUMA_TESTS, NUMNODES_GET");
      exit(1);
    }
    
    numa_stats_old = new numa_stats_t[numNodes];
    nodeNames = new XmString[numNodes];
    getNodeNames();
    XtVaSetValues ( _scrolledList, XmNitems, nodeNames,
                    XmNitemCount, numNodes, NULL );

    // Initialize old_numa_stats array to the current values
    for(int i = 0; i < numNodes; i++) {
      assert(XmStringGetLtoR(nodeNames[i], XmFONTLIST_DEFAULT_TAG, &currentNode));
      if (syssgi(SGI_NUMA_STATS_GET, currentNode, &numa_stats_old[i]) < 0) {
	perror("syssgi SGI_NUMA_STATS_GET");
	exit(1);
      }
    }
    
    currentEntry = 0;
    for(i = 0; i < HIST_LEN; i++) {
      numa_stats_hist[i] = new numa_stats_t[numNodes];
      bzero(numa_stats_hist[i], sizeof(numa_stats_t) * numNodes);
    }
    currentNode = NULL;

    struct itimerval iTimerVal;
    iTimerVal.it_interval.tv_sec = 1;
    iTimerVal.it_interval.tv_usec = 0;
    iTimerVal.it_value.tv_sec = 1;
    iTimerVal.it_value.tv_usec = 0;
    signal(SIGALRM, timerHandler);
    setitimer(ITIMER_REAL, &iTimerVal, NULL);

    scaleVal = 100;
    totalFlag = 0;
    //    _tickmarks->setScale(0, 100, 50, 10);

    //---- End editable code block: BulletinBoard constructor



}    // End Constructor



BulletinBoard::BulletinBoard(const char *name) : 
                   BulletinBoardUI(name) 
 { 
    // This constructor calls BulletinBoardUI(name)
    // which does not create any widgets. Usually, this
    // constructor is not used

    //---- Start editable code block: BulletinBoard constructor 2


    //---- End editable code block: BulletinBoard constructor 2



}    // End Constructor



BulletinBoard::~BulletinBoard()
{
    // The base class destructors are responsible for
    // destroying all widgets and objects used in this component.
    // Only additional items created directly in this class
    // need to be freed here.

    //---- Start editable code block: BulletinBoard destructor
    for(int i = 0; i < HIST_LEN; i++)
      delete numa_stats_hist[i];

    //---- End editable code block: BulletinBoard destructor



}    // End Destructor


const char * BulletinBoard::className() // classname
{
    return ("BulletinBoard");
} // End className()


void BulletinBoard::nodeSelect ( Widget w, XtPointer callData )
{
    //---- Start editable code block: BulletinBoard nodeSelect

    XmListCallbackStruct *cbs = (XmListCallbackStruct*) callData;

    //    cout << "Called nodeSelect" << endl;
    //    _scrolledList.XmNitems = { "Bob", "Lyle", "Joe" };
    
    assert(XmStringGetLtoR(cbs->item, XmFONTLIST_DEFAULT_TAG, &currentNode));
    //    cout << cbs->item_position << endl;
    currentNodeNum = cbs->item_position - 1;

    Update(1);

    //---- End editable code block: BulletinBoard nodeSelect

}    // End BulletinBoard::nodeSelect()


void BulletinBoard::setDiff10( Widget w, XtPointer callData )
{


    //---- Start editable code block: BulletinBoard setDiff10
    if(XmToggleButtonGadgetGetState(w)) {
      scaleVal = 100;
      _tickmarks->setScale(0, 10, 5, 1);
    }

    //---- End editable code block: BulletinBoard setDiff10

}    // End BulletinBoard::setDiff10()


void BulletinBoard::setDiff100( Widget w, XtPointer callData )
{


    //---- Start editable code block: BulletinBoard setDiff100
    if(XmToggleButtonGadgetGetState(w)) {
      scaleVal = 10;
      _tickmarks->setScale(0, 100, 50, 10);
    }

    //---- End editable code block: BulletinBoard setDiff100

}    // End BulletinBoard::setDiff100()


void BulletinBoard::setDiff1000( Widget w, XtPointer callData )
{


    //---- Start editable code block: BulletinBoard setDiff1000
    if(XmToggleButtonGadgetGetState(w)) {
      scaleVal = 1;
      _tickmarks->setScale(0, 1000, 500, 100);
    }

    //---- End editable code block: BulletinBoard setDiff1000

}    // End BulletinBoard::setDiff1000()


void BulletinBoard::setInterval10( Widget w, XtPointer callData )
{


    //---- Start editable code block: BulletinBoard setInterval10

    if(XmToggleButtonGadgetGetState(w)) {
      struct itimerval iTimerVal;
      iTimerVal.it_interval.tv_sec = 0;
      iTimerVal.it_interval.tv_usec = 10000;
      iTimerVal.it_value.tv_sec = 0;
      iTimerVal.it_value.tv_usec = 10000;
      signal(SIGALRM, timerHandler);
      setitimer(ITIMER_REAL, &iTimerVal, NULL);
    }

    //---- End editable code block: BulletinBoard setInterval10

}    // End BulletinBoard::setInterval10()


void BulletinBoard::setInterval100( Widget w, XtPointer callData )
{


    //---- Start editable code block: BulletinBoard setInterval100

    if(XmToggleButtonGadgetGetState(w)) {
      struct itimerval iTimerVal;
      iTimerVal.it_interval.tv_sec = 0;
      iTimerVal.it_interval.tv_usec = 100000;
      iTimerVal.it_value.tv_sec = 0;
      iTimerVal.it_value.tv_usec = 100000;
      signal(SIGALRM, timerHandler);
      setitimer(ITIMER_REAL, &iTimerVal, NULL);
    }

    //---- End editable code block: BulletinBoard setInterval100

}    // End BulletinBoard::setInterval100()


void BulletinBoard::setInterval1000( Widget w, XtPointer callData )
{


    //---- Start editable code block: BulletinBoard setInterval1000

    if(XmToggleButtonGadgetGetState(w)) {
      struct itimerval iTimerVal;
      iTimerVal.it_interval.tv_sec = 1;
      iTimerVal.it_interval.tv_usec = 0;
      iTimerVal.it_value.tv_sec = 1;
      iTimerVal.it_value.tv_usec = 0;
      signal(SIGALRM, timerHandler);
      setitimer(ITIMER_REAL, &iTimerVal, NULL);
    }


    //---- End editable code block: BulletinBoard setInterval1000

}    // End BulletinBoard::setInterval1000()


void BulletinBoard::setTotal( Widget w, XtPointer callData )
{


    //---- Start editable code block: BulletinBoard setTotal
    if(XmToggleButtonGadgetGetState(w))
      totalFlag = 1;
    else
      totalFlag = 0;

    //---- End editable code block: BulletinBoard setTotal

}    // End BulletinBoard::setTotal()





///////////////////////////////////////////////////////////////////
// static creation function, for importing class into rapidapp
// or dynamically loading, using VkComponent::loadComponent
///////////////////////////////////////////////////////////////////


VkComponent *BulletinBoard::CreateBulletinBoard( const char *name, Widget parent ) 
{  
    VkComponent *obj =  new BulletinBoard ( name, parent );
    return ( obj );
} // End CreateBulletinBoard


///////////////////////////////////////////////////////////////////
// Function for accessing a description of the dynamic interface
// to this class.
///////////////////////////////////////////////////////////////////


// WARNING: This structure is different than that used with 1.1 RapidApp.
// See the RapidApp release notes for details

struct InterfaceMap {
  char  *resourceName;
  char  *methodName;
  char  *argType;
  char  *definingClass; // Optional, if not this class
  void (VkCallbackObject::*method)(...); // Reserved, do not set
};


void *BulletinBoard::RegisterBulletinBoardInterface()
{ 
    // This structure registers information about this class
    // that allows RapidApp to create and manipulate an instance.
    // Each entry provides a resource name that will appear in the
    // resource manager palette when an instance of this class is
    // selected, the name of the member function as a string,
    // the type of the single argument to this function, and an.
    // optional argument indicating the class that defines this function.
    // All member functions must have the form
    //  
    //     void memberFunction ( Type );
    //
    // where "Type" is one of:
    //    const char *    (Use XmRString)
    //    Boolean         (Use XmRBoolean)
    //    int             (Use XmRInt)
    //    float           (Use XmRFloat)
    //    No argument     (Use VkRNoArg or "NoArg"
    //    A filename      (Use VkRFilename or "Filename")
    //    An enumeration  (Use "Enumeration:ClassName:Type: VALUE1, VALUE2, VALUE3")
    //    A callback      (Use XmRCallback)


    static InterfaceMap map[] = {
    //---- Start editable code block: BulletinBoardUI resource table

      // { "resourceName", "setAttribute", XmRString},
    //---- End editable code block: BulletinBoardUI resource table
      { NULL }, // MUST be NULL terminated
    };

    return map;
} // End RegisterBulletinBoardInterface()






//---- End of generated code

//---- Start editable code block: End of generated code
int BulletinBoard::getNodeNames()
{
  FILE *node_stream;
  int total_nodes = 0;
  char **node_names;

  node_names = new char *[numNodes];
  
  for(int i = 0; i < numNodes; i++)
    node_names[i] = new char[27];

  /* use some UNIX stuff to read get the node names */
  if((node_stream = popen("find /hw -name node -print | sort", "r")) == NULL) {
    perror("popen()");
    return(-1);
  }
  
  /* read in the node names and figure out how many nodes there are */
  while(fgets(node_names[total_nodes], 27, node_stream) != NULL) {
    node_names[total_nodes][25] = '\0';
    total_nodes++;
  }

  pclose(node_stream);

  for(i = 0; i < total_nodes; i++)
    nodeNames[i] = XmStringCreateLocalized(node_names[i]);

  /* return total number of nodes in system */
  return(total_nodes);
}

void timerHandler(int _signal)
{
  signal(SIGALRM, timerHandler);
  gBulletinBoard->Update();
}

void BulletinBoard::SumHistory(int node, numa_stats_t *numa_stats)
// Assumes numa_stats has been zeroed!  (useful when doing total stats)
{
  int i;
  for(i = 0; i < HIST_LEN; i++) {
    numa_stats->refcnt_interrupt_number += numa_stats_hist[i][node].refcnt_interrupt_number;
    numa_stats->migr_auto_number_in += numa_stats_hist[i][node].migr_auto_number_in;
    numa_stats->migr_auto_number_out += numa_stats_hist[i][node].migr_auto_number_out;
    numa_stats->migr_auto_number_fail += numa_stats_hist[i][node].migr_auto_number_fail;
    numa_stats->migr_user_number_in += numa_stats_hist[i][node].migr_user_number_in;
    numa_stats->migr_user_number_out += numa_stats_hist[i][node].migr_user_number_out;
    numa_stats->migr_user_number_fail += numa_stats_hist[i][node].migr_user_number_fail;
    numa_stats->migr_coalescingd_number_in += numa_stats_hist[i][node].migr_coalescingd_number_in;
    numa_stats->migr_coalescingd_number_out += numa_stats_hist[i][node].migr_coalescingd_number_out;
    numa_stats->migr_coalescingd_number_fail += numa_stats_hist[i][node].migr_coalescingd_number_fail;
    numa_stats->migr_bouncecontrol_frozen_pages += numa_stats_hist[i][node].migr_bouncecontrol_frozen_pages;
    numa_stats->migr_bouncecontrol_melt_pages += numa_stats_hist[i][node].migr_bouncecontrol_melt_pages;
  }
}

void BulletinBoard::CalcAvg(numa_stats_t *numa_stats)
{
  numa_stats->refcnt_interrupt_number /= HIST_LEN;
  numa_stats->migr_auto_number_in /= HIST_LEN;
  numa_stats->migr_auto_number_out /= HIST_LEN;
  numa_stats->migr_auto_number_fail /= HIST_LEN;
  numa_stats->migr_user_number_in /= HIST_LEN;
  numa_stats->migr_user_number_out /= HIST_LEN;
  numa_stats->migr_user_number_fail /= HIST_LEN;
  numa_stats->migr_coalescingd_number_in /= HIST_LEN;
  numa_stats->migr_coalescingd_number_out /= HIST_LEN;
  numa_stats->migr_coalescingd_number_fail /= HIST_LEN;
  numa_stats->migr_bouncecontrol_frozen_pages /= HIST_LEN;
  numa_stats->migr_bouncecontrol_melt_pages /= HIST_LEN;  
}

void BulletinBoard::Update(int force)
{
    numa_stats_t numa_stats, numa_stats_diff;
    char sbuff[10];
    XmString xSbuff;
    char *nodeString;
    static int total = 0;
    char changed[13];
    
    bzero(changed, sizeof(char) * 13);

    if(!force) {
    for(int i = 0; i < numNodes; i++) {
      assert(XmStringGetLtoR(nodeNames[i], XmFONTLIST_DEFAULT_TAG, &nodeString));
      if(currentNodeNum == i && currentNode != NULL) {
	if (syssgi(SGI_NUMA_STATS_GET, nodeString, &numa_stats) < 0) {
	  perror("syssgi SGI_NUMA_STATS_GET");
	  exit(1);
	}
	if(numa_stats_hist[currentEntry][i].refcnt_interrupt_number = numa_stats.refcnt_interrupt_number -
	  numa_stats_old[i].refcnt_interrupt_number)
	  changed[0] = 1;
	if(numa_stats_hist[currentEntry][i].migr_auto_number_in = numa_stats.migr_auto_number_in -
	  numa_stats_old[i].migr_auto_number_in)
	  changed[1] = 1;
	if(numa_stats_hist[currentEntry][i].migr_auto_number_out = numa_stats.migr_auto_number_out -
	  numa_stats_old[i].migr_auto_number_out)
	  changed[2] = 1;
	if(numa_stats_hist[currentEntry][i].migr_auto_number_fail = numa_stats.migr_auto_number_fail -
	  numa_stats_old[i].migr_auto_number_fail)
	  changed[3] = 1;
	if(numa_stats_hist[currentEntry][i].migr_user_number_in = numa_stats.migr_user_number_in -
	  numa_stats_old[i].migr_user_number_in)
	  changed[4] = 1;
	if(numa_stats_hist[currentEntry][i].migr_user_number_out = numa_stats.migr_user_number_out -
	  numa_stats_old[i].migr_user_number_out)
	  changed[5] = 1;
	if(numa_stats_hist[currentEntry][i].migr_user_number_fail = numa_stats.migr_user_number_fail -
	  numa_stats_old[i].migr_user_number_fail)
	  changed[6] = 1;
	if(numa_stats_hist[currentEntry][i].migr_coalescingd_number_in = numa_stats.migr_coalescingd_number_in -
	  numa_stats_old[i].migr_coalescingd_number_in)
	  changed[7] = 1;
	if(numa_stats_hist[currentEntry][i].migr_coalescingd_number_out = numa_stats.migr_coalescingd_number_out -
	  numa_stats_old[i].migr_coalescingd_number_out)
	  changed[8] = 1;
	if(numa_stats_hist[currentEntry][i].migr_coalescingd_number_fail = numa_stats.migr_coalescingd_number_fail -
	  numa_stats_old[i].migr_coalescingd_number_fail)
	  changed[9] = 1;
	if(numa_stats_hist[currentEntry][i].migr_bouncecontrol_frozen_pages = numa_stats.migr_bouncecontrol_frozen_pages -
	  numa_stats_old[i].migr_bouncecontrol_frozen_pages)
	  changed[10] = 1;
	if(numa_stats_hist[currentEntry][i].migr_bouncecontrol_melt_pages = numa_stats.migr_bouncecontrol_melt_pages -
	  numa_stats_old[i].migr_bouncecontrol_melt_pages)
	  changed[11] = 1;
	if(numa_stats.migr_threshold - numa_stats_old[i].migr_threshold)
	  changed[12] = 1;
	bcopy(&numa_stats, &numa_stats_old[i], sizeof(numa_stats_t));
      } 
      else {
	if (syssgi(SGI_NUMA_STATS_GET, nodeString, &numa_stats) < 0) {
	  perror("syssgi SGI_NUMA_STATS_GET");
	  exit(1);
	}
	numa_stats_hist[currentEntry][i].refcnt_interrupt_number = numa_stats.refcnt_interrupt_number -
	  numa_stats_old[i].refcnt_interrupt_number;
	numa_stats_hist[currentEntry][i].migr_auto_number_in = numa_stats.migr_auto_number_in -
	  numa_stats_old[i].migr_auto_number_in;
	numa_stats_hist[currentEntry][i].migr_auto_number_out = numa_stats.migr_auto_number_out -
	  numa_stats_old[i].migr_auto_number_out;
	numa_stats_hist[currentEntry][i].migr_auto_number_fail = numa_stats.migr_auto_number_fail -
	  numa_stats_old[i].migr_auto_number_fail;
	numa_stats_hist[currentEntry][i].migr_user_number_in = numa_stats.migr_user_number_in -
	  numa_stats_old[i].migr_user_number_in;
	numa_stats_hist[currentEntry][i].migr_user_number_out = numa_stats.migr_user_number_out -
	  numa_stats_old[i].migr_user_number_out;
	numa_stats_hist[currentEntry][i].migr_user_number_fail = numa_stats.migr_user_number_fail -
	  numa_stats_old[i].migr_user_number_fail;
	numa_stats_hist[currentEntry][i].migr_coalescingd_number_in = numa_stats.migr_coalescingd_number_in -
	  numa_stats_old[i].migr_coalescingd_number_in;
	numa_stats_hist[currentEntry][i].migr_coalescingd_number_out = numa_stats.migr_coalescingd_number_out -
	  numa_stats_old[i].migr_coalescingd_number_out;
	numa_stats_hist[currentEntry][i].migr_coalescingd_number_fail = numa_stats.migr_coalescingd_number_fail -
	  numa_stats_old[i].migr_coalescingd_number_fail;
	numa_stats_hist[currentEntry][i].migr_bouncecontrol_frozen_pages = numa_stats.migr_bouncecontrol_frozen_pages -
	  numa_stats_old[i].migr_bouncecontrol_frozen_pages;
	numa_stats_hist[currentEntry][i].migr_bouncecontrol_melt_pages = numa_stats.migr_bouncecontrol_melt_pages -
	  numa_stats_old[i].migr_bouncecontrol_melt_pages;
	bcopy(&numa_stats, &numa_stats_old[i], sizeof(numa_stats_t));
      }
    }
    

    currentEntry++;
    if(currentEntry >= HIST_LEN)
      currentEntry = 0;

    if(currentNode == NULL)
      return;

    bzero(&numa_stats_diff, sizeof(numa_stats_t));
    if(totalFlag)
      for(i = 0; i < numNodes; i++)
	SumHistory(i, &numa_stats_diff);
    else
      SumHistory(currentNodeNum, &numa_stats_diff);
    
    CalcAvg(&numa_stats_diff);

    _meterCI->setValue(110 - numa_stats_diff.refcnt_interrupt_number * scaleVal / 10, 0);
    _meterAMT->setValue(110 - numa_stats_diff.migr_auto_number_in * scaleVal / 10, 0);
    _meterAMF->setValue(110 - numa_stats_diff.migr_auto_number_out * scaleVal / 10, 0);
    _meterAMS->setValue(110 - numa_stats_diff.migr_auto_number_fail * scaleVal / 10, 0);
    _meterUMT->setValue(110 - numa_stats_diff.migr_user_number_in * scaleVal / 10, 0);
    _meterUMF->setValue(110 - numa_stats_diff.migr_user_number_out * scaleVal / 10, 0);
    _meterUMS->setValue(110 - numa_stats_diff.migr_user_number_fail * scaleVal / 10, 0);
    _meterCMT->setValue(110 - numa_stats_diff.migr_coalescingd_number_in * scaleVal / 10, 0);
    _meterCMF->setValue(110 - numa_stats_diff.migr_coalescingd_number_out * scaleVal / 10, 0);
    _meterCMS->setValue(110 - numa_stats_diff.migr_coalescingd_number_fail * scaleVal / 10, 0);
    _meterFP->setValue(110 - numa_stats_diff.migr_bouncecontrol_frozen_pages * scaleVal / 10, 0);
    _meterMP->setValue(110 - numa_stats_diff.migr_bouncecontrol_melt_pages * scaleVal / 10, 0);

    }
    if(force || changed[12]) {
      sprintf(sbuff, "%08d", numa_stats_old[currentNodeNum].migr_threshold);
      xSbuff = XmStringCreateLocalized(sbuff);
      XtVaSetValues(_valMT, XmNlabelString, xSbuff, NULL);
    }    
    if(force || changed[0]) {
      sprintf(sbuff, "%08d", numa_stats_old[currentNodeNum].refcnt_interrupt_number);
      xSbuff = XmStringCreateLocalized(sbuff);
      XtVaSetValues(_valCI, XmNlabelString, xSbuff, NULL);
    }
    if(force || changed[1]) {
      sprintf(sbuff, "%08d", numa_stats_old[currentNodeNum].migr_auto_number_in);
      xSbuff = XmStringCreateLocalized(sbuff);
      XtVaSetValues(_valAMT, XmNlabelString, xSbuff, NULL);
    }
    if(force || changed[2]) {
      sprintf(sbuff, "%08d", numa_stats_old[currentNodeNum].migr_auto_number_out);
      xSbuff = XmStringCreateLocalized(sbuff);
      XtVaSetValues(_valAMF, XmNlabelString, xSbuff, NULL);
    }
    if(force || changed[3]) {
      sprintf(sbuff, "%08d", numa_stats_old[currentNodeNum].migr_auto_number_fail);
      xSbuff = XmStringCreateLocalized(sbuff);
      XtVaSetValues(_valAMS, XmNlabelString, xSbuff, NULL);
    }
    if(force || changed[4]) {
      sprintf(sbuff, "%08d", numa_stats_old[currentNodeNum].migr_user_number_in);
      xSbuff = XmStringCreateLocalized(sbuff);
      XtVaSetValues(_valUMT, XmNlabelString, xSbuff, NULL);
    }
    if(force || changed[5]) {
      sprintf(sbuff, "%08d", numa_stats_old[currentNodeNum].migr_user_number_out);
      xSbuff = XmStringCreateLocalized(sbuff);
      XtVaSetValues(_valUMF, XmNlabelString, xSbuff, NULL);
    }
    if(force || changed[6]) {
      sprintf(sbuff, "%08d", numa_stats_old[currentNodeNum].migr_user_number_fail);
      xSbuff = XmStringCreateLocalized(sbuff);
      XtVaSetValues(_valUMS, XmNlabelString, xSbuff, NULL);
    }
    if(force || changed[7]) {
      sprintf(sbuff, "%08d", numa_stats_old[currentNodeNum].migr_coalescingd_number_in);
      xSbuff = XmStringCreateLocalized(sbuff);
      XtVaSetValues(_valCMT, XmNlabelString, xSbuff, NULL);
    }
    if(force || changed[8]) {
      sprintf(sbuff, "%08d", numa_stats_old[currentNodeNum].migr_coalescingd_number_out);
      xSbuff = XmStringCreateLocalized(sbuff);
      XtVaSetValues(_valCMF, XmNlabelString, xSbuff, NULL);
    }
    if(force || changed[9]) {
      sprintf(sbuff, "%08d", numa_stats_old[currentNodeNum].migr_coalescingd_number_fail);
      xSbuff = XmStringCreateLocalized(sbuff);
      XtVaSetValues(_valCMS, XmNlabelString, xSbuff, NULL);
    }
    if(force || changed[10]) {
      sprintf(sbuff, "%08d", numa_stats_old[currentNodeNum].migr_bouncecontrol_frozen_pages);
      xSbuff = XmStringCreateLocalized(sbuff);
      XtVaSetValues(_valFP, XmNlabelString, xSbuff, NULL);
    }
    if(force || changed[11]) {
      sprintf(sbuff, "%08d", numa_stats_old[currentNodeNum].migr_bouncecontrol_melt_pages);
      xSbuff = XmStringCreateLocalized(sbuff);
      XtVaSetValues(_valMP, XmNlabelString, xSbuff, NULL);
    }
    
    //XmTextFieldSetString(_textfield, (char *)VkFormat("%d", total++));
#if 0
    for(i = 0; i < 13; i++) {
      if(changed[i]) {
	XmUpdateDisplay(_valMP);
	break;
      }
    }
    if(i == 13 && force)
      XmUpdateDisplay(_valMP);
#endif
    XmUpdateDisplay(_valCI);

}    // End BulletinBoard::Update()

//---- End editable code block: End of generated code


