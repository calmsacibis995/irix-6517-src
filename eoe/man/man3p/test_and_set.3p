'\"macro stdmacro
.TH TEST_AND_SET 3P
.SH NAME
test_and_set, test_then_and, test_then_nand, test_then_not, test_then_nor, test_then_xor, test_then_or, test_then_add, add_then_test, atomic_op, is_mips2, _test_and_set  \- mutual exclusion operators
.Op c p a
.SH C SYNOPSIS
.B #include <mutex.h>
.nf
.PP
.B "unsigned long test_and_set (unsigned long \(**, unsigned long);"
.PP
.B "unsigned long test_then_and (unsigned long \(**, unsigned long);"
.PP
.B "unsigned long test_then_nand (unsigned long \(**, unsigned long);"
.PP
.B "unsigned long test_then_not (unsigned long \(**, unsigned long);"
.PP
.B "unsigned long test_then_nor (unsigned long \(**, unsigned long);"
.PP
.B "unsigned long test_then_xor (unsigned long \(**, unsigned long);"
.PP
.B "unsigned long test_then_or (unsigned long \(**, unsigned long);"
.PP
.B "unsigned long test_then_add (unsigned long \(**, unsigned long);"
.PP
.B "unsigned long add_then_test (unsigned long \(**, unsigned long);"
.PP
.B "unsigned long atomic_op ("
.B "               unsigned long (\(**)(unsigned long \(*, unsigned long),"
.B "               unsigned long \(**, unsigned long);"
.PP
.B "is_mips2(void);"
.PP
.B "int _test_and_set (int \(**, int);"
.fi
.br
.sp
-------------------
.br
.sp
.B #include <sgidefs.h>
.br
.B #include <mutex.h>
.nf
.PP
.B "__uint32_t test_and_set32 (__uint32_t \(**, __uint32_t);"
.PP
.B "__uint32_t test_then_and32 (__uint32_t \(**, __uint32_t);"
.PP
.B "__uint32_t test_then_nand32 (__uint32_t \(**, __uint32_t);"
.PP
.B "__uint32_t test_then_not32 (__uint32_t \(**, __uint32_t);"
.PP
.B "__uint32_t test_then_nor32 (__uint32_t \(**, __uint32_t);"
.PP
.B "__uint32_t test_then_xor32 (__uint32_t \(**, __uint32_t);"
.PP
.B "__uint32_t test_then_or32 (__uint32_t \(**, __uint32_t);"
.PP
.B "__uint32_t test_then_add32 (__uint32_t \(**, __uint32_t);"
.PP
.B "__uint32_t add_then_test32 (__uint32_t \(**, __uint32_t);"
.PP
.B "__uint32_t atomic_op32 ("
.B "               __uint32_t (\(**)(__uint32_t \(*, __uint32_t),"
.B "               __uint32_t \(**, __uint32_t);"
.fi
.Op
.SH DESCRIPTION
\f4test_and_set\f1 atomically reads the \f2unsigned long\f1 pointed to by
the first argument and updates the location with the value specified in the
second argument.
The read value is returned.
.PP
\f4test_then_and\f1 atomically reads the \f2unsigned long\f1 pointed to by
the first argument and updates the location with the value specified in the
second argument bit-wise and'ed with the read value.
The read value is returned.
.PP
\f4test_then_nand\f1 atomically reads the \f2unsigned long\f1 pointed to by
the first argument and updates the location with the value specified in the
second argument bit-wise nand'ed with the read value.
The read value is returned.
.PP
\f4test_then_not\f1 atomically reads the \f2unsigned long\f1 pointed to by
the first argument and updates the location with the bit-wise inverted
version of the read value.
The read value is returned.
.PP
\f4test_then_nor\f1 atomically reads the \f2unsigned long\f1 pointed to by
the first argument and updates the location with the value specified in the
second argument bit-wise or'ed with the read value then inverted.
The read value is returned.
.PP
\f4test_then_xor\f1 atomically reads the \f2unsigned long\f1 pointed to by
the first argument and updates the location with the value specified in the
second argument bit-wise xor'ed with the read value.
The read value is returned.
.PP
\f4test_then_or\f1 atomically reads the \f2unsigned long\f1 pointed to by
the first argument and updates the location with the value specified in the
second argument bit-wise or'ed with the read value.
The read value is returned.
.PP
\f4test_then_add\f1 atomically reads the \f2unsigned long\f1 pointed to by
the first argument and updates the location with the value specified in the
second argument summed with the read value.
The read value is returned.
.PP
\f4add_then_test\f1 atomically reads the \f2unsigned long\f1 pointed to by
the first argument and updates the location with the value specified in the
second argument summed with the read value.
The summed value is returned.
.PP
\f4atomic_op\f1 permits one of the above functions to be passed as
the first argument.
The other two arguments and return value are the same as those of the
specified function.
.PP
\f4is_mips2\f1 returns 1 if the machine on which it is executed supports
the MIPS II instruction set, 0 otherwise.
.PP
\f4_test_and_set\f1 atomically reads the \f2int\f1 pointed to by
the first argument and updates the location with the value specified in the
second argument.
The read value is returned.
This function is the same as \f4test_and_set\f1 except for the type
of its arguments.
.PP
\f4test_and_set32\f1, \f4test_then_and32\f1,  \f4test_then_nand32\f1,
\f4test_then_not32\f1, \f4test_then_nor32\f1, \f4test_then_xor32\f1,
\f4test_then_or32\f1, \f4test_then_add32\f1, \f4add_then_test32\f1, and
\f4atomic_op32\f1 all work the same as their non-32 counterparts, except
that the size of the arguments are 32-bits (\f2__uint32_t\f1) regardless of
the size of an \f2unsigned long\f1.  This accommodates shared variables
between 64-bit and 32-bit programs.
.SH SEE ALSO
usinit(3P), abilock(3X).
.SH DIAGNOSTICS
The return value for these functions is specified in the above description
for each function.
