.TH xfs_db 1M
.SH NAME
xfs_db, xfs_db64 \- debug an XFS filesystem
.SH SYNOPSIS
.nf
\f3xfs_db\f1 [ \f3\-c\f1 cmd ] ... [ \f3\-p\f1 prog ] [ \f3\-r\f1 ] [ \f3\-x\f1 ] xfs_special
.sp .8v
\f3xfs_db\f1 \f3\-f\f1 [ \f3\-c\f1 cmd ] ... [ \f3\-p\f1 prog ] [ \f3\-f\f1 ] [ \f3\-r\f1 ] [ \f3\-x\f1 ] file
.sp .8v
\f3xfs_db64\f1 [ \f3\-c\f1 cmd ] ... [ \f3\-p\f1 prog ] [ \f3\-f\f1 ] [ \f3\-r\f1 ] [ \f3\-x\f1 ] xfs_special
.sp .8v
\f3xfs_db64\f1 \f3\-f\f1 [ \f3\-c\f1 cmd ] ... [ \f3\-p\f1 prog ] [ \f3\-r\f1 ] [ \f3\-x\f1 ] file
.fi
.SH DESCRIPTION
\f2xfs_db\f1 is used to examine an XFS filesystem.
Under rare circumstances it can also be used to modify an XFS filesystem,
but that task is normally left to \f2xfs_repair\f1(1M) or to
scripts such as \f2xfs_chver\f1 that run \f2xfs_db\f1.
.PP
\f2xfs_db64\f1 is a 64-bit version of \f2xfs_db\f1
which is not as susceptible to running out of memory.
It is available only on 64-bit capable systems.
.PP
The options to \f2xfs_db\f1 are:
.TP 10
\f3\-c\f1 \f2cmd\f1
\f2xfs_db\f1 commands may be run interactively (the default)
or as arguments on the command line.
Multiple \f3\-c\f1 arguments may be given.
The commands are run in the sequence given, then the program exits.
This is the mechanism used to implement \f2xfs_check\f1(1M).
.TP
\f3\-f\f1
Specifies that the filesystem image to be processed is stored in a 
regular file
(see the \f2mkfs_xfs\f1 \f3\-d\f1 \f2file\f1 option).
This might happen if an image copy
of a filesystem has been made into an ordinary file with \f2xfs_copy\f1(1M).
.TP
\f3\-p\f1 \f2prog\f1
Set the program name for prompts and some error messages,
the default value is \f2xfs_db\f1 or \f2xfs_db64\f1.
.TP
\f3\-r\f1
Open \f2file\f1 or \f2xfs_special\f1 read-only.
This option is required if \f2xfs_special\f1 is a mounted filesystem.
It is only necessary to omit this flag if a command that changes data
(\f3write\f1, \f3blocktrash\f1) is to be used.
.TP
\f3\-x\f1
Specifies expert mode.
This enables the \f3write\f1 command.
.SH CONCEPTS
\f2xfs_db\f1 commands can be broken up into two classes.
Most commands are for the navigation and display of data structures in
the filesystem.
Other commands are for scanning the filesystem in some way.
.PP
Commands which are used to navigate the filesystem structure take arguments
which reflect the names of filesystem structure fields.
There can be multiple field names separated by dots when the underlying
structures are nested, as in C.
The field names can be indexed (as an array index)
if the underlying field is an array.
The array indices can be specified as a range, two numbers separated by a dash.
.PP
\f2xfs_db\f1 maintains a current address in the filesystem.
The granularity of the address is a filesystem structure.
This can be a filesystem block,
an inode or quota (smaller than a filesystem block),
or a directory block (could be larger than a filesystem block).
There are a variety of commands to set the current address.
Associated with the current address is the current data type,
which is the structural type of this data.
Commands which follow the structure of the filesystem always set the type
as well as the address.
Commands which examine pieces of an individual file (inode) need the current
inode to be set, this is done with the \f3inode\f1 command.
.PP
The current address/type information is actually maintained in a
stack that can be explicitly manipulated with the
\f3push\f1, \f3pop\f1, and \f3stack\f1 commands.
This allows for easy examination of a nested filesystem structure.
Also, the last several locations visited are stored in a ring buffer
which can be manipulated with the
\f3forward\f1, \f3back\f3, and \f3ring\f1 commands.
.PP
XFS filesystems are divided into a small number of allocation groups.
\f2xfs_db\f1 maintains a notion of the current allocation group which is
manipulated by some commands.
The initial allocation group is 0.
.SH COMMANDS
.PP
Many commands have extensive online help.
Use the \f3help\f1 command for more details on any command.
.TP 10
\f3a\f1
See the \f3addr\f1 command.
.TP
\f3ablock\f1 \f2filoff\f1
Set current address to the offset \f2filoff\f1 (a filesystem block number)
in the attribute area of the current inode.
.TP
\f3addr\f1 [ \f2field-expression\f1 ]
Set current address to the value of the \f2field-expression\f1.
This is used to ``follow'' a reference in one structure to the object
being referred to.
If no argument is given the current address is printed.
.TP
\f3agf\f1 [ \f2agno\f1 ]
Set current address to the AGF block for allocation group \f2agno\f1.
If no argument is given use the current allocation group.
.TP
\f3agfl\f1 [ \f2agno\f1 ]
Set current address to the AGFL block for allocation group \f2agno\f1.
If no argument is given use the current allocation group.
.TP
\f3agi\f1 [ \f2agno\f1 ]
Set current address to the AGI block for allocation group \f2agno\f1.
If no argument is given use the current allocation group.
.TP
\f3b\f1
See the \f3back\f1 command.
.TP
\f3back\f1
Move to the previous location in the position ring.
.TP
\f3blockfree\f1
Free block usage information collected by the last execution of the
\f3blockget\f1 command.
This must be done before another \f3blockget\f1 command can be given,
presumably with different arguments than the previous one.
.TP
\f3blockget\f1 [ \f3\-npsv\f1 ] [ \f3\-b\f1 \f2bno\f1 ] ... [ \f3\-i\f1 \f2ino\f1 ] ...
Get block usage and check filesystem consistency.
The information is saved for use by a subsequent
\f3blockuse\f1, \f3ncheck\f1, or \f3blocktrash\f1 command.
See \f2xfs_check\f1(1M) for more information.
.br
The \f3\-b\f1 option is used to specify filesystem block numbers
about which verbose information should be printed.
.br
The \f3\-i\f1 option is used to specify inode numbers about which
verbose information should be printed.
.br
The \f3\-n\f1 option is used to save pathnames for inodes visited,
this is used to support the \f2xfs_ncheck\f1(1M) command.
It also means that pathnames will be printed for inodes that have problems.
This option uses a lot of memory so is not enabled by default.
.br
The \f3\-p\f1 option causes error messages to be prefixed with the
filesystem name being processed.
This is useful if several copies of \f2xfs_db\f1 are run in parallel.
.br
The \f3\-s\f1 option restricts output to severe errors only.
This is useful if the output is too long otherwise.
.br
The \f3\-v\f1 option enables verbose output.
Messages will be printed for every block and inode processed.
.TP
\f3blocktrash\f1 [ \f3\-n\f1 \f2c\f1 ] [ \f3\-x\f1 \f2a\f1 ] [ \f3\-y\f1 \f2b\f1 ] [ \f3\-s\f1 \f2s\f1 ] [ \f3\-0123\f1 ] [ \f3\-t\f1 \f2t\f1 ] ...
Trash randomly selected filesystem metadata blocks.
Trashing occurs to randomly selected bits in the chosen blocks.
This command is available only in debugging versions of \f2xfs_db\f1.
It is useful for testing \f2xfs_repair\f1(1M) and \f2xfs_check\f1(1M).
.br
The \f3\-0\f1, \f3\-1\f1, \f3\-2\f1, and \f3\-3\f1 options (mutually exclusive)
set the operating mode for \f3blocktrash\f1.
In \f3\-0\f1 mode, changed bits are cleared.
In \f3\-1\f1 mode, changed bits are set.
In \f3\-2\f1 mode, changed bits are inverted.
In \f3\-3\f1 mode, changed bits are randomized.
.br
The \f3\-n\f1 option supplies the count of block-trashings to perform
(default 1).
.br
The \f3\-s\f1 option supplies a seed to the random processing.
.br
The \f3\-t\f1 option gives a type of blocks to be selected
for trashing.
Multiple \f3\-t\f1 options may be given.
If no \f3\-t\f1 options are given then all metadata types can be trashed.
.br
The \f3\-x\f1 option sets the minimum size of bit range to be trashed.
The default value is 1.
.br
The \f3\-y\f1 option sets the maximum size of bit range to be trashed.
The default value is 1024.
.TP
\f3blockuse\f1 [ \f3\-n\f1 ] [ \f3\-c\f1 \f2blockcount\f1 ]
Print usage for current filesystem block(s).
For each block, the type and (if any) inode are printed.
.br
The \f3\-c\f1 option specifies a count of blocks to process.
The default value is 1 (the current block only).
.br
The \f3\-n\f1 option specifies that file names should be printed.
The prior \f3blockget\f1 command must have also specified the \f3\-n\f1 option.
.TP
\f3bmap\f1 [ \f3\-a\f1 ] [ \f3\-d\f1 ] [ \f2block\f1 [ \f2len\f1 ] ]
Show the block map for the current inode.
The map display can be restricted to an area of the file with the
\f2block\f1 and \f2len\f1 arguments.
If \f2block\f1 is given and \f2len\f1 is omitted then 1 is assumed for len.
.br
The \f3\-a\f1 and \f3\-d\f1 options are used to select the attribute or data
area of the inode, if neither option is given then both areas are shown.
.TP
\f3check\f1
See the \f3blockget\f1 command.
.TP
\f3convert\f1 \f2type\f1 \f2number\f1 [ \f2type\f1 \f2number\f1 ] ... \f2type\f1
Convert from one address form to another.
The known \f2type\f1s, with alternate names, are:
\f3agblock\f1 or \f3agbno\f1 (filesystem block within an allocation group),
\f3agino\f1 or \f3aginode\f1 (inode number within an allocation group),
\f3agnumber\f1 or \f3agno\f1 (allocation group number),
\f3bboff\f1 or \f3daddroff\f1 (byte offset in a \f3daddr\f1),
\f3blkoff\f1 or \f3fsboff\f1 or \f3agboff\f1 (byte offset in a \f3agblock\f1
or \f3fsblock\f1),
\f3byte\f1 or \f3fsbyte\f1 (byte address in filesystem),
\f3daddr\f1 or \f3bb\f1 (disk address, 512-byte blocks),
\f3fsblock\f1 or \f3fsb\f1 or \f3fsbno\f1 (filesystem block, see the
\f3fsblock\f1 command),
\f3ino\f1 or \f3inode\f1 (inode number),
\f3inoidx\f1 or \f3offset\f1 (index of inode in filesystem block),
and \f3inooff\f1 or \f3inodeoff\f1 (byte offset in inode).
Only conversions that ``make sense'' are allowed.
The compound form (with more than three arguments) is useful for
conversions such as
\f3convert\f1 \f3agno\f1 \f2ag\f1 \f3agbno\f1 \f2agb\f1 \f3fsblock\f1.
.TP
\f3daddr\f1 [ \f2d\f1 ]
Set current address to the daddr (512 byte block) given by \f2d\f1.
If no value for \f2d\f1 is given the current address is printed,
expressed as a daddr.
The type is set to \f3data\f1 (uninterpreted).
.TP
\f3dblock\f1 \f2filoff\f1
Set current address to the offset \f2filoff\f1 (a filesystem block number)
in the data area of the current inode.
.TP
\f3debug\f1 [ \f2flagbits\f1 ]
Set debug option bits.
These are used for debugging \f2xfs_db\f1.
If no value is given for \f2flagbits\f1, print the current debug option bits.
These are for the use of the implementor.
.TP
\f3dquot\f1 [ \f2projectid_or_userid\f1 ]
Set current address to a project or user quota block.
.TP
\f3echo\f1 [ \f2arg\f1 ] ...
Echo the arguments to the output.
.TP
\f3f\f1
See the \f3forward\f1 command.
.TP
\f3forward\f1
Move forward to the next entry in the position ring.
.TP
\f3frag\f1 [ \f3\-adflqRrv\f1 ]
Get file fragmentation data.
This prints information about fragmentation of file data in the filesystem
(as opposed to fragmentation of freespace,
for which see the \f3freesp\f1 command).
Every file in the filesystem is examined to see how far from ideal
its extent mappings are.
A summary is printed giving the totals.
.br
The \f3\-v\f1 option sets verbosity,
every inode has information printed for it.
The remaining options select which inodes and extents are examined.
If no options are given then all are assumed set,
otherwise just those given are enabled.
.br
The \f3\-a\f1 option enables processing of attribute data.
.br
The \f3\-d\f1 option enables processing of directory data.
.br
The \f3\-f\f1 option enables processing of regular file data.
.br
The \f3\-l\f1 option enables processing of symbolic link data.
.br
The \f3\-q\f1 option enables processing of quota file data.
.br
The \f3\-R\f1 option enables processing of realtime control file data.
.br
The \f3\-r\f1 option enables processing of realtime file data.
.TP
\f3freesp\f1 [ \f3\-bcds\f1 ] [ \f3\-a\f1 \f2a\f1 ] ... [ \f3\-e\f1 \f2i\f1 ] [ \f3\-h\f1 \f2h1\f1 ] ... [ \f3\-m\f1 \f2m\f1 ]
Summarize free space for the filesystem.
The free blocks are examined and totalled,
and displayed in the form of a histogram,
with a count of extents in each range of free extent sizes.
.br
The \f3\-a\f1 \f2a\f1 option adds \f2a\f1 to the list of
allocation groups to be processed.
If no \f3\-a\f1 options are given then all allocation groups are processed.
.br
The \f3\-b\f1 option specifies that the histogram buckets are binary-sized,
with the starting sizes being the powers of 2.
.br
The \f3\-c\f1 option specifies that \f3freesp\f1 will search the
by-size (cnt) space Btree instead of the default by-block (bno) space Btree.
.br
The \f3\-d\f1 option specifies that every free extent will be displayed.
.br
The \f3\-e\f1 \f2i\f1 option specifies that the histogram buckets are
equal-sized, with the size specified as \f2i\f1.
.br
The \f3\-h\f1 \f2h1\f1 option specifies a starting block number
for a histogram bucket as \f2h1\f1.
Multiple \f3\-h\f1 options are given to specify the complete set of buckets.
.br
The \f3\-m\f1 \f2m\f1 option specifies that the histogram
starting block numbers are powers of \f2m\f1.
This is the general case of \f3\-b\f1.
.br
The \f3\-s\f1 option specifies that a final summary of total free extents,
free blocks, and the average free extent size is printed.
.TP
\f3fsb\f1
See the \f3fsblock\f1 command.
.TP
\f3fsblock\f1 [ \f2fsb\f1 ]
Set current address to the fsblock value given by \f2fsb\f1.
If no value for \f2fsb\f1 is given the current address is printed,
expressed as an fsb.
The type is set to \f3data\f1 (uninterpreted).
XFS filesystem block numbers are computed
((\f2agno\f1 << \f2agshift\f1) | \f2agblock\f1)
where \f2agshift\f1 depends on the size of an allocation group.
Use the \f3convert\f1 command to convert to and from this form.
Block numbers given for file blocks
(for instance from the \f3bmap\f1 command)
are in this form.
.TP
\f3hash\f1 \f2string\f1
Prints the hash value of \f2string\f1 using the hash function of the XFS
directory and attribute implementation.
.TP
\f3help\f1 [ \f2command\f1 ]
Print help for one or all commands.
.TP
\f3inode\f1 [ \f2inode#\f1 ]
Set the current inode number.
If no \f2inode#\f1 is given, print the current inode number.
.TP
\f3log\f1 [ \f3stop\f1 | \f3start\f1 \f2filename\f1 ]
Start logging output to \f2filename\f1, stop logging,
or print the current logging status.
.TP
\f3ncheck\f1 [ \f3\-s\f1 ] [ \f3\-i\f1 \f2ino\f1 ] ...
Print name-inode pairs.
A \f3blockget -n\f1 command must be run first to gather the information.
.br
The \f3\-i\f1 option specifies an inode number to be printed.
If no \f3\-i\f1 options are given then all inodes are printed.
.br
The \f3\-s\f1 option specifies that only setuid and setgid files are printed.
.TP
\f3p\f1
See the \f3print\f1 command.
.TP
\f3pop\f1
Pop location from the stack.
.TP
\f3print\f1 [ \f2field-expression\f1 ] ...
Print field values.
If no argument is given, print all fields in the current structure.
.TP
\f3push\f1 [ \f2command\f1 ]
Push location to the stack.
If \f2command\f1 is supplied,
set the current location to the results of \f2command\f1
after pushing the old location.
.TP
\f3q\f1
See the \f3quit\f1 command.
.TP
\f3quit\f1
Exit \f2xfs_db\f1.
.TP
\f3ring\f1 [ \f2index\f1 ]
Show position ring (if no \f2index\f1 argument is given),
or move to a specific entry in the position ring given by \f2index\f1.
.TP
\f3sb\f1 [ \f2agno\f1 ]
Set current address to SB header in allocation group \f2agno\f1.
If no \f2agno\f1 is given use the current allocation group number.
.TP
\f3source\f1 \f2source-file\f1
Process commands from \f2source-file\f1.
\f3source\f1 commands can be nested.
.TP
\f3stack\f1
View the location stack.
.TP
\f3type\f1 [ \f2type\f1 ]
Set the current data type to \f2type\f1.
If no argument is given, show the current data type.
The possible data types are:
\f3agf\f1, \f3agfl\f1, \f3agi\f1, \f3attr\f1, \f3bmapbta\f1, \f3bmapbtd\f1,
\f3bnobt\f1, \f3cntbt\f1, \f3data\f1, \f3dir\f1, \f3dir2\f1, \f3dqblk\f1,
\f3inobt\f1, \f3inode\f1, \f3log\f1, \f3rtbitmap\f1, \f3rtsummary\f1,
\f3sb\f1, and \f3symlink\f1.
See the TYPES section below for more information on these data types.
.TP
\f3write\f1 [ \f2field or value\f1 ] ...
Write a value to disk.
Specific fields can be set in structures (struct mode),
or a block can be set to data values (data mode),
or a block can be set to string values (string mode, for symlink blocks).
The operation happens immediately: there is no buffering.
.br
Struct mode is in effect when the current type is structural,
i.e. not data.
For struct mode, the syntax is ``\f3write\f1 \f2field\f1 \f2value\f1''.
.br
Data mode is in effect when the current type is data.
In this case the contents of the block can be shifted or rotated left or right,
or filled with a sequence, a constant value, or a random value.
In this mode \f3write\f1 with no arguments gives more information on
the allowed commands.
.SH TYPES
This section gives the fields in each structure type and their meanings.
Note that some types of block cover multiple actual structures,
for instance directory blocks.
.TP 10
\f3agf\f1
The AGF block is the header for block allocation information;
it is in the second 512-byte block of each allocation group.
The following fields are defined:
.br
\f3magicnum\f1: AGF block magic number, 0x58414746 ('XAGF')
.br
\f3versionnum\f1: version number, currently 1
.br
\f3seqno\f1: sequence number starting from 0
.br
\f3length\f1: size in filesystem blocks of the allocation group.
All allocation groups except the last one of the filesystem have
the superblock's \f3agblocks\f1 value here
.br
\f3bnoroot\f1: block number of the root of the Btree holding free space
information sorted by block number
.br
\f3cntroot\f1: block number of the root of the Btree holding free space
information sorted by block count
.br
\f3bnolevel\f1: number of levels in the by-block-number Btree
.br
\f3cntlevel\f1: number of levels in the by-block-count Btree
.br
\f3flfirst\f1: index into the AGFL block of the first active entry
.br
\f3fllast\f1: index into the AGFL block of the last active entry
.br
\f3flcount\f1: count of active entries in the AGFL block
.br
\f3freeblks\f1: count of blocks represented in the freespace Btrees
.br
\f3longest\f1: longest free space represented in the freespace Btrees
.TP
\f3agfl\f1
The AGFL block contains block numbers for use of the block allocator;
it is in the fourth 512-byte block of each allocation group.
Each entry in the active list is a block number within the allocation group
that can be used for any purpose if space runs low.
The AGF block fields \f3flfirst\f1, \f3fllast\f1, and \f3flcount\f1
designate which entries are currently active.
Entry space is allocated in a circular manner within the AGFL block.
Fields defined:
.br
\f3bno\f1: array of all block numbers.
Even those which are not active are printed
.TP
\f3agi\f1
The AGI block is the header for inode allocation information;
it is in the third 512-byte block of each allocation group.
Fields defined:
.br
\f3magicnum\f1: AGI block magic number, 0x58414749 ('XAGI')
.br
\f3versionnum\f1: version number, currently 1
.br
\f3seqno\f1: sequence number starting from 0
.br
\f3length\f1: size in filesystem blocks of the allocation group
.br
\f3count\f1: count of inodes allocated
.br
\f3root\f1: block number of the root of the Btree holding inode allocation
information
.br
\f3level\f1: number of levels in the inode allocation Btree
.br
\f3freecount\f1: count of allocated inodes that are not in use
.br
\f3newino\f1: last inode number allocated
.br
\f3dirino\f1: unused
.br
\f3unlinked\f1: an array of inode numbers within the allocation group.
The entries in the AGI block are the heads of lists which run through the
inode \f3next_unlinked\f1 field.
These inodes are to be unlinked the next time the filesystem is mounted
.TP
\f3attr\f1
An attribute fork is organized as a Btree with the actual data
embedded in the leaf blocks.
The root of the Btree is found in block 0 of the fork.
The index (sort order) of the Btree is the hash value of the attribute name.
All the blocks contain a \f3blkinfo\f1 structure at the beginning,
see type \f3dir\f1 for a description.
Nonleaf blocks are identical in format to those for version 1 and
version 2 directories, see type \f3dir\f1 for a description.
Leaf blocks can refer to ``local'' or ``remote'' attribute values.
Local values are stored directly in the leaf block.
Remote values are stored in an independent block in the attribute fork
(with no structure).
Leaf blocks contain the following fields:
.br
\f3hdr\f1: header containing
a \f3blkinfo\f1 structure \f3info\f1 (magic number 0xfbee),
a \f3count\f1 of active entries,
\f3usedbytes\f1 total bytes of names and values,
the \f3firstused\f1 byte in the name area,
\f3holes\f1 set if the block needs compaction,
and array \f3freemap\f1 as for \f3dir\f1 leaf blocks
.br
\f3entries\f1: array of structures containing
a \f3hashval\f1,
\f3nameidx\f1 (index into the block of the name),
and flags \f3incomplete\f1,
\f3root\f1,
and \f3local\f1
.br
\f3nvlist\f1: array of structures describing the attribute names and values.
Fields always present:
\f3valuelen\f1 (length of value in bytes),
\f3namelen\f1,
and \f3name\f1.
Fields present for local values:
\f3value\f1 (value string).
Fields present for remote values:
\f3valueblk\f1 (fork block number of containing the value).
.TP
\f3bmapbt\f1
Files with many extents in their data or attribute fork will have the
extents described by the contents of a Btree for that fork,
instead of being stored directly in the inode.
Each bmap Btree starts with a root block contained within the inode.
The other levels of the Btree are stored in filesystem blocks.
The blocks are linked to sibling left and right blocks at each level,
as well as by pointers from parent to child blocks.
Each block contains the following fields:
.br
\f3magic\f1: bmap Btree block magic number, 0x424d4150 ('BMAP')
.br
\f3level\f1: level of this block above the leaf level
.br
\f3numrecs\f1: number of records or keys in the block
.br
\f3leftsib\f1: left (logically lower) sibling block, 0 if none
.br
\f3rightsib\f1: right (logically higher) sibling block, 0 if none
.br
\f3recs\f1: [leaf blocks only] array of extent records.
Each record contains
\f3startoff\f1,
\f3startblock\f1,
\f3blockcount\f1,
and \f3extentflag\f1 (1 if the extent is unwritten)
.br
\f3keys\f1: [nonleaf blocks only] array of key records.
These are the first key value of each block in the level below this one.
Each record contains \f3startoff\f1
.br
\f3ptrs\f1: [nonleaf blocks only] array of child block pointers.
Each pointer is a filesystem block number to the next level in the Btree
.TP
\f3bnobt\f1
There is one set of filesystem blocks forming the by-block-number allocation
Btree for each allocation group.
The root block of this Btree is designated by the \f3bnoroot\f1 field in the
coresponding AGF block.
The blocks are linked to sibling left and right blocks at each level,
as well as by pointers from parent to child blocks.
Each block has the following fields:
.br
\f3magic\f1: BNOBT block magic number, 0x41425442 ('ABTB')
.br
\f3level\f1: level number of this block, 0 is a leaf
.br
\f3numrecs\f1: number of data entries in the block
.br
\f3leftsib\f1: left (logically lower) sibling block, 0 if none
.br
\f3rightsib\f1: right (logically higher) sibling block, 0 if none
.br
\f3recs\f1: [leaf blocks only] array of freespace records.
Each record contains
\f3startblock\f1
and \f3blockcount\f1
.br
\f3keys\f1: [nonleaf blocks only] array of key records.
These are the first value of each block in the level below this one.
Each record contains 
\f3startblock\f1
and \f3blockcount\f1
.br
\f3ptrs\f1: [nonleaf blocks only] array of child block pointers.
Each pointer is a block number within the allocation group to the next level
in the Btree
.TP
\f3cntbt\f1
There is one set of filesystem blocks forming the by-block-count allocation
Btree for each allocation group.
The root block of this Btree is designated by the \cntroot\f1 field in the
coresponding AGF block.
The blocks are linked to sibling left and right blocks at each level,
as well as by pointers from parent to child blocks.
Each block has the following fields:
.br
\f3magic\f1: CNTBT block magic number, 0x41425443 ('ABTC')
.br
\f3level\f1: level number of this block, 0 is a leaf
.br
\f3numrecs\f1: number of data entries in the block
.br
\f3leftsib\f1: left (logically lower) sibling block, 0 if none
.br
\f3rightsib\f1: right (logically higher) sibling block, 0 if none
.br
\f3recs\f1: [leaf blocks only] array of freespace records.
Each record contains 
\f3startblock\f1
and \f3blockcount\f1
.br
\f3keys\f1: [nonleaf blocks only] array of key records.
These are the first value of each block in the level below this one.
Each record contains 
\f3blockcount\f1
and \f3startblock\f1
.br
\f3ptrs\f1: [nonleaf blocks only] array of child block pointers.
Each pointer is a block number within the allocation group to the next level
in the Btree
.TP
\f3data\f1
User file blocks, and other blocks whose type is unknown,
have this type for display purposes in \f2xfs_db\f1.
The block data is displayed in hexadecimal format.
.TP
\f3dir\f1
A version 1 directory is organized as a Btree with the directory data
embedded in the leaf blocks.
The root of the Btree is found in block 0 of the file.
The index (sort order) of the Btree is the hash value of the entry name.
All the blocks contain a \f3blkinfo\f1 structure at the beginning
with the following fields:
.br
\f3forw\f1: next sibling block
.br
\f3back\f1: previous sibling block
.br
\f3magic\f1: magic number for this block type
.sp
The nonleaf (node) blocks have the following fields:
.br
\f3hdr\f1: header containing
a \f3blkinfo\f1 structure \f3info\f1 (magic number 0xfebe),
the \f3count\f1 of active entries,
and the \f3level\f1 of this block above the leaves
.br
\f3btree\f1: array of entries containing
\f3hashval\f1 and
\f3before\f1 fields.
The \f3before\f1 value is a block number within the directory file to the
child block,
the \f3hashval\f1 is the last hash value in that block
.sp
The leaf blocks have the following fields:
.br
\f3hdr\f1: header containing
a \f3blkinfo\f1 structure \f3info\f1 (magic number 0xfeeb),
the \f3count\f1 of active entries,
\f3namebytes\f1 (total name string bytes),
\f3holes\f1 flag (block needs compaction),
and \f3freemap\f1 (array of \f3base\f1, \f3size\f1 entries for free regions)
.br
\f3entries\f1: array of structures containing
\f3hashval\f1,
\f3nameidx\f1 (byte index into the block of the name string),
and \f3namelen\f1
.br
\f3namelist\f1: array of structures containing
\f3inumber\f1
and \f3name\f1
.TP
\f3dir2\f1
A version 2 directory has four kinds of blocks.
Data blocks start at offset 0 in the file.
There are two kinds of data blocks: single-block directories have
the leaf information embedded at the end of the block, data blocks
in multi-block directories do not.
Node and leaf blocks start at offset 32GB (with either a single
leaf block or the root node block).
Freespace blocks start at offset 64GB.
The node and leaf blocks form a Btree, with references to the data
in the data blocks.
The freespace blocks form an index of longest free spaces within the
data blocks.
.sp
A single-block directory block contains the following fields:
.br
\f3bhdr\f1: header containing 
\f3magic\f1 number 0x58443242 ('XD2B')
and an array \f3bestfree\f1 of the longest 3 free spaces in the block
(\f3offset\f1, \f3length\f1)
.br
\f3bu\f1: array of union structures.
Each element is either an entry or a freespace.
For entries, there are the following fields:
\f3inumber\f1,
\f3namelen\f1,
\f3name\f1,
and \f3tag\f1.
For freespace, there are the following fields:
\f3freetag\f1 (0xffff),
\f3length\f1,
and \f3tag\f1.
The \f3tag\f1 value is the byte offset in the block of the start
of the entry it is contained in
.br
\f3bleaf\f1: array of leaf entries containing
\f3hashval\f1
and \f3address\f1.
The \f3address\f1 is a 64-bit word offset into the file
.br
\f3btail\f1: tail structure containing
the total \f3count\f1 of leaf entries
and \f3stale\f1 count of unused leaf entries
.sp
A data block contains the following fields:
.br
\f3dhdr\f1:
header containing 
\f3magic\f1 number 0x58443244 ('XD2D')
and an array \f3bestfree\f1 of the longest 3 free spaces in the block
(\f3offset\f1, \f3length\f1)
.br
\f3du\f1: array of union structures as for \f3bu\f1
.sp
Leaf blocks have two possible forms.
If the Btree consists of a single leaf then the freespace information
is in the leaf block,
otherwise it is in separate blocks and the root of the Btree is
a node block.
A leaf block contains the following fields:
.br
\f3lhdr\f1: header containing
a \f3blkinfo\f1 structure \f3info\f1 (magic number 0xd2f1 for the single
leaf case, 0xd2ff for the true Btree case),
the total \f3count\f1 of leaf entries,
and \f3stale\f1 count of unused leaf entries
.br
\f3lents\f1: leaf entries, as for \f3bleaf\f1
.br
\f3lbests\f1: [single leaf only]
array of values which represent the longest freespace
in each data block in the directory
.br
\f3ltail\f1: [single leaf only] tail structure containing
\f3bestcount\f1 count of \f3lbests\f1
.sp
A node block is identical to that for types \f3attr\f1 and \f3dir\f1.
.sp
A freespace block contains the following fields:
.br
\f3fhdr\f1: header containing
\f3magic\f1 number 0x58443246 ('XD2F'), 
\f3firstdb\f1 first data block number covered by this freespace block,
\f3nvalid\f1 number of valid entries,
and \f3nused\f1 number of entries representing real data blocks
.br
\f3fbests\f1: array of values as for \f3lbests\f1
.TP
\f3dqblk\f1
The quota information is stored in files referred to by the superblock
\f3uquotino\f1 and \f3pquotino\f1 fields.
Each filesystem block in a quota file contains a constant number of
quota entries.
The quota entry size is currently 136 bytes,
so with a 4KB filesystem block size there are 30 quota entries per block.
The \f3dquot\f1 command is used to locate these entries in the filesystem.
The file entries are indexed by the user or project identifier
to determine the block and offset.
Each quota entry has the following fields:
.br
\f3magic\f1: magic number, 0x4451 ('DQ')
.br
\f3version\f1: version number, currently 1
.br
\f3flags\f1: flags, values include
0x01 for user quota,
0x02 for project quota
.br
\f3id\f1: user or project identifier
.br
\f3blk_hardlimit\f1: absolute limit on blocks in use
.br
\f3blk_softlimit\f1: preferred limit on blocks in use
.br
\f3ino_hardlimit\f1: absolute limit on inodes in use
.br
\f3ino_softlimit\f1: preferred limit on inodes in use
.br
\f3bcount\f1: blocks actually in use
.br
\f3icount\f1: inodes actually in use
.br
\f3itimer\f1: time when service will be refused if soft limit is violated
for inodes
.br
\f3btimer\f1: time when service will be refused if soft limit is violated
for blocks
.br
\f3iwarns\f1: number of warnings issued about inode limit violations
.br
\f3bwarns\f1: number of warnings issued about block limit violations
.br
\f3rtb_hardlimit\f1: absolute limit on realtime blocks in use
.br
\f3rtb_softlimit\f1: preferred limit on realtime blocks in use
.br
\f3rtbcount\f1: realtime blocks actually in use
.br
\f3rtbtimer\f1: time when service will be refused if soft limit is violated
for realtime blocks
.br
\f3rtbwarns\f1: number of warnings issued about realtime block limit violations
.TP
\f3inobt\f1
There is one set of filesystem blocks forming the inode allocation
Btree for each allocation group.
The root block of this Btree is designated by the \f3root\f1 field in the
coresponding AGI block.
The blocks are linked to sibling left and right blocks at each level,
as well as by pointers from parent to child blocks.
Each block has the following fields:
.br
\f3magic\f1: INOBT block magic number, 0x49414254 ('IABT')
.br
\f3level\f1: level number of this block, 0 is a leaf
.br
\f3numrecs\f1: number of data entries in the block
.br
\f3leftsib\f1: left (logically lower) sibling block, 0 if none
.br
\f3rightsib\f1: right (logically higher) sibling block, 0 if none
.br
\f3recs\f1: [leaf blocks only] array of inode records.
Each record contains 
\f3startino\f1 allocation-group relative inode number,
\f3freecount\f1 count of free inodes in this chunk,
and \f3free\f1 bitmap, LSB corresponds to inode 0
.br
\f3keys\f1: [nonleaf blocks only] array of key records.
These are the first value of each block in the level below this one.
Each record contains 
\f3startino\f1
.br
\f3ptrs\f1: [nonleaf blocks only] array of child block pointers.
Each pointer is a block number within the allocation group to the next level
in the Btree
.TP
\f3inode\f1
Inodes are allocated in ``chunks'' of 64 inodes each.
Usually a chunk is multiple filesystem blocks, although there are cases
with large filesystem blocks where a chunk is less than one block.
The inode Btree (see \f3inobt\f1 above)
refers to the inode numbers per allocation group.
The inode numbers directly reflect the location of the inode block on disk.
Use the \f3inode\f1 command to point \f2xfs_db\f1 to a specific inode.
Each inode contains four regions:
\f3core\f1,
\f3next_unlinked\f1,
\f3u\f1,
and \f3a\f1.
\f3core\f1 contains the fixed information.
\f3next_unlinked\f1 is separated from the core due to
journalling considerations, see type \f3agi\f1 field \f3unlinked\f1.
\f3u\f1 is a union structure that is different in size and format depending
on the type and representation of the file data (``data fork'').
\f3a\f1 is an optional union structure to describe attribute data,
that is different in size, format, and location depending on the presence
and representation of attribute data, and the size of the \f3u\f1 data
(``attribute fork'').
\f2xfs_db\f1 automatically selects the proper union members based on
information in the inode.
.br
The following are fields in the inode core:
.br
\f3magic\f1: inode magic number, 0x494e ('IN')
.br
\f3mode\f1: mode and type of file, as described in \f3chmod\f1(2),
\f3mknod\f1(2), and \f3stat\f1(2)
.br
\f3version\f1: inode version, 1 or 2
.br
\f3format\f1: format of \f3u\f1 union data
(0: dev_t,
1: local file \- in-inode directory or symlink,
2: extent list,
3: Btree root,
4: unique id [unused])
.br
\f3nlinkv1\f1: number of links to the file in a version 1 inode
.br
\f3nlinkv2\f1: number of links to the file in a version 2 inode
.br
\f3projid\f1: owner's project id (version 2 inode only)
.br
\f3uid\f1: owner's user id
.br
\f3gid\f1: owner's group id
.br
\f3atime\f1: time last accessed (seconds and nanoseconds)
.br
\f3mtime\f1: time last modified
.br
\f3ctime\f1: time created or inode last modified
.br
\f3size\f1: number of bytes in the file
.br
\f3nblocks\f1: total number of blocks in the file including
indirect and attribute
.br
\f3extsize\f1: basic/minimum extent size for the file, used only for realtime
.br
\f3nextents\f1: number of extents in the data fork
.br
\f3naextents\f1: number of extents in the attribute fork
.br
\f3forkoff\f1: attribute fork offset in the inode,
in 64-bit words from the start of \f3u\f1
.br
\f3aformat\f1: format of \f3a\f1 data
(1: local attribute data,
2: extent list,
3: Btree root)
.br
\f3dmevmask\f1: DMAPI event mask
.br
\f3dmstate\f1: DMAPI state information
.br
\f3newrtbm\f1: file is the realtime bitmap and is ``new'' format
.br
\f3prealloc\f1: file has preallocated data space after EOF
.br
\f3realtime\f1: file data is in the realtime subvolume
.br
\f3gen\f1: inode generation number
.sp
The following fields are in the \f3u\f1 data fork union:
.br
\f3bmbt\f1: bmap Btree root.
This looks like a \f3bmapbtd\f1 block with redundant information removed
.br
\f3bmx\f1: array of extent descriptors
.br
\f3dev\f1: dev_t for the block or character device
.br
\f3sfdir\f1: shortform (in-inode) version 1 directory.
This consists of 
a \f3hdr\f1 containing 
the \f3parent\f1 inode number
and a \f3count\f1 of active entries in the directory,
followed by 
an array \f3list\f1 of \f3hdr\f1.\f3count\f1 entries.
Each such entry contains 
\f3inumber\f1, 
\f3namelen\f1,
and \f3name\f1 string
.br
\f3sfdir2\f1: shortform (in-inode) version 2 directory.
This consists of 
a \f3hdr\f1 containing 
a \f3count\f1 of active entries in the directory,
an \f3i8count\f1 of entries with inumbers that don't fit in a 32-bit value,
and the \f3parent\f1 inode number,
followed by 
an array \f3list\f1 of \f3hdr\f1.\f3count\f1 entries.
Each such entry contains 
\f3namelen\f1,
a saved \f3offset\f1 used when the directory is converted to a larger form,
a \f3name\f1 string,
and the \f3inumber\f1
.br
\f3symlink\f1: symbolic link string value
.sp
The following fields are in the \f3a\f1 attribute fork union if it exists:
.br
\f3bmbt\f1: bmap Btree root, as above
.br
\f3bmx\f1: array of extent descriptors
.br
\f3sfattr\f1: shortform (in-inode) attribute values.
This consists of
a \f3hdr\f1 containing
a \f3totsize\f1 (total size in bytes)
and a \f3count\f1 of active entries,
followed by
an array \f3list\f1 of \f3hdr\f1.\f3count\f1 entries.
Each such entry contains
\f3namelen\f1,
\f3valuelen\f1,
\f3root\f1 flag,
\f3name\f1,
and \f3value\f1
.TP
\f3log\f1
Log blocks contain the journal entries for XFS.
It's not useful to examine these with \f2xfs_db\f1,
use \f2xfs_logprint\f1(1M) instead.
.TP
\f3rtbitmap\f1
If the filesystem has a realtime subvolume, then the \f3rbmino\f1 field
in the superblock refers to a file that contains the realtime bitmap.
Each bit in the bitmap file controls the allocation of a single realtime extent
(set == free).
The bitmap is processed in 32-bit words,
the LSB of a word is used for the first extent controlled by that bitmap word.
The \f3atime\f1 field of the realtime bitmap inode contains a counter
that is used to control where the next new realtime file will start.
.TP
\f3rtsummary\f1
If the filesystem has a realtime subvolume,
then the \f3rsumino\f1 field in the superblock refers to a file
that contains the realtime summary data.
The summary file contains a two-dimensional array of 16-bit values.
Each value counts the number of free extent runs
(consecutive free realtime extents)
of a given range of sizes that starts in a given bitmap block.
The size ranges are binary buckets (low size in the bucket is a power of 2).
There are as many size ranges as are necessary given the size of the
realtime subvolume.
The first dimension is the size range,
the second dimension is the starting bitmap block number
(adjacent entries are for the same size, adjacent bitmap blocks).
.TP
\f3sb\f1
There is one sb (superblock) structure per allocation group.
It is the first disk block in the allocation group.
Only the first one (block 0 of the filesystem) is actually used;
the other blocks are redundant information for \f2xfs_repair\f1(1M)
to use if the first superblock is damaged.
Fields defined:
.br
\f3magicnum\f1: superblock magic number, 0x58465342 ('XFSB')
.br
\f3blocksize\f1: filesystem block size in bytes
.br
\f3dblocks\f1: number of filesystem blocks present in the data subvolume
.br
\f3rblocks\f1: number of filesystem blocks present in the realtime subvolume
.br
\f3rextents\f1: number of realtime extents that \f3rblocks\f1 contain
.br
\f3uuid\f1: unique identifier of the filesystem
.br
\f3logstart\f1: starting filesystem block number of the log (journal).
If this value is 0 the log is ``external''
.br
\f3rootino\f1: root inode number
.br
\f3rbmino\f1: realtime bitmap inode number
.br
\f3rsumino\f1: realtime summary data inode number
.br
\f3rextsize\f1: realtime extent size in filesystem blocks
.br
\f3agblocks\f1: size of an allocation group in filesystem blocks
.br
\f3agcount\f1: number of allocation groups
.br
\f3rbmblocks\f1: number of realtime bitmap blocks
.br
\f3logblocks\f1: number of log blocks (filesystem blocks)
.br
\f3versionnum\f1: filesystem version information.
This value is currently 1, 2, 3, or 4 in the low 4 bits.
If the low bits are 4 then the other bits have additional meanings.
1 is the original value.
2 means that attributes were used.
3 means that version 2 inodes (large link counts) were used.
4 is the bitmask version of the version number.
In this case, the other bits are used as flags
(0x0010: attributes were used,
0x0020: version 2 inodes were used,
0x0040: quotas were used,
0x0080: inode cluster alignment is in force,
0x0100: data stripe alignment is in force,
0x0200: the \f3shared_vn\f1 field is used,
0x1000: unwritten extent tracking is on,
0x2000: version 2 directories are in use)
.br
\f3sectsize\f1: sector size in bytes, currently always 512.
This is the size of the superblock and the other header blocks
.br
\f3inodesize\f1: inode size in bytes
.br
\f3inopblock\f1: number of inodes per filesystem block
.br
\f3fname\f1: obsolete, filesystem name
.br
\f3fpack\f1: obsolete, filesystem pack name
.br
\f3blocklog\f1: log2 of \f3blocksize\f1
.br
\f3sectlog\f1: log2 of \f3sectsize\f1
.br
\f3inodelog\f1: log2 of \f3inodesize\f1
.br
\f3inopblog\f1: log2 of \f3inopblock\f1
.br
\f3agblklog\f1: log2 of \f3agblocks\f1 (rounded up)
.br
\f3rextslog\f1: log2 of \f3rextents\f1
.br
\f3inprogress\f1: \f2mkfs_xfs\f1(1M) aborted before completing this filesystem
.br
\f3imax_pct\f1: maximum percentage of filesystem space used for inode blocks
.br
\f3icount\f1: number of allocated inodes
.br
\f3ifree\f1: number of allocated inodes that are not in use
.br
\f3fdblocks\f1: number of free data blocks
.br
\f3frextents\f1: number of free realtime extents
.br
\f3uquotino\f1: user quota inode number
.br
\f3pquotino\f1: project quota inode number; this is currently unused
.br
\f3qflags\f1: quota status flags
(0x01: user quota accounting is on,
0x02: user quota limits are enforced,
0x04: quotacheck has been run on user quotas,
0x08: project quota accounting is on,
0x10: project quota limits are enforced,
0x20: quotacheck has been run on project quotas)
.br
\f3flags\f1: random flags.
0x01: only read-only mounts are allowed
.br
\f3shared_vn\f1: shared version number (shared readonly filesystems)
.br
\f3inoalignmt\f1: inode chunk alignment in filesystem blocks
.br
\f3unit\f1: stripe or RAID unit
.br
\f3width\f1: stripe or RAID width
.br
\f3dirblklog\f1: log2 of directory block size (filesystem blocks)
.TP
\f3symlink\f1
Symbolic link blocks are used only when the symbolic link value does
not fit inside the inode.
The block content is just the string value.
Bytes past the logical end of the symbolic link value have arbitrary values.
.SH DIAGNOSTICS
Many messages can come from the \f3check\f1 (\f3blockget\f1) command;
these are documented in \f2xfs_check\f1(1M).
.SH SEE ALSO
mkfs_xfs(1M),
xfs_check(1M),
xfs_copy(1M),
xfs_logprint(1M),
xfs_ncheck(1M),
xfs_repair(1M),
chmod(2),
mknod(2),
stat(2),
xfs(4).
