'\"! tbl | eqn | mmdoc
'\"macro stdmacro
.\" Copyright 1991 UNIX System Laboratories, Inc.
.\" Copyright 1989, 1990 AT&T
.nr X
.if \nX=0 .ds x} terminfo 4 "Terminal Information Utilities" "\&"
.TH \*(x}
'\" ident	"@(#)svid_ti:ti_env/terminfo	1.13"
.\" Copyright 1991 UNIX System Laboratories, Inc.
.SH NAME
\f4terminfo\f1 \- terminal capability data base
.SH SYNOPSIS
.nf
\f4/usr/share/lib/terminfo/?/\(**\f1
.fi
.SH DESCRIPTION
\f4terminfo\f1 is a database produced by \f4tic\f1 that describes
the capabilities of devices such as terminals and printers.
Devices are described in \f4terminfo\f1 source files
by specifying a set of capabilities,
by quantifying certain aspects of the device,
and by specifying character sequences that effect particular results.
This database is often used by screen oriented applications
such as \f4vi\f1 and \f4curses\fP programs,
as well as by some UNIX system commands such as \f4ls\f1 and \f4more\f1.
This usage allows them to work with a variety of devices
without changes to the programs.
.PP
\f4terminfo\f1 source files consist of one or more device descriptions.
Each description consists of a header
(beginning in column 1) and one or more lines
that list the features for that particular device.
Every line in a \f4terminfo\f1 source file must end in a comma (\f4,\fP).
Every line in a \f4terminfo\f1 source file except the header must be
indented with one or more white spaces (either spaces or tabs).
.PP
Entries in \f4terminfo\f1 source files
consist of a number of comma-separated fields.
White space after each comma is ignored.
Embedded commas must be escaped by using a backslash.
The following example shows the format of a \f4terminfo\f1 source file.
.IP
.EQ
delim $$
.EN
.TS
l l.
.\"	column 1
.\".sp .5
.\"	\s+6\f4\(da\f1\s0
.\" .sp .5
$alias sub 1$ | $alias sub 2$ | ... | $alias sub n$ | \f2longname\f1,
\f2<white space>\f1 \f4am, lines #24,\fP
\f2<white space>\f1 \f4home=\\\\Eeh,\fP
.TE
.EQ
delim off
.EN
.P
The first line, commonly referred to as the header line,
must begin in column one and must contain
at least two aliases separated by vertical bars.
The last field in the header line must be the long name of the device
and it may contain any string.
Alias names must be unique in the \f4terminfo\f1 database
and they must conform to UNIX system file naming conventions [see \f4tic\fP(1M)];
they cannot, for example, contain white space or slashes.
.P
Every device must be assigned a name, such as "vt100".
Device names (except the long name)
should be chosen using the following conventions.
The name should not contain hyphens because hyphens are reserved for use
when adding suffixes that indicate special modes.
.P
These special modes may be modes that the hardware can be in,
or user preferences.
To assign a special mode to a particular device, append a suffix
consisting of a hyphen and an indicator of the mode to the device name.
For example, the \f4-w\f1 suffix means "wide mode"; when specified,
it allows for a width of 132 columns instead of the standard 80 columns.
Therefore, if you want to use a vt100 device set to wide mode,
name the device "vt100-w."
Use the following suffixes where possible.
.PP
.TS
l l l.
Suffix	Meaning	Example
.sp .8v
\f4-w\f1	Wide mode (more than 80 columns)	5410-w
\f4-am\f1	With auto. margins (usually default)	vt100-am
\f4-nam\f1	Without automatic margins	vt100-nam
\f2-n\f1	Number of lines on the screen	2300-40
\f4-na\f1	No arrow keys (leave them in local)	c100-na
-\f2n\f1p	Number of pages of memory	c100-4p
\f4-rv\f1	Reverse video	4415-rv
.TE
.PP
The \f4terminfo\f1 reference manual page
is organized in two sections: "DEVICE CAPABILITIES" and "PRINTER CAPABILITIES."
.SS "PART 1: DEVICE CAPABILITIES"
Capabilities in \f4terminfo\f1 are of three types: Boolean capabilities
(which show that a device has or does not have a particular feature),
numeric capabilities (which quantify particular features of a device),
and string capabilities (which provide sequences that can be used to perform
particular operations on devices).
.PP
In the following table, a \f3Variable\f1
is the name by which a \f3C\f1 programmer
accesses a capability (at the \f4terminfo\f1 level).
A \f3Capname\f1 is the short name for
a capability specified in the \f4terminfo\f1 source file.
It is used by a person updating the source file
and by the \f4tput\f1 command.
A \f3Termcap Code\f1 is a two-letter sequence that corresponds to the
\f4termcap\f1 capability name.
(Note that \f4termcap\f1 is no longer supported.)
.P
Capability names have no real length limit,
but an informal limit of five characters has been adopted to keep them short.
Whenever possible, capability names are chosen to be the same as or similar to
those specified by the ANSI X3.64-1979 standard.
Semantics are also intended to match those of the ANSI standard.
.P
All string capabilities listed below may have
padding specified, with the exception of those used for input.
Input capabilities, listed under the
\f3Strings\f1 section in the following tables,
have names beginning with \f4key_\f1.
The \f4#i\f1 symbol in the description field
of the following tables refers to the \f2i\f1th parameter.
.SS Booleans
.TS H
l l l l
l l l l
lf4 lf4 lf4 l.
	Cap-	Termcap		
Variable	name	Code	Description
.sp .8v
auto_left_margin	bw	bw	\f4cub1\f1 wraps from column 0 to
			last column
auto_right_margin	am	am	Terminal has automatic
			margins
back_color_erase	bce	be	Screen erased with background
			color
can_change	ccc	cc	Terminal can redefine
			existing color
ceol_standout_glitch	xhp	xs	Standout not erased by
			overwriting (hp)
col_addr_glitch	xhpa	YA	Only positive motion for
			\f4hpa\f1/\f4mhpa\f1 caps
cpi_changes_res	cpix	YF	Changing character pitch
			changes resolution
cr_cancels_micro_mode	crxm	YB	Using \f4cr\f1 turns off micro mode
eat_newline_glitch	xenl	xn	Newline ignored after 80
			columns (Concept)
erase_overstrike	eo	eo	Can erase overstrikes with a
			blank
generic_type	gn	gn	Generic line type (\f2e.g.\f1,
			dialup, switch)
hard_copy	hc	hc	Hardcopy terminal
hard_cursor	chts	HC	Cursor is hard to see
has_meta_key	km	km	Has a meta key (shift, sets
			parity bit)
has_print_wheel	daisy	YC	Printer needs operator to
			change character set
has_status_line	hs	hs	Has extra "status line"
hue_lightness_saturation	hls	hl	Terminal uses only HLS color
			notation (Tektronix)
insert_null_glitch	in	in	Insert mode distinguishes
			nulls
lpi_changes_res	lpix	YG	Changing line pitch changes
			resolution
memory_above	da	da	Display may be retained above
			the screen
memory_below	db	db	Display may be retained below
			the screen
move_insert_mode	mir	mi	Safe to move while in insert
			mode
move_standout_mode	msgr	ms	Safe to move in standout
			modes
needs_xon_xoff	nxon	nx	Padding won't work, xon/xoff
			required	
no_esc_ctlc	xsb	xb	Beehive (f1=escape,
			f2=ctrl C)
non_rev_rmcup	nrrmc	NR	\f4smcup\f1 does not reverse \f4rmcup\f1
no_pad_char	npc	NP	Pad character doesn't exist
over_strike	os	os	Terminal overstrikes on
			hard-copy terminal
prtr_silent	mc5i	5i	Printer won't echo on screen
row_addr_glitch	xvpa	YD	Only positive motion for
			\f4vpa\f1/\f4mvpa\f1 caps
semi_auto_right_margin	sam	YE	Printing in last column
			causes \f4cr\f1
status_line_esc_ok	eslok	es	Escape can be used on the
			status line
dest_tabs_magic_smso	xt	xt	Destructive tabs, magic \f4smso\f1
			char (t1061)
tilde_glitch	hz	hz	Hazeltine; can't print
			tilde (~)
transparent_underline	ul	ul	Underline character
			overstrikes
xon_xoff	xon	xo	Terminal uses xon/xoff
			handshaking
.TE
.SS Numbers
.TS H
l l l l
l l l l
lf4 lf4 lf4 l.
	Cap-	Termcap		
Variable	name	Code	Description
.sp .8v
buffer_capacity	bufsz	Ya	Number of bytes buffered before
			printing
columns	cols	co	Number of columns in a line
dot_vert_spacing	spinv	Yb	Spacing of pins vertically in
			pins per inch
dot_horz_spacing	spinh	Yc	Spacing of dots horizontally in
			dots per inch
init_tabs	it	it	Tabs initially every # spaces
label_height	lh	lh	Number of rows in each label
label_width	lw	lw	Number of columns in each label
lines	lines	li	Number of lines on a screen or a
			page
lines_of_memory	lm	lm	Lines of memory if > \f4lines\f1; \f40\f1
			means varies
magic_cookie_glitch	xmc	sg	Number of blank characters left
			by \f4smso\f1 or \f4rmso\f1
max_colors	colors	Co	Maximum number of colors on the
			screen
max_micro_address	maddr	Yd	Maximum value in
			\f4micro_..._address\f1
max_micro_jump	mjump	Ye	Maximum value in \f4parm_..._micro\f1
max_pairs	pairs	pa	Maximum number of color-pairs on
			the screen
micro_col_size	mcs	Yf	Character step size when in
			micro mode
micro_line_size	mls	Yg	Line step size when in micro
			mode
no_color_video	ncv	NC	Video attributes that can't be
			used with colors
number_of_pins	npins	Yh	Number of pins in print-head
num_labels	nlab	Nl	Number of labels on screen
			(start at 1)
output_res_char	orc	Yi	Horizontal resolution in units
			per character
output_res_line	orl	Yj	Vertical resolution in units per
			line
output_res_horz_inch	orhi	Yk	Horizontal resolution in units
			per inch
output_res_vert_inch	orvi	Yl	Vertical resolution in units per
			inch
padding_baud_rate	pb	pb	Lowest baud rate where padding
			needed
virtual_terminal	vt	vt	Virtual terminal number (UNIX
			system)	
wide_char_size	widcs	Yn	Character step size when in
			double wide mode
width_status_line	wsl	ws	Number of columns in status line
.TE
.SS Strings
.TS H
l l l l
l l l l
lf4 lf4 lf4 l.
	Cap-	Termcap		
Variable	name	Code	Description
.sp .8v
acs_chars	acsc	ac	Graphic charset pairs
			aAbBcC
alt_scancode_esc	scesca	S8	Alternate escape for
			scancode emulation
			(default is for vt100)
back_tab	cbt	bt	Back tab
bell	bel	bl	Audible signal (bell)
bit_image_repeat	birep	Zy	Repeat bit-image cell
			#1 #2 times (use
			tparm)
bit_image_newline	binel	Zz	Move to next row of the
			bit image (use tparm)
bit_image_carriage_return	bicr	Yv	Move to beginning of same
			row (use tparm)
carriage_return	cr	cr	Carriage return
change_char_pitch	cpi	ZA	Change number of
			characters per inch
change_line_pitch	lpi	ZB	Change number of lines per
			inch
change_res_horz	chr	ZC	Change horizontal
			resolution
change_res_vert	cvr	ZD	Change vertical resolution
change_scroll_region	csr	cs	Change to lines #1 through
			#2 (vt100)
char_padding	rmp	rP	Like \f4ip\f1 but when in
			replace mode
char_set_names	csnm	Zy	List of character set
			names
clear_all_tabs	tbc	ct	Clear all tab stops
clear_margins	mgc	MC	Clear all margins (top,
			bottom, and sides)
clear_screen	clear	cl	Clear screen and home
			cursor
clr_bol	el1	cb	Clear to beginning of
			line, inclusive	
clr_eol	el	ce	Clear to end of line
clr_eos	ed	cd	Clear to end of display
code_set_init	csin	ci	Init sequence for multiple
			codesets
color_names	colornm	Yw	Give name for color #1
column_address	hpa	ch	Horizontal position
			absolute
command_character	cmdch	CC	Terminal settable cmd
			character in prototype
cursor_address	cup	cm	Move to row #1 col #2
cursor_down	cud1	do	Down one line
cursor_home	home	ho	Home cursor (if no \f4cup\f1)
cursor_invisible	civis	vi	Make cursor invisible
cursor_left	cub1	le	Move left one space.
cursor_mem_address	mrcup	CM	Memory relative cursor
			addressing
cursor_normal	cnorm	ve	Make cursor appear normal
			(undo \f4vs/vi\f1)
cursor_right	cuf1	nd	Non-destructive space
			(cursor or carriage right)
cursor_to_ll	ll	ll	Last line, first column
			(if no \f4cup\f1)
cursor_up	cuu1	up	Upline (cursor up)
cursor_visible	cvvis	vs	Make cursor very visible
define_bit_image_region	defbi	Yx	Define rectangular
			bit-image region (use
			tparm)
define_char	defc	ZE	Define a character in a
			character set\(dg
delete_character	dch1	dc	Delete character
delete_line	dl1	dl	Delete line
device_type	devt	dv	Indicate language/codeset
			support
dis_status_line	dsl	ds	Disable status line
display_pc_char	dispc	S1	Display PC character
down_half_line	hd	hd	Half-line down (forward
			1/2 linefeed)
ena_acs	enacs	eA	Enable alternate character
			set
end_bit_image_region	endbi	Yy	End a bit-image region
			(use tparm)
enter_alt_charset_mode	smacs	as	Start alternate character
			set
enter_am_mode	smam	SA	Turn on automatic margins	
enter_blink_mode	blink	mb	Turn on blinking
enter_bold_mode	bold	md	Turn on bold (extra
			bright) mode
enter_ca_mode	smcup	ti	String to begin programs
			that use \f4cup\f1
enter_delete_mode	smdc	dm	Delete mode (enter)
enter_dim_mode	dim	mh	Turn on half-bright mode
enter_doublewide_mode	swidm	ZF	Enable double wide
			printing
enter_draft_quality	sdrfq	ZG	Set draft quality print
enter_insert_mode	smir	im	Insert mode (enter)
enter_italics_mode	sitm	ZH	Enable italics
enter_leftward_mode	slm	ZI	Enable leftward carriage
			motion
enter_micro_mode	smicm	ZJ	Enable micro motion
			capabilities
enter_near_letter_quality	snlq	ZK	Set near-letter quality
			print
enter_normal_quality	snrmq	ZL	Set normal quality print
enter_pc_charset_mode	smpch	S2	Enter PC character display
			mode
enter_protected_mode	prot	mp	Turn on protected mode
enter_reverse_mode	rev	mr	Turn on reverse video mode
enter_scancode_mode	smsc	S4	Enter PC scancode mode
enter_secure_mode	invis	mk	Turn on blank mode
			(characters invisible)
enter_shadow_mode	sshm	ZM	Enable shadow printing
enter_standout_mode	smso	so	Begin standout mode
enter_subscript_mode	ssubm	ZN	Enable subscript printing
enter_superscript_mode	ssupm	ZO	Enable superscript
			printing
enter_underline_mode	smul	us	Start underscore mode
enter_upward_mode	sum	ZP	Enable upward carriage
			motion
enter_xon_mode	smxon	SX	Turn on xon/xoff
			handshaking
erase_chars	ech	ec	Erase #1 characters
exit_alt_charset_mode	rmacs	ae	End alternate character
			set	
exit_am_mode	rmam	RA	Turn off automatic margins
exit_attribute_mode	sgr0	me	Turn off all attributes
exit_ca_mode	rmcup	te	String to end programs
			that use \f4cup\f1
exit_delete_mode	rmdc	ed	End delete mode
exit_doublewide_mode	rwidm	ZQ	Disable double wide
			printing
exit_insert_mode	rmir	ei	End insert mode
exit_italics_mode	ritm	ZR	Disable italics
exit_leftward_mode	rlm	ZS	Enable rightward (normal)
			carriage motion
exit_micro_mode	rmicm	ZT	Disable micro motion
			capabilities
exit_pc_charset_mode	rmpch	S3	Disable PC character
			display mode
exit_scancode_mode	rmsc	S5	Disable PC scancode mode
exit_shadow_mode	rshm	ZU	Disable shadow printing
exit_standout_mode	rmso	se	End standout mode
exit_subscript_mode	rsubm	ZV	Disable subscript printing
exit_superscript_mode	rsupm	ZW	Disable superscript
			printing
exit_underline_mode	rmul	ue	End underscore mode
exit_upward_mode	rum	ZX	Enable downward (normal)
			carriage motion
exit_xon_mode	rmxon	RX	Turn off xon/xoff
			handshaking
flash_screen	flash	vb	Visible bell (may not move
			cursor)
form_feed	ff	ff	Hardcopy terminal page
			eject
from_status_line	fsl	fs	Return from status line
init_1string	is1	i1	Terminal or printer
			initialization string
init_2string	is2	is	Terminal or printer
			initialization string
init_3string	is3	i3	Terminal or printer
			initialization string
init_file	if	if	Name of initialization
			file
init_prog	iprog	iP	Pathname of program for
			initialization
initialize_color	initc	Ic	Initialize the definition
			of color
initialize_pair	initp	Ip	Initialize color-pair
insert_character	ich1	ic	Insert character
insert_line	il1	al	Add new blank line
insert_padding	ip	ip	Insert pad after character
			inserted
.TE
.P
The ``\f4key_\fP'' strings are sent by specific keys.
The ``\f4key_\fP'' descriptions include the macro, defined in
\f4curses.h\fP, for the code returned by the \f4curses\fP routine
\f4getch\fP when the key is pressed [see curs_getch(3X)].
.P
.TS
l l l l
l l l l
lw22f4 lf4 lf4 l.
	Cap-	Termcap		
Variable	name	Code	Description
.sp .8v
key_a1	ka1	K1	\f4KEY_A1\f1, upper left of keypad
key_a3	ka3	K3	\f4KEY_A3\f1, upper right of keypad
key_b2	kb2	K2	\f4KEY_B2\f1, center of keypad
key_backspace	kbs	kb	\f4KEY_BACKSPACE\f1, sent by
			backspace key
key_beg	kbeg	@1	\f4KEY_BEG\f1, sent by beg(inning)
			key	
key_btab	kcbt	kB	\f4KEY_BTAB\f1, sent by back-tab key
key_c1	kc1	K4	\f4KEY_C1\f1, lower left of keypad
key_c3	kc3	K5	\f4KEY_C3\f1, lower right of keypad
key_cancel	kcan	@2	\f4KEY_CANCEL\f1, sent by cancel key	
key_catab	ktbc	ka	\f4KEY_CATAB\f1, sent by
			clear-all-tabs key
key_clear	kclr	kC	\f4KEY_CLEAR\f1, sent by clear-screen
			or erase key
key_close	kclo	@3	\f4KEY_CLOSE\f1, sent by close key
key_command	kcmd	@4	\f4KEY_COMMAND\f1, sent by cmd
			(command) key
key_copy	kcpy	@5	\f4KEY_COPY\f1, sent by copy key
key_create	kcrt	@6	\f4KEY_CREATE\f1, sent by create key
key_ctab	kctab	kt	\f4KEY_CTAB\f1, sent by clear-tab key
key_dc	kdch1	kD	\f4KEY_DC\f1, sent by
			delete-character key
key_dl	kdl1	kL	\f4KEY_DL\f1, sent by delete-line key
key_down	kcud1	kd	\f4KEY_DOWN\f1, sent by terminal
			down-arrow key
key_eic	krmir	kM	\f4KEY_EIC\f1, sent by \f4rmir\f1 or \f4smir\f1
			in insert mode
key_end	kend	@7	\f4KEY_END\f1, sent by end key
key_enter	kent	@8	\f4KEY_ENTER\f1, sent by enter/send
			key
key_eol	kel	kE	\f4KEY_EOL\f1, sent by
			clear-to-end-of-line key
key_eos	ked	kS	\f4KEY_EOS\f1, sent by
			clear-to-end-of-screen key
key_exit	kext	@9	\f4KEY_EXIT\f1, sent by exit key
key_f0	kf0	k0	\f4KEY_F(0)\f1, sent by function
			key f0
key_f1	kf1	k1	\f4KEY_F(1)\f1, sent by function
			key f1
key_f2	kf2	k2	\f4KEY_F(2)\f1, sent by function
			key f2
key_f3	kf3	k3	\f4KEY_F(3)\f1, sent by function
			key f3
key_f4	kf4	k4	\f4KEY_F(4)\f1, sent by function
			key f4
key_f5	kf5	k5	\f4KEY_F(5)\f1, sent by function
			key f5
key_f6	kf6	k6	\f4KEY_F(6)\f1, sent by function
			key f6
key_f7	kf7	k7	\f4KEY_F(7)\f1, sent by function
			key f7
key_f8	kf8	k8	\f4KEY_F(8)\f1, sent by function
			key f8
key_f9	kf9	k9	\f4KEY_F(9)\f1, sent by function
			key f9
key_f10	kf10	k;	\f4KEY_F(10)\f1, sent by function
			key f10
key_f11	kf11	F1	\f4KEY_F(11)\f1, sent by function
			key f11
key_f12	kf12	F2	\f4KEY_F(12)\f1, sent by function
			key f12
key_f13	kf13	F3	\f4KEY_F(13)\f1, sent by function
			key f13
key_f14	kf14	F4	\f4KEY_F(14)\f1, sent by function
			key f14
key_f15	kf15	F5	\f4KEY_F(15)\f1, sent by function
			key f15
key_f16	kf16	F6	\f4KEY_F(16)\f1, sent by function
			key f16
key_f17	kf17	F7	\f4KEY_F(17)\f1, sent by function
			key f17
key_f18	kf18	F8	\f4KEY_F(18)\f1, sent by function
			key f18
key_f19	kf19	F9	\f4KEY_F(19)\f1, sent by function
			key f19
key_f20	kf20	FA	\f4KEY_F(20)\f1, sent by function
			key f20
key_f21	kf21	FB	\f4KEY_F(21)\f1, sent by function
			key f21
key_f22	kf22	FC	\f4KEY_F(22)\f1, sent by function
			key f22
key_f23	kf23	FD	\f4KEY_F(23)\f1, sent by function
			key f23
key_f24	kf24	FE	\f4KEY_F(24)\f1, sent by function
			key f24
key_f25	kf25	FF	\f4KEY_F(25)\f1, sent by function
			key f25
key_f26	kf26	FG	\f4KEY_F(26)\f1, sent by function
			key f26
key_f27	kf27	FH	\f4KEY_F(27)\f1, sent by function
			key f27
key_f28	kf28	FI	\f4KEY_F(28)\f1, sent by function
			key f28
key_f29	kf29	FJ	\f4KEY_F(29)\f1, sent by function
			key f29
key_f30	kf30	FK	\f4KEY_F(30)\f1, sent by function
			key f30
key_f31	kf31	FL	\f4KEY_F(31)\f1, sent by function
			key f31
key_f32	kf32	FM	\f4KEY_F(32)\f1, sent by function
			key f32
key_f33	kf33	FN	\f4KEY_F(13)\f1, sent by function
			key f13
key_f34	kf34	FO	\f4KEY_F(34)\f1, sent by function
			key f34
key_f35	kf35	FP	\f4KEY_F(35)\f1, sent by function
			key f35
key_f36	kf36	FQ	\f4KEY_F(36)\f1, sent by function
			key f36
key_f37	kf37	FR	\f4KEY_F(37)\f1, sent by function
			key f37
key_f38	kf38	FS	\f4KEY_F(38)\f1, sent by function
			key f38
key_f39	kf39	FT	\f4KEY_F(39)\f1, sent by function
			key f39
key_f40	kf40	FU	\f4KEY_F(40)\f1, sent by function
			key f40
key_f41	kf41	FV	\f4KEY_F(41)\f1, sent by function
			key f41
key_f42	kf42	FW	\f4KEY_F(42)\f1, sent by function
			key f42
key_f43	kf43	FX	\f4KEY_F(43)\f1, sent by function
			key f43
key_f44	kf44	FY	\f4KEY_F(44)\f1, sent by function
			key f44
key_f45	kf45	FZ	\f4KEY_F(45)\f1, sent by function
			key f45
key_f46	kf46	Fa	\f4KEY_F(46)\f1, sent by function
			key f46
key_f47	kf47	Fb	\f4KEY_F(47)\f1, sent by function
			key f47
key_f48	kf48	Fc	\f4KEY_F(48)\f1, sent by function
			key f48
key_f49	kf49	Fd	\f4KEY_F(49)\f1, sent by function
			key f49
key_f50	kf50	Fe	\f4KEY_F(50)\f1, sent by function
			key f50
key_f51	kf51	Ff	\f4KEY_F(51)\f1, sent by function
			key f51
key_f52	kf52	Fg	\f4KEY_F(52)\f1, sent by function
			key f52
key_f53	kf53	Fh	\f4KEY_F(53)\f1, sent by function
			key f53
key_f54	kf54	Fi	\f4KEY_F(54)\f1, sent by function
			key f54
key_f55	kf55	Fj	\f4KEY_F(55)\f1, sent by function
			key f55
key_f56	kf56	Fk	\f4KEY_F(56)\f1, sent by function
			key f56
key_f57	kf57	Fl	\f4KEY_F(57)\f1, sent by function
			key f57
key_f58	kf58	Fm	\f4KEY_F(58)\f1, sent by function
			key f58
key_f59	kf59	Fn	\f4KEY_F(59)\f1, sent by function
			key f59
key_f60	kf60	Fo	\f4KEY_F(60)\f1, sent by function
			key f60
key_f61	kf61	Fp	\f4KEY_F(61)\f1, sent by function
			key f61
key_f62	kf62	Fq	\f4KEY_F(62)\f1, sent by function
			key f62
key_f63	kf63	Fr	\f4KEY_F(63)\f1, sent by function
			key f63
key_find	kfnd	@0	\f4KEY_FIND\f1, sent by find key
key_help	khlp	%1	\f4KEY_HELP\f1, sent by help key
key_home	khome	kh	\f4KEY_HOME\f1, sent by home key
key_ic	kich1	kI	\f4KEY_IC\f1, sent by ins-char/enter
			ins-mode key
key_il	kil1	kA	\f4KEY_IL\f1, sent by insert-line key
key_left	kcub1	kl	\f4KEY_LEFT\f1, sent by terminal
			left-arrow
			key
key_ll	kll	kH	\f4KEY_LL\f1, sent by home-down key
key_mark	kmrk	%2	\f4KEY_MARK\f1, sent by mark key
key_message	kmsg	%3	\f4KEY_MESSAGE\f1, sent by message
			key
key_move	kmov	%4	\f4KEY_MOVE\f1, sent by move key
key_next	knxt	%5	\f4KEY_NEXT\f1, sent by
			next-object key
key_npage	knp	kN	\f4KEY_NPAGE\f1, sent by
			next-page key
key_open	kopn	%6	\f4KEY_OPEN\f1, sent by open key
key_options	kopt	%7	\f4KEY_OPTIONS\f1, sent by options
			key
key_ppage	kpp	kP	\f4KEY_PPAGE\f1, sent by
			previous-page key
key_previous	kprv	%8	\f4KEY_PREVIOUS\f1, sent by
			previous-object key
key_print	kprt	%9	\f4KEY_PRINT\f1, sent by print or
			copy key
key_redo	krdo	%0	\f4KEY_REDO\f1, sent by redo key
key_reference	kref	&1	\f4KEY_REFERENCE\f1, sent by
			ref(erence) key
key_refresh	krfr	&2	\f4KEY_REFRESH\f1, sent by refresh
			key
key_replace	krpl	&3	\f4KEY_REPLACE\f1, sent by replace
			key
key_restart	krst	&4	\f4KEY_RESTART\f1, sent by restart
			key
key_resume	kres	&5	\f4KEY_RESUME\f1, sent by resume key
key_right	kcuf1	kr	\f4KEY_RIGHT\f1, sent by terminal
			right-arrow key
key_save	ksav	&6	\f4KEY_SAVE\f1, sent by save key
key_sbeg	kBEG	&9	\f4KEY_SBEG\f1, sent by shifted
			beginning key
key_scancel	kCAN	&0	\f4KEY_SCANCEL\f1, sent by shifted
			cancel key
key_scommand	kCMD	\(**1	\f4KEY_SCOMMAND\f1, sent by shifted
			command key
key_scopy	kCPY	\(**2	\f4KEY_SCOPY\f1, sent by shifted copy
			key
key_screate	kCRT	\(**3	\f4KEY_SCREATE\f1, sent by shifted
			create key
key_sdc	kDC	\(**4	\f4KEY_SDC\f1, sent by shifted
			delete-char key
key_sdl	kDL	\(**5	\f4KEY_SDL\f1, sent by shifted
			delete-line key
key_select	kslt	\(**6	\f4KEY_SELECT\f1, sent by select key
key_send	kEND	\(**7	\f4KEY_SEND\f1, sent by shifted end
			key
key_seol	kEOL	\(**8	\f4KEY_SEOL\f1, sent by shifted
			clear-line key
key_sexit	kEXT	\(**9	\f4KEY_SEXIT\f1, sent by shifted exit
			key
key_sf	kind	kF	\f4KEY_SF\f1, sent by
			scroll-forward/down key
key_sfind	kFND	\(**0	\f4KEY_SFIND\f1, sent by shifted find
			key
key_shelp	kHLP	#1	\f4KEY_SHELP\f1, sent by shifted help
			key
key_shome	kHOM	#2	\f4KEY_SHOME\f1, sent by shifted home
			key
key_sic	kIC	#3	\f4KEY_SIC\f1, sent by shifted input
			key
key_sleft	kLFT	#4	\f4KEY_SLEFT\f1, sent by shifted
			left-arrow key
key_smessage	kMSG	%a	\f4KEY_SMESSAGE\f1, sent by shifted
			message key
key_smove	kMOV	%b	\f4KEY_SMOVE\f1, sent by shifted move
			key
key_snext	kNXT	%c	\f4KEY_SNEXT\f1, sent by shifted next
			key
key_soptions	kOPT	%d	\f4KEY_SOPTIONS\f1, sent by shifted
			options key
key_sprevious	kPRV	%e	\f4KEY_SPREVIOUS\f1, sent by shifted
			prev key
key_sprint	kPRT	%f	\f4KEY_SPRINT\f1, sent by shifted
			print key
key_sr	kri	kR	\f4KEY_SR\f1, sent by
			scroll-backward/up key
key_sredo	kRDO	%g	\f4KEY_SREDO\f1, sent by shifted redo
			key
key_sreplace	kRPL	%h	\f4KEY_SREPLACE\f1, sent by shifted
			replace key
key_sright	kRIT	%i	\f4KEY_SRIGHT\f1, sent by shifted
			right-arrow key
key_srsume	kRES	%j	\f4KEY_SRSUME\f1, sent by shifted
			resume key
key_ssave	kSAV	!1	\f4KEY_SSAVE\f1, sent by shifted save
			key
key_ssuspend	kSPD	!2	\f4KEY_SSUSPEND\f1, sent by shifted
			suspend key
key_stab	khts	kT	\f4KEY_STAB\f1, sent by set-tab key
key_sundo	kUND	!3	\f4KEY_SUNDO\f1, sent by shifted undo
			key
key_suspend	kspd	&7	\f4KEY_SUSPEND\f1, sent by suspend
			key
key_undo	kund	&8	\f4KEY_UNDO\f1, sent by undo key
key_up	kcuu1	ku	\f4KEY_UP\f1, sent by terminal
			up-arrow key
keypad_local	rmkx	ke	Out of ``keypad-transmit'' mode
keypad_xmit	smkx	ks	Put terminal in
			``keypad-transmit'' mode
lab_f0	lf0	l0	Labels on function key f0 if
			not f0
lab_f1	lf1	l1	Labels on function key f1 if
			not f1
lab_f2	lf2	l2	Labels on function key f2 if
			not f2
lab_f3	lf3	l3	Labels on function key f3 if
			not f3
lab_f4	lf4	l4	Labels on function key f4 if
			not f4
lab_f5	lf5	l5	Labels on function key f5 if
			not f5
lab_f6	lf6	l6	Labels on function key f6 if
			not f6
lab_f7	lf7	l7	Labels on function key f7 if
			not f7
lab_f8	lf8	l8	Labels on function key f8 if
			not f8
lab_f9	lf9	l9	Labels on function key f9 if
			not f9
lab_f10	lf10	la	Labels on function key f10 if
			not f10
label_off	rmln	LF	Turn off soft labels
label_on	smln	LO	Turn on soft labels
meta_off	rmm	mo	Turn off "meta mode"
meta_on	smm	mm	Turn on "meta mode" (8th bit)
micro_column_address	mhpa	ZY	Like \f4column_address\f1 for micro
			adjustment
micro_down	mcud1	ZZ	Like \f4cursor_down\f1 for micro
			adjustment
micro_left	mcub1	Za	Like \f4cursor_left\f1 for micro
			adjustment
micro_right	mcuf1	Zb	Like \f4cursor_right\f1 for micro
			adjustment
micro_row_address	mvpa	Zc	Like \f4row_address\f1 for micro
			adjustment
micro_up	mcuu1	Zd	Like \f4cursor_up\f1 for micro
			adjustment
newline	nel	nw	Newline (behaves like \f4cr\f1
			followed by \f4lf\f1)
order_of_pins	porder	Ze	Matches software bits to
			print-head pins
orig_colors	oc	oc	Set all color(-pair)s to the
			original ones
orig_pair	op	op	Set default color-pair to the
			original one
pad_char	pad	pc	Pad character (rather than
			null)
parm_dch	dch	DC	Delete #1 chars
parm_delete_line	dl	DL	Delete #1 lines
parm_down_cursor	cud	DO	Move down #1 lines
parm_down_micro	mcud	Zf	Like \f4parm_down_cursor\f1 for micro
			adjustment
parm_ich	ich	IC	Insert #1 blank chars
parm_index	indn	SF	Scroll forward #1 lines
parm_insert_line	il	AL	Add #1 new blank lines
parm_left_cursor	cub	LE	Move cursor left #1 spaces
parm_left_micro	mcub	Zg	Like \f4parm_left_cursor\f1 for micro
			adjustment
parm_right_cursor	cuf	RI	Move right #1 spaces
parm_right_micro	mcuf	Zh	Like \f4parm_right_cursor\f1 for
			micro adjustment
parm_rindex	rin	SR	Scroll backward #1 lines
parm_up_cursor	cuu	UP	Move cursor up #1 lines
parm_up_micro	mcuu	Zi	Like \f4parm_up_cursor\f1 for micro
			adjustment
pc_term_options	pctrm	S6	PC terminal options
pkey_key	pfkey	pk	Prog funct key #1 to type
			string #2
pkey_local	pfloc	pl	Prog funct key #1 to execute
			string #2
pkey_plab	pfxl	xl	Prog key #1 to xmit string #2
			and show string #3
pkey_xmit	pfx	px	Prog funct key #1 to xmit
			string #2
plab_norm	pln	pn	Prog label #1 to show string #2
print_screen	mc0	ps	Print contents of the screen
prtr_non	mc5p	pO	Turn on the printer for #1
			bytes
prtr_off	mc4	pf	Turn off the printer
prtr_on	mc5	po	Turn on the printer
repeat_char	rep	rp	Repeat char #1 #2 times
req_for_input	rfi	RF	Send next input char (for ptys)
reset_1string	rs1	r1	Reset terminal completely to
			sane modes
reset_2string	rs2	r2	Reset terminal completely to
			sane modes
reset_3string	rs3	r3	Reset terminal completely to
			sane modes
reset_file	rf	rf	Name of file containing reset
			string
restore_cursor	rc	rc	Restore cursor to position of
			last sc
row_address	vpa	cv	Vertical position absolute
save_cursor	sc	sc	Save cursor position
scancode_escape	scesc	S7	Escape for scancode emulation
scroll_forward	ind	sf	Scroll text up
scroll_reverse	ri	sr	Scroll text down
select_char_set	scs	Zj	Select character set
set0_des_seq	s0ds	s0	Shift into codeset 0 (EUC set
			0, ASCII)
set1_des_seq	s1ds	s1	Shift into codeset 1
set2_des_seq	s2ds	s2	Shift into codeset 2
set3_des_seq	s3ds	s3	Shift into codeset 3
set_a_background	setab	AB	Set background color using ANSI
			escape
set_a_foreground	setaf	AF	Set foreground color using ANSI
			escape
set_attributes	sgr	sa	Define the video attributes
			#1-#9
set_background	setb	Sb	Set current background color
set_bottom_margin	smgb	Zk	Set bottom margin at current
			line
set_bottom_margin_parm	smgbp	Zl	Set bottom margin at line #1
			or #2 lines from bottom
set_color_band	setcolor	Yz	Change to ribbon color #1
set_color_pair	scp	sp	Set current color-pair
set_foreground	setf	Sf	Set current foreground color1
set_left_margin	smgl	ML	Set left margin at current line
set_left_margin_parm	smglp	Zm	Set left (right) margin at
			column #1 (#2)
set_lr_margin	smglr	ML	Sets both left and right
			margins
set_page_length	slines	YZ	Set page length to #1 lines
			(use tparm)
set_pglen_inch	slength	YI	Set page length to #1
			hundredths of an inch (use
			tparm)
set_right_margin	smgr	MR	Set right margin at current
			column
set_right_margin_parm	smgrp	Zn	Set right margin at column #1
set_tab	hts	st	Set a tab in all rows, current
			column
set_tb_margin	smgtb	MT	Sets both top and bottom
			margins
set_top_margin	smgt	Zo	Set top margin at current line
set_top_margin_parm	smgtp	Zp	Set top (bottom) margin at
			line #1 (#2)
set_window	wind	wi	Current window is lines #1-#2
			cols #3-#4
start_bit_image	sbim	Zq	Start printing bit image
			graphics
start_char_set_def	scsd	Zr	Start definition of a character
			set
stop_bit_image	rbim	Zs	End printing bit image
			graphics
stop_char_set_def	rcsd	Zt	End definition of a character
			set
subscript_characters	subcs	Zu	List of ``subscriptable''
			characters
superscript_characters	supcs	Zv	List of ``superscriptable''
			characters
tab	ht	ta	Tab to next 8-space hardware
			tab stop
these_cause_cr	docr	Zw	Printing any of these chars
			causes \f4cr\f1
to_status_line	tsl	ts	Go to status line, col #1
underline_char	uc	uc	Underscore one char and move
			past it
up_half_line	hu	hu	Half-line up (reverse 1/2
			linefeed)
xoff_character	xoffc	XF	X-off character
xon_character	xonc	XN	X-on character
zero_motion	zerom	Zx	No motion for the subsequent
			character
.TE
.in +.4i
.SS Sample Entry
The following entry, which describes the AT&T 610 terminal,
is among the more complex entries in the
\f4terminfo\f1 file as of this writing.
.PP
.ta .2i
.nf
.ft4
610|610bct|ATT610|att610|AT&T610;80column;98key keyboard
	am, eslok, hs, mir, msgr, xenl, xon,
	cols#80, it#8, lh#2, lines#24, lw#8, nlab#8, wsl#80,
	acsc=``aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,
	bel=^G, blink=\eE[5m, bold=\eE[1m, cbt=\eE[Z,
	civis=\eE[?25l, clear=\eE[H\eE[J, cnorm=\eE[?25h\eE[?12l,
	cr=\er, csr=\eE[%i%p1%d;%p2%dr, cub=\eE[%p1%dD, cub1=\eb,
	cud=\eE[%p1%dB, cud1=\eE[B, cuf=\eE[%p1%dC, cuf1=\eE[C,
	cup=\eE[%i%p1%d;%p2%dH, cuu=\eE[%p1%dA, cuu1=\eE[A,
	cvvis=\eE[?12;25h, dch=\eE[%p1%dP, dch1=\eE[P, dim=\eE[2m,
	dl=\eE[%p1%dM, dl1=\eE[M, ed=\eE[J, el=\eE[K, el1=\eE[1K,
	flash=\eE[?5h$<200>\eE[?5l, fsl=\eE8, home=\eE[H, ht=\et,
	ich=\eE[%p1%d@, il=\eE[%p1%dL, il1=\eE[L, ind=\eED, .ind=\eED$<9>,
	invis=\eE[8m,
	is1=\eE[8;0 | \eE[?3;4;5;13;15l\eE[13;20l\eE[?7h\eE[12h\eE(B\eE)0,
	is2=\eE[0m^O, is3=\eE(B\eE)0, kLFT=\eE[\es@, kRIT=\eE[\esA,
	kbs=^H, kcbt=\eE[Z, kclr=\eE[2J, kcub1=\eE[D, kcud1=\eE[B,
	kcuf1=\eE[C, kcuu1=\eE[A, kf1=\eEOc, kf10=\eENp,
	kf11=\eENq, kf12=\eENr, kf13=\eENs, kf14=\eENt, kf2=\eEOd,
	kf3=\eEOe, kf4=\eEOf, kf5=\eEOg, kf6=\eEOh, kf7=\eEOi,
	kf8=\eEOj, kf9=\eENo, khome=\eE[H, kind=\eE[S, kri=\eE[T,
	ll=\eE[24H, mc4=\eE[?4i, mc5=\eE[?5i, nel=\eEE,
	pfxl=\eE[%p1%d;%p2%l%02dq%?%p1%{9}%<%t\es\es\esF%p1%1d\es\es\es\es\es
\es\es\es\es\es\es%;%p2%s,
	pln=\eE[%p1%d;0;0;0q%p2%:-16.16s, rc=\eE8, rev=\eE[7m,
	ri=\eEM, rmacs=^O, rmir=\eE[4l, rmln=\eE[2p, rmso=\eE[m,
	rmul=\eE[m, rs2=\eEc\eE[?3l, sc=\eE7,
	sgr=\eE[0%?%p6%t;1%;%?%p5%t;2%;%?%p2%t;4%;%?%p4%t;5%;
%?%p3%p1% | %t;7%;%?%p7%t;8%;m%?%p9%t^N%e^O%;,
	sgr0=\eE[m^O, smacs=^N, smir=\eE[4h, smln=\eE[p,
	smso=\eE[7m, smul=\eE[4m, tsl=\eE7\eE[25;%i%p1%dx,
.ft
.fi
.SS "Types of Capabilities in the Sample Entry"
The sample entry shows the formats for the three types
of \f4terminfo\f1 capabilities listed: Boolean,
numeric, and string.
All capabilities specified in the \f4terminfo\f1 source file
must be followed by commas,
including the last capability in the source file.
In \f4terminfo\f1 source files,
capabilities are referenced by their capability names
(as shown in the previous tables).
.P
Boolean capabilities are specified
simply by their comma separated cap names.
.PP
Numeric capabilities are followed by the character `#'
and then a positive integer value.
Thus, in the sample,
\f4cols\f1 (which shows the number of columns available on a device)
is assigned the value \f480\f1 for the AT&T 610.
(Values for numeric capabilities
may be specified in decimal, octal, or hexadecimal,
using normal C programming language conventions.)
.PP
Finally, string-valued capabilities
such as \f4el\f1 (clear to end of line
sequence) are listed by a two- to five-character capname,
an `=', and a string ended by the next occurrence of a comma.
A delay in milliseconds may appear
anywhere in such a capability, preceded by \f4$\f1 and enclosed in angle brackets,
as in \f4el=\eEK$<3>\f1.
Padding characters are supplied by \f4tput\f1.
The delay can be any of the following: a number,
a number followed by an asterisk, such as \f45\(**\f1,
a number followed by a slash, such as \f45/\f1,
or a number followed by both, such as \f45\(**/\f1.
A
\f1`\f4\(**\f4'\f1
shows that the padding required is proportional
to the number of lines affected by the operation,
and the amount given
is the per-affected-unit padding required.
(In the case of insert characters, the factor is still the number of
lines affected.
This is always 1 unless the device has
\f4in\f1
and the software uses it.)
When a
\f1`\f4\(**\f4'\f1
is specified, it is sometimes useful to give a delay of the form
\f43.5\f1 to specify a delay per unit to tenths of milliseconds.
(Only one decimal place is allowed.)
.PP
A `/' indicates that the padding is mandatory.
If a device has
\f4xon\f1
defined,
the padding information is advisory and will only be used for cost
estimates or when the device is in raw mode.
Mandatory padding will be transmitted regardless of the setting of
\f4xon\f1.\f1
If padding (whether advisory or mandatory)
is specified for \f4bel\f1 or \f4flash\f1, however,
it will always be used,
regardless of whether \f4xon\f1 is specified.
.PP
\f4terminfo\f1 offers notation for encoding special characters.
Both \f4\eE\f1 and \f4\ee\f1 map to an ESCAPE character,
\f2^x\f1 maps to a control \f2x\f1 for any appropriate \f2x\f1,
and the sequences
\f4\en, \el, \er, \et, \eb, \ef\f1, and \f4\es\f1 give
a newline, linefeed, return, tab, backspace, formfeed, and space, respectively.
Other escapes include: \f4\e^\f1 for caret (^);
\f4\e\e\f1 for backslash (\e); \f4\e\f1, for comma (,); \f4\e:\f1 for colon (:);
and \f4\e0\f1 for null.
(\f4\e0\f1 will actually produce \f4\e200\f1,
which does not terminate a string but behaves
as a null character on most devices,
providing CS7 is specified.
[See \f4stty\fP(1).]
Finally, characters may be given as three octal digits after a
backslash (for example, \e123).
.PP
Sometimes individual capabilities must be commented out.
To do this, put a period before the capability name.
For example, see the second
\f4ind\f1
in the example above.
Note that capabilities are defined in a
left-to-right order and, therefore,
a prior definition will override a later
definition.
.SS "Preparing Descriptions"
The most effective way to prepare a device description
is by imitating the description of a similar device in
\f4terminfo\f1
and building up a description gradually, using partial descriptions
with \f4vi\f1 to check that they are correct.
Be aware that a very unusual device may expose deficiencies
in the ability of the \f4terminfo\f1 file to describe it
or the inability of \f4vi\f1 to work with that device.
To test a new device description, set the environment variable
\f4TERMINFO\f1 to the pathname of a directory containing the
compiled description you are working
on and programs will look there rather than in
\f4/usr/share/lib/terminfo\f1.
To get the padding for insert-line correct (if the device manufacturer
did not document it) a severe test is to comment out \f4xon\f1,
edit a large file at 9600 baud with \f4vi\f1,
delete 16 or so lines from the middle of the screen,
and then press the \f4u\f1 key several times quickly.
If the display is corrupted, more padding is usually needed.
A similar test can be used for insert-character.
.SS "Section 1-1: Basic Capabilities"
The number of columns on each line for the device is given by the
\f4cols\f1 numeric capability.
.RF 38
If the device has a screen, then the
number of lines on the screen is given by the \f4lines\f1 capability.
.RF 44
If the device wraps around to the beginning of the next line when
it reaches the right margin, then it should have the \f4am\f1 capability.
If the terminal can clear its screen, leaving the cursor in the home
position, then this is given by the \f4clear\f1 string capability.
.RF 78
If the terminal overstrikes
(rather than clearing a position when a character is struck over)
then it should have the \f4os\f1 capability.
.RF 28
If the device is a printing terminal, with no soft copy unit,
specify both
\f4hc\f1
.RF 12
and
\f4os\f1.\f1
If there is a way to move the cursor to the left edge of the current
row, specify this as
\f4cr\f1.\f1
.RF 68
(Normally this will be carriage return, control M.)
If there is a way to produce an audible signal
(such as a bell or a beep),
specify it as
\f4bel\f1.\f1
.RF 67
If, like most devices,
the device uses the xon-xoff flow-control protocol,
specify
\f4xon\f1.\f1
.RF 36
.PP
If there is a way to move the cursor one position to the left
(such as backspace), that capability should be given as
\f4cub1\f1.\f1
.RF 88
Similarly, sequences to move to the right, up, and down should be
given as
\f4cuf1\f1,
.RF 91
\f4cuu1\f1,
.RF 93
and
\f4cud1\f1,
.RF 85
respectively.
These local cursor motions must not alter the text they pass over;
for example, you would not normally use ``\f4cuf1\f1=\es'' because the
space would erase the character moved over.
.PP
A very important point here is that the local cursor motions encoded
.RF 1
in
\f4terminfo\f1
are undefined at the left and top edges of a screen terminal.
Programs should never attempt to backspace around the left edge,
unless \f4bw\f1 is specified,
and should never attempt to go up locally off the top.
To scroll text up, a program goes to the bottom left corner
of the screen and sends the
\f4ind\f1
.RF 365
(index) string.
.PP
To scroll text down, a program goes to the top left corner
of the screen and sends the
\f4ri\f1
.RF 366
(reverse index) string.
The strings
\f4ind\f1
and
\f4ri\f1
are undefined when not on their respective corners of the screen.
.PP
Parameterized versions of the scrolling sequences are
\f4indn\f1
.RF 339
and \f4rin\f1.
.RF 345
These versions have the same semantics as
\f4ind\f1
and
\f4ri\f1,
except that they take one parameter and scroll
the number of lines specified by that parameter.
They are also undefined except at the appropriate edge of the screen.
.PP
The \f4am\f1 capability tells whether the cursor sticks at the right
.RF 2
edge of the screen when text is output, but this does not necessarily
apply to a \f4cuf1\f1 from the last column.
Backward motion from the left edge of the screen
is possible only when \f4bw\f1 is specified.
In this case, \f4cub1\f1 will move to the right edge of the previous row.
If \f4bw\f1 is not given, the effect is undefined.
This is useful for drawing a box around the edge of the screen, for example.
If the device has switch selectable automatic margins,
\f4am\f1 should be specified in the \f4terminfo\f1 source file.
In this case,
initialization strings should turn on this option, if possible.
If the device has a command that moves to the first column of the next line,
that command can be given as \f4nel\f1
.RF 329
(newline).
It does not matter if the command clears the remainder of the current line,
so if the device has no \f4cr\f1
.RF 68
and \f4lf\f1
.RF 150
it may still be possible to craft a working
\f4nel\f1 out of one or both of them.
.PP
These capabilities suffice to describe hardcopy and screen terminals.
Thus the AT&T 5320 hardcopy terminal is described as follows:
.PP
.nf
   \f45320|att5320|AT&T 5320 hardcopy terminal,
	  am, hc, os,
	  cols#132,
	  bel=^G, cr=\er, cub1=\eb, cnd1=\en,
	  dch1=\eE[P, dl1=\eE[M,
	  ind=\en,
while the Lear Siegler ADM\-3 is described as
.fi
.nf
   \f4adm3|lsi adm3,
   am, bel=^G, clear=^Z, cols#80, cr=^M, cub1=^H,
   cud1=^J, ind=^J, lines#24\f1,
.fi
.SS "Section 1-2: Parameterized Strings"
.PP
Cursor addressing and other strings requiring parameters
are described by a parameterized string capability, with
\f4printf\f1-like\f1
escapes (\f4%\f2x\f1) in it.
For example, to address the cursor, the
\f4cup\f1
.RF 84
capability is given, using two parameters:
the row and column to address to.
(Rows and columns are numbered from zero and refer to the
physical screen visible to the user, not to any unseen memory.)
If the terminal has memory relative cursor addressing,
that can be indicated by
\f4mrcup\f1.\f1
.RF 89
.PP
The parameter mechanism uses a stack and special \f4%\f1 codes
to manipulate the stack
in the manner of Reverse Polish Notation (postfix).
Typically a sequence will push one of the
parameters onto the stack and then print it in some format.
Often more complex operations are necessary.
Operations are in postfix form with the operands in the usual order.
That is, to subtract 5 from the first parameter,
one would use \f4%p1%{5}%\-\f1.
.PP
The \f4%\f1 encodings have the following meanings:
.TP 10
\f4%%\fP
outputs `%'
.TP
\f4%[[:]\f2flags\f1][\f2width\f1[\f2.precision\f1]][\f4doxXs\f1]\fP
as in \f4printf\fP, flags are \f4[\-+#]\f1 and space
.TP
\f4%c\fP
print pop gives %c
.TP
\f4%p[1-9]\fP
push \f2i\f1th parm
.TP
\f4%P[a-z]\fP
set dynamic variable [a-z] to pop
.TP
\f4%g[a-z]\fP
get dynamic variable [a-z] and push it
.TP
\f4%P[A-Z]\fP
set static variable [a-z] to pop
.TP
\f4%g[A-Z]\fP
get static variable [a-z] and push it
.TP
\f4%'\f2c\fP'\f1
push char constant \f2c\f1
.TP
\f4%{\f2nn\fP}\f1
push decimal constant \f2nn\f1
.TP
\f4%l\fP
push strlen(pop)
.TP
\f4%+ %\- %\(** %/ %m\fP
.EQ
delim $$
.EN
arithmetic (\f4%m\fP is mod): push(pop $integer sub 2$ op pop $integer sub 1$)
.TP
\f4%& %| %^\fP
bit operations: push(pop $integer sub 2$ op pop $integer sub 1$)
.TP
\f4%= %> %<\fP
logical operations: push(pop $integer sub 2$ op pop $integer sub 1$)
.EQ
delim off
.EN
.TP
\f4%A %O\fP
logical operations: and, or
.TP
\f4%! %~\fP
unary operations: push(op pop)
.TP
\f4%i\fP
(for ANSI terminals)
add 1 to first parm, if one parm present,
or first two parms, if more than one parm present
.TP
\f4%? \f2expr\fP %t \f2thenpart\fP %e \f2elsepart\fP %;\f1
if-then-else, \f4%e\fP \f2elsepart\fP is optional;
else-if's are possible ala Algol 68:
\f4%? c\d\u %t b\d\u %e c\d\u %t b\d\u %e c\d\u %t b\d\u %e c\d\u %t b\d\u %e b\d\u%;\fP
.br
c\d\f2i\fP\u are conditions, b\d\f2i\fP\u are bodies.
.DT
.PP
If the ``\f4\-\fP'' flag is used with ``\f4%\fP[\fPdoxXs\f1]'',
then a colon (\f4:\fP) must be placed
between the ``\f4%\fP'' and the ``\f4\-\fP''
to differentiate the flag from the binary ``\f4%\-\fP''
operator, for example, ``\f4%:\-16.16s\fP''.
.PP
Consider the Hewlett-Packard 2645, which, to get to row 3 and column 12, needs
to be sent \f4\eE&a12c03Y\f1 padded for 6 milliseconds.
Note that the order
of the rows and columns is inverted here, and that the row and column
are zero-padded as two digits.
Thus its \f4cup\f1 capability is:
.Ex
cup=\eE&a%p2%2.2dc%p1%2.2dY$<6>
.Ee
The Micro-Term ACT-IV needs the current row and column sent
preceded by a \f4^T\f1, with the row and column simply encoded in binary,
``\f4cup=^T%p1%c%p2%c\f1''.
Devices that use ``\f4%c\fP'' need to be able to
backspace the cursor (\f4cub1\f1),
and to move the cursor up one line on the screen (\f4cuu1\f1).
This is necessary because it is not always safe to transmit \f4\en\f1,
\f4^D\f1, and \f4\er\f1, as the system may change or discard them.
(The library routines dealing with \f4terminfo\f1 set tty modes so that
tabs are never expanded, so \f4\et\f1 is safe to send.
This turns out to be essential for the Ann Arbor 4080.)
.PP
A final example is the LSI ADM-3a, which uses row and column
offset by a blank character, thus
``\f4cup=\eE=%p1%'\es'%+%c%p2%'\es'%+%c\f1''.
After sending ``\f4\eE=\f1'', this pushes the first parameter, pushes the
ASCII value for a space (32), adds them (pushing the sum on the stack
in place of the two previous values), and outputs that value as a character.
Then the same is done for the second parameter.
More complex arithmetic is possible using the stack.
.SS "Section 1-3: Cursor Motions"
If the terminal has a fast way to home the cursor
(to very upper left corner of screen) then this can be given as
\f4home\f1; similarly a fast way of getting to the lower left-hand corner
.RF 86
can be given as \f4ll\f1; this may involve going up with \f4cuu1\f1
.RF 92
from the home position,
but a program should never do this itself (unless \f4ll\f1 does) because it
can make no assumption about the effect of moving up from the home position.
Note that the home position is the same as addressing to (0,0):
to the top left corner of the screen, not of memory.
(Thus, the \f4\eEH\f1 sequence
on Hewlett-Packard terminals cannot be used for
\f4home\f1
without losing some of the other features on the terminal.)
.PP
If the device has row or column absolute-cursor addressing,
these can be given as single parameter capabilities
\f4hpa\f1
.RF 82
(horizontal position absolute)
and
\f4vpa\f1
.RF 363
(vertical position absolute).
Sometimes these are shorter than the more general two-parameter
sequence (as with the Hewlett-Packard 2645)
and can be used in preference to
\f4cup\f1.\f1
If there are parameterized local motions (for example, move
\f2n\f1
spaces to the right) these can be given as
\f4cud\f1,
.RF 336
\f4cub\f1,
.RF 341
\f4cuf\f1,
.RF 343
and
\f4cuu\f1
.RF 346
with a single parameter indicating how many spaces to move.
These are primarily useful if the device does not have
\f4cup\f1,
such as the Tektronix 4025.
.PP
If the device needs to be in a special mode when running
a program that uses these capabilities,
the codes to enter and exit this mode
can be given as \f4smcup\f1
.RF 105
and \f4rmcup\f1.
.RF 130
This arises, for example,
from terminals, such as the Concept,
with more than one page of memory.
If the device has only memory relative cursor addressing and not screen
relative cursor addressing, a one screen-sized window must be fixed into
the device for cursor addressing to work properly.
This is also used for the Tektronix 4025,
where
\f4smcup\f1
sets the command character to be the one used by
\f4terminfo\f1.\f1
If the \f4smcup\f1 sequence will not restore the
screen after an \f4rmcup\f1 sequence is output
(to the state prior to outputting \f4rmcup\f1),
specify \f4nrrmc\f1.
.RF 26
.SS "Section 1-4: Area Clears"
.PP
If the terminal can clear from the current position to the end of the
line, leaving the cursor where it is, this should be given as \f4el\f1.
.RF 80
If the terminal can clear from the beginning of the line to the current
position inclusive,
leaving the cursor where it is, this should be given as \f4el1\f1.
If the terminal can clear from the current position to the end of the
display, then this should be given as \f4ed\f1.
.RF 81
\f4ed\f1 is only defined from the first column of a line.
(Thus, it can be simulated by a request to delete a large number of lines,
if a true
\f4ed\f1
is not available.)
.SS "Section 1-5: Insert/Delete Line"
.PP
If the terminal can open a new blank line before the line where the cursor
is, this should be given as \f4il1\f1; this is done only from the first
.RF 155
position of a line.
The cursor must then appear on the newly blank line.
If the terminal can delete the line which the cursor is on, then this
should be given as \f4dl1\f1; this is done only from the first position on
.RF 97
the line to be deleted.
Versions of
\f4il1\f1
and
\f4dl1\f1
which take a single parameter and insert or delete that many lines can
be given as
\f4il\f1
.RF 340
and
\f4dl\f1.\f1
.RF 335
.P
If the terminal has a settable destructive scrolling region (like the VT100)
the command to set this can be described with the
\f4csr\f1
.RF 73
capability, which takes two parameters:
the top and bottom lines of the scrolling region.
The cursor position is, alas, undefined after using this command.
It is possible to get the effect of insert or delete line using
this command \-\- the
\f4sc\f1
.RF 364
and
\f4rc\f1
.RF 362
(save and restore cursor) commands are also useful.
Inserting lines at the top or bottom of the screen can also be
done using
\f4ri\f1
or
\f4ind\f1
on many terminals without a true insert/delete line,
and is often faster even on terminals with those features.
.P
To determine whether a terminal has destructive scrolling
regions or non-destructive scrolling regions,
create a scrolling region in the middle of the screen,
place data on the bottom line of the scrolling region,
move the cursor to the top line of the
scrolling region, and do a reverse index (\f4ri\f1) followed
by a delete line (\f4dl1\f1) or index (\f4ind\f1).
If the data that was originally on the bottom line
of the scrolling region was restored into the scrolling
region by the \f4dl1\f1 or \f4ind\f1,
then the terminal has non-destructive scrolling regions.
Otherwise, it has destructive scrolling regions.
Do not specify \f4csr\f1 if the terminal has
non-destructive scrolling regions,
unless \f4ind\f1, \f4ri\f1,
\f4indn\f1, \f4rin\f1, \f4dl\f1, and \f4dl1\f1 all
simulate destructive scrolling.
.PP
If the terminal has the ability to define a window as part of
memory, which all commands affect,
it should be given as the parameterized string
\f4wind\f1.\f1
The four parameters are the starting and ending lines in memory
and the starting and ending columns in memory, in that order.
.PP
If the terminal can retain display memory above, then the
\f4da\f1 capability should be given; if display memory can be retained
.RF 20
below, then \f4db\f1 should be given.
.RF 21
These indicate
that deleting a line or scrolling a full screen
may bring non-blank lines up from below
or that scrolling back with \f4ri\f1 may bring down non-blank lines.
.SS "Section 1-6: Insert/Delete Character"
.PP
There are two basic kinds of intelligent terminals with respect to
insert/delete character operations which can be described using
\f4terminfo.\f1
The most common insert/delete character operations
affect only the characters
on the current line and shift characters off the end of the line rigidly.
Other terminals,
such as the Concept 100 and the Perkin Elmer Owl, make
a distinction between typed and untyped blanks on the screen, shifting
upon an insert or delete only to an untyped blank on the screen which is
either eliminated, or expanded to two untyped blanks.
You can determine the kind of terminal you have by clearing the screen and
then typing text separated by cursor motions.
Type ``\f4abc\f1\ \ \ \ \f4def\f1'' using
local cursor motions (not spaces) between the
\f4abc\f1 and the \f4def\f1.
Then position the cursor before the
\f4abc\f1 and put the terminal in insert mode.
If typing characters causes the rest of the line to shift rigidly and
characters to fall off the end, then your terminal does not distinguish
between blanks and untyped positions.
If the \f4abc\f1 shifts over to the
\f4def\f1 which then move together around the
end of the current line and onto the next as you insert, you have the second
type of terminal, and should give the capability \f4in\f1, which stands for
.RF 18
``insert null.''
While these are two logically separate attributes (one line versus multiline
insert mode, and special treatment of untyped spaces) we have seen no
terminals whose insert mode cannot be described with the single attribute.
.PP
\f4terminfo\f1
can describe both terminals that have an insert mode and terminals
which send a simple sequence to open a blank position on the current line.
Give as \f4smir\f1 the sequence to get into insert mode.
.RF 110
Give as \f4rmir\f1 the sequence to leave insert mode.
.RF 133
Now give as \f4ich1\f1 any sequence needed to be sent just before sending
.RF 154
the character to be inserted.
Most terminals with a true insert mode will not give \f4ich1\f1; terminals
that send a sequence to open a screen position should give it here.
(If your terminal has both, insert mode is usually preferable to \f4ich1\f1.
Do not give both unless the terminal actually requires both to be used in
combination.)
If post-insert padding is needed, give this as a number of milliseconds
padding in
\f4ip\f1
(a string option).
Any other sequence which may need to be sent after an insert of a single
character may also be given in
\f4ip\f1.\f1
.RF 156
If your terminal needs both to be placed into an `insert mode' and
a special code to precede each inserted character, then both
\f4smir\f1/\f1rmir\f1
and
\f4ich1\f1
can be given, and both will be used.
The
\f4ich\f1
capability, with one parameter,
.IR n ,
will insert
.I n
blanks.
.PP
If padding is necessary between characters typed while
not
in insert mode, give this as a number of milliseconds padding in
\f4rmp\f1.\f1
.RF 74
.PP
It is occasionally necessary to move around while in insert mode
to delete characters on the same line (for example, if there is a tab after
the insertion position).
If your terminal allows motion while in insert mode you can give the
capability
\f4mir\f1
.RF 22
to speed up inserting in this case.
Omitting
\f4mir\f1
will affect only speed.
Some terminals (notably Datamedia's) must not have \f4mir\f1 because of the
way their insert mode works.
.PP
Finally, you can specify
\f4dch1\f1
.RF 96
to delete a single character,
\f4dch\f1
.RF 334
with one parameter,
.IR n ,
to delete
\f2n\f1
characters,
and delete mode by giving
\f4smdc\f1
.RF 106
and
\f4rmdc\f1
.RF 131
to enter and exit delete mode (any mode the terminal needs to be placed
in for
\f4dch1\f1
to work).
.PP
A command to erase
\f2n\f1
characters (equivalent to outputting
\f2n\f1
blanks without moving the cursor)
can be given as
\f4ech\f1
.RF 126
with one parameter.
.SS "Section 1-7: Highlighting, Underlining, and Visible Bells"
.PP
Your device may have one or more kinds of display attributes
that allow you to highlight selected characters
when they appear on the screen.
The following display modes
(shown with the names by which they are set)
may be available:
a blinking screen (\f4blink\f1),
.RF 103
bold or extra-bright characters (\f4bold\f1),
.RF 104
dim or half-bright characters (\f4dim\f1),
.RF 107
blanking or invisible text (\f4invis\f1),
protected text (\f4prot\f1),
.RF 116
a reverse-video screen (\f4rev\f1),
.RF 117
and an alternate character set
(\f4smacs\f1 to enter this mode and
.RF 101
\f4rmacs\f1 to exit it).
(If a command is necessary
before you can enter alternate character set mode,
give the sequence in
\f4enacs\f1
.RF 100
or "enable alternate-character-set" mode.)
Turning on any of these modes singly may or may not turn off other modes.
.PP
\f4sgr0\f1 should be
used to turn off all video enhancement capabilities.
It should always be specified because
it represents the only way to turn off some capabilities,
such as \f4dim\f1 or \f4blink\f1.
.RF 129
.PP
You should choose one display method as
.IR "standout mode"
[see \f4curses\fP(3X)]
and use it to highlight error messages and other
kinds of text to which you want to draw attention.
Choose a form of display that provides strong contrast
but that is easy on the eyes.
(We recommend reverse-video plus half-bright
or reverse-video alone.)
The sequences to enter and exit standout mode are
given as
\f4smso\f1
.RF 120
and
\f4rmso\f1,
.RF 138
respectively.
If the code to change into or out of standout
mode leaves one or even two blank spaces on the screen,
as the TVI 912 and Teleray 1061 do,
then
\f4xmc\f1
.RF 46
should be given to tell how many spaces are left.
.PP
Sequences to begin underlining and end underlining can be specified as
\f4smul\f1
.RF 123
and
\f4rmul ,\f1
.RF 141
respectively.
If the device has a sequence
to underline the current character
and to move the cursor one space to the right
(such as the Micro-Term MIME),
this sequence can be specified as
\f4uc\f1.\f1
.PP
Terminals with the ``magic cookie'' glitch
\f1(\f4xmc\f4)\f1
.RF 46
deposit special ``cookies'' when they receive mode-setting sequences,
which affect the display algorithm rather than having extra bits for
each character.
Some terminals,
such as the Hewlett-Packard 2621, automatically leave standout
mode when they move to a new line or the cursor is addressed.
Programs using standout mode should exit standout mode before
moving the cursor or sending a newline,
unless the
\f4msgr\f1
.RF 23
capability, asserting that it is safe to move in standout mode, is present.
.PP
If the terminal has
a way of flashing the screen to indicate an error quietly (a bell replacement),
then this can be given as \f4flash\f1; it must not move the cursor.
.RF 144
A good flash can be done by changing the screen
into reverse video, pad for 200 ms, then return the screen
to normal video.
.PP
If the cursor needs to be made more visible than normal when it is
not on the bottom line (to make, for example, a non-blinking underline into an
easier to find block or blinking underline)
give this sequence as
\f4cvvis\f1.\f1
.RF 94
The boolean
\f4chts\f1
.RF 13
should also be given.
If there is a way to make the cursor completely invisible, give that as
\f4civis\f1.\f1
.RF 87
The capability
\f4cnorm\f1
.RF 90
should be given which undoes the effects of either of these modes.
.PP
If your terminal generates underlined characters
by using the underline character
(with no special sequences needed)
even though it does not otherwise overstrike characters,
then you should specify the capability \f4ul\f1.
.RF 35
For devices on which a character overstriking another
leaves both characters on the screen,
specify the capability
\f4os\f1.\f1
.RF 28
If overstrikes are erasable with a blank,
then this should be indicated by specifying \f4eo\f1.
.RF 10
.PP
If there is a sequence to set arbitrary combinations of modes,
this should be given as
\f4sgr\f1
(set attributes),
taking nine parameters.
Each parameter is either
\f40\f1
or non-zero,
as the corresponding attribute is on or off.
The nine parameters are, in order:
standout, underline, reverse, blink, dim, bold, blank, protect, alternate
character set.
Not all modes need to be supported by
\f4sgr\f1;\f1
only those for which corresponding separate attribute commands exist
should be supported.
For example, let's assume that the terminal in question
needs the following escape sequences
to turn on various modes.
.PP
.TS
l l l
l l l
lf4 l lf4.
tparm
Parameter	Attribute	Escape Sequence
.sp .8v
	none	\eE[0m
p1	standout	\eE[0;4;7m
p2	underline	\eE[0;3m
p3	reverse	\eE[0;4m
p4	blink	\eE[0;5m
p5	dim	\eE[0;7m
p6	bold	\eE[0;3;4m
p7	invis	\eE[0;8m
p8	protect	\f1not available\f4
p9	altcharset	^O \f1(off)\fP ^N \f1(on)
.TE
.PP
Note that each escape sequence requires a
\f40\f1 to turn off other modes before
turning on its own mode.
Also note that, as suggested above,
\f2standout\f1 is set up to be the combination of
\f2reverse\f1 and \f2dim\f1.
Also, because this terminal has no \f2bold\f1 mode,
\f2bold\f1 is set up as the combination of \f2reverse\f1
and \f2underline\f1.
In addition, to allow combinations, such as \f2underline+blink\f1,
the sequence to use would be
\f4\eE[0;3;5m\f1.\f1
The terminal doesn't have \f2protect\f1 mode, either,
but that cannot be simulated in any way, so \f4p8\f1 is ignored.
The \f2altcharset\f1 mode is different in that it is either
\f4^O\f1 or \f4^N\f1, depending on whether it is off or on.
If all modes were to be turned on, the sequence would be
\f4\eE[0;3;4;5;7;8m^N\f1.\f1
.PP
Now look at when different sequences are output.
For example, \f4;3\f1 is output when either \f4p2\f1
or \f4p6\f1 is true, that is, if either
\f2underline\f1 or \f2bold\f1 modes are turned on.
Writing out the above sequences, along with their
dependencies, gives the following:
.PP
.TS
l l l
lf4 l lf4.
Sequence	When to Output	Terminfo Translation
.sp .8v
\eE[0	always	\eE[0
;3	if \f4p2\fP or \f4p6\fP	%?%p2%p6%|%t;3%;
;4	if \f4p1\fP or \f4p3\fP or \f4p6\fP	%?%p1%p3%|%p6%|%t;4%;
;5	if \f4p4\fP	%?%p4%t;5%;
;7	if \f4p1\fP or \f4p5\fP	%?%p1%p5%|%t;7%;
;8	if \f4p7\fP	%?%p7%t;8%;
m	always	m
^N \f1or\fP ^O	if \f4p9\fP \f4^N\fP, else \f4^O\fP	%?%p9%t^N%e^O%;
.TE
.PP
Putting this all together into the
\f4sgr\f1
sequence gives:
.PP
\f4sgr=\eE[0%?%p2%p6%|%t;3%;%?%p1%p3%|%p6%
.ti 1i
|%t;4%;%?%p5%t;5%;%?%p1%p5%
.ti 1i
|%t;7%;%?%p7%t;8%;m%?%p9%t^N%e^O%;,\f1
.PP
Remember that \f4sgr\f1 and \f4sgr0\f1 must always be specified.
.SS "Section 1-8: Keypad"
If the device has a keypad
that transmits sequences when the keys are pressed,
this information can also be specified.
Note that it is not possible to handle
devices where the keypad only works in local (this applies, for example,
to the unshifted Hewlett-Packard 2621 keys).
If the keypad can be set to transmit or not transmit,
specify these sequences as \f4smkx\f1
.RF 307
and \f4rmkx\f1.
.RF 306
Otherwise the keypad is assumed to always transmit.
.PP
The sequences sent by the left arrow,
right arrow, up arrow, down arrow,
and home keys can be given as \f4kcub1,
.RF 251
kcuf1,
.RF 269
kcuu1,
.RF 305
kcud1,
.RF 175
\f1and\f4 khome\f1, respectively.
.RF 248
If there are function keys such as f0, f1, ..., f63,
the sequences they send
can be specified as \f4kf0, kf1, ..., kf63\f1.
.RF 182
.RF 183
.RF 184
.RF 185
.RF 186
.RF 187
.RF 188
.RF 189
.RF 190
.RF 191
.RF 192
.RF 193
.RF 194
.RF 195
.RF 196
.RF 197
.RF 198
.RF 199
.RF 200
.RF 201
.RF 202
.RF 203
.RF 204
.RF 205
.RF 206
.RF 207
.RF 208
.RF 209
.RF 210
.RF 211
.RF 212
.RF 213
.RF 214
.RF 215
.RF 216
.RF 217
.RF 218
.RF 219
.RF 220
.RF 221
.RF 222
.RF 223
.RF 224
.RF 225
.RF 226
.RF 227
.RF 228
.RF 229
.RF 230
.RF 231
.RF 232
.RF 233
.RF 234
.RF 235
.RF 236
.RF 237
.RF 238
.RF 239
.RF 240
.RF 241
.RF 242
.RF 243
.RF 244
.RF 245
If the first 11 keys have labels other than the default f0 through f10,
the labels can be given as
\f4lf0, lf1, ..., lf10\f1.
.RF 308
.RF 309
.RF 310
.RF 311
.RF 312
.RF 313
.RF 314
.RF 315
.RF 316
.RF 317
.RF 318
The codes transmitted by certain other special keys can be given:
\f4kll\f1
.RF 252
(home down),
\f4kbs\f1
.RF 160
(backspace),
\f4ktbc\f1
.RF 166
(clear all tabs),
\f4kctab\f1
.RF 172
(clear the tab stop in this column),
\f4kclr\f1
.RF 167
(clear screen or erase key),
\f4kdch1\f1
.RF 173
(delete character),
\f4kdl1\f1
.RF 174
(delete line),
\f4krmir\f1
.RF 176
(exit insert mode),
\f4kel\f1
.RF 179
(clear to end of line),
\f4ked\f1
.RF 180
(clear to end of screen),
\f4kich1\f1
.RF 249
(insert character or enter insert mode),
\f4kil1\f1
.RF 250
(insert line),
\f4knp\f1
.RF 257
(next page),
\f4kpp\f1
.RF 260
(previous page),
\f4kind\f1
.RF 282
(scroll forward/down),
\f4kri\f1
.RF 294
(scroll backward/up),
\f4khts\f1
.RF 301
(set a tab stop in this column).
In addition, if the keypad has a 3 by 3 array of keys including the four
arrow keys, the other five keys can be given as
\f4ka1\f1,
.RF 157
\f4ka3\f1,
.RF 158
\f4kb2\f1,
.RF 159
\f4kc1\f1,
.RF 163
and
\f4kc3\f1.\f1
.RF 164
These keys are useful when
the effects of a 3 by 3 directional pad are needed.
Further keys are defined above in the capabilities list.
.PP
Strings to program function keys can be specified as
\f4pfkey\f1,
.RF 348
\f4pfloc\f1,
.RF 349
and
\f4pfx\f1.\f1
.RF 350
A string to program screen labels should be specified as
\f4pln\f1.\f1
.RF 351
Each of these strings takes two parameters: a function key identifier
and a string to program it with.
\f4pfkey\f1
causes pressing the given key to be the same as the user typing the
given string;
\f4pfloc\f1
causes the string to be executed by the terminal in local mode; and
\f4pfx\f1
causes the string to be transmitted to the computer.
The capabilities
\f4nlab\f1,
.RF 55
\f4lw\f1
.RF 43
and
\f4lh\f1
.RF 42
define the number of programmable screen labels
and their width and height.
If there are commands to turn the labels on and off, give them in
\f4smln\f1
.RF 320
and
\f4rmln\f1.\f1
.RF 319
\f4smln\f1
is normally output after one or more
\f4pln\f1
sequences to make sure that the change
becomes visible.
.SS "Section 1-9: Tabs and Initialization"
.PP
If the device has hardware tabs, the command to advance to the next
tab stop can be given as
\f4ht\f1
.RF 388
(usually control I).
A ``backtab'' command that moves leftward to the next tab stop can
be given as
\f4cbt\f1.\f1
.RF 66
By convention, if tty modes show that tabs are being
expanded by the computer rather than being sent to the device,
programs should not use
\f4ht\f1
or
\f4cbt\f1
(even if they are present)
because the user may not have the tab stops properly set.
If the device has hardware tabs that are initially set every
\f2n\f1
spaces when the device is powered up,
the numeric parameter
\f4it\f1
.RF 41
is given, showing the number of spaces the tabs are set to.
This is normally used by
\f4tput\f1
\f4init\f1
[see \f4tput\fP(1)]
to determine whether to set the mode for hardware tab expansion
and whether to set the tab stops.
If the device has tab stops that can be saved in nonvolatile memory,
the
\f4terminfo\f1
description can assume that they are properly set.
If there are commands to set and clear tab stops, they can be given as
\f4tbc\f1
.RF 76
(clear all tab stops)
and
\f4hts\f1
.RF 378
(set a tab stop in the current column of every row).
.PP
Other capabilities
include:
\f4is1\f1,
.RF 147
\f4is2\f1,
.RF 148
and
\f4is3\f1,
.RF 149
initialization strings for the device;
\f4iprog\f1,
.RF 151
the pathname of a program to be run to initialize the device;
and \f4if\f1, the name of a file containing long initialization strings.
These strings are expected to set the device into modes consistent
with the rest of the
\f4terminfo\f1
description.
They must be sent to the device
each time the user logs in and be output in the
following order:
run the program
\f4iprog\f1;\f1
output
\f4is1\f1;\f1
output
\f4is2\f1;\f1
set the margins using
\f4mgc\f1,
.RF 77
\f4smgl\f1
.RF 374
and
\f4smgr\f1;\f1
.RF 376
set the tabs using
\f4tbc\f1
and
\f4hts\f1;\f1
print the file
\f4if\f1;\f1
and finally output
\f4is3\f1.\f1
This is usually done using the \f4init\f1 option of \f4tput\f1.
.P
Most initialization is done with
\f4is2\f1.\f1
Special device modes can be set up without duplicating strings
by putting the common sequences in
\f4is2\f1
and special cases in
\f4is1\f1
and
\f4is3\f1.\f1
Sequences that do a reset from a totally unknown state
can be given as
\f4rs1\f1,
.RF 358
\f4rs2\f1,
.RF 359
\f4rf\f1,
.RF 361
and
\f4rs3\f1,
.RF 360
analogous to
\f4is1\f1,
\f4is2\f1,
\f4is3\f1,
and
\f4if\f1.\f1
(The method using files,
\f4if\f1
and
\f4rf\f1,
is used for a few terminals, from
\f4/usr/share/lib/tabset/\(**\f1;
however, the recommended method is to use the initialization and reset
strings.)
These strings are output by
\f4tput\f1 reset,
which is used when the terminal gets into a wedged state.
Commands are normally placed in
\f4rs1\f1,
\f4rs2\f1,
\f4rs3\f1,
and
\f4rf\f1
only if they produce annoying effects on the screen and are not
necessary when logging in.
For example, the command to set a terminal into 80-column mode would
normally be part of
\f4is2\f1,
but on some terminals
it causes an annoying glitch on the screen and is not normally
needed because the terminal is usually already in 80-column mode.
.PP
If a more complex sequence is needed to set the tabs than can be
described by using \f4tbc\f1 and \f4hts\f1, the sequence can be placed in
\f4is2\f1
or
\f4if\f1.\f1
.PP
Any margin can be cleared with \f4mgc\f1.
(For instructions on how to specify
commands to set and clear margins,
see "Margins" below under "PRINTER CAPABILITIES.")
.SS "Section 1-10: Delays"
Certain capabilities control padding in the \f4tty\f1 driver.
These are primarily needed by hard-copy terminals, and are used
by
\f4tput\f1
\f4init\f1
to set tty modes appropriately.
Delays embedded in the capabilities
\f4cr\f1,
\f4ind\f1,
\f4cub1\f1,
\f4ff\f1,
.RF 145
and
\f4tab\f1
can be used to set the appropriate delay bits to be set in the tty driver.
If
\f4pb\f1
.RF 60
(padding baud rate)
is given,
these values can be ignored at baud rates below the value of
\f4pb\f1.\f1
.SS "Section 1-11: Status Lines"
If the terminal has an extra ``status line'' that is not normally
used by software, this fact can be indicated.
If the status line is viewed as an extra line below the bottom line,
into which one can cursor address normally
(such as the Heathkit h19's 25th line, or the 24th line of a VT100
which is set to a 23-line scrolling region),
the capability
\f4hs\f1
.RF 16
should be given.
Special strings
that go to a given column of the status
line and return from the status line can be given as
\f4tsl\f1
.RF 390
and
\f4fsl\f1.\f1
.RF 146
\f1(\f4fsl\f1
must leave the cursor position in the same place it was before
\f4tsl\f1.\f1
If necessary, the
\f4sc\f1
and
\f4rc\f1
strings can be included in
\f4tsl\f1
and
\f4fsl\f1
to get this effect.)
The capability
\f4tsl\f1
takes one parameter, which is the column number of the status line
the cursor is to be moved to.
.PP
If escape sequences and other special commands, such as tab, work
while in the status line, the flag
\f4eslok\f1
.RF 32
can be given.
A string which turns off the status line (or otherwise erases its
contents) should be given as
\f4dsl\f1.\f1
.RF 98
If the terminal has commands to save and restore the position of the cursor,
give them as
\f4sc\f1
and
\f4rc\f1.\f1
The status line is normally assumed to be the same width as the rest
of the screen, for example, \f4cols\f1.
.RF 38
If the status line is a different width (possibly because
the terminal does not allow an entire line to be loaded) the width, in columns,
can be indicated with the numeric parameter
\f4wsl\f1.\f1
.RF 64
.SS "Section 1-12: Line Graphics"
If the device has a line drawing alternate character set, the mapping of
glyph to character would be given in
\f4acsc\f1.\f1
.RF 65
The definition of this string is based on the alternate character set used
in the DEC VT100 terminal, extended slightly with some characters from the
AT&T 4410v1 terminal.
.PP
.TS
l l
l lf4.
Glyph Name	vt100+ Character
.sp .8v
arrow pointing right	+
arrow pointing left	,
arrow pointing down	.
solid square block	0
lantern symbol	I
arrow pointing up	\-
diamond	`
checker board (stipple)	a
degree symbol	f
plus/minus	g
board of squares	h
lower right corner	j
upper right corner	k
upper left corner	l
lower left corner	m
plus	n
scan line 1	o
horizontal line	q
scan line 9	s
left tee (\z\(br\-)	t
right tee (\-\(br)	u
bottom tee (\o'\(ul\(br')	v
top tee (\o'\(rn\(br')	w
vertical line	x
bullet	~
.TE
.PP
The best way to describe a new device's line graphics set is to add a
third column to the above table with the characters for the new device
that produce the appropriate glyph when the device is in the alternate
character set mode.
For example,
.PP
.TS
l l l
l l l
l lf4 lf4.
	vt100+	New Tty
Glyph Name	Char	Char
.sp .8v
upper left corner	l	R
lower left corner	m	F
upper right corner	k	T
lower right corner	j	G
horizontal line	q	,
vertical line	x	.
.TE
.PP
Now write down the characters left to right,
as in ``\f4acsc=lRmFkTjGq\e,x.\f1''.
.PP
In addition, \f4terminfo\f1 allows you to define
multiple character sets.
See Section 2-5 for details.
.SS "Section 1-13: Color Manipulation"
Let us define two methods
of color manipulation: the Tektronix method
and the HP method.
The Tektronix method uses a set of N predefined colors (usually 8)
from which a user can select "current" foreground and background colors.
Thus a terminal can support up to N colors mixed into N*N color-pairs to
be displayed on the screen at the same time.
When using an HP method the user
cannot define the foreground independently of the background, or
vice-versa.
Instead, the user must define an entire color-pair at once.
Up to M color-pairs,
made from 2*M different colors,
can be defined this way.
Most existing color terminals belong to
one of these two classes of terminals.
.PP
The numeric variables \f4colors\f1
.RF 47
and \f4pairs\f1
.RF 50
define the number of colors and color-pairs that can be displayed
on the screen at the same time.
If a terminal can change the definition of a color
(for example, the Tektronix 4100 and 4200 series terminals),
this should be specified with \f4ccc\f1 (can change color).
.RF 4
To change the definition of a color (Tektronix 4200 method),
use \f4initc\f1 (initialize color).
.RF 152
It requires four arguments: color number
(ranging from 0 to \f4colors\f1\-1)
and three RGB (red, green, and blue) values
or
three HLS colors (Hue, Lightness, Saturation).
Ranges of RGB and HLS values are terminal dependent.
.PP
Tektronix 4100 series terminals only use HLS color notation.
For such terminals (or dual-mode terminals to be operated in HLS mode)
one must define a boolean variable \f4hls\f1;
that would instruct the \f4curses\fP \f4init_color\fP routine to convert
its RGB arguments to HLS before sending them to the terminal.
.RF 17
The last three arguments to the \f4initc\f1 string
would then be HLS values.
.PP
If a terminal can change the definitions of colors,
but uses a color notation different from RGB and HLS,
a mapping to either RGB or HLS must be developed.
.PP
To set current foreground or
background to a given color,
use \f4setaf\f1 (set ANSI foreground)
.RF 373
and \f4setab\f1 (set ANSI background).
.RF 369
They require one parameter: the number of the color.
To initialize a color-pair (HP method),
use \f4initp\f1 (initialize pair).
.RF 153
It requires seven parameters: the number of a color-pair
(range=0 to \f4pairs\f1\-1), and six RGB values: three
for the foreground followed by three for the background.
(Each of these groups of three should be in the order RGB.)
When \f4initc\f1 or \f4initp\f1 are used,
RGB or HLS arguments should
be in the order "red, green, blue"
or "hue, lightness, saturation"), respectively.
To make a color-pair
current, use \f4scp\f1 (set color-pair).
.RF 372
It takes one parameter, the number of a color-pair.
.PP
Some terminals
(for example, most color terminal emulators for PCs)
erase areas of the screen with current background color.
In such cases,
\f4bce\f1 (background color erase)
.RF 3
should be defined.
The variable
\f4op\f1 (original pair)
.RF 332
contains a sequence for setting
the foreground and the
background colors to what they were at the terminal start-up time.
Similarly, \f4oc\f1 (original colors)
.RF 331
contains a control sequence for setting
all colors (for the Tektronix method)
or color-pairs (for the HP method) to the values they had
at the terminal start-up time.
.PP
Some color terminals substitute color for video attributes.
Such video attributes should not be combined with colors.
Information about these video attributes should be packed into
the \f4ncv\f1 (no color video) variable.
.RF 53
There is a one-to-one correspondence between the nine least significant
bits of that variable and the video attributes.
The following table depicts this correspondence.
.PP
.TS
l l l
l l l
lf4 n n .
	Bit	Decimal
Attribute	Position	Value
.sp .8v
A_STANDOUT	0	1
A_UNDERLINE	1	2
A_REVERSE	2	4
A_BLINK	3	8
A_DIM	4	16
A_BOLD	5	32
A_INVIS	6	64
A_PROTECT	7	128
A_ALTCHARSET	8	256
.TE
.PP
When a particular video attribute should not be used with colors,
the corresponding \f4ncv\f1 bit should be set to 1; otherwise
it should be set to zero.
To determine the information to pack into the \f4ncv\f1 variable,
you must add together the decimal values
corresponding to those attributes
that cannot coexist with colors.
For example, if the terminal uses colors to simulate
reverse video (bit number 2 and decimal value 4)
and bold (bit number 5 and decimal value 32),
the resulting value for \f4ncv\f1 will be 36 (4 + 32).
.SS "Section 1-14: Miscellaneous"
If the terminal requires other than a null (zero) character as a pad,
then this can be given as \f4pad\f1.
.RF 333
Only the first character of the
\f4pad\f1
string is used.
If the terminal does not have a pad character, specify \f4npc\f1.
.RF 27
.PP
If the terminal can move up or down half a line,
this can be indicated with
\f4hu\f1
.RF 392
(half-line up)
and
\f4hd\f1
.RF 99
(half-line down).
This is primarily useful for superscripts and subscripts on hardcopy
terminals.
If a hardcopy terminal can eject to the next page (form feed), give this as
\f4ff\f1
(usually control L).
.PP
If there is a command to repeat a given character a given number of
times (to save time transmitting a large number of identical characters)
this can be indicated with the parameterized string
\f4rep\f1.\f1
.RF 356
The first parameter is the character to be repeated and the second
is the number of times to repeat it.
Thus,
\f4tparm(repeat_char, 'x', 10)\f1
is the same as
\f4xxxxxxxxxx.\f1
.PP
If the terminal has a settable command character, such as the Tektronix 4025,
this can be indicated with
\f4cmdch\f1.\f1
.RF 83
A prototype command character is chosen which is used in all capabilities.
This character is given in the
\f4cmdch\f1
capability to identify it.
The following convention is supported on some UNIX systems:
If the environment variable
\f4CC\f1
exists, all
occurrences of the prototype character are replaced with the character
in
\f4CC\f1.\f1
.PP
Terminal descriptions that do not represent a specific kind of known
terminal, such as
\f2switch\f1,
\f2dialup\f1,
\f2patch\f1,
and
\f2network\f1,
should include the
\f4gn\f1
.RF 11
(generic) capability so that programs can complain that they do not know
how to talk to the terminal.
(This capability does not apply to
\f2virtual\f1
terminal descriptions for which the escape sequences are known.)
If the terminal is one of those supported by the UNIX system virtual
terminal protocol, the terminal number can be given as
\f4vt\f1.\f1
A line-turn-around sequence to be transmitted before doing reads should be
specified in
\f4rfi\f1.\f1
.RF 357
.PP
If the device uses xon/xoff handshaking for flow control, give
\f4xon\f1.\f1
.RF 36
Padding information should still be included so that routines can
make better decisions about costs, but actual pad characters will
not be transmitted.
Sequences to turn on and off xon/xoff handshaking may be given in
\f4smxon\f1
.RF 125
and
\f4rmxon\f1.\f1
.RF 143
If the characters used for handshaking are not
\f4^S\f1
and
\f4^Q\f1,
they may
be specified with
\f4xonc\f1
.RF 394
and
\f4xoffc\f1.\f1
.RF 393
.PP
If the terminal has a ``meta key'' which acts as a shift key,
setting the 8th bit of any character transmitted, this fact can
be indicated with
\f4km\f1.\f1
.RF 14
Otherwise, software will assume that the 8th bit is parity and it
will usually be cleared.
If strings exist to turn this ``meta mode'' on and off, they
can be given as \f4smm\f1
.RF 322
and \f4rmm\f1.\f1
.RF 321
.PP
If the terminal has more lines of memory than will fit on the screen
at once, the number of lines of memory can be indicated with
\f4lm\f1.\f1
.RF 45
A value of
\f4lm\f1#0\f1
indicates that the number of lines is not fixed,
but that there is still more memory than fits on the screen.
.PP
Media copy
strings which control an auxiliary printer connected to the terminal
can be given as
\f4mc0\f1:\f1
.RF 352
print the contents of the screen,
\f4mc4\f1:\f1
.RF 354
turn off the printer, and
\f4mc5\f1:\f1
.RF 355
turn on the printer.
When the printer is on, all text sent to the terminal will be sent
to the printer.
A variation,
\f4mc5p\f1,
.RF 353
takes one parameter, and leaves the printer on for as many characters
as the value of the parameter, then turns the printer off.
The parameter should not exceed 255.
If the text is not displayed on the terminal screen when the printer is on,
specify
\f4mc5i\f1
.RF 29
(silent printer).
All text, including
\f4mc4\f1,
is transparently passed to the printer while an
\f4mc5p\f1
is in effect.
.SS "Section 1-15: Special Cases"
The working model used by
\f4terminfo\f1
fits most terminals reasonably well.
However, some terminals do not completely
match that model,
requiring special support by \f4terminfo\f1.
These are not meant to be construed as
deficiencies in the terminals;
they are just differences between the
working model and the actual hardware.
They may be unusual devices or,
for some reason, do not have all the
features of the \f4terminfo\f1 model implemented.
.P
Terminals that cannot display tilde (~)
characters, such as certain Hazeltine terminals,
should indicate \f4hz\f1.
.RF 34
.P
Terminals that ignore a linefeed immediately
after an \f4am\f1 wrap,
such as the Concept 100, should indicate \f4xenl\f1.
.RF 9
Those terminals whose cursor remains on the right-most
column until another character has been received,
rather than wrapping immediately upon receiving
the right-most character, such as the VT100,
should also indicate \f4xenl\f1.
.P
If \f4el\f1 is required to get rid of standout
(instead of writing normal text on top of it),
\f4xhp\f1 should be given.
.RF 5
.P
Those Teleray terminals whose tabs turn all characters
moved over to blanks, should indicate \f4xt\f1 (destructive
tabs).
.RF 33
This capability is also taken to mean that it is not possible
to position the cursor on top of a ``magic cookie.''
Therefore, to erase standout mode, it is
necessary, instead, to use delete and insert line.
.P
Those Beehive Superbee terminals which do not transmit
the escape or control\-C characters, should specify \f4xsb\f1,
.RF 25
indicating that the f1 key is to be used for escape and the f2 key
for control C.
.SS "Section 1-16: Similar Terminals"
If there are two very similar terminals,
one can be defined as being just like the other with certain exceptions.
The string capability \f4use\f1 can be given
with the name of the similar terminal.
The capabilities given before
\f4use\f1
override those in the terminal type invoked by
\f4use\f1.\f1
A capability can be canceled by placing \f2xx\f4@\f1 to the left of the
capability definition, where \f2xx\f1 is the capability.
For example, the entry
.P
.nf
.ft 4
.in +2
att4424-2|Teletype\04424 in display function group ii,
.in +2
rev@, sgr@, smul@, use=att4424,
.in -4
.ft 1
.fi
.PP
defines an AT&T\04424 terminal that does not have the
\f4rev\f1,
.RF 117
\f4sgr\f1,
.RF 368
and \f4smul\f1 capabilities,
.RF 123
and hence cannot do highlighting.
This is useful for different modes for a terminal,
or for different user preferences.
More than one \f4use\f1 capability may be given.
.SS "PART 2: PRINTER CAPABILITIES"
The \f4terminfo\f1 database
allows you to define
capabilities of printers
as well as terminals.
To find out what capabilities are available
for printers as well as for terminals,
see the two lists under "DEVICE CAPABILITIES"
that list capabilities by variable and by capability name.
.SS "Section 2-1: Rounding Values"
Because parameterized
string capabilities work only with integer values,
we recommend that \f4terminfo\f1 designers
create strings that expect numeric values
that have been rounded.
Application designers should note this
and should always round values to the nearest integer
before using them with a parameterized string capability.
.SS "Section 2-2: Printer Resolution"
A printer's resolution is defined to be the smallest spacing of
characters it can achieve.
In general printers have independent resolution horizontally and
vertically.
Thus the vertical resolution of a printer can be determined by
measuring the smallest achievable distance between consecutive
printing baselines,
while the horizontal resolution can be determined by measuring
the smallest achievable distance between the left-most edges of
consecutive printed, identical, characters.
.P
All printers are assumed to be capable of printing with a
uniform horizontal and vertical resolution.
The view of printing that \f4terminfo\f1 currently
presents is one of printing inside a uniform matrix:
All characters are printed at fixed positions relative to each
``cell'' in the matrix;
furthermore,
each cell has the same size given by the smallest horizontal
and vertical step sizes dictated by the resolution.
(The cell size can be changed as will be seen later.)
.P
Many printers are capable of ``proportional printing,''
where the horizontal spacing depends on the size of the
character last printed.
\f4terminfo\f1 does not make use of this capability,
although it does provide enough capability definitions to allow
an application to simulate proportional printing.
.P
A printer must not only be able to print characters as close
together as the horizontal and vertical resolutions suggest,
but also of ``moving'' to a position an integral multiple of the
smallest distance away from a previous position.
Thus printed characters can be spaced apart a distance that is
an integral multiple of the smallest distance,
up to the length or width of a single page.
.P
Some printers can have different resolutions depending on
different ``modes.''
In ``normal mode,''
the existing \f4terminfo\f1 capabilities are assumed to work on
columns and lines,
just like a video terminal.
Thus the old
\f4lines\f1
.RF 44
capability would give the length of a page in lines,
and the
\f4cols\f1
capability would give the width of a page in columns.
In ``micro mode,''
many \f4terminfo\f1 capabilities
work on increments of lines and columns.
With some printers the micro mode may be concomitant with
normal mode,
so that all the capabilities work at the same time.
.SS "Section 2-3: Specifying Printer Resolution"
The printing resolution of a printer is given in several ways.
Each specifies the resolution as the number of smallest steps
per distance:
.PP
.TS
c s
c s
lf4 l.
Specification of Printer Resolution
Characteristic Number of Smallest Steps
.sp .8v
orhi	Steps per inch horizontally
.RF 58
orvi	Steps per inch vertically
.RF 59
orc	Steps per column
.RF 56
orl	Steps per line
.RF 57
.TE
.PP
When printing in normal mode,
each character printed causes movement to the next column,
except in special cases described later;
the distance moved is the same as the per-column resolution.
Some printers cause an automatic movement to the next line when
a character is printed in the rightmost position;
the distance moved vertically is the same as the per-line
resolution.
When printing in micro mode,
these distances can be different,
and may be zero for some printers.
.PP
.TS
c s
c s
lf4 l.
Specification of Printer Resolution
Automatic Motion after Printing
.sp .8v
\f1Normal mode:\f4
orc	Steps moved horizontally
orl	Steps moved vertically
.sp .8v
\f1Micro mode:\f4
mcs	Steps moved horizontally
.RF 51
mls	Steps moved vertically
.RF 52
.TE
.P
Some printers are capable of printing wide characters.
The distance moved when a wide character is printed in normal
mode may be different from when a regular width character is
printed.
The distance moved when a wide character is printed in micro
mode may also be different from when a regular character is
printed in micro mode,
but the differences are assumed to be related:
If the distance moved for a regular character is the same
whether in normal mode or micro mode
(\f4mcs\f1=\f4orc\f1),
then the distance moved for a wide character is also the same
whether in normal mode or micro mode.
This doesn't mean the normal character distance is necessarily
the same as the wide character distance,
just that the distances don't change with a change in normal to
micro mode.
However, if the distance moved for a regular character is
different in micro mode from the distance moved in normal mode
\f1(\f4mcs\f1<\f4orc\f1)\f1,
the micro mode distance is assumed to be the same for a wide
character printed in micro mode,
as the table below shows.
.PP
.TS
c s
c s
lf4 l.
Specification of Printer Resolution
Automatic Motion after Printing Wide Character
.sp .8v
\f1Normal mode or micro mode (\f4mcs\f1 = \f4orc\f1):\f4
widcs	Steps moved horizontally
.RF 63
.sp .8v
\f1Micro mode (\f4mcs\f1 < \f4orc\f1):\f4
mcs	Steps moved horizontally
.TE
.P
There may be control sequences to change
the number of columns per inch
(the character pitch)
and to change the number of lines per inch
(the line pitch).
If these are used,
the resolution of the printer changes,
but the type of change depends on the printer:
.P
.TS
c s
c s
lf4 l.
Specification of Printer Resolution
Changing the Character/Line Pitches
.sp .8v
cpi	Change character pitch
.RF 69
cpix	If set, \f4cpi\f1 changes \f4orhi\f1, otherwise changes \f4orc\f1
.RF 7
.sp .8v
lpi	Change line pitch
.RF 70
lpix	If set, \f4lpi\f1 changes \f4orvi\f1, otherwise changes \f4orl\f1
.RF 19
.sp .8v
chr	Change steps per column
.RF 71
cvr	Change steps per line
.RF 72
.TE
.P
The
\f4cpi\f1
and
\f4lpi\f1
string capabilities are each used with a single argument,
the pitch in columns (or characters) and lines per inch,
respectively.
The
\f4chr\f1
and
\f4cvr\f1
string capabilities are each used with a single argument,
the number of steps per column and line,
respectively.
.P
Using any of the control sequences in these strings will imply a
change in some of the values of
\f4orc\f1,
\f4orhi\f1,
\f4orl\f1,
and
\f4orvi\f1.\f1
Also,
the distance moved when a wide character is printed,
\f4widcs\f1,
changes in relation to
\f4orc\f1.\f1
The distance moved when a character is printed in micro mode,
\f4mcs\f1,
changes similarly,
with one exception: if the distance is 0 or 1, then
no change is assumed
(see items marked with
\(dg
in the following table).
.P
Programs that use
\f4cpi\f1,
\f4lpi\f1,
\f4chr\f1,
or
\f4cvr\f1
should recalculate the printer resolution
(and should recalculate other values\*(em see
"Effect of Changing Printing Resolution"
under
"Dot-Mapped Graphics").
.PP
.EQ
delim $$
define pr 'sup bold prime'
.EN
.TS
c s
c s
c c
l l .
Specification of Printer Resolution
Effects of Changing the Character/Line Pitches
.sp .8v
Before	After
.sp .8v
Using \f4cpi \f1with \f4cpix \f1clear:
$bold orhi '$	\f3orhi\f1
$bold orc '$	$bold orc = bold orhi over V sub italic cpi$
.sp .8v
Using \f4cpi \f1with \f4cpix \f1set:
$bold orhi '$	$bold orhi = bold orc cdot V sub italic cpi$
$bold orc '$	$bold orc$
.sp .8v
Using \f4lpi \f1with \f4lpix \f1clear:
$bold orvi '$	$bold orvi$
$bold orl '$	$bold orl = bold orvi over V sub italic lpi$
.sp .8v
Using \f4lpi \f1with \f4lpix \f1set:
$bold orvi '$	$bold orvi = bold orl cdot V sub italic lpi$
$bold orl '$	$bold orl$
.sp .8v
Using \f4chr:\f1
$bold orhi '$	$bold orhi$
$bold orc '$	$V sub italic chr$
.sp .8v
Using \f4cvr:\f1
$bold orvi '$	$bold orvi$
$bold orl '$	$V sub italic cvr$
.sp .8v
Using \f4cpi \f1or \f4chr:\f1
$bold widcs '$	$bold widcs = bold {widcs '} bold orc over { bold {orc '} }$
$bold mcs '$	$bold mcs = bold {mcs '} bold orc over { bold {orc '} }$
.TE
.PP
$V sub italic cpi$,
$V sub italic lpi$,
$V sub italic chr$,
and
$V sub italic cvr$
are the arguments used
with
\f4cpi\f1,
\f4lpi\f1,
\f4chr\f1,
and
\f4cvr\f1,
respectively.
The prime marks (')
indicate the old values.
.EQ
delim off
.EN
.SS "Section 2-4: Capabilities that Cause Movement"
In the following descriptions,
``movement'' refers to the motion of the ``current position.''
With video terminals this would be the cursor;
with some printers this is the carriage position.
Other printers have different equivalents.
In general,
the current position is where a character would be displayed if
printed.
.P
\f4terminfo\f1 has string capabilities for control
sequences that cause movement a number of full columns or lines.
It also has equivalent string capabilities for control
sequences that cause movement a number of smallest steps.
.PP
.TS
c s
lf4 l.
String Capabilities for Motion
.sp .8v
mcub1	Move 1 step left
.RF 325
mcuf1	Move 1 step right
.RF 326
mcuu1	Move 1 step up
.RF 328
mcud1	Move 1 step down
.RF 324
.sp .8v
mcub	Move \f2N\f1 steps left
.RF 342
mcuf	Move \f2N\f1 steps right
.RF 344
mcuu	Move \f2N\f1 steps up
.RF 347
mcud	Move \f2N\f1 steps down
.RF 337
.sp .8v
mhpa	Move \f2N\f1 steps from the left
.RF 323
mvpa	Move \f2N\f1 steps from the top
.RF 327
.TE
.P
The latter six strings are each used with a single argument,
.IR "N" .
.P
Sometimes the motion is limited to less than the width or
length of a page.
Also,
some printers don't accept absolute motion to the left of the
current position.
\f4terminfo\f1 has capabilities for specifying these limits.
.P
.TS
c s
lf4 l.
Limits to Motion
.sp .8v
mjump	Limit on use of \f4mcub1\f1, \f4mcuf1\f1, \f4mcuu1\f1, \f4mcud1\f1
.RF 49
maddr	Limit on use of \f4mhpa\f1, \f4mvpa\f1
.RF 48
.sp .8v
xhpa	If set, \f4hpa\f1 and \f4mhpa\f1 can't move left
.RF 6
xvpa	If set, \f4vpa\f1 and \f4mvpa\f1 can't move up
.RF 30
.TE
.P
If a printer needs to be in a ``micro mode'' for the motion
capabilities described above to work,
there are string capabilities defined to contain the control
sequence to enter and exit this mode.
A boolean is available for those printers where using a carriage
return causes an automatic return to normal mode.
.P
.TS
c s
lf4 l.
Entering/Exiting Micro Mode
.sp .8v
smicm	Enter micro mode
.RF 113
rmicm	Exit micro mode
.RF 136
.sp .8v
crxm	Using \f4cr\f1 exits micro mode
.RF 8
.TE
.P
The movement made when a character is printed in the rightmost
position varies among printers.
Some make no movement,
some move to the beginning of the next line,
others move to the beginning of the same line.
\f4terminfo\f1 has boolean capabilities for describing all three cases.
.P
.TS
c s
c s
lf4 l.
What Happens After Character
Printed in Rightmost Position
.sp .8v
sam	Automatic move to beginning of same line
.RF 31
.TE
.P
Some printers can be put in a mode where the normal direction of
motion is reversed.
This mode can be especially useful when there are no
capabilities for leftward or upward motion,
because those capabilities can be built from the motion reversal
capability and the rightward or downward motion capabilities.
It is best to leave it up to an application to build the
leftward or upward capabilities,
though,
and not enter them in the \f4terminfo\f1 database.
This allows several reverse motions to be strung together
without intervening wasted steps that leave and reenter reverse
mode.
.P
.TS
c s
lf4 l.
Entering/Exiting Reverse Modes
.sp .8v
slm	Reverse sense of horizontal motions
.RF 112
rlm	Restore sense of horizontal motions
.RF 135
sum	Reverse sense of vertical motions
.RF 124
rum	Restore sense of vertical motions
.RF 142
.sp .8v
.T&
lI s.
While sense of horizontal motions reversed:
.T&
lf4 l.
mcub1	Move 1 step right
mcuf1	Move 1 step left
mcub	Move \f2N\f1 steps right
mcuf	Move \f2N\f1 steps left
cub1	Move 1 column right
.RF 88
cuf1	Move 1 column left
.RF 91
cub	Move \f2N\f1 columns right
cuf	Move \f2N\f1 columns left
.sp .8v
.T&
lI s.
While sense of vertical motions reversed:
.T&
lf4 l.
mcuu1	Move 1 step down
mcud1	Move 1 step up
mcuu	Move \f2N\f1 steps down
mcud	Move \f2N\f1 steps up
cuu1	Move 1 line down
.RF 93
cud1	Move 1 line up
.RF 85
cuu	Move \f2N\f1 lines down
cud	Move \f2N\f1 lines up
.TE
.PP
The reverse motion modes should not affect the
\f4mvpa\f1
and
\f4mhpa\f1
absolute motion capabilities.
The reverse vertical motion mode should,
however,
also reverse the action of the line ``wrapping'' that occurs
when a character is printed in the right-most position.
Thus printers that have the standard \f4terminfo\f1 capability
\f4am\f1
defined should experience motion to the beginning of the
previous line when a character is printed in the right-most
position under reverse vertical motion mode.
.P
The action when any other motion capabilities are used in
reverse motion modes is not defined;
thus,
programs must exit reverse motion modes before using other
motion capabilities.
.P
Two miscellaneous capabilities complete the list of new motion
capabilities.
One of these is needed for printers that move the current
position to the beginning of a line when certain control
characters,
such as ``line-feed'' or ``form-feed,''
are used.
The other is used for the capability of suspending the motion
that normally occurs after printing a character.
.P
.TS
c s
lf4 l.
Miscellaneous Motion Strings
.sp .8v
docr	List of control characters causing \f4cr\f1
.RF 389
zerom	Prevent auto motion after printing next single character
.RF 395
.TE
.SS "Margins"
\f4terminfo\f1 provides two strings for setting margins
on terminals: one for the left and one for the right margin.
Printers, however, have two additional margins,
for the top and bottom margins of each page.
Furthermore,
some printers require not using motion strings to move the
current position to a margin and then fixing the margin there,
but require the specification of where a margin should be
regardless of the current position.
Therefore \f4terminfo\f1
offers six additional strings for defining margins with printers.
.P
.TS
c s
lf4 l.
Setting Margins
.sp .8v
smgl	Set left margin at current column
smgr	Set right margin at current column
smgb	Set bottom margin at current line
.RF 370
smgt	Set top margin at current line
.RF 379
.sp .8v
smgbp	Set bottom margin at line \f2N\f1
.RF 371
smglp	Set left margin at column \f2N\f1
.RF 375
smgrp	Set right margin at column \f2N\f1
.RF 377
smgtp	Set top margin at line \f2N\f1
.RF 380
.TE
.P
The last four strings are used with one or more arguments that
give the position of the margin or margins to set.
If both of
\f4smglp\f1
and
\f4smgrp\f1
are set,
each is used with a single argument, \f2N,\f1
that gives the column number of the left and right margin,
respectively.
If both of \f4smgtp\f1 and \f4smgbp\f1 are set,
each is used to set the top and bottom margin, respectively:
\f4smgtp\f1 is used with a single argument, \f2N,\f1
the line number of the top margin; however, \f4smgbp\f1
is used with two arguments, \f2N\f1 and \f2M,\f1
that give the line number of the bottom margin,
the first counting from the top of the page and the second
counting from the bottom.
This accommodates the two styles of specifying the bottom margin
in different manufacturers' printers.
When coding a
\f4terminfo\f1
entry for a printer that has a settable bottom margin,
only the first or second parameter should be used,
depending on the printer.
When writing an application that uses
\f4smgbp\f1
to set the bottom margin,
both arguments must be given.
.P
If only one of
\f4smglp\f1
and
\f4smgrp\f1
is set,
then it is used with two arguments,
the column number of the left and right margins,
in that order.
Likewise,
if only one of
\f4smgtp\f1
and
\f4smgbp\f1
is set,
then it is used with two arguments that give the top and bottom
margins,
in that order,
counting from the top of the page.
Thus when coding a
\f4terminfo\f1
entry for a printer that requires setting both left and right
or top and bottom margins simultaneously,
only one of
\f4smglp\f1
and
\f4smgrp\f1
or
\f4smgtp\f1
and
\f4smgbp\f1
should be defined;
the other should be left blank.
When writing an application that uses these string capabilities,
the pairs should be first checked to see if each in the pair is
set or only one is set,
and should then be used accordingly.
.P
In counting lines or columns,
line zero is the top line and column zero is the left-most column.
A zero value for the second argument with
\f4smgbp\f1
means the bottom line of the page.
.PP
All margins can be cleared with \f4mgc\f1.
.SS "Shadows, Italics, Wide Characters, Superscripts, Subscripts"
Five new sets of strings are used to describe the capabilities
printers have of enhancing printed text.
.P
.TS
c s
lf4 l.
Enhanced Printing
.sp .8v
sshm	Enter shadow-printing mode
.RF 119
rshm	Exit shadow-printing mode
.RF 137
.sp .8v
sitm	Enter italicizing mode
.RF 111
ritm	Exit italicizing mode
.RF 134
.sp .8v
swidm	Enter wide character mode
.RF 108
rwidm	Exit wide character mode
.RF 132
.sp .8v
ssupm	Enter superscript mode
.RF 122
rsupm	Exit superscript mode
.RF 140
supcs	List of characters available as superscripts
.RF 387
.sp .8v
ssubm	Enter subscript mode
.RF 121
rsubm	Exit subscript mode
.RF 139
subcs	List of characters available as subscripts
.RF 386
.TE
.P
If a printer requires the
\f4sshm\f1
control sequence before every character to be shadow-printed,
the
\f4rshm\f1
string is left blank.
Thus programs that find a control sequence in
\f4sshm\f1
but none in
\f4rshm\f1
should use the
\f4sshm\f1
control sequence before every character to be shadow-printed;
otherwise,
the
\f4sshm\f1
control sequence should be used once before the set of
characters to be shadow-printed, followed
by
\f4rshm\f1.\f1
The same is also true of each of the
\f4sitm\f1/\f1\f4ritm\f1,
\f4swidm\f1/\f1\f4rwidm\f1,
\f4ssupm\f1/\f1\f4rsupm\f1,
and
\f4ssubm\f1/\f1 \f4rsubm\f1
pairs.
.P
Note that \f4terminfo\f1 also has a capability for printing
emboldened text
\f1(\f4bold\f1).\f1
While shadow printing and emboldened printing are similar in
that they ``darken'' the text,
many printers produce these two types of print
in slightly different ways.
Generally,
emboldened printing is done by overstriking the same
character one or more times.
Shadow printing likewise usually involves overstriking,
but with a slight movement up and/or to the side so that the
character is ``fatter.''
.P
It is assumed that enhanced printing modes are independent modes,
so that it would be possible,
for instance,
to shadow print italicized subscripts.
.P
As mentioned earlier,
the amount of motion automatically made after printing a wide
character should be given in
\f4widcs\f1.\f1
.P
If only a subset of the printable ASCII characters can be
printed as superscripts or subscripts,
they should be listed in
\f4supcs\f1
or
\f4subcs\f1
strings,
respectively.
If the
\f4ssupm\f1
or
\f4ssubm\f1
strings contain control sequences,
but the corresponding
\f4supcs\f1
or
\f4subcs\f1
strings are empty,
it is assumed that all printable ASCII characters are available
as superscripts or subscripts.
.P
Automatic motion made after printing a superscript or subscript
is assumed to be the same as for regular characters.
Thus,
for example,
printing any of the following three examples will result in
equivalent motion:
.P
.RS
.ft 4
Bi  B\di\u  B\ui\d
.ft 1
.RE
.P
Note that the existing
\f4msgr\f1
boolean capability describes whether motion control sequences
can be used while in ``standout mode.''
This capability is extended to cover the enhanced printing modes
added here.
\f4msgr\f1
should be set for those printers that accept any motion control
sequences without affecting shadow,
italicized,
widened,
superscript,
or subscript printing.
Conversely,
if
\f4msgr\f1
is not set,
a program should end these modes before attempting any motion.
.SS "Section 2-5: Alternate Character Sets"
In addition to allowing you to define line graphics
(described in Section 1-12),
\f4terminfo\f1 lets you define alternate character sets.
The following capabilities cover printers
and terminals with multiple selectable or definable
character sets.
.P
.TS
c s
lf4 l.
Alternate Character Sets
.sp .8v
scs	Select character set \f2N\f1
.RF 367
.sp .8v
scsd	Start definition of character set \f2N\f1, \f2M\f1 characters
.RF 383
defc	Define character \f2A\f1, \f2B\f1 dots wide, descender \f2D\f1
.RF 95
rcsd	End definition of character set \f2N\f1
.RF 385
.sp .8v
csnm	List of character set names
.RF 75
.sp .8v
daisy	Printer has manually changed print-wheels
.RF 15
.TE
.P
The
\f4scs\f1,
\f4rcsd\f1,
and
\f4csnm\f1
strings are used with a single argument,
.IR "N" ,
a number from 0 to 63 that identifies the character set.
The
\f4scsd\f1
string is also used with the argument
\f2N\f1
and another,
.IR "M" ,
that gives the number of characters in the set.
The
\f4defc\f1
string is used with three arguments:
\f2A\f1
gives the ASCII code representation for the character,
\f2B\f1
gives the width of the character in dots,
and
\f2D\f1
is zero or one depending on whether the character is a ``descender''
or not.
The
\f4defc\f1
string is also followed by a string of ``image-data'' bytes
that describe how the character looks
(see below).
.P
Character set 0 is the default character set present after the
printer has been initialized.
Not every printer has 64 character sets,
of course;
using
\f4scs\f1
with an argument that doesn't select an available character set
should cause a null result from \f4tparm\f1.
.P
If a character set has to be defined before it can be used,
the
\f4scsd\f1
control sequence is to be used before defining the character
set, and the \f4rcsd\f1 is to be used after.
They should also cause a null result from
\f4tparm\f1
when used with an argument
\f2N\f1
that doesn't apply.
If a character set still has to be selected after being
defined,
the
\f4scs\f1
control sequence should follow the
\f4rcsd\f1
control sequence.
By examining the results of using each of the
\f4scs\f1,
\f4scsd\f1,
and
\f4rcsd\f1
strings with a character set number in a call to
\f4tparm\f1,
a program can determine which of the three are needed.
.P
Between use of the
\f4scsd\f1
and
\f4rcsd\f1
strings,
the
\f4defc\f1
string should be used to define each character.
To print any character on printers covered by \f4terminfo\f1,
the ASCII code is sent to the printer.
This is true for characters in an alternate set as well as
``normal'' characters.
Thus the definition of a character includes the ASCII code that
represents it.
In addition,
the width of the character in dots is given,
along with an indication of whether the character should
descend below the print line
(such as the lower case letter ``g'' in most character sets).
The width of the character in dots also indicates the number of
image-data bytes that will follow the
\f4defc\f1
string.
These image-data bytes indicate where in a dot-matrix pattern
ink should be applied to ``draw'' the character;
the number of these bytes and their form are defined below
under ``Dot-Mapped Graphics.''
.P
It's easiest for the creator of \f4terminfo\f1 entries to
refer to each character set by number;
however,
these numbers will be meaningless to the application developer.
The
\f4csnm\f1
string alleviates this problem by providing names for each
number.
.P
When used with a character set number in a call to
\f4tparm\f1,
the
\f4csnm\f1
string will produce the equivalent name.
These names should be used as a reference only.
No naming convention is implied,
although anyone who creates a \f4terminfo\f1 entry for a
printer should use names consistent with the names found in
user documents for the printer.
Application developers should allow a user to specify a
character set by number
(leaving it up to the user to examine the
\f4csnm\f1
string to determine the correct number),
or by name,
where the application examines the
\f4csnm\f1
string to determine the corresponding character set number.
.P
These capabilities are likely to be used only with dot-matrix
printers.
If they are not available,
the strings should not be defined.
For printers that have manually changed print-wheels or font
cartridges,
the boolean
\f4daisy\f1
is set.
.SS "Section 2-6: Dot-Matrix Graphics"
Dot-matrix printers typically have the capability of
reproducing ``raster-graphics'' images.
Three new numeric capabilities and three new string capabilities can
help a program draw raster-graphics images independent of
the type of dot-matrix printer or the number of pins or dots
the printer can handle at one time.
.PP
.TS
c s
lf4 l.
Dot-Matrix Graphics
.sp .8v
npins	Number of pins, \f2N\f1, in print-head
.RF 54
spinv	Spacing of pins vertically in pins per inch
.RF 39
spinh	Spacing of dots horizontally in dots per inch
.RF 40
porder	Matches software bits to print-head pins
.RF 330
sbim	Start printing bit image graphics, \f2B\f1 bits wide
.RF 382
rbim	End printing bit image graphics
.RF 384
.TE
.P
The
\f4sbim\f1
sring is used with a single argument,
.IR "B" ,
the width of the image in dots.
.P
The model of dot-matrix or raster-graphics that
\f4terminfo\f1 presents is similar to the technique used for most
dot-matrix printers:
each pass of the printer's print-head is assumed to produce a
dot-matrix that is
\f2N\f1
dots high and
\f2B\f1
dots wide.
This is typically a wide, squat, rectangle of dots.
The height of this rectangle in dots will vary from one printer
to the next;
this is given in the
\f4npins\f1
numeric capability.
The size of the rectangle in fractions of an inch will also
vary;
it can be deduced from the
\f4spinv\f1
and
\f4spinh\f1
numeric capabilities.
With these three values an application can divide a complete
raster-graphics image into several horizontal strips,
perhaps interpolating to account for different dot spacing
vertically and horizontally.
.P
The
\f4sbim\f1
and
\f4rbim\f1
strings are used to start and end a dot-matrix image,
respectively.
The
\f4sbim\f1
string is used with a single argument that gives the width of
the dot-matrix in dots.
A sequence of ``image-data bytes'' are sent to the printer
after the
\f4sbim\f1
string and before the
\f4rbim\f1
string.
The number of bytes is a integral multiple of the width of the
dot-matrix;
the multiple and the form of each byte is determined by the
\f4porder\f1
string as described below.
.P
The
\f4porder\f1
string is a comma separated list of pin numbers optionally
followed by an numerical offset.
The offset,
if given,
is separated from the list with a semicolon.
The position of each pin number in the list corresponds to a
bit in an 8-bit data byte.
The pins are numbered consecutively from 1 to
\f4npins\f1,
with 1 being the top pin.
Note that the term ``pin'' is used loosely here;
``ink-jet'' dot-matrix printers don't have pins,
but can be considered to have an equivalent method of applying
a single dot of ink to paper.
The bit positions in
\f4porder\f1
are in groups of 8,
with the first position in each group the most significant bit
and the last position the least significant bit.
An application produces 8-bit bytes in the order of the groups in
\f4porder\f1.
.P
An application computes the ``image-data bytes'' from the
internal image,
mapping vertical dot positions in each print-head pass into
8-bit bytes,
using a 1 bit where ink should be applied and 0 where no ink
should be applied.
This can be reversed (0 bit for ink, 1 bit for no ink)
by giving a negative pin number.
If a position is skipped in
\f4porder\f1,
a 0 bit is used.
If a position has a lower case `x' instead of a pin number,
a 1 bit is used in the skipped position.
For consistency,
a lower case `o' can be used to represent a 0 filled, skipped
bit.
There must be a multiple of 8 bit positions used or skipped in
\f4porder\f1;
if not,
0 bits are used to fill the last byte in the least significant
bits.
The offset,
if given,
is added to each data byte;
the offset can be negative.
.P
Some examples may help clarify the use of the
\f4porder\f1
string.
The AT&T 470, AT&T 475 and C.Itoh 8510 printers provide eight
pins for graphics.
The pins are identified top to bottom by the 8 bits in a byte,
from least significant to most.
The
\f4porder\f1
strings for these printers would be
\f48,7,6,5,4,3,2,1\f1.
The AT&T 478 and AT&T 479 printers also provide eight pins for
graphics.
However, the pins are identified in the reverse order.
The
\f4porder\f1
strings for these printers would be
\f41,2,3,4,5,6,7,8\f1.
The AT&T 5310, AT&T 5320, DEC LA100, and DEC LN03 printers
provide six pins for graphics.
The pins are identified top to bottom by the decimal values 1,
2, 4, 8, 16 and 32.
These correspond to the low six bits in an 8-bit byte,
although the decimal values are further offset by the value 63.
The
\f4porder\f1
string for these printers would be
\f4,,6,5,4,3,2,1;63\f1,
or alternately
\f4o,o,6,5,4,3,2,1;63\f1.
.SS "Section 2-7: Effect of Changing Printing Resolution"
If the control sequences to change the character pitch or the
line pitch are used,
the pin or dot spacing may change:
.PP
.TS
c s
c s
lf4 l.
Dot-Matrix Graphics
Changing the Character/Line Pitches
.sp .8v_
cpi	Change character pitch
cpix	If set, \f4cpi\f1 changes \f4spinh\f1
.sp .8v
lpi	Change line pitch
lpix	If set, \f4lpi\f1 changes \f4spinv\f1
.TE
.P
Programs that use
\f4cpi\f1
or
\f4lpi\f1
should recalculate the dot spacing:
.PP
.EQ
delim $$
define pr 'sup bold prime'
.EN
.TS
c s
c s
c c
l l .
Dot-Matrix Graphics
Effects of Changing the Character/Line Pitches
.sp .8v
\f1Before	After
.sp .8v
Using \f4cpi \f1with \f4cpix \f1clear:\f1
$bold spinh '$	$bold spinh$
.sp .8v
Using \f4cpi \f1with \f4cpix \f1set:\f1
$bold spinh '$	$bold spinh = bold spinh ' cdot bold orhi over { bold {orhi '} }$
.sp .8v
Using \f4lpi \f1with \f4lpix \f1clear:\f1
$bold spinv '$	$bold spinv$
.sp .8v
Using \f4lpi \f1with \f4lpix \f1set:\f1
$bold spinv '$	$bold spinv = bold {spinv '} cdot bold orhi over { bold {orhi '}}$
.sp .8v
Using \f4chr:\f1
$bold spinh '$	$bold spinh$
.sp .8v
Using \f4cvr:\f1
$bold spinv '$	$bold spinv$
.TE
.P
\f3orhi'\f1 and \f3orhi\f1
are the values of the horizontal resolution in steps per inch,
before using
\f4cpi\f1
and after using
\f4cpi\f1,
respectively.
Likewise,
\f3orvi'\f1
and
\f3orvi\f1
are the values of the vertical resolution in steps per inch,
before using
\f4lpi\f1
and after using
\f4lpi\f1,
respectively.
Thus,
the changes in the dots per inch for dot-matrix graphics
follow the changes in steps per inch for printer resolution.
.EQ
delim off
.EN
.SS "Section 2-8: Print Quality"
Many dot-matrix printers can alter the dot spacing of printed
text to produce near ``letter quality'' printing or ``draft
quality'' printing.
Usually it is important to be able to choose one or the other
because the rate of printing generally falls off as the quality
improves.
There are three new strings used to describe these
capabilities.
.P
.TS
c s
lf4 l.
Print Quality
.sp .8v
snlq	Set near-letter quality print
.RF 114
snrmq	Set normal quality print
.RF 115
sdrfq	Set draft quality print
.RF 109
.TE
.P
The capabilities are listed in decreasing levels of quality.
If a printer doesn't have all three levels,
one or two of the strings should be left blank as appropriate.
.SS "Section 2-9: Printing Rate and Buffer Size"
Because there is no standard protocol that can be used to keep a
program synchronized with a printer,
and because modern printers can buffer data before printing it,
a program generally cannot determine at any time what has been
printed.
Two new numeric capabilities can help a program estimate what
has been printed.
.P
.TS
c s
lf4 l.
Print Rate/Buffer Size
.sp .8v
cps	Nominal print rate in characters per second
.RF 61
bufsz	Buffer capacity in characters
.RF 37
.TE
.P
\f4cps\f1
is the nominal or average rate at which the printer prints
characters;
if this value is not given,
the rate should be estimated at one-tenth the prevailing baud rate.
\f4bufsz\f1
is the maximum number of subsequent characters
buffered before the guaranteed printing of an earlier character,
assuming proper flow control has been used.
If this value is not given it is assumed that the printer does
not buffer characters,
but prints them as they are received.
.P
As an example,
if a printer has a 1000-character buffer,
then sending the letter ``a'' followed by 1000 additional
characters is guaranteed to cause the letter ``a'' to print.
If the same printer prints at the rate of 100 characters per
second,
then it should take 10 seconds to print all the characters in
the buffer,
less if the buffer is not full.
By keeping track of the characters sent to a printer,
and knowing the print rate and buffer size,
a program can synchronize itself with the printer.
.P
Note that most printer manufacturers advertise the maximum
print rate,
not the nominal print rate.
A good way to get a value to put in for
\f4cps\f1
is to generate a few pages of text,
count the number of printable characters,
and then see how long it takes to print the text.
.P
Applications that use these values should recognize the
variability in the print rate.
Straight text, in short lines,
with no embedded control sequences
will probably print at close to the advertised print rate and
probably faster than the rate in \f4cps\f1.
Graphics data with a lot of control sequences,
or very long lines of text,
will print at well below the advertised rate and below the rate
in \f4cps\f1.
If the application is using
\f4cps\f1
to decide how long it should take a printer to print a block of
text,
the application should pad the estimate.
If the application is using
\f4cps\f1
to decide how much text has already been printed,
it should shrink the estimate.
The application will thus err in favor of the user,
who wants, above all, to see all the output in its correct place.
.SH FILES
.TP 31
\f4/usr/share/lib/terminfo/?/\(**\f1
compiled terminal description database
.TP
\f4/usr/share/lib/.COREterm/?/\(**\f1
subset of compiled terminal description database
.TP
\f4/usr/share/lib/tabset/\(**\f1
tab settings for some terminals, in a format appropriate to be
output to the terminal (escape sequences that set margins and tabs)
.SH SEE ALSO
ls(1),
pg(1),
stty(1),
tic(1M),
tput(1),
tty(1),
vi(1),
curses(3X),
printf(3S).
.SH NOTES
The most effective way to prepare a terminal description is by
imitating the description of a similar terminal in \f4terminfo\f1
and to build up a description gradually, using partial descriptions
with a screen oriented editor, such as \f4vi\f1, to check that they
are correct.
To easily test a new terminal description the environment
variable \f4TERMINFO\f1 can be set to the pathname of a directory
containing the compiled description, and programs will look there
rather than in \f4/usr/share/lib/terminfo\f1.
