'\"! tbl | mmdoc
'\"macro stdmacro
.if n .pH g3g.glob @(#)glob	40.8 of 7/05/95
.\" Copyright 1995 Silicon Graphics, Inc.
.\" Copyright 1989, 1993, 1994 The Regents of the University of California.
.nr X
.if \nX=0 .ds x} glob 3G "Enhanced Programming Library" "\&"
.if \nX=1 .ds x} glob 3G "Enhanced Programming Library"
.if \nX=2 .ds x} glob 3G "" "\&"
.if \nX=3 .ds x} glob "" "" "\&"
.TH \*(x}
.SH NAME
\f4glob\f1 \- generate pathnames matching a pattern
.SH "SYNOPSIS"
.nf
\f4#include <glob.h>\f1
.sp .6v
\f4int glob(const char \(**pattern, int flags,
.br
.in+0.4i
int(\(**errfunc)(const char \(**epath, int eerrno),\f1
.br
.in+0.4i
.B "glob_t \(**pglob);"
.in-0.4i
.in-0.4i
.sp
.B "void globfree(glob_t \(**pglob);"
.fi
.SH DESCRIPTION
The structure type
.B "glob_t"
is defined in the header \f4<glob.h>\fP and includes at least the
following members:
.sp
.nf
MemberType  MemberName Description
_______________________________________________________________
.B "size_t      gl_offs    Slots to reserve at start of gl_pathv."
.B "char \(***     gl_pathv   Pointer to list of matched pathnames."
.B "size_t      gl_pathc   Count of paths matched by pattern.    "
.fi
.sp
The argument \f2pattern\f1 is a pointer to a pathname pattern to be expanded.
The \f4glob\fP function matches all accessible pathnames against this pattern
and develops a list of all pathnames that match.  In order to have access to a
pathname, \f4glob\fP requires search permission on every component of a path
except the last, and read permission on each directory of any filename
component of \f2pattern\f1 that contains any of the following characters:
.sp
.nf
     \(**     ?      [
.fi
.sp
The \f4glob\fP function stores the number of matched pathnames into
.br
.B "pglob->gl_pathc"
and a pointer to a list of pointers to pathnames into
.br
.B "pglob->gl_pathv."
The pathnames are in sort order as defined by the current setting of the
LC_COLLATE category.  The first pointer after the last pathname is a null
pointer.  If the pattern does not match any pathnames, the returned number of
matched paths is set to zero, and the contents of
.B "pglob->gl_pathv"
are undetermined.
.sp
It is the caller's responsibilty to create the structure pointed to by
\f4glob\fP.  \f4glob\fP allocates other space as needed, including the memory
pointed to by
.B "gl_pathv."
The \f4globfree\fP function frees any space associated with \f4glob\fP from a
previous call to \f4glob\fP.
.sp
The \f2flags\f1 argument is used to control the behaviour of \f4glob\fP.  The
value of \f2flags\f1 is a bitwise inclusive OR of zero or more of the following
constants, which are defined in the header \f4<glob.h>\fP:
.sp
\f2GLOB_APPEND\f1
.sp
.in+0.5i
Append pathnames generated to the ones from a previous call to \f4glob\fP.
.in-0.5i
.sp
\f2GLOB_DOOFFS\f1
.sp
.in+0.5i
Make use of
.B "pglob->gl_offs."
If this flag is set,
.B "pglob->gl_offs"
is used to specify how many null pointers to add to the beginning of
.B "pglob->gl_pathv."
In other words,
.B "pglob->gl_pathv"
will point to
.B "pglob->gl_offs"
null pointers, followed by
.B "pglob->gl_pathc"
pathname pointers, followed by a null pointer.
.in-0.5i
.sp
\f2GLOB_ERR\f1
.sp
.in+0.5i
Causes \f4glob\fP to return when it encounters a directory that it cannot
open or read.  Ordinarily, \f4glob\fP continues to find matches.
.in-0.5i
.sp
\f2GLOB_MARK\f1
.sp
.in+0.5i
Each pathname that is a directory that matches \f2pattern\f1 has a slash
appended.
.in-0.5i
.sp
\f2GLOB_NOCHECK\f1
.sp
.in+0.5i
If \f2pattern\f1 does not match any pathname, then \f4glob\fP returns a list
consisting of only \f2pattern\f1, and the number of matched pathnames is
one (1).
.in-0.5i
.sp
\f2GLOB_NOESCAPE\f1
.sp
.in+0.5i
Disable backslash escaping.
.in-0.5i
.sp
\f2GLOB_NOSORT\f1
.sp
.in+0.5i
Ordinarily, \f4glob\fP sorts the matching pathnames according to the
current setting of the LC_COLLATE category.  When this flag is used the
order of pathnames returned is unspecified.
.in-0.5i
.sp
The GLOB_APPEND flag can be used to append a new set of pathnames to those
found in a previous call to \f4glob\fP.  The following rules apply when two
or more calls to \f4glob\fP are made with the same value of \f2pglob\f1 and
without intervening calls to \f4globfree\fP:
.sp
.in+0.2i
The first such call must not set GLOB_APPEND.  All subsequent calls must
set it.
.sp
All the calls must set GLOB_DOOFFS, or all must not set it.
.sp
After the second call,
.B "pglob->gl_pathv"
points to a list containing the following:
.sp
.in+0.3i
Zero or more null pointers, as specified by GLOB_DOOFFS and
.br
.B "pglob->gl_offs."
.sp
Pointers to the pathnames that were in the
.B "pglob->gl_pathv"
list before the call, in the same order as before.
.sp
Pointers to the new pathnames generated by the second call, in the
specified order.
.sp
.in-0.3i
The count returned in
.B "pglob->gl_pathc"
will be the total number of pathnames from the two calls.
.sp
The application can change any of the fields after a call to \f4glob\fP.
If it does, it must reset them to the original value before a subsequent call,
using the same \f2pglob\f1 value, to \f4globfree\fP or \f4glob\fP with the
GLOB_APPEND flag.
.sp
.in-0.2i
If, during the search, a directory is encountered that cannot be opened or
read and \f2errfunc\f1 is not a null pointer, \f4glob\fP calls
\f2(\(**errfunc())\f1 with two arguments:
.sp
.in+0.2i
The \f2epath\f1 argument is a pointer to the path that failed.
.sp
The \f2eerrno\f1 argument is the value of \f2errno\f1 from that failure,
as set by \f2opendir()\f1, \f2readdir()\f1 or \f2stat()\f1.  (Other values
may be used to report other errors not explicitly documented for those
functions.)
.in-0.2i
.sp
The following constants are defined as error return valuses for \f4glob\fP:
.sp
\f2GLOB_ABORTED\f1
.sp
.in +0.5i
The scan was stopped because GLOB_ERR was set or \f2(\(**errfunc())\f1
returned non-zero.
.in -0.5i
.sp
\f2GLOB_NOMATCH\f1
.sp
.in +0.5i
The pattern does not match any existing pathname, and GLOB_NOCHECK was not
set in flags.
.in -0.5i
.sp
\f2GLOB_NOSPACE\f1
.sp
.in +0.5i
An attempt to allocate memory failed.
.in -0.5i
.sp
If \f2(\(**errfunc())\f1 is called and returns non-zero or if the GLOB_ERR
flag is set in \f2flags\f1, \f4glob\fP stops the scan and returns GLOB_ABORTED
after setting
.I "gl_pathv"
in \f2pglob\f1 to reflect the paths already scanned.  If GLOB_ERR is not set
and either \f2errfunc\f1 is a null pointer or \f2(\(**errfunc())\f1 returns
zero, the error is ignaored.
.SH "RETURN VALUE"
On successful completion, \f4glob\fP returns zero.  The argument
.br
.B "pglob->gl_pathc"
returns the number of matched pathnames and the argument
.B "pglob->gl_pathv"
contains a pointer to a null-terminated list of matched and sorted pathnames.
However, if
.B "pglob->gl_pathc"
is zero, the contents of
.B "pglob->gl_pathv"
is undefined.
.sp
The \f4globfree\fP function returns no value.
.sp
If \f4glob\fP terminates due to an error, it returns one of the non-zero
constants defined in \f4<glob.h>\fP.  The arguments
.B "pglob->gl_pathc"
and
.br
.B "pglob->gl_pathv"
are still set as defined above.
.SH EXAMPLES
One use of the GLOB_DOOFFS flag is by applications that build an argument list
for use with \f4execv\fP, \f4execve\fP or \f4execvp\fP.  Suppose, for
example, that an application wants to do the equivalent of:
.sp
.nf
        \f4ls -l \(**.c\f1
.fi
.sp
But for some reason:
.sp
.nf
        \f4system("ls -l \(**.c")\f1
.fi
.sp
is not acceptable.  The application could obtain approximately the same result
using the sequence:
.sp
.nf
.in+0.5i
.B globbuf.gl_offs = 2;
.br
.B glob ("\(**.c", GLOB_DOOFFS, NULL, &globbuf);
.br
.B globbuf.gl_pathv[0] ="ls";
.br
.B globbuf.gl_pathv[1] ="-l";
.br
.B execp ("ls", &globbuf.gl_pathv[0]);
.fi
.in-0.5i
.sp
Using the same example:
.sp
.nf
        \f4ls -l \(**.c \(**.h\f1
.fi
.sp
could be approximately simulated using GLOB_APPEND as follows:
.sp
.nf
.in+0.5i
.B globbuf.gl_offs = 2;
.br
.B glob ("\(**.c", GLOB_DOOFFS, NULL, &globbuf);
.br
.B glob ("\(**.h", GLOB_DOOFFS|GLOB_APPEND, NULL, &globbuf);
.br
 ...
.SH "APPLICATION USAGE"
This function is not provided for the purpose of enabling utilites to
perform pathname expansion on their arguments, as the operation is performed
by the shell, and utilites are explicitly not expected to redo this.  Instead,
it is provided for applications that need to do pathname expansion on strings
obtained from other sources, such as a pattern typed by a user or read from
a file.
.sp
If a utility needs to see if a pathname matches a given pattern, it can use
\f4fnmatch\fP.
.sp
Note that
.B "gl_pathc"
and
.B "gl_pathv"
have meaning even if \f4glob\fP fails.  This allows \f4glob\fP to report
partial results in the event of an error.  However, if
.B "gl_pathc"
is zero,
.B "gl_pathv"
is unspecified even if \f4glob\fP did not return an error.
.sp
The GLOB_NOCHECK option could be used when an application wants to expand a
pathname if wildcards are specified, but wants to treat the pattern as just a
string otherwise.  The \f4sh\fP utility might use this for option-arguments,
for example.
.sp
The new pathnames generated by a subsequent call with GLOB_APPEND are not
sorted together with the previous pathnames.  This mirrors the way that the
sheel handles pathname expansion when multiple expansions are done on a
command line.
.sp
Applications that need tilde and parameter expansion should use \f4wordexp\fP.
.SH "SEE ALSO"
execv(2), fnmatch(3g), opendir(3b), readdir(3b), stat(2), wordexp(3g),
\f4<glob.h>\fP.
