'\"macro stdmacro
.if n .pH g1.wait @(#)wait	30.2 of 12/25/85
.nr X
.if \nX=0 .ds x} WAIT 1 "Essential Utilities" "\&"
.if \nX=1 .ds x} WAIT 1 "Essential Utilities"
.if \nX=2 .ds x} WAIT 1 "" "\&"
.if \nX=3 .ds x} WAIT "" "" "\&"
.ds OK [\|
.ds CK \|]
.TH \*(x}
.SH NAME
wait \- await completion of process
.SH SYNOPSIS
\f3wait\fP \*(OK \f2n\^\fP \*(CK
.SH DESCRIPTION
Wait for your background process whose process id is
.I n\^
and report its termination status.
If
.I n\^
is omitted,
all your shell's currently active background processes are waited for
and the return code will be zero.
.PP
The shell itself executes
.IR wait ,
without creating a new process.
.SH "SEE ALSO"
sh(1).
.SH CAVEAT
If you get the error message
.IR "cannot fork, too many processes" ,
try using the
.IR wait\^ (1)
command to clean up your background processes.
If this doesn't help,
the system process table is probably full or you have too many active foreground processes.
(There is a limit to the number of process ids
associated with your login,
and to the number the system can keep track of.)
.SH BUGS
Not all the processes of a 3- or more-stage
pipeline are children of the shell, and
thus cannot be waited for.
.PP
If
.I n\^
is not an active process id,
all your shell's currently active background processes are waited for
and the return code will be zero.
.\"	@(#)wait.1	6.2 of 9/2/83
.Ee
'\".so /pubs/tools/origin.att
