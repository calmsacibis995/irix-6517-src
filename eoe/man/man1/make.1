'\"macro stdmacro
.if n .pH g1.make @(#)make      @(#)make        31.4 of 1/30/87
.nr X
.if \nX=0 .ds x} MAKE 1 "Extended Software Generation System Utilities" "\&"
.if \nX=1 .ds x} MAKE 1 "Extended Software Generation System Utilities"
.if \nX=2 .ds x} MAKE 1 "" "\&"
.if \nX=3 .ds x} MAKE "" "" "\&"
.TH \*(x}
.SH NAME
\f4make\f1 \- maintain, update, and regenerate groups of programs (\f4DEVELOPMENT\fP)
.SH SYNOPSIS
\f4make [\f4\-eiknpqrsStuwdDPBNMOg\f4] [\-f \f2makefile\f4] \.\.\.
\ \ \ \ \ [\|\f2macros=name\f4\|] \.\.\. \f1[\|\f2target_name\f4\|] \.\.\.\f1
.SH DESCRIPTION
The 
.I make
utility can be used as a part of software development to update files that are
derived from other files. A typical case is one where object files are derived 
from the corresponding source files. The 
.I make
utility examines time relationships and updates those derived files
(called targets) that have modified times earlier than the modified
times of the files (called prerequisites) from which they are derived.
A description file (makefile) contains a description of the
relationships between files, and the commands that must be executed to
update the targets to reflect changes in their prerequisites. Each
specification, or rule, consists of a target, optional prerequisites
and optional commands to be executed when a prerequisite is newer than
the target. There are two types of rule:
.PP
.PD 0
.TP
-
inference rules, which have one target name with at least one period (\.) and no slash (/) 

.TP
-
target rules, which can have more than one target name.
.PD
.RE
.PP
In addition, 
.I make
has a collection of built-in macros and inference
rules that infer prerequisite relationships to simplify maintenance of
programs.
.PP
To receive exactly the behaviour described in this section,
a portable makefile must:
.PP
.PD 0
.TP
-
include the special target \.POSIX

.TP
-
omit any special target reserved for implementations (a leading period
followed by upper-case letters) that has not been specified by this
section.
.PP
\f4NOTE:\fP See \f4COMPATIBILITY ISSUES\fP section below for 
when these conditions are not met.
.PD
.RE
.PP
.SH OPTIONS 
The following options are supported:
.TP 13
.B \-b
Compatibility mode for old makefiles.
.TP
.B \-B
Blocked output.
In parallel mode, the output from concurrently updating targets can
be either intermingled or saved up and printed upon completion of the
target.
The default is to intermingle the output, this option turns on the 'blocking'
of output until the target has completed.
.TP
.B \-d
Debug.
As targets are traversed, the reason they are being updated is printed.
.TP
.B \-D
Debug.
A full dump of all aspects of target and variable handling.
This option usually produces an overwhelming amount of information.
.TP
.B \-e
Cause environment variables, including those with null values, to
override macro assignments within makefiles.
.TP
.BI \-f " makefile\^"
Specify a different makefile. The argument makefile is a pathname of a
description file, which is also referred to as the makefile. A pathname of
- denotes the standard input. There can be multiple instances of this
option, and they will be processed in the order specified.
.TP
.B \-g
Auto get.
If a file does not exist, attempt to 'get' it from
SCCS using the
.SM
.B $(GET)
macro.
.TP
.B \-i
Ignore error codes returned by invoked commands. This mode is the
same as if the special target \f4\.IGNORE\f1
were specified without prerequisites.
.TP
.B \-k 
Continue to update other targets that do not depend on the current 
target if a non-ignored error
occurs while executing the commands to bring a target up-to-date.
.TP
.B \-M
Turn off
.B \-N
(this is the default).
.TP
.B \-n
Write commands that would be executed on standard output, but do not
execute them. However, lines with a plus sign (\f4+\f1) prefix will be
executed. In this mode, lines with an at sign (\f4@\f1) character prefix
will be written to standard output.
.TP
.B \-N
Permit targets that have dependencies to still be candidates for
application of the
.SM
.I empty rule (NULL)
suffix transformation rules \f4(see the "Inference Rules" section below).\f1
.TP
.B \-O
Turn off compatibility mode for old makefiles.
.TP
.B \-p 
Write to standard output the
complete set of macro definitions and target descriptions. The output
format is unspecified.
.TP
.B \-P
Parallel.
Enables building independent parts of the makefile concurrently
\f4(see "Parallel Execution" section below).\f1
.TP
.B \-q 
Return a zero exit value if the target file
is up-to-date; otherwise, return an exit value of 1 (one). Targets will not
be updated if this option is specified. However, a command line
(associated with the targets) with a plus sign (\f4+\f1) prefix will be
executed.
.TP
.B \-r 
Clear the suffix list and do not use the built-in rules.
.TP
.B \-s 
Do not write command lines or touch messages (see \f4-t\f1) to standard
output before executing. This mode is the same as 
if the special target \f4\.SILENT\f1
were specified without prerequisites. 
.TP
.B \-S 
Terminate 
.I make
if an error occurs while executing the commands to
bring a target up-to-date. This will be the default 
and the opposite of the \f4-k\f1 option.
.TP
.B \-t 
Update the modification time of
each target as though a 
.I touch target 
had been executed. Targets that have prerequisites but no
commands (see \f4Target Rules\f1), or that are already up-to-date, will not be
touched in this manner. Write messages to standard output for each
target file indicating the name of the file and that it was touched.
Normally, the command lines associated with each target are not
executed. However, a command line with a plus sign (\f4+\f1) prefix will be
executed.  
.TP
.B \-u
Unconditional.
Build all targets regardless of whether they are up-to-date or not.
.TP
.B \-w
Suppress warning messages.  Fatal messages will not be affected.
.PP
If the \f4-k\f1 and \f4-S\f1 options are both specified on the command
line, by the 
.I MAKEFLAGS 
environment variable, or by the \f4MAKEFLAGS\f1 macro,
the last one evaluated will take precedence. The 
.I MAKEFLAGS 
environment
variable will be evaluated first and the command line will be evaluated
second. Assignments to the \f4MAKEFLAGS\f1 macro will be evaluated as
described in the \f4"ENVIRONMENT VARIABLES"\f1 section.

.SH OPERANDS
The following operands are supported:
.TP
.I target_name 
.PD
Target names, as defined in \f4EXTENDED DESCRIPTION.\f1
If no target is specified, while
.I make
is processing the makefiles, the first target that 
.I make
encounters that is not a special target or an inference rule will be used.
.TP
.I macro=name 
.PD
Macro definitions, as defined in the \f4Macros\f1 section.
.SH STDIN 
The standard input will be used only if the makefile
option-argument is
.B \-.
See \f4INPUT FILES\f1 section.
.SH INPUT FILES 
The input file, otherwise known as the makefile, is a text
file containing rules, macro definitions and comments.
.SH ENVIRONMENT VARIABLES
The following environment variables affect the execution of 
.I make:
.TP
.I MAKEFLAGS
.PD 0
This variable is interpreted as a character string representing a
series of option characters to be used as the default options. The
implementation will accept both of the following formats (but need not
accept them when intermixed):
.RS
.PD 1
.TP 4
1.
The characters are option letters
without the leading hyphens or blank character separation used on a
command line.  
.TP
2.
The characters are formatted in a manner similar to a
portion of the 
.I make
command line: options are preceded by hyphens and
blank-character-separated. The
.I macro=name 
macro definition operands can also be included. The
difference between the contents of \f4MAKEFLAGS\f1 and the command line is
that the contents of the variable will not be subjected to the word
expansions.
.PP
When the command-line options \f4-\f1f or \f4-\f1p are used, they will take effect
regardless of whether they also appear in \f4MAKEFLAGS.\f1
.PP
The \f4MAKEFLAGS\f1 variable will be
accessed from the environment before the makefile is read. At that
time, all of the options (except \f4-\f1f and \f4-\f1p ) and command-line macros not
already included in \f4MAKEFLAGS\f1 are added to the \f4MAKEFLAGS\f1 macro. The
\f4MAKEFLAGS\f1 macro will be passed into the environment as an environment
variable for all child processes. If the \f4MAKEFLAGS\f1 macro is
subsequently set by the makefile, it replaces the 
.I MAKEFLAGS 
variable currently found in the environment.
.RE
.PP
The value of the 
.I SHELL 
environment variable will not be used as a macro
and will not be modified by defining the \f4SHELL\f1 macro in a makefile or
on the command line. All other environment variables, including those
with null values, are used as macros, as defined in the \f4"Macros"\f1 section.

.SH ASYNCHRONOUS EVENTS 
If not already ignored, 
.I make
will trap SIGHUP, SIGTERM, SIGINT and SIGQUIT and remove the current target unless the
target is a directory or the target is a prerequisite of the special
target \f4.PRECIOUS\f1
or unless one of the \f4-n\f1, \f4-p\f1 or \f4-q\f1 options was specified. Any targets
removed in this manner will be reported in diagnostic messages of
unspecified format, written to standard error. After this cleanup
process, if any, 
.I make
will take the standard action for all other
signals.

.SH STDOUT 
The 
.I make
utility will write all commands to be executed to
standard output unless the s option was specified, the command is
prefixed with an at sign, or the special target \f4.SILENT\f1
has either the current target as a prerequisite or has no
prerequisites. If 
.I make
is invoked without any work needing to be done,
it will write a message to standard output indicating that no action
was taken.
.SH STDERR 
Used only for diagnostic messages.
.SH OUTPUT FILES 
None. However, utilities invoked by 
.I make
may create additional files.
.SH EXTENDED DESCRIPTION 
The 
.I make
utility attempts to perform the actions
required to ensure that the specified targets are up-to-date. A target
is considered out-of-date if it is older than any of its prerequisites
or if it does not exist. The 
.I make
utility treats all prerequisites as
targets themselves and recursively ensures that they are up-to-date,
processing them in the order in which they appear in the rule. The 
.I make
utility uses the modification times of files to determine if the
corresponding targets are out-of-date. 
.PP
After 
.I make
has ensured that all of the prerequisites of a target are
up-to-date and if the target is out-of-date, the commands associated
with the target entry are executed. If there are no commands listed for
the target, the target is treated as up-to-date.
.PP
.B Makefile Syntax
.PP
A makefile can contain rules, macro definitions, and
comments. There are two kinds of rules: inference rules and target
rules. The 
.I make
utility contains a set of built-in inference rules. If
the \f4-\f1r option is present, the built-in rules are not used and the suffix
list is cleared. Additional rules of both types can be specified in a
makefile. If a rule or macro is defined more than once, the value of
the rule or macro will be that of the last one specified. Comments
start with a number sign (\f4#\f1) and continue until an unescaped newline
character is reached.
.PP
By default, the following files are tried in sequence:
.B ./makefile, ./Makefile, ./s.makefile, SCCS/s.makefile, ./s.Makefile
and 
\f4SCCS/s.Makefile.\f1
.PP
The \f4-\f1f option directs 
.I make
to ignore any of these default files and use
the specified argument as a makefile instead. If the \f4-\f1 argument is
specified, standard input will be used.
.PP
The term makefile is used to refer to any rules provided by the user, whether in
\f4./makefile\f1 or its variants, or specified by the \f4-\f1f option.
.PP
The rules in makefiles consist of the following types of lines: target
rules, including special targets (see \f4Target Rules\f1);  inference rules (see
\f4Inference Rules\f1); macro definitions (see \f4Macros\f1); empty lines; and comments.
Comments start with a number sign (\f4#\f1) and continue until an unescaped
newline character is reached.
.PP
When an escaped newline character (one
preceded by a \f4backslash\f1) is found anywhere in the makefile, it is
replaced, along with any leading white space on the following line,
with a single space character.
.PP
.B Makefile Execution
.PP
Command lines are processed one at a time by writing the command line
to the standard output (unless one of the conditions listed below under
\f4@\f1 suppresses the writing) and executing the commands in the line. A tab
character may precede the command to standard output. Commands will be
executed by passing the command line to the command interpreter in the
same manner as if the string were the argument to the
.I system()
function.
.PP
The environment for the command being executed will contain all of the
variables in the environment of 
.I make.
The macros from the command line to
.I make
will be added to 
.I make's 
environment. Other implementation-dependent variables may also be added to 
.I make's
environment. If any command-line macro has been defined elsewhere, the
command-line value will overwrite the existing value. If the 
.I MAKEFLAGS
variable is not set in the environment in which 
.I make
was invoked, in the makefile or on the command line, it will be created by 
.I make, 
and will contain all options specified on the command line except for the 
\f4-f\f1 and \f4-p\f1 options. It may also contain implementation-dependent options.
.PP
By default, when 
.I make
receives a non-zero status from the execution of
a command, it terminates with an error message to standard error.
.PP
Command lines can have one or more of the following prefixes: a hyphen
(\f4-\f1), an at sign (\f4@\f1), or a plus sign (\f4+\f1). These modify the way in
which 
.I make
processes the command. When a command is written to standard
output, the prefix is not included in the output.  
.PD 1
.TP 4
.B - 
If the command
prefix contains a hyphen, or the \f4-i\f1 option is present, or the special
target \f4.IGNORE\f1
has either the current target as a prerequisite or has no
prerequisites, any error found while executing the command will be
ignored.
.TP
.B @ 
If the command prefix contains an at sign and the command-line n
option is not specified, or the s option is present, or the special
target \f4.SILENT\f1
has either the current target as a prerequisite or has no
prerequisites, the command will not be written to standard output
before it is executed.
.TP
.B + 
If the command prefix contains a plus sign,
this indicates a command line that will be executed even 
if \f4-n\f1, \f4-q\f1 or \f4-t\f1
is specified.
.PP
.B Include Files
.PP
If the string
.I include
or
.I sinclude
appears at the beginning of a line in a
.I makefile,
and is followed by a blank or a tab, the rest of the
line is assumed to be a filename and will be read by 
the current invocation, after substituting for any macros.
For
.I include
it is a fatal error if the file is not readable,
for
.I sinclude
a non-readable file is silently ignored.
.PP
.B Alternate Make
.PP
.I make
understands a convention similar to the alternate interpreter feature of
.I exec(2) .
If the first line of the makefile starts with a 
.B "#!alternate_make", 
then
.I make
will attempt to
.I exec
the alternate make with the same environment and arguments that
.I make
itself was invoked with.
Additional arguments may be supplied on the 
.B "#!" 
line - these are placed
ahead of all the command line arguments given to the original invocation
of
.I make .
If a new makefile specification is given using the
.B -f
flag, any original
.B -f
options given on the command line are ignored.
If the alternate make cannot be found in the user's
.B PATH
or make finds that it would be re-invoking itself, then make silently ignores
the line and continues to execute the remainder of the
makefile.
The
.B -d
flag will display information as to whether the alternate make was
successfully invoked.
As a special case to support compatibility with a makefile used as a
shell script (with a "#!/bin/make -f"), a lone
.B -f
flag is ignored.
.PP
.B Parallel Execution
.PP
The
.B \-P
option turns on parallel execution. In this mode
.I make
views all dependencies for a given target as independent, and works on
a set of them concurrently.  By default, the concurrency factor is two.
This may be changed by setting the environment variable
.I PARALLEL.
Note that some makefiles make use of the property that in the non-parallel
versions of make dependencies were brought up to date in the order listed.
The following makefile relies on this ordering
and thus would not work correctly when invoked with the parallel option:
.PP
.TP
    default: a b
    a:
           mkdir foo
    b:
           cd foo; echo hi
.PP
.B Target Rules
.PP
Target rules are formatted as follows:
.PP
.RS
.I target [target...]: [prerequisite...][; command ]
.br
.I [<tab> command
.br
.I  <tab> command
.br
.I ...]
.br
.I line that does not begin with 
.I <tab>
.br
.RE
.PP
Target entries are specified by a
blank-character-separated, non-null list of targets, then a colon, then
a blank-character-separated, possibly empty list of prerequisites. Text
following a semicolon, if any, and all following lines that begin with
a tab character, are command lines to be executed to update the target.
The first non-empty line that does not begin with a tab character or \f4#\f1
begins a new entry. An empty or blank line, or a line beginning with \f4#,\f1
may begin a new entry.
.PP
Applications must select target names from the set of characters
consisting solely of periods, underscores, digits and alphabetics from
the portable character set. Implementations may allow other characters in
target names as extensions. The interpretation of targets containing
the characters (\f4%\f1) and (\f4"\f1) is implementation-dependent.  A target that has
prerequisites, but does not have any commands, can be used to add to
the prerequisite list for that target. Only one target rule for any
given target can contain commands.
.PP
Lines that begin with one of the following are called special targets
and control the operation of 
.I make:
.TP 13
.B .DEFAULT
If the makefile uses this special target, it must be specified with
commands, but without prerequisites. The commands will be used by 
.I make
if there are no other rules available to build a target.
.TP
.B .IGNORE
Prerequisites of this special target are targets themselves; this will
cause errors from commands associated with them to be ignored in the
same manner as specified by the \f4-i\f1 option. Subsequent occurrences of
.B .IGNORE
add to the list of targets ignoring command errors. If no prerequisites
are specified, 
.I make
will behave as if the \f4-i\f1 option had been specified
and errors from all commands associated with all targets will be
ignored.
.TP
.B .MAKEOPTS
Any command line option except
.B \-[ref]
may be set in a makefile by listing it as a dependency to this target.
Note that this is a target not a macro; do not assign (using an '=')
a value to it.
.TP
.B .POSIX
This special target must be specified without prerequisites or
commands. If it appears before the first non-comment line in the
makefile, 
.I make
will process the makefile as specified by this section;
otherwise, the behaviour of 
.I make
is unspecified.
.TP
.B .PRECIOUS
Prerequisites of this special target will not be removed if 
.I make
receives one of the asynchronous events explicitly described in
.B ASYNCHRONOUS EVENTS. 
Subsequent occurrences of
.B .PRECIOUS
add to the list of precious files. If no prerequisites are specified,
all targets in the makefile will be treated as if specified with
.B .PRECIOUS.
.TP
.B .SCCS_GET
This special target must be specified without prerequisites. If this
special target is included in a makefile, the commands specified with
this target replace the default commands associated with this special
target. (See "\f4Default Rules"\f1).  The commands specified with this target are used
to get all SCCS files that are not found in the current directory.
.IP
When source files are named in a dependency list, 
.I make
treats them just
like any other target. Because the source file is presumed to be
present in the directory, there is no need to add an entry for it to
the makefile. When a target has no dependencies, but is present in the
directory, 
.I make
assumes that that file is up-to-date. If, however, an
SCCS file named \f4SCCS/s\f1.source_file is found for a target 
.I source_file, make
does some additional checking to assure that the target is up-to-date. If the
target is missing, or if the SCCS file is newer, 
.I make
automatically
issues the commands specified for the
.B .SCCS_GET
special target to retrieve the most recent version. However, if the
target is writable by anyone, 
.I make
does not retrieve a new version.
.TP
.B .SILENT
Prerequisites of this special target are targets themselves; this
causes commands associated with them to not be written to the standard
output before they are executed. Subsequent occurrences of
.B .SILENT
add to the list of targets with silent commands. If no prerequisites
are specified, 
.I make
will behave as if the \f4-s\f1 option had been specified
and no commands or touch messages associated with any target will be
written to standard output.
.TP
.B .SUFFIXES
Prerequisites of
.B .SUFFIXES
are appended to the list of known suffixes and are used in conjunction
with the inference rules (see "\f4Inference Rules\f1" ). If
.B .SUFFIXES
does not have any prerequisites, the list of known suffixes will be
cleared. Makefiles must not associate commands with
.B .SUFFIXES.

Targets with names consisting of a leading period followed by the
upper-case letters POSIX and then any other characters are reserved for
future standardisation. Targets with names consisting of a leading
period followed by one or more upper-case letters are reserved for
implementation extensions.
.PP
.B Macros 
.PP
Macro definitions are in the form:  
.PP
.RS
.I string1 = [ string2 ] 
.RE
.PP
The macro named 
.I string1 
is defined as having the value of
.I string2, 
where 
.I string2 
is defined as all characters, if any, after the
equal sign, up to a comment character (\f4#\f1) or an unescaped newline
character. Any blank characters immediately before or after the equal
sign will be ignored.  
.PP
Subsequent appearances of 
.I $(string1) 
or 
.I ${string1} are replaced by 
.I string2. 
The parentheses or braces are optional if
.I string1 
is a single character. The macro \f4$$\fP is replaced by the single
character \f4$\fP in effect escaping the \f4$\fP character.
.PP
See \f4NOTES\fP below about macros defined within macros. 
.PP
Applications must select macro names from the set of characters
consisting solely of periods, underscores, digits and alphabetics from
the portable character set.
A macro name cannot contain an equal sign.
Implementations may allow other characters in macro names as
extensions.
.PP
Macros can appear anywhere in the makefile. Macros in
target lines will be evaluated when the target line is read. Macros in
command lines will be evaluated when the command is executed. Macros in
macro definition lines will not be evaluated until the new macro being
defined is used in a rule or command. A macro that has not been defined
will evaluate to a null string without causing any error condition.
.PP
The forms 
.B $(string1[:subst1=[subst2]]) 
or 
.B ${string1[:subst1=[subst2]]}
can be used to replace all occurrences of 
.I subst1
with 
.I subst2 
when the macro substitution is performed. The 
.I subst1 
to be replaced is recognised when it is a suffix at the end of a word in
.I string1 
(where a 
.I word, 
in this context, is defined to be a string
delimited by the beginning of the line, a blank or newline character).
.PP
Macro assignments will be accepted from the sources listed below, in
the order shown. If a macro name already exists at the time it is being
processed, the newer definition will replace the existing definition.
.TP 4
1.
Macros defined in 
.I make's 
built-in inference rules.
.TP
2.
The contents of the environment, including the variables with null values, in the order
defined in the environment.
.TP
3.
Macros defined in the makefiles, processed
in the order specified.
.TP
4.
Macros specified on the command line. It is
unspecified whether the internal macros defined in \f4Internal Macros\f1 are accepted
from the command line.
.PP
If the \f4-e\f1 option is specified, the order of
processing sources items 2 and 3 will be reversed.
.PP
The \f4SHELL\f1 macro is treated specially. It is provided by 
.I make
and set to the pathname of the shell command language interpreter (see 
.Ish). 
The 
.I SHELL 
environment variable will not affect the value of the \f4SHELL\f1
macro. If \f4SHELL\f1 is defined in the makefile or is specified on the
command line, it will replace the original value of the \f4SHELL\f1 macro,
but will not affect the 
.I SHELL 
environment variable. Other effects of
defining \f4SHELL\f1 in the makefile or on the command line are
implementation-dependent.
.PP
.B Inference Rules 
.PP
Inference rules are formatted as follows:
.PP
.RS
.I target:
.br
.I <tab>command 
.br
.I [<tab>command ]
.br
.I ...
.br
.I line that does not begin with 
.I <tab> or #
.RE
.PP
The 
.I target 
portion must be a
valid target name (see "\f4Target Rules\f1") of the form 
.I .s2 
or
.I .s1.s2 
(where
.I .s1
and
.I .s2
are suffixes that have been given as prerequisites of the \f4.SUFFIXES\f1
special target and 
.I s1 
and 
.I s2 
do not contain any slashes or periods.) If
there is only one period in the target, it is a single-suffix inference
rule. Targets with two periods are double-suffix inference rules.
Inference rules can have only one target before the colon.
.PP
The makefile must not specify prerequisites for inference rules; no
characters other than white space can follow the colon in the first
line, except when creating the 
.I empty rule, 
described below.
Prerequisites are inferred, as described below.
.PP
Inference rules can be redefined. A target that matches an existing
inference rule will overwrite the old inference rule. An empty rule can
be created with a command consisting of simply a semicolon (that is,
the rule still exists and is found during inference rule search, but
since it is empty, execution has no effect). The empty rule also can be
formatted as follows:
.PP
.RS
.I rule: ; 
.RE
.PP
where zero or more blank characters separate the colon and semicolon. 
.PP
The 
.I make
utility uses the suffixes
of targets and their prerequisites to infer how a target can be made
up-to-date. A list of inference rules defines the commands to be
executed. By default, 
.I make
contains a built-in set of inference rules.
Additional rules can be specified in the makefile.
.PP
The special target 
.B .SUFFIXES
contains as its prerequisites a list of suffixes that are to be used by
the inference rules. The order in which the suffixes are specified
defines the order in which the inference rules for the suffixes are
used. New suffixes will be appended to the current list by specifying a
.B .SUFFIXES
special target in the makefile. A 
.B .SUFFIXES
target with no prerequisites will clear the list of suffixes. An empty
.B .SUFFIXES
target followed by a new 
.B .SUFFIXES
list is required to change the order of the suffixes.
.PP
Normally, the user would provide an inference rule for each suffix. The inference
rule to update a target with a suffix
.I .s1
from a prerequisite with a suffix
.I .s2
is specified as a target
.I .s2.s1.
The internal macros provide the means to specify general inference
rules. (See \f4Internal Macros\f1)
.PP
When no target rule is found to update a target, the inference rules
are checked. The suffix of the target 
.I (.s1) 
to be built is compared to the list of suffixes specified by the
\f4.SUFFIXES\f1 special targets. If the
.I .s1
suffix is found in \f4.SUFFIXES,\f1
the inference rules are searched in the order defined for the first
.I .s2.s1
rule whose prerequisite file 
.I (\f4$*\f1.s2)
exists. If the target is out-of-date with respect to this
prerequisite, the commands for that inference rule are executed.
.PP
If the target to be built does not contain a suffix and there is no rule
for the target, the single suffix inference rules will be checked. The
single-suffix inference rules define how to build a target if a file is
found with a name that matches the target name with one of the single
suffixes appended. A rule with one suffix
.I .s2
is the definition of how to build 
.I target 
from 
.I target.s2.
The other suffix 
.I (.s1) 
is treated as null.
.PP
A tilde (\f4\~\f1) in the above rules refers to an SCCS file in the current
directory. Thus, the rule
.B .c.o
would transform an SCCS C-language source file into an object file 
.B (.o). 
Because the 
.B s.
of the SCCS files is a prefix, it is incompatible
with 
.I make's 
suffix point of view. Hence, the 
.B ~ 
is a way of changing any file reference into an SCCS file reference.
.PP
.B Libraries
.PP
If a target or prerequisite contains parentheses, it will be
treated as a member of an archive library. For the 
.I lib(member.o)
expression 
.I lib 
refers to the name of the archive library and 
.I member.o
to the member name. The member must be an object file with the
.I .o
suffix. The modification time of the expression is the modification
time for the member as kept in the archive library
.I (See ar).
The
.B .a
suffix refers to an archive library. The
.I .s2.\f4a\f1
rule is used to update a member in the library from a file with a suffix
.I .s2.
.PP
.B Internal Macros
.PP
The 
.I make
utility maintains five internal macros that
can be used in target and inference rules. In order to clearly define
the meaning of these macros, some clarification of the terms 
.I target rule, inference rule, target 
and 
.I prerequisite 
is necessary.
.PP
Target rules are specified by the user in a makefile for a particular target.
Inference rules are user- or 
.I make
-specified rules for a particular
class of target names. Explicit prerequisites are those prerequisites
specified in a makefile on target lines. Implicit prerequisites are
those prerequisites that are generated when inference rules are used.
Inference rules are applied to implicit prerequisites or to explicit
prerequisites that do not have target rules defined for them in the
makefile. Target rules are applied to targets specified in the
makefile.
.PP
Before any target in the makefile is updated, each of its prerequisites
(both explicit and implicit) will be updated. This is accomplished by
recursively processing each prerequisite. Upon recursion, each
prerequisite becomes a target itself. Its prerequisites in turn are
processed recursively until a target is found that has no
prerequisites, at which point the recursion stops. The recursion then
backs up, updating each target as it goes.
.PP
In the definitions that follow, the word 
.I target 
refers to one of:
.PP
.PD 0
.TP
-
a target specified in the makefile

.TP
-
an explicit prerequisite specified in the makefile that becomes the
target when 
.I make
processes it during recursion

.TP
-
an implicit prerequisite that becomes a target when 
.I make
processes it during recursion.
.PD
.RE
.PP
In the definitions that follow, the word
.I prerequisite 
refers to one of the following:
.PP
.PD 0
.TP
-
an explicit prerequisite specified in the makefile for a particular target

.TP
-
an implicit prerequisite generated as a result of locating an
appropriate inference rule and corresponding file that matches the
suffix of the target.
.PD
.RE
.PP
The internal macros are:
.TP 8
.B $@ 
The $@ evaluates to the full target name of the current target, or
the archive filename part of a library archive target. It is evaluated
for both target and inference rules.  For example, in the
.B .c.a
inference rule, $@ represents the out-of-date
.B .a
file to be built. Similarly, in a makefile target rule to build 
.B lib.a
from 
.B file.c, 
$@ represents the out-of-date 
.B lib.a.
.TP
.B $$@
The $$@ macro stands for
the full target name of the current target (which is \f3$@\fP).
It has meaning only on the dependency line in a makefile.
Thus, in the following:

    cat dd: $$@.c

the dependency is translated at execution time first to the string
.B cat.c,
then to the string
.B dd.c.
.TP
.B $% 
The $% macro is evaluated only when the current target is an archive
library member of the form 
.I libname(member\f4.o\f1).
In these cases, $@ evaluates to 
.I libname 
and $% evaluates to 
.I member.\f4o.\f1
The $% macro is evaluated for both target and inference rules.
.IP
For example, in a makefile target rule to build 
.B lib.a(file.o), 
$% represents 
.B file.o 
as opposed to $@, which represents 
.B lib.a.
.TP
.B $?  
The $? macro evaluates to the list of prerequisites that are newer
than the current target. It is evaluated for both target and inference
rules.
.IP
For example, in a makefile target rule to build 
.B prog
from
.B file1.o, file2.o 
and 
.B file3.o, 
and where 
.B prog 
is not out of date with
respect to 
.B file1.o, 
but is out of date with respect to 
.B file2.o 
and
.B file3.o, 
$? represents 
.B file2.o 
and 
.B file3.o.
.TP
.B $< 
In an inference rule, $< evaluates to the file name whose existence
allowed the inference rule to be chosen for the target. In the
.B .DEFAULT
rule, the $< macro evaluates to the current target name. The $< macro
is evaluated only for inference rules.
.IP
For example, in the
.B .c.a
inference rule, $< represents the prerequisite
.B .c
file.
.TP
.B $* 
The $* macro evaluates to the current target name with its suffix
deleted. It is evaluated at least for inference rules.
.IP
For example, in the
.B .c.a
inference rule, $*.o represents the out-of-date
.B .o
file that corresponds to the prerequisite
.B .c
file.
.PP
Each of the internal macros has an alternative form. When an
upper-case D or F is appended to any of the macros, the meaning is
changed to the 
.I directory part 
for D and 
.I filename 
part for F. The directory part is the path prefix of the file without a trailing
slash; for the current directory, the directory part is ``.''. When the
$? macro contains more than one prerequisite filename, the $(?D) and
$(?F) (or ${?D} and ${?F}) macros expand to a list of directory name
parts and filename parts respectively.
.PP
For the target 
.I lib(member.o)
and the 
.B s2.a 
rule, the internal macros are defined as:
.PP
.TP 8
.B $< 
.I member.\f4s2\f1
.TP
.B $* 
.I member 
.TP
.B $@ 
.I lib
.TP
.B $?
.I member.\f4s2\f1
.TP
.B $% 
.I member.\f4o\f1
.PP
.B Default Rules 
.PP 
The default rules for 
.I make
achieve results that are the same as if the following were used.
.PP 
.B SPECIAL TARGETS:
.PP
 .SCCS_GET: sccs $(SCCSFLAGS) get $(SCCSGETFLAGS) $@
.PP
 .SUFFIXES: .o .c .y l .a .sh .f .c~ .y~ .l~ .sh~ .f~
.PP
.B MACROS:
.PP
MAKE=make
.br
AR=ar
.br
ARFLAGS=-rv
.br
YACC=yacc
.br
YFLAGS=
.br
LEX=lex
.br
LFLAGS=
LDFLAGS=
.br
CC=c89
.br
CFLAGS=-O
.br
FC=fort77
.br
FFLAGS=-O 1
.br
GET=get
.br
GFLAGS=
SCCSFLAGS=
.br
SCCSGETFLAGS=-s
.PP
.PP
.B SINGLE SUFFIX RULES
.PP
 .c:  
.br
          $(CC) $(CFLAGS) $(LDFLAGS) -o $@ $<
.br
.PP
 .f:  
.br
          $(FC) $(FFLAGS) $(LDFLAGS) -o $@ $<
.br
.PP
 .sh:
.br
          cp $< $@
.br
          chmod a+x $@
.br
 .c~:
.br
          $(GET) $(GFLAGS) -p $< > $*.c
          $(CC) $(CFLAGS) $(LDFLAGS) -o $@ $*.c
.br
.PP
 .f~:
.br
          $(GET) $(GFLAGS) -p $< > $*.f
          $(FC) $(FFLAGS) $(LDFLAGS) -o $@ $*.f
.br
.PP
 .sh~:
.br
          $(GET) $(GFLAGS) -p $< > $*.sh  
.br
          cp $*.sh $@
.br
          chmod a+x $@
.PP
.B DOUBLE SUFFIX RULES
.PP
 .c.o:
.br
          $(CC) $(CFLAGS) -c $<
.br
.PP
 .f.o:
.br
          $(FC) $(FFLAGS) -c $<
.br
.PP
 .y.o:
.br
          $(YACC) $(YFLAGS) $<
.br
          $(CC) $(CFLAGS) -c y.tab.c
.br
          rm -f y.tab.c
.br
          mv y.tab.o $@
.br
.PP
 .l.o:
.br
          $(LEX) $(LFLAGS) $<
.br
          $(CC) $(CFLAGS) -c lex.yy.c
.br
          rm -f lex.yy.c
.br
          mv lex.yy.o $@
.br
.PP
 .y.c:
.br
          $(YACC) $(YFLAGS) $<  
.br
          mv y.tab.c $@
.br
.PP
 .l.c:
.br
          $(LEX) $(LFLAGS) $<
.br
          mv lex.yy.c $@
.br
.PP
 .c~.o:
.br
          $(GET) $(GFLAGS) -p $< > $*.c
.br
          $(CC) $(CFLAGS) -c $*.c
.br
.PP
 .f~.o:
.br
          $(GET) $(GFLAGS) -p $< > $*.f
.br
          $(FC) $(FFLAGS) -c $*.f
.br
.PP
 .y~.o:
.br
          $(GET) $(GFLAGS) -p $< > $*.y
.br
          $(YACC) $(YFLAGS) $*.y
.br
          $(CC) $(CFLAGS) -c y.tab.c
.br
          rm -f y.tab.c
.br
          mv y.tab.o $@
.br
.PP
 .l~.o:
.br
          $(GET) $(GFLAGS) -p $< > $*.l
.br
          $(LEX) $(LFLAGS) $*.l
.br
          $(CC) $(CFLAGS) -c lex.yy.c
.br
          rm -f lex.yy.c
.br
          mv lex.yy.o $@
.br
.PP
 .y~.c:
.br
          $(GET) $(GFLAGS) -p $< > $*.y
.br
          $(YACC) $(YFLAGS) $*.y
.br
          mv y.tab.c $@
.br
.PP
 .l~.c:
.br
          $(GET) $(GFLAGS) -p $< > $*.l
.br
          $(LEX) $(LFLAGS) $*.l
.br
          mv lex.yy.c $@
.br
.PP
 .c.a:
.br
          $(CC) -c $(CFLAGS) $<
.br
          $(AR) $(ARFLAGS) $@ $*.o
.br
          rm -f $*.o
.br
.PP
 .f.a:
.br
          $(FC) -c $(FFLAGS) $<
.br
          $(AR) $(ARFLAGS) $@ $*.o
.br
          rm -f $*.o
.PP
.SH EXIT STATUS 
.PP
When the 
.B -q 
option is specified, the 
.I make
utility will exit with one of the following values:
.PP
 0 Successful completion.
.br
 1 The target was not up-to-date.
.br
>1 An error occurred.
.PP
When the 
.B -q 
option is not specified, the 
.I make
utility will exit with one of the following values:
.PP
 0 successful completion 
.PP
>0 an error occurred 
.PP
.SH APPLICATION USAGE 
If there is a source file (such as
.B ./source.c) 
and there are two SCCS files corresponding to it 
.B (./s.source.c
and
.B ./SCCS/s.source.c), 
.I make
will use the SCCS file in the current directory. However, users
are advised to use the underlying SCCS utilities 
.I (admin, delta, get,
and so forth) or the sccs utility for all source files in a given
directory. If both forms are used for a given source file, future
developers may be confused.
.PP
It is incumbent upon portable makefiles to specify the
.B .POSIX
special target in order to guarantee that they are not affected by
local extensions.
.PP
The 
.B -k 
and 
.B -S 
options are both present so that the
relationship between the command line, the 
.I MAKEFLAGS 
variable, and the
makefile can be controlled precisely. If the 
.B -k 
flag is passed in
.I MAKEFLAGS 
and a command is of the form:
.PP
.IP
$(MAKE) -S foo 
.PP
then the default behaviour is restored for the child 
.I make.
.PP
When the 
.B -n 
option is specified, it is always added to 
.I MAKEFLAGS. 
This allows a recursive
.I make
.B -n
.I target 
to be used to see all of the action that would be taken to update 
.I target.
.PP
Because of widespread historical practice, interpreting a # number sign
inside a variable as the start of a comment has the unfortunate side
effect of making it impossible to place a number sign in a variable,
thus forbidding something like:
.PP
.IP
CFLAGS = "-D COMMENT_CHAR='#'" 
.PP
Many historical 
.I make
utilities stop chaining together inference rules when
an intermediate target is non-existent. For example, it might be
possible for a 
.I make
to determine that both .y.c and .c.o could be used
to convert a .y to a .o. Instead, in this case, 
.I make
requires the use
of a .y.o rule.
.PP
The best way to provide portable makefiles is to
include all of the rules needed in the makefile itself. The rules
provided use only features provided by other parts of the standard. The
default rules include rules for optional commands in the standard. Only
rules pertaining to commands that are provided are needed in an
implementation's default set.
.PP
Macros used within other macros are
evaluated when the new macro is used rather than when the new macro is
defined. Therefore:
.PP
.IP
MACRO = 
.I value1
.br
NEW   = $(MACRO)
.br
MACRO = 
.I value2
.IP
target:
.br
       echo $(NEW)
.PP
would produce 
.I value2 
and not 
.I value1 
since 
.B NEW 
was not expanded until it was needed in the 
.I echo 
command line.
.PP
Some historical applications have been known to intermix 
.I target_name 
and
.I macro=name 
operands on the command line, expecting that all of the
macros will be processed before any of the targets are dealt with.
Portable applications do not do this, although some backward
compatibility support may be included in some implementations.
.PP
The following characters in filenames may give trouble:
.IP
=   :   `   '   @
.PP
For inference rules, the description of $< and $? seem similar.
However, an example shows the minor difference. In a makefile
containing:
.IP
foo.o: foo.h
.PP 
if 
.B foo.h 
is newer than 
.B foo.o, 
yet 
.B foo.c 
is older than 
.B foo.o, 
the built-in rule to make
.B foo.o 
from 
.B foo.c 
will be
used, with $< equal to 
.B foo.c 
and $? equal to 
.B foo.h. 
If
.B foo.c 
is also newer than 
.B foo.o, 
$< is equal to 
.B foo.c 
and $? is equal to 
.B foo.h foo.c.
.PP
.SH EXAMPLES 
.PP
.TP 4
1.
The following command:  

     make

makes the first target found in the makefile.
.TP
2.
The following command:  

    make junk 

makes the target junk.
.TP
3.
The following makefile says that 
.B pgm 
depends on two files, 
.B a.o 
and 
.B b.o,
and that they in turn depend on their corresponding source files 
.B (a.c
and 
.B b.c), 
and a common file 
.B incl.h:

pgm: a.o b.o 
        c89 a.o b.o -o pgm

a.o: incl.h a.c
        c89 -c a.c 

b.o: incl.h b.c 
        c89 -c b.c
.TP
4.
An example for making optimised
.B .o
files from
.B .c
files is:

 .c.o:
        c89 -c -O $*.c 

or:

 .c.o:
        c89 -c -O $< 
.TP
5.
The most common use of the archive interface follows.
Here, it is assumed that the source files are all C-language source:

lib:   lib(file1.o) lib(file2.o) lib(file3.o)  
       @echo lib is now up-to-date

The
.B .c.a
rule is used to make 
.B file1.o, file2.o 
and 
.B file3.o 
and insert them into
.B lib.

The treatment of escaped newline characters throughout the makefile is
historical practice. For example, the inference rule:

    .c.o\\

    :

works, and the macro:

    f=     bar baz\\ 

           biz 

    a:  
           echo ==$f== 

will echo ==bar baz biz==.

If $? were:

    /usr/include/stdio.h /usr/include/unistd.h foo.h 

then $(?D) would be:

    /usr/include /usr/include .  

and $(?F) would be:

    stdio.h unistd.h foo.h 

.TP
6.
The contents of the built-in rules can be viewed by
running:

    make -p -f /dev/null 2>/dev/null

.PP
.SH SEE ALSO 
.PP
.I ar, c89, cc, get, lex, sh, yacc
.SH NOTES
The VPATH facility is a derivation of the undocumented VPATH
feature in the System V Release 3 version of
.IR make .
System V Release 4 has a new VPATH implementation, much like the
.IR pmake (1)
.SM
.B .PATH
feature. This new feature is also undocumented in the standard
System V Release 4 manual pages.
For this reason it is not available in the IRIX version of
.I make .
The VPATH facility should not be used with the new parallel make option.
.PP
An added feature is the ability for macros to be placed with macros.
For example, when FLAGS = TYPE, then $(MAKE_${FLAGS}) will get expanded to
the macro $(MAKE_TYPE). This syntax can handle about 100 levels of imbedding.
.SH COMPATIBILITY ISSUES
When the special target \f4.POSIX\fP is not specified, the following backward
compatible actions take place:
.TP 4
1.
The content of the \f4MAKEFLAGS\fP variable will contain only the command line
options and not command line macros. 
.SH BUGS
Filenames with the characters
.B "= : @"
will not work.
.PP
Commands that are directly executed by the shell,
notably
.IR cd (1),
are ineffectual across new-lines in
.IR make .
.PP
The syntax \f3(lib(file1.o file2.o file3.o)\fP is illegal.
.PP
You cannot build \f3lib(file.o)\fP from \f3file.o\fP.
.PP
The macro \f3$(a:.o=.c~)\fP does not work.
.PP
Named pipes are not handled well.
