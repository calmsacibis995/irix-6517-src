.\" Copyright 1991 UNIX System Laboratories, Inc.
.\" Copyright 1989, 1990 AT&T
.\" Copyright (c) 1988 Sun Microsystems, Inc. - All Rights Reserved.
.\"
.\"	csh_built-ins, strip all but Built-Ins section
.nr X
.if \nX=0 .ds x} csh 1 "User Environment Utilities" "\&"
.TH \*(x}
.SH NAME
\f4csh\f1 \- shell command interpreter with a C-like syntax
.SH SYNOPSIS
.nf
\f4csh\f1 [ \f4\-bcefinstvVxX\f1 ] [ \f2argument\f1 ... ]
.fi
.SH DESCRIPTION
\f4csh\f1,
the C shell, is a command interpreter with a syntax reminiscent
of the C language.
It provides a number of convenient features for interactive use
that are not available with the standard (Bourne) shell, including
filename completion, command aliasing, history substitution, job
control, and a number of built-in commands.
As with the standard shell, the C shell provides variable, command and
filename substitution.
.SS Initialization and Termination
When first started, the C shell normally performs commands from the
\f4\&.cshrc\f1
file in your home directory,
provided that it is readable and you either own it or your real
group
ID
matches its group
ID.
If the shell is invoked with a name that starts with
\f1`\f4\-\f1',
as when started by
\f4login\f1(1),
the shell runs as a
\f4login\fP
shell.
In this case,
before executing the commands from the
\f4\&.cshrc\f1
file,
the shell executes the commands from the following files in the
order specified:
\f4/etc/cshrc\f1,
\f4/etc/\&.login\f1 and
\f4/etc/csh\&.cshrc\f1.
These files can be used to provide system-wide settings
for all \f4csh\f1 users.
After executing commands from the
\f4\&.cshrc\f1
file, a login shell executes commands from the
\f4\&.login\f1
file in your home directory;
the same permission checks as those for
\f4\&.cshrc\f1
are applied to this file.
Typically, the
\f4\&.login\f1
file contains commands to specify the terminal type and
environment.
Please note that
\f4csh\fP
can run as a
\f4login\fP
shell if it is invoked upon startup of a window shell such as
\f4xwsh\f1(1G).
This is so any terminal type information that might be contained in the
\f4\&.login\f1
file(s) can be made known to the window shell.
.P
As a login shell terminates, it performs commands from the
\f4\&.logout\f1
file in your home directory;
the same permission checks as those for
\f4\&.cshrc\f1
are applied to this file.
.SS Interactive Operation
After startup processing is complete, an interactive C shell
begins reading commands from the terminal, prompting with
\f2hostname\f4%\f1
(or
\f2hostname\f4#\f1
for the privileged user).
The shell then repeatedly performs the following actions:
a line of command input is read and broken into
\f2words\f1.
This sequence of words is placed on the history list and
then parsed, as described under
USAGE,
below.
Finally, the shell executes each command in the current line.
.SS Noninteractive Operation
When running noninteractively, the shell does not prompt for
input from the terminal.
A noninteractive C shell can
execute a command supplied as an
\f2argument\f1
on its command line, or interpret commands from a script.
.P
The following options are available:
.TP
\f4\-b\f1
Force a \(lqbreak\(rq from option processing.
Subsequent command-line arguments are not interpreted as C shell options.
This allows the passing of options to a script without confusion.
The shell does not run a set-user-ID script unless this option
is present.
.TP
\f4\-c\f1
Read commands from the first filename
\f2argument\f1
(which must be present).
Remaining arguments are placed in
\f4argv\f1,
the argument-list variable.
.TP
\f4\-e\f1
Exit if a command terminates abnormally or yields a nonzero exit
status.
.TP
\f4\-f\f1
Fast start.
Read neither the
\f4\&.cshrc\f1
file, nor the
\f4\&.login\f1
file (if a login shell) upon startup.
.TP
\f4\-i\f1
Forced interactive.
Prompt for command line input, even if the standard
input does not appear to be a terminal (character-special device).
.TP
\f4\-n\f1
Parse (interpret), but do not execute commands.
This option can be used to check C shell scripts for syntax errors.
.TP
\f4\-s\f1
Take commands from the standard input.
.TP
\f4\-t\f1
Read and execute a single command line.
A
\f1`\f4\e\f1'
(backslash) can be used to escape each
newline
for continuation of the command line onto subsequent input lines.
.TP
\f4\-v\f1
Verbose.
Set the
\f4verbose\f1
predefined variable; command input is
echoed after history substitution (but before other substitutions) and
before execution.
.TP
\f4\-V\f1
Set
\f4verbose\f1
before reading
\f4\&.cshrc\f1.
.TP
\f4\-x\f1
Echo.
Set the
\f4echo\f1
variable; echo commands after all substitutions and just before
execution.
.TP
\f4\-X\f1
Set
\f4echo\f1
before reading
\f4\&.cshrc\f1.
.P
Except with the options
\f4\-c\f1,
\f4\-i\f1,
\f4\-s\f1,
or
\f4\-t,\f1
the first nonoption
\f2argument\f1
is taken to be the name of a command or script.
It is passed as argument zero, and subsequent arguments are added to the
argument list for that command or script.
\f4csh\f1
scripts should always start with the line
.Ex
\f4#! /bin/csh \-f\f1
.Ee
which causes the script to be executed by \f4/bin/csh\f1 even if invoked
by a user running a shell other than
\f4csh\f1
and inhibits processing of the
\f4\&.cshrc\f1
file to prevent interference from aliases defined by the invoking user.
.SH USAGE
.SS "Filename Completion"
When enabled by setting the variable
\f4filec\f1,
an interactive
C shell can complete a partially typed filename or user name.
When an unambiguous partial filename is followed by an
ESC
character on the terminal input line, the shell fills in the remaining
characters of a matching filename from the working directory.
.P
If a partial filename is followed by the
EOF
character (usually typed as
<Ctrl-d>),
the shell lists all filenames that match.
It then prompts once again,
supplying the incomplete command line typed in so far.
.P
When the last (partial) word begins with a tilde
\f1(\f4~\f1),
the shell attempts completion with a user name, rather than
a file in the working directory.
.P
The terminal bell signals errors or multiple matches;
this can be inhibited by setting the variable
\f4nobeep\f1.
You can exclude files with certain suffixes by listing those
suffixes in the variable
\f4fignore\f1.
If, however, the only possible completion includes a suffix in
the list, it is not ignored.
\f4fignore\f1
does not affect the
listing of filenames by the
EOF
character.
.SS Lexical Structure
The shell splits input lines into words at
space
and
tab
characters, except as noted below.
The characters
\f4&\f1,
\f4|\f1,
\f4;\f1,
\f4<\f1,
\f4>\f1,
\f4(\f1,
and
\f4)\f1
form separate words; if paired, the pairs form single words.
These shell metacharacters can be made part of other words, and
their special meaning can be suppressed by preceding them with a
\f1`\f4\e\f1'
(backslash).
A
newline
preceded by a
\f4\e\f1
is equivalent to a
space
character.
.P
In addition, a string enclosed in matched pairs of single-quotes
\f1(\f4\'\f1),
double-quotes
(\f4"\f1),
or backquotes
\f1(\f4\`\f1),
forms a partial word; metacharacters in such a string, including any
space
or
tab
characters, do not form separate words.
Within pairs of backquote
\f1(\`\f4)\f1
or double-quote
(\f4"\f1) characters, a
newline
preceded by a
\f1`\f4\e\f1'
(backslash) gives a true
newline
character.
Additional functions of each type of quote are
described, below, under
\f4Variable Substitution\f1,
\f4Command Substitution\f1,
and
\f4Filename Substitution\f1.
.P
When the shell's input is not a terminal, the character
\f4#\f1
introduces a comment that continues to the end of the input line.
Its special meaning is suppressed when preceded by a
\f4\e\f1
or enclosed in matching quotes.
.SS Command Line Parsing
A
\f2simple command\f1
is composed of a sequence of words.
The first word
(that is not part of an I/O redirection) specifies the command to be
executed.
A simple command, or a set of simple commands separated by
\f4|\f1
or
\f4|&\f1
characters, forms a
\f2pipeline\f1.
With
\f4|\f1,
the standard output of the preceding command is redirected to the
standard input of the command that follows.
With
\f4|&\f1,
both the standard error and the standard output are redirected through
the pipeline.
.P
Pipelines can be separated by semicolons
\f1(\f4;\f1),
in which case they are executed sequentially.
Pipelines that are separated by
\f4&&\f1
or
\f4||\f1
form conditional sequences in which the execution of pipelines
on the right depends upon the success or failure, respectively,
of the pipeline on the left.
.P
A pipeline or sequence can be enclosed within parentheses
\f1`\f4( )\f1'
to form a simple command that can be a component in a pipeline or
sequence.
.P
A sequence of pipelines can be executed asynchronously, or
\(lqin the background\(rq by appending an
\f1`\f4&\f1';
rather than waiting for the sequence to finish before issuing
a prompt, the shell displays the job number (see
\f4Job Control\f1,
below) and associated process
IDs,
and prompts immediately.
.SS History Substitution
History substitution allows you to use words from previous command
lines in the command line you are typing.
This simplifies spelling
corrections and the repetition of complicated commands or arguments.
Command lines are saved in the history list, the size of which
is controlled by the
\f4history\f1
variable.
The most recent command is retained in any case.
A history substitution begins with a
\f4!\f1 (although you can change this with the
\f4histchars\f1
variable) and can occur anywhere on the command line; history
substitutions do not nest.
The
\f4!\f1 can be escaped with
\f4\e\f1
to suppress its special meaning.
.P
Input lines containing history substitutions are echoed on the
terminal after being expanded, but before any other
substitutions take place or the command gets executed.
.SS \f2Event Designators\fP
An event designator is a reference to a command-line entry in
the history list.
.TP 10
\f4!\f1
Start a history substitution, except when followed by a
space
character,
tab,
newline,
\f4=\f1
or
\f4(\f1.
.TP
\f4!!\f1
Refer to the previous command.
By itself, this substitution
repeats the previous command.
.TP
\f4!\f2n\f1
Refer to command line
\f2n\f1 .
.TP
\f4!\f2\-n\f1
Refer to the current command line minus
\f2n\f1.
.TP
\f4!\f4str\fP
Refer to the most recent command starting with
\f4str\fP.
.TP
\f4!?\f2str\f1[\fP\f4?\f2\f1]\fP
Refer to the most recent command containing
\f4str\fP.
.TP
\f4!{\f1...\f4}\f1
Insulate a history reference from adjacent characters (if necessary).
.SS \f2Word Designators\f1
A
\f1`\f4:\f1'
(colon)
separates the event specification from the word designator.
It can be omitted if the word designator begins with a
\f4^\f1,
\f4$\f1,
\f4*\f1,
\f4\-\f1
or
\f4%\f1.
If the word is to be selected from the previous command, the second
\f4!\f1 character can be omitted from the event specification.
For instance,
\f4!!:1\f1
and
\f4!:1\f1
both refer to the first word of the previous command, while
\f4!!$\f1
and
\f4!$\f1 both refer to the last word in the previous command.
Word designators include:
.TP
\f4#\f1
The entire command line typed so far.
.PD 0
.TP
\f40\f1
The first input word (command).
.TP
\f2n\f1
The
\f2n\f1'th
argument.
.TP
\f4^\f1
The first argument, that is,
\f41\f1.
.TP
\f4$\f1
The last argument.
.TP
\f4%\f1
The word matched by (the most recent)
\f4?\f2s\f1
search.
.TP
\f2x\f4\-\f2y\f1
A range of words;
\f4\-\f2y\f1
abbreviates
\f40\-\f2y\f1.\f1
.TP
\f4*\f1
All the arguments, or a null value if there is just
one word in the event.
.TP
\f2x\f4*\f1
Abbreviates
\f2x\f4\-$\f2.\f1
.TP
\f2x\f4\-\f1
Like
\f2x*\f1
but omitting word
\f4$\f1.
.PD
.SS \f2Modifiers\f1
After the optional word designator, you can add
a sequence of one or more of the following modifiers,
each preceded by a
\f4:\f1.
.TP
\f4h\f1
Remove a trailing pathname component, leaving the head.
.PD 0
.TP
\f4r\f1
Remove a trailing suffix of the form
\f1`\f4\&.\f2xxx\f1',
leaving the basename.
.TP
\f4e\f1
Remove all but the suffix.
.TP
\f4s/\f2l\f4/\f2r\f1[\fP\f4/\f2\f1]\fP
Substitute
\f2r\f1
for
\f2l\f1.
.TP
\f4t\f1
Remove all leading pathname components, leaving the tail.
.TP
\f4&\f1
Repeat the previous substitution.
.TP
\f4g\f1
Apply the change to the first occurrence of a match in each word,
by prefixing the above (for example,
\f4g&\f1).
.TP
\f4p\f1
Print the new command but do not execute it.
.TP
\f4q\f1
Quote the substituted words, escaping further substitutions.
.TP
\f4x\f1
Like
\f4q\f1,
but break into words at each
space
character,
tab
or
newline.
.PD
.P
Unless preceded by a
\f4g\f1,
the modification is applied only to the
first string that matches
\f2l\f1;
an error results if no string matches.
.P
The left-hand side of substitutions are not regular expressions,
but character strings.
Any character can be used as the delimiter in place of
\f4/\f1.
A backslash quotes the delimiter character.
The character
\f4&\f1,
in the right hand side, is replaced by the text
from the left-hand-side.
The
\f4&\f1
can be quoted with a backslash.
A null
\f2l\f1
uses the previous string either from a
\f2l\f1
or from a contextual scan string
\f2s\f1
from
\f4!?\f2s\f1.\f1
You can omit the rightmost delimiter if a
newline
immediately follows
\f2r\f1;
the rightmost
\f4?\f1
in a context scan can similarly be omitted.
.P
Without an event specification, a history reference refers either to the
previous command, or to a previous history reference on the command line
(if any).
.SS \f2Quick Substitution\f1
.TP 10
\f4^\f2l\f4^\f2r\f1[\fP\f4^\f2\f1]\fP
This is equivalent to the history substitution:
\f4!:s^\f2l\f4^\f2r\c\f1
\f1[\f4^\f1].
.SS Aliases
The C shell maintains a list of aliases that you can create, display,
and modify using the
\f4alias\f1
and
\f4unalias\f1
commands.
The shell checks the first word in each command to see if it matches
the name of an existing alias.
If it does, the command is reprocessed
with the alias definition replacing its name; the history
substitution mechanism is made available as though that command
were the previous input line.
This allows history substitutions,
escaped with a backslash in the definition, to be replaced with
actual command-line arguments when the alias is used.
If no
history substitution is called for, the arguments remain unchanged.
.P
Aliases can be nested.
That is, an alias definition can contain
the name of another alias.
Nested aliases are expanded before any
history substitutions is applied.
This is useful in pipelines such as
.IP
.ft 4
alias \ lm \'ls \ \-l \ \e!* \ | \ more\'
.ft 1
.P
which when called, pipes the output of
\f4ls\f1(1)
through
\f4more\f1(1).
.P
Except for the first word, the name of the alias cannot appear in its
definition, nor in any alias referred to by its definition.
Such loops are detected, and cause an error message.
.SS I/O Redirection
The following metacharacters indicate that the subsequent word
is the name of a file to which the command's standard input, standard
output, or standard error is redirected; this word is variable,
command, and filename expanded separately from the rest of the command.
.TP 10
\f4<\f1
Redirect the standard input.
.TP
\f4<<\f2word\f1
Read the standard input, up to a line that is identical
with
\f2word\f1,
and place the resulting lines in a temporary file.
Unless
\f2word\f1
is escaped or quoted, variable and command substitutions are performed
on these lines.
Then, invoke the pipeline with the temporary file as
its standard input.
\f2word\f1
is not subjected to variable, filename, or command substitution,
and each line is compared to it before any substitutions are
performed by the shell.
.TP
\f4>\f1\ \ \ \f4>!\f1\ \ \ \f4>&\f1\ \ \ \f4>&!\f1
Redirect the standard output to a file.
If the file does not exist, it is created.
If it does
exist, it is overwritten; its previous contents are lost.
.IP
When set, the variable
\f4noclobber\f1
prevents destruction of existing
files.
It also prevents redirection to terminals and
\f4/dev/null\f1,
unless one of the
\f4!\f1 forms is used.
The
\f4&\f1
forms redirect both standard output and the standard
error (diagnostic output) to the file.
.TP
\f4>>\f1\ \ \ \f4>>&\f1\ \ \ \f4>>!\f1\ \ \ \f4>>&!\f1
Append the standard output.
Like
\f4>\f1,
but places output at the end of the file rather
than overwriting it.
If
\f4noclobber\f1
is set, it is an error for the file not to exist, unless
one of the
\f4!\f1 forms is used.
The
\f4&\f1
forms append both the standard error and standard output to the
file.
.SS "Variable Substitution"
The C shell maintains a set of
\f2variables\f1,
each of which is composed of a
\f2name\f1
and a
\f2value\f1.
A variable name consists of up to 20 letters and digits,
and starts with a letter (the underscore is considered a letter).
A variable's value is a space-separated list of zero or more words.
.P
To refer to a variable's value, precede its name with a
\f1`\f4$\f1'.
Certain references (described below) can be used to select specific
words from the
value, or to display other information about the variable.
Braces can
be used to insulate the reference from other characters in an input-line
word.
.P
Variable substitution takes place after
the input line is analyzed, aliases are resolved, and I/O
redirections are applied.
Exceptions to this are variable references in I/O redirections
(substituted at the time the redirection is made), and backquoted
strings (see
Command Substitution).
.P
Variable substitution can be suppressed by preceding the
\f4$\f1
with a
\f4\e\f1,
except within double-quotes where it always occurs.
Variable substitution is suppressed inside of single-quotes.
A
\f4$\f1
is escaped if followed by a
space
character,
tab
or
newline.
.P
Variables can be created, displayed, or destroyed using the
\f4set\f1
and
\f4unset\f1
commands.
Some variables are maintained or used by the shell.
For instance, the
\f4argv\f1
variable contains an image of the shell's argument list.
Of the variables used by the shell, a number are toggles;
the shell does not care what their value is,
only whether they are set or not.
.P
Numerical values can be operated on as numbers (as with the
\f4@\f1
built-in).
With numeric operations, an empty value
is considered to be zero; the second and subsequent words of
multiword values are ignored.
For instance, when the
\f4verbose\f1
variable is set to any value (including an empty value), command
input is echoed on the terminal.
.P
Command and filename substitution is subsequently applied to the words
that result from the variable substitution, except when suppressed by
double-quotes, when
\f4noglob\f1
is set (suppressing filename substitution), or when the reference is
quoted with the
\f4:q\f1
modifier.
Within double-quotes, a reference is expanded to form (a portion
of) a quoted string; multiword values are expanded to a string with
embedded
space
characters.
When the
\f4:q\f1
modifier is applied to the reference, it is expanded to a list
of space-separated words, each of which is quoted
to prevent subsequent command or filename substitutions.
.P
Except as noted below, it is an error to refer to a variable that is
not set.
.TP 15
\f4$\f2var\f1
.PD 0
.TP
\f4${\f2var\f4}\f1
.PD
These are replaced by words from the value of
\f2var\f1,
each separated by a
space
character.
If
\f2var\f1
is an environment variable, its
value is returned (but
\f1`\f4:\f1'
modifiers and the other forms
given below are not available).
.TP
\f4$\f2var\f4\f1[\f2index\f4\f1]\fP
.PD 0
.TP
\f4${\f2var\f4[\f2index\f4]}\f1
.PD
These select only the indicated words from the value of
\f2var\f1.
Variable substitution is applied to
\f2index\f1,
which can
consist of (or result in) a either single number, two numbers
separated by a
\f1`\f4\-\f1',
or an asterisk.
Words are indexed starting from 1; a
\f1`\f4*\f1'
selects all words.
If the first number of a range is omitted (as with
\f4$argv[\-2]\f1),
it defaults to 1.
If the last number of a range is omitted
(as with
\f4$argv[1\-]\f1),
it defaults to
\f4$#\f2var\f1
(the word count).
It is not an error for a range to be empty if the second argument is
omitted (or within range).
.TP
\f4$#\f2name\f1
.PD 0
.TP
\f4${#\f2name\f4}\f1
.PD
These give the number of words in the variable.
.TP
\f4$0\f1
This substitutes the name of the file from which command input is
being read.
An error occurs if the name is not known.
.TP
\f4$\f2n\f1
.PD 0
.TP
\f4${\f2n\f4}\f1
.PD
Equivalent to
\f4$argv[\f2n\f4]\f2.\f1
.TP
\f4$*\f1
Equivalent to
\f4$argv[*]\f1.
.P
The modifiers
\f4:e\f1,
\f4:h\f1,
\f4:q\f1,
\f4:r\f1,
\f4:t\f1
and
\f4:x\f1
can be applied (see
\f4History Substitution\f1),
as can
\f4:gh\f1,
\f4:gt\f1
and
\f4:gr\f1.
If
\f4{}\f1
(braces) are used, then the modifiers must appear within the braces.
The current implementation allows only one such modifier per
expansion.
.P
The following references cannot be modified with
\f4:\f1 modifiers.
.TP 10
\f4$?\f2var\f1
.PD 0
.TP
\f4${?\f2var\f4}\f1
.PD
Substitutes the string 1 if
\f2var\f1
is set or 0 if it is not set.
.TP
\f4$?0\f1
Substitutes 1 if the current input filename is known, or 0 if it is not.
.TP
\f4$$\f1
Substitute the process number of the (parent) shell.
.TP
\f4$<\f1
Substitutes a line from the standard
input, with no further interpretation thereafter.
It can be used
to read from the keyboard in a C shell script.
.SS "Command and Filename Substitutions"
Command and filename substitutions are applied selectively to
the arguments of built-in commands.
Portions of expressions that are
not evaluated are not expanded.
For non-built-in commands, filename expansion of the command
name is done separately from that of the argument list; expansion occurs
in a subshell, after I/O redirection is performed.
.SS Command Substitution
A command enclosed by backquotes
\f1(\f4\`\f1...\f4\`\f1)
is performed by a subshell.
Its standard output is broken into separate words at each
space
character,
tab
and
newline;
null words are discarded.
This text replaces the backquoted
string on the current command line.
Within double-quotes, only
newline
characters force new words;
space
and
tab
characters are preserved.
However, a final
newline
is ignored.
It is therefore possible for a command substitution
to yield a partial word.
.SS "Filename Substitution"
Unquoted words containing any of the characters
\f4*\f1,
\f4?\f1,
\f4[\f1
or
\f4{\f1,
or that begin with
\f4~\f1,
are expanded (also known as
\f2globbing\f1)
to an alphabetically sorted list of filenames, as follows:
.TP 15
\f4*\f1
Match any (zero or more) characters.
.TP
\f4?\f1
Match any single character.
.TP
\f4[\f1 ...\& \f4]\f1
Match any single character in the enclosed list(s) or range(s).
A list is a string of characters.
A range is two characters separated by a minus-sign
\f1(\f4\-\f1),
and includes all the characters in between in the
ASCII
collating sequence (see \f4ascii\f1(5)).
.TP
\f4{\f1 \f2str\f4,\f1 \f2str\f4,\f1 ...\& \f4}\f1
Expand to each string (or filename-matching pattern) in the
comma-separated list.
Unlike the pattern-matching expressions above, the expansion of this
construct is not sorted.
For instance,
\f4{b,a}\f1
expands to
\f1`\f4b\f1'
\f1`\f4a\f1',
(not
\f1`\f4a\f1'
\f1`\f4b\f1').
As special cases, the characters
\f4{\f1
and
\f4}\f1,
along with the string
\f4{}\f1,
are passed undisturbed.
.TP
\f4~\f1[ \f2user\f1 ]
Your home directory, as indicated by the value of the variable
\f4home\f1,
or that of
\f2user\f1,
as indicated by the password entry for
\f2user\f1.
.P
Only the patterns
\f4*\f1,\f4 ?\f1
and
\f4[\f1...\f4]\f1
imply pattern matching; an error results if
no filename matches a pattern that contains them.
The
\f1`\f4.\f1'
(dot character),
when it is the first character in a filename or pathname
component, must be matched explicitly.
The
\f4/\f1
(slash)
must also be matched explicitly.
.SS Expressions and Operators
A number of C shell built-in commands accept expressions, in which the
operators are similar to those of C
and have the same precedence.
These expressions typically appear in the
\f4@\f1,
\f4exit\f1,
\f4if\f1,
\f4set\f1
and
\f4while\f1
commands, and are often used to regulate the flow of control for
executing commands.
Components of an expression are separated by white space.
.P
Null or missing values are considered 0.
The result of all
expressions are strings, which can represent decimal numbers.
.P
The following C shell operators are grouped in order of precedence:
.TP 20
\f4(\f1...\f4)\f1
grouping
.PD  0
.TP
\f4~\f1
one's complement
.TP
\f4!\f1
logical negation
.TP
\f4*   /   %\f1
multiplication, division, remainder (These are right associative,
which can lead to unexpected results.
Group combinations
explicitly with parentheses.)
.TP
\f4+   \-\f1
addition, subtraction (also right associative)
.TP
\f4<<   >>\f1
bitwise shift left, bitwise shift right
.TP
\f4<   >   <=   >=\f1
less than, greater than, less than or equal to, greater than or equal to
.TP
\f4==   !=   =~   !~\f1
equal to, not equal to, filename-substitution pattern match
(described below),
filename-substitution pattern mismatch
.TP
\f4&\f1
bitwise
AND
.TP
\f4^\f1
bitwise
XOR
(exclusive or)
.TP
\f4|\f1
bitwise inclusive
OR
.TP
\f4&&\f1
logical
AND
.TP
\f4||\f1
logical
OR
.PD
.RE
.P
The operators:
\f4==\f1,
\f4!=\f1,
\f4=~\f1,
and
\f4!~\f1
compare their arguments as strings; other operators use numbers.
The operators
\f4=~\f1
and
\f4!~\f1
each check whether or not a string to the left matches a filename
substitution pattern on the right.
This reduces the need for
\f4switch\f1
statements when pattern-matching between strings is all that is
required.
.P
Also available are file inquiries:
.P
.PD 0
.TP 10
\f4\-r\f2 file\f1
Return true, or 1 if the user has read access.
Otherwise it returns false, or 0.
.TP
\f4\-w\f2 file\f1
True if the user has write access.
.TP
\f4\-x\f2 file\f1
True if the user has execute permission (or search permission on
a directory).
.TP
\f4\-e\f2 file\f1
True if
\f2file\f1
exists.
.TP
\f4\-o\f2 file\f1
True if the user owns
\f2file\f1.
.TP
\f4\-z\f2 file\f1
True if
\f2file\f1
is of zero length (empty).
.TP
\f4\-f\f2 file\f1
True if
\f2file\f1
is a plain file.
.TP
\f4\-d\f2 file\f1
True if
\f2file\f1
is a directory.
.TP
\f4\-l\f2 file\f1
True if
\f2file\f1
is a symbolic link.
.TP
\f4\-c\f2 file\f1
True if
\f2file\f1
is a character special file.
.TP
\f4\-b\f2 file\f1
True if
\f2file\f1
is a block special file.
.TP
\f4\-p\f2 file\f1
True if
\f2file\f1
is a named pipe (fifo).
.TP
\f4\-u\f2 file\f1
True if
\f2file\f1
has the set-user-ID permission bit set (see \f2chmod\f1(1)).
.TP
\f4\-g\f2 file\f1
True if
\f2file\f1
has the set-group-ID permission bit set (see \f2chmod\f1(1)).
.TP
\f4\-k\f2 file\f1
True if
\f2file\f1
has the sticky bit set (see \f2chmod\f1(1)).
.TP
\f4\-s\f2 file\f1
True if
\f2file\f1
has size strictly greater than zero.
.TP
\f4\-t\f2 file\f1
True if
\f2file\f1
is an open file descriptor for a terminal device.
.PD
.P
If
\f2file\f1
does not exist or is inaccessible, then all inquiries return false.
.P
An inquiry as to the success of a command is also available:
.TP 15
\f4{ \f2command\f4 }\f1
If
\f2command\f1
runs successfully, the expression evaluates to true, 1.
Otherwise it evaluates to false 0.
(Note that, conversely,
\f2command\f1
itself typically returns 0 when it runs successfully,
or some other value if it encounters a problem.
If you want to get at
the status directly, use the value of the
\f4status\f1
variable rather than this expression).
.SS Control Flow
The shell contains a number of commands to regulate the flow of
control in scripts, and within limits, from the terminal.
These commands operate by forcing the shell either to reread
input (to
\f2loop\f1),
or to skip input under certain conditions (to
\f2branch\f1).
.P
Each occurrence of a
\f4foreach\f1,
\f4switch\f1,
\f4while\f1,
\f4if\f1...\f4then\f1
and
\f4else\f1
built-in must appear as the first word on its own input line.
.P
If the shell's input is not seekable and a loop is being read, that
input is buffered.
The shell performs seeks within the internal
buffer to accomplish the rereading implied by the loop.
(To the
extent that this allows, backward
\f4goto\f1
commands succeed on nonseekable inputs.)
.SS Command Execution
If the command is a C shell built-in, the shell executes it directly.
Otherwise, the shell searches for a file by that name with
execute access.
If the command-name contains a
\f4/\f1,
the shell takes it as a pathname, and searches for it.
If the command-name does not contain a
\f4/\f1,
the shell attempts to resolve it to a pathname, searching each
directory in the
\f4path\f1
variable for the command.
To speed the search, the shell uses its
hash table (see the
\f4rehash\f1
built-in) to eliminate directories that have no applicable files.
This hashing can be disabled with the
\f4\-c\f1
or
\f4\-t\f1,
options, or the
\f4unhash\f1
built-in.
.P
As a special case, if there is no
\f4/\f1
in the name of the script and there is an alias for the word
\f4shell\f1,
the expansion of the
\f4shell\f1
alias is prepended (without modification), to the command line.
The system attempts to execute the first word of this special
(late-occurring) alias, which should be a full pathname.
Remaining words of the alias's definition, along with the text of the
input line, are treated as arguments.
.P
When a pathname is found that has proper execute permissions,
the shell forks a new process and passes it, along with its
arguments to the kernel (using the
\f4execve\f1(2)
system call).
The kernel then attempts to overlay the new process
with the desired program.
If the file is an executable binary (in
\f4a.out\f1(4)
format)
the kernel succeeds, and begins executing the new process.
If the file
is a text file, and the first line begins with
\f4#!\f1,
the next word is taken to be the pathname of a shell (or command) to
interpret that script.
Subsequent words on the first line are taken as
options for that shell.
The kernel invokes (overlays) the indicated
shell, using the name of the script as an argument.
.P
If neither of the above conditions holds, the kernel cannot overlay
the file (the
\f4execve\f1(2)
call fails); the C shell then attempts to execute the file by spawning
a new shell, as follows:
.TP 3
\(bu
If the first character of the file is a
\f4#\f1,
a C shell is invoked.
.TP
\(bu
Otherwise, a standard (Bourne) shell is invoked.
.SS Signal Handling
The shell normally ignores
QUIT
signals.
Background jobs are immune to signals generated from the
keyboard, including
hangups
(HUP).
Other signals have the values that the
C shell inherited from its environment.
The shell's handling of interrupt and terminate signals
within scripts can be controlled by the
\f4onintr\f1
built-in.
Login shells catch the
TERM
signal; otherwise this signal is passed on to child processes.
In no case are interrupts allowed when a login shell is reading the
\f4\&.logout\f1
file.
.SS "Job Control"
The shell associates a numbered
\f2job\f1
with each command sequence, to keep track of those commands that are
running in the background or have been stopped with
TSTP
signals (typically
<Ctrl-z>).
When a command, or command sequence (semicolon separated list), is
started in the background using the
\f4&\f1
metacharacter, the shell displays a line with the job number in
brackets, and a list of associated process numbers:
.IP
\f4[1] 1234\f1
.P
To see the current list of jobs, use the
\f4jobs\f1
built-in command.
The job most recently stopped (or put into the
background if none are stopped) is referred to as the
\f2current\f1
job, and is indicated with a
\f1`\f4+\f1'.
The previous job is indicated with a
\f1`\f4\-\f1';
when the current job is terminated or moved to the foreground,
this job takes its place (becomes the new current job).
.P
To manipulate jobs, refer to the
\f4bg\f1,
\f4fg\f1,
\f4kill\f1,
\f4stop\f1
and
\f4%\f1
built-ins.
.P
A reference to a job begins with a
\f1`\f4%\f1'.
By itself, the percent-sign refers to the current job.
.TP 15
\f4%\f1\ \ \ \f4%+\f1\ \ \ \f4%%\f1
The current job.
.TP
\f4%\-\f1
The previous job.
.TP
\f4%\f2j\f1
Refer to job
\f2j\f1
as in:
\f1`\f4kill \-9 %\f2j\f1'.
\f2j\f1
can be a job number, or a string that
uniquely specifies the command line by which it was started;
\f1`\f4fg %vi\f1'
might bring a stopped
\f4vi\f1
job to the foreground, for instance.
.TP
\f4%?\f2string\f1
Specify the job for which the command line uniquely contains
\f2string\f1.
.P
A job running in the background stops when it attempts to read
from the terminal.
Background jobs can normally produce output,
but this can be suppressed using the
\f1`\f4stty tostop\f1'
command.
.SS Status Reporting
While running interactively, the shell tracks the status of each job
and reports whenever a finishes or becomes blocked.
It normally
displays a message to this effect as it issues a prompt, so as to avoid
disturbing the appearance of your input.
When set, the
\f4notify\f1
variable indicates that the shell is to report status changes
immediately.
By default, the
\f4notify\f1
command marks the current process; after starting a background job, type
\f4notify\f1
to mark it.
.SS "Built-In Commands"
Built-in commands are executed within the C shell.
If a built-in command occurs as any component of a pipeline
except the last, it is executed in a subshell.
.TP 15
\f4:\f1
Null command.
This command is interpreted, but performs no action.
.TP
\f4alias\f1 [ \f2name\f1 [ \f2def\f1 ] ]
Assign
\f2def\f1
to the alias
\f2name\f1.
\f2def\f1
is a list of words that can contain escaped history-substitution
metasyntax.
\f2name\f1
is not allowed to be
\f4alias\f1
or
\f4unalias\f1.
If
\f2def\f1
is omitted, the alias
\f2name\f1
is displayed along with its current definition.
If both
\f2name\f1
and
\f2def\f1
are omitted, all aliases are displayed.
.TP
\f4bg\f1 \f1[\f4%\c\f1 \f2job\f1] ...
\f1Run the current or specified jobs in the background.
.TP
\f4break\f1
Resume execution after the
\f4end\f1
of the nearest enclosing
\f4foreach\f1
or
\f4while\f1
loop.
The remaining commands on the current line
are executed.
This allows multilevel breaks to be written as a
list of
\f4break\f1
commands, all on one line.
.TP
\f4breaksw\f1
Break from a
\f4switch\f1,
resuming after the
\f4endsw\f1.
.TP
\f4case\f2 label\f4:\f1
A label in a
\f4switch\f1
statement.
.TP
\f4cd\f1 [ \f2dir\f1 ]
.PD 0
.TP
\f4chdir\f1 [ \f2dir\f1 ]
Change the shell's working directory to directory
\f2dir\f1.
If no argument is given, change to the home directory of the user.
If
\f2dir\f1
is a relative pathname not found in the current directory, check for
it in those directories listed in the
\f4cdpath\f1
variable.
If
\f2dir\f1
is the name of a shell variable whose value starts with a
\f4/\f1,
change to the directory named by that value.
.PD
.TP
\f4continue\f1
Continue execution of the nearest enclosing
\f4while\f1
or
\f4foreach\f1.
.TP
\f4default:\f1
Labels the default case in a
\f4switch\f1
statement.
The default should come after all
\f4case\f1
labels.
Any remaining commands on the command line are first executed.
.TP
\f4dirs\f1 [ \f4\-l\f1 ]
Print the directory stack, most recent to the left;
the first directory shown is the current directory.
With the
\f4\-l\f1
argument, produce an unabbreviated printout; use of the
\f4~\f1
notation is suppressed.
.TP
\f4echo\f1 [ \f4\-n\f1 ] \f2list\f1
The words in
\f2list\f1
are written to the shell's standard output, separated by
space
characters.
The output is terminated with a
newline
unless the
\f4\-n\f1
option or the
\f4\ec\f1
escape is specified.
The following C-like escape sequences are available:
.RS
.sp .8v
.PD 0
.TP
\f4\eb\f1
backspace
.TP
\f4\ec\f1
print line without newline
.TP
\f4\ef\f1
formfeed
.TP
\f4\en\f1
newline
.TP
\f4\er\f1
carriage return
.TP
\f4\et\f1
tab
.TP
\f4\e\e\f1
backslash
.TP
\f4\e\f1\f20n\f1
the 8-bit character whose code is
the 1-, 2- or 3-digit octal number
.IR n .
Note that \f4\e\f1\f2n\f1 (no leading zero) is accepted for backwards
compatibility with older IRIX cshs.
This can cause unexpected results
in older scripts if the character immediately trailing three digits is
also numeric.
.PD
.RE
.TP
\f4eval \f2 argument\f1 ...
Reads the arguments as input to the shell, and executes the resulting
command(s).
This is usually used to execute commands
generated as the result of command or variable substitution, since
parsing occurs before these substitutions.
See
\f4tset\f1(1)
for an example of how to use
\f4eval\f1.
.TP
\f4exec\f2 command\f1
Execute
\f2command\f1
in place of the current shell, which terminates.
.TP
\f4exit\f1 [ \f4(\f2expr\f4)\f1 ]
The shell exits, either with the value of the
STATUS
variable, or with the value specified by the expression
\f4expr\fP.
.TP
\f4fg %\f1 [ \f2job\f1 ]
Bring the current or specified
\f2job\f1
into the foreground.
.TP
\f4foreach\f2 var \f4(\f2wordlist\f4)\f1
.PD 0
.TP
\&...
.TP
\f4end\f1
The variable
\f2var\f1
is successively set to each member of
\f2wordlist\f1.
The sequence of commands between this command and the matching
\f4end\f1
is executed for each new value of
\f2var\f1.
(Both
\f4foreach\f1
and
\f4end\f1
must appear alone on separate lines.)
.PD
.IP
The built-in command
\f4continue\f1
can be used to continue the loop prematurely and the built-in command
\f4break\f1
to terminate it prematurely.
When this command is read from the terminal, the loop is read up once
prompting with
\f4?\f1
before any statements in the loop are executed.
.TP
\f4glob\f2 wordlist\f1
Perform filename expansion on
\f2wordlist\f1.
Like
\f4echo\f1,
but no
\f4\e\f1
escapes are recognized.
Words are delimited by
\f4NULL\fP
characters in the output.
.TP
\f4goto\f2 label\f1
The specified
\f2label\f1
is filename and command expanded to yield a label.
The shell rewinds its input as much as possible
and searches for a line of the form
\f2label\f4:\f1
possibly preceded by
space
or
tab
characters.
Execution continues after the indicated line.
It is an error to jump to a label that occurs between a
\f4while\f1
or
\f4for\f1
built-in, and its corresponding
\f4end\f1.
.TP
\f4history\f1 [ \f4\-hr\f1 ] [ \f2n\f1 ]
Display the history list; if
\f2n\f1
is given, display only the
\f2n\f1
most recent events.
.RS
.TP
\f4\-r\f1
Reverse the order of printout to be most recent first rather than oldest first.
.PD 0
.TP
\f4\-h\f1
Display the history list without leading numbers.
This is used to produce files suitable for sourcing using the
\f4\-h\f1
option to
\f2source\f1.
.PD
.RE
.TP
\f4if (\f2expr\f4) \f2command\f1
If the specified expression evaluates to true, the single
\f2command\f1
with arguments is executed.
Variable substitution on
\f2command\f1
happens early, at the same time it does for the rest of the
\f2if\f1
command.
\f2command\f1
must be a simple command, not a pipeline, a command list, or a
parenthesized command list.
Note: I/O redirection occurs even
if
\f4expr\fP
is false, when
\f2command\f1
is
\f2not\f1
executed (this is a bug).
.TP
\f4if (\f2expr\f4) then\f1
.PD 0
.TP
\&...
.TP
\f4else if (\f2expr2\f4) then\f1
.TP
\&...
.TP
\f4else\f1
.TP
\&...
.TP
\f4endif\f1
If
\f4expr\fP""
is true, commands up to the first
\f4else\f1
are executed.
Otherwise, if
\f2expr2\f1
is true, the commands between the
\f4else if\f1
and the second
\f4else\f1
are executed.
Otherwise, commands between the
\f4else\f1
and the
\f4endif\f1
are executed.
Any number of
\f4else if\f1
pairs are allowed, but only one
\f4else\f1.
Only one
\f4endif\f1
is needed, but it is required.
The words
\f4else\f1
and
\f4endif\f1
must be the first nonwhite characters on a line.
The
\f4if\f1
must appear alone on its input line or after an
\f4else\f1.)
.PD
.TP
\f4jobs\f1 [\f4 \-l \f1]
List the active jobs under job control.
.RS
.TP
\f4\-l\f1
List process
IDs,
in addition to the normal information.
.RE
.TP
\f4kill\f1 [ \f4\-\f2sig\f1 ] [ \f2pid\f1 ] [ \f4%\f2job\f1 ] ...
.PD 0
.TP
\f4kill \-l\f1
.PD
Send the
TERM
(terminate) signal, by default, or the signal specified, to the
specified process
ID,
the
\f2job\f1
indicated, or the current
\f2job\f1.
Signals are either given by number or by name.
There is no default.
Typing
\f4kill\f1
does not send a signal to the current job.
If the signal being sent is
TERM
(terminate) or
HUP
(hangup), then the job or process is sent a
CONT
(continue) signal as well.
.RS
.TP
\f4\-l\f1
List the signal names that can be sent.
.RE
.TP
\f4limit\f1 [ \f4\-h\f1 ] [ \f2resource\f1 [ \f2max-use\f1 ] ]
Limit the consumption by the current process or any process it spawns,
each not to exceed
\f2max-use\f1
on the specified
\f2resource\f1.
If
\f2max-use\f1
is omitted, print the current limit; if
\f2resource\f1
is omitted, display all limits.
.RS
.TP
\f4\-h\f1
Use hard limits instead of the current limits.
Hard limits impose a
ceiling on the values of the current limits.
Only the privileged user can
raise the hard limits.
.P
\f2resource\f1
is one of:
.TP 15
\f4cputime\f1
Maximum
CPU
seconds per process.
.PD 0
.TP
\f4filesize\f1
Largest single file allowed.
.TP
\f4datasize\f1
Maximum data size (including stack) for the process.
.TP
\f4stacksize\f1
Maximum stack size for the process.
Note: If this is set too high, \f4sproc\f1(2) may fail.
.TP
\f4coredumpsize\f1
Maximum size of a core dump (file).
.TP
\f4memoryuse\f1
Maximum amount of physical memory per process (resident set size).
.TP
\f4vmemoryuse\f1
Maximum amount of virtual memory per process, including text, data, heap,
shared memory, mapped files, stack, etc..
.TP
\f4descriptors\f1
Maximum number of open file descriptors per process.
.TP
\f4threads\f1
Maximum number of \f4pthreads\f1(5) which may be created.
.PD
.P
\f2max-use\f1
is a number, with an optional scaling factor, as follows:
.TP 10
\f2n\f4h\f1
Hours (for
\f4cputime\f1).
.PD 0
.TP
\f2n\f4k\f1
\f2n\f1
kilobytes.
This is the default for all file or memory size limits.
.TP
\f2n\f4m\f1
\f2n\f1
megabytes or minutes (for
\f4cputime\f1).
.TP
\f2mm\f4:\f2ss\f1
Minutes and seconds (for
\f4cputime\f1).
.PD
.P
The \f2resource\f1 argument can be abbreviated by
using only enough characters to make the name unambiguous.
Refer to the \f4setrlimit\f1(2) manual entry for more information
about process resource limits.
.RE
.TP
\f4login\f1 [ \f2username |\f4\-p\f1 ]
Terminate a login shell and invoke
\f4login\f1(1).
The
\f4\&.logout\f1
file is not processed.
If
\f2username\f1
is omitted,
\f4login\fP
prompts for the name of a user.
.RS
.TP
\f4\-p\f1
Preserve the current environment (variables).
.RE
.TP
\f4logout\f1
Terminate a login shell.
.TP
\f4nice\f1 [ \f4+\f2n\f1 |\f4\-\f2n\f1 ] [ \f2command\f1 ]
\f1Increment the process priority value for the shell or for
\f2command\f1
by
\f2n\f1.
The higher the priority value, the lower the priority of a process, and
the slower it runs.
When given,
\f2command\f1
is always run in a subshell, and the restrictions placed on
commands in simple
\f4if\f1
commands apply.
If
\f2command\f1
is omitted,
\f4nice\f1
increments the value for the current shell.
If no increment is specified,
\f4nice\f1
sets the process priority value to 4.
The range of process priority values is
from \-20 to 20.
Values of
\f2n\f1
outside this range set the value to the lower, or to the higher
boundary, respectively.
.RS
.TP
\f4+\f2n\f1
Increment the process priority value by
\f2n\f1.
.PD 0
.TP
\f4\-\f2n\f1
Decrement by
\f2n\f1.
This argument can be used only by the privileged user.
.PD
.RE
.TP
\f4nohup\f1 [ \f2command\f1 ]
Run
\f2command\f1
with
HUPs
ignored.
With no arguments, ignore
HUPs
throughout the remainder of a script.
When given,
\f2command\f1
is always run in a subshell, and the restrictions placed on
commands in simple
\f4if\f1
commands apply.
All processes detached with
\f4&\f1
are effectively
\f4nohup\f1'd.
.TP
\f4notify\f1 [ \f4%\f2job\f1 ] ...
Notify the user asynchronously when the status of the current, or of specified
jobs, changes.
.TP
\f4onintr\f1 [\f4 \- \f1|\f2label\f1 ]
Control the action of the shell on interrupts.
With no arguments,
\f4onintr\f1
restores the default action of the shell on interrupts.
(The shell terminates shell scripts and returns to the
terminal command input level).
With the
\f4\-\f1
argument, the shell ignores all interrupts.
With a
\f2label\f1
argument, the shell executes a
\f4goto\f2 label\f1
when an interrupt is received or a child process terminates because
it was interrupted.
.TP
\f4popd\f1 [\f4+\f2n\f1]
Pop the directory stack, and \f4cd\f1 to the new top directory.
The elements of the directory stack are numbered from 0 starting at the top.
.RS
.TP
\f4+\f2n\f1
Discard the
\f2n\f1'th
entry in the stack.
.RE
.TP
\f4pushd\f1 [\f4+\f2n\f1 |\f2dir\f1]
Push a directory onto the directory stack.
With no arguments, exchange the top two elements.
.RS
.TP
\f4+\f2n\f1
Rotate the
\f2n\f1'th
entry to the top of the stack and
\f4cd\f1
to it.
.PD 0
.TP
\f2dir\f1
Push the current working directory onto the stack and change to
\f2dir\f1.
.PD
.RE
.TP
\f4rehash\f1
Recompute the internal hash table of the contents of directories listed
in the
\f2path\f1
variable to account for new commands added.
.TP
\f4repeat\f2 count command\f1
Repeat
\f2command\f1
\f2count\f1
times.
\f2command\f1
is subject to the same restrictions as with the one-line
\f4if\f1
statement.
.TP
\f4set\f1 [ \f2var\f1 [ \f4=\f2 value\f1 ] ]
.PD 0
.TP
\f4set\f2 var\f4[\f2n\f4] =\f2 word\f1
.PD
With no arguments,
\f4set\f1
displays the values of all shell variables.
Multiword values
are displayed as a parenthesized list.
With the
\f2var\f1
argument alone,
\f4set\f1
assigns an empty (null) value to the variable
\f2var\f1.
With arguments of the form
\f2var\f4 = \f2value\f1
\f4set\f1
assigns
\f2value\f1
to
\f2var\f1,
where
\f2value\f1
is one of:
.RS
.TP 15
\f2word\f1
A single word (or quoted string).
.PD 0
.TP
\f4(\f2wordlist\f4)\f1
A space-separated list of words enclosed in parentheses.
.PD
.RE
.IP
Values are command and filename expanded before being assigned.
The form
\f4set\f2 var\f4[\f2n\f4] =\f2 word\f1
replaces the
\f2n\f1'th
word in a multiword value with
\f2word\f1.
.IP
Multiple assignments can be performed with a single
\f4set\f1 command:
.RS
.sp .8v
	\f4set notify mail=(\&30 /usr/mail/nemo)\f1
.RE
.TP
\f4setenv\f1 [ \f2VAR\f1 [ \f2word\f1 ] ]
With no arguments,
\f4setenv\f1
displays all environment variables.
With the
\f2VAR\f1
argument sets the environment variable
\f2VAR\f1
to have an empty (null) value.
(By convention, environment
variables are normally given upper-case names.)
With both
\f2VAR\f1
and
\f2word\f1
arguments
\f4setenv\f1
sets the environment variable
\f4NAME\fP
to the value
\f2word\f1,
which must be either a single word or a quoted string.
The most commonly used environment variables,
\f4USER\f1,
\f4TERM\f1,
and
\f4PATH\f1,
are automatically imported to and exported from the
\f4csh\f1
variables
\f4user\f1,
\f4term\f1,
and
\f4path\f1;
there is no need to use
\f4setenv\f1
for these.
In addition,
the shell sets the
\f4PWD\fP
environment variable from the
\f4csh\f1
variable
\f4cwd\f1
whenever the latter changes.
.TP
\f4shift\f1 [ \f2variable\f1 ]
The components of
\f4argv\f1,
or
\f2variable\f1,
if supplied, are shifted to the left, discarding
the first component.
It is an error for the variable not to be set, or to have a null value.
.TP
\f4source\f1 [ \f4\-h\f1 ] \f2name\f1
Reads commands from
\f2name\f1.
\f4source\f1
commands can be nested, but if they are nested too deeply the shell may
run out of file descriptors.
An error in a sourced file at any level terminates all nested
\f4source\f1
commands.
.RS
.TP
\f4\-h\f1
Place commands from the file
\f2name\f1
on the history list without executing them.
.RE
.TP
\f4stop\f1 [ \f4%\f2job\f1 ] ...
Stop the current or specified background job.
.TP
\f4suspend\f1
Stop the shell in its tracks, much as if it had been sent a stop
signal with
\f4^Z\f1.
This is most often used to stop shells started by
\f4su\f1.
.TP
\f4switch (\f2string\f4)\f1
.PD 0
.TP
\f4case\f2 label\f4:\f1
.TP
\&...
.TP
\f4breaksw\f1
.TP
\&...
.TP
\f4default:\f1
.TP
\&...
.TP
\f4breaksw\f1
.TP
\f4endsw\f1
.PD
Each
\f2label\f1
is successively matched, against the specified
\f2string\f1,
which is first command and filename expanded.
The file metacharacters
\f4*\f1,
\f4?\f1
and
\f4[\f1...\f4]\f1
can be used in the case labels, which are variable expanded.
If none of the labels match before a \(lqdefault\(rq label is found,
execution begins after the default label.
Each
\f4case\f1
statement and the
\f4default\f1
statement must appear at the beginning of a line.
The command
\f4breaksw\f1
continues execution after the
\f4endsw\f1.
Otherwise control falls through subsequent
\f4case\f1
and
\f4default\f1
statements as with C.
If no label matches and there is no default, execution continues after
the
\f4endsw\f1.
.PD
.TP
\f4time\f1 [ \f2command\f1 ]
With no argument, print a summary of time used by
this C shell and its children.
With an optional
\f2command\f1,
execute
\f2command\f1
and print a summary of the time it uses.
.TP
\f4umask\f1 [ \f2value\f1 ]
Display the file creation mask.
With
\f2value\f1
set the file creation mask.
\f2value\f1
is given in octal, and is
XORed
with the permissions of 666 for files and 777 for directories to arrive
at the permissions for new files.
Common values include 002, giving complete access to the group, and
read (and directory search) access to others, or 022, giving read
(and directory search) but not write permission to the group and others.
.TP
\f4unalias\f2 pattern\f1
Discard aliases that match (filename substitution)
\f2pattern\f1.
All aliases are removed by
\f4unalias\ *\f1.
.TP
\f4unhash\f1
Disable the internal hash table.
.TP
\f4unlimit\f1 [ \f4\-h\f1 ] [ \f2resource\f1 ]
Remove a limitation on
\f2resource\f1.
If no
\f2resource\f1
is specified, then all
\f2resource\f1
limitations are removed.
See the description of the
\f4limit\f1
command for the list of
\f2resource\f1
names.
.RS
.TP
\f4\-h\f1
Remove corresponding hard limits.
Only the privileged user can do this.
.RE
.TP
\f4unset\f2 pattern\f1
Remove variables whose names match (filename substitution)
\f2pattern\f1.
All variables are removed by
\f1`\f4unset *\f1';
this has noticeably distasteful side-effects.
.TP
\f4unsetenv\f2 variable\f1
Remove
\f2variable\f1
from the environment.
Pattern matching, as with
\f4unset\f1
is not performed.
.TP
\f4wait\f1
Wait for background jobs to finish (or for an interrupt) before
prompting.
.TP
\f4while (\f2expr\f4)\f1
.PD 0
.TP
\&...
.TP
\f4end\f1
.PD
While
\f4expr\fP
is true (evaluates to non-zero), repeat commands between the
\f4while\f1
and the matching
\f4end\f1
statement.
\f4break\f1
and
\f4continue\f1
can be used to terminate or continue the loop prematurely.
The
\f4while\f1
and
\f4end\f1
must appear alone on their input lines.
If the shell's input is a terminal, it prompts for commands
with a question-mark until the
\f4end\f1
command is entered and then performs the commands in the loop.
.TP
\f4%\f1 [ \f2job\f1 ] [ \f4&\f1 ]
Bring the current or indicated
\f2job\f1
to the foreground.
With the ampersand, continue running
\f2job\f1
in the background.
.TP
\f4@\f1 [ \f2var \f4=expr\f1 ]
.PD 0
.TP
\f4@\f1 [ \f2var \f4[\f2n\f4] =expr\f1 ]
.PD
With no arguments, display the values for all shell variables.
With arguments,
the variable
\f2var\f1,
or the
\f2n\f1'th
word in the value of
\f2var\f1 ,
to the value that
\f4expr\fP
evaluates to.
(If
\f4[\f2n\f4]\f1
is supplied, both
\f2var\f1
and its
\f2n\f1'th
component must already exist.)
.IP
If the expression contains the characters
\f4>\f1,
\f4<\f1,
\f4&\f1
or
\f4|\f1,
then at least this part of
\f4expr\fP
must be placed within parentheses.
.IP
The operators
\f4*=\f1,
\f4+=\f1,
etc., are available as in C.
The space separating the name from the assignment operator is optional.
Spaces are, however, mandatory in separating components of
\f4expr\fP
that would otherwise be single words.
.IP
Special postfix operators,
\f4++\f1
and
\f4\-\-\f1
increment or decrement
\f2name\f1,
respectively.
.PD
.SS "Environment Variables and Predefined Shell Variables"
Unlike the standard shell, the C shell maintains a distinction between
environment variables,
which are automatically exported to processes it invokes, and
shell variables, which are not.
Both types of variables are treated similarly under variable substitution.
The shell sets the variables
\f4argv\f1,
\f4cwd\f1,
\f4home\f1,
\f4path\f1,
\f4prompt\f1,
\f4shell\f1,
and
\f4status\f1
upon initialization.
The shell copies the environment variable
\f4USER\fP
into the shell variable
\f4user\f1,
\f4TERM\fP
into
\f4term\f1,
and
\f4HOME\fP
into
\f4home\f1,
and copies each back into the respective environment variable whenever
the shell variables are reset.
\f4PATH\fP
and
\f4path\f1
are similarly handled.
You need only set
\f4path\f1
once in the
\f4\&.cshrc\f1
or
\f4\&.login\f1
file.
The environment variable
\f4PWD\fP
is set from
\f4cwd\f1
whenever the latter changes.
The following shell variables have predefined meanings:
.TP 10
\f4argv\f1
Argument list.
Contains the list of command-line arguments
supplied to the current invocation of the shell.
This variable
determines the value of the positional parameters
\f4$1\f1,
\f4$2\f1,
and so on.
Note:  \f4argv[0]\f1 does not contain the command name.
.TP
\f4cdpath\f1
Contains a list of directories to be searched by the
\f4cd\f1,
\f4chdir\f1,
and
\f4popd\f1
commands, if the directory argument each accepts is not a subdirectory
of the current directory.
.TP
\f4child\f1
The process id of the most recently started background job.
.TP
\f4cwd\f1
The full pathname of the current directory.
.TP
\f4echo\f1
Echo commands (after substitutions), just before execution.
.TP
\f4fignore\f1
A list of filename suffixes to ignore when attempting filename
completion.
Typically the single word
\f1`\f4\&.o\f1'.
.TP
\f4filec\f1
Enable filename completion, in which case the
<Ctrl-d>
character
<Ctrl-d>)
and the
ESC
character have special significance when typed in at the end of
a terminal input line:
.RS
.TP
EOT
Print a list of all filenames that start with the preceding string.
.PD 0
.TP
ESC
Replace the preceding string with the
longest unambiguous extension.
.PD
.RE
.TP
\f4hardpaths\f1
If set, pathnames in the directory stack are resolved to contain
no symbolic-link components.
.TP
\f4histchars\f1
A two-character string.
The first character replaces
\f4!\f1 as the history-substitution character.
The second replaces
the carat
\f1(\f4^\f1)
for quick substitutions.
.TP
\f4history\f1
The number of lines saved in the history list.
A very large number may use up all of the C shell's memory.
If not set, the C shell saves only the most recent command.
.TP
\f4home\f1
The user's home directory.
The filename expansion of
\f4~\f1
refers to the value of this variable.
.TP
\f4ignoreeof\f1
If set, the shell ignores
EOF
from terminals.
This protects
against accidentally killing a C shell by typing a
<Ctrl-d>.
.TP
\f4mail\f1
A list of files where the C shell checks for mail.
If the first word of the value is a number, it specifies a mail checking
interval in seconds (default 5 minutes).
.TP
\f4nobeep\f1
Suppress the bell during command completion when asking the C shell to
extend an ambiguous filename.
.TP
\f4noclobber\f1
Restrict output redirection so that existing files are not destroyed by
accident.
\f4>\f1
redirections can only be made to new files.
\f4>>\f1
redirections can only be made to existing files.
.TP
\f4noglob\f1
Inhibit filename substitution.
This is most useful in shell scripts once filenames (if any) are
obtained and no further expansion is desired.
.TP
\f4nonomatch\f1
Returns the filename substitution pattern, rather than an error, if the
pattern is not matched.
Malformed patterns still result in errors.
.TP
\f4notify\f1
If set, the shell notifies you immediately as jobs are completed,
rather than waiting until just before issuing a prompt.
.TP
\f4path\f1
The list of directories in which to search for commands.
\f4path\f1
is initialized from the environment variable
\f4PATH\f1,
which the C shell updates whenever
\f4path\f1
changes.
A null word specifies the current directory.
The default search path for normal users is:
\f4(.
/usr/sbin /usr/bsd /bin /usr/bin /usr/bin/X11)\f1.
For the privileged user, the default search path is:
\f4(/usr/sbin /usr/bsd /bin /usr/bin /etc /usr/etc /usr/bin/X11)\f1.
If
\f4path\f1
becomes unset, only full pathnames execute.
An interactive C shell normally hashes the contents of the
directories
listed after reading
\f4\&.cshrc\f1,
and whenever
\f4path\f1
is reset.
If new commands are added, use the
\f4rehash\f1
command to update the table.
.TP
\f4prompt\f1
The string an interactive C shell prompts with.
Noninteractive shells leave the
\f4prompt\f1
variable unset.
Aliases and other commands in the
\f4\&.cshrc\f1
file that are only useful interactively, can be placed after the
following test:
\f1`\f4if ($?prompt == 0) exit\f1',
to reduce startup time for noninteractive shells.
A
\f4!\f1 in the
\f4prompt\f1
string is replaced by the current event number.
The default prompt is
\f2hostname\f4%\f1
for mere mortals, or
\f2hostname\f4#\f1
for the privileged user.
.TP
\&
If the \f4prompt\f1 string includes the sequence \f4\e@\f1\f2x\f1,
where \f2x\f1 is one of the characters listed below,
it is replaced by the current time and date in the
indicated format.
.sp .8v
.RS
.PD 0
.TP
\f3R\f1
time as HH:MM AM/PM, for example, 8:40PM
.TP
\f3r\f1
time as HH:MM:SS AM/PM, for example, 08:40:25 PM
.TP
\f3m\f1
month of year \- 01 to 12
.TP
\f3d\f1
day of month \- 01 to 31
.TP
\f3y\f1
last 2 digits of year \- 00 to 99
.TP
\f3D\f1
date as mm/dd/yy
.TP
\f3H\f1
hour \- 00 to 23
.TP
\f3M\f1
minute \- 00 to 59
.TP
\f3S\f1
second \- 00 to 59
.TP
\f3T\f1
time as HH:MM:SS
.TP
\f3j\f1
day of year \- 001 to 366
.TP
\f3w\f1
day of week \- Sunday = 0
.TP
\f3a\f1
abbreviated weekday \- Sun to Sat
.TP
\f3h\f1
abbreviated month \- Jan to Dec
.TP
\f3n\f1
insert a newline character
.TP
\f3t\f1
insert a tab character
.RE
.PD
.TP
\f4savehist\f1
The number of lines from the history list that are saved in
\f4~/.history\f1
when the user logs out.
Large values for
\f4savehist\f1
slow down the C shell during startup.
To prevent \f4su\f1 sessions from overwriting the
underlying user's history file,
the shell only writes in the \f4~/.history\f1 file if its
current effective user id is the same as the owner of the
directory specified by the \f4home\f1 variable.
.TP
\f4shell\f1
The file in which the C shell resides.
This is used in forking shells to interpret files that have execute
bits set, but that are not executable by the system.
.TP
\f4status\f1
The status returned by the most recent command.
If that command terminated abnormally, 0200 is added to the status.
Built-in commands that fail return exit status 1,
all other built-in commands set status to 0.
.TP
\f4time\f1
Control automatic timing of commands.
Can be supplied with one or two
values.
The first is the reporting threshold in
CPU
seconds.
The second is a string of tags and text indicating which resources
to report on.
A tag is a percent sign
\f1(\f4%\f1)
followed by a single
\f2upper-case\f1
letter (unrecognized tags print as text):
.RS
.TP
\f4%D\f1
Average amount of unshared data space used in Kilobytes.
.PD 0
.TP
\f4%E\f1
Elapsed (wallclock) time for the command.
.TP
\f4%F\f1
Page faults.
.TP
\f4%I\f1
Number of block input operations.
.TP
\f4%K\f1
Average amount of unshared stack space used in Kilobytes.
.TP
\f4%M\f1
Maximum real memory used during execution of the process in Kilobytes.
.TP
\f4%O\f1
Number of block output operations.
.TP
\f4%P\f1
Total
CPU
time \-\- U (user) plus S (system) \-\- as a percentage of
E (elapsed) time.
.TP
\f4%S\f1
Number of seconds of
CPU
time consumed by the kernel on behalf of the
user's process.
.TP
\f4%U\f1
Number of seconds of
CPU
time devoted to the user's process.
.TP
\f4%W\f1
Number of swaps.
.TP
\f4%X\f1
Average amount of shared memory used in Kilobytes.
.PD
.RE
.IP
The default summary display outputs from the
\f4%U\f1,
\f4%S\f1,
\f4%E\f1,
\f4%P\f1,
\f4%X\f1,
\f4%D\f1,
\f4%I\f1,
\f4%O\f1,
\f4%F\f1
and
\f4%W\f1
tags, in that order.
.IP
Note that the values for
\f4%D\f1,
\f4%K\f1,
and
\f4%X\f1
always print as zero since the
IRIX kernel does not maintain the \f4getrusage\f1(3)
counters required to calculate them.
.TP
\f4verbose\f1
Display each command after history substitution takes place.
.SH FILES
.PD 0
.TP 15
\f4~/.cshrc\f1
Read at beginning of execution by each shell.
.TP
\f4/etc/cshrc\f1
Read by login shells before
\f4\&.cshrc\f1
at login.
.TP
\f4/etc/.login\f1
Read by login shells before
\f4\&.cshrc\f1
and after
\f4/etc/cshrc\f1.
.TP
\f4/etc/csh.cshrc\f1
Read by login shells before
\f4\&.cshrc\f1 and after
\f4/etc/.login\f1.
.TP
\f4~/.login\f1
Read by login shells after
\f4\&.cshrc\f1
at login.
.TP
\f4~/.logout\f1
Read by login shells at logout.
.TP
\f4~/.history\f1
Saved history for use at next login.
.TP
\f4/usr/bin/sh\f1
Standard shell, for shell scripts not starting with a
\f1`\f4#\f1'.
.TP
\f4/tmp/sh*\f1
Temporary file for
\f1`\f4<<\f1'.
.TP
\f4/etc/passwd\f1
Source of home directories for
\f2`\f4~\f2name'\f1.
.PD
.SH "SEE ALSO"
login(1),
sh(1),
xwsh(1G),
access(2),
exec(2),
fork(2),
pipe(2),
a.out(4),
ascii(5),
environ(5),
termio(7).
.SH DIAGNOSTICS
.TP
\f4You have stopped jobs.\f1
You attempted to exit the C shell with stopped jobs under job control.
An immediate second attempt to exit will succeed, terminating
the stopped jobs.
.SH NOTES
Words can be no longer than 1024 characters.
The system limits argument lists (including all environment variables)
to 20480 characters by default.
Command substitutions can expand to no more characters than are
allowed in the argument list.
Sometimes, particularly when using wildcards, the shell will fail to
execute a command, and complain with the message
   \f3Arguments too long\fP
.br
This can often be avoided by using multiple commands, the 
.IR xargs (1)
command, or by increasing the \f3ncargs\fP kernel parameter with the
.IR systune (1m)
command.  If the kernel parameter is increased, currently running
\f2csh\fP's will not notice the change.  It is necessary to start
a new shell, or logout and back in, for the change to be effective.
.P
To detect looping, the shell restricts the number of
\f4alias\f1
substitutions on a single line to 20.
.P
When a command is restarted from a stop,
the shell prints the directory it started in if this is different
from the current directory; this can be misleading (that is, wrong)
as the job may have changed directories internally.
.P
Shell built-in functions are not stoppable/restartable.
Command sequences of the form
\f2a\f4 ; \f2b\f4 ; \f2c\f1
are also not handled gracefully
when stopping is attempted.
If you suspend
\f2b\f1,
the shell never executes
\f2c\f1.
This is especially noticeable if the
expansion results from an alias.
It can be avoided by
placing the sequence in parentheses to force it into a subshell.
.P
Control over terminal output after processes are started is primitive.
.P
Multiline shell procedures should be provided, as they are with the
standard (Bourne) shell.
.P
Commands within loops, prompted for by
\f4?\f1,
are not placed in the
\f2history\f1
list.
.P
Control structures should be parsed rather than being recognized as
built-in commands.
This would allow control commands to be placed
anywhere, to be combined with
\f4|\f1,
and to be used with
\f4&\f1
and
\f4;\f1
metasyntax.
.P
It should be possible to use the
\f4:\f1
modifiers on the output of command substitutions.
There are two problems with
\f4:\f1
modifier usage on variable substitutions:
not all of the modifiers are available, and only one modifier per
substitution is allowed.
.P
The
\f4g\f1
(global) flag in history substitutions applies only to the first
match in each word, rather than all matches in all words.
The the standard text editors consistently do the latter when given the
\f4g\f1
flag in a substitution command.
.P
Quoting conventions are confusing.
Overriding the
escape character to force variable substitutions within double
quotes is counterintuitive and inconsistent with the Bourne shell.
.P
Symbolic links can fool the shell.
Setting the
\f4hardpaths\f1
variable alleviates this.
.P
\f1`\f4set path\f1'
should remove duplicate pathnames from the pathname list.
These often occur because a shell script or a
\f4\&.cshrc\f1
file does something like
\f1`\f4set path=(/usr/local\ \ /usr/hosts\ \ $path)\f1'
to ensure that the named directories are in the pathname list.
.P
The only way to direct the standard output and standard error
separately is by invoking a subshell, as follows:
.IP
.ft 4
example% (\f2command\fP > \f2outfile\fP) >& \f2errorfile\fP
.ft 1
.P
Although robust enough for general use, adventures into the esoteric
periphery of the C shell may reveal unexpected quirks.
