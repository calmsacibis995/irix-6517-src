'\"macro stdmacro
.if n .pH g1.fpmode @(#)fpmode
.nr X
.if \nX=0 .ds x} FPMODE 1 "User Environment Utilities" "\&"
.if \nX=1 .ds x} FPMODE 1 "User Environment Utilities"
.if \nX=2 .ds x} FPMODE 1 "" "\&"
.if \nX=3 .ds x} FPMODE "" "" "\&"
.TH \*(x}
.tr ~
.SH NAME
fpmode \- run a command in specified floating point and/or memory mode
.SH SYNOPSIS
.B fpmode
precise|performance|smm|nsmm|spec|nonspec command [ arguments ]
.SH DESCRIPTION
.I fpmode\^
executes
.I command\^,
forcing it to use the specified floating point exception and memory access
mode. This is
only meaningful on processors that support multiple modes. On
these processors, the default mode is usually performance mode (also
called imprecise exception mode) and non-sequential memory (nsmm) mode.
On all other processors, the default is precise exception and sequential (smm)
mode.
.PP
The R8000 is the only processor which supports both a precise exception
mode and a performance mode.  All other processors support only precise
exceptions, though automatic flushing of denormalized results to zero
may be controlled through the setting of the FS bit in the FP
control and status register by calling \f2set_fpc_csr()\fP.
.PP
In precise exception mode, all floating point exceptions/interrupts are
reported on the instruction that caused the exception, so floating point
signal handlers can clean up the FP state and continue execution. In
performance mode, floating point interrupts are asynchronous and the
reported program counter is meaningless. Precise mode is provided as
a means of debugging processes and/or backward compatibility for programs
that have knowledge of the FP state. It causes significant performance
degradation.
.PP
When a program is run in performance mode on an R8000, the floating point processor
automatically flushes all denormalized results to zero regardless of the
setting of the FS (flush denormalized results to zero) bit in the FP
control and status register. This bit is turned on at \f2exec()\fP time.
Turning it off (by calling \f2set_fpc_csr()\fP) will cause performance
degradation. When the same program is run in precise mode, the FS bit is
turned off at \f2exec()\fP time (for backward compatibility with older
processors). Note that this means a given program may generate different
results when run in performance and precise modes.
.PP
Non-sequential memory access mode allows the processor to do
floating point and integer memory operations out of order, thus
possibly providing better performance.  This is only supported on R8000
processors.
.PP
Turning on speculative execution (spec) mode tells the kernel to
ignore all memory access faults generated by the program. This mode
is used by the compiler to provide better performance in some cases
by allowing eager instruction scheduling. Note that this may also cause
significantly worse performance if used indiscriminately and should
be avoided when debugging since it masks potential problems.
.PP
The floating point mode is inherited across \f2fork()\fP and
\f2exec()\fP system calls. To modify both exception and memory modes,
use fpmode twice; e.g.,
.sp
.RS
fpmode precise fpmode smm command
.RE
.sp
.SH SEE ALSO
syssgi(2), get_fpc_csr(3), set_fpc_csr(3).
.SH WARNINGS
In the case of the following command
.sp
.RS
fpmode precise command1; command2
.RE
.sp
\f2fpmode\f1
applies only to
command1.
The command
.sp
.RS
fpmode precise (command1; command2)
.RE
.sp
is syntactically incorrect.
.Ee
'\".so /pubs/tools/origin.att
