'\"macro stdmacro
.if n .pH g2.intro @(#)intro	30.18 of 3/24/86
.nr X
.if \nX=0 .ds x} INTRO 2 "" "\&"
.if \nX=1 .ds x} INTRO 2 ""
.if \nX=2 .ds x} INTRO 2 "" "\&"
.if \nX=3 .ds x} INTRO "" "" "\&"
.TH \*(x}
.de {n
.HP
\\$1  \\$2  \\$3
.br
..
.SH NAME
intro \- introduction to system calls and error numbers
.SH SYNOPSIS
.B #include \|<errno.h>
.br
.B #include \|<limits.h>
.SH DESCRIPTION
This section
describes all of the system calls.
Most of these calls have one or more error returns.
An error condition is indicated by an otherwise
impossible returned value.
This is almost always \-1 or the NULL pointer;
the individual descriptions specify the details.
An error number is also made available
in the external variable
.IR errno .
.I errno\^
is not cleared on successful calls, so it should be tested only
after an error has been indicated.
.PP
Many of these errors are caused by certain system or user limits
being exceeded.
In the individual manual pages, these limits are enclosed in
braces (i.e.
.SM
.IR {OPEN_MAX} ).
The section
.I LIMITS
defines these limits, where and how they are configured, and whether they are
alterable.
.PP
Each system call description attempts to
list all possible error numbers.
The following is a complete list of the error numbers and
their names as defined in
.BR <errno.h> .
.{n 1 \s-1EPERM\s+1 "Operation not permitted"
Typically this error indicates
an attempt to modify a file in some way forbidden
except to its owner or super-user.
It is also returned for attempts
by ordinary users to do things
allowed only to the super-user.
A special case of this involves setuid/setgid shell scripts
and a kernel that is configured with a non-zero value for
.I nosuidshells
(the shipped default).
The kernel returns \s-1EPERM\s+1 when a non-superuser attempts to
execute such a shell script with a uid
or gid which is different than the user's effective uid/gid.
The kernel also returns \s-1EPERM\s+1 if it has been configured with
a non-zero value for
.I restricted_chown .
Only the super-user can change the owner of the file, because if users
were able to give files away, they could defeat the file space accounting
procedures. The owner of the file may change the group ownership only
to those groups of which he is a member.
Another case where the kernel may return \s-1EPERM\s+2 is when a non-superuser
tries to execute a setuid file which belongs to some other user and the
file system in which the file resides has been mounted with the
.I nosuid
option.
.{n 2 \s-1ENOENT\s+1 "No such file or directory"
This error occurs when a file name is specified
and the file should exist but doesn't, or when one
of the directories in a path name does not exist.
.{n 3 \s-1ESRCH\s+1 "No such process"
No process can be found corresponding to that specified by
.I pid\^
in
\f2kill\f1(2),
\f2blockproc\f1(2),
or
\f2ptrace\f1(2).
.{n 4 \s-1EINTR\s+1 "Interrupted function call"
An asynchronous signal (such as interrupt or quit),
which the user has elected to catch,
occurred during the execution of an interruptible function.
If execution is resumed
after processing the signal,
it will appear as if the interrupted system call
returned this error condition
[see section on interruptibility].
.{n 5 \s-1EIO\s+1 "I/O error"
Some physical I/O error has occurred.
This error may in some cases occur
on a call following the one to which it actually applies.
.{n 6 \s-1ENXIO\s+1 "No such device or address"
I/O on a special file refers to a subdevice which does not
exist,
or beyond the limits of the device.
It may also occur when, for example, a tape drive
is not on-line or no disk pack is loaded on a drive.
.{n 7 \s-1E2BIG\s+1 "Arg list too long"
An argument list longer than 
.SM
.I {ARG_MAX}
bytes
is presented to a member of the
.IR exec (2)
family.
.{n 8 \s-1ENOEXEC\s+1 "Exec format error"
A request is made to execute a file
which, although it has the appropriate permissions,
does not start with a valid magic number [see
.IR a.out (4)].
.{n 9 \s-1EBADF\s+1 "Bad file number"
Either a file descriptor refers to no
open file,
or a 
.IR read (2)
[respectively, 
.IR write (2)]
request is made to
a file which is open only for writing (respectively, reading).
.{n 10 \s-1ECHILD\s+1 "No child processes"
A
.I wait
or
.I waitpid
function
was executed by a process that had no existing or unwaited-for child processes.
.{n 11 \s-1EAGAIN\s+1 "Resource temporarily unavailable"
1) A
.I fork
or
.I sproc
failed because the maximum number of processes system wide
.SM
.I {NPROC}
was exceeded
or the user exceeded their limit on the number of child processes
.SM
.IR {CHILD_MAX} .
2) A system call failed because of insufficient memory or swap space.
Later calls to the same routine may complete normally.
3) Some read system calls--involving empty streams or locked 
files/records--with the O_NDELAY flag set may return this error.
See 
.IR read (2).
4) An operation which would cause a process to block was attempted
on an object in non-blocking mode [see 
.IR ioctl\^ (2)].
5) A file system operation was unable to complete due to a locked file
or record (see \f4fcntl\fP(2)].
.{n 11 \s-1EWOULDBLOCK\s+1 "Operation would block"
This is a synonym for \s-1EAGAIN\s+1.
.{n 12 \s-1ENOMEM\s+1 "Not enough space"
During an
\f2exec\f1(2),
\f2brk\f1(2),
or
\f2sbrk\f1(2),
a process exceeds its maximum allowable size
.SM
.IR {PROCSIZE_MAX} .
This may also be returned by device drivers if they cannot dynamically allocate
enough space.
.{n 13 \s-1EACCES\s+1 "Permission denied"
An attempt was made to access a file in a way forbidden
by the protection system.
.{n 14 \s-1EFAULT\s+1 "Bad address"
The system encountered a hardware fault in attempting to
use an argument of a system call.
.{n 15 \s-1ENOTBLK\s+1 "Block device required"
A non-block file was mentioned where a block device was required,
(e.g., in a call to the \f2mount\f1(2) routine).
.{n 16 \s-1EBUSY\s+1 "Resource busy"
An attempt was made to mount a device that was already mounted or
an attempt was made to dismount a device
on which there is an active file
(open file, current directory, mounted-on file, active text segment).
It will also occur if an attempt is made to enable accounting when it is
already enabled.
The device or resource is currently unavailable.
.{n 17 \s-1EEXIST\s+1 "File exists"
An existing file was mentioned in an inappropriate context,
(e.g., call to the \f2link\f1(2) routine).
.{n 18 \s-1EXDEV\s+1 "Improper link"
A link to a file on another file system
was attempted.
.{n 19 \s-1ENODEV\s+1 "No such device"
An attempt was made to apply an inappropriate
system call to a device;
e.g., read a write-only device.
.{n 20 \s-1ENOTDIR\s+1 "Not a directory"
A non-directory was specified where a directory
is required,
(e.g., in a path prefix or
as an argument to the \f2chdir\fP(2) routine).
.{n 21 \s-1EISDIR\s+1 "Is a directory"
An attempt was made to write on a directory.
.{n 22 \s-1EINVAL\s+1 "Invalid argument"
Some invalid argument (e.g., dismounting a non-mounted device;
mentioning an undefined signal in
\f2signal\f1(2)
or
\f2kill\f1(2);
reading or writing a file for which
\f2lseek\f1(2)
has generated a negative pointer).
Also set by the math functions described in the (3M) entries
of this manual.
.{n 23 \s-1ENFILE\s+1 "Too many open files in system"
The system file table is full (has exceeded
.SM
.I {NFILE_MAX}
entries),
and temporarily no more
.I opens\^
can be accepted.
.{n 24 \s-1EMFILE\s+1 "Too many open files in a process"
No process may have more than
.SM
.I {OPEN_MAX}
descriptors open at a time.
Or the maximum number of shared memory segments
.SM
.I {SHMAT_MAX}
was exceeded.
.{n 25 \s-1ENOTTY\s+1 "Inappropriate I/O control operation"
An attempt was made to \f2ioctl\f1(2) a file that
is not a special character device.
.{n 26 \s-1ETXTBSY\s+1 "Text file busy"
An attempt was made to execute a pure-procedure
program that is currently open for writing.
Also an attempt to open for writing or to remove a pure-procedure
program that is being executed.
This error is no longer returned, and the actions mentioned above are
now permitted.
.{n 27 \s-1EFBIG\s+1 "File too large"
The size of a file exceeded the per process maximum
file size
.SM
.IR {FILESIZE_MAX} ,
or the file has more than
the maximum number of direct and indirect extents (usually indicates
an extremely fragmented filesystem; see
.IR fsr (1m)
for a method to fix this).
.{n 28 \s-1ENOSPC\s+1 "No space left on device"
During a
\f2write\f1(2)
to an ordinary file,
there is no free space left on the device.
.{n 29 \s-1ESPIPE\s+1 "Illegal seek"
An
\f2lseek\f1(2)
was issued to a pipe or FIFO.
.{n 30 \s-1EROFS\s+1 "Read-only file system"
An attempt to modify a file or directory
was made
on a device mounted read-only.
.{n 31 \s-1EMLINK\s+1 "Too many links"
An attempt to make more than the maximum number of links 
.SM
.IR {LINK_MAX}
to a file.
.{n 32 \s-1EPIPE\s+1 "Broken pipe"
A write on a pipe or FIFO for which there is no process
to read the data.
.{n 33 \s-1EDOM\s+1 "Domain error"
The argument of a function in the math package (3M) or other library functions
is out of the domain of the function.
.{n 34 \s-1ERANGE\s+1 "Result too large"
The value of a function in the math package (3M)
is not representable within machine precision, or a size specified
is not large enough.
.{n 35 \s-1ENOMSG\s+1 "No message of desired type"
An attempt was made to receive a message of a type
that does not exist on the specified message queue [see
.IR msgop (2)].
.{n 36 \s-1EIDRM\s+1 "Identifier removed"
This error is returned to processes that resume execution due to the removal
of an identifier from the file system's name space [see
.IR msgctl "(2), " semctl "(2), and " shmctl (2)].
.{n 37-44 Reserved numbers  
.{n 45 \s-1EDEADLK\s+1 "Resource deadlock avoided"
An attempt was made to lock a system resource that would have
resulted in a deadlock situation.
.{n 46 \s-1ENOLCK\s+1 "No locks available"
In
\f2fcntl\f1(2)
the setting or removing of record locks on a file
cannot be accomplished because the system wide maximum number of record entries
.SM
.I {FLOCK_MAX}
has been exceeded.
It can also occur when attempting to lock a file located on an NFS
mounted file system and the appropriate NFS lock daemons are not running.
.{n 47 \s-1ECKPT\s+1 "Checkpoint/Restart error"
A process Checkpoint/Restart (CPR) operation has failed due to several
possible fatal reasons. It can occur when an unrecoverable critical resource is 
associated with the target process during a checkpoint or restart.  
See
\f2cpr\f1(1)
for more detailed descriptions on CPR and error conditions.
.{n 50-57 Reserved numbers
.{n 60 \s-1ENOSTR\s+1 "Not a stream device"
A
.IR putmsg "(2) or " getmsg (2)
system call was attempted on
a file descriptor that is not a \s-1STREAMS\s0 device.
.{n 61 \s-1ENODATA\s+1 "No data available"
.{n 62 \s-1ETIME\s+1 "Timer expired"
The timer set for a \s-1STREAMS\s0 \f2ioctl\f1(2) call has
expired.  The cause of this error is device
specific and could indicate either a hardware
or software failure, or perhaps a timeout value
that is too short for the specific operation.
The status of the \f2ioctl\f1(2) operation is indeterminate.
.{n 63 \s-1ENOSR\s+1 "Out of stream resources"
During a
\s-1STREAMS\s0
\f2open\f1(2), either no
\s-1STREAMS\s0
queues or no
\s-1STREAMS\s0
head data structures were available.
This is a temporary condition; one may recover from it
if other processes release resources.
.{n 64 Reserved
.{n 65 \s-1ENOPKG\s+1 "Package not installed"
This error occurs when users attempt to use
a system call from a package which has not been installed.
.{n 66-70 Reserved numbers
.{n 71 \s-1EPROTO\s+1 "Protocol error"
Some protocol error occurred.  This error
is device specific, but is generally not related
to a hardware failure.
.{n 74-76 Reserved numbers
.{n 77 \s-1EBADMSG\s+1 "Bad message"
During a \f2read\f1(2), \f2getmsg\f1(2), or \f2ioctl\f1(2) \s-1I_RECVFD\s0 system call
to a \s-1STREAMS\s0 device, something has come to the head of the queue
that can't be processed.  That something depends on the
system call:
  \f2read\f1(2) - control information or a passed file descriptor.
  \f2getmsg\f1(2) - passed file descriptor.
  \f2ioctl\f1(2) - control or data information.
.{n 78 \s-1ENAMETOOLONG\s+1 "File name too long"
The size of a pathname string exceeds
.SM
.I {PATH_MAX}
, or a pathname component was longer than
.SM
.I {NAME_MAX}
and
.I {_POSIX_NO_TRUNC}
was in effect for that file.
.{n 79 \s-1EOVERFLOW\s+1 "Value too large for defined data type"
This error can occur for a variety of reasons, most to do with existing
applications being compiled with data structures that cannot handle
newer expanded sizes.
It also occurs often if a 32 bit program attempts to access particular
data about a 64 bit program.
.sp
The user ID or group ID of an IPC or file system object was too large to
be stored into appropriate member of the caller-provided structure.
.sp
The size of a file system object is larger than can be represented
in an \f4off_t\fP. This occurs when standard 32 bit programs attempt
to access files greater than 2GB, or files greater than 2GB are accessed
across a remote file system that cannot handle that size.
.{n 80-82 Reserved numbers
.{n 83 \s-1ELIBACC\s+1  "Can not access a needed shared library"
Trying to \f2exec\f1(2) an \f2a.out\fP that requires a shared library
(to be linked in) and the shared library doesn't exist or
the user doesn't have permission to use it. (obsolete)
.{n 84 \s-1ELIBBAD\s+1 "Accessing a corrupted shared library"
Trying to \f2exec\f1(2) an \f2a.out\fP that requires a shared library
(to be linked in) and \f2exec\f1(2) could not load the shared
library. The shared library is probably corrupted. (obsolete)
.{n 85 \s-1ELIBSCN\s+1 ".lib section in \f2a.out\fP corrupted"
Trying to \f2exec\f1(2) an \f2a.out\fP that requires a shared library
(to be linked in) and there was erroneous data in the .lib
section of the \f2a.out\fP. The .lib section tells \f2exec\f1(2) what
shared libraries are needed. The \f2a.out\fP is probably
corrupted. (obsolete)
.{n 86 \s-1ELIBMAX\s+1 "Attempting to link in more shared libraries than system limit"
Trying to \f2exec\f1(2) an \f2a.out\fP that requires more shared
libraries (to be linked in) than the system imposed maximum
.SM
.IR {SHLIB_MAX} .
(obsolete)
.{n 87 \s-1ELIBEXEC\s+1 "Cannot exec a shared library directly"
Trying to \f2exec\f1(2) a shared library directly. This
is not allowed. (obsolete)
.{n 88 Reserved number
.{n 89 \s-1ENOSYS\s+1 "Function not implemented"
An attempt was made to use a function that is not available in
this implementation.
.{n 90 \s-1ELOOP\s+1 "Too many symbolic links in path name traversal"
A path name lookup involved more than
.SM
.IR {SYMLINK_MAX} symbolic links.
.{n 91 \s-1ERESTART\s+1 "Restartable system call"
Interrupted system call should be restarted.
.{n 92 \s-1ESTRPIPE\s+1 "If pipe/FIFO, don't sleep in stream head"
Streams pipe error (not externally visible).
.{n 93 \s-1ENOTEMPTY\s+1 "Directory not empty"
A directory with entries other than dot and dot-dot was supplied
when an empty directory was expected.
.{n 94 Reserved number
.{n 95 \s-1ENOTSOCK\s+1 "Socket operation on non-socket"
.{n 96 \s-1EDESTADDRREQ\s+1 "Destination address required"
A required address was omitted from an operation on a socket.
.{n 97 \s-1EMSGSIZE\s+1 "Inappropriate message buffer length"
A message sent on a socket was larger than the internal message
buffer or some other network limit.
.{n 98 \s-1EPROTOTYPE\s+1 "Protocol wrong type for socket"
A protocol was specified which does not support the semantics of the
socket type requested.  For example, you cannot use the 
.SM ARPA 
Internet
.SM UDP 
protocol with type SOCK_STREAM.
.{n 99 \s-1ENOPROTOOPT\s+1 "Option not supported by protocol"
A bad option was specified in a 
.IR getsockopt\^ (2)
or
.IR setsockopt\^ (2)
call.
.{n 120 \s-1EPROTONOSUPPORT\s+1 "Protocol not supported"
The protocol has not been configured into the system or no
implementation for it exists.
.{n 121 \s-1ESOCKTNOSUPPORT\s+1 "Socket type not supported"
The support for the socket type has not been configured into the system
or no implementation exists.
.{n 122 \s-1EOPNOTSUPP\s+1 "Operation not supported on socket"
For example, trying to \f2accept\^\fP a connection on a datagram socket.
.{n 123 \s-1EPFNOSUPPORT\s+1 "Protocol family not supported"
The protocol family has not been configured into the system
or no implementation exists.
.{n 124 \s-1EAFNOSUPPORT\s+1 "Address family not supported by protocol family"
An address incompatible with the requested protocol was used.
For example, you shouldn't necessarily expect to be able to use 
.SM PUP
Internet addresses with 
.SM ARPA
Internet protocols.
.{n 125 \s-1EADDRINUSE\s+1 "Address already in use"
Only one usage of each address is normally permitted.
.{n 126 \s-1EADDRNOTAVAIL\s+1 "Can't assign requested address"
Normally results from an attempt to create a socket with an
address not on this machine.
.{n 127 \s-1ENETDOWN\s+1 "Network is down"
A socket operation encountered a dead network.
.{n 128 \s-1ENETUNREACH\s+1 "Network is unreachable"
A socket operation was attempted to an unreachable network.
.{n 129 \s-1ENETRESET\s+1 "Network dropped connection on reset"
The host you were connected to crashed and rebooted.
.{n 130 \s-1ECONNABORTED\s+1 "Software caused connection abort"
A connection abort was caused internal to your host machine.
.{n 131 \s-1ECONNRESET\s+1 "Connection reset by peer"
A connection was forcibly closed by a peer.  This normally results
from a peer executing a
.IR shutdown\^ (2) 
call.
.{n 132 \s-1ENOBUFS\s+1 "No buffer space available"
An operation on a socket or pipe performed because the system 
lacked sufficient buffer space.
.{n 133 \s-1EISCONN\s+1 "Socket is already connected"
A 
.I connect
request was made on an already connected socket; or a
.I sendto
or 
.I sendmsg
request on a connected socket specified a destination other than the
connected party.
.{n 134 \s-1ENOTCONN\s+1 "Socket is not connected"
A request to send or receive data was disallowed because the socket 
was not connected.
.{n 135-142 Reserved numbers for XENIX
.{n 143 \s-1ESHUTDOWN\s+1 "Can't send after socket shutdown"
A request to send data was disallowed because the socket had already
been shut down with a previous
.IR shutdown\^ (2)
call.
.{n 144 \s-1ETOOMANYREFS\s+1 "Too many references: can't splice"
.{n 145 \s-1ETIMEDOUT\s+1 "Connection timed out"
A 
.I connect
request failed because the connected party did not properly respond
after a period of time. (The timeout period is dependent on the
communication protocol.)
[see section on interruptibility.]
.{n 146 \s-1ECONNREFUSED\s+1 "Connection refused"
No connection could be made because the target machine actively
refused it.
.{n 147 \s-1EHOSTDOWN\s+1 "Host is down"
.{n 148 \s-1EHOSTUNREACH\s+1 "No route to host"
.{n 149 \s-1EALREADY\s+1 "Operation already in progress"
An operation was attempted on a non-blocking object which
already had an operation in progress.
.{n 150 \s-1EINPROGRESS\s+1 "Operation now in progress"
An operation which takes a long time to complete (such as a
.IR connect\^ (2))
was attempted on a non-blocking object [see
.IR ioctl\^ (2)].
.{n 151 \s-1ESTALE\s+1 "Stale NFS file handle"
.{n 158 \s-1ECANCELLED\s+1 "Cancelled"
The associated asynchronous operation was canceled before completion.
.{n 1008 \s-1ENOTSUP\s+1 "Not supported"
IRIX does not support this feature of a standard.
.{n 1009 \s-1ENOATTR\s+1 "Attribute not found"
Named attribute does not exist for this file.
.{n 1010 \s-1EFSCORRUPTED\s+1 "Filesystem is corrupted"
Operation failed because the filesystem is corrupted.
.{n 1011 \s-1EWRONGFS\s+1 "Mount with wrong filesystem type"
Mount failed because the wrong filesystem type was supplied,
or because there is no filesystem on the device.
.{n 1133 \s-1EDQUOT\s+1 "Disc quota exceeded"
.{n 1135 \s-1ENFSREMOTE\s+1 "Too many levels of remote in path"
.SH DEFINITIONS
.SS
\f3Background Process Group\f1
Any process group that is not the foreground process group 
of a session that has established a connection
with a controlling terminal.
.SS
\f3Controlling Process\f1
A session leader that established a connection to a controlling terminal.
.SS
\f3Controlling Terminal\f1
A terminal that is associated with a session.  Each session may have, at most
one controlling terminal associated with it and a controlling terminal may
be associated with only one session.  Certain input sequences from the
controlling terminal cause signals to be sent to process groups in the session
associated with the controlling terminal; see \f4termio\fP(7).
.SS
\f3Directory\f1
.SS
Directories organize files into a hierarchical system where
directories are the nodes in the hierarchy.
A directory is a file that catalogues the list of files, including
directories (sub-directories), that are directly beneath it in the hierarchy.
Entries in a directory file are called links.
A link associates a file identifier with a filename.
By convention, a directory contains at least two links, \f4.\f1 (dot)
and \f4..\f1 (dot-dot).
The link called dot refers to the directory itself while dot-dot
refers to its parent directory.
The root directory, which is the top-most node of the hierarchy, has itself
as its parent directory.
The pathname of the root directory is \f4/\f1 and the
parent directory of the root directory is \f4/\f1.
\f3Downstream\f1
In a \f2stream\f1, the direction from \f2stream head\f1 to \f2driver\f1.
.SS
\f3Driver\f1
In a \f2stream\f1,
the \f2driver\f1 provides the interface between
peripheral hardware and the \f2stream\f1.
A \f2driver\f1 can also be a pseudo-\f2driver\f1,
such as a \f2multiplexor\f1 or log \f2driver\f1 [see \f2log\f1(7)],
which is not associated with a hardware device.
.SS
\f3Effective User \s-1ID\s+1 and Effective Group \s-1ID\s+1\f1
An active process has an effective user
.SM ID
and an effective group
.SM ID
that are used to determine file access permissions (see below).
The effective
user
.SM ID
and effective group
.SM ID
are equal to the process's real user
.SM ID
and real group
.SM ID
respectively, unless the process
or one of its ancestors evolved from a file that had the set-user-\s-1ID\s+1
bit or set-group
.SM ID
bit set 
[see \f2exec\f1(2)].
.SS
\f3File Descriptor\f1
A file descriptor is a small integer used
to do \s-1I/O\s+1 on a file.
The value of a file descriptor is from
0 to (NOFILES - 1).
A process may have no more than NOFILES file descriptors 
open simultaneously.
A file descriptor is returned by system calls such as
\f2open\f1(2),
or \f2pipe\f1(2).
The file descriptor is used as an
argument by calls such as
\f2read\f1(2),
\f2write\f1(2),
\f2ioctl\f1(2),
\f2mmap\f1(2),
\f2munmap\f1(2),
and
\f2close\f1(2).
NOFILES is a synonym for
.SM
.IR {OPEN_MAX} .
.SS
\f3File Access Permissions\f1
Read, write, and execute/search permissions on a file are
granted to a process if one or more of the following are true:
.IP
The effective user
.SM ID
of the process
is super-user.
.IP
The effective user
.SM ID
of the process
matches the user
.SM ID
of the owner of the file
and the appropriate access bit of the
``owner'' portion (0700) of the file mode is set.
.IP
The effective user
.SM ID
of the process
does not match the user
.SM ID
of the owner of the file,
and the effective group
.SM ID
of the process
matches the group of the file and
the appropriate access bit of the ``group'' portion
(0070) of the file mode is set.
.IP
The effective user
.SM ID
of the process
does not match the user
.SM ID
of the owner of the file,
and the effective group
.SM ID
of the process
does not match the group
.SM ID
of the file,
and the appropriate access bit of the ``other'' portion (0007) of the
file mode is set.
.PP
Otherwise, the corresponding permissions are denied.
.SS
\f3File Name\f1
Names consisting of 1 to
.SM
.I {NAME_MAX}
characters may be used to name an ordinary file,
special file or directory.
.PP
These characters may be selected from the set of all character values
excluding \e0 (null) and the
.SM ASCII
code for
.B /
(slash).
.PP
Note that it is generally unwise to use
.BR "*" ,
.BR "?" ,
.BR "[" ,
or
.B "]"
as part of file names because of the special meaning attached to these
characters by the shell
[see
.IR sh (1)].
Although permitted, the use of unprintable
characters in file names should be avoided.
.PP
A file name is sometimes referred to as a pathname component.  The
interpretation of a pathname component is dependent on the values of
\f4NAME_MAX\fP and \f4_POSIX_NO_TRUNC\fP associated with the path prefix of that
component.  If any pathname component is longer than \f4NAME_MAX\fP and
\f4_POSIX_NO_TRUNC\fP is in effect for the path prefix of that component
[see \f4fpathconf\fP(2) and \f4limits\fP(4)], it shall be considered an error condition in 
that implementation.  Otherwise, the implementation shall use the first
\f4NAME_MAX\fP bytes of the pathname component.
.SS
\f3Foreground Process Group\f1
Each session that has established a connection with a controlling terminal
will distinguish one process group of the session as the foreground process group
of the controlling terminal.  This group has certain privileges when accessing
its controlling terminal that are denied to background process groups.
.SS
\f3Message\f1
In a \f2stream\f1, one or more blocks of data or information, with associated \s-1STREAMS\s0 control structures.
\f2Messages\f1 can be of several defined types, which identify
the \f2message\f1 contents.
\f2Messages\f1 are the only means of transferring data and communicating within a \f2stream\f1.
.SS
\f3Message Queue\f1
In a \f2stream\f1, a linked list of \f2messages\f1 awaiting processing by
a \f2module\f1 or \f2driver\f1.
.SS
\f3Message Queue Identifier\f1
A message queue identifier (msqid) is a unique positive integer created by a
.IR msgget (2)
system call.
Each msqid has a message queue and a data structure associated with it.
The data structure is referred to as
.I msqid_ds
and contains the following members:
.PP
.RS
.ta 8n 28n
.nf
struct	ipc_perm msg_perm;
struct	msg *msg_first;
struct 	msg *msg_last;
ulong_t	msg_cbytes;
ulong_t	msg_qnum;
ulong_t	msg_qbytes;
pid_t	msg_lspid;
pid_t	msg_lrpid;
time_t	msg_stime;
time_t	msg_rtime;
time_t	msg_ctime;
.fi
.RE
.PP
.B msg_perm
is an ipc_perm structure that
specifies the message operation permission (see below).
This structure includes the following members:
.PP
.RS
.ta 8n 20n
.nf
uid_t	cuid;	/\(** creator user id \(**/
gid_t	cgid;	/\(** creator group id \(**/
uid_t	uid;	/\(** user id \(**/
gid_t	gid;	/\(** group id \(**/
mode_t	mode;	/\(** r/w permission \(**/
ulong_t	seq;	/\(** slot usage sequence # \(**/
key_t	key;	/\(** key \(**/
.PP
.fi
.RE
.TP
.B msg *msg_first
is a pointer to the first message on the queue.
.TP
.B msg *msg_last
is a pointer to the last message on the queue.
.TP
.B msg_cbytes
is the current number of bytes on the queue.
.TP
.B msg_qnum
is the number of messages currently on the queue.
.TP
.B msg_qbytes
is the maximum number of bytes allowed on the queue.
.TP
.B msg_lspid
is the process id of the last process that performed a
.IR msgsnd " operation."
.TP
.B msg_lrpid
is the process id of the last process that performed a
.IR msgrcv " operation."
.TP
.B msg_stime
is the time of the last
.I msgsnd
operation.
.TP
.B msg_rtime
is the time of the last
.I msgrcv
operation
.TP
.B msg_ctime
is the time of the last
.IR msgctl (2)
operation that changed a member of the above structure.
.SS
\f3Message Operation Permissions\f1
In the
.IR msgop "(2) and " msgctl (2)
system call descriptions, the permission required
for an operation is given as "{token}", where "token" is the type
of permission needed, interpreted as follows:
.PP
.RS 0.75i
.PD 0
.TP 1.50i
00400
Read by user
.TP
00200
Write by user
.TP
00040
Read by group
.TP
00020
Write by group
.TP
00004
Read by others
.TP
00002
Write by others
.RE
.PD
.PP
Read and write permissions on a msqid are
granted to a process if one or more of the following are true:
.IP
The effective user
.SM ID
of the process
is super-user.
.IP
The effective user
.SM ID
of the process
matches
.B msg_perm.cuid
or
.B msg_perm.uid
in the data structure associated with
.I msqid
and the appropriate bit of the
``user'' portion (0600) of
.B msg_perm.mode
is set.
.IP
The effective group
.SM ID
of the process
matches
.B msg_perm.cgid
or
.B msg_perm.gid
and the appropriate bit of the ``group'' portion
(060) of
.B msg_perm.mode
is set.
.IP
The appropriate bit of the ``other'' portion (006) of
.B msg_perm.mode
is set.
.PP
Otherwise, the corresponding permissions are denied.
.SS
\f3Module\f1
A module is an entity containing processing
routines for input and output data.
It always exists in the middle of a
\f2stream\f1, between the stream's head
and a \f2driver\f1.
A \f2module\f1 is the \s-1STREAMS\s0 counterpart to the commands
in a Shell pipeline except that a module contains a pair
of functions which allow independent bidirectional (\f2downstream\f1
and \f2upstream\f1) data flow and processing.
.SS
\f3Multiplexor\f1
A multiplexor is a driver that allows \f2streams\f1
associated with several user processes to be
connected to a single \f2driver\f1, or
several \f2drivers\f1 to be connected to a single
user process.
\s-1STREAMS\s0 does not provide a general multiplexing
\f2driver\f1, but does provide the facilities for
constructing them, and for connecting multiplexed
configurations of \f2streams\f1.
.SS
\f3Orphaned Process Group\f1
A process group in which the parent of every member in the group is
either itself a member of the group, or is not a member of the process
group's session.
In other words, there
is no process that can handle job control signals for the process group.
.SS
\f3Path Name and Path Prefix\f1
A path name is a null-terminated character string
starting with an optional slash
.RB ( / ),
followed by
zero or more directory names separated by slashes, optionally followed
by a file name.
The entire length of a path name is limited to
.SM
.I {PATH_MAX}
characters.
.PP
If a path name begins with a slash, the path search begins at the
.I root\^
directory.
Otherwise, the search begins from the current working directory.
.PP
A slash by itself names the root directory.
.PP
Unless specifically stated otherwise,
the null path name is treated as if it named
a non-existent file.
.SS
\f3Process \s-1ID\s+1\f1
Each active process in the system is uniquely identified by a
positive value called a process
.SM ID\*S.
This value is of the type pid_t.
.SS
\f3Parent Process \s-1ID\s+1\f1
A new process is created by a currently active
process [see
.IR fork (2)
and
.IR sproc (2)].
The parent process
.SM ID
of a process is the process
.SM ID
of its creator.
.SH
\f3Process Group\f1
Each process in the system is a member of a process group that is
identified by a process group \s-1ID\s+1.  Any process that is not a process
group leader may create a new process group and become its leader.
Any process that is not a process group leader may join an existing
process group that shares the same session as the process.  
Note that all members of a given process group are also members of
the same session, by definition.
A newly
created process joins the process group of its parent.
.LP
A terminal may have a particular process group associated with it,
which allows that group access to the terminal.
This process group can be set only to
process groups that are members of the terminal's session.
The process group currently associated with the terminal is referred to
as the
.B foreground
process group; all others are 
.B background
process groups.
.LP
A command interpreter, such as
.IR csh (1),
that supports \*(lqjob control\*(rq can allocate the terminal to different
.IR jobs ,
or process groups,
by placing related processes in a single process group and associating this
process group with the terminal.  A terminal's associated process group
may be set or examined by a process with sufficient privileges.
.SS
\f3Process Group Leader\f1
A process group leader is a process whose process
.SM ID
is the same as
its process group \s-1ID\s+1.
.SS
\f3Process Group \s-1ID\s+1\f1
Each active process is a member of a process group that is
identified by a positive value called the process group
.SM ID\*S.
This
.SM ID
is the process
.SM ID
of the group leader.
This grouping permits the signaling of related processes [see
.IR kill (2)].
.SS
\f3Process Lifetime\f1
A process lifetime begins when the process is forked and ends after it
exits, when its termination has been acknowledged by its parent process.
See \f4wait\fP(2).
.SS
\f3Process Group Lifetime\f1
A process group lifetime begins when the process group is created by its
process group leader, and ends when the lifetime of the last process in the 
group ends or when the last process in the group leaves the group by calling
.IR setpgid(2)
or
.IR setsid(2).
.SS
\f3Read Queue\f1
In a \f2stream\f1, the \f2message queue\f1 in a \f2module\f1 or \f2driver\f1 containing \f2messages\f1 moving \f2upstream\f1.
.SS
\f3Real User \s-1ID\s+1 and Real Group \s-1ID\s+1\f1
Each user allowed on the system is 
identified by a positive integer 0 to
.SM
.I {UID_MAX}
(2,147,483,647) called a real user
.SM ID\*S.
.PP
Each user is also a member of a group.
The group is identified by a positive integer called the real group
.SM ID\*S.
.PP
An active process has a real user
.SM ID
and real group
.SM ID
that are set to the real user
.SM ID
and real group
.SM ID\*S,
respectively, of the user responsible for the creation of the process.
.SS
\f3Root Directory and Current Working Directory\f1
Each process has associated with it a concept of a root directory and
a current working directory for the purpose of resolving path name searches.
The root directory of a process need not be the root directory of the root
file system.
.SS
\f3Saved User \s-1ID\s0 and Saved Group \s-1ID\s0\f1
The saved user
.SM ID
and saved
group
.SM ID
are the values of the 
effective user
.SM ID
and effective group
.SM ID
prior to an \f4exec\fP of a file [see \f4exec\fP(2)].
.SS
\f3Semaphore Identifier\f1
A semaphore identifier (semid) is a unique positive integer created by a
.IR semget (2)
system call.
Each semid has a set of semaphores and a data structure associated with it.
The data structure is referred to as
.I semid_ds
and contains the following members:
.PP
.RS
.ta 8n 28n
.nf
struct   ipc_perm sem_perm;	/\(** operation permission struct \(**/
struct   sem \(**sem_base;	/\(** ptr to first semaphore in set \(**/
ushort_t sem_nsems;	/\(** number of sems in set \(**/
time_t   sem_otime;	/\(** last operation time \(**/
time_t   sem_ctime;	/\(** last change time \(**/
		/\(** Times measured in secs since \(**/
		/\(** 00:00:00 \s-1GMT\s+1, Jan. 1, 1970 \(**/
.fi
.RE
.br
.ne 5
.PP
.B sem_perm
is an ipc_perm structure that
specifies the semaphore operation permission (see below).
This structure includes the following members:
.PP
.RS
.ta 8n 20n
.nf
uid_t	uid;	/\(** user id \(**/
gid_t	gid;	/\(** group id \(**/
uid_t	cuid;	/\(** creator user id \(**/
gid_t	cgid;	/\(** creator group id \(**/
mode_t	mode;	/\(** r/a permission \(**/
ulong_t	seq;	/\(** slot usage sequence number \(**/
key_t	key;	/\(** key \(**/
.PP
.fi
.RE
.TP
.B sem_nsems
is equal to the number of semaphores in the set.
Each semaphore in the set is referenced by a nonnegative integer
referred to as a
.IR sem_num .
Sem_num values run sequentially from 0 to the value of sem_nsems minus 1.
.TP
.B sem_otime
is the time of the last
.IR semop (2)
operation.
.TP
.B sem_ctime
is the time of the last
.IR semctl (2)
operation that changed a member of the above structure.
.PP
A semaphore is a data structure called \f2sem\f1
that contains the following members:
.PP
.RS
.ta 8n 20n
.nf
ushort_t  semval;	/\(** semaphore value \(**/
pid_t     sempid;	/\(** pid of last operation  \(**/
ushort_t  semncnt;	/\(** # awaiting semval > cval \(**/
ushort_t  semzcnt;	/\(** # awaiting semval = 0 \(**/
.fi
.RE
.TP
.B semval
is a non-negative integer which is the actual value of the semaphore.
.TP
.B sempid
is equal to the process
.SM ID
of the last process that performed a semaphore operation on this semaphore.
.TP
.B semncnt
is a count of the number of processes that are currently suspended
awaiting this semaphore's semval to become greater than its current value.
.TP
.B semzcnt
is a count of the number of processes that are currently suspended
awaiting this semaphore's semval to become zero.
.SS
\f3Semaphore Operation Permissions\f1
In the
.IR semop "(2) and " semctl (2)
system call descriptions, the permission required
for an operation is given as "{token}", where "token" is the type
of permission needed interpreted as follows:
.PP
.RS 0.75i
.PD 0
.TP 1.50i
00400
Read by user
.TP
00200
Alter by user
.TP
00040
Read by group
.TP
00020
Alter by group
.TP
00004
Read by others
.TP
00002
Alter by others
.RE
.PD
.PP
Read and alter permissions on a semid are
granted to a process if one or more of the following are true:
.IP
The effective user
.SM ID
of the process
is super-user.
.IP
The effective user
.SM ID
of the process
matches
.B sem_perm.cuid
or
.B sem_perm.uid
in the data structure associated with
.I semid
and the appropriate bit of the
``user'' portion (0600) of
.B sem_perm.mode
is set.
.IP
The effective group
.SM ID
of the process
matches
.B sem_perm.cgid
or
.B sem_perm.gid
and the appropriate bit of the ``group'' portion
(060) of
.B sem_perm.mode
is set.
.IP
The appropriate bit of the ``other'' portion (006) of
.B sem_perm.mode
is set.
.PP
Otherwise, the corresponding permissions are denied.
.SS
\f3Sessions\f1
A session is a group of processes identified by a common
.SM ID
called a session
\s-1ID\s+1, capable of establishing a connection with a controlling terminal.
Each session is associated with one \*(lqlogin\*(rq session (windows
count as logins). 
Any process that is not a process group leader may create a new session
and process group by calling
.IR setsid (2),
which will put the process in a new session as its only member
and as the session leader of that session.
A newly created process joins the session of its creator.
.SS
\f3Session Leader\f1
A session leader is a process whose session
.SM ID
is the same as its
process and process group \s-1ID\s+1.
.SS
\f3Session Lifetime\f1
A session lifetime begins when the session is created by its session
leader, and ends when the lifetime of the last process that is a member
of the session ends, or when the last process that is a member of the
session leaves the session by calling
.IR setsid(2).
.SS
\f3Shared Memory Identifier\f1
A shared memory identifier (shmid) is a unique positive integer created by a
.IR shmget (2)
system call.
Each shmid has a segment of memory (referred to as a shared memory segment)
and a data structure associated with it.
(Note that these shared memory segments 
must be explicitly removed by the user
after the last reference to them is removed.)
The data structure is referred to as
.I shmid_ds
and contains the following members:
.PP
.RS
.ta 8n 28n
.nf
struct	ipc_perm shm_perm;	/\(** operation permission struct \(**/
size_t	shm_segsz;	/\(** size of segment \(**/
pid_t	shm_lpid;	/\(** pid of last operation \(**/
pid_t	shm_cpid;	/\(** creator pid \(**/
shmatt_t shm_nattch;	/\(** number of current attaches \(**/
ulong_t	shm_cnattch;	/\(** used only for shminfo \(**/
time_t	shm_atime;	/\(** last attach time \(**/
time_t	shm_dtime;	/\(** last detach time \(**/
time_t	shm_ctime;	/\(** last change time \(**/
		/\(** Times measured in secs since \(**/
		/\(** 00:00:00 \s-1GMT\s+1, Jan. 1, 1970 \(**/
.fi
.RE
.PP
.B shm_perm
is an ipc_perm structure that
specifies the shared memory operation permission (see below).
This structure includes the following members:
.PP
.RS
.ta 8n 20n
.nf
uid_t	cuid;	/\(** creator user id \(**/
gid_t	cgid;	/\(** creator group id \(**/
uid_t	uid;	/\(** user id \(**/
gid_t	gid;	/\(** group id \(**/
mode_t	mode;	/\(** r/w permission \(**/
ulong_t	seq;	/\(** slot usage sequence # \(**/
key_t	key;	/\(** key \(**/
.PP
.fi
.RE
.TP
.B shm_segsz
specifies the size of the shared memory segment in bytes.
.TP
.B shm_cpid
is the process id of the process that created the shared memory identifier.
.TP
.B shm_lpid
is the process id of the last process that performed a
.IR shmop "(2) operation."
.TP
.B shm_nattch
is the number of processes that currently have this segment attached.
.TP
.B shm_atime
is the time of the last
\f2shmat\f1(2)
operation,
.TP
.B shm_dtime
is the time of the last
\f2shmdt\f1(2)
operation.
.TP
.B shm_ctime
is the time of the last
.IR shmctl (2)
operation that changed one of the members of the above structure.
.SS
\f3Shared Memory Operation Permissions\f1
In the
.IR shmop "(2) and " shmctl (2)
system call descriptions, the permission required
for an operation is given as "{token}", where "token" is the type
of permission needed interpreted as follows:
.PP
.RS 0.75i
.PD 0
.TP 1.50i
00400
Read by user
.TP
00200
Write by user
.TP
00040
Read by group
.TP
00020
Write by group
.TP
00004
Read by others
.TP
00002
Write by others
.RE
.PD
.PP
Read and write permissions on a shmid are
granted to a process if one or more of the following are true:
.IP
The effective user
.SM ID
of the process
is super-user.
.IP
The effective user
.SM ID
of the process
matches
.B shm_perm.cuid
or
.B shm_perm.uid
in the data structure associated with
.I shmid
and the appropriate bit of the
``user'' portion (0600) of
.B shm_perm.mode
is set.
.IP
The effective group
.SM ID
of the process
matches
.B shm_perm.cgid
or
.B shm_perm.gid
and the appropriate bit of the ``group'' portion
(060) of
.B shm_perm.mode
is set.
.IP
The appropriate bit of the ``other'' portion (06) of
.B shm_perm.mode
is set.
.PP
Otherwise, the corresponding permissions are denied.
.SS
\f3Special Processes\f1
The processes with a process
.SM ID
of 0 and a process
.SM ID
of 1 are special processes and are referred to as
.IR proc0 " and " proc1.
.PP
.I Proc0\^
is the scheduler.
.I Proc1\^
is the initialization process 
.RI ( init ).
Proc1 is the ancestor of every other
process in the system and is used to control the process structure.
.SH
\f3\s-1STREAMS\s0\f1
A set of kernel mechanisms that support the development of
network services and data communication \f2driver\f1s.
It defines interface standards for character input/output
within the kernel and between the kernel and user level processes.
The \s-1STREAMS\s0 mechanism is composed of utility routines,
kernel facilities and a set of data structures.
.SH
\f3Stream\f1
A stream is a full-duplex data path within the kernel 
between a user process and driver routines.
The primary components are a \f2stream head\f1,
a \f2driver\f1 and zero or more \f2modules\f1
between the \f2stream head\f1 and \f2driver\f1.
A \f2stream\f1 is analogous to a Shell pipeline except that data flow and processing are bidirectional.
.SH
\f3Stream Head\f1
In a \f2stream\f1, the \f2stream head\f1 is the end of the \f2stream\f1
that provides
the interface between the \f2stream\f1 and a user process.
The principle functions of the \f2stream head\f1 are processing
\s-1STREAMS\s0-related system calls,
and passing data and information between a user
process and the \f2stream\f1.
.SS
\f3Supplementary Group ID\f1
A process has up to
.SM
.I {NGROUPS_MAX}
supplementary group IDs used in determining file access permissions,
in addition to the effective group ID.
The supplementary group IDs of a process are set to the
supplementary group IDs of the parent process when the process is created.
.SS
\f3Super-user\f1
A process is recognized as a
.I super-user\^
process and is granted special privileges, such as immunity from
file permissions, if its effective user
.SM ID
is 0.
.SS
\f3Upstream\f1
In a \f2stream\f1, the direction from \f2driver\f1 to \f2stream head\f1.
.SS
\f3Write Queue\f1
In a \f2stream\f1, the \f2message queue\f1 in a \f2module\f1 or \f2driver\f1 containing \f2messages\f1 moving \f2downstream\f1.
.SH LIMITS
The various limits can be categorized as follows:
not modifiable, modifiable at sysgen time and modifiable at runtime.
Most limits are controlled by variables
that can be changed by editing the file
.IR "/var/sysgen/stune"
or using the \f4systune\fP(1M) command.
All the tunable parameters and their ranges are located in the
directory
.IR "/var/sysgen/mtune" .
Files in this directory should not be modified.
Limits may apply system wide or
per process.
Most per process limits are inherited on
.IR fork ,
.IR sproc ,
and
.IR exec .
Some per process limits are managed via the \f4setrlimit\fP(2)
resource management call.
These resource limits have two values associated with them - a current
and a maximum.
A non-privileged process may change its current value as long as
its less than the maximum.
It may also lower its maximum, but once it does so, it may not raise it
again.
A privileged process may raise or lower both its current and
maximum values.
Resource limits may be queried programmatically via \f4getrlimit\fP(2)
and via the shell
.I limit
or
.I ulimit
built-in command.
They may also be set either programmatically or via the shell.
The initial values (those given to process 1, and via inheritance to
all other processes) may be set at sysgen time.
.SH
.SM
.I {NPROC}
is the maximum number of processes allowed to run concurrently
on the system.
It is modifiable at sysgen time by setting the variable
.I nproc
within the range defined in
.IR "/var/sysgen/mtune/kernel" .
The current number in use and the current configured number
may be retrieved via the
.I "sar -v"
command.
.SH
.I {NFILE_MAX}
is the maximum number of open files that can be simultaneously active
system wide.
This is limited only by the amount of memory in the system.
The current number in use and the maximum number that has ever been
allocated may be retrieved via the
.I "sar -v"
command.
.SH
.SM
.I {FLOCK_MAX}
is the maximum number of file locks system wide that may be active.
This is limited only by the amount of memory in the system.
The current number in use and the maximum number that has ever been
allocated may be retrieved via the
.I "sar -v"
command.
.SH
.SM
.I {NAME_MAX}
is the maximum length of a file name.
It is defined in
.I limits.h
and is not modifiable.
.SH
.SM
.I {PATH_MAX}
is the maximum length of a path name.
It is defined in
.I limits.h
and is not modifiable.
.SH
.SM
.I {LINK_MAX}
is the maximum number of hard links that may be made to a given file.
It is defined in
.I limits.h
and is not modifiable.
.SH
.SM
.I {OPEN_MAX}
is the maximum number of open files a given process may have.
The minimum value this can have is defined in
.IR "limits.h" .
It is the resource limit \f4RLIMIT_NOFILE\fP defined in \f4setrlimit\fP (2).
The initial current and maximum limits may be changed by setting
the variables
.I rlimit_nofile_cur
and
.I rlimit_nofile_max
within the range defined in
.IR "/var/sysgen/mtune/kernel" .
The current number of open files configured may be obtained programmatically
via
.IR getrlimit (2),
.IR getdtablesize (2),
.IR sysconf (2),
or
.IR ulimit (2);
and may be obtained from the shell by either the
.I limit
or
.I ulimit
built-in command.
.SH
.SM
.I {CHILD_MAX}
is the maximum number of processes a given user may have running simultaneously.
The minimum value this can have is defined in
.IR "limits.h" .
It is modifiable at runtime by setting the variable
.I maxup
within the range defined in
.IR "/var/sysgen/mtune/kernel" .
The current configured maximum may be obtained from
.IR sysconf (2).
.SH
.SM
.I {SHLIB_MAX}
is the maximum number of shared libraries a program can link with.
It is modifiable at runtime by setting the variable
.I shlbmax
within the range defined in
.IR "/var/sysgen/mtune/kernel" .
.SH
.SM
.I {ARG_MAX}
is the maximum number of bytes that may be passed via
.IR exec .
The minimum value this can have is defined in
.IR "limits.h" .
It is modifiable at runtime by setting the variable
.I ncargs
within the range defined in
.IR "/var/sysgen/mtune/kernel" .
The current configured maximum may be obtained from
.IR sysconf (2).
.SH
.SM
.I {FILESIZE_MAX}
is the maximum size in bytes that a single file can grow to.
It is the resource limit \f4RLIMIT_FSIZE\fP defined in \f4setrlimit\fP (2).
The initial current and maximum limits may be changed by setting
the variables
.I rlimit_fsize_cur
and
.I rlimit_fsize_max
within the range defined in
.IR "/var/sysgen/mtune/kernel" .
.SH
.SM
.I {PROCSIZE_MAX}
is the maximum virtual size a process can grow to.
A process is made up an arbitrary number of virtual spaces.
There are limits on the total size of process as well as certain limits
on individual spaces.
The overall limit is defined by the
resource limit \f4RLIMIT_VMEM\fP.
The initial current and maximum limits may be changed by setting
the variables
.I rlimit_vmem_cur
and
.I rlimit_vmem_max
within the range defined in
.IR "/var/sysgen/mtune/kernel" .
The maximum stack size is defined by the
resource limit \f4RLIMIT_STACK\fP.
The initial current and maximum limits may be changed by setting
the variables
.I rlimit_stack_cur
and
.I rlimit_stack_max
within the range defined in
.IR "/var/sysgen/mtune/kernel" .
The maximum data size is defined by the
resource limit \f4RLIMIT_DATA\fP.
The initial current and maximum limits may be changed by setting
the variables
.I rlimit_data_cur
and
.I rlimit_data_max
within the range defined in
.IR "/var/sysgen/mtune/kernel" .
The maximum size of a shared memory segment is modifiable
at sysgen time by setting the variable
.I shmmax
within the range defined in
.IR "/var/sysgen/mtune/shm" .
.SH
.I {SHMSEG_MAX}
is the maximum number of shared memory segments system wide.
It is modifiable at sysgen time by setting the variable
.I shmmni
within the range defined in
.IR "/var/sysgen/mtune/shm" .
.SH
.I {SHMAT_MAX}
is the maximum number of shared memory segments a given process may attach to.
It is modifiable at sysgen time by setting the variable
.I sshmseg
within the range defined in
.IR "/var/sysgen/mtune/shm" .
.SH
.I {SYMLINK_MAX}
is the maximum number of symbolic links a given path name traversal
will follow before assuming there is a loop.
It is modifiable at runtime by setting the variable
.I maxsymlinks
within the range defined in
.IR "/var/sysgen/mtune/kernel" .
.SH
.I {PLOCK_MAX}
is the maximum number of pages a non-privileged process is allowed to lock
at any one time.
It is modifiable at runtime by setting the variable
.I maxlkmem
within the range defined in
.IR "/var/sysgen/mtune/kernel" .
.SH
.I {PROFIL_MAX}
is the maximum number of \f2prof\fP structures that can be passed as an
argument to the 
.B sprofil
(2) system call.
It is modifiable at sysgen time by setting the variable
.I nprofile
within the range defined in
.IR "/var/sysgen/mtune/kernel" .
.SH
.I {IOV_MAX}
is the maximum number of \f2iovec\fP structures that can be passed to
\f4readv\fP or \f4writev\fP.
Currently, its value is 16.
.SH INTERRUPTIBILITY
Certain system calls can be interrupted by the process
receiving a signal.
These include but are not limited to
.IR fcntl (2),
.IR open (2),
.IR read (2),
.IR write (2),
and
.IR ioctl (2).
The conditions under which a given system call can be interrupted
are listed on each manual page.
In addition, any file system oriented system call can either
time out (
.SM ETIMEDOUT
or be interrupted
.SM EINTR
) if the object of the system call is located on a remote system accessed
via
.SM NFS.
Whether these system calls can time out or be interrupted is based
on how the underlying file system was mounted on the local machine [see
.IR fstab (4)
and
.IR mount (1M)].
.PP
All system calls can be automatically restarted upon receipt of
a signal.
Whether a system call should be restarted is configurable
on a per signal basis (see \f4sigaction\fP(2)).
.SH SEE ALSO
sar(1), lboot(1M), mount(1M),
getrlimit(2), pathconf(2), sysconf(2), ulimit(2),
intro(3), perror(3),
fstab(4).
.Ee
