/* vxsys.c - program to make a boot diskette */

/*
modification history
--------------------
01g,24jan95,jdi	 doc cleanup.
01f,25oct94,hdn	 added fdRawio() instead of using raw file system.
		 swapped 1st and 2nd parameter of vxsys().
01e,28may94,hdn	 updated the boot sector to DOS version.
01d,27jan94,hdn	 changed the entry point 0x10000 to 0x8000.
01c,16nov93,hdn	 changed name of the boot image "bootrom.dat" to "bootrom.sys".
01b,07nov93,hdn	 adopted Dave Fraser's idea.
01a,12oct93,hdn	 written
*/

/*
DESCRIPTION
This library creates a boot diskette.  This program currently supports
only floppy disks.  To support the IDE drive, another bootStrap[] would
be required.

NOMANUAL
*/

#include "vxworks.h"
#include "a_out.h"
#include "errnolib.h"
#include "iolib.h"
#include "stdio.h"
#include "string.h"
#include "usrlib.h"
#include "dosfslib.h"
#include "drv/fdisk/nec765fd.h"


#define VXCOPY_DOSDEV	"/vxsysdos/"
#define VXCOPY_FILE	"/vxsysdos/bootrom.sys"

/* global */

int vxsysDebug = 0;


/* local */

LOCAL BOOL vxsysBootsec = TRUE;
LOCAL BOOL vxsysBootrom = TRUE;

LOCAL char bootStrap[] =
    {
    0x8C, 0xC8,
    0x8E, 0xD8, 0x8E, 0xC0, 0xFC, 0xFA, 0x8E, 0xD0,	/* 0x040 */
    0xBC, 0xFE, 0x7B, 0xFB, 0xBE, 0xD4, 0x7D, 0xE8,
    0xEB, 0x00, 0x33, 0xDB, 0x8B, 0xC3, 0xA0, 0x10,	/* 0x050 */
    0x7C, 0xF7, 0x26, 0x16, 0x7C, 0x8B, 0x0E, 0x0E,
    0x7C, 0x03, 0x0E, 0x1C, 0x7C, 0x13, 0x16, 0x1E,	/* 0x060 */
    0x7C, 0x89, 0x0E, 0x03, 0x7B, 0x89, 0x16, 0x05,
    0x7B, 0x03, 0xC8, 0x13, 0xD3, 0x89, 0x0E, 0x07,	/* 0x070 */
    0x7B, 0x89, 0x16, 0x09, 0x7B, 0x89, 0x0E, 0x0B,
    0x7B, 0x89, 0x16, 0x0D, 0x7B, 0x52, 0xB8, 0x20,	/* 0x080 */
    0x00, 0xF7, 0x26, 0x11, 0x7C, 0x8B, 0x36, 0x0B,
    0x7C, 0x03, 0xC6, 0x48, 0xF7, 0xF6, 0x01, 0x06,	/* 0x090 */
    0x0B, 0x7B, 0x11, 0x1E, 0x0D, 0x7B, 0xA3, 0x0F,
    0x7B, 0x91, 0x5A, 0xBB, 0x00, 0x7E, 0xE8, 0xAE,	/* 0x0a0 */
    0x00, 0x73, 0x03, 0xE9, 0x83, 0x00, 0xBE, 0xEC,
    0x7D, 0xFC, 0x8B, 0x0E, 0x11, 0x7C, 0xBF, 0x00,	/* 0x0b0 */
    0x7E, 0x51, 0x56, 0x57, 0xB9, 0x0B, 0x00, 0xF3,
    0xA6, 0x5F, 0x5E, 0x59, 0x74, 0x0A, 0x83, 0xC7,	/* 0x0c0 */
    0x20, 0xE2, 0xEE, 0xBE, 0xE9, 0x7D, 0xEB, 0x64,
    0x8B, 0x45, 0x1C, 0x8B, 0x55, 0x1E, 0xF7, 0x36,	/* 0x0d0 */
    0x0B, 0x7C, 0xD1, 0xE8, 0xD1, 0xE8, 0x40, 0xA3,
    0x11, 0x7B, 0xA1, 0x0B, 0x7C, 0xD1, 0xE8, 0xD1,	/* 0x0e0 */
    0xE8, 0xA3, 0x13, 0x7B, 0x8B, 0x45, 0x1A, 0x48,
    0x48, 0x33, 0xC9, 0x8A, 0x0E, 0x0D, 0x7C, 0xF7,	/* 0x0f0 */
    0xE1, 0x03, 0x06, 0x0B, 0x7B, 0x13, 0x16, 0x0D,
    0x7B, 0xBB, 0x00, 0x08, 0x8E, 0xC3, 0x33, 0xDB,	/* 0x100 */
    0xB1, 0x04, 0x50, 0x52, 0xE8, 0x48, 0x00, 0x5A,
    0x58, 0x72, 0x1E, 0xBE, 0xF8, 0x7D, 0xE8, 0x24,	/* 0x110 */
    0x00, 0xFF, 0x0E, 0x11, 0x7B, 0x74, 0x0E, 0x83,
    0xC0, 0x04, 0x83, 0xD2, 0x00, 0x8C, 0xC3, 0x03,	/* 0x120 */
    0x1E, 0x13, 0x7B, 0xEB, 0xD7, 0xFF, 0x2E, 0x39,
    0x7D, 0xBE, 0xDE, 0x7D, 0xE8, 0x06, 0x00, 0xEB,	/* 0x130 */
    0xFE, 0x00, 0x00, 0x00, 0x08, 0x53, 0x50, 0x80,
    0x3E, 0xD3, 0x7D, 0x00, 0x75, 0x0E, 0xAC, 0x0A,	/* 0x140 */
    0xC0, 0x74, 0x09, 0xB4, 0x0E, 0xBB, 0x07, 0x00,
    0xCD, 0x10, 0xEB, 0xF2, 0x58, 0x5B, 0xC3, 0xB5,	/* 0x150 */
    0x02, 0x57, 0x88, 0x0E, 0x00, 0x7B, 0x8B, 0xF0,
    0x8B, 0xFA, 0x89, 0x1E, 0x01, 0x7B, 0x8B, 0xC6,	/* 0x160 */
    0x8B, 0xD7, 0x8B, 0x1E, 0x18, 0x7C, 0xF7, 0xF3,
    0x42, 0x43, 0x52, 0x02, 0xD1, 0x3B, 0xD3, 0x5A,	/* 0x170 */
    0x76, 0x04, 0xFE, 0xC9, 0xEB, 0xF4, 0x8B, 0xDA,
    0x51, 0x99, 0xF7, 0x36, 0x1A, 0x7C, 0x86, 0xE0,	/* 0x180 */
    0xB1, 0x06, 0xD2, 0xE0, 0x91, 0x0A, 0xCB, 0x8A,
    0xF2, 0x58, 0xB7, 0x05, 0x53, 0x50, 0x8B, 0x1E,	/* 0x190 */
    0x01, 0x7B, 0x8A, 0x16, 0xD2, 0x7D, 0x50, 0xCD,
    0x13, 0x58, 0x32, 0xE4, 0x72, 0x1F, 0x59, 0x5B,	/* 0x1a0 */
    0x03, 0xF0, 0x83, 0xD7, 0x00, 0x28, 0x06, 0x00,
    0x7B, 0xF7, 0x26, 0x0B, 0x7C, 0x01, 0x06, 0x01,	/* 0x1b0 */
    0x7B, 0x8A, 0x0E, 0x00, 0x7B, 0x80, 0xF9, 0x00,
    0x77, 0xA4, 0xF8, 0x5F, 0xC3, 0x33, 0xC0, 0xCD,	/* 0x1c0 */
    0x13, 0x58, 0x5B, 0xFE, 0xCF, 0x75, 0xC5, 0xF9,
    0xEB, 0xF1, 0x00, 0x00, 0x56, 0x78, 0x4C, 0x64,	/* 0x1d0 */
    0x20, 0x31, 0x2E, 0x32, 0x20, 0x00, 0x52, 0x65,
    0x61, 0x64, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72,	/* 0x1e0 */
    0x00, 0x4E, 0x6F, 0x20, 0x42, 0x4F, 0x4F, 0x54,
    0x52, 0x4F, 0x4D, 0x20, 0x53, 0x59, 0x53, 0x00,	/* 0x1f0 */
    0x2E, 0x00, 0x00, 0x00, 0x00, 0xDF, 0x55, 0xAA
    };


/*******************************************************************************
*
* vxsys - create a boot diskette from a specified file
*
* This command changes a boot sector and copies the text and data of 
* a specified file to the output device.
*
* EXAMPLES:
* The following example makes a conventional copy from the file named
* `bootrom_uncmp' to the floppy drive 0, which contains a diskette of type 0.
* .CS
*     -> vxsys 0, 0, "bootrom_uncmp"
* .CE
*
* RETURNS:
* OK, or
* ERROR if <in> or <out> cannot be opened/created, or if there is an
* error copying from <in> to <out>.
*
*/

int vxsys 
    (
    int drive,			/* drive number (0 - 3)	*/
    int fdType,			/* type of floppy disk	*/
    char *in			/* name of file to read	*/
    )
    {
    BLK_DEV *pBlkDev;
    int inFd;
    int outFd;
    int ix;
    int bytes;
    struct exec hdr;
    char buffer[4096];
    char *pTail;
    FD_RAW fdRaw;


    if ((UINT)drive > FD_MAX_DRIVES)
	{
	printErr ("drive is out of range (0-%d).\n", FD_MAX_DRIVES - 1);
	return (ERROR);
	}


    if (vxsysBootsec)
	{
        /* read the boot sector */

        fdRaw.cylinder   = 0;
        fdRaw.head       = 0;
        fdRaw.sector     = 1;
        fdRaw.pBuf       = buffer;
        fdRaw.nSecs      = 1;
        fdRaw.direction  = 0;
        (void) fdRawio (drive, fdType, &fdRaw);

        /* modify the boot sector */

	buffer[0] = 0xeb;
	buffer[1] = 0x3c;
	buffer[2] = 0x90;
        bcopy (bootStrap, (char *)&buffer[0x3e], sizeof (bootStrap));
    
        /* write the boot sector */

        fdRaw.direction  = 1;
        (void) fdRawio (drive, fdType, &fdRaw);
	}


    if (vxsysBootrom)
	{
        /* read the header to get a text-size and a data-size */

        if ((inFd = open (in, O_RDONLY, 0644)) == ERROR)
            {
            printErr ("Can't open \"%s\"\n", in);
	    return (ERROR);
	    }

        if ((read (inFd, (char *)&hdr, sizeof(hdr))) == ERROR)
	    {
	    printErr ("Error during read header: %x\n", errnoGet ());
	    return (ERROR);
	    }

        if (vxsysDebug)
            printErr ("text=0x%x data=0x%x\n", hdr.a_text, hdr.a_data);

        bytes = hdr.a_text + hdr.a_data;

        /* create a DOS file system */

        if ((pBlkDev = fdDevCreate (drive, fdType, 0, 0)) == NULL)
	    {
	    printErr ("Error during fdDevCreate: %x\n", errnoGet ());
	    return (ERROR);
	    }

        if ((dosFsDevInit (VXCOPY_DOSDEV, pBlkDev, NULL)) == NULL)
	    {
	    printErr ("Error during dosFsDevInit: %x\n", errnoGet ());
	    return (ERROR);
	    }

        if ((outFd = open (VXCOPY_FILE, O_CREAT | O_RDWR, 0644)) == ERROR)
	    {
            close (inFd);
            printErr ("Can't open \"%s\"\n", VXCOPY_FILE);
	    return (ERROR);
	    }

        if (ioctl (outFd, FIOCONTIG, bytes) == ERROR)
	    {
	    printErr ("Error during ioctl FIOCONTIG: %x\n", errnoGet ());
	    return (ERROR);
	    }

        /* read text and data, write them to the diskette */

        for (ix = 0; ix < bytes; ix += sizeof(buffer))
	    {
	    if (read (inFd, buffer, sizeof(buffer)) == ERROR)
	        {
	        printErr ("Error during read file: %x\n", errnoGet ());
	        return (ERROR);
	        }

	    if (write (outFd, buffer, sizeof(buffer)) == ERROR)
	        {
	        printErr ("Error during write fd: %x\n", errnoGet ());
	        return (ERROR);
	        }
	    }

        close (inFd);
        close (outFd);
        iosDevDelete (iosDevFind (VXCOPY_DOSDEV, &pTail));
        }

    return (OK);
    }

