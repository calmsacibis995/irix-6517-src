/* Dallas 1286 [1386 on Indy] clock tests.
 */

#include "sys/types.h"
#include "sys/cpu.h"
#include "sys/sbd.h"
#include "sys/i8254clock.h"
#include "sys/ds1286.h"
#include "libsk.h"
#include "uif.h"

#ident "$Revision: 1.7 $"

#define	CLOCK_COUNTER		10
#define	POWER_FAIL_DELAY_ENABLE	(0x02)
#define POWER_FAIL_INT_ENABLE	(0x80)
#define	TIMESAVE_COUNTER	5
#define COUNTER2_VAL		1000	/* counter2 output = 1 kHz */
#define COUNTER1_VAL		2000	/* counter1 output = 2 sec */
#define CAUSE_COUNTER1		CAUSE_IP6

/*
 *  Tests the accuracy of the DS1286/DS1386 real time clock by comparing the
 * elapsed time generated by the clock with the time generated by the 
 * i8254 counter/timer on INT2.
 */
int
rt_clock(void)
{
    int	counter;
    static char	*counter_name[CLOCK_COUNTER] = {
	"Ten milliseconds",
	"Second",
	"Minute",
	"Hour",
	"Day of month",
	"Month",
	"Year",
	0, 		/* don't care */
	0, 		/* don't care */
	"Day of week"
    };
    unsigned int	current_time[CLOCK_COUNTER];
    static unsigned char	expected_time[CLOCK_COUNTER] = {
	0x50,
	0x01,
	0x00,
	0x00,
	0x01,
	0x01,
	0x00,
	0x01, 	/* don't care */
	0x00, 	/* don't care */
	0x01
    };
    static unsigned char	initial_time[CLOCK_COUNTER] = {
	0x50,
	0x59,
	0x59,
	0x23,
	0x31,
	0x12,
	0x99,
	0x66, 	/* don't care */
	0x03, 	/* don't care */
	0x07
    };
    int errcount = 0;
    volatile struct ds1286_clk *rt_clock = 
	(struct ds1286_clk *)RT_CLOCK_ADDR;
    volatile struct pt_clock *pt = (struct pt_clock *)PT_CLOCK_ADDR;

    msg_printf (VRB, "Time of day clock test\n");

    if (is_ioc1 ()) {
	/* printf ("Clock broken; test disabled.\n"); */
	return (errcount);
    }


    /* freeze external time of the day registers for reading */
    rt_clock->command &= ~WTR_TE;

    /* save current time
     */
    current_time[0]= rt_clock->hundreth_sec;
    current_time[1]= (char)rt_clock->sec;
    current_time[2]= (char)rt_clock->min;
    current_time[3]= (char)rt_clock->hour & 0x1f;
    current_time[4]= (char)rt_clock->date & 0x3f;
    current_time[5]= (char)rt_clock->month & 0x1f;
    current_time[6]= (char)rt_clock->year;
    current_time[9]= (char)rt_clock->day;

    /* set up clock counters and clear timesave ram
     */
    rt_clock->hundreth_sec = initial_time[0];
    rt_clock->sec = initial_time[1];
    rt_clock->min = initial_time[2];
    rt_clock->hour = initial_time[3];
    rt_clock->date = initial_time[4];
    rt_clock->month = initial_time[5];
    rt_clock->year = initial_time[6];
    rt_clock->day = initial_time[9];

    /* start clock */
    rt_clock->command |= WTR_TE;

    /* start counter/timer ticking
     */
    *(volatile char *)TIMER_ACK_ADDR = ACK_TIMER0 | ACK_TIMER1; wbflush();
    pt->pt_control = PTCW_SC(2)|PTCW_16B|PTCW_MODE(MODE_RG); 	wbflush();
    pt->pt_counter2 = COUNTER2_VAL & 0xff; 			wbflush();
    pt->pt_counter2 = (COUNTER2_VAL >> 8) & 0xff; 		wbflush();
    pt->pt_control = PTCW_SC(1)|PTCW_16B|PTCW_MODE(MODE_RG); 	wbflush();
    pt->pt_counter1 = COUNTER1_VAL & 0xff; 			wbflush();
    pt->pt_counter1 = (COUNTER1_VAL >> 8) & 0xff; 		wbflush();

    /* wait for counter/timer to expire
     */
    *(volatile char *)TIMER_ACK_ADDR = ACK_TIMER0 | ACK_TIMER1; wbflush();
    while (1) 
	if (get_cause() & CAUSE_COUNTER1)
	    break;
   
    rt_clock->command &= ~WTR_TE;

    /* clean up counter/timer regs
     */
    pt->pt_control = PTCW_SC(0)|PTCW_16B|PTCW_MODE(MODE_STS); 	wbflush();
    pt->pt_control = PTCW_SC(1)|PTCW_16B|PTCW_MODE(MODE_STS); 	wbflush();
    *(volatile char *)TIMER_ACK_ADDR = ACK_TIMER0 | ACK_TIMER1;

    /* verify clock counters, all counters must match exactly
     */
    for (counter = 0; counter < CLOCK_COUNTER; counter++)
	if (counter_name[counter])
	        switch (counter) {
        	case 0:
	    		if ((rt_clock->hundreth_sec & 0xff) != 
	        		expected_time[counter]) {
				++errcount;
				msg_printf (ERR,\
		    		"%s clock counter, Expected: 0x%02x, \
				Actual: 0x%02x\n",counter_name[counter], \
				expected_time[counter],\
				rt_clock->hundreth_sec & 0xff);
	    		}   /* if */
                	break;
        	case 1:
	    		if ((rt_clock->sec & 0xff) != 
	        		expected_time[counter]) {
				++errcount;
				msg_printf (ERR,\
		    		"%s clock counter, Expected: 0x%02x, \
				Actual: 0x%02x\n",counter_name[counter], \
				expected_time[counter],\
				rt_clock->sec & 0xff);
	    		}   /* if */
                	break;
        	case 2:
	    		if ((rt_clock->min & 0xff) != 
	        		expected_time[counter]) {
				++errcount;
				msg_printf (ERR,\
		    		"%s clock counter, Expected: 0x%02x, \
				Actual: 0x%02x\n",counter_name[counter], \
				expected_time[counter],\
				rt_clock->min & 0xff);
	    		}   /* if */
                	break;
        	case 3:
	    		if ((rt_clock->hour & 0xff) != 
	        		expected_time[counter]) {
				++errcount;
				msg_printf (ERR,\
		    		"%s clock counter, Expected: 0x%02x, \
				Actual: 0x%02x\n",counter_name[counter], \
				expected_time[counter],\
				rt_clock->hour & 0xff);
	    		}   /* if */
                	break;
        	case 4:
	    		if ((rt_clock->date & 0xff) != 
	        		expected_time[counter]) {
				++errcount;
				msg_printf (ERR,\
		    		"%s clock counter, Expected: 0x%02x, \
				Actual: 0x%02x\n",counter_name[counter], \
				expected_time[counter],\
				rt_clock->date & 0xff);
	    		}   /* if */
                	break;
        	case 5:
	    		if ((rt_clock->month & 0xff) != 
	        		expected_time[counter]) {
				++errcount;
				msg_printf (ERR,\
		    		"%s clock counter, Expected: 0x%02x, \
				Actual: 0x%02x\n",counter_name[counter], \
				expected_time[counter],\
				rt_clock->month & 0xff);
	    		}   /* if */
                	break;
        	case 6:
	    		if ((rt_clock->year & 0xff) != 
	        		expected_time[counter]) {
				++errcount;
				msg_printf (ERR,\
		    		"%s clock counter, Expected: 0x%02x, \
				Actual: 0x%02x\n",counter_name[counter], \
				expected_time[counter],\
				rt_clock->year & 0xff);
	    		}   /* if */
                	break;
        	case 9:
	    		if ((rt_clock->day & 0xff) != 
	        		expected_time[counter]) {
				++errcount;
				msg_printf (ERR,\
		    		"%s clock counter, Expected: 0x%02x, \
				Actual: 0x%02x\n",counter_name[counter], \
				expected_time[counter],\
				rt_clock->day & 0xff);
	    		}   /* if */
                	break;
        	}

    /* restart the clock. the time will be ~3 seconds behind
     */
    rt_clock->hundreth_sec = current_time[0];
    rt_clock->sec = current_time[1];
    rt_clock->min = current_time[2];
    rt_clock->hour = current_time[3];
    rt_clock->date = current_time[4];
    rt_clock->month = current_time[5];
    rt_clock->year = current_time[6];
    rt_clock->day = current_time[9];

    /* unfreeze external time of the day registers */
    rt_clock->command |= WTR_TE;

    if (errcount != 0)
	sum_error ("time of day clock");
    else
	okydoky ();

    return (errcount);
}
