		****   DISASSEMBLER  ****


disassembly for IP25.O/ip25prom-1MB-4-2-1_9

section	.text
Skipping source listing to line 23 of /cores/banyan/stand/arcs/IP25prom/vector.s...
   24:  * The power-on vector table starts here.  It is important to ensure
   25:  * that this file is loaded at 0x900000001fc00000 so that the vectors
   26:  * appear in the memory locations expected by the R10000.
   27:  */
   28: 
   29: #define	HANDLER(_handler)	j	_handler; nop
   30: #define	INVALID()		HANDLER(notimplemented)
   31: 
   32: LEAF(start)
   33: 	HANDLER(entry);			HANDLER(bevRestartMaster);
start:
[  33] 0x900000001fc00000:  0b f0 01 10 j		entry
[  33] 0x900000001fc00004:  00 00 00 00 nop
[  33] 0x900000001fc00008:  0b f0 01 f6 j		bevRestartMaster
[  33] 0x900000001fc0000c:  00 00 00 00 nop
   34: 	HANDLER(bevRestartSlave);	HANDLER(bevPodMode)
[  34] 0x900000001fc00010:  0b f0 02 39 j		bevRestartSlave
[  34] 0x900000001fc00014:  00 00 00 00 nop
[  34] 0x900000001fc00018:  0b f0 02 49 j		bevPodMode
[  34] 0x900000001fc0001c:  00 00 00 00 nop
   35: 	HANDLER(bevRestartMasterEPC);	HANDLER(bevFlashLeds)
[  35] 0x900000001fc00020:  0b f0 02 41 j		bevRestartMasterEPC
[  35] 0x900000001fc00024:  00 00 00 00 nop
[  35] 0x900000001fc00028:  0b f0 04 32 j		bevFlashLeds
[  35] 0x900000001fc0002c:  00 00 00 00 nop
   36: 	HANDLER(bevRePod);		HANDLER(bevIP25monExit);
[  36] 0x900000001fc00030:  0b f0 05 06 j		bevRePod
[  36] 0x900000001fc00034:  00 00 00 00 nop
[  36] 0x900000001fc00038:  0b f0 05 2a j		bevIP25monExit
[  36] 0x900000001fc0003c:  00 00 00 00 nop
   37: 	INVALID();			INVALID(); /* 0x40 */
[  37] 0x900000001fc00040:  0b f0 04 e2 j		notimplemented
[  37] 0x900000001fc00044:  00 00 00 00 nop
[  37] 0x900000001fc00048:  0b f0 04 e2 j		notimplemented
[  37] 0x900000001fc0004c:  00 00 00 00 nop
   38:         INVALID();			INVALID();	
[  38] 0x900000001fc00050:  0b f0 04 e2 j		notimplemented
[  38] 0x900000001fc00054:  00 00 00 00 nop
[  38] 0x900000001fc00058:  0b f0 04 e2 j		notimplemented
[  38] 0x900000001fc0005c:  00 00 00 00 nop
   39: 	INVALID();			INVALID();
[  39] 0x900000001fc00060:  0b f0 04 e2 j		notimplemented
[  39] 0x900000001fc00064:  00 00 00 00 nop
[  39] 0x900000001fc00068:  0b f0 04 e2 j		notimplemented
[  39] 0x900000001fc0006c:  00 00 00 00 nop
   40:         INVALID();			INVALID();	
[  40] 0x900000001fc00070:  0b f0 04 e2 j		notimplemented
[  40] 0x900000001fc00074:  00 00 00 00 nop
[  40] 0x900000001fc00078:  0b f0 04 e2 j		notimplemented
[  40] 0x900000001fc0007c:  00 00 00 00 nop
   41: 	INVALID();			INVALID(); /* 0x80 */
[  41] 0x900000001fc00080:  0b f0 04 e2 j		notimplemented
[  41] 0x900000001fc00084:  00 00 00 00 nop
[  41] 0x900000001fc00088:  0b f0 04 e2 j		notimplemented
[  41] 0x900000001fc0008c:  00 00 00 00 nop
   42:         INVALID();			INVALID();	
[  42] 0x900000001fc00090:  0b f0 04 e2 j		notimplemented
[  42] 0x900000001fc00094:  00 00 00 00 nop
[  42] 0x900000001fc00098:  0b f0 04 e2 j		notimplemented
[  42] 0x900000001fc0009c:  00 00 00 00 nop
   43: 	INVALID();			INVALID();
[  43] 0x900000001fc000a0:  0b f0 04 e2 j		notimplemented
[  43] 0x900000001fc000a4:  00 00 00 00 nop
[  43] 0x900000001fc000a8:  0b f0 04 e2 j		notimplemented
[  43] 0x900000001fc000ac:  00 00 00 00 nop
   44:         INVALID();			INVALID();	
[  44] 0x900000001fc000b0:  0b f0 04 e2 j		notimplemented
[  44] 0x900000001fc000b4:  00 00 00 00 nop
[  44] 0x900000001fc000b8:  0b f0 04 e2 j		notimplemented
[  44] 0x900000001fc000bc:  00 00 00 00 nop
   45: 	INVALID();			INVALID(); /* 0xc0 */
[  45] 0x900000001fc000c0:  0b f0 04 e2 j		notimplemented
[  45] 0x900000001fc000c4:  00 00 00 00 nop
[  45] 0x900000001fc000c8:  0b f0 04 e2 j		notimplemented
[  45] 0x900000001fc000cc:  00 00 00 00 nop
   46:         INVALID();			INVALID();	
[  46] 0x900000001fc000d0:  0b f0 04 e2 j		notimplemented
[  46] 0x900000001fc000d4:  00 00 00 00 nop
[  46] 0x900000001fc000d8:  0b f0 04 e2 j		notimplemented
[  46] 0x900000001fc000dc:  00 00 00 00 nop
   47: 	INVALID();			INVALID();
[  47] 0x900000001fc000e0:  0b f0 04 e2 j		notimplemented
[  47] 0x900000001fc000e4:  00 00 00 00 nop
[  47] 0x900000001fc000e8:  0b f0 04 e2 j		notimplemented
[  47] 0x900000001fc000ec:  00 00 00 00 nop
   48:         INVALID();			INVALID();		
[  48] 0x900000001fc000f0:  0b f0 04 e2 j		notimplemented
[  48] 0x900000001fc000f4:  00 00 00 00 nop
[  48] 0x900000001fc000f8:  0b f0 04 e2 j		notimplemented
[  48] 0x900000001fc000fc:  00 00 00 00 nop
   49: 	HANDLER(bevECC);		INVALID(); /* 0x100 */
[  49] 0x900000001fc00100:  0b f0 04 9a j		bevECC
[  49] 0x900000001fc00104:  00 00 00 00 nop
[  49] 0x900000001fc00108:  0b f0 04 e2 j		notimplemented
[  49] 0x900000001fc0010c:  00 00 00 00 nop
   50:         INVALID();			INVALID();		
[  50] 0x900000001fc00110:  0b f0 04 e2 j		notimplemented
[  50] 0x900000001fc00114:  00 00 00 00 nop
[  50] 0x900000001fc00118:  0b f0 04 e2 j		notimplemented
[  50] 0x900000001fc0011c:  00 00 00 00 nop
   51: 	INVALID();			INVALID();
[  51] 0x900000001fc00120:  0b f0 04 e2 j		notimplemented
[  51] 0x900000001fc00124:  00 00 00 00 nop
[  51] 0x900000001fc00128:  0b f0 04 e2 j		notimplemented
[  51] 0x900000001fc0012c:  00 00 00 00 nop
   52:         INVALID();			INVALID();		
[  52] 0x900000001fc00130:  0b f0 04 e2 j		notimplemented
[  52] 0x900000001fc00134:  00 00 00 00 nop
[  52] 0x900000001fc00138:  0b f0 04 e2 j		notimplemented
[  52] 0x900000001fc0013c:  00 00 00 00 nop
   53: 	INVALID();			INVALID(); /* 0x140 */
[  53] 0x900000001fc00140:  0b f0 04 e2 j		notimplemented
[  53] 0x900000001fc00144:  00 00 00 00 nop
[  53] 0x900000001fc00148:  0b f0 04 e2 j		notimplemented
[  53] 0x900000001fc0014c:  00 00 00 00 nop
   54:         INVALID();			INVALID();	
[  54] 0x900000001fc00150:  0b f0 04 e2 j		notimplemented
[  54] 0x900000001fc00154:  00 00 00 00 nop
[  54] 0x900000001fc00158:  0b f0 04 e2 j		notimplemented
[  54] 0x900000001fc0015c:  00 00 00 00 nop
   55: 	INVALID();			INVALID();
[  55] 0x900000001fc00160:  0b f0 04 e2 j		notimplemented
[  55] 0x900000001fc00164:  00 00 00 00 nop
[  55] 0x900000001fc00168:  0b f0 04 e2 j		notimplemented
[  55] 0x900000001fc0016c:  00 00 00 00 nop
   56:         INVALID();			INVALID();	
[  56] 0x900000001fc00170:  0b f0 04 e2 j		notimplemented
[  56] 0x900000001fc00174:  00 00 00 00 nop
[  56] 0x900000001fc00178:  0b f0 04 e2 j		notimplemented
[  56] 0x900000001fc0017c:  00 00 00 00 nop
   57: 	INVALID();			INVALID(); /* 0x180 */
[  57] 0x900000001fc00180:  0b f0 04 e2 j		notimplemented
[  57] 0x900000001fc00184:  00 00 00 00 nop
[  57] 0x900000001fc00188:  0b f0 04 e2 j		notimplemented
[  57] 0x900000001fc0018c:  00 00 00 00 nop
   58:         INVALID();			INVALID();	
[  58] 0x900000001fc00190:  0b f0 04 e2 j		notimplemented
[  58] 0x900000001fc00194:  00 00 00 00 nop
[  58] 0x900000001fc00198:  0b f0 04 e2 j		notimplemented
[  58] 0x900000001fc0019c:  00 00 00 00 nop
   59: 	INVALID();			INVALID();
[  59] 0x900000001fc001a0:  0b f0 04 e2 j		notimplemented
[  59] 0x900000001fc001a4:  00 00 00 00 nop
[  59] 0x900000001fc001a8:  0b f0 04 e2 j		notimplemented
[  59] 0x900000001fc001ac:  00 00 00 00 nop
   60:         INVALID();			INVALID();	
[  60] 0x900000001fc001b0:  0b f0 04 e2 j		notimplemented
[  60] 0x900000001fc001b4:  00 00 00 00 nop
[  60] 0x900000001fc001b8:  0b f0 04 e2 j		notimplemented
[  60] 0x900000001fc001bc:  00 00 00 00 nop
   61: 	INVALID();			INVALID(); /* 0x1c0 */
[  61] 0x900000001fc001c0:  0b f0 04 e2 j		notimplemented
[  61] 0x900000001fc001c4:  00 00 00 00 nop
[  61] 0x900000001fc001c8:  0b f0 04 e2 j		notimplemented
[  61] 0x900000001fc001cc:  00 00 00 00 nop
   62:         INVALID();			INVALID();	
[  62] 0x900000001fc001d0:  0b f0 04 e2 j		notimplemented
[  62] 0x900000001fc001d4:  00 00 00 00 nop
[  62] 0x900000001fc001d8:  0b f0 04 e2 j		notimplemented
[  62] 0x900000001fc001dc:  00 00 00 00 nop
   63: 	INVALID();			INVALID();
[  63] 0x900000001fc001e0:  0b f0 04 e2 j		notimplemented
[  63] 0x900000001fc001e4:  00 00 00 00 nop
[  63] 0x900000001fc001e8:  0b f0 04 e2 j		notimplemented
[  63] 0x900000001fc001ec:  00 00 00 00 nop
   64:         INVALID();			INVALID();	
[  64] 0x900000001fc001f0:  0b f0 04 e2 j		notimplemented
[  64] 0x900000001fc001f4:  00 00 00 00 nop
[  64] 0x900000001fc001f8:  0b f0 04 e2 j		notimplemented
[  64] 0x900000001fc001fc:  00 00 00 00 nop
   65: 	INVALID();			INVALID(); /* 0x200 */
[  65] 0x900000001fc00200:  0b f0 04 e2 j		notimplemented
[  65] 0x900000001fc00204:  00 00 00 00 nop
[  65] 0x900000001fc00208:  0b f0 04 e2 j		notimplemented
[  65] 0x900000001fc0020c:  00 00 00 00 nop
   66:         INVALID();			INVALID();	
[  66] 0x900000001fc00210:  0b f0 04 e2 j		notimplemented
[  66] 0x900000001fc00214:  00 00 00 00 nop
[  66] 0x900000001fc00218:  0b f0 04 e2 j		notimplemented
[  66] 0x900000001fc0021c:  00 00 00 00 nop
   67: 	INVALID();			INVALID();
[  67] 0x900000001fc00220:  0b f0 04 e2 j		notimplemented
[  67] 0x900000001fc00224:  00 00 00 00 nop
[  67] 0x900000001fc00228:  0b f0 04 e2 j		notimplemented
[  67] 0x900000001fc0022c:  00 00 00 00 nop
   68:         INVALID();			INVALID();		
[  68] 0x900000001fc00230:  0b f0 04 e2 j		notimplemented
[  68] 0x900000001fc00234:  00 00 00 00 nop
[  68] 0x900000001fc00238:  0b f0 04 e2 j		notimplemented
[  68] 0x900000001fc0023c:  00 00 00 00 nop
   69: 	INVALID();			INVALID(); /* 0x240 */
[  69] 0x900000001fc00240:  0b f0 04 e2 j		notimplemented
[  69] 0x900000001fc00244:  00 00 00 00 nop
[  69] 0x900000001fc00248:  0b f0 04 e2 j		notimplemented
[  69] 0x900000001fc0024c:  00 00 00 00 nop
   70:         INVALID();			INVALID();	
[  70] 0x900000001fc00250:  0b f0 04 e2 j		notimplemented
[  70] 0x900000001fc00254:  00 00 00 00 nop
[  70] 0x900000001fc00258:  0b f0 04 e2 j		notimplemented
[  70] 0x900000001fc0025c:  00 00 00 00 nop
   71: 	INVALID();			INVALID();
[  71] 0x900000001fc00260:  0b f0 04 e2 j		notimplemented
[  71] 0x900000001fc00264:  00 00 00 00 nop
[  71] 0x900000001fc00268:  0b f0 04 e2 j		notimplemented
[  71] 0x900000001fc0026c:  00 00 00 00 nop
   72:         INVALID();			INVALID();	
[  72] 0x900000001fc00270:  0b f0 04 e2 j		notimplemented
[  72] 0x900000001fc00274:  00 00 00 00 nop
[  72] 0x900000001fc00278:  0b f0 04 e2 j		notimplemented
[  72] 0x900000001fc0027c:  00 00 00 00 nop
   73: 	HANDLER(bevXtlbRefill);		INVALID(); /* 0x280 */
[  73] 0x900000001fc00280:  0b f0 04 be j		bevXtlbRefill
[  73] 0x900000001fc00284:  00 00 00 00 nop
[  73] 0x900000001fc00288:  0b f0 04 e2 j		notimplemented
[  73] 0x900000001fc0028c:  00 00 00 00 nop
   74:         INVALID();			INVALID();	
[  74] 0x900000001fc00290:  0b f0 04 e2 j		notimplemented
[  74] 0x900000001fc00294:  00 00 00 00 nop
[  74] 0x900000001fc00298:  0b f0 04 e2 j		notimplemented
[  74] 0x900000001fc0029c:  00 00 00 00 nop
   75: 	INVALID();			INVALID();
[  75] 0x900000001fc002a0:  0b f0 04 e2 j		notimplemented
[  75] 0x900000001fc002a4:  00 00 00 00 nop
[  75] 0x900000001fc002a8:  0b f0 04 e2 j		notimplemented
[  75] 0x900000001fc002ac:  00 00 00 00 nop
   76:         INVALID();			INVALID();	
[  76] 0x900000001fc002b0:  0b f0 04 e2 j		notimplemented
[  76] 0x900000001fc002b4:  00 00 00 00 nop
[  76] 0x900000001fc002b8:  0b f0 04 e2 j		notimplemented
[  76] 0x900000001fc002bc:  00 00 00 00 nop
   77: 	INVALID();			INVALID(); /* 0x2c0 */
[  77] 0x900000001fc002c0:  0b f0 04 e2 j		notimplemented
[  77] 0x900000001fc002c4:  00 00 00 00 nop
[  77] 0x900000001fc002c8:  0b f0 04 e2 j		notimplemented
[  77] 0x900000001fc002cc:  00 00 00 00 nop
   78:         INVALID();			INVALID();	
[  78] 0x900000001fc002d0:  0b f0 04 e2 j		notimplemented
[  78] 0x900000001fc002d4:  00 00 00 00 nop
[  78] 0x900000001fc002d8:  0b f0 04 e2 j		notimplemented
[  78] 0x900000001fc002dc:  00 00 00 00 nop
   79: 	INVALID();			INVALID();
[  79] 0x900000001fc002e0:  0b f0 04 e2 j		notimplemented
[  79] 0x900000001fc002e4:  00 00 00 00 nop
[  79] 0x900000001fc002e8:  0b f0 04 e2 j		notimplemented
[  79] 0x900000001fc002ec:  00 00 00 00 nop
   80:         INVALID();			INVALID();	
[  80] 0x900000001fc002f0:  0b f0 04 e2 j		notimplemented
[  80] 0x900000001fc002f4:  00 00 00 00 nop
[  80] 0x900000001fc002f8:  0b f0 04 e2 j		notimplemented
[  80] 0x900000001fc002fc:  00 00 00 00 nop
   81: 	HANDLER(bevCache);		INVALID(); /* 0x300 */
[  81] 0x900000001fc00300:  0b f0 05 4d j		bevCache
[  81] 0x900000001fc00304:  00 00 00 00 nop
[  81] 0x900000001fc00308:  0b f0 04 e2 j		notimplemented
[  81] 0x900000001fc0030c:  00 00 00 00 nop
   82:         INVALID();			INVALID();	
[  82] 0x900000001fc00310:  0b f0 04 e2 j		notimplemented
[  82] 0x900000001fc00314:  00 00 00 00 nop
[  82] 0x900000001fc00318:  0b f0 04 e2 j		notimplemented
[  82] 0x900000001fc0031c:  00 00 00 00 nop
   83: 	INVALID();			INVALID();
[  83] 0x900000001fc00320:  0b f0 04 e2 j		notimplemented
[  83] 0x900000001fc00324:  00 00 00 00 nop
[  83] 0x900000001fc00328:  0b f0 04 e2 j		notimplemented
[  83] 0x900000001fc0032c:  00 00 00 00 nop
   84:         INVALID();			INVALID();		
[  84] 0x900000001fc00330:  0b f0 04 e2 j		notimplemented
[  84] 0x900000001fc00334:  00 00 00 00 nop
[  84] 0x900000001fc00338:  0b f0 04 e2 j		notimplemented
[  84] 0x900000001fc0033c:  00 00 00 00 nop
   85: 	INVALID();			INVALID(); /* 0x340 */
[  85] 0x900000001fc00340:  0b f0 04 e2 j		notimplemented
[  85] 0x900000001fc00344:  00 00 00 00 nop
[  85] 0x900000001fc00348:  0b f0 04 e2 j		notimplemented
[  85] 0x900000001fc0034c:  00 00 00 00 nop
   86:         INVALID();			INVALID();	
[  86] 0x900000001fc00350:  0b f0 04 e2 j		notimplemented
[  86] 0x900000001fc00354:  00 00 00 00 nop
[  86] 0x900000001fc00358:  0b f0 04 e2 j		notimplemented
[  86] 0x900000001fc0035c:  00 00 00 00 nop
   87: 	INVALID();			INVALID();
[  87] 0x900000001fc00360:  0b f0 04 e2 j		notimplemented
[  87] 0x900000001fc00364:  00 00 00 00 nop
[  87] 0x900000001fc00368:  0b f0 04 e2 j		notimplemented
[  87] 0x900000001fc0036c:  00 00 00 00 nop
   88: 	INVALID();			INVALID();
[  88] 0x900000001fc00370:  0b f0 04 e2 j		notimplemented
[  88] 0x900000001fc00374:  00 00 00 00 nop
[  88] 0x900000001fc00378:  0b f0 04 e2 j		notimplemented
[  88] 0x900000001fc0037c:  00 00 00 00 nop
   89:         HANDLER(bevGeneral);		INVALID(); /* 0x380 */
[  89] 0x900000001fc00380:  0b f0 04 37 j		bevGeneral
[  89] 0x900000001fc00384:  00 00 00 00 nop
[  89] 0x900000001fc00388:  0b f0 04 e2 j		notimplemented
[  89] 0x900000001fc0038c:  00 00 00 00 nop
   90: 	INVALID();			INVALID(); 
[  90] 0x900000001fc00390:  0b f0 04 e2 j		notimplemented
[  90] 0x900000001fc00394:  00 00 00 00 nop
[  90] 0x900000001fc00398:  0b f0 04 e2 j		notimplemented
[  90] 0x900000001fc0039c:  00 00 00 00 nop
   91:         INVALID();			INVALID();	
[  91] 0x900000001fc003a0:  0b f0 04 e2 j		notimplemented
[  91] 0x900000001fc003a4:  00 00 00 00 nop
[  91] 0x900000001fc003a8:  0b f0 04 e2 j		notimplemented
[  91] 0x900000001fc003ac:  00 00 00 00 nop
   92:         INVALID();			INVALID();	
[  92] 0x900000001fc003b0:  0b f0 04 e2 j		notimplemented
[  92] 0x900000001fc003b4:  00 00 00 00 nop
[  92] 0x900000001fc003b8:  0b f0 04 e2 j		notimplemented
[  92] 0x900000001fc003bc:  00 00 00 00 nop
   93: 	INVALID();			INVALID(); /* 0x3c0 */
[  93] 0x900000001fc003c0:  0b f0 04 e2 j		notimplemented
[  93] 0x900000001fc003c4:  00 00 00 00 nop
[  93] 0x900000001fc003c8:  0b f0 04 e2 j		notimplemented
[  93] 0x900000001fc003cc:  00 00 00 00 nop
   94:         INVALID();			INVALID();	
[  94] 0x900000001fc003d0:  0b f0 04 e2 j		notimplemented
[  94] 0x900000001fc003d4:  00 00 00 00 nop
[  94] 0x900000001fc003d8:  0b f0 04 e2 j		notimplemented
[  94] 0x900000001fc003dc:  00 00 00 00 nop
   95: 	INVALID();			INVALID();
[  95] 0x900000001fc003e0:  0b f0 04 e2 j		notimplemented
[  95] 0x900000001fc003e4:  00 00 00 00 nop
[  95] 0x900000001fc003e8:  0b f0 04 e2 j		notimplemented
[  95] 0x900000001fc003ec:  00 00 00 00 nop
   96: 	INVALID();			INVALID();
[  96] 0x900000001fc003f0:  0b f0 04 e2 j		notimplemented
[  96] 0x900000001fc003f4:  00 00 00 00 nop
[  96] 0x900000001fc003f8:  0b f0 04 e2 j		notimplemented
[  96] 0x900000001fc003fc:  00 00 00 00 nop
ip25Config:
[  96] 0x900000001fc00400:  12 11 a8 05 beq	s0,s1,0x900000001fbea418
[  96] 0x900000001fc00404:  00 00 00 00 nop
[  96] 0x900000001fc00408:  0a 0a 0a 0a j		0x9000000018282828
[  96] 0x900000001fc0040c:  0a 0a 0a 0a j		0x9000000018282828
[  96] 0x900000001fc00410:  00 00 00 00 nop
[  96] 0x900000001fc00414:  00 00 00 00 nop
[  96] 0x900000001fc00418:  00 00 00 00 nop
[  96] 0x900000001fc0041c:  00 00 00 00 nop
[  96] 0x900000001fc00420:  aa aa aa aa swl	a6,-21846(s5)
[  96] 0x900000001fc00424:  aa aa aa aa swl	a6,-21846(s5)
[  96] 0x900000001fc00428:  aa aa aa aa swl	a6,-21846(s5)
[  96] 0x900000001fc0042c:  aa aa aa aa swl	a6,-21846(s5)
[  96] 0x900000001fc00430:  55 55 55 55 bnel	a6,s5,0x900000001fc15988
[  96] 0x900000001fc00434:  55 55 55 55 bnel	a6,s5,0x900000001fc1598c
[  96] 0x900000001fc00438:  55 55 55 55 bnel	a6,s5,0x900000001fc15990
[  96] 0x900000001fc0043c:  55 55 55 55 bnel	a6,s5,0x900000001fc15994
Skipping source listing to line 60 of /cores/banyan/stand/arcs/IP25prom/entry.s...
   61:  *	through the power-on vector to this point.
   62:  *	This routine initializes the processor and starts 
   63:  *	basic system configuration.
   64:  */
   65: LEAF(entry)
   66: 	.set	at
   67: 	
   68: 	/* Check for NMI. */
   69: 
   70: 	MFC0(k0, C0_SR)
entry:
[  70] 0x900000001fc00440:  40 1a 60 00 mfc0	k0,sr
   71: 	and	k0,SR_SR		/* Was it NMI? */
[  71] 0x900000001fc00444:  3c 01 00 10 lui	at,0x10
[  71] 0x900000001fc00448:  03 41 d0 24 and	k0,k0,at
   72: 	bnez	k0,bevNmi		/*  let NMI handler take it */
[  72] 0x900000001fc0044c:  17 40 02 52 bne	k0,zero,0x900000001fc00d98
   73: 	nop
[  73] 0x900000001fc00450:  00 00 00 00 nop
   74: 	
   75: 	li	v0,PROM_SR		/* Our expected SR */
[  75] 0x900000001fc00454:  3c 02 24 40 lui	v0,0x2440
[  75] 0x900000001fc00458:  34 42 00 80 ori	v0,v0,0x80
   76: 	MTC0(v0, C0_SR)			/* In known state */
[  76] 0x900000001fc0045c:  40 82 60 00 mtc0	v0,sr
   77: 	SETPC()
[  77] 0x900000001fc00460:  3c 1a 90 00 lui	k0,0x9000
[  77] 0x900000001fc00464:  67 5a 00 00 daddiu	k0,k0,0
[  77] 0x900000001fc00468:  00 1a d4 38 dsll	k0,k0,16
[  77] 0x900000001fc0046c:  67 5a 1f c0 daddiu	k0,k0,8128
[  77] 0x900000001fc00470:  00 1a d4 38 dsll	k0,k0,16
[  77] 0x900000001fc00474:  67 5a 04 80 daddiu	k0,k0,1152
[  77] 0x900000001fc00478:  03 40 00 08 jr	k0
[  77] 0x900000001fc0047c:  00 00 00 00 nop
   78: 
   79: 	LEDS(PLED_STARTUP)
[  79] 0x900000001fc00480:  00 00 00 00 nop
[  79] 0x900000001fc00484:  34 04 00 01 ori	a0,zero,0x1
[  79] 0x900000001fc00488:  3c 02 90 00 lui	v0,0x9000
[  79] 0x900000001fc0048c:  00 02 14 38 dsll	v0,v0,16
[  79] 0x900000001fc00490:  34 42 19 00 ori	v0,v0,0x1900
[  79] 0x900000001fc00494:  00 02 14 38 dsll	v0,v0,16
[  79] 0x900000001fc00498:  34 42 40 00 ori	v0,v0,0x4000
[  79] 0x900000001fc0049c:  fc 44 00 00 sd	a0,0(v0)
   80: 	SPIN()
[  80] 0x900000001fc004a0:  0f f0 05 72 jal		__spin
[  80] 0x900000001fc004a4:  00 00 00 00 nop
   81: 
   82: 	jal	initializeCPU		/* Initialize the CPU */
[  82] 0x900000001fc004a8:  0f f0 02 5a jal		initializeCPU
   83: 	nop
[  83] 0x900000001fc004ac:  00 00 00 00 nop
   84: 
   85: 	/*
   86: 	 * Until we arbitrate, assume we are a slave. That way, we will 
   87: 	 * never try to jump to pod, with a stack in the cache.
   88: 	 */
   89: 	dli	t0, BSR_SLAVE
[  89] 0x900000001fc004b0:  24 0c 10 00 li	t0,4096
   90: 	DMTBR(t0, BR_BSR)
[  90] 0x900000001fc004b4:  44 ac 00 00 dmtc1	t0,$f0
   91: 
   92: 	/*
   93: 	 * Configure the CC UART.
   94: 	 */
   95: 	LEDS(PLED_UARTINIT)
[  95] 0x900000001fc004b8:  00 00 00 00 nop
[  95] 0x900000001fc004bc:  34 04 00 17 ori	a0,zero,0x17
[  95] 0x900000001fc004c0:  3c 02 90 00 lui	v0,0x9000
[  95] 0x900000001fc004c4:  00 02 14 38 dsll	v0,v0,16
[  95] 0x900000001fc004c8:  34 42 19 00 ori	v0,v0,0x1900
[  95] 0x900000001fc004cc:  00 02 14 38 dsll	v0,v0,16
[  95] 0x900000001fc004d0:  34 42 40 00 ori	v0,v0,0x4000
[  95] 0x900000001fc004d4:  fc 44 00 00 sd	a0,0(v0)
   96: 	jal	ccuart_init		/* configure the UART */
[  96] 0x900000001fc004d8:  0f f0 0c a5 jal		ccuart_init
   97: 	nop				/* DELAY */
[  97] 0x900000001fc004dc:  00 00 00 00 nop
   98: 	LEDS(PLED_CCUARTDONE)
[  98] 0x900000001fc004e0:  00 00 00 00 nop
[  98] 0x900000001fc004e4:  34 04 00 18 ori	a0,zero,0x18
[  98] 0x900000001fc004e8:  3c 02 90 00 lui	v0,0x9000
[  98] 0x900000001fc004ec:  00 02 14 38 dsll	v0,v0,16
[  98] 0x900000001fc004f0:  34 42 19 00 ori	v0,v0,0x1900
[  98] 0x900000001fc004f4:  00 02 14 38 dsll	v0,v0,16
[  98] 0x900000001fc004f8:  34 42 40 00 ori	v0,v0,0x4000
[  98] 0x900000001fc004fc:  fc 44 00 00 sd	a0,0(v0)
   99: 
  100: 	/*
  101:  	 * Now do some testing ....
  102: 	 */
  103: 	jal	testIcache
[ 103] 0x900000001fc00500:  0f f0 05 99 jal		testIcache
  104: 	nop
[ 104] 0x900000001fc00504:  00 00 00 00 nop
  105: 	beqz	v0,1f
[ 105] 0x900000001fc00508:  10 40 00 05 beq	v0,zero,0x900000001fc00520
  106:         nop
[ 106] 0x900000001fc0050c:  00 00 00 00 nop
  107: 	FLASH(FLED_ICACHE)
[ 107] 0x900000001fc00510:  00 00 00 00 nop
[ 107] 0x900000001fc00514:  34 04 00 23 ori	a0,zero,0x23
[ 107] 0x900000001fc00518:  0f f0 0c 7f jal		flash_cc_leds
[ 107] 0x900000001fc0051c:  00 00 00 00 nop
  108: 
  109: 1:	jal	testDcache
[ 109] 0x900000001fc00520:  0f f0 06 a5 jal		testDcache
  110: 	nop
[ 110] 0x900000001fc00524:  00 00 00 00 nop
  111: 	beqz	v0,1f
[ 111] 0x900000001fc00528:  10 40 00 04 beq	v0,zero,0x900000001fc0053c
  112: 	FLASH(FLED_DCACHE)
[ 112] 0x900000001fc0052c:  00 00 00 00 nop
[ 112] 0x900000001fc00530:  34 04 00 24 ori	a0,zero,0x24
[ 112] 0x900000001fc00534:  0f f0 0c 7f jal		flash_cc_leds
[ 112] 0x900000001fc00538:  00 00 00 00 nop
  113: 1:	
  114: #if 0
  115: 	LEDS(PLED_CKCCLOCAL)		/* Check local CC registers */
  116: 	jal	pod_check_cclocal	
  117: 	nop				/* DELAY */
  118: #endif
  119: 	jal	pod_check_ccconfig	/* Check CC config registers */
[ 119] 0x900000001fc0053c:  0f f0 13 0f jal		pod_check_ccconfig
  120: 	nop				/* DELAY */
[ 120] 0x900000001fc00540:  00 00 00 00 nop
  121: 
  122: 	jal	initializeIP25
[ 122] 0x900000001fc00544:  0f f0 02 ec jal		initializeIP25
  123: 	nop				/* DELAY */
[ 123] 0x900000001fc00548:  00 00 00 00 nop
  124: 
  125: 	EV_GET_SPNUM(t0, t1)
[ 125] 0x900000001fc0054c:  3c 0c 90 00 lui	t0,0x9000
[ 125] 0x900000001fc00550:  00 0c 64 38 dsll	t0,t0,16
[ 125] 0x900000001fc00554:  35 8c 18 00 ori	t0,t0,0x1800
[ 125] 0x900000001fc00558:  00 0c 64 38 dsll	t0,t0,16
[ 125] 0x900000001fc0055c:  35 8c 00 08 ori	t0,t0,0x8
[ 125] 0x900000001fc00560:  dd 8c 00 00 ld	t0,0(t0)
[ 125] 0x900000001fc00564:  00 00 00 00 nop
[ 125] 0x900000001fc00568:  31 8c 00 3f andi	t0,t0,0x3f
[ 125] 0x900000001fc0056c:  31 8d 00 03 andi	t1,t0,0x3
[ 125] 0x900000001fc00570:  01 a0 68 21 addu	t1,t1,0
[ 125] 0x900000001fc00574:  00 0c 60 82 srl	t0,t0,2
  126: 	EV_SET_PROCREG(t0, t1, EV_CFG_PGBRDEN, zero) /* no piggies */
[ 126] 0x900000001fc00578:  00 0d d9 80 sll	k1,t1,6
[ 126] 0x900000001fc0057c:  63 7b 00 14 daddi	k1,k1,20
[ 126] 0x900000001fc00580:  00 0c d2 c0 sll	k0,t0,11
[ 126] 0x900000001fc00584:  3c 01 90 00 lui	at,0x9000
[ 126] 0x900000001fc00588:  00 01 0c 38 dsll	at,at,16
[ 126] 0x900000001fc0058c:  34 21 18 00 ori	at,at,0x1800
[ 126] 0x900000001fc00590:  00 01 0c 38 dsll	at,at,16
[ 126] 0x900000001fc00594:  34 21 80 00 ori	at,at,0x8000
[ 126] 0x900000001fc00598:  03 41 d0 2c dadd	k0,k0,at
[ 126] 0x900000001fc0059c:  00 1b d8 2c dadd	k1,zero,k1
[ 126] 0x900000001fc005a0:  00 1b d8 c0 sll	k1,k1,3
[ 126] 0x900000001fc005a4:  03 5b d0 2c dadd	k0,k0,k1
[ 126] 0x900000001fc005a8:  00 00 d8 25 move	k1,zero
[ 126] 0x900000001fc005ac:  ff 5b 00 00 sd	k1,0(k0)
[ 126] 0x900000001fc005b0:  00 00 00 00 nop
  127: 	
  128: 	/*
  129: 	 * Compute SCC cache tag mask ---- use the SR because it has the
  130: 	 * log2 value as it stands.
  131: 	 */
  132: 
  133: 	MFC0(v0,C0_CONFIG)
[ 133] 0x900000001fc005b4:  40 02 80 00 mfc0	v0,config
  134: 	and	v0,CONFIG_SS
[ 134] 0x900000001fc005b8:  3c 01 00 07 lui	at,0x7
[ 134] 0x900000001fc005bc:  00 41 10 24 and	v0,v0,at
  135: 	srl	v0,CONFIG_SS_SHFT
[ 135] 0x900000001fc005c0:  00 02 14 02 srl	v0,v0,16
  136: 
  137: 	/*
  138: 	 * SCC needs to know the size of the secondary cache at
  139: 	 * this point to correctly mask bits and generate
  140: 	 * Parity.
  141: 	 */	
  142: 	li	v1,5
[ 142] 0x900000001fc005c4:  24 03 00 05 li	v1,5
  143: 	sub	v0,v1,v0			/* SCC value:CACHE_SZ */
[ 143] 0x900000001fc005c8:  00 62 10 22 sub	v0,v1,v0
  144: 	EV_GET_SPNUM(k0,k1)			/* our address */
[ 144] 0x900000001fc005cc:  3c 1a 90 00 lui	k0,0x9000
[ 144] 0x900000001fc005d0:  00 1a d4 38 dsll	k0,k0,16
[ 144] 0x900000001fc005d4:  37 5a 18 00 ori	k0,k0,0x1800
[ 144] 0x900000001fc005d8:  00 1a d4 38 dsll	k0,k0,16
[ 144] 0x900000001fc005dc:  37 5a 00 08 ori	k0,k0,0x8
[ 144] 0x900000001fc005e0:  df 5a 00 00 ld	k0,0(k0)
[ 144] 0x900000001fc005e4:  00 00 00 00 nop
[ 144] 0x900000001fc005e8:  33 5a 00 3f andi	k0,k0,0x3f
[ 144] 0x900000001fc005ec:  33 5b 00 03 andi	k1,k0,0x3
[ 144] 0x900000001fc005f0:  03 60 d8 21 addu	k1,k1,0
[ 144] 0x900000001fc005f4:  00 1a d0 82 srl	k0,k0,2
  145: 	EV_SET_PROCREG(k0, k1, EV_CFG_CACHE_SZ, v0)
[ 145] 0x900000001fc005f8:  00 1b d9 80 sll	k1,k1,6
[ 145] 0x900000001fc005fc:  63 7b 00 3e daddi	k1,k1,62
[ 145] 0x900000001fc00600:  00 1a d2 c0 sll	k0,k0,11
[ 145] 0x900000001fc00604:  3c 01 90 00 lui	at,0x9000
[ 145] 0x900000001fc00608:  00 01 0c 38 dsll	at,at,16
[ 145] 0x900000001fc0060c:  34 21 18 00 ori	at,at,0x1800
[ 145] 0x900000001fc00610:  00 01 0c 38 dsll	at,at,16
[ 145] 0x900000001fc00614:  34 21 80 00 ori	at,at,0x8000
[ 145] 0x900000001fc00618:  03 41 d0 2c dadd	k0,k0,at
[ 145] 0x900000001fc0061c:  00 1b d8 2c dadd	k1,zero,k1
[ 145] 0x900000001fc00620:  00 1b d8 c0 sll	k1,k1,3
[ 145] 0x900000001fc00624:  03 5b d0 2c dadd	k0,k0,k1
[ 145] 0x900000001fc00628:  00 02 d8 25 or	k1,zero,v0
[ 145] 0x900000001fc0062c:  ff 5b 00 00 sd	k1,0(k0)
[ 145] 0x900000001fc00630:  00 00 00 00 nop
  146: 
  147: 	DMFBR(t0, BR_BSR)		/* set boot status register */
[ 147] 0x900000001fc00634:  44 2c 00 00 dmfc1	t0,$f0
  148: 	or	t0, BSR_CCUI
[ 148] 0x900000001fc00638:  35 8c 00 02 ori	t0,t0,0x2
  149: 	DMTBR(t0, BR_BSR)
[ 149] 0x900000001fc0063c:  44 ac 00 00 dmtc1	t0,$f0
  150: 	
  151: 	/*
  152: 	 * Print PROM header now that we can talk to the world.
  153: 	 */
  154: 
  155: 	DPRINT("\r\n\nEVEREST IP25 BRINGUP PROM ");
  156: 	MFC0(t0, C0_CONFIG)
[ 156] 0x900000001fc00640:  40 0c 80 00 mfc0	t0,config
  157: 	and	t0,CONFIG_BE
[ 157] 0x900000001fc00644:  31 8c 80 00 andi	t0,t0,0x8000
  158: 	bnez	t0,1f
[ 158] 0x900000001fc00648:  15 80 00 03 bne	t0,zero,0x900000001fc00658
  159: 	nop				/* DELAY */
[ 159] 0x900000001fc0064c:  00 00 00 00 nop
  160: 	DPRINT("(LE)\r\n")
  161: 	b	2f
[ 161] 0x900000001fc00650:  10 00 00 01 b		0x900000001fc00658
  162: 	nop				/* DELAY */
[ 162] 0x900000001fc00654:  00 00 00 00 nop
  163: 1:	
  164: 	DPRINT("(BE)\r\n")
  165: 2:
  166: 
  167: 	/*
  168: 	 * Check and do initial configuration of the A chip. In order
  169: 	 * to avoid conflicts between processors as they test their
  170: 	 * connection with the A chip, we delay based on our location.
  171: 	 */
  172: 	DPRINT("Testing A chip ... \t\t\t");
  173: 	dli	a0, EV_SPNUM
[ 173] 0x900000001fc00658:  3c 04 90 00 lui	a0,0x9000
[ 173] 0x900000001fc0065c:  00 04 24 38 dsll	a0,a0,16
[ 173] 0x900000001fc00660:  34 84 18 00 ori	a0,a0,0x1800
[ 173] 0x900000001fc00664:  00 04 24 38 dsll	a0,a0,16
[ 173] 0x900000001fc00668:  34 84 00 08 ori	a0,a0,0x8
  174: 	ld	a0,0(a0)
[ 174] 0x900000001fc0066c:  dc 84 00 00 ld	a0,0(a0)
  175: 	and	a0,EV_PROCNUM_MASK
[ 175] 0x900000001fc00670:  30 84 00 03 andi	a0,a0,0x3
  176: 	jal	delay
[ 176] 0x900000001fc00674:  0f f0 0d a4 jal		delay
  177: 	sll	a0,11			/* 2048 * slot # */
[ 177] 0x900000001fc00678:  00 04 22 c0 sll	a0,a0,11
  178: 	LEDS(PLED_CKACHIP)
[ 178] 0x900000001fc0067c:  00 00 00 00 nop
[ 178] 0x900000001fc00680:  34 04 00 19 ori	a0,zero,0x19
[ 178] 0x900000001fc00684:  3c 02 90 00 lui	v0,0x9000
[ 178] 0x900000001fc00688:  00 02 14 38 dsll	v0,v0,16
[ 178] 0x900000001fc0068c:  34 42 19 00 ori	v0,v0,0x1900
[ 178] 0x900000001fc00690:  00 02 14 38 dsll	v0,v0,16
[ 178] 0x900000001fc00694:  34 42 40 00 ori	v0,v0,0x4000
[ 178] 0x900000001fc00698:  fc 44 00 00 sd	a0,0(v0)
  179: 	jal	pod_check_achip		/* Check out Mr. A */
[ 179] 0x900000001fc0069c:  0f f0 13 f1 jal		pod_check_achip
  180: 	nop
[ 180] 0x900000001fc006a0:  00 00 00 00 nop
  181: 	DPRINT("OK\r\n");
  182: 	
  183: 	LEDS(PLED_AINIT)
[ 183] 0x900000001fc006a4:  00 00 00 00 nop
[ 183] 0x900000001fc006a8:  34 04 00 1a ori	a0,zero,0x1a
[ 183] 0x900000001fc006ac:  3c 02 90 00 lui	v0,0x9000
[ 183] 0x900000001fc006b0:  00 02 14 38 dsll	v0,v0,16
[ 183] 0x900000001fc006b4:  34 42 19 00 ori	v0,v0,0x1900
[ 183] 0x900000001fc006b8:  00 02 14 38 dsll	v0,v0,16
[ 183] 0x900000001fc006bc:  34 42 40 00 ori	v0,v0,0x4000
[ 183] 0x900000001fc006c0:  fc 44 00 00 sd	a0,0(v0)
  184: 	DPRINT("Initializing A chip ...\t\t\t");
  185: 	EV_GET_SPNUM(t0,zero)		# Get slot number
[ 185] 0x900000001fc006c4:  3c 0c 90 00 lui	t0,0x9000
[ 185] 0x900000001fc006c8:  00 0c 64 38 dsll	t0,t0,16
[ 185] 0x900000001fc006cc:  35 8c 18 00 ori	t0,t0,0x1800
[ 185] 0x900000001fc006d0:  00 0c 64 38 dsll	t0,t0,16
[ 185] 0x900000001fc006d4:  35 8c 00 08 ori	t0,t0,0x8
[ 185] 0x900000001fc006d8:  dd 8c 00 00 ld	t0,0(t0)
[ 185] 0x900000001fc006dc:  00 00 00 00 nop
[ 185] 0x900000001fc006e0:  31 8c 00 3f andi	t0,t0,0x3f
[ 185] 0x900000001fc006e4:  31 80 00 03 andi	zero,t0,0x3
[ 185] 0x900000001fc006e8:  00 00 00 21 nada
[ 185] 0x900000001fc006ec:  00 0c 60 82 srl	t0,t0,2
  186: 	EV_GET_CONFIG(t0, EV_A_ERROR_CLEAR, t1)
[ 186] 0x900000001fc006f0:  00 0c d2 c0 sll	k0,t0,11
[ 186] 0x900000001fc006f4:  3c 01 90 00 lui	at,0x9000
[ 186] 0x900000001fc006f8:  00 01 0c 38 dsll	at,at,16
[ 186] 0x900000001fc006fc:  34 21 18 00 ori	at,at,0x1800
[ 186] 0x900000001fc00700:  00 01 0c 38 dsll	at,at,16
[ 186] 0x900000001fc00704:  34 21 80 00 ori	at,at,0x8000
[ 186] 0x900000001fc00708:  03 41 d0 2c dadd	k0,k0,at
[ 186] 0x900000001fc0070c:  60 0d 00 07 daddi	t1,zero,7
[ 186] 0x900000001fc00710:  00 0d 68 c0 sll	t1,t1,3
[ 186] 0x900000001fc00714:  03 4d d0 2c dadd	k0,k0,t1
[ 186] 0x900000001fc00718:  df 4d 00 00 ld	t1,0(k0)
[ 186] 0x900000001fc0071c:  00 00 00 00 nop
  187: 	EV_SET_CONFIG(t0, EV_A_RSC_TIMEOUT, RSC_TIMEOUT)
[ 187] 0x900000001fc00720:  00 0c d2 c0 sll	k0,t0,11
[ 187] 0x900000001fc00724:  3c 01 90 00 lui	at,0x9000
[ 187] 0x900000001fc00728:  00 01 0c 38 dsll	at,at,16
[ 187] 0x900000001fc0072c:  34 21 18 00 ori	at,at,0x1800
[ 187] 0x900000001fc00730:  00 01 0c 38 dsll	at,at,16
[ 187] 0x900000001fc00734:  34 21 80 00 ori	at,at,0x8000
[ 187] 0x900000001fc00738:  03 41 d0 2c dadd	k0,k0,at
[ 187] 0x900000001fc0073c:  60 1b 00 04 daddi	k1,zero,4
[ 187] 0x900000001fc00740:  00 1b d8 c0 sll	k1,k1,3
[ 187] 0x900000001fc00744:  03 5b d0 2c dadd	k0,k0,k1
[ 187] 0x900000001fc00748:  3c 01 00 4c lui	at,0x4c
[ 187] 0x900000001fc0074c:  34 21 4b 40 ori	at,at,0x4b40
[ 187] 0x900000001fc00750:  00 01 d8 25 or	k1,zero,at
[ 187] 0x900000001fc00754:  ff 5b 00 00 sd	k1,0(k0)
[ 187] 0x900000001fc00758:  00 00 00 00 nop
  188: 	EV_SET_CONFIG(t0, EV_A_URGENT_TIMEOUT, URG_TIMEOUT)
[ 188] 0x900000001fc0075c:  00 0c d2 c0 sll	k0,t0,11
[ 188] 0x900000001fc00760:  3c 01 90 00 lui	at,0x9000
[ 188] 0x900000001fc00764:  00 01 0c 38 dsll	at,at,16
[ 188] 0x900000001fc00768:  34 21 18 00 ori	at,at,0x1800
[ 188] 0x900000001fc0076c:  00 01 0c 38 dsll	at,at,16
[ 188] 0x900000001fc00770:  34 21 80 00 ori	at,at,0x8000
[ 188] 0x900000001fc00774:  03 41 d0 2c dadd	k0,k0,at
[ 188] 0x900000001fc00778:  60 1b 00 03 daddi	k1,zero,3
[ 188] 0x900000001fc0077c:  00 1b d8 c0 sll	k1,k1,3
[ 188] 0x900000001fc00780:  03 5b d0 2c dadd	k0,k0,k1
[ 188] 0x900000001fc00784:  34 1b 00 40 ori	k1,zero,0x40
[ 188] 0x900000001fc00788:  ff 5b 00 00 sd	k1,0(k0)
  189: 	DPRINT("ok\r\n")
  190: 
  191: #if IP25MON
  192: 	jal	initDcacheStack
  193: 	nop
  194: 	dli	a0, PROM_SR
  195: 	MTC0(a0, C0_SR)
  196: 	LEDS(PLED_MAIN)
  197: 	jal	ccuart_flush
  198: 	nop
  199: 	jal	__spin
  200: 	nop
  201: 	jal	main
  202: #endif
  203: 	
  204: 	/*
  205: 	 * Check the EBUS.
  206: 	 */
  207: 	LEDS(PLED_CKEBUS1)
[ 207] 0x900000001fc0078c:  00 00 00 00 nop
[ 207] 0x900000001fc00790:  00 00 00 00 nop
[ 207] 0x900000001fc00794:  34 04 00 1b ori	a0,zero,0x1b
[ 207] 0x900000001fc00798:  3c 02 90 00 lui	v0,0x9000
[ 207] 0x900000001fc0079c:  00 02 14 38 dsll	v0,v0,16
[ 207] 0x900000001fc007a0:  34 42 19 00 ori	v0,v0,0x1900
[ 207] 0x900000001fc007a4:  00 02 14 38 dsll	v0,v0,16
[ 207] 0x900000001fc007a8:  34 42 40 00 ori	v0,v0,0x4000
[ 207] 0x900000001fc007ac:  fc 44 00 00 sd	a0,0(v0)
  208: 	DPRINT("Testing EBUS ...\t\t\t")
  209: 	jal	pod_check_ebus1
[ 209] 0x900000001fc007b0:  0f f0 14 30 jal		pod_check_ebus1
  210: 	nop
[ 210] 0x900000001fc007b4:  00 00 00 00 nop
  211: 	beqz	v0, 1f			/* Keep going if OK */
[ 211] 0x900000001fc007b8:  10 40 00 05 beq	v0,zero,0x900000001fc007d0
  212: 	nop
[ 212] 0x900000001fc007bc:  00 00 00 00 nop
  213: 	DPRINT("FAILED\r\n")
  214: 	FLASH(PLED_CKEBUS1)
[ 214] 0x900000001fc007c0:  00 00 00 00 nop
[ 214] 0x900000001fc007c4:  34 04 00 1b ori	a0,zero,0x1b
[ 214] 0x900000001fc007c8:  0f f0 0c 7f jal		flash_cc_leds
[ 214] 0x900000001fc007cc:  00 00 00 00 nop
  215: 	
  216: 1:	DPRINT("ok\r\n")
  217: 	
  218: 	/*
  219: 	 * Perform Boot master arbitration. If this processor is
  220:  	 * the Boot Master, jump to the master processor thread of
  221: 	 * execution.  Otherwise, jump to the slave thread of execution.
  222: 	 */
  223: 	j	arb_bootmaster		/* Do actual arb */
[ 223] 0x900000001fc007d0:  0b f0 0e 44 j		arb_bootmaster
  224: 	nop
[ 224] 0x900000001fc007d4:  00 00 00 00 nop
  225: 	/* DOESN'T RETURN */
  226: 	END(entry)
  227: 
  228: /*
  229:  * Function:	bevRestartMaster
  230:  * Purpose:	entry point for restart from BEV vector. This is
  231:  *		called when the OS wants to reboot or return
  232:  *		from the prom monitor.
  233:  * Parameters:	none
  234:  * Returns:	Doesn't
  235:  */
  236: LEAF(bevRestartMaster)
  237: 	SETPC()
bevRestartMaster:
[ 237] 0x900000001fc007d8:  3c 1a 90 00 lui	k0,0x9000
[ 237] 0x900000001fc007dc:  67 5a 00 00 daddiu	k0,k0,0
[ 237] 0x900000001fc007e0:  00 1a d4 38 dsll	k0,k0,16
[ 237] 0x900000001fc007e4:  67 5a 1f c0 daddiu	k0,k0,8128
[ 237] 0x900000001fc007e8:  00 1a d4 38 dsll	k0,k0,16
[ 237] 0x900000001fc007ec:  67 5a 07 f8 daddiu	k0,k0,2040
[ 237] 0x900000001fc007f0:  03 40 00 08 jr	k0
[ 237] 0x900000001fc007f4:  00 00 00 00 nop
  238: 	jal	initializeCPU
[ 238] 0x900000001fc007f8:  0f f0 02 5a jal		initializeCPU
  239: 	nop
[ 239] 0x900000001fc007fc:  00 00 00 00 nop
  240: 	SCPRINT("Re-initing caches")
[ 240] 0x900000001fc00800:  3c 04 90 00 lui	a0,0x9000
[ 240] 0x900000001fc00804:  64 84 00 00 daddiu	a0,a0,0
[ 240] 0x900000001fc00808:  00 04 24 38 dsll	a0,a0,16
[ 240] 0x900000001fc0080c:  64 84 1f c1 daddiu	a0,a0,8129
[ 240] 0x900000001fc00810:  00 04 24 38 dsll	a0,a0,16
[ 240] 0x900000001fc00814:  64 84 71 00 daddiu	a0,a0,28928
[ 240] 0x900000001fc00818:  0f f0 11 7c jal		sysctlr_message
[ 240] 0x900000001fc0081c:  00 00 00 00 nop
  241: 	jal	initializeIP25
[ 241] 0x900000001fc00820:  0f f0 02 ec jal		initializeIP25
  242: 	nop
[ 242] 0x900000001fc00824:  00 00 00 00 nop
  243: 	SCPRINT("Rebuilding stack")
[ 243] 0x900000001fc00828:  3c 04 90 00 lui	a0,0x9000
[ 243] 0x900000001fc0082c:  64 84 00 00 daddiu	a0,a0,0
[ 243] 0x900000001fc00830:  00 04 24 38 dsll	a0,a0,16
[ 243] 0x900000001fc00834:  64 84 1f c1 daddiu	a0,a0,8129
[ 243] 0x900000001fc00838:  00 04 24 38 dsll	a0,a0,16
[ 243] 0x900000001fc0083c:  64 84 71 12 daddiu	a0,a0,28946
[ 243] 0x900000001fc00840:  0f f0 11 7c jal		sysctlr_message
[ 243] 0x900000001fc00844:  00 00 00 00 nop
  244: 	jal	initDcacheStack
[ 244] 0x900000001fc00848:  0f f0 0a de jal		initDcacheStack
  245: 	nop
[ 245] 0x900000001fc0084c:  00 00 00 00 nop
  246: 	SCPRINT("Re-initing IO4")
[ 246] 0x900000001fc00850:  3c 04 90 00 lui	a0,0x9000
[ 246] 0x900000001fc00854:  64 84 00 00 daddiu	a0,a0,0
[ 246] 0x900000001fc00858:  00 04 24 38 dsll	a0,a0,16
[ 246] 0x900000001fc0085c:  64 84 1f c1 daddiu	a0,a0,8129
[ 246] 0x900000001fc00860:  00 04 24 38 dsll	a0,a0,16
[ 246] 0x900000001fc00864:  64 84 71 23 daddiu	a0,a0,28963
[ 246] 0x900000001fc00868:  0f f0 11 7c jal		sysctlr_message
[ 246] 0x900000001fc0086c:  00 00 00 00 nop
  247: 	jal	io4_initmaster
[ 247] 0x900000001fc00870:  0f f0 3b 6f jal		io4_initmaster
  248: 	nop
[ 248] 0x900000001fc00874:  00 00 00 00 nop
  249: 	SCPRINT("Re-initing EPC UART")
[ 249] 0x900000001fc00878:  3c 04 90 00 lui	a0,0x9000
[ 249] 0x900000001fc0087c:  64 84 00 00 daddiu	a0,a0,0
[ 249] 0x900000001fc00880:  00 04 24 38 dsll	a0,a0,16
[ 249] 0x900000001fc00884:  64 84 1f c1 daddiu	a0,a0,8129
[ 249] 0x900000001fc00888:  00 04 24 38 dsll	a0,a0,16
[ 249] 0x900000001fc0088c:  64 84 71 32 daddiu	a0,a0,28978
[ 249] 0x900000001fc00890:  0f f0 11 7c jal		sysctlr_message
[ 249] 0x900000001fc00894:  00 00 00 00 nop
  250: 	jal	init_epc_uart
[ 250] 0x900000001fc00898:  0f f0 59 e7 jal		init_epc_uart
  251: 	nop
[ 251] 0x900000001fc0089c:  00 00 00 00 nop
  252: 	DMFBR(t0, BR_BSR)
[ 252] 0x900000001fc008a0:  44 2c 00 00 dmfc1	t0,$f0
  253: 	or	t0,BSR_EPCUART
[ 253] 0x900000001fc008a4:  35 8c 01 00 ori	t0,t0,0x100
  254: 	DMTBR(t0, BR_BSR)
[ 254] 0x900000001fc008a8:  44 ac 00 00 dmtc1	t0,$f0
  255: 	SCPRINT("Re-loading IO4 PROM")
[ 255] 0x900000001fc008ac:  3c 04 90 00 lui	a0,0x9000
[ 255] 0x900000001fc008b0:  64 84 00 00 daddiu	a0,a0,0
[ 255] 0x900000001fc008b4:  00 04 24 38 dsll	a0,a0,16
[ 255] 0x900000001fc008b8:  64 84 1f c1 daddiu	a0,a0,8129
[ 255] 0x900000001fc008bc:  00 04 24 38 dsll	a0,a0,16
[ 255] 0x900000001fc008c0:  64 84 71 46 daddiu	a0,a0,28998
[ 255] 0x900000001fc008c4:  0f f0 11 7c jal		sysctlr_message
[ 255] 0x900000001fc008c8:  00 00 00 00 nop
  256: 	jal	load_io4prom
[ 256] 0x900000001fc008cc:  0f f0 5b 40 jal		load_io4prom
  257: 	nop
[ 257] 0x900000001fc008d0:  00 00 00 00 nop
  258: 	FLASH(FLED_RESTART)
[ 258] 0x900000001fc008d4:  00 00 00 00 nop
[ 258] 0x900000001fc008d8:  34 04 00 22 ori	a0,zero,0x22
[ 258] 0x900000001fc008dc:  0f f0 0c 7f jal		flash_cc_leds
[ 258] 0x900000001fc008e0:  00 00 00 00 nop
  259: 	END(bevRestartMaster)
  260: /*
  261:  * Function:	bevRestartSlave
  262:  * Parameters:	entery point for restart from BEV vector. This is
  263:  *		called by the slave CPUs.
  264:  * Parameters:	none
  265:  * Returns:	nothing
  266:  */
  267: LEAF(bevRestartSlave)
  268: 	.set	noreorder
  269: 	jal	initializeCPU
bevRestartSlave:
[ 269] 0x900000001fc008e4:  0f f0 02 5a jal		initializeCPU
  270: 	nop
[ 270] 0x900000001fc008e8:  00 00 00 00 nop
  271: 	jal	initializeIP25
[ 271] 0x900000001fc008ec:  0f f0 02 ec jal		initializeIP25
  272: 	nop
[ 272] 0x900000001fc008f0:  00 00 00 00 nop
  273: 	li	v0,BSR_SLAVE
[ 273] 0x900000001fc008f4:  24 02 10 00 li	v0,4096
  274: 	DMTBR(v0, BR_BSR)
[ 274] 0x900000001fc008f8:  44 a2 00 00 dmtc1	v0,$f0
  275: 	j	prom_slave
[ 275] 0x900000001fc008fc:  0b f0 0e e0 j		prom_slave
  276: 	nop
[ 276] 0x900000001fc00900:  00 00 00 00 nop
  277: 	.set	reorder
  278:  	END(bevRestartSlave)
  279: 
  280: /*
  281:  * Function: 	bevRestartMasterEPC
  282:  * Purpose:	To restart POD using the EPC, ignoring all the other
  283:  *		stuff.
  284:  * Parameters:	none
  285:  * Returns:	Never.
  286:  */
  287: LEAF(bevRestartMasterEPC)
  288: 	.set	noreorder
  289: 	jal	initializeCPU
bevRestartMasterEPC:
[ 289] 0x900000001fc00904:  0f f0 02 5a jal		initializeCPU
  290: 	nop
[ 290] 0x900000001fc00908:  00 00 00 00 nop
  291: 	jal	initializeIP25
[ 291] 0x900000001fc0090c:  0f f0 02 ec jal		initializeIP25
  292: 	nop
[ 292] 0x900000001fc00910:  00 00 00 00 nop
  293: 	li	t0,BSR_CCUI+BSR_EPCUART+BSR_POD+BSR_NODIAG
[ 293] 0x900000001fc00914:  24 0c 01 86 li	t0,390
  294: 	DMTBR(t0, BR_BSR)
[ 294] 0x900000001fc00918:  44 ac 00 00 dmtc1	t0,$f0
  295: 	j	prom_master		/* No arbitration here */
[ 295] 0x900000001fc0091c:  0b f0 12 10 j		prom_master
  296: 	nop
[ 296] 0x900000001fc00920:  00 00 00 00 nop
  297: 	.set reorder
  298: 	END(bevRestartMasterEPC)
  299: 
  300: /*
  301:  * Function:	bedPodMode
  302:  * Purpose:	To put the current CPU into POD. Allows symmon or
  303:  *		whatever to jump back into pod.
  304:  * Parameters:	None
  305:  * Returns:	Nothing
  306:  */
  307: LEAF(bevPodMode)
  308: 	jal	initializeCPU
bevPodMode:
[ 308] 0x900000001fc00924:  0f f0 02 5a jal		initializeCPU
[ 308] 0x900000001fc00928:  00 00 00 00 nop
  309: 	jal	initializeIP25
[ 309] 0x900000001fc0092c:  0f f0 02 ec jal		initializeIP25
[ 309] 0x900000001fc00930:  00 00 00 00 nop
  310: 	DMFBR(t0,BR_BSR)
[ 310] 0x900000001fc00934:  44 2c 00 00 dmfc1	t0,$f0
  311: 	or	t0,BSR_CCUI
[ 311] 0x900000001fc00938:  00 00 00 00 nop
[ 311] 0x900000001fc0093c:  35 8c 00 02 ori	t0,t0,0x2
  312: 	DMTBR(t0,BR_BSR)
[ 312] 0x900000001fc00940:  44 ac 00 00 dmtc1	t0,$f0
  313: 	MESSAGE(a1, "POD mode")
[ 313] 0x900000001fc00944:  3c 05 90 00 lui	a1,0x9000
[ 313] 0x900000001fc00948:  64 a5 00 00 daddiu	a1,a1,0
[ 313] 0x900000001fc0094c:  00 05 2c 38 dsll	a1,a1,16
[ 313] 0x900000001fc00950:  64 a5 1f c1 daddiu	a1,a1,8129
[ 313] 0x900000001fc00954:  00 05 2c 38 dsll	a1,a1,16
[ 313] 0x900000001fc00958:  64 a5 71 5a daddiu	a1,a1,29018
  314: 	li	a0,EVDIAG_DEBUG
[ 314] 0x900000001fc0095c:  24 04 00 fd li	a0,253
  315: 	jal	podMode
[ 315] 0x900000001fc00960:  0f f0 15 fd jal		podMode
[ 315] 0x900000001fc00964:  00 00 00 00 nop
  316: 	END(bevPodMode)
  317: 
  318: /*
  319:  * Function: 	initializeCPU
  320:  * Purpose:	Initializes the T5 registers to a known state.
  321:  * Parameters:	None
  322:  * Returns:	Nothing
  323:  * Notes:	uses t0,v0,a0
  324:  */
  325: LEAF(initializeCPU)
  326: 	.set	noreorder
  327: 	move	t1,ra
initializeCPU:
[ 327] 0x900000001fc00968:  03 e0 68 25 move	t1,ra
  328: 	li	v0,PROM_SR		/* Our expected SR */
[ 328] 0x900000001fc0096c:  3c 02 24 40 lui	v0,0x2440
[ 328] 0x900000001fc00970:  34 42 00 80 ori	v0,v0,0x80
  329: 	MTC0(v0, C0_SR)			/* In known state */
[ 329] 0x900000001fc00974:  40 82 60 00 mtc0	v0,sr
  330: 	LEDS(PLED_STARTUP)		/* set startup leds */
[ 330] 0x900000001fc00978:  00 00 00 00 nop
[ 330] 0x900000001fc0097c:  34 04 00 01 ori	a0,zero,0x1
[ 330] 0x900000001fc00980:  3c 02 90 00 lui	v0,0x9000
[ 330] 0x900000001fc00984:  00 02 14 38 dsll	v0,v0,16
[ 330] 0x900000001fc00988:  34 42 19 00 ori	v0,v0,0x1900
[ 330] 0x900000001fc0098c:  00 02 14 38 dsll	v0,v0,16
[ 330] 0x900000001fc00990:  34 42 40 00 ori	v0,v0,0x4000
[ 330] 0x900000001fc00994:  fc 44 00 00 sd	a0,0(v0)
  331: 
  332: 	/*
  333: 	 * Initialize the busy-bit table in 2 steps:
  334: 	 *	1:
  335: 	 *	2:
  336: 	 */
  337: 	.set	noat	
  338:         add	$at, $0, $0	;         mtc1    $0, $f0
[ 338] 0x900000001fc00998:  00 00 08 20 add	at,zero,zero
[ 338] 0x900000001fc0099c:  44 80 00 00 mtc1	zero,$f0
  339:         add 	$2, $0, $0	;         mtc1    $0, $f1
[ 339] 0x900000001fc009a0:  00 00 10 20 add	v0,zero,zero
[ 339] 0x900000001fc009a4:  44 80 08 00 mtc1	zero,$f1
  340:         add 	$3, $0, $0	;         mtc1    $0, $f2
[ 340] 0x900000001fc009a8:  00 00 18 20 add	v1,zero,zero
[ 340] 0x900000001fc009ac:  44 80 10 00 mtc1	zero,$f2
  341:         add 	$4, $0, $0	;         mtc1    $0, $f3
[ 341] 0x900000001fc009b0:  00 00 20 20 add	a0,zero,zero
[ 341] 0x900000001fc009b4:  44 80 18 00 mtc1	zero,$f3
  342:         add 	$5, $0, $0	;         mtc1    $0, $f4
[ 342] 0x900000001fc009b8:  00 00 28 20 add	a1,zero,zero
[ 342] 0x900000001fc009bc:  44 80 20 00 mtc1	zero,$f4
  343:         add 	$6, $0, $0	;         mtc1    $0, $f5
[ 343] 0x900000001fc009c0:  00 00 30 20 add	a2,zero,zero
[ 343] 0x900000001fc009c4:  44 80 28 00 mtc1	zero,$f5
  344:         add 	$7, $0, $0	;         mtc1    $0, $f6
[ 344] 0x900000001fc009c8:  00 00 38 20 add	a3,zero,zero
[ 344] 0x900000001fc009cc:  44 80 30 00 mtc1	zero,$f6
  345:         add 	$8, $0, $0	;         mtc1    $0, $f7
[ 345] 0x900000001fc009d0:  00 00 40 20 add	a4,zero,zero
[ 345] 0x900000001fc009d4:  44 80 38 00 mtc1	zero,$f7
  346:         add 	$9, $0, $0	;         mtc1    $0, $f8
[ 346] 0x900000001fc009d8:  00 00 48 20 add	a5,zero,zero
[ 346] 0x900000001fc009dc:  44 80 40 00 mtc1	zero,$f8
  347:         add 	$10, $0, $0	;         mtc1    $0, $f9
[ 347] 0x900000001fc009e0:  00 00 50 20 add	a6,zero,zero
[ 347] 0x900000001fc009e4:  44 80 48 00 mtc1	zero,$f9
  348:         add 	$11, $0, $0	;         mtc1    $0, $f10
[ 348] 0x900000001fc009e8:  00 00 58 20 add	a7,zero,zero
[ 348] 0x900000001fc009ec:  44 80 50 00 mtc1	zero,$f10
  349:         add 	$12, $0, $0	;         mtc1    $0, $f11
[ 349] 0x900000001fc009f0:  00 00 60 20 add	t0,zero,zero
[ 349] 0x900000001fc009f4:  44 80 58 00 mtc1	zero,$f11
  350:         /*add 	$13, $0, $0*/	;         mtc1    $0, $f12
[ 350] 0x900000001fc009f8:  44 80 60 00 mtc1	zero,$f12
  351:         add 	$14, $0, $0	;         mtc1    $0, $f13
[ 351] 0x900000001fc009fc:  00 00 70 20 add	t2,zero,zero
[ 351] 0x900000001fc00a00:  44 80 68 00 mtc1	zero,$f13
  352:         add 	$15, $0, $0	;         mtc1    $0, $f14
[ 352] 0x900000001fc00a04:  00 00 78 20 add	t3,zero,zero
[ 352] 0x900000001fc00a08:  44 80 70 00 mtc1	zero,$f14
  353:         add 	$16, $0, $0	;         mtc1    $0, $f15
[ 353] 0x900000001fc00a0c:  00 00 80 20 add	s0,zero,zero
[ 353] 0x900000001fc00a10:  44 80 78 00 mtc1	zero,$f15
  354:         add 	$17, $0, $0	;         mtc1    $0, $f16
[ 354] 0x900000001fc00a14:  00 00 88 20 add	s1,zero,zero
[ 354] 0x900000001fc00a18:  44 80 80 00 mtc1	zero,$f16
  355:         add 	$18, $0, $0	;         mtc1    $0, $f17
[ 355] 0x900000001fc00a1c:  00 00 90 20 add	s2,zero,zero
[ 355] 0x900000001fc00a20:  44 80 88 00 mtc1	zero,$f17
  356:         add 	$19, $0, $0	;         mtc1    $0, $f18
[ 356] 0x900000001fc00a24:  00 00 98 20 add	s3,zero,zero
[ 356] 0x900000001fc00a28:  44 80 90 00 mtc1	zero,$f18
  357:         add 	$20, $0, $0	;         mtc1    $0, $f19
[ 357] 0x900000001fc00a2c:  00 00 a0 20 add	s4,zero,zero
[ 357] 0x900000001fc00a30:  44 80 98 00 mtc1	zero,$f19
  358:         add 	$21, $0, $0	;         mtc1    $0, $f20
[ 358] 0x900000001fc00a34:  00 00 a8 20 add	s5,zero,zero
[ 358] 0x900000001fc00a38:  44 80 a0 00 mtc1	zero,$f20
  359:         add 	$22, $0, $0	;         mtc1    $0, $f21
[ 359] 0x900000001fc00a3c:  00 00 b0 20 add	s6,zero,zero
[ 359] 0x900000001fc00a40:  44 80 a8 00 mtc1	zero,$f21
  360:         add 	$23, $0, $0	;         mtc1    $0, $f22
[ 360] 0x900000001fc00a44:  00 00 b8 20 add	s7,zero,zero
[ 360] 0x900000001fc00a48:  44 80 b0 00 mtc1	zero,$f22
  361:         add 	$24, $0, $0	;         mtc1    $0, $f23
[ 361] 0x900000001fc00a4c:  00 00 c0 20 add	t8,zero,zero
[ 361] 0x900000001fc00a50:  44 80 b8 00 mtc1	zero,$f23
  362:         add 	$25, $0, $0	;         mtc1    $0, $f24
[ 362] 0x900000001fc00a54:  00 00 c8 20 add	t9,zero,zero
[ 362] 0x900000001fc00a58:  44 80 c0 00 mtc1	zero,$f24
  363:         add 	$26, $0, $0	;         mtc1    $0, $f25
[ 363] 0x900000001fc00a5c:  00 00 d0 20 add	k0,zero,zero
[ 363] 0x900000001fc00a60:  44 80 c8 00 mtc1	zero,$f25
  364:         add 	$27, $0, $0	;         mtc1    $0, $f26
[ 364] 0x900000001fc00a64:  00 00 d8 20 add	k1,zero,zero
[ 364] 0x900000001fc00a68:  44 80 d0 00 mtc1	zero,$f26
  365:         add 	$28, $0, $0	;         mtc1    $0, $f27
[ 365] 0x900000001fc00a6c:  00 00 e0 20 add	gp,zero,zero
[ 365] 0x900000001fc00a70:  44 80 d8 00 mtc1	zero,$f27
  366:         add 	$29, $0, $0	;         mtc1    $0, $f28
[ 366] 0x900000001fc00a74:  00 00 e8 20 add	sp,zero,zero
[ 366] 0x900000001fc00a78:  44 80 e0 00 mtc1	zero,$f28
  367:         add 	$30, $0, $0	;         mtc1    $0, $f29
[ 367] 0x900000001fc00a7c:  00 00 f0 20 add	s8,zero,zero
[ 367] 0x900000001fc00a80:  44 80 e8 00 mtc1	zero,$f29
  368:         add	$31, $0, $0	;         mtc1    $0, $f30
[ 368] 0x900000001fc00a84:  00 00 f8 20 add	ra,zero,zero
[ 368] 0x900000001fc00a88:  44 80 f0 00 mtc1	zero,$f30
  369:         mtc1    $0, $f31	        
[ 369] 0x900000001fc00a8c:  44 80 f8 00 mtc1	zero,$f31
  370: 	mult	$1, v0          # for hi lo registers;
[ 370] 0x900000001fc00a90:  00 22 00 18 mult	at,v0
  371: 
  372: 	/*
  373: 	 * Step 2: Initialize other half of busy bit table.
  374: 	 */
  375: 
  376:         li      v0, 32
[ 376] 0x900000001fc00a94:  24 02 00 20 li	v0,32
  377: 1:
  378:         mtc1    zero, $f0
[ 378] 0x900000001fc00a98:  44 80 00 00 mtc1	zero,$f0
  379: 	sub     v0, 1
[ 379] 0x900000001fc00a9c:  20 42 ff ff addi	v0,v0,-1
  380:         bgez    v0, 1b
[ 380] 0x900000001fc00aa0:  04 41 ff fd bgez	v0,0x900000001fc00a98
  381: 	nop
[ 381] 0x900000001fc00aa4:  00 00 00 00 nop
  382: 
  383: 
  384: 	/* Initialize the co-proc 0 registers */
  385: 
  386: 	MTC0(zero, C0_CAUSE)		/* 32-bit */
[ 386] 0x900000001fc00aa8:  40 80 68 00 mtc0	zero,cause
  387: 	MTC0(zero, C0_WATCHLO)
[ 387] 0x900000001fc00aac:  40 80 90 00 mtc0	zero,watchlo
  388: 	MTC0(zero, C0_WATCHHI)
[ 388] 0x900000001fc00ab0:  40 80 98 00 mtc0	zero,watchhi
  389: 	MTC0(zero, C0_TLBWIRED)
[ 389] 0x900000001fc00ab4:  40 80 30 00 mtc0	zero,wired
  390: 	MTC0(zero, C0_ECC)
[ 390] 0x900000001fc00ab8:  40 80 d0 00 mtc0	zero,ecc
  391: 	
  392: 	DMTC0(zero, C0_TLBLO_0)		/* 64 bit */
[ 392] 0x900000001fc00abc:  40 a0 10 00 dmtc0	zero,tlblo
  393: 	DMTC0(zero, C0_TLBLO_1)
[ 393] 0x900000001fc00ac0:  40 a0 18 00 dmtc0	zero,tlblo1
  394: 	DMTC0(zero, C0_CTXT)
[ 394] 0x900000001fc00ac4:  40 a0 20 00 dmtc0	zero,context
  395: 	DMTC0(zero, C0_COMPARE)
[ 395] 0x900000001fc00ac8:  40 a0 58 00 dmtc0	zero,compare
  396: 	DMTC0(zero, C0_EXTCTXT)
[ 396] 0x900000001fc00acc:  40 a0 a0 00 dmtc0	zero,c0r20
  397: 
  398: 
  399: 	/*
  400: 	 * Test coprocessor 1 registers that we plan to use ...
  401: 	 */
  402: 	LEDS(PLED_TESTCP1)
[ 402] 0x900000001fc00ad0:  00 00 00 00 nop
[ 402] 0x900000001fc00ad4:  34 04 00 02 ori	a0,zero,0x2
[ 402] 0x900000001fc00ad8:  3c 02 90 00 lui	v0,0x9000
[ 402] 0x900000001fc00adc:  00 02 14 38 dsll	v0,v0,16
[ 402] 0x900000001fc00ae0:  34 42 19 00 ori	v0,v0,0x1900
[ 402] 0x900000001fc00ae4:  00 02 14 38 dsll	v0,v0,16
[ 402] 0x900000001fc00ae8:  34 42 40 00 ori	v0,v0,0x4000
[ 402] 0x900000001fc00aec:  fc 44 00 00 sd	a0,0(v0)
  403: 	DMTBR(zero, BR_BSR)		/* Boot status register */
[ 403] 0x900000001fc00af0:  44 a0 00 00 dmtc1	zero,$f0
  404: 	DMTBR(zero, BR_DIAG)		/* Diagnostic value */
[ 404] 0x900000001fc00af4:  44 a0 28 00 dmtc1	zero,$f5
  405: 	DMFBR(v0, BR_BSR)		/* Read it back */
[ 405] 0x900000001fc00af8:  44 22 00 00 dmfc1	v0,$f0
  406: 	beq	v0,zero,1f		/* skip panic if OK */
[ 406] 0x900000001fc00afc:  10 40 00 05 beq	v0,zero,0x900000001fc00b14
  407: 	nop
[ 407] 0x900000001fc00b00:  00 00 00 00 nop
  408: 	FLASH(FLED_CP1)			/* Dead coproc # 1 */
[ 408] 0x900000001fc00b04:  00 00 00 00 nop
[ 408] 0x900000001fc00b08:  34 04 00 21 ori	a0,zero,0x21
[ 408] 0x900000001fc00b0c:  0f f0 0c 7f jal		flash_cc_leds
[ 408] 0x900000001fc00b10:  00 00 00 00 nop
  409: 1:	DMFBR(v0, BR_DIAG)
[ 409] 0x900000001fc00b14:  44 22 28 00 dmfc1	v0,$f5
  410: 	beq	v0,zero,1f
[ 410] 0x900000001fc00b18:  10 40 00 05 beq	v0,zero,0x900000001fc00b30
  411: 	nop
[ 411] 0x900000001fc00b1c:  00 00 00 00 nop
  412: 	FLASH(FLED_CP1)
[ 412] 0x900000001fc00b20:  00 00 00 00 nop
[ 412] 0x900000001fc00b24:  34 04 00 21 ori	a0,zero,0x21
[ 412] 0x900000001fc00b28:  0f f0 0c 7f jal		flash_cc_leds
[ 412] 0x900000001fc00b2c:  00 00 00 00 nop
  413: 1:	dli	v0,0xa5a5a5a5a5a5a5a5	/* Another try */
[ 413] 0x900000001fc00b30:  3c 02 a5 a5 lui	v0,0xa5a5
[ 413] 0x900000001fc00b34:  34 42 a5 a5 ori	v0,v0,0xa5a5
[ 413] 0x900000001fc00b38:  00 02 14 38 dsll	v0,v0,16
[ 413] 0x900000001fc00b3c:  34 42 a5 a5 ori	v0,v0,0xa5a5
[ 413] 0x900000001fc00b40:  00 02 14 38 dsll	v0,v0,16
[ 413] 0x900000001fc00b44:  34 42 a5 a5 ori	v0,v0,0xa5a5
  414: 	DMTBR(v0, BR_BSR)
[ 414] 0x900000001fc00b48:  44 a2 00 00 dmtc1	v0,$f0
  415: 	DMTBR(v0, BR_DIAG)
[ 415] 0x900000001fc00b4c:  44 a2 28 00 dmtc1	v0,$f5
  416: 	DMFBR(t0, BR_BSR)
[ 416] 0x900000001fc00b50:  44 2c 00 00 dmfc1	t0,$f0
  417: 	beq	v0,t0,1f		/* checks out ok */
[ 417] 0x900000001fc00b54:  10 4c 00 05 beq	v0,t0,0x900000001fc00b6c
  418: 	nop
[ 418] 0x900000001fc00b58:  00 00 00 00 nop
  419: 	FLASH(FLED_CP1)
[ 419] 0x900000001fc00b5c:  00 00 00 00 nop
[ 419] 0x900000001fc00b60:  34 04 00 21 ori	a0,zero,0x21
[ 419] 0x900000001fc00b64:  0f f0 0c 7f jal		flash_cc_leds
[ 419] 0x900000001fc00b68:  00 00 00 00 nop
  420: 1:	DMFBR(t0, BR_DIAG)
[ 420] 0x900000001fc00b6c:  44 2c 28 00 dmfc1	t0,$f5
  421: 	beq	v0,t0,1f
[ 421] 0x900000001fc00b70:  10 4c 00 05 beq	v0,t0,0x900000001fc00b88
  422: 	nop
[ 422] 0x900000001fc00b74:  00 00 00 00 nop
  423: 	FLASH(FLED_CP1)
[ 423] 0x900000001fc00b78:  00 00 00 00 nop
[ 423] 0x900000001fc00b7c:  34 04 00 21 ori	a0,zero,0x21
[ 423] 0x900000001fc00b80:  0f f0 0c 7f jal		flash_cc_leds
[ 423] 0x900000001fc00b84:  00 00 00 00 nop
  424: 1:		
  425: 	/*
  426: 	 * Assume Coproc #1 (boot registers) is working, and initialize 
  427: 	 * all the registers.
  428: 	 */
  429: 	DMTBR(zero, BR_BSR)
[ 429] 0x900000001fc00b88:  44 a0 00 00 dmtc1	zero,$f0
  430: 	DMTBR(zero, BR_NOFAULT)
[ 430] 0x900000001fc00b8c:  44 a0 08 00 dmtc1	zero,$f1
  431: 	DMTBR(zero, BR_ASMHNDLR)
[ 431] 0x900000001fc00b90:  44 a0 10 00 dmtc1	zero,$f2
  432: 	DMTBR(zero, BR_DUARTBASE)
[ 432] 0x900000001fc00b94:  44 a0 18 00 dmtc1	zero,$f3
  433: 	DMTBR(zero, BR_DIAG)
[ 433] 0x900000001fc00b98:  44 a0 28 00 dmtc1	zero,$f5
  434: 	jal	flushTlb
[ 434] 0x900000001fc00b9c:  0f f0 17 47 jal		flushTlb
  435: 	nop
[ 435] 0x900000001fc00ba0:  00 00 00 00 nop
  436: 	move	ra,t1
[ 436] 0x900000001fc00ba4:  01 a0 f8 25 move	ra,t1
  437: 	j	ra
[ 437] 0x900000001fc00ba8:  03 e0 00 08 jr	ra
  438: 	nop
[ 438] 0x900000001fc00bac:  00 00 00 00 nop
  439: 	.set	reorder
  440: 	END(initializeCPU)
  441: 
  442: /* 
  443:  * Function: 	InitializeIP25
  444:  * Purpose:	To initialize the IP25 to a known state after diags
  445:  *		have been run or the kernel returned control to
  446:  *		us.
  447:  * Parameters:	none
  448:  * Returns:	nothing
  449:  * Notes:	uses a, t, v, s0, at
  450:  */
  451: LEAF(initializeIP25)
  452: 	.set	noreorder
  453: 	move	s0,ra
initializeIP25:
[ 453] 0x900000001fc00bb0:  03 e0 80 25 move	s0,ra
  454: 	dli	a0,EV_ERTOIP
[ 454] 0x900000001fc00bb4:  3c 04 90 00 lui	a0,0x9000
[ 454] 0x900000001fc00bb8:  00 04 24 38 dsll	a0,a0,16
[ 454] 0x900000001fc00bbc:  34 84 18 00 ori	a0,a0,0x1800
[ 454] 0x900000001fc00bc0:  00 04 24 38 dsll	a0,a0,16
[ 454] 0x900000001fc00bc4:  34 84 09 00 ori	a0,a0,0x900
  455: 	ld	a0,0(a0)
[ 455] 0x900000001fc00bc8:  dc 84 00 00 ld	a0,0(a0)
  456: 	DMTBR(a0,BR_ERTOIP)
[ 456] 0x900000001fc00bcc:  44 a4 20 00 dmtc1	a0,$f4
  457: 	jal	invalidateIDcache	/* Clear Instruction/Data cache */
[ 457] 0x900000001fc00bd0:  0f f0 07 f8 jal		invalidateIDcache
  458: 	nop	
[ 458] 0x900000001fc00bd4:  00 00 00 00 nop
  459: 	jal	invalidateScache	/* Clear secondary cache */
[ 459] 0x900000001fc00bd8:  0f f0 08 c3 jal		invalidateScache
  460: 	nop
[ 460] 0x900000001fc00bdc:  00 00 00 00 nop
  461:         DPRINT("Zeroing ...... \n\r");
  462: 	dli	a0, EV_IGRMASK		/* Turn off all Interrupt Groups */
[ 462] 0x900000001fc00be0:  3c 04 90 00 lui	a0,0x9000
[ 462] 0x900000001fc00be4:  00 04 24 38 dsll	a0,a0,16
[ 462] 0x900000001fc00be8:  34 84 18 00 ori	a0,a0,0x1800
[ 462] 0x900000001fc00bec:  00 04 24 38 dsll	a0,a0,16
[ 462] 0x900000001fc00bf0:  34 84 08 38 ori	a0,a0,0x838
  463: 	sd	zero, 0(a0)		
[ 463] 0x900000001fc00bf4:  fc 80 00 00 sd	zero,0(a0)
  464: 	dli	a0, EV_ILE		/* Disable interrupts */
[ 464] 0x900000001fc00bf8:  3c 04 90 00 lui	a0,0x9000
[ 464] 0x900000001fc00bfc:  00 04 24 38 dsll	a0,a0,16
[ 464] 0x900000001fc00c00:  34 84 18 00 ori	a0,a0,0x1800
[ 464] 0x900000001fc00c04:  00 04 24 38 dsll	a0,a0,16
[ 464] 0x900000001fc00c08:  34 84 08 40 ori	a0,a0,0x840
  465: 	sd	zero, 0(a0)
[ 465] 0x900000001fc00c0c:  fc 80 00 00 sd	zero,0(a0)
  466: 	dli	a0, EV_CIPL124		/* Clear all level 1,2 ints */
[ 466] 0x900000001fc00c10:  3c 04 90 00 lui	a0,0x9000
[ 466] 0x900000001fc00c14:  00 04 24 38 dsll	a0,a0,16
[ 466] 0x900000001fc00c18:  34 84 18 00 ori	a0,a0,0x1800
[ 466] 0x900000001fc00c1c:  00 04 24 38 dsll	a0,a0,16
[ 466] 0x900000001fc00c20:  34 84 08 50 ori	a0,a0,0x850
  467: 	sd	zero, 0(a0)
[ 467] 0x900000001fc00c24:  fc 80 00 00 sd	zero,0(a0)
  468: 	dli	a0, EV_CERTOIP		/* Clear any error states */
[ 468] 0x900000001fc00c28:  3c 04 90 00 lui	a0,0x9000
[ 468] 0x900000001fc00c2c:  00 04 24 38 dsll	a0,a0,16
[ 468] 0x900000001fc00c30:  34 84 18 00 ori	a0,a0,0x1800
[ 468] 0x900000001fc00c34:  00 04 24 38 dsll	a0,a0,16
[ 468] 0x900000001fc00c38:  34 84 09 08 ori	a0,a0,0x908
  469:         dli	v0,-1
[ 469] 0x900000001fc00c3c:  24 02 ff ff li	v0,-1
  470: 	sd	v0, 0(a0)
[ 470] 0x900000001fc00c40:  fc 82 00 00 sd	v0,0(a0)
  471: 	dli	a0, EV_GRCNTL
[ 471] 0x900000001fc00c44:  3c 04 90 00 lui	a0,0x9000
[ 471] 0x900000001fc00c48:  00 04 24 38 dsll	a0,a0,16
[ 471] 0x900000001fc00c4c:  34 84 18 00 ori	a0,a0,0x1800
[ 471] 0x900000001fc00c50:  00 04 24 38 dsll	a0,a0,16
[ 471] 0x900000001fc00c54:  34 84 03 08 ori	a0,a0,0x308
  472: 	dli	v0, EV_GRCNTL_ENABLE+EV_GRCNTL_WS
[ 472] 0x900000001fc00c58:  24 02 00 03 li	v0,3
  473: 	sd	v0,0(a0)		/* Enable WG - for accelerated only */
[ 473] 0x900000001fc00c5c:  fc 82 00 00 sd	v0,0(a0)
  474: 	dli	a0, EV_ERADDR		/* Clear any errors */
[ 474] 0x900000001fc00c60:  3c 04 90 00 lui	a0,0x9000
[ 474] 0x900000001fc00c64:  00 04 24 38 dsll	a0,a0,16
[ 474] 0x900000001fc00c68:  34 84 18 00 ori	a0,a0,0x1800
[ 474] 0x900000001fc00c6c:  00 04 24 38 dsll	a0,a0,16
[ 474] 0x900000001fc00c70:  34 84 09 18 ori	a0,a0,0x918
  475: 	sd	zero,0(a0)
[ 475] 0x900000001fc00c74:  fc 80 00 00 sd	zero,0(a0)
  476: 
  477: 	/*
  478: 	 * Figure out what to do about CC configuration. If we are running
  479: 	 * with 1 outstanding read, then disable the Abort Logic, since
  480: 	 * it is not required, and we are probably running this way because
  481: 	 * the abort logic is broken (as in rev D SCC). However, this
  482: 	 * affects ONLY rev D and greater SCCs.
  483: 	 */
  484: 	li	v0,EV_ECCSB_SWM		/* Start off with this for now */
[ 484] 0x900000001fc00c78:  24 02 00 08 li	v0,8
  485: 	.set	at
  486: 	GET_CC_REV(t0,t1)		/* t0 has revision - 0 -> X */
[ 486] 0x900000001fc00c7c:  3c 0c 90 00 lui	t0,0x9000
[ 486] 0x900000001fc00c80:  00 0c 64 38 dsll	t0,t0,16
[ 486] 0x900000001fc00c84:  35 8c 18 00 ori	t0,t0,0x1800
[ 486] 0x900000001fc00c88:  00 0c 64 38 dsll	t0,t0,16
[ 486] 0x900000001fc00c8c:  35 8c 00 08 ori	t0,t0,0x8
[ 486] 0x900000001fc00c90:  dd 8c 00 00 ld	t0,0(t0)
[ 486] 0x900000001fc00c94:  00 00 00 00 nop
[ 486] 0x900000001fc00c98:  31 8c 00 3f andi	t0,t0,0x3f
[ 486] 0x900000001fc00c9c:  31 8d 00 03 andi	t1,t0,0x3
[ 486] 0x900000001fc00ca0:  01 a0 68 21 addu	t1,t1,0
[ 486] 0x900000001fc00ca4:  00 0c 60 82 srl	t0,t0,2
[ 486] 0x900000001fc00ca8:  00 0d d9 80 sll	k1,t1,6
[ 486] 0x900000001fc00cac:  63 7b 00 20 daddi	k1,k1,32
[ 486] 0x900000001fc00cb0:  00 0c d2 c0 sll	k0,t0,11
[ 486] 0x900000001fc00cb4:  3c 01 90 00 lui	at,0x9000
[ 486] 0x900000001fc00cb8:  00 01 0c 38 dsll	at,at,16
[ 486] 0x900000001fc00cbc:  34 21 18 00 ori	at,at,0x1800
[ 486] 0x900000001fc00cc0:  00 01 0c 38 dsll	at,at,16
[ 486] 0x900000001fc00cc4:  34 21 80 00 ori	at,at,0x8000
[ 486] 0x900000001fc00cc8:  03 41 d0 2c dadd	k0,k0,at
[ 486] 0x900000001fc00ccc:  00 1b 60 2c dadd	t0,zero,k1
[ 486] 0x900000001fc00cd0:  00 0c 60 c0 sll	t0,t0,3
[ 486] 0x900000001fc00cd4:  03 4c d0 2c dadd	k0,k0,t0
[ 486] 0x900000001fc00cd8:  df 4c 00 00 ld	t0,0(k0)
[ 486] 0x900000001fc00cdc:  00 00 00 00 nop
[ 486] 0x900000001fc00ce0:  00 0c 67 3a dsrl	t0,t0,28
[ 486] 0x900000001fc00ce4:  31 8c 00 0f andi	t0,t0,0xf
  487: 	.set	noat
  488: 	sub	t0,3			/* 'A' - 'D' == 3 */
[ 488] 0x900000001fc00ce8:  21 8c ff fd addi	t0,t0,-3
  489: 	bltz	t0,1f			/* < Rev D - ignore */
[ 489] 0x900000001fc00cec:  05 80 00 07 bltz	t0,0x900000001fc00d0c
  490: 	nop
[ 490] 0x900000001fc00cf0:  00 00 00 00 nop
  491: 	
  492: 	/* Check if 1 outstanding read */
  493: 
  494: 	MFC0(t0, C0_CONFIG)
[ 494] 0x900000001fc00cf4:  40 0c 80 00 mfc0	t0,config
  495: 	and	t0,CONFIG_PM
[ 495] 0x900000001fc00cf8:  31 8c 01 80 andi	t0,t0,0x180
  496: 	srl	t0,CONFIG_PM_SHFT	/* # requests - 1 */
[ 496] 0x900000001fc00cfc:  00 0c 61 c2 srl	t0,t0,7
  497: 	bnez	t0,1f			/* More that 1 request */
[ 497] 0x900000001fc00d00:  15 80 00 02 bne	t0,zero,0x900000001fc00d0c
  498: 	nop
[ 498] 0x900000001fc00d04:  00 00 00 00 nop
  499: 	or	v0,EV_ECCSB_DIAL	/* disable aborts */
[ 499] 0x900000001fc00d08:  34 42 00 02 ori	v0,v0,0x2
  500: 1:	
  501: 	dli	a0, EV_ECCSB		/* Address */
[ 501] 0x900000001fc00d0c:  3c 04 90 00 lui	a0,0x9000
[ 501] 0x900000001fc00d10:  00 04 24 38 dsll	a0,a0,16
[ 501] 0x900000001fc00d14:  34 84 18 00 ori	a0,a0,0x1800
[ 501] 0x900000001fc00d18:  00 04 24 38 dsll	a0,a0,16
[ 501] 0x900000001fc00d1c:  34 84 09 10 ori	a0,a0,0x910
  502: 	sd	v0,0(a0)		/* Bang ! */
[ 502] 0x900000001fc00d20:  fc 82 00 00 sd	v0,0(a0)
  503: 
  504: 	.set	at	
  505: 	EV_GET_SPNUM(t0, t1)
[ 505] 0x900000001fc00d24:  3c 0c 90 00 lui	t0,0x9000
[ 505] 0x900000001fc00d28:  00 0c 64 38 dsll	t0,t0,16
[ 505] 0x900000001fc00d2c:  35 8c 18 00 ori	t0,t0,0x1800
[ 505] 0x900000001fc00d30:  00 0c 64 38 dsll	t0,t0,16
[ 505] 0x900000001fc00d34:  35 8c 00 08 ori	t0,t0,0x8
[ 505] 0x900000001fc00d38:  dd 8c 00 00 ld	t0,0(t0)
[ 505] 0x900000001fc00d3c:  00 00 00 00 nop
[ 505] 0x900000001fc00d40:  31 8c 00 3f andi	t0,t0,0x3f
[ 505] 0x900000001fc00d44:  31 8d 00 03 andi	t1,t0,0x3
[ 505] 0x900000001fc00d48:  01 a0 68 21 addu	t1,t1,0
[ 505] 0x900000001fc00d4c:  00 0c 60 82 srl	t0,t0,2
  506: 	EV_SET_PROCREG(t0, t1, EV_CFG_ECCHKDIS, zero)
[ 506] 0x900000001fc00d50:  00 0d d9 80 sll	k1,t1,6
[ 506] 0x900000001fc00d54:  63 7b 00 15 daddi	k1,k1,21
[ 506] 0x900000001fc00d58:  00 0c d2 c0 sll	k0,t0,11
[ 506] 0x900000001fc00d5c:  3c 01 90 00 lui	at,0x9000
[ 506] 0x900000001fc00d60:  00 01 0c 38 dsll	at,at,16
[ 506] 0x900000001fc00d64:  34 21 18 00 ori	at,at,0x1800
[ 506] 0x900000001fc00d68:  00 01 0c 38 dsll	at,at,16
[ 506] 0x900000001fc00d6c:  34 21 80 00 ori	at,at,0x8000
[ 506] 0x900000001fc00d70:  03 41 d0 2c dadd	k0,k0,at
[ 506] 0x900000001fc00d74:  00 1b d8 2c dadd	k1,zero,k1
[ 506] 0x900000001fc00d78:  00 1b d8 c0 sll	k1,k1,3
[ 506] 0x900000001fc00d7c:  03 5b d0 2c dadd	k0,k0,k1
[ 506] 0x900000001fc00d80:  00 00 d8 25 move	k1,zero
[ 506] 0x900000001fc00d84:  ff 5b 00 00 sd	k1,0(k0)
[ 506] 0x900000001fc00d88:  00 00 00 00 nop
  507: 	.set	noat
  508: 	
  509: 	DMTBR(zero, BR_BSR)		/* Clear BSR */
[ 509] 0x900000001fc00d8c:  44 a0 00 00 dmtc1	zero,$f0
  510: 	j	s0
[ 510] 0x900000001fc00d90:  02 00 00 08 jr	s0
  511:  	nop
[ 511] 0x900000001fc00d94:  00 00 00 00 nop
  512: 	.set	reorder
  513: 	END(initializeIP25)
  514: 	
  515: /*
  516:  * Function:	bevNmi
  517:  * Purpose:	Process an NMI interrupt
  518:  * Parameters:	none, assumes entered from boot vector.
  519:  * Returns:	doesn't
  520:  */
  521: LEAF(bevNmi)
  522: 	.set	noreorder
  523: 	/*
  524: 	 * Be sure FPU is enabled
  525: 	 */
  526: 	MFC0(k0, C0_SR)
bevNmi:
[ 526] 0x900000001fc00d98:  40 1a 60 00 mfc0	k0,sr
  527: 
  528: 	dli	k1, PROM_SR
[ 528] 0x900000001fc00d9c:  3c 1b 24 40 lui	k1,0x2440
[ 528] 0x900000001fc00da0:  37 7b 00 80 ori	k1,k1,0x80
  529: 	or	k0, k1
[ 529] 0x900000001fc00da4:  03 5b d0 25 or	k0,k0,k1
  530: 
  531: 	MTC0(k0, C0_SR)
[ 531] 0x900000001fc00da8:  40 9a 60 00 mtc0	k0,sr
  532: #if 1	
  533: 	li	k0,0xb9004000
[ 533] 0x900000001fc00dac:  3c 1a b9 00 lui	k0,0xb900
[ 533] 0x900000001fc00db0:  37 5a 40 00 ori	k0,k0,0x4000
  534: 
  535: 	DMFC0(k1,C0_ERROR_EPC)
[ 535] 0x900000001fc00db4:  40 3b f0 00 dmfc0	k1,errorepc
  536: 	sd	k1,8(k0)
[ 536] 0x900000001fc00db8:  ff 5b 00 08 sd	k1,8(k0)
  537: 	DMFC0(k1,C0_EPC)
[ 537] 0x900000001fc00dbc:  40 3b 70 00 dmfc0	k1,epc
  538: 	sd	k1,0x10(k0)
[ 538] 0x900000001fc00dc0:  ff 5b 00 10 sd	k1,16(k0)
  539: 	DMFC0(k1,C0_BADVADDR)
[ 539] 0x900000001fc00dc4:  40 3b 40 00 dmfc0	k1,badvaddr
  540: 	sd	k1,0x18(k0)
[ 540] 0x900000001fc00dc8:  ff 5b 00 18 sd	k1,24(k0)
  541: 	MFC0(k1, C0_CAUSE)
[ 541] 0x900000001fc00dcc:  40 1b 68 00 mfc0	k1,cause
  542: 	sd	k1,0x20(k0)
[ 542] 0x900000001fc00dd0:  ff 5b 00 20 sd	k1,32(k0)
  543: 	MFC0(k1, C0_SR)
[ 543] 0x900000001fc00dd4:  40 1b 60 00 mfc0	k1,sr
  544: 	sd	k1,0x28(k0)
[ 544] 0x900000001fc00dd8:  ff 5b 00 28 sd	k1,40(k0)
  545: 
  546: 	sd	AT,0x100(k0)
[ 546] 0x900000001fc00ddc:  ff 41 01 00 sd	at,256(k0)
  547: 	sd	v0,0x108(k0)
[ 547] 0x900000001fc00de0:  ff 42 01 08 sd	v0,264(k0)
  548: 	sd	v1,0x110(k0)
[ 548] 0x900000001fc00de4:  ff 43 01 10 sd	v1,272(k0)
  549: 	sd	a0,0x118(k0)
[ 549] 0x900000001fc00de8:  ff 44 01 18 sd	a0,280(k0)
  550: 	sd	a1,0x120(k0)
[ 550] 0x900000001fc00dec:  ff 45 01 20 sd	a1,288(k0)
  551: 	sd	a2,0x128(k0)
[ 551] 0x900000001fc00df0:  ff 46 01 28 sd	a2,296(k0)
  552: 	sd	a3,0x130(k0)
[ 552] 0x900000001fc00df4:  ff 47 01 30 sd	a3,304(k0)
  553: 	sd	a4,0x138(k0)
[ 553] 0x900000001fc00df8:  ff 48 01 38 sd	a4,312(k0)
  554: 	sd	a5,0x140(k0)
[ 554] 0x900000001fc00dfc:  ff 49 01 40 sd	a5,320(k0)
  555: 	sd	a6,0x148(k0)
[ 555] 0x900000001fc00e00:  ff 4a 01 48 sd	a6,328(k0)
  556: 	sd	a7,0x150(k0)
[ 556] 0x900000001fc00e04:  ff 4b 01 50 sd	a7,336(k0)
  557: 
  558: 	sd	t0,0x158(k0)
[ 558] 0x900000001fc00e08:  ff 4c 01 58 sd	t0,344(k0)
  559: 	sd	t1,0x160(k0)
[ 559] 0x900000001fc00e0c:  ff 4d 01 60 sd	t1,352(k0)
  560: 	sd	t2,0x168(k0)
[ 560] 0x900000001fc00e10:  ff 4e 01 68 sd	t2,360(k0)
  561: 	sd	t3,0x170(k0)
[ 561] 0x900000001fc00e14:  ff 4f 01 70 sd	t3,368(k0)
  562: 
  563: 	sd	s0,0x178(k0)
[ 563] 0x900000001fc00e18:  ff 50 01 78 sd	s0,376(k0)
  564: 	sd	s1,0x180(k0)
[ 564] 0x900000001fc00e1c:  ff 51 01 80 sd	s1,384(k0)
  565: 	sd	s2,0x188(k0)
[ 565] 0x900000001fc00e20:  ff 52 01 88 sd	s2,392(k0)
  566: 	sd	s3,0x190(k0)
[ 566] 0x900000001fc00e24:  ff 53 01 90 sd	s3,400(k0)
  567: 	sd	s4,0x198(k0)
[ 567] 0x900000001fc00e28:  ff 54 01 98 sd	s4,408(k0)
  568: 	sd	s5,0x1a0(k0)
[ 568] 0x900000001fc00e2c:  ff 55 01 a0 sd	s5,416(k0)
  569: 	sd	s6,0x1a8(k0)
[ 569] 0x900000001fc00e30:  ff 56 01 a8 sd	s6,424(k0)
  570: 	sd	s7,0x1b0(k0)
[ 570] 0x900000001fc00e34:  ff 57 01 b0 sd	s7,432(k0)
  571: 
  572: 	sd	t8,0x1c0(k0)
[ 572] 0x900000001fc00e38:  ff 58 01 c0 sd	t8,448(k0)
  573: 	sd	t9,0x1c8(k0)
[ 573] 0x900000001fc00e3c:  ff 59 01 c8 sd	t9,456(k0)
  574: 
  575: 	sd	gp,0x1d0(k0)
[ 575] 0x900000001fc00e40:  ff 5c 01 d0 sd	gp,464(k0)
  576: 	sd	sp,0x1d8(k0)
[ 576] 0x900000001fc00e44:  ff 5d 01 d8 sd	sp,472(k0)
  577: 	sd	s8,0x1e0(k0)
[ 577] 0x900000001fc00e48:  ff 5e 01 e0 sd	s8,480(k0)
  578: 	sd	ra,0x1e8(k0)
[ 578] 0x900000001fc00e4c:  ff 5f 01 e8 sd	ra,488(k0)
  579: #endif
  580: 
  581: 	SETPC()
[ 581] 0x900000001fc00e50:  3c 1a 90 00 lui	k0,0x9000
[ 581] 0x900000001fc00e54:  67 5a 00 00 daddiu	k0,k0,0
[ 581] 0x900000001fc00e58:  00 1a d4 38 dsll	k0,k0,16
[ 581] 0x900000001fc00e5c:  67 5a 1f c0 daddiu	k0,k0,8128
[ 581] 0x900000001fc00e60:  00 1a d4 38 dsll	k0,k0,16
[ 581] 0x900000001fc00e64:  67 5a 0e 70 daddiu	k0,k0,3696
[ 581] 0x900000001fc00e68:  03 40 00 08 jr	k0
[ 581] 0x900000001fc00e6c:  00 00 00 00 nop
  582: 
  583: 	DMTBR(zero, BR_NOFAULT)		/* Turn off no fault */
[ 583] 0x900000001fc00e70:  44 a0 08 00 dmtc1	zero,$f1
  584: 	dla	k0, bevNmiFailedAccess	/* Jump-to on exception */
[ 584] 0x900000001fc00e74:  3c 1a 90 00 lui	k0,0x9000
[ 584] 0x900000001fc00e78:  67 5a 00 00 daddiu	k0,k0,0
[ 584] 0x900000001fc00e7c:  00 1a d4 38 dsll	k0,k0,16
[ 584] 0x900000001fc00e80:  67 5a 1f c0 daddiu	k0,k0,8128
[ 584] 0x900000001fc00e84:  00 1a d4 38 dsll	k0,k0,16
[ 584] 0x900000001fc00e88:  67 5a 0f f4 daddiu	k0,k0,4084
  585: 	DMTBR(k0, BR_ASMHNDLR)		/* Set up assembler handler */
[ 585] 0x900000001fc00e8c:  44 ba 10 00 dmtc1	k0,$f2
  586: 	/*
  587: 	 * Check if host has NMI vector set that we sould branch to.
  588: 	 * If yes, go there. This access may fail, in which case we
  589: 	 * branch to the ASMHDLR.
  590: 	 */
  591: 
  592: 	dli	k0, GDA_ADDR		/* Global data area */
[ 592] 0x900000001fc00e90:  3c 1a 90 00 lui	k0,0x9000
[ 592] 0x900000001fc00e94:  00 1a d0 3c dsll32	k0,k0,0
[ 592] 0x900000001fc00e98:  37 5a 04 00 ori	k0,k0,0x400
  593: 	lw	k0, G_MAGICOFF(k0)	/* Check magic number */
[ 593] 0x900000001fc00e9c:  8f 5a 00 00 lw	k0,0(k0)
  594: 	li	k1, GDA_MAGIC
[ 594] 0x900000001fc00ea0:  3c 1b 58 46 lui	k1,0x5846
[ 594] 0x900000001fc00ea4:  37 7b 45 52 ori	k1,k1,0x4552
  595: 	bne	k0,k1,bevNmiBadGDA	/* Hmmm - bummer */
[ 595] 0x900000001fc00ea8:  17 5b 00 6e bne	k0,k1,0x900000001fc01064
  596: 	nop
[ 596] 0x900000001fc00eac:  00 00 00 00 nop
  597: 
  598: 	dli	k0, GDA_ADDR		/* Reload GDA address */
[ 598] 0x900000001fc00eb0:  3c 1a 90 00 lui	k0,0x9000
[ 598] 0x900000001fc00eb4:  00 1a d0 3c dsll32	k0,k0,0
[ 598] 0x900000001fc00eb8:  37 5a 04 00 ori	k0,k0,0x400
  599: 	lw	k1, G_NMIVECOFF(k0)	/* Load the vector */
[ 599] 0x900000001fc00ebc:  8f 5b 00 08 lw	k1,8(k0)
  600: 	beqz	k1, 2f			/* If vec is zero, just goto pod */
[ 600] 0x900000001fc00ec0:  13 60 00 1e beq	k1,zero,0x900000001fc00f3c
  601: 	nop
[ 601] 0x900000001fc00ec4:  00 00 00 00 nop
  602: 1:
  603: 	dli	k0, EV_SCRATCH
[ 603] 0x900000001fc00ec8:  3c 1a 90 00 lui	k0,0x9000
[ 603] 0x900000001fc00ecc:  00 1a d4 38 dsll	k0,k0,16
[ 603] 0x900000001fc00ed0:  37 5a 18 00 ori	k0,k0,0x1800
[ 603] 0x900000001fc00ed4:  00 1a d4 38 dsll	k0,k0,16
[ 603] 0x900000001fc00ed8:  37 5a 05 00 ori	k0,k0,0x500
  604: 	sd	k1, 0(k0)
[ 604] 0x900000001fc00edc:  ff 5b 00 00 sd	k1,0(k0)
  605: 
  606: 	/* Set LEDS using k0/k1 only */
  607: 	
  608: 	li	k0, PLED_NMI
[ 608] 0x900000001fc00ee0:  24 1a 00 2a li	k0,42
  609: 	dli	k1, EV_LED_BASE
[ 609] 0x900000001fc00ee4:  3c 1b 90 00 lui	k1,0x9000
[ 609] 0x900000001fc00ee8:  00 1b dc 38 dsll	k1,k1,16
[ 609] 0x900000001fc00eec:  37 7b 19 00 ori	k1,k1,0x1900
[ 609] 0x900000001fc00ef0:  00 1b dc 38 dsll	k1,k1,16
[ 609] 0x900000001fc00ef4:  37 7b 40 00 ori	k1,k1,0x4000
  610: 	sd	k0, 0(k1)		/* Set the LEDs to NMI jump value */
[ 610] 0x900000001fc00ef8:  ff 7a 00 00 sd	k0,0(k1)
  611: 
  612: 	/*
  613: 	 * wait for all to come through, then zero and launch.
  614: 	 */
  615: 	li	k0,1000000
[ 615] 0x900000001fc00efc:  3c 1a 00 0f lui	k0,0xf
[ 615] 0x900000001fc00f00:  37 5a 42 40 ori	k0,k0,0x4240
  616: 3:	
  617: 	bnez	k0,3b
[ 617] 0x900000001fc00f04:  17 40 ff ff bne	k0,zero,0x900000001fc00f04
  618: 	sub	k0,1
[ 618] 0x900000001fc00f08:  23 5a ff ff addi	k0,k0,-1
  619: 	dli	k0,GDA_ADDR
[ 619] 0x900000001fc00f0c:  3c 1a 90 00 lui	k0,0x9000
[ 619] 0x900000001fc00f10:  00 1a d0 3c dsll32	k0,k0,0
[ 619] 0x900000001fc00f14:  37 5a 04 00 ori	k0,k0,0x400
  620: 	sw	zero,G_NMIVECOFF(k0)
[ 620] 0x900000001fc00f18:  af 40 00 08 sw	zero,8(k0)
  621: 
  622: 	/*
  623: 	 * Now on to user ....
  624: 	 */
  625: 	
  626: 	dli	k0, EV_SCRATCH
[ 626] 0x900000001fc00f1c:  3c 1a 90 00 lui	k0,0x9000
[ 626] 0x900000001fc00f20:  00 1a d4 38 dsll	k0,k0,16
[ 626] 0x900000001fc00f24:  37 5a 18 00 ori	k0,k0,0x1800
[ 626] 0x900000001fc00f28:  00 1a d4 38 dsll	k0,k0,16
[ 626] 0x900000001fc00f2c:  37 5a 05 00 ori	k0,k0,0x500
  627: 	ld	k1, 0(k0)
[ 627] 0x900000001fc00f30:  df 5b 00 00 ld	k1,0(k0)
  628: 	j	k1			/* Off to OS land .... */
[ 628] 0x900000001fc00f34:  03 60 00 08 jr	k1
  629: 	nop
[ 629] 0x900000001fc00f38:  00 00 00 00 nop
  630: 2:
  631: 	/*
  632: 	 * Save away our registers ...
  633: 	 */
  634: 	DMTC1(ra,RA_FP)
[ 634] 0x900000001fc00f3c:  44 bf f8 00 dmtc1	ra,$f31
  635: 	jal	saveGprs
[ 635] 0x900000001fc00f40:  0f f0 15 c3 jal		saveGprs
  636: 	nop
[ 636] 0x900000001fc00f44:  00 00 00 00 nop
  637: 	
  638: 	/*
  639: 	 * No NMI vector set, so we go to pod mode - check who is
  640: 	 * master.
  641: 	 */
  642: 	dli	k0,GDA_ADDR
[ 642] 0x900000001fc00f48:  3c 1a 90 00 lui	k0,0x9000
[ 642] 0x900000001fc00f4c:  00 1a d0 3c dsll32	k0,k0,0
[ 642] 0x900000001fc00f50:  37 5a 04 00 ori	k0,k0,0x400
  643: 	lw	k0,G_MASTEROFF(k0)	/* pick up master CPU # */
[ 643] 0x900000001fc00f54:  8f 5a 00 10 lw	k0,16(k0)
  644: 	dli	k1, EV_ERTOIP
[ 644] 0x900000001fc00f58:  3c 1b 90 00 lui	k1,0x9000
[ 644] 0x900000001fc00f5c:  00 1b dc 38 dsll	k1,k1,16
[ 644] 0x900000001fc00f60:  37 7b 18 00 ori	k1,k1,0x1800
[ 644] 0x900000001fc00f64:  00 1b dc 38 dsll	k1,k1,16
[ 644] 0x900000001fc00f68:  37 7b 09 00 ori	k1,k1,0x900
  645: 	ld	k1, 0(k1)
[ 645] 0x900000001fc00f6c:  df 7b 00 00 ld	k1,0(k1)
  646: 	DMTBR(k1, BR_ERTOIP)
[ 646] 0x900000001fc00f70:  44 bb 20 00 dmtc1	k1,$f4
  647: 	dli	k1,EV_SPNUM
[ 647] 0x900000001fc00f74:  3c 1b 90 00 lui	k1,0x9000
[ 647] 0x900000001fc00f78:  00 1b dc 38 dsll	k1,k1,16
[ 647] 0x900000001fc00f7c:  37 7b 18 00 ori	k1,k1,0x1800
[ 647] 0x900000001fc00f80:  00 1b dc 38 dsll	k1,k1,16
[ 647] 0x900000001fc00f84:  37 7b 00 08 ori	k1,k1,0x8
  648: 	ld	k1,0(k1)		/* Pick up our CPU # */
[ 648] 0x900000001fc00f88:  df 7b 00 00 ld	k1,0(k1)
  649: 	beq	k0,k1,bevNmiMaster
[ 649] 0x900000001fc00f8c:  13 5b 00 05 beq	k0,k1,0x900000001fc00fa4
  650: 	nop
[ 650] 0x900000001fc00f90:  00 00 00 00 nop
  651: 	/*
  652: 	 * We are a slave.
  653: 	 */
  654: 	DPRINT("CPU running in slave mode\r\n");
  655: 	li	a0,BSR_SLAVE
[ 655] 0x900000001fc00f94:  24 04 10 00 li	a0,4096
  656: 	DMTBR(a0, BR_BSR)
[ 656] 0x900000001fc00f98:  44 a4 00 00 dmtc1	a0,$f0
  657: 	j	prom_slave
[ 657] 0x900000001fc00f9c:  0b f0 0e e0 j		prom_slave
  658: 	nop
[ 658] 0x900000001fc00fa0:  00 00 00 00 nop
  659: 	
  660: bevNmiMaster:	
  661: 	/*
  662: 	 * We are master and an NMI occured. If we are in 
  663: 	 * manufacturing mode, use the CC uart, otherwise use the
  664: 	 * EPC uart. GDA Address in k0.
  665: 	 */
  666: 	dli	k0,GDA_ADDR
[ 666] 0x900000001fc00fa4:  3c 1a 90 00 lui	k0,0x9000
[ 666] 0x900000001fc00fa8:  00 1a d0 3c dsll32	k0,k0,0
[ 666] 0x900000001fc00fac:  37 5a 04 00 ori	k0,k0,0x400
  667: 	lw	k1,G_VDSOFF(k0)
[ 667] 0x900000001fc00fb0:  8f 5b 00 28 lw	k1,40(k0)
  668: 	andi	k1,VDS_MANUMODE		/* if Manumode */
[ 668] 0x900000001fc00fb4:  33 7b 00 80 andi	k1,k1,0x80
  669: 	bnez	k1,3f
[ 669] 0x900000001fc00fb8:  17 60 00 05 bne	k1,zero,0x900000001fc00fd0
  670: 	li	a0,BSR_CCUI+BSR_MANUMODE /* DELAY: use CC uart */
[ 670] 0x900000001fc00fbc:  24 04 00 42 li	a0,66
  671: 
  672: 	/*
  673: 	 * Attempt to use EPC uart. Reload the EPC pointer from the 
  674: 	 * GDA and hope it works. 
  675: 	 */
  676: 	ld	k1,G_EPC(k0)		/* EPC pointer */
[ 676] 0x900000001fc00fc0:  df 5b 00 40 ld	k1,64(k0)
  677: 	beqz	k1,bevNmiBadGDA
[ 677] 0x900000001fc00fc4:  13 60 00 27 beq	k1,zero,0x900000001fc01064
  678: 	li	a0,BSR_EPCUART+BSR_CCUI	/*           else EPC uart */
[ 678] 0x900000001fc00fc8:  24 04 01 02 li	a0,258
  679: 	DMTBR(k1, BR_DUARTBASE)
[ 679] 0x900000001fc00fcc:  44 bb 18 00 dmtc1	k1,$f3
  680: 3:	
  681: 	DMTBR(a0,BR_BSR)		/* BSR set up for uart routines */
[ 681] 0x900000001fc00fd0:  44 a4 00 00 dmtc1	a0,$f0
  682: 	MESSAGE(a1,"\r\n\n*** Non-maskable interrupt occurred. \r\n\n")
[ 682] 0x900000001fc00fd4:  3c 05 90 00 lui	a1,0x9000
[ 682] 0x900000001fc00fd8:  64 a5 00 00 daddiu	a1,a1,0
[ 682] 0x900000001fc00fdc:  00 05 2c 38 dsll	a1,a1,16
[ 682] 0x900000001fc00fe0:  64 a5 1f c1 daddiu	a1,a1,8129
[ 682] 0x900000001fc00fe4:  00 05 2c 38 dsll	a1,a1,16
[ 682] 0x900000001fc00fe8:  64 a5 71 63 daddiu	a1,a1,29027
  683: 	j	podMode
[ 683] 0x900000001fc00fec:  0b f0 15 fd j		podMode
  684: 	ori	a0,EVDIAG_NMI
[ 684] 0x900000001fc00ff0:  34 84 00 fc ori	a0,a0,0xfc
  685: 
  686: bevNmiFailedAccess:
  687: 	/*
  688: 	 * We land here if the memory access above failed, in that
  689: 	 * case clear memory access error.
  690: 	 */
  691: 	dli	k0,EV_CERTOIP
[ 691] 0x900000001fc00ff4:  3c 1a 90 00 lui	k0,0x9000
[ 691] 0x900000001fc00ff8:  00 1a d4 38 dsll	k0,k0,16
[ 691] 0x900000001fc00ffc:  37 5a 18 00 ori	k0,k0,0x1800
[ 691] 0x900000001fc01000:  00 1a d4 38 dsll	k0,k0,16
[ 691] 0x900000001fc01004:  37 5a 09 08 ori	k0,k0,0x908
  692: 	li	k1,0xffffffff /* CC_ERROR_MY_ADDR %%% */
[ 692] 0x900000001fc01008:  24 1b ff ff li	k1,-1
  693: 	sd	k1, 0(k0)
[ 693] 0x900000001fc0100c:  ff 5b 00 00 sd	k1,0(k0)
  694: 	
  695: 	DMFBR(a0, BR_BSR)		/* Don't use EPC serial port */
[ 695] 0x900000001fc01010:  44 24 00 00 dmfc1	a0,$f0
  696: 	li	a1, BSR_EPCUART
[ 696] 0x900000001fc01014:  24 05 01 00 li	a1,256
  697: 	not	a1
[ 697] 0x900000001fc01018:  00 a0 28 27 nor	a1,a1,zero
  698: 	and	a0,a1
[ 698] 0x900000001fc0101c:  00 85 20 24 and	a0,a0,a1
  699: 	DMTBR(a0, BR_BSR)
[ 699] 0x900000001fc01020:  44 a4 00 00 dmtc1	a0,$f0
  700: 
  701: 	SCPRINT("IP25Prom: NMI handler exception")
[ 701] 0x900000001fc01024:  3c 04 90 00 lui	a0,0x9000
[ 701] 0x900000001fc01028:  64 84 00 00 daddiu	a0,a0,0
[ 701] 0x900000001fc0102c:  00 04 24 38 dsll	a0,a0,16
[ 701] 0x900000001fc01030:  64 84 1f c1 daddiu	a0,a0,8129
[ 701] 0x900000001fc01034:  00 04 24 38 dsll	a0,a0,16
[ 701] 0x900000001fc01038:  64 84 71 8f daddiu	a0,a0,29071
[ 701] 0x900000001fc0103c:  0f f0 11 7c jal		sysctlr_message
[ 701] 0x900000001fc01040:  00 00 00 00 nop
  702: 	MESSAGE(a1, "\r\n\n*** NMI Interrupt (Exception handler)")
[ 702] 0x900000001fc01044:  3c 05 90 00 lui	a1,0x9000
[ 702] 0x900000001fc01048:  64 a5 00 00 daddiu	a1,a1,0
[ 702] 0x900000001fc0104c:  00 05 2c 38 dsll	a1,a1,16
[ 702] 0x900000001fc01050:  64 a5 1f c1 daddiu	a1,a1,8129
[ 702] 0x900000001fc01054:  00 05 2c 38 dsll	a1,a1,16
[ 702] 0x900000001fc01058:  64 a5 71 af daddiu	a1,a1,29103
  703: 	j	podMode
[ 703] 0x900000001fc0105c:  0b f0 15 fd j		podMode
  704: 	move	a0,zero
[ 704] 0x900000001fc01060:  00 00 20 25 move	a0,zero
  705: 
  706: bevNmiBadGDA:
  707: 	/*
  708: 	 * We land here if the memory access worked, but the GDA appears
  709: 	 * botched. All we can do is Flash the leds at this point.
  710: 	 */
  711: 	li	a0,BSR_CCUI		/* Let it at least try CC uart */
[ 711] 0x900000001fc01064:  24 04 00 02 li	a0,2
  712: 	DMTBR(a0,BR_BSR)		/* BSR set up for uart routines */
[ 712] 0x900000001fc01068:  44 a4 00 00 dmtc1	a0,$f0
  713: 	FLASH(FLED_BADGDA)
[ 713] 0x900000001fc0106c:  00 00 00 00 nop
[ 713] 0x900000001fc01070:  34 04 00 27 ori	a0,zero,0x27
[ 713] 0x900000001fc01074:  0f f0 0c 7f jal		flash_cc_leds
[ 713] 0x900000001fc01078:  00 00 00 00 nop
  714: 	.set	reorder
  715: 	END(bevNmi)
  716: 
  717: /*
  718:  * Function:	bevPanic
  719:  * Purpose:	Panic, or longjump back to the pod goober that set up
  720:  *	   	for this.
  721:  * Parameters:	a0 - panic code
  722:  *		a1 - pointer to panic string
  723:  *		a2 - diag code (used by sc_disp in pod_loop).
  724:  * Returns:	
  725:  */
  726: LEAF(bevPanic)
  727: 	.set	noreorder
  728: 	move	s0,a0			/* Save panic code */
bevPanic:
[ 728] 0x900000001fc0107c:  00 80 80 25 move	s0,a0
  729: 	move	s1,a1			/* Save panic string */
[ 729] 0x900000001fc01080:  00 a0 88 25 move	s1,a1
  730: 
  731: 	/*
  732: 	 * Check if the nofault vector is set, and if so, long jump
  733: 	 * back to where ever ...
  734: 	 */
  735: 
  736: 	DMFBR(a0, BR_NOFAULT)
[ 736] 0x900000001fc01084:  44 24 08 00 dmfc1	a0,$f1
  737: 	beqz	a0,1f			/* Not set, oh-oh */
[ 737] 0x900000001fc01088:  10 80 00 04 beq	a0,zero,0x900000001fc0109c
  738: 	nop				/* DELAY */
[ 738] 0x900000001fc0108c:  00 00 00 00 nop
  739: 	DMTBR(zero, BR_NOFAULT)
[ 739] 0x900000001fc01090:  44 a0 08 00 dmtc1	zero,$f1
  740: 	j	longjmp
[ 740] 0x900000001fc01094:  0b f0 18 6e j		longjmp
  741: 	ori	a1,zero,1		/* DELAY: Tell program */
[ 741] 0x900000001fc01098:  34 05 00 01 ori	a1,zero,0x1
  742: 1:
  743: 	/* No handler set, so do normal processing now */
  744: 
  745: 	DMFBR(a0, BR_BSR)
[ 745] 0x900000001fc0109c:  44 24 00 00 dmfc1	a0,$f0
  746: 	andi	a0,BSR_SLAVE		/* Check if we are slave */
[ 746] 0x900000001fc010a0:  30 84 10 00 andi	a0,a0,0x1000
  747: 	beqz	a0,2f
[ 747] 0x900000001fc010a4:  10 80 00 05 beq	a0,zero,0x900000001fc010bc
  748: 	nop
[ 748] 0x900000001fc010a8:  00 00 00 00 nop
  749: 	FLASH(s0)			/* Flash error */
[ 749] 0x900000001fc010ac:  00 00 00 00 nop
[ 749] 0x900000001fc010b0:  00 10 20 25 or	a0,zero,s0
[ 749] 0x900000001fc010b4:  0f f0 0c 7f jal		flash_cc_leds
[ 749] 0x900000001fc010b8:  00 00 00 00 nop
  750: 2:	
  751: 	move	a1,s1	
[ 751] 0x900000001fc010bc:  02 20 28 25 move	a1,s1
  752: 	j	podMode
[ 752] 0x900000001fc010c0:  0b f0 15 fd j		podMode
  753: 	ori	a0,zero, EVDIAG_PANIC	/* pass panic code */
[ 753] 0x900000001fc010c4:  34 04 00 fb ori	a0,zero,0xfb
  754: 
  755: 	.set	reorder	
  756: 	END(bevPanic)
  757: 
  758: /*
  759:  * Function: 	bevFlashLeds
  760:  * Purpose:	Entery point to allow kernel to request leds flash
  761:  * Parameters:	None
  762:  * Returns:	Never
  763:  */
  764: LEAF(bevFlashLeds)
  765: 	FLASH(FLED_OS)
bevFlashLeds:
[ 765] 0x900000001fc010c8:  00 00 00 00 nop
[ 765] 0x900000001fc010cc:  34 04 00 2f ori	a0,zero,0x2f
[ 765] 0x900000001fc010d0:  0f f0 0c 7f jal		flash_cc_leds
[ 765] 0x900000001fc010d4:  00 00 00 00 nop
[ 765] 0x900000001fc010d8:  00 00 00 00 nop
  766: 	END(bevFlashLeds)
  767: 
  768: /*
  769:  * Define:	BEV_LEAF
  770:  * Purpose: 	Defines the first "N" instructions of the vectored
  771:  * 		handlers, and the entry point.
  772:  * Parameters:	r - function name
  773:  *		_X - Bits to turn o in the SR.
  774:  * Notes:	In order to avoid trashing the registers saved in the fprs,
  775:  * 		we need to check for an asm fault handler immediately when
  776:  * 		we enter each of the exception handlers.  If one isn't set,
  777:  * 		we save the ra and then proceed.  This stuff is written as
  778:  * 		macro so that we won't lose the ra.
  779:  * 
  780:  */
  781: #define	BEV_LEAF(r, _X)			\
  782:         .set noreorder;			\
  783: 	LEAF(r);			\
  784: 	MFC0(k0,C0_SR);			\
  785: 	li	k1,SR_CU1+SR_FR+_X;	\
  786: 	or	k0,k1;			\
  787: 	MTC0(k0,C0_SR);			\
  788: 	SETPC();			\
  789: 	DMFBR(k0,BR_ASMHNDLR);		\
  790: 	DMTBR(zero, BR_ASMHNDLR);	\
  791: 	beqz	k0, 99f;		\
  792: 	nop;				\
  793: 	j	k0;			\
  794: 99:	dmtc1	ra, RA_FP;		\
  795: 	jal	saveGprs;		\
  796: 	nop;				\
  797: 	dli	k0,EV_ERTOIP;		\
  798: 	ld	k0,0(k0);		\
  799: 	DMTBR(k0,BR_ERTOIP);
  800:         .set reorder
  801: 
  802: /*
  803:  * Function:	bevGeneral
  804:  * Purpose:	Vector entry point for general exception vector.
  805:  * Parameters:	As per exceptions
  806:  * Returns:	Nothing
  807:  */
  808: BEV_LEAF(bevGeneral, 0)
bevGeneral:
[ 808] 0x900000001fc010dc:  40 1a 60 00 mfc0	k0,sr
[ 808] 0x900000001fc010e0:  3c 1b 24 00 lui	k1,0x2400
[ 808] 0x900000001fc010e4:  03 5b d0 25 or	k0,k0,k1
[ 808] 0x900000001fc010e8:  40 9a 60 00 mtc0	k0,sr
[ 808] 0x900000001fc010ec:  3c 1a 90 00 lui	k0,0x9000
[ 808] 0x900000001fc010f0:  67 5a 00 00 daddiu	k0,k0,0
[ 808] 0x900000001fc010f4:  00 1a d4 38 dsll	k0,k0,16
[ 808] 0x900000001fc010f8:  67 5a 1f c0 daddiu	k0,k0,8128
[ 808] 0x900000001fc010fc:  00 1a d4 38 dsll	k0,k0,16
[ 808] 0x900000001fc01100:  67 5a 11 0c daddiu	k0,k0,4364
[ 808] 0x900000001fc01104:  03 40 00 08 jr	k0
[ 808] 0x900000001fc01108:  00 00 00 00 nop
[ 808] 0x900000001fc0110c:  44 3a 10 00 dmfc1	k0,$f2
[ 808] 0x900000001fc01110:  44 a0 10 00 dmtc1	zero,$f2
[ 808] 0x900000001fc01114:  13 40 00 02 beq	k0,zero,0x900000001fc01120
[ 808] 0x900000001fc01118:  00 00 00 00 nop
[ 808] 0x900000001fc0111c:  03 40 00 08 jr	k0
[ 808] 0x900000001fc01120:  44 bf f8 00 dmtc1	ra,$f31
[ 808] 0x900000001fc01124:  0f f0 15 c3 jal		saveGprs
[ 808] 0x900000001fc01128:  00 00 00 00 nop
[ 808] 0x900000001fc0112c:  3c 1a 90 00 lui	k0,0x9000
[ 808] 0x900000001fc01130:  00 1a d4 38 dsll	k0,k0,16
[ 808] 0x900000001fc01134:  37 5a 18 00 ori	k0,k0,0x1800
[ 808] 0x900000001fc01138:  00 1a d4 38 dsll	k0,k0,16
[ 808] 0x900000001fc0113c:  37 5a 09 00 ori	k0,k0,0x900
[ 808] 0x900000001fc01140:  df 5a 00 00 ld	k0,0(k0)
[ 808] 0x900000001fc01144:  44 ba 20 00 dmtc1	k0,$f4
  809: 	/*
  810: 	 * We allow for "break" and "watch-point" exceptions....
  811: 	 */
  812: 	.set	at
  813: 	.set	noreorder
  814: 	MFC0(v0, C0_CAUSE)
[ 814] 0x900000001fc01148:  40 02 68 00 mfc0	v0,cause
  815: 	.set	reorder
  816: 	and	v0,CAUSE_EXCMASK
[ 816] 0x900000001fc0114c:  30 42 00 7c andi	v0,v0,0x7c
  817:         li	v1,EXC_WATCH
[ 817] 0x900000001fc01150:  24 03 00 5c li	v1,92
  818: 	beq	v0,v1,bevGeneralWatch
[ 818] 0x900000001fc01154:  10 43 00 0e beq	v0,v1,0x900000001fc01190
[ 818] 0x900000001fc01158:  00 00 00 00 nop
  819:         li	v1,EXC_BREAK
[ 819] 0x900000001fc0115c:  24 03 00 24 li	v1,36
  820: 	beq	v0,v1,bevGeneralBreak
[ 820] 0x900000001fc01160:  10 43 00 16 beq	v0,v1,0x900000001fc011bc
[ 820] 0x900000001fc01164:  00 00 00 00 nop
  821: bevGeneralPanic:	
  822: 	PANIC(FLED_GENERAL, "General Exception\r\n")
[ 822] 0x900000001fc01168:  3c 05 90 00 lui	a1,0x9000
[ 822] 0x900000001fc0116c:  64 a5 00 00 daddiu	a1,a1,0
[ 822] 0x900000001fc01170:  00 05 2c 38 dsll	a1,a1,16
[ 822] 0x900000001fc01174:  64 a5 1f c1 daddiu	a1,a1,8129
[ 822] 0x900000001fc01178:  00 05 2c 38 dsll	a1,a1,16
[ 822] 0x900000001fc0117c:  64 a5 71 d8 daddiu	a1,a1,29144
[ 822] 0x900000001fc01180:  24 04 00 2c li	a0,44
[ 822] 0x900000001fc01184:  0b f0 04 1f j		bevPanic
[ 822] 0x900000001fc01188:  00 00 00 00 nop
[ 822] 0x900000001fc0118c:  00 00 00 00 nop
  823: bevGeneralWatch:
  824:         PMESSAGE("*** Watchpoint");
[ 824] 0x900000001fc01190:  3c 04 90 00 lui	a0,0x9000
[ 824] 0x900000001fc01194:  64 84 00 00 daddiu	a0,a0,0
[ 824] 0x900000001fc01198:  00 04 24 38 dsll	a0,a0,16
[ 824] 0x900000001fc0119c:  64 84 1f c1 daddiu	a0,a0,8129
[ 824] 0x900000001fc011a0:  00 04 24 38 dsll	a0,a0,16
[ 824] 0x900000001fc011a4:  64 84 71 ec daddiu	a0,a0,29164
[ 824] 0x900000001fc011a8:  0f f0 15 03 jal		pod_puts
[ 824] 0x900000001fc011ac:  00 00 00 00 nop
[ 824] 0x900000001fc011b0:  00 00 00 00 nop
  825:         b	1f
[ 825] 0x900000001fc011b4:  10 00 00 0a b		0x900000001fc011e0
[ 825] 0x900000001fc011b8:  00 00 00 00 nop
  826: bevGeneralBreak:
  827:         PMESSAGE("*** Breakpoint");
[ 827] 0x900000001fc011bc:  3c 04 90 00 lui	a0,0x9000
[ 827] 0x900000001fc011c0:  64 84 00 00 daddiu	a0,a0,0
[ 827] 0x900000001fc011c4:  00 04 24 38 dsll	a0,a0,16
[ 827] 0x900000001fc011c8:  64 84 1f c1 daddiu	a0,a0,8129
[ 827] 0x900000001fc011cc:  00 04 24 38 dsll	a0,a0,16
[ 827] 0x900000001fc011d0:  64 84 71 fb daddiu	a0,a0,29179
[ 827] 0x900000001fc011d4:  0f f0 15 03 jal		pod_puts
[ 827] 0x900000001fc011d8:  00 00 00 00 nop
[ 827] 0x900000001fc011dc:  00 00 00 00 nop
  828: 1:
  829:         .set	noreorder
  830:         DMFC0(v0, C0_EPC)
[ 830] 0x900000001fc011e0:  40 22 70 00 dmfc0	v0,epc
  831:         .set	reorder
  832: 	PMESSAGE(" EPC:	"); PHEX(v0);
[ 832] 0x900000001fc011e4:  3c 04 90 00 lui	a0,0x9000
[ 832] 0x900000001fc011e8:  64 84 00 00 daddiu	a0,a0,0
[ 832] 0x900000001fc011ec:  00 04 24 38 dsll	a0,a0,16
[ 832] 0x900000001fc011f0:  64 84 1f c1 daddiu	a0,a0,8129
[ 832] 0x900000001fc011f4:  00 04 24 38 dsll	a0,a0,16
[ 832] 0x900000001fc011f8:  64 84 72 0a daddiu	a0,a0,29194
[ 832] 0x900000001fc011fc:  0f f0 15 03 jal		pod_puts
[ 832] 0x900000001fc01200:  00 00 00 00 nop
[ 832] 0x900000001fc01204:  00 00 00 00 nop
[ 832] 0x900000001fc01208:  00 02 20 25 or	a0,zero,v0
[ 832] 0x900000001fc0120c:  0f f0 14 f8 jal		pod_puthex64
[ 832] 0x900000001fc01210:  00 00 00 00 nop
[ 832] 0x900000001fc01214:  00 00 00 00 nop
  833: 2:	
  834: 	PMESSAGE("\r\n Continue (y/n)? ")
[ 834] 0x900000001fc01218:  3c 04 90 00 lui	a0,0x9000
[ 834] 0x900000001fc0121c:  64 84 00 00 daddiu	a0,a0,0
[ 834] 0x900000001fc01220:  00 04 24 38 dsll	a0,a0,16
[ 834] 0x900000001fc01224:  64 84 1f c1 daddiu	a0,a0,8129
[ 834] 0x900000001fc01228:  00 04 24 38 dsll	a0,a0,16
[ 834] 0x900000001fc0122c:  64 84 72 11 daddiu	a0,a0,29201
[ 834] 0x900000001fc01230:  0f f0 15 03 jal		pod_puts
[ 834] 0x900000001fc01234:  00 00 00 00 nop
[ 834] 0x900000001fc01238:  00 00 00 00 nop
  835: 	PGETC()
[ 835] 0x900000001fc0123c:  0f f0 15 0b jal		pod_getc
[ 835] 0x900000001fc01240:  00 00 00 00 nop
[ 835] 0x900000001fc01244:  00 00 00 00 nop
  836: 	beq	v0, 0x6e, bevGeneralPanic	/* 'n' */
[ 836] 0x900000001fc01248:  24 01 00 6e li	at,110
[ 836] 0x900000001fc0124c:  10 41 ff c6 beq	v0,at,0x900000001fc01168
[ 836] 0x900000001fc01250:  00 00 00 00 nop
  837: 	bne	v0, 0x79, 2b
[ 837] 0x900000001fc01254:  24 01 00 79 li	at,121
[ 837] 0x900000001fc01258:  14 41 ff ef bne	v0,at,0x900000001fc01218
[ 837] 0x900000001fc0125c:  00 00 00 00 nop
  838: 	/*
  839: 	 * Resotre registers and continue...
  840: 	 */
  841: 	j	podResume
[ 841] 0x900000001fc01260:  0b f0 15 e1 j		podResume
[ 841] 0x900000001fc01264:  00 00 00 00 nop
  842: 	END(bevGeneral)
  843: 
  844: 
  845: /*
  846:  * Function:	bevECC
  847:  * Purpose:	ECC handler
  848:  * Parameters:	none
  849:  * Returns:	Does not return, unless ASM handler is set.
  850:  */
  851: BEV_LEAF(bevECC, 0)
bevECC:
[ 851] 0x900000001fc01268:  40 1a 60 00 mfc0	k0,sr
[ 851] 0x900000001fc0126c:  3c 1b 24 00 lui	k1,0x2400
[ 851] 0x900000001fc01270:  03 5b d0 25 or	k0,k0,k1
[ 851] 0x900000001fc01274:  40 9a 60 00 mtc0	k0,sr
[ 851] 0x900000001fc01278:  3c 1a 90 00 lui	k0,0x9000
[ 851] 0x900000001fc0127c:  67 5a 00 00 daddiu	k0,k0,0
[ 851] 0x900000001fc01280:  00 1a d4 38 dsll	k0,k0,16
[ 851] 0x900000001fc01284:  67 5a 1f c0 daddiu	k0,k0,8128
[ 851] 0x900000001fc01288:  00 1a d4 38 dsll	k0,k0,16
[ 851] 0x900000001fc0128c:  67 5a 12 98 daddiu	k0,k0,4760
[ 851] 0x900000001fc01290:  03 40 00 08 jr	k0
[ 851] 0x900000001fc01294:  00 00 00 00 nop
[ 851] 0x900000001fc01298:  44 3a 10 00 dmfc1	k0,$f2
[ 851] 0x900000001fc0129c:  44 a0 10 00 dmtc1	zero,$f2
[ 851] 0x900000001fc012a0:  13 40 00 02 beq	k0,zero,0x900000001fc012ac
[ 851] 0x900000001fc012a4:  00 00 00 00 nop
[ 851] 0x900000001fc012a8:  03 40 00 08 jr	k0
[ 851] 0x900000001fc012ac:  44 bf f8 00 dmtc1	ra,$f31
[ 851] 0x900000001fc012b0:  0f f0 15 c3 jal		saveGprs
[ 851] 0x900000001fc012b4:  00 00 00 00 nop
[ 851] 0x900000001fc012b8:  3c 1a 90 00 lui	k0,0x9000
[ 851] 0x900000001fc012bc:  00 1a d4 38 dsll	k0,k0,16
[ 851] 0x900000001fc012c0:  37 5a 18 00 ori	k0,k0,0x1800
[ 851] 0x900000001fc012c4:  00 1a d4 38 dsll	k0,k0,16
[ 851] 0x900000001fc012c8:  37 5a 09 00 ori	k0,k0,0x900
[ 851] 0x900000001fc012cc:  df 5a 00 00 ld	k0,0(k0)
[ 851] 0x900000001fc012d0:  44 ba 20 00 dmtc1	k0,$f4
  852: 	.set	noreorder
  853: 	PANIC(FLED_ECC, "ECC Exception")
[ 853] 0x900000001fc012d4:  3c 05 90 00 lui	a1,0x9000
[ 853] 0x900000001fc012d8:  64 a5 00 00 daddiu	a1,a1,0
[ 853] 0x900000001fc012dc:  00 05 2c 38 dsll	a1,a1,16
[ 853] 0x900000001fc012e0:  64 a5 1f c1 daddiu	a1,a1,8129
[ 853] 0x900000001fc012e4:  00 05 2c 38 dsll	a1,a1,16
[ 853] 0x900000001fc012e8:  64 a5 72 25 daddiu	a1,a1,29221
[ 853] 0x900000001fc012ec:  24 04 00 28 li	a0,40
[ 853] 0x900000001fc012f0:  0b f0 04 1f j		bevPanic
[ 853] 0x900000001fc012f4:  00 00 00 00 nop
  854: 	.set	reorder
  855: 	END(bevECC)
  856: 
  857: /*
  858:  * Function:	bevXtlbRefill
  859:  * Purpose:	BEV exception handler for XTLB refill expcetion
  860:  * Parameters:	none
  861:  * Returns:	Panics, unless ASM handler set.
  862:  */
  863: BEV_LEAF(bevXtlbRefill, 0)
bevXtlbRefill:
[ 863] 0x900000001fc012f8:  40 1a 60 00 mfc0	k0,sr
[ 863] 0x900000001fc012fc:  3c 1b 24 00 lui	k1,0x2400
[ 863] 0x900000001fc01300:  03 5b d0 25 or	k0,k0,k1
[ 863] 0x900000001fc01304:  40 9a 60 00 mtc0	k0,sr
[ 863] 0x900000001fc01308:  3c 1a 90 00 lui	k0,0x9000
[ 863] 0x900000001fc0130c:  67 5a 00 00 daddiu	k0,k0,0
[ 863] 0x900000001fc01310:  00 1a d4 38 dsll	k0,k0,16
[ 863] 0x900000001fc01314:  67 5a 1f c0 daddiu	k0,k0,8128
[ 863] 0x900000001fc01318:  00 1a d4 38 dsll	k0,k0,16
[ 863] 0x900000001fc0131c:  67 5a 13 28 daddiu	k0,k0,4904
[ 863] 0x900000001fc01320:  03 40 00 08 jr	k0
[ 863] 0x900000001fc01324:  00 00 00 00 nop
[ 863] 0x900000001fc01328:  44 3a 10 00 dmfc1	k0,$f2
[ 863] 0x900000001fc0132c:  44 a0 10 00 dmtc1	zero,$f2
[ 863] 0x900000001fc01330:  13 40 00 02 beq	k0,zero,0x900000001fc0133c
[ 863] 0x900000001fc01334:  00 00 00 00 nop
[ 863] 0x900000001fc01338:  03 40 00 08 jr	k0
[ 863] 0x900000001fc0133c:  44 bf f8 00 dmtc1	ra,$f31
[ 863] 0x900000001fc01340:  0f f0 15 c3 jal		saveGprs
[ 863] 0x900000001fc01344:  00 00 00 00 nop
[ 863] 0x900000001fc01348:  3c 1a 90 00 lui	k0,0x9000
[ 863] 0x900000001fc0134c:  00 1a d4 38 dsll	k0,k0,16
[ 863] 0x900000001fc01350:  37 5a 18 00 ori	k0,k0,0x1800
[ 863] 0x900000001fc01354:  00 1a d4 38 dsll	k0,k0,16
[ 863] 0x900000001fc01358:  37 5a 09 00 ori	k0,k0,0x900
[ 863] 0x900000001fc0135c:  df 5a 00 00 ld	k0,0(k0)
[ 863] 0x900000001fc01360:  44 ba 20 00 dmtc1	k0,$f4
  864: 	PANIC(FLED_XTLBMISS, "XTLB Refill Exception")
[ 864] 0x900000001fc01364:  3c 05 90 00 lui	a1,0x9000
[ 864] 0x900000001fc01368:  64 a5 00 00 daddiu	a1,a1,0
[ 864] 0x900000001fc0136c:  00 05 2c 38 dsll	a1,a1,16
[ 864] 0x900000001fc01370:  64 a5 1f c1 daddiu	a1,a1,8129
[ 864] 0x900000001fc01374:  00 05 2c 38 dsll	a1,a1,16
[ 864] 0x900000001fc01378:  64 a5 72 33 daddiu	a1,a1,29235
[ 864] 0x900000001fc0137c:  24 04 00 29 li	a0,41
[ 864] 0x900000001fc01380:  0b f0 04 1f j		bevPanic
[ 864] 0x900000001fc01384:  00 00 00 00 nop
  865: 	END(bevXtlbRefill)
  866: 	
  867: /*
  868:  * Function:	notimplemented
  869:  * Purpose:	process a an unimplemented exception
  870:  * Parameters:	none
  871:  * Returns:	does not return
  872:  */
  873: BEV_LEAF(notimplemented, 0)
notimplemented:
[ 873] 0x900000001fc01388:  40 1a 60 00 mfc0	k0,sr
[ 873] 0x900000001fc0138c:  3c 1b 24 00 lui	k1,0x2400
[ 873] 0x900000001fc01390:  03 5b d0 25 or	k0,k0,k1
[ 873] 0x900000001fc01394:  40 9a 60 00 mtc0	k0,sr
[ 873] 0x900000001fc01398:  3c 1a 90 00 lui	k0,0x9000
[ 873] 0x900000001fc0139c:  67 5a 00 00 daddiu	k0,k0,0
[ 873] 0x900000001fc013a0:  00 1a d4 38 dsll	k0,k0,16
[ 873] 0x900000001fc013a4:  67 5a 1f c0 daddiu	k0,k0,8128
[ 873] 0x900000001fc013a8:  00 1a d4 38 dsll	k0,k0,16
[ 873] 0x900000001fc013ac:  67 5a 13 b8 daddiu	k0,k0,5048
[ 873] 0x900000001fc013b0:  03 40 00 08 jr	k0
[ 873] 0x900000001fc013b4:  00 00 00 00 nop
[ 873] 0x900000001fc013b8:  44 3a 10 00 dmfc1	k0,$f2
[ 873] 0x900000001fc013bc:  44 a0 10 00 dmtc1	zero,$f2
[ 873] 0x900000001fc013c0:  13 40 00 02 beq	k0,zero,0x900000001fc013cc
[ 873] 0x900000001fc013c4:  00 00 00 00 nop
[ 873] 0x900000001fc013c8:  03 40 00 08 jr	k0
[ 873] 0x900000001fc013cc:  44 bf f8 00 dmtc1	ra,$f31
[ 873] 0x900000001fc013d0:  0f f0 15 c3 jal		saveGprs
[ 873] 0x900000001fc013d4:  00 00 00 00 nop
[ 873] 0x900000001fc013d8:  3c 1a 90 00 lui	k0,0x9000
[ 873] 0x900000001fc013dc:  00 1a d4 38 dsll	k0,k0,16
[ 873] 0x900000001fc013e0:  37 5a 18 00 ori	k0,k0,0x1800
[ 873] 0x900000001fc013e4:  00 1a d4 38 dsll	k0,k0,16
[ 873] 0x900000001fc013e8:  37 5a 09 00 ori	k0,k0,0x900
[ 873] 0x900000001fc013ec:  df 5a 00 00 ld	k0,0(k0)
[ 873] 0x900000001fc013f0:  44 ba 20 00 dmtc1	k0,$f4
  874: 	PANIC(FLED_NOTIMPL, "Unimplemented Exception")
[ 874] 0x900000001fc013f4:  3c 05 90 00 lui	a1,0x9000
[ 874] 0x900000001fc013f8:  64 a5 00 00 daddiu	a1,a1,0
[ 874] 0x900000001fc013fc:  00 05 2c 38 dsll	a1,a1,16
[ 874] 0x900000001fc01400:  64 a5 1f c1 daddiu	a1,a1,8129
[ 874] 0x900000001fc01404:  00 05 2c 38 dsll	a1,a1,16
[ 874] 0x900000001fc01408:  64 a5 72 49 daddiu	a1,a1,29257
[ 874] 0x900000001fc0140c:  24 04 00 2d li	a0,45
[ 874] 0x900000001fc01410:  0b f0 04 1f j		bevPanic
[ 874] 0x900000001fc01414:  00 00 00 00 nop
  875: 	END(notimplemented)
  876: 
  877: /*
  878:  * Function:	bevRePod
  879:  * Purpose:	TO return to pod Uncached
  880:  * Parameters:	none
  881:  * Returns:	nothing
  882:  */
  883: BEV_LEAF(bevRePod, 0)
bevRePod:
[ 883] 0x900000001fc01418:  40 1a 60 00 mfc0	k0,sr
[ 883] 0x900000001fc0141c:  3c 1b 24 00 lui	k1,0x2400
[ 883] 0x900000001fc01420:  03 5b d0 25 or	k0,k0,k1
[ 883] 0x900000001fc01424:  40 9a 60 00 mtc0	k0,sr
[ 883] 0x900000001fc01428:  3c 1a 90 00 lui	k0,0x9000
[ 883] 0x900000001fc0142c:  67 5a 00 00 daddiu	k0,k0,0
[ 883] 0x900000001fc01430:  00 1a d4 38 dsll	k0,k0,16
[ 883] 0x900000001fc01434:  67 5a 1f c0 daddiu	k0,k0,8128
[ 883] 0x900000001fc01438:  00 1a d4 38 dsll	k0,k0,16
[ 883] 0x900000001fc0143c:  67 5a 14 48 daddiu	k0,k0,5192
[ 883] 0x900000001fc01440:  03 40 00 08 jr	k0
[ 883] 0x900000001fc01444:  00 00 00 00 nop
[ 883] 0x900000001fc01448:  44 3a 10 00 dmfc1	k0,$f2
[ 883] 0x900000001fc0144c:  44 a0 10 00 dmtc1	zero,$f2
[ 883] 0x900000001fc01450:  13 40 00 02 beq	k0,zero,0x900000001fc0145c
[ 883] 0x900000001fc01454:  00 00 00 00 nop
[ 883] 0x900000001fc01458:  03 40 00 08 jr	k0
[ 883] 0x900000001fc0145c:  44 bf f8 00 dmtc1	ra,$f31
[ 883] 0x900000001fc01460:  0f f0 15 c3 jal		saveGprs
[ 883] 0x900000001fc01464:  00 00 00 00 nop
[ 883] 0x900000001fc01468:  3c 1a 90 00 lui	k0,0x9000
[ 883] 0x900000001fc0146c:  00 1a d4 38 dsll	k0,k0,16
[ 883] 0x900000001fc01470:  37 5a 18 00 ori	k0,k0,0x1800
[ 883] 0x900000001fc01474:  00 1a d4 38 dsll	k0,k0,16
[ 883] 0x900000001fc01478:  37 5a 09 00 ori	k0,k0,0x900
[ 883] 0x900000001fc0147c:  df 5a 00 00 ld	k0,0(k0)
[ 883] 0x900000001fc01480:  44 ba 20 00 dmtc1	k0,$f4
  884: 
  885: 	dli	sp, (POD_STACKPADDR + POD_STACKSIZE) | K1BASE
[ 885] 0x900000001fc01484:  3c 1d 90 00 lui	sp,0x9000
[ 885] 0x900000001fc01488:  00 1d ec 38 dsll	sp,sp,16
[ 885] 0x900000001fc0148c:  37 bd 00 0f ori	sp,sp,0xf
[ 885] 0x900000001fc01490:  00 1d ec 38 dsll	sp,sp,16
[ 885] 0x900000001fc01494:  37 bd f0 00 ori	sp,sp,0xf000
  886: 	dli	a0,1
[ 886] 0x900000001fc01498:  24 04 00 01 li	a0,1
  887: 	move	a1,zero
[ 887] 0x900000001fc0149c:  00 00 28 25 move	a1,zero
  888: 	j	pod_loop
[ 888] 0x900000001fc014a0:  0b f0 19 1c j		pod_loop
  889: 	nop
[ 889] 0x900000001fc014a4:  00 00 00 00 nop
  890: 
  891: 	/* Doesn't return */
  892: 
  893: END(bevRePod)
  894: 
  895: /*
  896:  * Function:	bevIP25monExit
  897:  * Purpose:	To return to pod - flushing caches and running out of 
  898:  *		cache again.
  899:  * Parameters:	none
  900:  * Returns:	nothing
  901:  */
  902: BEV_LEAF(bevIP25monExit, 0)
bevIP25monExit:
[ 902] 0x900000001fc014a8:  40 1a 60 00 mfc0	k0,sr
[ 902] 0x900000001fc014ac:  3c 1b 24 00 lui	k1,0x2400
[ 902] 0x900000001fc014b0:  03 5b d0 25 or	k0,k0,k1
[ 902] 0x900000001fc014b4:  40 9a 60 00 mtc0	k0,sr
[ 902] 0x900000001fc014b8:  3c 1a 90 00 lui	k0,0x9000
[ 902] 0x900000001fc014bc:  67 5a 00 00 daddiu	k0,k0,0
[ 902] 0x900000001fc014c0:  00 1a d4 38 dsll	k0,k0,16
[ 902] 0x900000001fc014c4:  67 5a 1f c0 daddiu	k0,k0,8128
[ 902] 0x900000001fc014c8:  00 1a d4 38 dsll	k0,k0,16
[ 902] 0x900000001fc014cc:  67 5a 14 d8 daddiu	k0,k0,5336
[ 902] 0x900000001fc014d0:  03 40 00 08 jr	k0
[ 902] 0x900000001fc014d4:  00 00 00 00 nop
[ 902] 0x900000001fc014d8:  44 3a 10 00 dmfc1	k0,$f2
[ 902] 0x900000001fc014dc:  44 a0 10 00 dmtc1	zero,$f2
[ 902] 0x900000001fc014e0:  13 40 00 02 beq	k0,zero,0x900000001fc014ec
[ 902] 0x900000001fc014e4:  00 00 00 00 nop
[ 902] 0x900000001fc014e8:  03 40 00 08 jr	k0
[ 902] 0x900000001fc014ec:  44 bf f8 00 dmtc1	ra,$f31
[ 902] 0x900000001fc014f0:  0f f0 15 c3 jal		saveGprs
[ 902] 0x900000001fc014f4:  00 00 00 00 nop
[ 902] 0x900000001fc014f8:  3c 1a 90 00 lui	k0,0x9000
[ 902] 0x900000001fc014fc:  00 1a d4 38 dsll	k0,k0,16
[ 902] 0x900000001fc01500:  37 5a 18 00 ori	k0,k0,0x1800
[ 902] 0x900000001fc01504:  00 1a d4 38 dsll	k0,k0,16
[ 902] 0x900000001fc01508:  37 5a 09 00 ori	k0,k0,0x900
[ 902] 0x900000001fc0150c:  df 5a 00 00 ld	k0,0(k0)
[ 902] 0x900000001fc01510:  44 ba 20 00 dmtc1	k0,$f4
  903: 	jal	cacheFlush
[ 903] 0x900000001fc01514:  0f f0 0c 0d jal		cacheFlush
  904: 	nop
[ 904] 0x900000001fc01518:  00 00 00 00 nop
  905: 	jal	initializeCPU
[ 905] 0x900000001fc0151c:  0f f0 02 5a jal		initializeCPU
  906: 	nop
[ 906] 0x900000001fc01520:  00 00 00 00 nop
  907: 	jal	initializeIP25
[ 907] 0x900000001fc01524:  0f f0 02 ec jal		initializeIP25
  908: 	nop
[ 908] 0x900000001fc01528:  00 00 00 00 nop
  909: 	j	pod_loop
[ 909] 0x900000001fc0152c:  0b f0 19 1c j		pod_loop
  910: 	nop
[ 910] 0x900000001fc01530:  00 00 00 00 nop
  911: 
  912: 	/* Doesn't return */
  913: 
  914: END(bevIP25monExit)
  915: 
  916: /*
  917:  * Function:	bevCache
  918:  * Purpose:	BEV cache error handler
  919:  * Parameters:	none
  920:  * Returns:	does not return
  921:  * Notes:	Turn on the DE bit in hopes of actually being able
  922:  *		to spit out a message.
  923:  */
  924: BEV_LEAF(bevCache, SR_DE)
bevCache:
[ 924] 0x900000001fc01534:  40 1a 60 00 mfc0	k0,sr
[ 924] 0x900000001fc01538:  3c 1b 24 01 lui	k1,0x2401
[ 924] 0x900000001fc0153c:  03 5b d0 25 or	k0,k0,k1
[ 924] 0x900000001fc01540:  40 9a 60 00 mtc0	k0,sr
[ 924] 0x900000001fc01544:  3c 1a 90 00 lui	k0,0x9000
[ 924] 0x900000001fc01548:  67 5a 00 00 daddiu	k0,k0,0
[ 924] 0x900000001fc0154c:  00 1a d4 38 dsll	k0,k0,16
[ 924] 0x900000001fc01550:  67 5a 1f c0 daddiu	k0,k0,8128
[ 924] 0x900000001fc01554:  00 1a d4 38 dsll	k0,k0,16
[ 924] 0x900000001fc01558:  67 5a 15 64 daddiu	k0,k0,5476
[ 924] 0x900000001fc0155c:  03 40 00 08 jr	k0
[ 924] 0x900000001fc01560:  00 00 00 00 nop
[ 924] 0x900000001fc01564:  44 3a 10 00 dmfc1	k0,$f2
[ 924] 0x900000001fc01568:  44 a0 10 00 dmtc1	zero,$f2
[ 924] 0x900000001fc0156c:  13 40 00 02 beq	k0,zero,0x900000001fc01578
[ 924] 0x900000001fc01570:  00 00 00 00 nop
[ 924] 0x900000001fc01574:  03 40 00 08 jr	k0
[ 924] 0x900000001fc01578:  44 bf f8 00 dmtc1	ra,$f31
[ 924] 0x900000001fc0157c:  0f f0 15 c3 jal		saveGprs
[ 924] 0x900000001fc01580:  00 00 00 00 nop
[ 924] 0x900000001fc01584:  3c 1a 90 00 lui	k0,0x9000
[ 924] 0x900000001fc01588:  00 1a d4 38 dsll	k0,k0,16
[ 924] 0x900000001fc0158c:  37 5a 18 00 ori	k0,k0,0x1800
[ 924] 0x900000001fc01590:  00 1a d4 38 dsll	k0,k0,16
[ 924] 0x900000001fc01594:  37 5a 09 00 ori	k0,k0,0x900
[ 924] 0x900000001fc01598:  df 5a 00 00 ld	k0,0(k0)
[ 924] 0x900000001fc0159c:  44 ba 20 00 dmtc1	k0,$f4
  925: 	.set	reorder
  926: 	PANIC(FLED_CACHE, "Cache Error Exception")
[ 926] 0x900000001fc015a0:  3c 05 90 00 lui	a1,0x9000
[ 926] 0x900000001fc015a4:  64 a5 00 00 daddiu	a1,a1,0
[ 926] 0x900000001fc015a8:  00 05 2c 38 dsll	a1,a1,16
[ 926] 0x900000001fc015ac:  64 a5 1f c1 daddiu	a1,a1,8129
[ 926] 0x900000001fc015b0:  00 05 2c 38 dsll	a1,a1,16
[ 926] 0x900000001fc015b4:  64 a5 72 61 daddiu	a1,a1,29281
[ 926] 0x900000001fc015b8:  24 04 00 2e li	a0,46
[ 926] 0x900000001fc015bc:  0b f0 04 1f j		bevPanic
[ 926] 0x900000001fc015c0:  00 00 00 00 nop
[ 926] 0x900000001fc015c4:  00 00 00 00 nop
  927: 	END(bevCache)
  928: 
  929: #ifdef	SABLE
  930: LEAF(bevSuccess)
  931: 	.set	noreorder
  932:         ori         zero,  zero,  0x2222
  933:         ori         zero,  zero,  0x1111
  934:         ori         zero,  zero,  0x0000
  935:         .word       ((0xffff0 << 6) | 0x000D)
  936:         nop
  937: 	j	ra
  938: 	nop
  939: 	.set	reorder
  940: 	END(bevSuccess)
  941: #endif
  942: 
  943: LEAF(__spin)
  944: 	.set	reorder
  945: #if	!defined(SABLE)
  946: 	.set	noreorder
  947: 	li	a0,0x60000
__spin:
[ 947] 0x900000001fc015c8:  3c 04 00 06 lui	a0,0x6
  948: 1:	
  949: 	sub	a0,1
[ 949] 0x900000001fc015cc:  20 84 ff ff addi	a0,a0,-1
  950:         bgt	a0,zero,1b
[ 950] 0x900000001fc015d0:  1c 80 ff fe bgtz	a0,0x900000001fc015cc
  951:         nop
[ 951] 0x900000001fc015d4:  00 00 00 00 nop
  952: #endif
  953: 	j	ra
[ 953] 0x900000001fc015d8:  03 e0 00 08 jr	ra
       0x900000001fc015dc:  00 00 00 00 nop
       0x900000001fc015e0:  00 00 00 00 nop
       0x900000001fc015e4:  00 00 00 00 nop
       0x900000001fc015e8:  00 00 00 00 nop
       0x900000001fc015ec:  00 00 00 00 nop
       0x900000001fc015f0:  00 00 00 00 nop
       0x900000001fc015f4:  00 00 00 00 nop
       0x900000001fc015f8:  00 00 00 00 nop
       0x900000001fc015fc:  00 00 00 00 nop
Skipping source listing to line 136 of /cores/banyan/stand/arcs/IP25prom/pod_cache.s...
  137: /*
  138:  * Function: sCacheSize
  139:  * Purpose: To read and return the size of the secondary cache
  140:  * Parameters:
  141:  * Returns: Cache size in bytes in v0
  142:  * Clobbers: v0,v1
  143:  */
  144: LEAF(sCacheSize)
  145:         .set	noreorder
  146: 	MFC0(v1, C0_CONFIG)		# Pick of config register value
sCacheSize:
[ 146] 0x900000001fc01600:  40 03 80 00 mfc0	v1,config
  147: 	and	v1,CONFIG_SS		# isolate cache size
[ 147] 0x900000001fc01604:  3c 01 00 07 lui	at,0x7
[ 147] 0x900000001fc01608:  00 61 18 24 and	v1,v1,at
  148: 	srl	v1,CONFIG_SS_SHFT
[ 148] 0x900000001fc0160c:  00 03 1c 02 srl	v1,v1,16
  149: 	add	v1,CONFIG_SCACHE_POW2_BASE
[ 149] 0x900000001fc01610:  20 63 00 13 addi	v1,v1,19
  150: 	li	v0,1
[ 150] 0x900000001fc01614:  24 02 00 01 li	v0,1
  151: 	j	ra
[ 151] 0x900000001fc01618:  03 e0 00 08 jr	ra
  152: 	sll	v0,v1			# Calculate # bytes
[ 152] 0x900000001fc0161c:  00 62 10 04 sllv	v0,v0,v1
  153:         END(sCacheSize)
  154: /*
  155:  * Function: iCacheSize
  156:  * Purpose: To read and return the size of the primary instruction cache
  157:  * Parameters: none
  158:  * Returns: Cache size in bytes in v0
  159:  * Clobbers: v0,v1
  160:  */
  161: LEAF(iCacheSize)
  162: 	.set	noreorder
  163: 	MFC0(v1, C0_CONFIG)		# Pick of config register value
iCacheSize:
[ 163] 0x900000001fc01620:  40 03 80 00 mfc0	v1,config
  164: 	and	v1,CONFIG_IC		# isolate cache size
[ 164] 0x900000001fc01624:  24 01 00 07 li	at,7
[ 164] 0x900000001fc01628:  00 01 0f 78 dsll	at,at,29
[ 164] 0x900000001fc0162c:  00 61 18 24 and	v1,v1,at
  165: 	srl	v1,CONFIG_IC_SHFT
[ 165] 0x900000001fc01630:  00 03 1f 42 srl	v1,v1,29
  166: 	add	v1,CONFIG_PCACHE_POW2_BASE
[ 166] 0x900000001fc01634:  20 63 00 0c addi	v1,v1,12
  167: 	li	v0,1
[ 167] 0x900000001fc01638:  24 02 00 01 li	v0,1
  168: 	j	ra
[ 168] 0x900000001fc0163c:  03 e0 00 08 jr	ra
  169: 	sll	v0,v1			# Calculate # bytes
[ 169] 0x900000001fc01640:  00 62 10 04 sllv	v0,v0,v1
  170:         END(iCacheSize)
  171: 
  172: /*
  173:  * Function: dCacheSize
  174:  * Purpose: To read and return the size of the primary data cache
  175:  * Parameters: none
  176:  * Returns: Cache size in bytes in v0
  177:  * Clobbers: v0,v1
  178:  */
  179: LEAF(dCacheSize)
  180:         .set	noreorder
  181: 	MFC0(v1, C0_CONFIG)		# Pick up config register value
dCacheSize:
[ 181] 0x900000001fc01644:  40 03 80 00 mfc0	v1,config
  182: 	and	v1,CONFIG_DC		# isolate cache size
[ 182] 0x900000001fc01648:  3c 01 1c 00 lui	at,0x1c00
[ 182] 0x900000001fc0164c:  00 61 18 24 and	v1,v1,at
  183: 	srl	v1,CONFIG_DC_SHFT	
[ 183] 0x900000001fc01650:  00 03 1e 82 srl	v1,v1,26
  184: 	add	v1,CONFIG_PCACHE_POW2_BASE
[ 184] 0x900000001fc01654:  20 63 00 0c addi	v1,v1,12
  185: 	li	v0,1
[ 185] 0x900000001fc01658:  24 02 00 01 li	v0,1
  186: 	j	ra
[ 186] 0x900000001fc0165c:  03 e0 00 08 jr	ra
  187: 	sll	v0,v1			# Calculate # bytes
[ 187] 0x900000001fc01660:  00 62 10 04 sllv	v0,v0,v1
  188:         END(dCacheSize)
  189: 
  190: /*
  191:  * Function:	testIcache
  192:  * Purpose:	verify we can write and read the Icache.
  193:  * Parameters:	None
  194:  * Returns:	v0 = 0 - success
  195:  *		   = !0- failed
  196:  * Notes:	The data patterns 0xaaaaaaaaa and 0x55555555 are used
  197:  * 	        to try and check for bits stuck to 0 or 1.
  198:  */
  199: LEAF(testIcache)
  200: 	.set	noreorder
  201: 
  202: 	LEDS(PLED_TESTICACHE)
testIcache:
[ 202] 0x900000001fc01664:  00 00 00 00 nop
[ 202] 0x900000001fc01668:  34 04 00 03 ori	a0,zero,0x3
[ 202] 0x900000001fc0166c:  3c 02 90 00 lui	v0,0x9000
[ 202] 0x900000001fc01670:  00 02 14 38 dsll	v0,v0,16
[ 202] 0x900000001fc01674:  34 42 19 00 ori	v0,v0,0x1900
[ 202] 0x900000001fc01678:  00 02 14 38 dsll	v0,v0,16
[ 202] 0x900000001fc0167c:  34 42 40 00 ori	v0,v0,0x4000
[ 202] 0x900000001fc01680:  fc 44 00 00 sd	a0,0(v0)
  203: 
  204: 	/* Figure out the number of lines */
  205: 
  206: 	move	t0,ra			/* save our way home */
[ 206] 0x900000001fc01684:  03 e0 60 25 move	t0,ra
  207: 	jal	iCacheSize
[ 207] 0x900000001fc01688:  0f f0 05 88 jal		iCacheSize
  208: 	nop
[ 208] 0x900000001fc0168c:  00 00 00 00 nop
  209: 	move	ra,t0			/* And Back! */
[ 209] 0x900000001fc01690:  01 80 f8 25 move	ra,t0
  210: 	divu	t0,v0,CACHE_ILINE_SIZE*2 /* # lines in t0/# ways */
[ 210] 0x900000001fc01694:  00 02 61 c2 srl	t0,v0,7
  211: 
  212: 	dla	v0,icache_patternStart /* Set first pattern */
[ 212] 0x900000001fc01698:  3c 02 90 00 lui	v0,0x9000
[ 212] 0x900000001fc0169c:  64 42 00 00 daddiu	v0,v0,0
[ 212] 0x900000001fc016a0:  00 02 14 38 dsll	v0,v0,16
[ 212] 0x900000001fc016a4:  64 42 1f c1 daddiu	v0,v0,8129
[ 212] 0x900000001fc016a8:  00 02 14 38 dsll	v0,v0,16
[ 212] 0x900000001fc016ac:  64 42 73 48 daddiu	v0,v0,29512
  213: 1:
  214: 	/*
  215: 	 * Check if we are done at the top of the loop. This means that
  216: 	 * we can have NO test patterns if desired.
  217: 	 */
  218: 	dla	v1,icache_patternEnd
[ 218] 0x900000001fc016b0:  3c 03 90 00 lui	v1,0x9000
[ 218] 0x900000001fc016b4:  64 63 00 00 daddiu	v1,v1,0
[ 218] 0x900000001fc016b8:  00 03 1c 38 dsll	v1,v1,16
[ 218] 0x900000001fc016bc:  64 63 1f c1 daddiu	v1,v1,8129
[ 218] 0x900000001fc016c0:  00 03 1c 38 dsll	v1,v1,16
[ 218] 0x900000001fc016c4:  64 63 73 a8 daddiu	v1,v1,29608
  219: 	bge	v0,v1,testIcacheData
[ 219] 0x900000001fc016c8:  00 43 08 2a slt	at,v0,v1
[ 219] 0x900000001fc016cc:  10 20 00 1f beq	at,zero,0x900000001fc0174c
  220: 	nop
[ 220] 0x900000001fc016d0:  00 00 00 00 nop
  221: 	lw	v1,CP_TAG_HI(v0)	/* Pick up pattern */
[ 221] 0x900000001fc016d4:  8c 43 00 00 lw	v1,0(v0)
  222:         lw	t3,CP_TAG_LO(v0)
[ 222] 0x900000001fc016d8:  8c 4f 00 04 lw	t3,4(v0)
  223: 		
  224: 	/*
  225: 	 * Loop through all lines and write the TAG and Data. Note that
  226: 	 * the parity may be incorrect, but we ONLY access the tags at
  227: 	 * this point using the cache instruction which ignores parity.
  228: 	 */
  229: 
  230: 	move	t1,t0			/* # lines */
[ 230] 0x900000001fc016dc:  01 80 68 25 move	t1,t0
  231: 	dli	t2,K0_BASE
[ 231] 0x900000001fc016e0:  24 0e 00 15 li	t2,21
[ 231] 0x900000001fc016e4:  00 0e 76 fc dsll32	t2,t2,27
  232: 
  233: 	MTC0(v1, C0_TAGHI)
[ 233] 0x900000001fc016e8:  40 83 e8 00 mtc0	v1,taghi
  234: 	MTC0(t3, C0_TAGLO)
[ 234] 0x900000001fc016ec:  40 8f e0 00 mtc0	t3,taglo
  235: 2:
  236: 	ICACHE(C_IST, 0(t2))		/* Hit both ways */
[ 236] 0x900000001fc016f0:  bd c8 00 00 cache	Index_Store_Tag[I],0(t2)
  237: 	ICACHE(C_IST, 1(t2))
[ 237] 0x900000001fc016f4:  bd c8 00 01 cache	Index_Store_Tag[I],1(t2)
  238: 	
  239: 	sub	t1,1
[ 239] 0x900000001fc016f8:  21 ad ff ff addi	t1,t1,-1
  240: 	bgtz	t1,2b			/* See if more to do ... */
[ 240] 0x900000001fc016fc:  1d a0 ff fc bgtz	t1,0x900000001fc016f0
  241: 	daddu	t2,CACHE_ILINE_SIZE
[ 241] 0x900000001fc01700:  65 ce 00 40 daddiu	t2,t2,64
  242: 
  243: 	/*
  244: 	 * At this point, the tags have been written. Read them
  245: 	 * back to see what happened. Note that above, we have
  246: 	 * saved expected values in v0/v1.
  247: 	 */
  248: 
  249: 	move	t1,t0			/* Number of lines */
[ 249] 0x900000001fc01704:  01 80 68 25 move	t1,t0
  250: 	dli	t2,K0_BASE
[ 250] 0x900000001fc01708:  24 0e 00 15 li	t2,21
[ 250] 0x900000001fc0170c:  00 0e 76 fc dsll32	t2,t2,27
  251: 3:
  252: 	ICACHE(C_ILT, 0(t2))		/* one way	*/
[ 252] 0x900000001fc01710:  bd c4 00 00 cache	Index_Load_Tag[I],0(t2)
  253: 	MFC0(a0,C0_TAGHI)
[ 253] 0x900000001fc01714:  40 04 e8 00 mfc0	a0,taghi
  254: 	bne	a0,v1,testIcacheFailAddrWay0
[ 254] 0x900000001fc01718:  14 83 00 43 bne	a0,v1,0x900000001fc01828
  255: 	MFC0(a1,C0_TAGLO)
[ 255] 0x900000001fc0171c:  40 05 e0 00 mfc0	a1,taglo
  256: 	bne	a1,t3,testIcacheFailAddrWay0
[ 256] 0x900000001fc01720:  14 af 00 41 bne	a1,t3,0x900000001fc01828
  257: 	ICACHE(C_ILT, 1(t2))		/* or the other */
[ 257] 0x900000001fc01724:  bd c4 00 01 cache	Index_Load_Tag[I],1(t2)
  258: 	MFC0(a0,C0_TAGHI)
[ 258] 0x900000001fc01728:  40 04 e8 00 mfc0	a0,taghi
  259: 	bne	a0,v1,testIcacheFailAddrWay1
[ 259] 0x900000001fc0172c:  14 83 00 46 bne	a0,v1,0x900000001fc01848
  260: 	MFC0(a1,C0_TAGLO)
[ 260] 0x900000001fc01730:  40 05 e0 00 mfc0	a1,taglo
  261: 	bne	a1,t3,testIcacheFailAddrWay1
[ 261] 0x900000001fc01734:  14 af 00 44 bne	a1,t3,0x900000001fc01848
  262: 
  263: 	sub	t1,1
[ 263] 0x900000001fc01738:  21 ad ff ff addi	t1,t1,-1
  264: 	bgtz	t1,3b
[ 264] 0x900000001fc0173c:  1d a0 ff f4 bgtz	t1,0x900000001fc01710
  265: 	daddu	t2,CACHE_ILINE_SIZE
[ 265] 0x900000001fc01740:  65 ce 00 40 daddiu	t2,t2,64
  266: 
  267: 	/*
  268: 	 * Move onto next test pattern.
  269: 	 */
  270: 	j	1b
[ 270] 0x900000001fc01744:  0b f0 05 ac j		(testIcache+76)
  271: 	dadd	v0,CP_SIZE
[ 271] 0x900000001fc01748:  60 42 00 18 daddi	v0,v0,24
  272: 
  273: testIcacheData:
  274: 	/*
  275: 	 * Now test the data part of the ICACHE, t0 still contains the 
  276: 	 * # of lines.
  277: 	 */
  278: 	dla	v0,icache_patternStart
[ 278] 0x900000001fc0174c:  3c 02 90 00 lui	v0,0x9000
[ 278] 0x900000001fc01750:  64 42 00 00 daddiu	v0,v0,0
[ 278] 0x900000001fc01754:  00 02 14 38 dsll	v0,v0,16
[ 278] 0x900000001fc01758:  64 42 1f c1 daddiu	v0,v0,8129
[ 278] 0x900000001fc0175c:  00 02 14 38 dsll	v0,v0,16
[ 278] 0x900000001fc01760:  64 42 73 48 daddiu	v0,v0,29512
  279: 1:
  280: 	/*
  281: 	 * Check if we are done at the top of the loop. This means that
  282: 	 * we can have NO test patterns if desired.
  283: 	 */
  284: 	dla	v1,icache_patternEnd
[ 284] 0x900000001fc01764:  3c 03 90 00 lui	v1,0x9000
[ 284] 0x900000001fc01768:  64 63 00 00 daddiu	v1,v1,0
[ 284] 0x900000001fc0176c:  00 03 1c 38 dsll	v1,v1,16
[ 284] 0x900000001fc01770:  64 63 1f c1 daddiu	v1,v1,8129
[ 284] 0x900000001fc01774:  00 03 1c 38 dsll	v1,v1,16
[ 284] 0x900000001fc01778:  64 63 73 a8 daddiu	v1,v1,29608
  285: 	bge	v0,v1,testIcacheDone
[ 285] 0x900000001fc0177c:  00 43 08 2a slt	at,v0,v1
[ 285] 0x900000001fc01780:  10 20 00 27 beq	at,zero,0x900000001fc01820
  286: 	nop
[ 286] 0x900000001fc01784:  00 00 00 00 nop
  287: 	lw	ta1,CP_DATA_HI(v0)	/* Pick up pattern */
[ 287] 0x900000001fc01788:  8c 49 00 10 lw	a5,16(v0)
  288:         lw	ta2,CP_DATA_LO(v0)
[ 288] 0x900000001fc0178c:  8c 4a 00 14 lw	a6,20(v0)
  289: 	lw	ta3,CP_ECC(v0)		/* ECC info */
[ 289] 0x900000001fc01790:  8c 4b 00 08 lw	a7,8(v0)
  290: 	
  291: 	/*
  292: 	 * Loop through all lines and write the Data. Note that
  293: 	 * the parity may be incorrect, but we ONLY access the data at
  294: 	 * this point using the cache instruction which ignores parity.
  295: 	 */
  296: 
  297: 	move	t1,t0			/* # lines */
[ 297] 0x900000001fc01794:  01 80 68 25 move	t1,t0
  298: 	dli	t2,K0_BASE
[ 298] 0x900000001fc01798:  24 0e 00 15 li	t2,21
[ 298] 0x900000001fc0179c:  00 0e 76 fc dsll32	t2,t2,27
  299: 
  300: 	MTC0(ta1, C0_TAGHI)
[ 300] 0x900000001fc017a0:  40 89 e8 00 mtc0	a5,taghi
  301: 	MTC0(ta2, C0_TAGLO)
[ 301] 0x900000001fc017a4:  40 8a e0 00 mtc0	a6,taglo
  302: 	MTC0(ta3, C0_ECC)
[ 302] 0x900000001fc017a8:  40 8b d0 00 mtc0	a7,ecc
  303: 
  304:         /* 
  305: 	 * Fill the line with the pattern in both "ways". t2 has the
  306: 	 * virtual address of the start of the cache line. 
  307: 	 */
  308: 2:
  309:         li	ta0,CACHE_ILINE_SIZE/4
[ 309] 0x900000001fc017ac:  24 08 00 10 li	a4,16
  310: 4:
  311: 	ICACHE(C_ISD, 0(t2))
[ 311] 0x900000001fc017b0:  bd dc 00 00 cache	Hit_Set_Virtual[I],0(t2)
  312: 	ICACHE(C_ISD, 1(t2))
[ 312] 0x900000001fc017b4:  bd dc 00 01 cache	Hit_Set_Virtual[I],1(t2)
  313: 3:					/* Loop over all words in line */
  314:         ICACHE(C_ILD, 0(t2))
[ 314] 0x900000001fc017b8:  bd d8 00 00 cache	Hit_WriteBack[I],0(t2)
  315:         MFC0(a1, C0_TAGHI)
[ 315] 0x900000001fc017bc:  40 05 e8 00 mfc0	a1,taghi
  316:         MFC0(a2, C0_TAGLO)
[ 316] 0x900000001fc017c0:  40 06 e0 00 mfc0	a2,taglo
  317: 	MFC0(a3, C0_ECC)
[ 317] 0x900000001fc017c4:  40 07 d0 00 mfc0	a3,ecc
  318:         bne	a1,ta1,testIcacheFailDataWay0
[ 318] 0x900000001fc017c8:  14 a9 00 5c bne	a1,a5,0x900000001fc0193c
  319: 	nop
[ 319] 0x900000001fc017cc:  00 00 00 00 nop
  320:         bne	a2,ta2,testIcacheFailDataWay0
[ 320] 0x900000001fc017d0:  14 ca 00 5a bne	a2,a6,0x900000001fc0193c
  321:         nop
[ 321] 0x900000001fc017d4:  00 00 00 00 nop
  322: 	bne	a3,ta3,testIcacheFailDataWay0
[ 322] 0x900000001fc017d8:  14 eb 00 58 bne	a3,a7,0x900000001fc0193c
  323: 
  324:         ICACHE(C_ILD, 1(t2))
[ 324] 0x900000001fc017dc:  bd d8 00 01 cache	Hit_WriteBack[I],1(t2)
  325:         MFC0(a1, C0_TAGHI)
[ 325] 0x900000001fc017e0:  40 05 e8 00 mfc0	a1,taghi
  326:         MFC0(a2, C0_TAGLO)
[ 326] 0x900000001fc017e4:  40 06 e0 00 mfc0	a2,taglo
  327: 	MFC0(a3, C0_ECC)
[ 327] 0x900000001fc017e8:  40 07 d0 00 mfc0	a3,ecc
  328:         bne	a1,ta1,testIcacheFailDataWay1
[ 328] 0x900000001fc017ec:  14 a9 00 5b bne	a1,a5,0x900000001fc0195c
  329: 	nop
[ 329] 0x900000001fc017f0:  00 00 00 00 nop
  330:         bne	a2,ta2,testIcacheFailDataWay1
[ 330] 0x900000001fc017f4:  14 ca 00 59 bne	a2,a6,0x900000001fc0195c
  331:         nop
[ 331] 0x900000001fc017f8:  00 00 00 00 nop
  332: 	bne	a3,ta3,testIcacheFailDataWay1
[ 332] 0x900000001fc017fc:  14 eb 00 57 bne	a3,a7,0x900000001fc0195c
  333: 
  334:         sub	ta0,1
[ 334] 0x900000001fc01800:  21 08 ff ff addi	a4,a4,-1
  335:         bgtz	ta0,4b			/* more words in line */
[ 335] 0x900000001fc01804:  1d 00 ff ea bgtz	a4,0x900000001fc017b0
  336:         daddiu 	t2,4			/* DELAY: Up 4 bytes */
[ 336] 0x900000001fc01808:  65 ce 00 04 daddiu	t2,t2,4
  337: 
  338: 	sub	t1,1
[ 338] 0x900000001fc0180c:  21 ad ff ff addi	t1,t1,-1
  339: 	bgtz	t1,2b			/* See if more to do ... */
[ 339] 0x900000001fc01810:  1d a0 ff e6 bgtz	t1,0x900000001fc017ac
  340: 	nop
[ 340] 0x900000001fc01814:  00 00 00 00 nop
  341: 
  342: 	/*
  343: 	 * Move onto next test pattern.
  344: 	 */
  345: 	j	1b
[ 345] 0x900000001fc01818:  0b f0 05 d9 j		(testIcache+256)
  346: 	daddu	v0,CP_SIZE
[ 346] 0x900000001fc0181c:  64 42 00 18 daddiu	v0,v0,24
  347: 
  348: testIcacheDone:	
  349: 	j	ra
[ 349] 0x900000001fc01820:  03 e0 00 08 jr	ra
  350: 	move	v0,zero			/* success */
[ 350] 0x900000001fc01824:  00 00 10 25 move	v0,zero
  351: 
  352: testIcacheFailAddrWay0:
  353: 	MESSAGE(a2, "I-cache tag compare error:	way 0:"); 
[ 353] 0x900000001fc01828:  3c 06 90 00 lui	a2,0x9000
[ 353] 0x900000001fc0182c:  64 c6 00 00 daddiu	a2,a2,0
[ 353] 0x900000001fc01830:  00 06 34 38 dsll	a2,a2,16
[ 353] 0x900000001fc01834:  64 c6 1f c1 daddiu	a2,a2,8129
[ 353] 0x900000001fc01838:  00 06 34 38 dsll	a2,a2,16
[ 353] 0x900000001fc0183c:  64 c6 74 28 daddiu	a2,a2,29736
  354: 	b	testIcacheFailAddr
[ 354] 0x900000001fc01840:  10 00 00 07 b		0x900000001fc01860
  355: 	nop
[ 355] 0x900000001fc01844:  00 00 00 00 nop
  356: testIcacheFailAddrWay1:
  357: 	MESSAGE(a2, "I-cache tag compare error:	way 1:"); 
[ 357] 0x900000001fc01848:  3c 06 90 00 lui	a2,0x9000
[ 357] 0x900000001fc0184c:  64 c6 00 00 daddiu	a2,a2,0
[ 357] 0x900000001fc01850:  00 06 34 38 dsll	a2,a2,16
[ 357] 0x900000001fc01854:  64 c6 1f c1 daddiu	a2,a2,8129
[ 357] 0x900000001fc01858:  00 06 34 38 dsll	a2,a2,16
[ 357] 0x900000001fc0185c:  64 c6 74 4a daddiu	a2,a2,29770
  358: testIcacheFailAddr:
  359: 	/*
  360: 	 * Tag compare error:
  361: 	 * a0/a1 - taghi/taglo read values
  362: 	 * v1,t3 - taghi/taglo expected values
  363: 	 * t2 - address
  364: 	 */
  365: 	dsll	a0,32
[ 365] 0x900000001fc01860:  00 04 20 3c dsll32	a0,a0,0
  366: 	dsll	a1,32
[ 366] 0x900000001fc01864:  00 05 28 3c dsll32	a1,a1,0
  367: 	dsrl	a1,32
[ 367] 0x900000001fc01868:  00 05 28 3e dsrl32	a1,a1,0
  368: 	or	t0,a1,a0		/* 64-bit read back value */
[ 368] 0x900000001fc0186c:  00 a4 60 25 or	t0,a1,a0
  369: 
  370: 	dsll	v1,32
[ 370] 0x900000001fc01870:  00 03 18 3c dsll32	v1,v1,0
  371: 	dsll	t3,32
[ 371] 0x900000001fc01874:  00 0f 78 3c dsll32	t3,t3,0
  372: 	dsrl	t3,32
[ 372] 0x900000001fc01878:  00 0f 78 3e dsrl32	t3,t3,0
  373: 	or	t3,v1			/* 64-bit expected value */
[ 373] 0x900000001fc0187c:  01 e3 78 25 or	t3,t3,v1
  374: 
  375: 	move	t1,ra			/* Save return address */
[ 375] 0x900000001fc01880:  03 e0 68 25 move	t1,ra
  376: 	
  377: 	PMESSAGE_PTR(a2); PMESSAGE(" address: 0x"); PHEX(t2)
[ 377] 0x900000001fc01884:  00 86 20 25 or	a0,a0,a2
[ 377] 0x900000001fc01888:  0f f0 15 03 jal		pod_puts
[ 377] 0x900000001fc0188c:  00 00 00 00 nop
[ 377] 0x900000001fc01890:  3c 04 90 00 lui	a0,0x9000
[ 377] 0x900000001fc01894:  64 84 00 00 daddiu	a0,a0,0
[ 377] 0x900000001fc01898:  00 04 24 38 dsll	a0,a0,16
[ 377] 0x900000001fc0189c:  64 84 1f c1 daddiu	a0,a0,8129
[ 377] 0x900000001fc018a0:  00 04 24 38 dsll	a0,a0,16
[ 377] 0x900000001fc018a4:  64 84 74 6c daddiu	a0,a0,29804
[ 377] 0x900000001fc018a8:  0f f0 15 03 jal		pod_puts
[ 377] 0x900000001fc018ac:  00 00 00 00 nop
[ 377] 0x900000001fc018b0:  00 0e 20 25 or	a0,zero,t2
[ 377] 0x900000001fc018b4:  0f f0 14 f8 jal		pod_puthex64
[ 377] 0x900000001fc018b8:  00 00 00 00 nop
  378: 	PMESSAGE("\n\r\twrote: 0x"); PHEX(t3);
[ 378] 0x900000001fc018bc:  3c 04 90 00 lui	a0,0x9000
[ 378] 0x900000001fc018c0:  64 84 00 00 daddiu	a0,a0,0
[ 378] 0x900000001fc018c4:  00 04 24 38 dsll	a0,a0,16
[ 378] 0x900000001fc018c8:  64 84 1f c1 daddiu	a0,a0,8129
[ 378] 0x900000001fc018cc:  00 04 24 38 dsll	a0,a0,16
[ 378] 0x900000001fc018d0:  64 84 74 79 daddiu	a0,a0,29817
[ 378] 0x900000001fc018d4:  0f f0 15 03 jal		pod_puts
[ 378] 0x900000001fc018d8:  00 00 00 00 nop
[ 378] 0x900000001fc018dc:  00 0f 20 25 or	a0,zero,t3
[ 378] 0x900000001fc018e0:  0f f0 14 f8 jal		pod_puthex64
[ 378] 0x900000001fc018e4:  00 00 00 00 nop
  379: 	PMESSAGE(" read: 0x"); PHEX(t0);
[ 379] 0x900000001fc018e8:  3c 04 90 00 lui	a0,0x9000
[ 379] 0x900000001fc018ec:  64 84 00 00 daddiu	a0,a0,0
[ 379] 0x900000001fc018f0:  00 04 24 38 dsll	a0,a0,16
[ 379] 0x900000001fc018f4:  64 84 1f c1 daddiu	a0,a0,8129
[ 379] 0x900000001fc018f8:  00 04 24 38 dsll	a0,a0,16
[ 379] 0x900000001fc018fc:  64 84 74 86 daddiu	a0,a0,29830
[ 379] 0x900000001fc01900:  0f f0 15 03 jal		pod_puts
[ 379] 0x900000001fc01904:  00 00 00 00 nop
[ 379] 0x900000001fc01908:  00 0c 20 25 or	a0,zero,t0
[ 379] 0x900000001fc0190c:  0f f0 14 f8 jal		pod_puthex64
[ 379] 0x900000001fc01910:  00 00 00 00 nop
  380: 	PMESSAGE("\n\r")
[ 380] 0x900000001fc01914:  3c 04 90 00 lui	a0,0x9000
[ 380] 0x900000001fc01918:  64 84 00 00 daddiu	a0,a0,0
[ 380] 0x900000001fc0191c:  00 04 24 38 dsll	a0,a0,16
[ 380] 0x900000001fc01920:  64 84 1f c1 daddiu	a0,a0,8129
[ 380] 0x900000001fc01924:  00 04 24 38 dsll	a0,a0,16
[ 380] 0x900000001fc01928:  64 84 74 90 daddiu	a0,a0,29840
[ 380] 0x900000001fc0192c:  0f f0 15 03 jal		pod_puts
[ 380] 0x900000001fc01930:  00 00 00 00 nop
  381: 	
  382: 	j	t1
[ 382] 0x900000001fc01934:  01 a0 00 08 jr	t1
  383: 	ori	v0,zero,EVDIAG_ICACHE_ADDR
[ 383] 0x900000001fc01938:  34 02 00 06 ori	v0,zero,0x6
  384: 	
  385: testIcacheFailDataWay0:
  386: 	MESSAGE(a0, "\r\n  I-cache data compare error: way 0:")
[ 386] 0x900000001fc0193c:  3c 04 90 00 lui	a0,0x9000
[ 386] 0x900000001fc01940:  64 84 00 00 daddiu	a0,a0,0
[ 386] 0x900000001fc01944:  00 04 24 38 dsll	a0,a0,16
[ 386] 0x900000001fc01948:  64 84 1f c1 daddiu	a0,a0,8129
[ 386] 0x900000001fc0194c:  00 04 24 38 dsll	a0,a0,16
[ 386] 0x900000001fc01950:  64 84 74 93 daddiu	a0,a0,29843
  387: 	b	testIcacheFailData
[ 387] 0x900000001fc01954:  10 00 00 07 b		0x900000001fc01974
  388: 	nop
[ 388] 0x900000001fc01958:  00 00 00 00 nop
  389: testIcacheFailDataWay1:	
  390: 	MESSAGE(a0, "\r\n  I-cache data compare error: way 1:")
[ 390] 0x900000001fc0195c:  3c 04 90 00 lui	a0,0x9000
[ 390] 0x900000001fc01960:  64 84 00 00 daddiu	a0,a0,0
[ 390] 0x900000001fc01964:  00 04 24 38 dsll	a0,a0,16
[ 390] 0x900000001fc01968:  64 84 1f c1 daddiu	a0,a0,8129
[ 390] 0x900000001fc0196c:  00 04 24 38 dsll	a0,a0,16
[ 390] 0x900000001fc01970:  64 84 74 ba daddiu	a0,a0,29882
  391: testIcacheFailData:
  392: 	/*
  393: 	 * Data Compare error:
  394: 	 * v0 - address of pattern in table.
  395: 	 * a1/a2/a3 - read HI/LO/ECC
  396: 	 * t2 - address
  397: 	 */
  398: 
  399: 	dsll	a1,32
[ 399] 0x900000001fc01974:  00 05 28 3c dsll32	a1,a1,0
  400: 	dsll	a2,32
[ 400] 0x900000001fc01978:  00 06 30 3c dsll32	a2,a2,0
  401: 	dsrl	a2,32
[ 401] 0x900000001fc0197c:  00 06 30 3e dsrl32	a2,a2,0
  402: 	or	a2,a1			/* 64-bit read value */
[ 402] 0x900000001fc01980:  00 c5 30 25 or	a2,a2,a1
  403: 	
  404: 	move	t0,ra
[ 404] 0x900000001fc01984:  03 e0 60 25 move	t0,ra
  405: 	move	t1,a1			/* Gets lots in print calls */
[ 405] 0x900000001fc01988:  00 a0 68 25 move	t1,a1
  406: 	move	t3,v0			/* Save pointer to table */
[ 406] 0x900000001fc0198c:  00 40 78 25 move	t3,v0
  407: 	move	k0,a3			/* zapped in HEX output */
[ 407] 0x900000001fc01990:  00 e0 d0 25 move	k0,a3
  408: 	
  409: 	PMESSAGE_PTR(a0); PMESSAGE(" address: 0x"); PHEX(t2)
[ 409] 0x900000001fc01994:  00 84 20 25 or	a0,a0,a0
[ 409] 0x900000001fc01998:  0f f0 15 03 jal		pod_puts
[ 409] 0x900000001fc0199c:  00 00 00 00 nop
[ 409] 0x900000001fc019a0:  3c 04 90 00 lui	a0,0x9000
[ 409] 0x900000001fc019a4:  64 84 00 00 daddiu	a0,a0,0
[ 409] 0x900000001fc019a8:  00 04 24 38 dsll	a0,a0,16
[ 409] 0x900000001fc019ac:  64 84 1f c1 daddiu	a0,a0,8129
[ 409] 0x900000001fc019b0:  00 04 24 38 dsll	a0,a0,16
[ 409] 0x900000001fc019b4:  64 84 74 e1 daddiu	a0,a0,29921
[ 409] 0x900000001fc019b8:  0f f0 15 03 jal		pod_puts
[ 409] 0x900000001fc019bc:  00 00 00 00 nop
[ 409] 0x900000001fc019c0:  00 0e 20 25 or	a0,zero,t2
[ 409] 0x900000001fc019c4:  0f f0 14 f8 jal		pod_puthex64
[ 409] 0x900000001fc019c8:  00 00 00 00 nop
  410: 	PMESSAGE("\n\r\twrote(data/ecc): 0x");
[ 410] 0x900000001fc019cc:  3c 04 90 00 lui	a0,0x9000
[ 410] 0x900000001fc019d0:  64 84 00 00 daddiu	a0,a0,0
[ 410] 0x900000001fc019d4:  00 04 24 38 dsll	a0,a0,16
[ 410] 0x900000001fc019d8:  64 84 1f c1 daddiu	a0,a0,8129
[ 410] 0x900000001fc019dc:  00 04 24 38 dsll	a0,a0,16
[ 410] 0x900000001fc019e0:  64 84 74 ee daddiu	a0,a0,29934
[ 410] 0x900000001fc019e4:  0f f0 15 03 jal		pod_puts
[ 410] 0x900000001fc019e8:  00 00 00 00 nop
  411: 		lwu	a0,CP_DATA_HI(t3)
[ 411] 0x900000001fc019ec:  9d e4 00 10 lwu	a0,16(t3)
  412: 		lwu	a1,CP_DATA_LO(t3)
[ 412] 0x900000001fc019f0:  9d e5 00 14 lwu	a1,20(t3)
  413: 		or	a0,a1
[ 413] 0x900000001fc019f4:  00 85 20 25 or	a0,a0,a1
  414: 		PHEX(a0)
[ 414] 0x900000001fc019f8:  00 04 20 25 or	a0,zero,a0
[ 414] 0x900000001fc019fc:  0f f0 14 f8 jal		pod_puthex64
[ 414] 0x900000001fc01a00:  00 00 00 00 nop
  415: 		PMESSAGE("/0x");
[ 415] 0x900000001fc01a04:  3c 04 90 00 lui	a0,0x9000
[ 415] 0x900000001fc01a08:  64 84 00 00 daddiu	a0,a0,0
[ 415] 0x900000001fc01a0c:  00 04 24 38 dsll	a0,a0,16
[ 415] 0x900000001fc01a10:  64 84 1f c1 daddiu	a0,a0,8129
[ 415] 0x900000001fc01a14:  00 04 24 38 dsll	a0,a0,16
[ 415] 0x900000001fc01a18:  64 84 75 05 daddiu	a0,a0,29957
[ 415] 0x900000001fc01a1c:  0f f0 15 03 jal		pod_puts
[ 415] 0x900000001fc01a20:  00 00 00 00 nop
  416: 		lwu	a0,CP_ECC(t3)
[ 416] 0x900000001fc01a24:  9d e4 00 08 lwu	a0,8(t3)
  417: 		PHEX32(a0)
[ 417] 0x900000001fc01a28:  00 04 20 25 or	a0,zero,a0
[ 417] 0x900000001fc01a2c:  0f f0 14 ed jal		pod_puthex32
[ 417] 0x900000001fc01a30:  00 00 00 00 nop
  418: 	
  419: 	PMESSAGE(" read(data/ecc): 0x")
[ 419] 0x900000001fc01a34:  3c 04 90 00 lui	a0,0x9000
[ 419] 0x900000001fc01a38:  64 84 00 00 daddiu	a0,a0,0
[ 419] 0x900000001fc01a3c:  00 04 24 38 dsll	a0,a0,16
[ 419] 0x900000001fc01a40:  64 84 1f c1 daddiu	a0,a0,8129
[ 419] 0x900000001fc01a44:  00 04 24 38 dsll	a0,a0,16
[ 419] 0x900000001fc01a48:  64 84 75 09 daddiu	a0,a0,29961
[ 419] 0x900000001fc01a4c:  0f f0 15 03 jal		pod_puts
[ 419] 0x900000001fc01a50:  00 00 00 00 nop
  420: 		PHEX32(a2); PMESSAGE("/0x"); PHEX32(k0)
[ 420] 0x900000001fc01a54:  00 06 20 25 or	a0,zero,a2
[ 420] 0x900000001fc01a58:  0f f0 14 ed jal		pod_puthex32
[ 420] 0x900000001fc01a5c:  00 00 00 00 nop
[ 420] 0x900000001fc01a60:  3c 04 90 00 lui	a0,0x9000
[ 420] 0x900000001fc01a64:  64 84 00 00 daddiu	a0,a0,0
[ 420] 0x900000001fc01a68:  00 04 24 38 dsll	a0,a0,16
[ 420] 0x900000001fc01a6c:  64 84 1f c1 daddiu	a0,a0,8129
[ 420] 0x900000001fc01a70:  00 04 24 38 dsll	a0,a0,16
[ 420] 0x900000001fc01a74:  64 84 75 1d daddiu	a0,a0,29981
[ 420] 0x900000001fc01a78:  0f f0 15 03 jal		pod_puts
[ 420] 0x900000001fc01a7c:  00 00 00 00 nop
[ 420] 0x900000001fc01a80:  00 1a 20 25 or	a0,zero,k0
[ 420] 0x900000001fc01a84:  0f f0 14 ed jal		pod_puthex32
[ 420] 0x900000001fc01a88:  00 00 00 00 nop
  421: 	
  422: 	j	t0
[ 422] 0x900000001fc01a8c:  01 80 00 08 jr	t0
  423: 	ori	v0,zero,EVDIAG_ICACHE_DATA
[ 423] 0x900000001fc01a90:  34 02 00 05 ori	v0,zero,0x5
  424: 	END(testIcache)
  425: 
  426: /*
  427:  * Function: 	testDcache
  428:  * Purpose: 	Verify we can write/read the Dcache
  429:  * Parameters: 	none
  430:  * Returns:	v0 = 0 - success
  431:  *		v0 !=0 = failed
  432:  */
  433: LEAF(testDcache)
  434: 	.set	noreorder
  435: 	LEDS(PLED_TESTDCACHE)
testDcache:
[ 435] 0x900000001fc01a94:  00 00 00 00 nop
[ 435] 0x900000001fc01a98:  34 04 00 04 ori	a0,zero,0x4
[ 435] 0x900000001fc01a9c:  3c 02 90 00 lui	v0,0x9000
[ 435] 0x900000001fc01aa0:  00 02 14 38 dsll	v0,v0,16
[ 435] 0x900000001fc01aa4:  34 42 19 00 ori	v0,v0,0x1900
[ 435] 0x900000001fc01aa8:  00 02 14 38 dsll	v0,v0,16
[ 435] 0x900000001fc01aac:  34 42 40 00 ori	v0,v0,0x4000
[ 435] 0x900000001fc01ab0:  fc 44 00 00 sd	a0,0(v0)
  436: 
  437: 	/* figure out # of lines */
  438: 
  439: 	move	t0,ra			/* save way back */
[ 439] 0x900000001fc01ab4:  03 e0 60 25 move	t0,ra
  440: 	jal	dCacheSize
[ 440] 0x900000001fc01ab8:  0f f0 05 91 jal		dCacheSize
  441: 	nop
[ 441] 0x900000001fc01abc:  00 00 00 00 nop
  442: 	move	ra,t0			/* Restore return path */
[ 442] 0x900000001fc01ac0:  01 80 f8 25 move	ra,t0
  443: 	divu	t0,v0,CACHE_DLINE_SIZE*2 /* # lines in t0/#ways */
[ 443] 0x900000001fc01ac4:  00 02 61 82 srl	t0,v0,6
  444: 
  445: 	dla	v0,dcache_patternStart
[ 445] 0x900000001fc01ac8:  3c 02 90 00 lui	v0,0x9000
[ 445] 0x900000001fc01acc:  64 42 00 00 daddiu	v0,v0,0
[ 445] 0x900000001fc01ad0:  00 02 14 38 dsll	v0,v0,16
[ 445] 0x900000001fc01ad4:  64 42 1f c1 daddiu	v0,v0,8129
[ 445] 0x900000001fc01ad8:  00 02 14 38 dsll	v0,v0,16
[ 445] 0x900000001fc01adc:  64 42 73 a8 daddiu	v0,v0,29608
  446: 1:
  447: 	/*
  448: 	 * Check if we are done at the top of the loop. This means that
  449: 	 * we can have NO test patterns if desired.
  450: 	 */
  451: 	dla	v1,dcache_patternEnd
[ 451] 0x900000001fc01ae0:  3c 03 90 00 lui	v1,0x9000
[ 451] 0x900000001fc01ae4:  64 63 00 00 daddiu	v1,v1,0
[ 451] 0x900000001fc01ae8:  00 03 1c 38 dsll	v1,v1,16
[ 451] 0x900000001fc01aec:  64 63 1f c1 daddiu	v1,v1,8129
[ 451] 0x900000001fc01af0:  00 03 1c 38 dsll	v1,v1,16
[ 451] 0x900000001fc01af4:  64 63 74 08 daddiu	v1,v1,29704
  452: 	bge	v0,v1,testDcacheData
[ 452] 0x900000001fc01af8:  00 43 08 2a slt	at,v0,v1
[ 452] 0x900000001fc01afc:  10 20 00 20 beq	at,zero,0x900000001fc01b80
  453: 	nop
[ 453] 0x900000001fc01b00:  00 00 00 00 nop
  454: 	lw	v1,CP_TAG_HI(v0)	/* Pick up pattern */
[ 454] 0x900000001fc01b04:  8c 43 00 00 lw	v1,0(v0)
  455:         lw	t3,CP_TAG_LO(v0)
[ 455] 0x900000001fc01b08:  8c 4f 00 04 lw	t3,4(v0)
  456: 	
  457: 	/*
  458: 	 * Loop through all lines and write the TAG and Data. Note that
  459: 	 * the parity may be incorrect, but we ONLY access the tags at
  460: 	 * this point using the cache instruction which ignores parity.
  461: 	 */
  462: 
  463: 	move	t1,t0			/* # lines */
[ 463] 0x900000001fc01b0c:  01 80 68 25 move	t1,t0
  464: 	dli	t2,K0_BASE
[ 464] 0x900000001fc01b10:  24 0e 00 15 li	t2,21
[ 464] 0x900000001fc01b14:  00 0e 76 fc dsll32	t2,t2,27
  465: 
  466: 	MTC0(v1, C0_TAGHI)
[ 466] 0x900000001fc01b18:  40 83 e8 00 mtc0	v1,taghi
  467: 	MTC0(t3, C0_TAGLO)
[ 467] 0x900000001fc01b1c:  40 8f e0 00 mtc0	t3,taglo
  468: 2:
  469: 	DCACHE(C_IST, 0(t2))		/* Hit both ways */
[ 469] 0x900000001fc01b20:  bd c9 00 00 cache	Index_Store_Tag[D],0(t2)
  470: 	DCACHE(C_IST, 1(t2))
[ 470] 0x900000001fc01b24:  bd c9 00 01 cache	Index_Store_Tag[D],1(t2)
  471: 	
  472: 	sub	t1,1
[ 472] 0x900000001fc01b28:  21 ad ff ff addi	t1,t1,-1
  473: 	daddu	t2,CACHE_DLINE_SIZE
[ 473] 0x900000001fc01b2c:  65 ce 00 20 daddiu	t2,t2,32
  474: 	bgtz	t1,2b			/* See if more to do ... */
[ 474] 0x900000001fc01b30:  1d a0 ff fb bgtz	t1,0x900000001fc01b20
  475: 	nop
[ 475] 0x900000001fc01b34:  00 00 00 00 nop
  476: 
  477: 	/*
  478: 	 * At this point, the tags have been written. Read them
  479: 	 * back to see what happened. Note that above, we have
  480: 	 * saved expected values in v1/t3.
  481: 	 */
  482: 
  483: 	move	t1,t0			/* Number of lines */
[ 483] 0x900000001fc01b38:  01 80 68 25 move	t1,t0
  484: 	dli	t2,K0_BASE
[ 484] 0x900000001fc01b3c:  24 0e 00 15 li	t2,21
[ 484] 0x900000001fc01b40:  00 0e 76 fc dsll32	t2,t2,27
  485: 3:
  486: 	DCACHE(C_ILT, 0(t2))		/* one way	*/
[ 486] 0x900000001fc01b44:  bd c5 00 00 cache	Index_Load_Tag[D],0(t2)
  487: 	MFC0(a2,C0_TAGHI)
[ 487] 0x900000001fc01b48:  40 06 e8 00 mfc0	a2,taghi
  488: 	bne	a2,v1,testDcacheFailAddrWay0
[ 488] 0x900000001fc01b4c:  14 c3 00 3b bne	a2,v1,0x900000001fc01c3c
  489: 	MFC0(a1,C0_TAGLO)		/* DELAY */
[ 489] 0x900000001fc01b50:  40 05 e0 00 mfc0	a1,taglo
  490: 	bne	a1,t3,testDcacheFailAddrWay0
[ 490] 0x900000001fc01b54:  14 af 00 39 bne	a1,t3,0x900000001fc01c3c
  491: 	DCACHE(C_ILT, 1(t2))		/* or the other */
[ 491] 0x900000001fc01b58:  bd c5 00 01 cache	Index_Load_Tag[D],1(t2)
  492: 	MFC0(a2,C0_TAGHI)
[ 492] 0x900000001fc01b5c:  40 06 e8 00 mfc0	a2,taghi
  493: 	bne	a2,v1,testDcacheFailAddrWay1
[ 493] 0x900000001fc01b60:  14 c3 00 3e bne	a2,v1,0x900000001fc01c5c
  494: 	MFC0(a1,C0_TAGLO)		/* DELAY */
[ 494] 0x900000001fc01b64:  40 05 e0 00 mfc0	a1,taglo
  495: 	bne	a1,t3,testDcacheFailAddrWay1
[ 495] 0x900000001fc01b68:  14 af 00 3c bne	a1,t3,0x900000001fc01c5c
  496: 
  497: 	sub	t1,1
[ 497] 0x900000001fc01b6c:  21 ad ff ff addi	t1,t1,-1
  498: 	bgtz	t1,3b
[ 498] 0x900000001fc01b70:  1d a0 ff f4 bgtz	t1,0x900000001fc01b44
  499: 	daddu	t2,CACHE_DLINE_SIZE
[ 499] 0x900000001fc01b74:  65 ce 00 20 daddiu	t2,t2,32
  500: 
  501: 	/*
  502: 	 * Move onto next test pattern.
  503: 	 */
  504: 	j	1b
[ 504] 0x900000001fc01b78:  0b f0 06 b8 j		(testDcache+76)
  505: 	daddu	v0,CP_SIZE
[ 505] 0x900000001fc01b7c:  64 42 00 18 daddiu	v0,v0,24
  506: 
  507: testDcacheData:
  508: 	/*
  509: 	 * Now test the data part of the ICACHE, t0 still contains the 
  510: 	 * # of lines.
  511: 	 */
  512: 	dla	v0,dcache_patternStart
[ 512] 0x900000001fc01b80:  3c 02 90 00 lui	v0,0x9000
[ 512] 0x900000001fc01b84:  64 42 00 00 daddiu	v0,v0,0
[ 512] 0x900000001fc01b88:  00 02 14 38 dsll	v0,v0,16
[ 512] 0x900000001fc01b8c:  64 42 1f c1 daddiu	v0,v0,8129
[ 512] 0x900000001fc01b90:  00 02 14 38 dsll	v0,v0,16
[ 512] 0x900000001fc01b94:  64 42 73 a8 daddiu	v0,v0,29608
  513: 	
  514: 1:
  515: 	/*
  516: 	 * Check if we are done at the top of the loop. This means that
  517: 	 * we can have NO test patterns if desired.
  518: 	 */
  519: 	dla	v1,dcache_patternEnd
[ 519] 0x900000001fc01b98:  3c 03 90 00 lui	v1,0x9000
[ 519] 0x900000001fc01b9c:  64 63 00 00 daddiu	v1,v1,0
[ 519] 0x900000001fc01ba0:  00 03 1c 38 dsll	v1,v1,16
[ 519] 0x900000001fc01ba4:  64 63 1f c1 daddiu	v1,v1,8129
[ 519] 0x900000001fc01ba8:  00 03 1c 38 dsll	v1,v1,16
[ 519] 0x900000001fc01bac:  64 63 74 08 daddiu	v1,v1,29704
  520: 	bge	v0,v1,testDcacheDone
[ 520] 0x900000001fc01bb0:  00 43 08 2a slt	at,v0,v1
[ 520] 0x900000001fc01bb4:  10 20 00 1f beq	at,zero,0x900000001fc01c34
  521: 	nop
[ 521] 0x900000001fc01bb8:  00 00 00 00 nop
  522: 	lw	v1,CP_DATA_LO(v0)	/* Pick up pattern */
[ 522] 0x900000001fc01bbc:  8c 43 00 14 lw	v1,20(v0)
  523:         lw	t3,CP_ECC(v0)
[ 523] 0x900000001fc01bc0:  8c 4f 00 08 lw	t3,8(v0)
  524: 	
  525: 	/*
  526: 	 * Loop through all lines and write the Data. Note that
  527: 	 * the parity may be incorrect, but we ONLY access the data at
  528: 	 * this point using the cache instruction which ignores parity.
  529: 	 */
  530: 
  531: 	move	a3,t0			/* # lines */
[ 531] 0x900000001fc01bc4:  01 80 38 25 move	a3,t0
  532: 	dli	t2,K0_BASE
[ 532] 0x900000001fc01bc8:  24 0e 00 15 li	t2,21
[ 532] 0x900000001fc01bcc:  00 0e 76 fc dsll32	t2,t2,27
  533: 
  534: 	DMTC0(v1, C0_TAGLO)
[ 534] 0x900000001fc01bd0:  40 a3 e0 00 dmtc0	v1,taglo
  535: 	DMTC0(t3, C0_ECC)
[ 535] 0x900000001fc01bd4:  40 af d0 00 dmtc0	t3,ecc
  536: 2:
  537:         /* 
  538: 	 * Fill the line with the pattern in both "ways". t2 has the
  539: 	 * virtual address of the start of the cache line. 
  540: 	 */
  541:         li	a0,CACHE_DLINE_SIZE/4
[ 541] 0x900000001fc01bd8:  24 04 00 08 li	a0,8
  542: 
  543: 	DCACHE(C_ISD, 0(t2))
[ 543] 0x900000001fc01bdc:  bd dd 00 00 cache	Hit_Set_Virtual[D],0(t2)
  544: 	DCACHE(C_ISD, 1(t2))
[ 544] 0x900000001fc01be0:  bd dd 00 01 cache	Hit_Set_Virtual[D],1(t2)
  545: 
  546: 3:					/* Loop over all words in line */
  547:         DCACHE(C_ILD, 0(t2))
[ 547] 0x900000001fc01be4:  bd d9 00 00 cache	Hit_WriteBack[D],0(t2)
  548:         MFC0(a1,C0_ECC)
[ 548] 0x900000001fc01be8:  40 05 d0 00 mfc0	a1,ecc
  549:         bne	a1,t3,testDcacheFailDataWay0
[ 549] 0x900000001fc01bec:  14 af 00 58 bne	a1,t3,0x900000001fc01d50
  550:         MFC0(a2,C0_TAGLO)		/* DELAY */
[ 550] 0x900000001fc01bf0:  40 06 e0 00 mfc0	a2,taglo
  551:         bne	a2,v1,testDcacheFailDataWay0
[ 551] 0x900000001fc01bf4:  14 c3 00 56 bne	a2,v1,0x900000001fc01d50
  552: 	nop
[ 552] 0x900000001fc01bf8:  00 00 00 00 nop
  553: 
  554:         DCACHE(C_ILD, 1(t2))
[ 554] 0x900000001fc01bfc:  bd d9 00 01 cache	Hit_WriteBack[D],1(t2)
  555:         MFC0(a1,C0_ECC)
[ 555] 0x900000001fc01c00:  40 05 d0 00 mfc0	a1,ecc
  556:         bne	a1,t3,testDcacheFailDataWay1
[ 556] 0x900000001fc01c04:  14 af 00 5a bne	a1,t3,0x900000001fc01d70
  557:         MFC0(a2,C0_TAGLO)		/* DELAY */
[ 557] 0x900000001fc01c08:  40 06 e0 00 mfc0	a2,taglo
  558:         bne	a2,v1,testDcacheFailDataWay1
[ 558] 0x900000001fc01c0c:  14 c3 00 58 bne	a2,v1,0x900000001fc01d70
  559: 	nop
[ 559] 0x900000001fc01c10:  00 00 00 00 nop
  560: 
  561:         sub	a0,1
[ 561] 0x900000001fc01c14:  20 84 ff ff addi	a0,a0,-1
  562: 	bgtz	a0,3b			/* more words in line */
[ 562] 0x900000001fc01c18:  1c 80 ff f2 bgtz	a0,0x900000001fc01be4
  563: 	nop
[ 563] 0x900000001fc01c1c:  00 00 00 00 nop
  564: 
  565: 	sub	a3,1
[ 565] 0x900000001fc01c20:  20 e7 ff ff addi	a3,a3,-1
  566: 	bgtz	a3,2b			/* See if more to do ... */
[ 566] 0x900000001fc01c24:  1c e0 ff ec bgtz	a3,0x900000001fc01bd8
  567: 	daddu	t2,CACHE_DLINE_SIZE
[ 567] 0x900000001fc01c28:  65 ce 00 20 daddiu	t2,t2,32
  568: 	
  569: 	/*
  570: 	 * Move onto next test pattern.
  571: 	 */
  572: 	j	1b
[ 572] 0x900000001fc01c2c:  0b f0 06 e6 j		(testDcache+260)
  573: 	daddu	v0,CP_SIZE
[ 573] 0x900000001fc01c30:  64 42 00 18 daddiu	v0,v0,24
  574: 
  575: testDcacheDone:	
  576: 	j	ra
[ 576] 0x900000001fc01c34:  03 e0 00 08 jr	ra
  577: 	move	v0,zero			/* success */
[ 577] 0x900000001fc01c38:  00 00 10 25 move	v0,zero
  578: 	
  579: testDcacheFailAddrWay0:
  580:         MESSAGE(a0, "\r\n  D-cache tag compare error: Way 0:")
[ 580] 0x900000001fc01c3c:  3c 04 90 00 lui	a0,0x9000
[ 580] 0x900000001fc01c40:  64 84 00 00 daddiu	a0,a0,0
[ 580] 0x900000001fc01c44:  00 04 24 38 dsll	a0,a0,16
[ 580] 0x900000001fc01c48:  64 84 1f c1 daddiu	a0,a0,8129
[ 580] 0x900000001fc01c4c:  00 04 24 38 dsll	a0,a0,16
[ 580] 0x900000001fc01c50:  64 84 75 21 daddiu	a0,a0,29985
  581:         b	testDcacheFailAddr
[ 581] 0x900000001fc01c54:  10 00 00 07 b		0x900000001fc01c74
  582: 	nop
[ 582] 0x900000001fc01c58:  00 00 00 00 nop
  583: testDcacheFailAddrWay1:
  584:         MESSAGE(a0, "\r\n  D-cache tag compare error: Way 1:")
[ 584] 0x900000001fc01c5c:  3c 04 90 00 lui	a0,0x9000
[ 584] 0x900000001fc01c60:  64 84 00 00 daddiu	a0,a0,0
[ 584] 0x900000001fc01c64:  00 04 24 38 dsll	a0,a0,16
[ 584] 0x900000001fc01c68:  64 84 1f c1 daddiu	a0,a0,8129
[ 584] 0x900000001fc01c6c:  00 04 24 38 dsll	a0,a0,16
[ 584] 0x900000001fc01c70:  64 84 75 47 daddiu	a0,a0,30023
  585: testDcacheFailAddr:
  586: 	/*
  587: 	 * Dump information on the failure:
  588: 	 *	a1/a2 - read taglo/taghi
  589: 	 *      t3/v1 - expected taglo/taghi
  590: 	 *	t2 - address
  591: 	 */
  592:  
  593:         dsll	a2,32
[ 593] 0x900000001fc01c74:  00 06 30 3c dsll32	a2,a2,0
  594:         dsll	a1,32
[ 594] 0x900000001fc01c78:  00 05 28 3c dsll32	a1,a1,0
  595:         dsrl	a1,32
[ 595] 0x900000001fc01c7c:  00 05 28 3e dsrl32	a1,a1,0
  596:         or	a2,a1				/* 64-bit read value */
[ 596] 0x900000001fc01c80:  00 c5 30 25 or	a2,a2,a1
  597: 
  598:         dsll	v1,32
[ 598] 0x900000001fc01c84:  00 03 18 3c dsll32	v1,v1,0
  599:         dsll	t3,32
[ 599] 0x900000001fc01c88:  00 0f 78 3c dsll32	t3,t3,0
  600:         dsrl	t3,32
[ 600] 0x900000001fc01c8c:  00 0f 78 3e dsrl32	t3,t3,0
  601:         or	t3,v1			/* 64-bit expected value */
[ 601] 0x900000001fc01c90:  01 e3 78 25 or	t3,t3,v1
  602: 
  603:         move	t1, ra
[ 603] 0x900000001fc01c94:  03 e0 68 25 move	t1,ra
  604: 
  605: 	PMESSAGE_PTR(a0); PMESSAGE(" address: 0x"); PHEX(t2);
[ 605] 0x900000001fc01c98:  00 84 20 25 or	a0,a0,a0
[ 605] 0x900000001fc01c9c:  0f f0 15 03 jal		pod_puts
[ 605] 0x900000001fc01ca0:  00 00 00 00 nop
[ 605] 0x900000001fc01ca4:  3c 04 90 00 lui	a0,0x9000
[ 605] 0x900000001fc01ca8:  64 84 00 00 daddiu	a0,a0,0
[ 605] 0x900000001fc01cac:  00 04 24 38 dsll	a0,a0,16
[ 605] 0x900000001fc01cb0:  64 84 1f c1 daddiu	a0,a0,8129
[ 605] 0x900000001fc01cb4:  00 04 24 38 dsll	a0,a0,16
[ 605] 0x900000001fc01cb8:  64 84 75 6d daddiu	a0,a0,30061
[ 605] 0x900000001fc01cbc:  0f f0 15 03 jal		pod_puts
[ 605] 0x900000001fc01cc0:  00 00 00 00 nop
[ 605] 0x900000001fc01cc4:  00 0e 20 25 or	a0,zero,t2
[ 605] 0x900000001fc01cc8:  0f f0 14 f8 jal		pod_puthex64
[ 605] 0x900000001fc01ccc:  00 00 00 00 nop
  606:         PMESSAGE("\n\r\t wrote: 0x"); PHEX(t3);
[ 606] 0x900000001fc01cd0:  3c 04 90 00 lui	a0,0x9000
[ 606] 0x900000001fc01cd4:  64 84 00 00 daddiu	a0,a0,0
[ 606] 0x900000001fc01cd8:  00 04 24 38 dsll	a0,a0,16
[ 606] 0x900000001fc01cdc:  64 84 1f c1 daddiu	a0,a0,8129
[ 606] 0x900000001fc01ce0:  00 04 24 38 dsll	a0,a0,16
[ 606] 0x900000001fc01ce4:  64 84 75 7a daddiu	a0,a0,30074
[ 606] 0x900000001fc01ce8:  0f f0 15 03 jal		pod_puts
[ 606] 0x900000001fc01cec:  00 00 00 00 nop
[ 606] 0x900000001fc01cf0:  00 0f 20 25 or	a0,zero,t3
[ 606] 0x900000001fc01cf4:  0f f0 14 f8 jal		pod_puthex64
[ 606] 0x900000001fc01cf8:  00 00 00 00 nop
  607:         PMESSAGE(" read: 0x"); PHEX(a2);
[ 607] 0x900000001fc01cfc:  3c 04 90 00 lui	a0,0x9000
[ 607] 0x900000001fc01d00:  64 84 00 00 daddiu	a0,a0,0
[ 607] 0x900000001fc01d04:  00 04 24 38 dsll	a0,a0,16
[ 607] 0x900000001fc01d08:  64 84 1f c1 daddiu	a0,a0,8129
[ 607] 0x900000001fc01d0c:  00 04 24 38 dsll	a0,a0,16
[ 607] 0x900000001fc01d10:  64 84 75 88 daddiu	a0,a0,30088
[ 607] 0x900000001fc01d14:  0f f0 15 03 jal		pod_puts
[ 607] 0x900000001fc01d18:  00 00 00 00 nop
[ 607] 0x900000001fc01d1c:  00 06 20 25 or	a0,zero,a2
[ 607] 0x900000001fc01d20:  0f f0 14 f8 jal		pod_puthex64
[ 607] 0x900000001fc01d24:  00 00 00 00 nop
  608:         PMESSAGE("\n\r");
[ 608] 0x900000001fc01d28:  3c 04 90 00 lui	a0,0x9000
[ 608] 0x900000001fc01d2c:  64 84 00 00 daddiu	a0,a0,0
[ 608] 0x900000001fc01d30:  00 04 24 38 dsll	a0,a0,16
[ 608] 0x900000001fc01d34:  64 84 1f c1 daddiu	a0,a0,8129
[ 608] 0x900000001fc01d38:  00 04 24 38 dsll	a0,a0,16
[ 608] 0x900000001fc01d3c:  64 84 75 92 daddiu	a0,a0,30098
[ 608] 0x900000001fc01d40:  0f f0 15 03 jal		pod_puts
[ 608] 0x900000001fc01d44:  00 00 00 00 nop
  609: 	j	t1
[ 609] 0x900000001fc01d48:  01 a0 00 08 jr	t1
  610: 	ori	v0,zero,EVDIAG_DCACHE_ADDR	/* DELAY */
[ 610] 0x900000001fc01d4c:  34 02 00 02 ori	v0,zero,0x2
  611: 
  612: testDcacheFailDataWay0:
  613: 	MESSAGE(a0, "\r\n  D-cache data compare error: Way 0:")
[ 613] 0x900000001fc01d50:  3c 04 90 00 lui	a0,0x9000
[ 613] 0x900000001fc01d54:  64 84 00 00 daddiu	a0,a0,0
[ 613] 0x900000001fc01d58:  00 04 24 38 dsll	a0,a0,16
[ 613] 0x900000001fc01d5c:  64 84 1f c1 daddiu	a0,a0,8129
[ 613] 0x900000001fc01d60:  00 04 24 38 dsll	a0,a0,16
[ 613] 0x900000001fc01d64:  64 84 75 95 daddiu	a0,a0,30101
  614: 	b	testDcacheFailData
[ 614] 0x900000001fc01d68:  10 00 00 07 b		0x900000001fc01d88
  615: 	nop
[ 615] 0x900000001fc01d6c:  00 00 00 00 nop
  616: testDcacheFailDataWay1:
  617: 	MESSAGE(a0, "\r\n  D-cache data compare error: Way 1:")
[ 617] 0x900000001fc01d70:  3c 04 90 00 lui	a0,0x9000
[ 617] 0x900000001fc01d74:  64 84 00 00 daddiu	a0,a0,0
[ 617] 0x900000001fc01d78:  00 04 24 38 dsll	a0,a0,16
[ 617] 0x900000001fc01d7c:  64 84 1f c1 daddiu	a0,a0,8129
[ 617] 0x900000001fc01d80:  00 04 24 38 dsll	a0,a0,16
[ 617] 0x900000001fc01d84:  64 84 75 bc daddiu	a0,a0,30140
  618: testDcacheFailData:	
  619: 	/*
  620: 	 * Dump information on the failure:
  621: 	 *	a1/a2 - read ecc/taglo
  622: 	 *      t3/v1 - expected ecc/taglo
  623: 	 *	t2 - address
  624: 	 */
  625: 	move	a3,a1			/* A1 - clobber by I/O */
[ 625] 0x900000001fc01d88:  00 a0 38 25 move	a3,a1
  626: 	move	t0,v1			/* Clobbered by I/O */
[ 626] 0x900000001fc01d8c:  00 60 60 25 move	t0,v1
  627: 	
  628:         move	t1, ra
[ 628] 0x900000001fc01d90:  03 e0 68 25 move	t1,ra
  629: 
  630: 	PMESSAGE_PTR(a0); PMESSAGE(" address: 0x"); PHEX(t2);
[ 630] 0x900000001fc01d94:  00 84 20 25 or	a0,a0,a0
[ 630] 0x900000001fc01d98:  0f f0 15 03 jal		pod_puts
[ 630] 0x900000001fc01d9c:  00 00 00 00 nop
[ 630] 0x900000001fc01da0:  3c 04 90 00 lui	a0,0x9000
[ 630] 0x900000001fc01da4:  64 84 00 00 daddiu	a0,a0,0
[ 630] 0x900000001fc01da8:  00 04 24 38 dsll	a0,a0,16
[ 630] 0x900000001fc01dac:  64 84 1f c1 daddiu	a0,a0,8129
[ 630] 0x900000001fc01db0:  00 04 24 38 dsll	a0,a0,16
[ 630] 0x900000001fc01db4:  64 84 75 e3 daddiu	a0,a0,30179
[ 630] 0x900000001fc01db8:  0f f0 15 03 jal		pod_puts
[ 630] 0x900000001fc01dbc:  00 00 00 00 nop
[ 630] 0x900000001fc01dc0:  00 0e 20 25 or	a0,zero,t2
[ 630] 0x900000001fc01dc4:  0f f0 14 f8 jal		pod_puthex64
[ 630] 0x900000001fc01dc8:  00 00 00 00 nop
  631:         PMESSAGE("\n\r\t wrote(data/parity): 0x"); PHEX32(t0); 
[ 631] 0x900000001fc01dcc:  3c 04 90 00 lui	a0,0x9000
[ 631] 0x900000001fc01dd0:  64 84 00 00 daddiu	a0,a0,0
[ 631] 0x900000001fc01dd4:  00 04 24 38 dsll	a0,a0,16
[ 631] 0x900000001fc01dd8:  64 84 1f c1 daddiu	a0,a0,8129
[ 631] 0x900000001fc01ddc:  00 04 24 38 dsll	a0,a0,16
[ 631] 0x900000001fc01de0:  64 84 75 f0 daddiu	a0,a0,30192
[ 631] 0x900000001fc01de4:  0f f0 15 03 jal		pod_puts
[ 631] 0x900000001fc01de8:  00 00 00 00 nop
[ 631] 0x900000001fc01dec:  00 0c 20 25 or	a0,zero,t0
[ 631] 0x900000001fc01df0:  0f f0 14 ed jal		pod_puthex32
[ 631] 0x900000001fc01df4:  00 00 00 00 nop
  632: 		PMESSAGE("/0x"); PHEX32(t3);
[ 632] 0x900000001fc01df8:  3c 04 90 00 lui	a0,0x9000
[ 632] 0x900000001fc01dfc:  64 84 00 00 daddiu	a0,a0,0
[ 632] 0x900000001fc01e00:  00 04 24 38 dsll	a0,a0,16
[ 632] 0x900000001fc01e04:  64 84 1f c1 daddiu	a0,a0,8129
[ 632] 0x900000001fc01e08:  00 04 24 38 dsll	a0,a0,16
[ 632] 0x900000001fc01e0c:  64 84 76 0b daddiu	a0,a0,30219
[ 632] 0x900000001fc01e10:  0f f0 15 03 jal		pod_puts
[ 632] 0x900000001fc01e14:  00 00 00 00 nop
[ 632] 0x900000001fc01e18:  00 0f 20 25 or	a0,zero,t3
[ 632] 0x900000001fc01e1c:  0f f0 14 ed jal		pod_puthex32
[ 632] 0x900000001fc01e20:  00 00 00 00 nop
  633:         PMESSAGE(" read(data/parity): 0x"); PHEX32(a2);
[ 633] 0x900000001fc01e24:  3c 04 90 00 lui	a0,0x9000
[ 633] 0x900000001fc01e28:  64 84 00 00 daddiu	a0,a0,0
[ 633] 0x900000001fc01e2c:  00 04 24 38 dsll	a0,a0,16
[ 633] 0x900000001fc01e30:  64 84 1f c1 daddiu	a0,a0,8129
[ 633] 0x900000001fc01e34:  00 04 24 38 dsll	a0,a0,16
[ 633] 0x900000001fc01e38:  64 84 76 0f daddiu	a0,a0,30223
[ 633] 0x900000001fc01e3c:  0f f0 15 03 jal		pod_puts
[ 633] 0x900000001fc01e40:  00 00 00 00 nop
[ 633] 0x900000001fc01e44:  00 06 20 25 or	a0,zero,a2
[ 633] 0x900000001fc01e48:  0f f0 14 ed jal		pod_puthex32
[ 633] 0x900000001fc01e4c:  00 00 00 00 nop
  634: 		PMESSAGE("/0x"); PHEX32(a3);
[ 634] 0x900000001fc01e50:  3c 04 90 00 lui	a0,0x9000
[ 634] 0x900000001fc01e54:  64 84 00 00 daddiu	a0,a0,0
[ 634] 0x900000001fc01e58:  00 04 24 38 dsll	a0,a0,16
[ 634] 0x900000001fc01e5c:  64 84 1f c1 daddiu	a0,a0,8129
[ 634] 0x900000001fc01e60:  00 04 24 38 dsll	a0,a0,16
[ 634] 0x900000001fc01e64:  64 84 76 26 daddiu	a0,a0,30246
[ 634] 0x900000001fc01e68:  0f f0 15 03 jal		pod_puts
[ 634] 0x900000001fc01e6c:  00 00 00 00 nop
[ 634] 0x900000001fc01e70:  00 07 20 25 or	a0,zero,a3
[ 634] 0x900000001fc01e74:  0f f0 14 ed jal		pod_puthex32
[ 634] 0x900000001fc01e78:  00 00 00 00 nop
  635:         PMESSAGE("\n\r");
[ 635] 0x900000001fc01e7c:  3c 04 90 00 lui	a0,0x9000
[ 635] 0x900000001fc01e80:  64 84 00 00 daddiu	a0,a0,0
[ 635] 0x900000001fc01e84:  00 04 24 38 dsll	a0,a0,16
[ 635] 0x900000001fc01e88:  64 84 1f c1 daddiu	a0,a0,8129
[ 635] 0x900000001fc01e8c:  00 04 24 38 dsll	a0,a0,16
[ 635] 0x900000001fc01e90:  64 84 76 2a daddiu	a0,a0,30250
[ 635] 0x900000001fc01e94:  0f f0 15 03 jal		pod_puts
[ 635] 0x900000001fc01e98:  00 00 00 00 nop
  636: 	
  637: 	j	t1
[ 637] 0x900000001fc01e9c:  01 a0 00 08 jr	t1
  638: 	ori	v0,zero,EVDIAG_DCACHE_DATA	/* DELAY */
[ 638] 0x900000001fc01ea0:  34 02 00 01 ori	v0,zero,0x1
  639: 
  640: testDcacheFail:
  641: 	
  642: 	END(testDcache)
  643: 
  644: 
  645: 	.text
  646: 
  647: /*
  648:  * Function:	invalidateIcache
  649:  * Purpsoe:	To invalidate the primary icache and leave it in a consistent
  650:  * 		state.
  651:  * Parameters:	none
  652:  * Returns:	nothing
  653:  * Notes:	uses t0,t1,v0,v1
  654:  */
  655: LEAF(invalidateIcache)
  656: 	.set	noreorder
  657:         LEDS(PLED_INVICACHE)
invalidateIcache:
[ 657] 0x900000001fc01ea4:  00 00 00 00 nop
[ 657] 0x900000001fc01ea8:  34 04 00 09 ori	a0,zero,0x9
[ 657] 0x900000001fc01eac:  3c 02 90 00 lui	v0,0x9000
[ 657] 0x900000001fc01eb0:  00 02 14 38 dsll	v0,v0,16
[ 657] 0x900000001fc01eb4:  34 42 19 00 ori	v0,v0,0x1900
[ 657] 0x900000001fc01eb8:  00 02 14 38 dsll	v0,v0,16
[ 657] 0x900000001fc01ebc:  34 42 40 00 ori	v0,v0,0x4000
[ 657] 0x900000001fc01ec0:  fc 44 00 00 sd	a0,0(v0)
  658: 	move	t0,ra			/* Remeber way home */
[ 658] 0x900000001fc01ec4:  03 e0 60 25 move	t0,ra
  659: 	jal	iCacheSize
[ 659] 0x900000001fc01ec8:  0f f0 05 88 jal		iCacheSize
  660: 	nop
[ 660] 0x900000001fc01ecc:  00 00 00 00 nop
  661: 	move	ra,t0			/* Back to its place */
[ 661] 0x900000001fc01ed0:  01 80 f8 25 move	ra,t0
  662: 	divu	v0,CACHE_ILINE_SIZE*2	/* # of lines/ways */
[ 662] 0x900000001fc01ed4:  00 02 11 c2 srl	v0,v0,7
  663: 
  664: 	/*
  665: 	 * For each cache line, we build a valid looking tag, except
  666: 	 * that the state indicates the line is invalid. As it turns out,
  667: 	 * parity fields are even, and "0" is an invalid line.
  668: 	 */
  669: 
  670: 	MTC0(zero, C0_TAGLO)		
[ 670] 0x900000001fc01ed8:  40 80 e0 00 mtc0	zero,taglo
  671: 	MTC0(zero, C0_TAGHI)		/* Tag registers */
[ 671] 0x900000001fc01edc:  40 80 e8 00 mtc0	zero,taghi
  672: 	DMTC0(zero, C0_ECC)		/* 0's - even parity */
[ 672] 0x900000001fc01ee0:  40 a0 d0 00 dmtc0	zero,ecc
  673: 
  674: 	/* first the tags */
  675: 	
  676: 	move	t0,zero
[ 676] 0x900000001fc01ee4:  00 00 60 25 move	t0,zero
  677: 	dli	t1,K0_BASE
[ 677] 0x900000001fc01ee8:  24 0d 00 15 li	t1,21
[ 677] 0x900000001fc01eec:  00 0d 6e fc dsll32	t1,t1,27
  678: 1:	
  679: 	ICACHE(C_IST, 0(t1))		/* way 0 */
[ 679] 0x900000001fc01ef0:  bd a8 00 00 cache	Index_Store_Tag[I],0(t1)
  680: 	ICACHE(C_IST, 1(t1))		/* way 1 */
[ 680] 0x900000001fc01ef4:  bd a8 00 01 cache	Index_Store_Tag[I],1(t1)
  681: 	daddu	t1, CACHE_ILINE_SIZE
[ 681] 0x900000001fc01ef8:  65 ad 00 40 daddiu	t1,t1,64
  682: 	add	t0,1
[ 682] 0x900000001fc01efc:  21 8c 00 01 addi	t0,t0,1
  683: 	ble	t0,v0,1b
[ 683] 0x900000001fc01f00:  00 4c 08 2a slt	at,v0,t0
[ 683] 0x900000001fc01f04:  10 20 ff fa beq	at,zero,0x900000001fc01ef0
  684: 	nop
[ 684] 0x900000001fc01f08:  00 00 00 00 nop
  685: 
  686: 	/* 
  687: 	 * Now for safty, the data - even parity, so taglo/hi are
  688: 	 * still ok.
  689: 	 */
  690: 
  691: 	dli	t1,K0_BASE
[ 691] 0x900000001fc01f0c:  24 0d 00 15 li	t1,21
[ 691] 0x900000001fc01f10:  00 0d 6e fc dsll32	t1,t1,27
  692: 	dli	t0,CACHE_ILINE_SIZE
[ 692] 0x900000001fc01f14:  24 0c 00 40 li	t0,64
  693: 	mult	v0,t0			/* Total # bytes per way */
[ 693] 0x900000001fc01f18:  00 4c 00 18 mult	v0,t0
  694: 	mflo	v0
[ 694] 0x900000001fc01f1c:  00 00 10 12 mflo	v0
  695: 1:
  696: 	ICACHE(C_ISD, 0(t1))
[ 696] 0x900000001fc01f20:  bd bc 00 00 cache	Hit_Set_Virtual[I],0(t1)
  697: 	ICACHE(C_ISD, 1(t1))
[ 697] 0x900000001fc01f24:  bd bc 00 01 cache	Hit_Set_Virtual[I],1(t1)
  698: 	sub	v0,4			/* count -= word size */
[ 698] 0x900000001fc01f28:  20 42 ff fc addi	v0,v0,-4
  699: 	daddu	t1,4			/* DELAY: address += word size */
[ 699] 0x900000001fc01f2c:  65 ad 00 04 daddiu	t1,t1,4
  700: 	bgtz	v0,1b
[ 700] 0x900000001fc01f30:  1c 40 ff fb bgtz	v0,0x900000001fc01f20
  701: 	nop
[ 701] 0x900000001fc01f34:  00 00 00 00 nop
  702: 	
  703: 	j	ra
[ 703] 0x900000001fc01f38:  03 e0 00 08 jr	ra
  704: 	nop
[ 704] 0x900000001fc01f3c:  00 00 00 00 nop
  705: 	END(invalidateIcache)
  706: 	
  707: /*
  708:  * Function:	invalidateDcache
  709:  * Purpsoe:	To invalidate the primary icache and leave it in a consistent
  710:  * 		state.
  711:  * Parameters:	none
  712:  * Returns:	nothing
  713:  * Notes:	uses v0,v1 t0/t1 registers.
  714:  */
  715: LEAF(invalidateDcache)
  716: 	.set	noreorder
  717:         LEDS(PLED_INVDCACHE)
invalidateDcache:
[ 717] 0x900000001fc01f40:  00 00 00 00 nop
[ 717] 0x900000001fc01f44:  34 04 00 0a ori	a0,zero,0xa
[ 717] 0x900000001fc01f48:  3c 02 90 00 lui	v0,0x9000
[ 717] 0x900000001fc01f4c:  00 02 14 38 dsll	v0,v0,16
[ 717] 0x900000001fc01f50:  34 42 19 00 ori	v0,v0,0x1900
[ 717] 0x900000001fc01f54:  00 02 14 38 dsll	v0,v0,16
[ 717] 0x900000001fc01f58:  34 42 40 00 ori	v0,v0,0x4000
[ 717] 0x900000001fc01f5c:  fc 44 00 00 sd	a0,0(v0)
  718: 	move	t0,ra			/* Remeber way home */
[ 718] 0x900000001fc01f60:  03 e0 60 25 move	t0,ra
  719: 	jal	dCacheSize
[ 719] 0x900000001fc01f64:  0f f0 05 91 jal		dCacheSize
  720: 	nop
[ 720] 0x900000001fc01f68:  00 00 00 00 nop
  721: 	move	ra,t0			/* Back to its place */
[ 721] 0x900000001fc01f6c:  01 80 f8 25 move	ra,t0
  722: 	divu	v0,CACHE_DLINE_SIZE*2	/* # of lines/ways */
[ 722] 0x900000001fc01f70:  00 02 11 82 srl	v0,v0,6
  723: 
  724: 	/*
  725: 	 * For each cache line, we build a valid looking tag, except
  726: 	 * that the state indicates the line is invalid. As it turns out,
  727: 	 * parity fields are even, and "0" is an invalid line - except
  728: 	 * for the statemod field, which must be "NORMAL" or 1.
  729: 	 */
  730: 
  731: 	dli	t0,(CTP_STATEMOD_N << CTP_STATEMOD_SHFT) >> 32
[ 731] 0x900000001fc01f74:  3c 0c 20 00 lui	t0,0x2000
  732: 
  733: 	MTC0(zero, C0_TAGLO)		
[ 733] 0x900000001fc01f78:  40 80 e0 00 mtc0	zero,taglo
  734: 	MTC0(t0, C0_TAGHI)		/* Tag registers */
[ 734] 0x900000001fc01f7c:  40 8c e8 00 mtc0	t0,taghi
  735: 	DMTC0(zero, C0_ECC)		/* 0's - even parity */
[ 735] 0x900000001fc01f80:  40 a0 d0 00 dmtc0	zero,ecc
  736: 
  737: 	/* first the tags */
  738: 	
  739: 	move	t0,zero
[ 739] 0x900000001fc01f84:  00 00 60 25 move	t0,zero
  740: 	dli	t1,K0_BASE
[ 740] 0x900000001fc01f88:  24 0d 00 15 li	t1,21
[ 740] 0x900000001fc01f8c:  00 0d 6e fc dsll32	t1,t1,27
  741: 1:	
  742: 	DCACHE(C_IST, 0(t1))		/* way 0 */
[ 742] 0x900000001fc01f90:  bd a9 00 00 cache	Index_Store_Tag[D],0(t1)
  743: 	DCACHE(C_IST, 1(t1))		/* way 1 */
[ 743] 0x900000001fc01f94:  bd a9 00 01 cache	Index_Store_Tag[D],1(t1)
  744: 	daddu	t1, CACHE_DLINE_SIZE
[ 744] 0x900000001fc01f98:  65 ad 00 20 daddiu	t1,t1,32
  745: 	add	t0,1
[ 745] 0x900000001fc01f9c:  21 8c 00 01 addi	t0,t0,1
  746: 	ble	t0,v0,1b
[ 746] 0x900000001fc01fa0:  00 4c 08 2a slt	at,v0,t0
[ 746] 0x900000001fc01fa4:  10 20 ff fa beq	at,zero,0x900000001fc01f90
  747: 	nop
[ 747] 0x900000001fc01fa8:  00 00 00 00 nop
  748: 
  749: 	/* 
  750: 	 *  Now for safty, the data. TAGLO and ECC used, but even
  751: 	 *  parity so 0's works out well.
  752: 	 */
  753: 
  754: 	dli	t1,K0_BASE
[ 754] 0x900000001fc01fac:  24 0d 00 15 li	t1,21
[ 754] 0x900000001fc01fb0:  00 0d 6e fc dsll32	t1,t1,27
  755: 	dli	t0,CACHE_DLINE_SIZE
[ 755] 0x900000001fc01fb4:  24 0c 00 20 li	t0,32
  756: 	mult	v0,t0			/* total bytes per way */
[ 756] 0x900000001fc01fb8:  00 4c 00 18 mult	v0,t0
  757: 	mflo	v0
[ 757] 0x900000001fc01fbc:  00 00 10 12 mflo	v0
  758: 1:	
  759: 	DCACHE(C_ISD, 0(t1))
[ 759] 0x900000001fc01fc0:  bd bd 00 00 cache	Hit_Set_Virtual[D],0(t1)
  760: 	DCACHE(C_ISD, 1(t1))
[ 760] 0x900000001fc01fc4:  bd bd 00 01 cache	Hit_Set_Virtual[D],1(t1)
  761: 	sub	v0,4			/* count -= word size */
[ 761] 0x900000001fc01fc8:  20 42 ff fc addi	v0,v0,-4
  762: 	daddu	t1,4			/* DELAY: address += word size */
[ 762] 0x900000001fc01fcc:  65 ad 00 04 daddiu	t1,t1,4
  763: 	bge	v0,zero,1b
[ 763] 0x900000001fc01fd0:  04 41 ff fb bgez	v0,0x900000001fc01fc0
  764: 	nop
[ 764] 0x900000001fc01fd4:  00 00 00 00 nop
  765: 
  766: 	j	ra
[ 766] 0x900000001fc01fd8:  03 e0 00 08 jr	ra
  767: 	nop
[ 767] 0x900000001fc01fdc:  00 00 00 00 nop
  768: 	END(invalidateDcache)
  769: 
  770: /*
  771:  * Function:	invalidateIDcache
  772:  * Purpose:	To invalidate the primary I & D cache and leave them 
  773:  * 		in a consistent	state.
  774:  * Parameters:	none
  775:  * Returns:	nothing
  776:  * Notes:	uses t0/t1 registers.
  777:  */
  778: LEAF(invalidateIDcache)
  779: 	move	t2,ra
invalidateIDcache:
[ 779] 0x900000001fc01fe0:  03 e0 70 25 move	t2,ra
  780: 	jal	invalidateIcache
[ 780] 0x900000001fc01fe4:  0f f0 07 a9 jal		invalidateIcache
  781: 	nop
[ 781] 0x900000001fc01fe8:  00 00 00 00 nop
  782: 	jal	invalidateDcache
[ 782] 0x900000001fc01fec:  0f f0 07 d0 jal		invalidateDcache
  783: 	nop
[ 783] 0x900000001fc01ff0:  00 00 00 00 nop
  784: 	j	t2
[ 784] 0x900000001fc01ff4:  01 c0 00 08 jr	t2
  785: 	nop
[ 785] 0x900000001fc01ff8:  00 00 00 00 nop
  786: 	END(invalidateIDcache)
  787: 	
  788: LEAF(invalidateCCtags)
  789: /*
  790:  * Function:	invalidateCCtags
  791:  * Purpose:	To invalidate the SCC duplicate tags.
  792:  * Parameters:	none
  793:  * Returns:	nothing
  794:  * Notes:	uses .... lots
  795:  *		This routine copies a segment of code to the Scache and
  796:  *		then the icache.
  797:  */
  798:        .set	noreorder
  799: #if !defined(SABLE)
  800:        move 	s7,ra
invalidateCCtags:
[ 800] 0x900000001fc01ffc:  03 e0 b8 25 move	s7,ra
  801:        LEDS(PLED_INVCCTAGS)
[ 801] 0x900000001fc02000:  00 00 00 00 nop
[ 801] 0x900000001fc02004:  34 04 00 0c ori	a0,zero,0xc
[ 801] 0x900000001fc02008:  3c 02 90 00 lui	v0,0x9000
[ 801] 0x900000001fc0200c:  00 02 14 38 dsll	v0,v0,16
[ 801] 0x900000001fc02010:  34 42 19 00 ori	v0,v0,0x1900
[ 801] 0x900000001fc02014:  00 02 14 38 dsll	v0,v0,16
[ 801] 0x900000001fc02018:  34 42 40 00 ori	v0,v0,0x4000
[ 801] 0x900000001fc0201c:  fc 44 00 00 sd	a0,0(v0)
  802:         /*
  803:          * Due to a CC chip "feature", we must configure the cache
  804:          * as maximum size (for shiva) and clear all the duplicate
  805: 	 * tags - even if the cache is not full size.
  806: 	 */
  807: 
  808: 	EV_GET_SPNUM(k0,k1)			/* our address */
[ 808] 0x900000001fc02020:  3c 1a 90 00 lui	k0,0x9000
[ 808] 0x900000001fc02024:  00 1a d4 38 dsll	k0,k0,16
[ 808] 0x900000001fc02028:  37 5a 18 00 ori	k0,k0,0x1800
[ 808] 0x900000001fc0202c:  00 1a d4 38 dsll	k0,k0,16
[ 808] 0x900000001fc02030:  37 5a 00 08 ori	k0,k0,0x8
[ 808] 0x900000001fc02034:  df 5a 00 00 ld	k0,0(k0)
[ 808] 0x900000001fc02038:  00 00 00 00 nop
[ 808] 0x900000001fc0203c:  33 5a 00 3f andi	k0,k0,0x3f
[ 808] 0x900000001fc02040:  33 5b 00 03 andi	k1,k0,0x3
[ 808] 0x900000001fc02044:  03 60 d8 21 addu	k1,k1,0
[ 808] 0x900000001fc02048:  00 1a d0 82 srl	k0,k0,2
  809: 	EV_GET_PROCREG(k0, k1, EV_CFG_CACHE_SZ, a4)
[ 809] 0x900000001fc0204c:  00 1b d9 80 sll	k1,k1,6
[ 809] 0x900000001fc02050:  63 7b 00 3e daddi	k1,k1,62
[ 809] 0x900000001fc02054:  00 1a d2 c0 sll	k0,k0,11
[ 809] 0x900000001fc02058:  3c 01 90 00 lui	at,0x9000
[ 809] 0x900000001fc0205c:  00 01 0c 38 dsll	at,at,16
[ 809] 0x900000001fc02060:  34 21 18 00 ori	at,at,0x1800
[ 809] 0x900000001fc02064:  00 01 0c 38 dsll	at,at,16
[ 809] 0x900000001fc02068:  34 21 80 00 ori	at,at,0x8000
[ 809] 0x900000001fc0206c:  03 41 d0 2c dadd	k0,k0,at
[ 809] 0x900000001fc02070:  00 1b 40 2c dadd	a4,zero,k1
[ 809] 0x900000001fc02074:  00 08 40 c0 sll	a4,a4,3
[ 809] 0x900000001fc02078:  03 48 d0 2c dadd	k0,k0,a4
[ 809] 0x900000001fc0207c:  df 48 00 00 ld	a4,0(k0)
[ 809] 0x900000001fc02080:  00 00 00 00 nop
  810: 	dli	a0,5
[ 810] 0x900000001fc02084:  24 04 00 05 li	a0,5
  811: 	EV_GET_SPNUM(k0,k1)			/* our address */
[ 811] 0x900000001fc02088:  3c 1a 90 00 lui	k0,0x9000
[ 811] 0x900000001fc0208c:  00 1a d4 38 dsll	k0,k0,16
[ 811] 0x900000001fc02090:  37 5a 18 00 ori	k0,k0,0x1800
[ 811] 0x900000001fc02094:  00 1a d4 38 dsll	k0,k0,16
[ 811] 0x900000001fc02098:  37 5a 00 08 ori	k0,k0,0x8
[ 811] 0x900000001fc0209c:  df 5a 00 00 ld	k0,0(k0)
[ 811] 0x900000001fc020a0:  00 00 00 00 nop
[ 811] 0x900000001fc020a4:  33 5a 00 3f andi	k0,k0,0x3f
[ 811] 0x900000001fc020a8:  33 5b 00 03 andi	k1,k0,0x3
[ 811] 0x900000001fc020ac:  03 60 d8 21 addu	k1,k1,0
[ 811] 0x900000001fc020b0:  00 1a d0 82 srl	k0,k0,2
  812: 	EV_SET_PROCREG(k0, k1, EV_CFG_CACHE_SZ, a0)
[ 812] 0x900000001fc020b4:  00 1b d9 80 sll	k1,k1,6
[ 812] 0x900000001fc020b8:  63 7b 00 3e daddi	k1,k1,62
[ 812] 0x900000001fc020bc:  00 1a d2 c0 sll	k0,k0,11
[ 812] 0x900000001fc020c0:  3c 01 90 00 lui	at,0x9000
[ 812] 0x900000001fc020c4:  00 01 0c 38 dsll	at,at,16
[ 812] 0x900000001fc020c8:  34 21 18 00 ori	at,at,0x1800
[ 812] 0x900000001fc020cc:  00 01 0c 38 dsll	at,at,16
[ 812] 0x900000001fc020d0:  34 21 80 00 ori	at,at,0x8000
[ 812] 0x900000001fc020d4:  03 41 d0 2c dadd	k0,k0,at
[ 812] 0x900000001fc020d8:  00 1b d8 2c dadd	k1,zero,k1
[ 812] 0x900000001fc020dc:  00 1b d8 c0 sll	k1,k1,3
[ 812] 0x900000001fc020e0:  03 5b d0 2c dadd	k0,k0,k1
[ 812] 0x900000001fc020e4:  00 04 d8 25 or	k1,zero,a0
[ 812] 0x900000001fc020e8:  ff 5b 00 00 sd	k1,0(k0)
[ 812] 0x900000001fc020ec:  00 00 00 00 nop
  813: 	GET_CC_REV(a0, a1)
[ 813] 0x900000001fc020f0:  3c 04 90 00 lui	a0,0x9000
[ 813] 0x900000001fc020f4:  00 04 24 38 dsll	a0,a0,16
[ 813] 0x900000001fc020f8:  34 84 18 00 ori	a0,a0,0x1800
[ 813] 0x900000001fc020fc:  00 04 24 38 dsll	a0,a0,16
[ 813] 0x900000001fc02100:  34 84 00 08 ori	a0,a0,0x8
[ 813] 0x900000001fc02104:  dc 84 00 00 ld	a0,0(a0)
[ 813] 0x900000001fc02108:  00 00 00 00 nop
[ 813] 0x900000001fc0210c:  30 84 00 3f andi	a0,a0,0x3f
[ 813] 0x900000001fc02110:  30 85 00 03 andi	a1,a0,0x3
[ 813] 0x900000001fc02114:  00 a0 28 21 addu	a1,a1,0
[ 813] 0x900000001fc02118:  00 04 20 82 srl	a0,a0,2
[ 813] 0x900000001fc0211c:  00 05 d9 80 sll	k1,a1,6
[ 813] 0x900000001fc02120:  63 7b 00 20 daddi	k1,k1,32
[ 813] 0x900000001fc02124:  00 04 d2 c0 sll	k0,a0,11
[ 813] 0x900000001fc02128:  3c 01 90 00 lui	at,0x9000
[ 813] 0x900000001fc0212c:  00 01 0c 38 dsll	at,at,16
[ 813] 0x900000001fc02130:  34 21 18 00 ori	at,at,0x1800
[ 813] 0x900000001fc02134:  00 01 0c 38 dsll	at,at,16
[ 813] 0x900000001fc02138:  34 21 80 00 ori	at,at,0x8000
[ 813] 0x900000001fc0213c:  03 41 d0 2c dadd	k0,k0,at
[ 813] 0x900000001fc02140:  00 1b 20 2c dadd	a0,zero,k1
[ 813] 0x900000001fc02144:  00 04 20 c0 sll	a0,a0,3
[ 813] 0x900000001fc02148:  03 44 d0 2c dadd	k0,k0,a0
[ 813] 0x900000001fc0214c:  df 44 00 00 ld	a0,0(k0)
[ 813] 0x900000001fc02150:  00 00 00 00 nop
[ 813] 0x900000001fc02154:  00 04 27 3a dsrl	a0,a0,28
[ 813] 0x900000001fc02158:  30 84 00 0f andi	a0,a0,0xf
  814: 	bne	a0,zero,invalidateCCtagsUncached
[ 814] 0x900000001fc0215c:  14 80 00 11 bne	a0,zero,0x900000001fc021a4
  815: 	nop
[ 815] 0x900000001fc02160:  00 00 00 00 nop
  816:         /*
  817: 	 * Now copy the code segment to the Icache, and run it.
  818: 	 */
  819:         dla	a0,1f
[ 819] 0x900000001fc02164:  3c 04 90 00 lui	a0,0x9000
[ 819] 0x900000001fc02168:  64 84 00 00 daddiu	a0,a0,0
[ 819] 0x900000001fc0216c:  00 04 24 38 dsll	a0,a0,16
[ 819] 0x900000001fc02170:  64 84 1f c0 daddiu	a0,a0,8128
[ 819] 0x900000001fc02174:  00 04 24 38 dsll	a0,a0,16
[ 819] 0x900000001fc02178:  64 84 22 00 daddiu	a0,a0,8704
  820:         dla	a1,2f
[ 820] 0x900000001fc0217c:  3c 05 90 00 lui	a1,0x9000
[ 820] 0x900000001fc02180:  64 a5 00 00 daddiu	a1,a1,0
[ 820] 0x900000001fc02184:  00 05 2c 38 dsll	a1,a1,16
[ 820] 0x900000001fc02188:  64 a5 1f c0 daddiu	a1,a1,8128
[ 820] 0x900000001fc0218c:  00 05 2c 38 dsll	a1,a1,16
[ 820] 0x900000001fc02190:  64 a5 23 00 daddiu	a1,a1,8960
  821:         jal	copyToICache
[ 821] 0x900000001fc02194:  0f f0 0b 99 jal		copyToICache
  822:         dsubu	a1,a0				/* DELAY: */
[ 822] 0x900000001fc02198:  00 a4 28 2f dsubu	a1,a1,a0
  823: 	b	invalidateCCtagsDoit
[ 823] 0x900000001fc0219c:  10 00 00 07 b		0x900000001fc021bc
  824: 	nop
[ 824] 0x900000001fc021a0:  00 00 00 00 nop
  825: invalidateCCtagsUncached:	
  826: 	dla	v0, 1f
[ 826] 0x900000001fc021a4:  3c 02 90 00 lui	v0,0x9000
[ 826] 0x900000001fc021a8:  64 42 00 00 daddiu	v0,v0,0
[ 826] 0x900000001fc021ac:  00 02 14 38 dsll	v0,v0,16
[ 826] 0x900000001fc021b0:  64 42 1f c0 daddiu	v0,v0,8128
[ 826] 0x900000001fc021b4:  00 02 14 38 dsll	v0,v0,16
[ 826] 0x900000001fc021b8:  64 42 22 00 daddiu	v0,v0,8704
  827: invalidateCCtagsDoit:
  828: 	
  829:         /* v0 - has cached address of routine on return */
  830:         
  831: 	li	a0,4*1024*1024/CACHE_SLINE_SIZE
[ 831] 0x900000001fc021bc:  34 04 80 00 ori	a0,zero,0x8000
  832: 	dli	a1,EV_BTRAM_BASE
[ 832] 0x900000001fc021c0:  3c 05 90 00 lui	a1,0x9000
[ 832] 0x900000001fc021c4:  00 05 2c 38 dsll	a1,a1,16
[ 832] 0x900000001fc021c8:  34 a5 18 1c ori	a1,a1,0x181c
[ 832] 0x900000001fc021cc:  00 05 2c 38 dsll	a1,a1,16
[ 832] 0x900000001fc021d0:  34 a5 00 00 ori	a1,a1,0
  833:         jal	v0
[ 833] 0x900000001fc021d4:  00 40 f8 09 jalr	ra,v0
  834:         nop
[ 834] 0x900000001fc021d8:  00 00 00 00 nop
  835: 
  836:         j	2f
[ 836] 0x900000001fc021dc:  0b f0 08 c0 j		(invalidateCCtags+772)
  837:         nop     				/* And continue on */
[ 837] 0x900000001fc021e0:  00 00 00 00 nop
[ 837] 0x900000001fc021e4:  00 00 00 00 nop
[ 837] 0x900000001fc021e8:  00 00 00 00 nop
[ 837] 0x900000001fc021ec:  00 00 00 00 nop
[ 837] 0x900000001fc021f0:  00 00 00 00 nop
[ 837] 0x900000001fc021f4:  00 00 00 00 nop
[ 837] 0x900000001fc021f8:  00 00 00 00 nop
[ 837] 0x900000001fc021fc:  00 00 00 00 nop
  838:         /* Pad out to start of secondary cache line */
  839:         .align	7
  840: 1:	
  841:         /*
  842:          * THIS CODE MAY BE EXECUTED OUT OF ICACHE.
  843:          */
  844:         nop
[ 844] 0x900000001fc02200:  00 00 00 00 nop
  845: 	sd	zero,0(a1)
[ 845] 0x900000001fc02204:  fc a0 00 00 sd	zero,0(a1)
  846: 	daddiu	a1,CTD_SIZE
[ 846] 0x900000001fc02208:  64 a5 00 08 daddiu	a1,a1,8
  847: 	sub	a0,1
[ 847] 0x900000001fc0220c:  20 84 ff ff addi	a0,a0,-1
  848: 	bgtz	a0,1b
[ 848] 0x900000001fc02210:  1c 80 ff fb bgtz	a0,0x900000001fc02200
  849: 	nop
[ 849] 0x900000001fc02214:  00 00 00 00 nop
  850: 	/*
  851: 	 * These instructions ensure that all store to the
  852: 	 * CC tags are complete before we do a read (instruction
  853: 	 * fetch). The GET_PROCREG makes sure of this, the SET_PROCREG
  854: 	 * is required to reset the cache size to its correct value.
  855: 	 */
  856: 	EV_GET_SPNUM(k0,k1)			/* our address */
[ 856] 0x900000001fc02218:  3c 1a 90 00 lui	k0,0x9000
[ 856] 0x900000001fc0221c:  00 1a d4 38 dsll	k0,k0,16
[ 856] 0x900000001fc02220:  37 5a 18 00 ori	k0,k0,0x1800
[ 856] 0x900000001fc02224:  00 1a d4 38 dsll	k0,k0,16
[ 856] 0x900000001fc02228:  37 5a 00 08 ori	k0,k0,0x8
[ 856] 0x900000001fc0222c:  df 5a 00 00 ld	k0,0(k0)
[ 856] 0x900000001fc02230:  00 00 00 00 nop
[ 856] 0x900000001fc02234:  33 5a 00 3f andi	k0,k0,0x3f
[ 856] 0x900000001fc02238:  33 5b 00 03 andi	k1,k0,0x3
[ 856] 0x900000001fc0223c:  03 60 d8 21 addu	k1,k1,0
[ 856] 0x900000001fc02240:  00 1a d0 82 srl	k0,k0,2
  857: 	EV_SET_PROCREG(k0, k1, EV_CFG_CACHE_SZ, a4)
[ 857] 0x900000001fc02244:  00 1b d9 80 sll	k1,k1,6
[ 857] 0x900000001fc02248:  63 7b 00 3e daddi	k1,k1,62
[ 857] 0x900000001fc0224c:  00 1a d2 c0 sll	k0,k0,11
[ 857] 0x900000001fc02250:  3c 01 90 00 lui	at,0x9000
[ 857] 0x900000001fc02254:  00 01 0c 38 dsll	at,at,16
[ 857] 0x900000001fc02258:  34 21 18 00 ori	at,at,0x1800
[ 857] 0x900000001fc0225c:  00 01 0c 38 dsll	at,at,16
[ 857] 0x900000001fc02260:  34 21 80 00 ori	at,at,0x8000
[ 857] 0x900000001fc02264:  03 41 d0 2c dadd	k0,k0,at
[ 857] 0x900000001fc02268:  00 1b d8 2c dadd	k1,zero,k1
[ 857] 0x900000001fc0226c:  00 1b d8 c0 sll	k1,k1,3
[ 857] 0x900000001fc02270:  03 5b d0 2c dadd	k0,k0,k1
[ 857] 0x900000001fc02274:  00 08 d8 25 or	k1,zero,a4
[ 857] 0x900000001fc02278:  ff 5b 00 00 sd	k1,0(k0)
[ 857] 0x900000001fc0227c:  00 00 00 00 nop
  858: 	EV_GET_SPNUM(k0,k1)			/* our address */
[ 858] 0x900000001fc02280:  3c 1a 90 00 lui	k0,0x9000
[ 858] 0x900000001fc02284:  00 1a d4 38 dsll	k0,k0,16
[ 858] 0x900000001fc02288:  37 5a 18 00 ori	k0,k0,0x1800
[ 858] 0x900000001fc0228c:  00 1a d4 38 dsll	k0,k0,16
[ 858] 0x900000001fc02290:  37 5a 00 08 ori	k0,k0,0x8
[ 858] 0x900000001fc02294:  df 5a 00 00 ld	k0,0(k0)
[ 858] 0x900000001fc02298:  00 00 00 00 nop
[ 858] 0x900000001fc0229c:  33 5a 00 3f andi	k0,k0,0x3f
[ 858] 0x900000001fc022a0:  33 5b 00 03 andi	k1,k0,0x3
[ 858] 0x900000001fc022a4:  03 60 d8 21 addu	k1,k1,0
[ 858] 0x900000001fc022a8:  00 1a d0 82 srl	k0,k0,2
  859: 	EV_GET_PROCREG(k0, k1, EV_CFG_CACHE_SZ, a4)
[ 859] 0x900000001fc022ac:  00 1b d9 80 sll	k1,k1,6
[ 859] 0x900000001fc022b0:  63 7b 00 3e daddi	k1,k1,62
[ 859] 0x900000001fc022b4:  00 1a d2 c0 sll	k0,k0,11
[ 859] 0x900000001fc022b8:  3c 01 90 00 lui	at,0x9000
[ 859] 0x900000001fc022bc:  00 01 0c 38 dsll	at,at,16
[ 859] 0x900000001fc022c0:  34 21 18 00 ori	at,at,0x1800
[ 859] 0x900000001fc022c4:  00 01 0c 38 dsll	at,at,16
[ 859] 0x900000001fc022c8:  34 21 80 00 ori	at,at,0x8000
[ 859] 0x900000001fc022cc:  03 41 d0 2c dadd	k0,k0,at
[ 859] 0x900000001fc022d0:  00 1b 40 2c dadd	a4,zero,k1
[ 859] 0x900000001fc022d4:  00 08 40 c0 sll	a4,a4,3
[ 859] 0x900000001fc022d8:  03 48 d0 2c dadd	k0,k0,a4
[ 859] 0x900000001fc022dc:  df 48 00 00 ld	a4,0(k0)
[ 859] 0x900000001fc022e0:  00 00 00 00 nop
  860:         /*
  861: 	 * Now serialize and be sure the 4 decoded instructions do not cause
  862: 	 * a cache prefetch.
  863: 	 */
  864:         DMFC0(zero, C0_SR)
[ 864] 0x900000001fc022e4:  40 20 60 00 dmfc0	zero,sr
  865:         j	ra
[ 865] 0x900000001fc022e8:  03 e0 00 08 jr	ra
  866:         nop
[ 866] 0x900000001fc022ec:  00 00 00 00 nop
  867:         nop
  868:         nop
[ 868] 0x900000001fc022f0:  00 00 00 00 nop
[ 868] 0x900000001fc022f4:  00 00 00 00 nop
[ 868] 0x900000001fc022f8:  00 00 00 00 nop
[ 868] 0x900000001fc022fc:  00 00 00 00 nop
  869:         /* Pad out to end of secondary cache line */
  870:         .align	7
  871: 2:
  872:         move	ra,s7
[ 872] 0x900000001fc02300:  02 e0 f8 25 move	ra,s7
  873: #endif
  874:         j	ra
[ 874] 0x900000001fc02304:  03 e0 00 08 jr	ra
  875:         nop
[ 875] 0x900000001fc02308:  00 00 00 00 nop
  876:         END(invalidateCCtags)
  877: 
  878: /*
  879:  * Function:	invalidateScache
  880:  * Purpose:	To invalidate the secondary cache, both duplicate and
  881:  *		T5 tags.
  882:  * Parameters:	none
  883:  * Returns:	nothing
  884:  * Notes:	uses v0,t0
  885:  */
  886: LEAF(invalidateScache)
  887: 	.set	noreorder
  888: 
  889:         LEDS(PLED_INVSCACHE)
invalidateScache:
[ 889] 0x900000001fc0230c:  00 00 00 00 nop
[ 889] 0x900000001fc02310:  34 04 00 0b ori	a0,zero,0xb
[ 889] 0x900000001fc02314:  3c 02 90 00 lui	v0,0x9000
[ 889] 0x900000001fc02318:  00 02 14 38 dsll	v0,v0,16
[ 889] 0x900000001fc0231c:  34 42 19 00 ori	v0,v0,0x1900
[ 889] 0x900000001fc02320:  00 02 14 38 dsll	v0,v0,16
[ 889] 0x900000001fc02324:  34 42 40 00 ori	v0,v0,0x4000
[ 889] 0x900000001fc02328:  fc 44 00 00 sd	a0,0(v0)
  890: #if !defined(SABLE)
  891: 	move	t0,ra				/* Save return address */
[ 891] 0x900000001fc0232c:  03 e0 60 25 move	t0,ra
  892: 
  893: 	jal	sCacheSize			/* go get cache size */
[ 893] 0x900000001fc02330:  0f f0 05 80 jal		sCacheSize
  894: 	nop					/* DELAY */
[ 894] 0x900000001fc02334:  00 00 00 00 nop
  895: 	move	ra,t0				/* Back to normal */
[ 895] 0x900000001fc02338:  01 80 f8 25 move	ra,t0
  896: 	ddivu	t0,v0,CACHE_SLINE_SIZE*2	/* # lines / way */
[ 896] 0x900000001fc0233c:  00 02 62 3a dsrl	t0,v0,8
  897: 	/*
  898: 	 * Set T5 cache tag in TAGLO/TAGHI registers.
  899: 	 */
  900: 	MTC0(zero, C0_TAGLO)
[ 900] 0x900000001fc02340:  40 80 e0 00 mtc0	zero,taglo
  901: 	MTC0(zero, C0_TAGHI)
[ 901] 0x900000001fc02344:  40 80 e8 00 mtc0	zero,taghi
  902: 	MTC0(zero, C0_ECC)
[ 902] 0x900000001fc02348:  40 80 d0 00 mtc0	zero,ecc
  903: 	/*
  904: 	 * For each cache line, store an invalid tag with valid ECC,
  905: 	 */
  906: 	dli	v0,K0_BASE
[ 906] 0x900000001fc0234c:  24 02 00 15 li	v0,21
[ 906] 0x900000001fc02350:  00 02 16 fc dsll32	v0,v0,27
  907: 1:
  908: 	SCACHE(C_IST, 0(v0))			/* T5:	way 0 */
[ 908] 0x900000001fc02354:  bc 4b 00 00 cache	Index_Store_Tag[SD],0(v0)
  909: 	SCACHE(C_IST, 1(v0))			/* T5:	way 1 */
[ 909] 0x900000001fc02358:  bc 4b 00 01 cache	Index_Store_Tag[SD],1(v0)
  910: 	SCACHE(C_ISD, 0x0(v0))
[ 910] 0x900000001fc0235c:  bc 5f 00 00 cache	Hit_Set_Virtual[SD],0(v0)
  911: 	SCACHE(C_ISD, 0x1(v0))
[ 911] 0x900000001fc02360:  bc 5f 00 01 cache	Hit_Set_Virtual[SD],1(v0)
  912: 	SCACHE(C_ISD, 0x10(v0))
[ 912] 0x900000001fc02364:  bc 5f 00 10 cache	Hit_Set_Virtual[SD],16(v0)
  913: 	SCACHE(C_ISD, 0x11(v0))
[ 913] 0x900000001fc02368:  bc 5f 00 11 cache	Hit_Set_Virtual[SD],17(v0)
  914: 	SCACHE(C_ISD, 0x20(v0))
[ 914] 0x900000001fc0236c:  bc 5f 00 20 cache	Hit_Set_Virtual[SD],32(v0)
  915: 	SCACHE(C_ISD, 0x21(v0))
[ 915] 0x900000001fc02370:  bc 5f 00 21 cache	Hit_Set_Virtual[SD],33(v0)
  916: 	SCACHE(C_ISD, 0x30(v0))
[ 916] 0x900000001fc02374:  bc 5f 00 30 cache	Hit_Set_Virtual[SD],48(v0)
  917: 	SCACHE(C_ISD, 0x31(v0))
[ 917] 0x900000001fc02378:  bc 5f 00 31 cache	Hit_Set_Virtual[SD],49(v0)
  918: 	SCACHE(C_ISD, 0x40(v0))
[ 918] 0x900000001fc0237c:  bc 5f 00 40 cache	Hit_Set_Virtual[SD],64(v0)
  919: 	SCACHE(C_ISD, 0x41(v0))
[ 919] 0x900000001fc02380:  bc 5f 00 41 cache	Hit_Set_Virtual[SD],65(v0)
  920: 	SCACHE(C_ISD, 0x50(v0))
[ 920] 0x900000001fc02384:  bc 5f 00 50 cache	Hit_Set_Virtual[SD],80(v0)
  921: 	SCACHE(C_ISD, 0x51(v0))
[ 921] 0x900000001fc02388:  bc 5f 00 51 cache	Hit_Set_Virtual[SD],81(v0)
  922: 	SCACHE(C_ISD, 0x60(v0))
[ 922] 0x900000001fc0238c:  bc 5f 00 60 cache	Hit_Set_Virtual[SD],96(v0)
  923: 	SCACHE(C_ISD, 0x61(v0))
[ 923] 0x900000001fc02390:  bc 5f 00 61 cache	Hit_Set_Virtual[SD],97(v0)
  924: 	SCACHE(C_ISD, 0x70(v0))
[ 924] 0x900000001fc02394:  bc 5f 00 70 cache	Hit_Set_Virtual[SD],112(v0)
  925: 	SCACHE(C_ISD, 0x71(v0))
[ 925] 0x900000001fc02398:  bc 5f 00 71 cache	Hit_Set_Virtual[SD],113(v0)
  926: 
  927: 	daddiu	v0,CACHE_SLINE_SIZE
[ 927] 0x900000001fc0239c:  64 42 00 80 daddiu	v0,v0,128
  928: 	sub	t0,1
[ 928] 0x900000001fc023a0:  21 8c ff ff addi	t0,t0,-1
  929: 	bgez	t0,1b
[ 929] 0x900000001fc023a4:  05 81 ff eb bgez	t0,0x900000001fc02354
  930: 	nop
[ 930] 0x900000001fc023a8:  00 00 00 00 nop
  931: #endif
  932: 
  933: 	j	ra
[ 933] 0x900000001fc023ac:  03 e0 00 08 jr	ra
  934: 	nop
[ 934] 0x900000001fc023b0:  00 00 00 00 nop
  935: 	END(invalidateScache)
  936: 
  937: /*
  938:  * Function:	testScache
  939:  * Purpose:	To test the secondary cache, without writting back to
  940:  *		main memory. This does NOT touch CC duplicate tags.
  941:  * Parameters:	none
  942:  * Returns: v0 - 0 OK, !0 failed
  943:  */
  944: LEAF(testScache)
  945: 	LEDS(PLED_TESTSCACHE)
testScache:
[ 945] 0x900000001fc023b4:  00 00 00 00 nop
[ 945] 0x900000001fc023b8:  34 04 00 05 ori	a0,zero,0x5
[ 945] 0x900000001fc023bc:  3c 02 90 00 lui	v0,0x9000
[ 945] 0x900000001fc023c0:  00 02 14 38 dsll	v0,v0,16
[ 945] 0x900000001fc023c4:  34 42 19 00 ori	v0,v0,0x1900
[ 945] 0x900000001fc023c8:  00 02 14 38 dsll	v0,v0,16
[ 945] 0x900000001fc023cc:  34 42 40 00 ori	v0,v0,0x4000
[ 945] 0x900000001fc023d0:  fc 44 00 00 sd	a0,0(v0)
  946: 	.set	noreorder
  947: 
  948: 	/* Figure out # of lines */
  949: 
  950: 	move	t0,ra				/* save return address */
[ 950] 0x900000001fc023d4:  03 e0 60 25 move	t0,ra
  951: 	jal	sCacheSize			/* pick up scache size */
[ 951] 0x900000001fc023d8:  0f f0 05 80 jal		sCacheSize
  952: 	nop					/* DELAY */
[ 952] 0x900000001fc023dc:  00 00 00 00 nop
  953: 	move	ra,t0				/* Put back in nice place */
[ 953] 0x900000001fc023e0:  01 80 f8 25 move	ra,t0
  954: 	divu	gp,v0,CACHE_SLINE_SIZE*2	/* 2-way remember */
[ 954] 0x900000001fc023e4:  00 02 e2 02 srl	gp,v0,8
  955: 
  956: 	dla	v0,scache_patternStart
[ 956] 0x900000001fc023e8:  3c 02 90 00 lui	v0,0x9000
[ 956] 0x900000001fc023ec:  64 42 00 00 daddiu	v0,v0,0
[ 956] 0x900000001fc023f0:  00 02 14 38 dsll	v0,v0,16
[ 956] 0x900000001fc023f4:  64 42 1f c1 daddiu	v0,v0,8129
[ 956] 0x900000001fc023f8:  00 02 14 38 dsll	v0,v0,16
[ 956] 0x900000001fc023fc:  64 42 73 00 daddiu	v0,v0,29440
  957: 1:
  958: 	/*
  959: 	 * Check if done at top of loop. This means that we can have
  960: 	 * no test patterns if desired.
  961: 	 */
  962: 
  963: 
  964: 	dla	v1,scache_patternEnd
[ 964] 0x900000001fc02400:  3c 03 90 00 lui	v1,0x9000
[ 964] 0x900000001fc02404:  64 63 00 00 daddiu	v1,v1,0
[ 964] 0x900000001fc02408:  00 03 1c 38 dsll	v1,v1,16
[ 964] 0x900000001fc0240c:  64 63 1f c1 daddiu	v1,v1,8129
[ 964] 0x900000001fc02410:  00 03 1c 38 dsll	v1,v1,16
[ 964] 0x900000001fc02414:  64 63 73 48 daddiu	v1,v1,29512
  965: 	bge	v0,v1,testScacheData
[ 965] 0x900000001fc02418:  00 43 08 2a slt	at,v0,v1
[ 965] 0x900000001fc0241c:  10 20 00 26 beq	at,zero,0x900000001fc024b8
  966: 	nop
[ 966] 0x900000001fc02420:  00 00 00 00 nop
  967: 	
  968: 	/*
  969: 	 * First test all of the cache tags.
  970: 	 */
  971: 	dli	v1,K0_BASE
[ 971] 0x900000001fc02424:  24 03 00 15 li	v1,21
[ 971] 0x900000001fc02428:  00 03 1e fc dsll32	v1,v1,27
  972: 	move	a3,gp				/* Count # pairs of lines */
[ 972] 0x900000001fc0242c:  03 80 38 25 move	a3,gp
  973: 	lw	t1,CP_TAG_LO(v0)
[ 973] 0x900000001fc02430:  8c 4d 00 04 lw	t1,4(v0)
  974: 	lw	t2,CP_TAG_HI(v0)
[ 974] 0x900000001fc02434:  8c 4e 00 00 lw	t2,0(v0)
  975: 	MTC0(t1, C0_TAGLO)
[ 975] 0x900000001fc02438:  40 8d e0 00 mtc0	t1,taglo
  976: 	MTC0(t2, C0_TAGHI)			/* top 32 bits */
[ 976] 0x900000001fc0243c:  40 8e e8 00 mtc0	t2,taghi
  977: 2:
  978: 	SCACHE(C_IST, 0(v1))			/* Store tag - way 0 */
[ 978] 0x900000001fc02440:  bc 6b 00 00 cache	Index_Store_Tag[SD],0(v1)
  979: 	SCACHE(C_IST, 1(v1))			/*           - way 1 */
[ 979] 0x900000001fc02444:  bc 6b 00 01 cache	Index_Store_Tag[SD],1(v1)
  980: 	subu	a3,1
[ 980] 0x900000001fc02448:  24 e7 ff ff addiu	a3,a3,-1
  981: 	daddiu	v1,CACHE_SLINE_SIZE		/* Next line(s) please */
[ 981] 0x900000001fc0244c:  64 63 00 80 daddiu	v1,v1,128
  982: 	bgtz	a3,2b
[ 982] 0x900000001fc02450:  1c e0 ff fb bgtz	a3,0x900000001fc02440
  983: 	nop
[ 983] 0x900000001fc02454:  00 00 00 00 nop
  984: 
  985: 	/*
  986: 	 * Read back all tags, note that the "correct" value of the 64-bit
  987: 	 * tag is in t1.
  988: 	 */
  989: 	dli	v1,K0_BASE
[ 989] 0x900000001fc02458:  24 03 00 15 li	v1,21
[ 989] 0x900000001fc0245c:  00 03 1e fc dsll32	v1,v1,27
  990: 	move	a3,gp				/* Count # pairs of lines */
[ 990] 0x900000001fc02460:  03 80 38 25 move	a3,gp
  991: 2:
  992: 
  993: 	SCACHE(C_ILT, 0(v1))			/* WAY 0 */
[ 993] 0x900000001fc02464:  bc 67 00 00 cache	Index_Load_Tag[SD],0(v1)
  994: 	MFC0(a1, C0_TAGLO)
[ 994] 0x900000001fc02468:  40 05 e0 00 mfc0	a1,taglo
  995: 	MFC0(a2, C0_TAGHI)
[ 995] 0x900000001fc0246c:  40 06 e8 00 mfc0	a2,taghi
  996: 	bne	t1,a1,testScacheFailedTagWay0
[ 996] 0x900000001fc02470:  15 a5 00 b2 bne	t1,a1,0x900000001fc0273c
  997: 	nop
[ 997] 0x900000001fc02474:  00 00 00 00 nop
  998: 	bne	t2,a2,testScacheFailedTagWay0
[ 998] 0x900000001fc02478:  15 c6 00 b0 bne	t2,a2,0x900000001fc0273c
  999: 	nop
[ 999] 0x900000001fc0247c:  00 00 00 00 nop
 1000: 	
 1001: 	SCACHE(C_ILT, 1(v1))			/* WAY 1 */
[1001] 0x900000001fc02480:  bc 67 00 01 cache	Index_Load_Tag[SD],1(v1)
 1002: 	MFC0(a1, C0_TAGLO)
[1002] 0x900000001fc02484:  40 05 e0 00 mfc0	a1,taglo
 1003: 	MFC0(a2, C0_TAGHI)
[1003] 0x900000001fc02488:  40 06 e8 00 mfc0	a2,taghi
 1004: 	bne	t1,a1,testScacheFailedTagWay1
[1004] 0x900000001fc0248c:  15 a5 00 b3 bne	t1,a1,0x900000001fc0275c
 1005: 	nop
[1005] 0x900000001fc02490:  00 00 00 00 nop
 1006: 	bne	t2,a2,testScacheFailedTagWay1
[1006] 0x900000001fc02494:  15 c6 00 b1 bne	t2,a2,0x900000001fc0275c
 1007: 	nop
[1007] 0x900000001fc02498:  00 00 00 00 nop
 1008: 
 1009: 	subu	a3, 1
[1009] 0x900000001fc0249c:  24 e7 ff ff addiu	a3,a3,-1
 1010: 	daddiu	v1,CACHE_SLINE_SIZE
[1010] 0x900000001fc024a0:  64 63 00 80 daddiu	v1,v1,128
 1011: 	bgtz	a3,2b
[1011] 0x900000001fc024a4:  1c e0 ff ef bgtz	a3,0x900000001fc02464
 1012: 	nop
[1012] 0x900000001fc024a8:  00 00 00 00 nop
 1013: 	daddiu	v0,CP_SIZE			/* DELAY */
[1013] 0x900000001fc024ac:  64 42 00 18 daddiu	v0,v0,24
 1014: 	b	1b				/* Back to top of loop */
[1014] 0x900000001fc024b0:  10 00 ff d3 b		0x900000001fc02400
 1015: 	nop
[1015] 0x900000001fc024b4:  00 00 00 00 nop
 1016: 	
 1017: testScacheData:		
 1018: 	/*
 1019: 	 * The INDEX STORE_DATA for the secondary cache only stores
 1020: 	 * 2 of the 4 words in each quad word. Thus, for each quad
 1021: 	 * word, we must first test the first 2 words, then the second
 1022: 	 * 2. We double check the ECC at both phases - just for fun.
 1023: 	 * v1 is really a boolean value that indicates if we are on the
 1024: 	 * upper 8 bytes or lower eight bytes.
 1025: 	 */
 1026: 	dla	v0,scache_patternStart
[1026] 0x900000001fc024b8:  3c 02 90 00 lui	v0,0x9000
[1026] 0x900000001fc024bc:  64 42 00 00 daddiu	v0,v0,0
[1026] 0x900000001fc024c0:  00 02 14 38 dsll	v0,v0,16
[1026] 0x900000001fc024c4:  64 42 1f c1 daddiu	v0,v0,8129
[1026] 0x900000001fc024c8:  00 02 14 38 dsll	v0,v0,16
[1026] 0x900000001fc024cc:  64 42 73 00 daddiu	v0,v0,29440
 1027: 1:	
 1028: 	dla	v1,scache_patternEnd
[1028] 0x900000001fc024d0:  3c 03 90 00 lui	v1,0x9000
[1028] 0x900000001fc024d4:  64 63 00 00 daddiu	v1,v1,0
[1028] 0x900000001fc024d8:  00 03 1c 38 dsll	v1,v1,16
[1028] 0x900000001fc024dc:  64 63 1f c1 daddiu	v1,v1,8129
[1028] 0x900000001fc024e0:  00 03 1c 38 dsll	v1,v1,16
[1028] 0x900000001fc024e4:  64 63 73 48 daddiu	v1,v1,29512
 1029: 	bge	v0,v1,testScacheSuccess
[1029] 0x900000001fc024e8:  00 43 08 2a slt	at,v0,v1
[1029] 0x900000001fc024ec:  10 20 00 35 beq	at,zero,0x900000001fc025c4
 1030: 	nop
[1030] 0x900000001fc024f0:  00 00 00 00 nop
 1031: 	dli	v1,8				/* # bytes left in quad */
[1031] 0x900000001fc024f4:  24 03 00 08 li	v1,8
 1032: 2:	
 1033: 	dli	t3,K0_BASE
[1033] 0x900000001fc024f8:  24 0f 00 15 li	t3,21
[1033] 0x900000001fc024fc:  00 0f 7e fc dsll32	t3,t3,27
 1034: 	daddu	t3,v1				/* Which quad word */
[1034] 0x900000001fc02500:  01 e3 78 2d daddu	t3,t3,v1
 1035: 
 1036: 3:	
 1037: 	lw	a3,CP_ECC(v0)			/* ECC bits */
[1037] 0x900000001fc02504:  8c 47 00 08 lw	a3,8(v0)
 1038: 	DMTC0(a3, C0_ECC)
[1038] 0x900000001fc02508:  40 a7 d0 00 dmtc0	a3,ecc
 1039: 	lw	a1, CP_DATA_LO(v0)
[1039] 0x900000001fc0250c:  8c 45 00 14 lw	a1,20(v0)
 1040: 	lw	a2, CP_DATA_HI(v0)
[1040] 0x900000001fc02510:  8c 46 00 10 lw	a2,16(v0)
 1041: 	MTC0(a1,C0_TAGLO)
[1041] 0x900000001fc02514:  40 85 e0 00 mtc0	a1,taglo
 1042: 	MTC0(a2,C0_TAGHI)
[1042] 0x900000001fc02518:  40 86 e8 00 mtc0	a2,taghi
 1043: 	/* 
 1044: 	 * Compute # of stores to execute. Each secondary cache line
 1045: 	 * is made up of some number of quadwords. For the first pass,
 1046: 	 * write the first 8-bytes of the quadwords for the entire
 1047: 	 * cache, and in the second pass write the last 8-bytes of
 1048: 	 * each quadword. # Quadwords is (#lines x #quads per line)
 1049: 	 */
 1050: 	li	a0,CACHE_SLINE_SIZE/CACHE_SLINE_SUBSIZE
[1050] 0x900000001fc0251c:  24 04 00 08 li	a0,8
 1051: 	multu	a0,gp				/* total sublines per way */
[1051] 0x900000001fc02520:  00 9c 00 19 multu	a0,gp
 1052:         mflo	a0
[1052] 0x900000001fc02524:  00 00 20 12 mflo	a0
 1053: 4:	
 1054: 	SCACHE(C_ISD, 0(t3))			/* Way 0 */
[1054] 0x900000001fc02528:  bd ff 00 00 cache	Hit_Set_Virtual[SD],0(t3)
 1055: 	SCACHE(C_ISD, 1(t3))			/* Way 1 */
[1055] 0x900000001fc0252c:  bd ff 00 01 cache	Hit_Set_Virtual[SD],1(t3)
 1056: 	subu	a0, 1
[1056] 0x900000001fc02530:  24 84 ff ff addiu	a0,a0,-1
 1057: 	daddiu	t3,CACHE_SLINE_SUBSIZE		/* Next subline */
[1057] 0x900000001fc02534:  65 ef 00 10 daddiu	t3,t3,16
 1058: 	bgtz	a0,4b
[1058] 0x900000001fc02538:  1c 80 ff fb bgtz	a0,0x900000001fc02528
 1059: 	nop	
[1059] 0x900000001fc0253c:  00 00 00 00 nop
 1060: 	/*
 1061: 	 * Now read back and verify the results with what we wrote. At
 1062: 	 * this point the expected values are:
 1063: 	 * ECC - a3, taghi - a2, taglo - a1
 1064: 	 */
 1065: 	dli	t3,K0_BASE
[1065] 0x900000001fc02540:  24 0f 00 15 li	t3,21
[1065] 0x900000001fc02544:  00 0f 7e fc dsll32	t3,t3,27
 1066: 	daddu	t3,v1
[1066] 0x900000001fc02548:  01 e3 78 2d daddu	t3,t3,v1
 1067: 	li	a0,CACHE_SLINE_SIZE/CACHE_SLINE_SUBSIZE
[1067] 0x900000001fc0254c:  24 04 00 08 li	a0,8
 1068: 	multu	a0,gp				/* Total sublines */
[1068] 0x900000001fc02550:  00 9c 00 19 multu	a0,gp
 1069:         mflo	a0
[1069] 0x900000001fc02554:  00 00 20 12 mflo	a0
 1070: 4:		
 1071: 	SCACHE(C_ILD, 0(t3))			/* Way 0 */
[1071] 0x900000001fc02558:  bd fb 00 00 cache	Hit_WriteBack[SD],0(t3)
 1072: 	MFC0(t0, C0_ECC)
[1072] 0x900000001fc0255c:  40 0c d0 00 mfc0	t0,ecc
 1073: 	MFC0(t1, C0_TAGHI)	
[1073] 0x900000001fc02560:  40 0d e8 00 mfc0	t1,taghi
 1074: 	MFC0(t2, C0_TAGLO)
[1074] 0x900000001fc02564:  40 0e e0 00 mfc0	t2,taglo
 1075: 	bne	t0,a3,testScacheFailedWay0
[1075] 0x900000001fc02568:  15 87 00 18 bne	t0,a3,0x900000001fc025cc
 1076: 	nop
[1076] 0x900000001fc0256c:  00 00 00 00 nop
 1077: 	bne	t1,a2,testScacheFailedWay0
[1077] 0x900000001fc02570:  15 a6 00 16 bne	t1,a2,0x900000001fc025cc
 1078: 	nop
[1078] 0x900000001fc02574:  00 00 00 00 nop
 1079: 	bne	t2,a1,testScacheFailedWay0
[1079] 0x900000001fc02578:  15 c5 00 14 bne	t2,a1,0x900000001fc025cc
 1080: 	nop
[1080] 0x900000001fc0257c:  00 00 00 00 nop
 1081: 	SCACHE(C_ILD, 1(t3))			/* Way 1 */
[1081] 0x900000001fc02580:  bd fb 00 01 cache	Hit_WriteBack[SD],1(t3)
 1082: 	MFC0(t0, C0_ECC)
[1082] 0x900000001fc02584:  40 0c d0 00 mfc0	t0,ecc
 1083: 	MFC0(t1, C0_TAGHI)
[1083] 0x900000001fc02588:  40 0d e8 00 mfc0	t1,taghi
 1084: 	MFC0(t2, C0_TAGLO)	
[1084] 0x900000001fc0258c:  40 0e e0 00 mfc0	t2,taglo
 1085: 	bne	t0,a3,testScacheFailedWay1
[1085] 0x900000001fc02590:  15 87 00 16 bne	t0,a3,0x900000001fc025ec
 1086: 	nop
[1086] 0x900000001fc02594:  00 00 00 00 nop
 1087: 	bne	t1,a2,testScacheFailedWay1
[1087] 0x900000001fc02598:  15 a6 00 14 bne	t1,a2,0x900000001fc025ec
 1088: 	nop
[1088] 0x900000001fc0259c:  00 00 00 00 nop
 1089: 	bne	t2,a1,testScacheFailedWay1
[1089] 0x900000001fc025a0:  15 c5 00 12 bne	t2,a1,0x900000001fc025ec
 1090: 	nop
[1090] 0x900000001fc025a4:  00 00 00 00 nop
 1091: 	
 1092: 	subu	a0,1				/* Next offset into sublines*/
[1092] 0x900000001fc025a8:  24 84 ff ff addiu	a0,a0,-1
 1093: 	bgtz	a0,4b
[1093] 0x900000001fc025ac:  1c 80 ff ea bgtz	a0,0x900000001fc02558
 1094: 	daddiu	t3,CACHE_SLINE_SUBSIZE
[1094] 0x900000001fc025b0:  65 ef 00 10 daddiu	t3,t3,16
 1095: 
 1096: 	bnez	v1,2b
[1096] 0x900000001fc025b4:  14 60 ff d0 bne	v1,zero,0x900000001fc024f8
 1097: 	move	v1,zero				/* DELAY */
[1097] 0x900000001fc025b8:  00 00 18 25 move	v1,zero
 1098: 
 1099: 	/*
 1100: 	 * End of outer loop.
 1101: 	 */
 1102: 	b	1b
[1102] 0x900000001fc025bc:  10 00 ff c4 b		0x900000001fc024d0
 1103: 	daddiu	v0,CP_SIZE			/* Next pattern */
[1103] 0x900000001fc025c0:  64 42 00 18 daddiu	v0,v0,24
 1104: 
 1105: testScacheSuccess:
 1106: 	j	ra
[1106] 0x900000001fc025c4:  03 e0 00 08 jr	ra
 1107: 	move	v0,zero
[1107] 0x900000001fc025c8:  00 00 10 25 move	v0,zero
 1108: 	
 1109: testScacheFailedWay0:
 1110: 	MESSAGE(a0, "\r\n  2ndry data compare error: Way 0:")
[1110] 0x900000001fc025cc:  3c 04 90 00 lui	a0,0x9000
[1110] 0x900000001fc025d0:  64 84 00 00 daddiu	a0,a0,0
[1110] 0x900000001fc025d4:  00 04 24 38 dsll	a0,a0,16
[1110] 0x900000001fc025d8:  64 84 1f c1 daddiu	a0,a0,8129
[1110] 0x900000001fc025dc:  00 04 24 38 dsll	a0,a0,16
[1110] 0x900000001fc025e0:  64 84 76 2d daddiu	a0,a0,30253
 1111: 	b	testScacheFailed
[1111] 0x900000001fc025e4:  10 00 00 07 b		0x900000001fc02604
 1112: 	nop
[1112] 0x900000001fc025e8:  00 00 00 00 nop
 1113: testScacheFailedWay1:
 1114: 	MESSAGE(a0, "\r\n  2ndry data compare error: Way 1:")
[1114] 0x900000001fc025ec:  3c 04 90 00 lui	a0,0x9000
[1114] 0x900000001fc025f0:  64 84 00 00 daddiu	a0,a0,0
[1114] 0x900000001fc025f4:  00 04 24 38 dsll	a0,a0,16
[1114] 0x900000001fc025f8:  64 84 1f c1 daddiu	a0,a0,8129
[1114] 0x900000001fc025fc:  00 04 24 38 dsll	a0,a0,16
[1114] 0x900000001fc02600:  64 84 76 52 daddiu	a0,a0,30290
 1115: testScacheFailed:
 1116: 	/*
 1117: 	 * For debug proms, attempt to dump information to
 1118: 	 * CC serial port. At this point:
 1119: 	 *	t3 - address
 1120: 	 *	t0 - read ECC value
 1121: 	 *	t1/t2 - read taghi/taglo values (8 bytes)
 1122: 	 *	a3 - expected ECC value
 1123: 	 *	a1/a2 - expected taghi/taglo values (8 bytes)
 1124: 	 */
 1125: 
 1126: 	dsll	t1,32
[1126] 0x900000001fc02604:  00 0d 68 3c dsll32	t1,t1,0
 1127: 	dsll	t2,32
[1127] 0x900000001fc02608:  00 0e 70 3c dsll32	t2,t2,0
 1128: 	dsrl	t2,32
[1128] 0x900000001fc0260c:  00 0e 70 3e dsrl32	t2,t2,0
 1129: 	or	t1,t2
[1129] 0x900000001fc02610:  01 ae 68 25 or	t1,t1,t2
 1130: 
 1131: 	dsll	a1,32
[1131] 0x900000001fc02614:  00 05 28 3c dsll32	a1,a1,0
 1132: 	dsll	a2,32
[1132] 0x900000001fc02618:  00 06 30 3c dsll32	a2,a2,0
 1133: 	dsrl	a2,32
[1133] 0x900000001fc0261c:  00 06 30 3e dsrl32	a2,a2,0
 1134: 	or	k1,a2,a1
[1134] 0x900000001fc02620:  00 c5 d8 25 or	k1,a2,a1
 1135: 	move	k0,a3
[1135] 0x900000001fc02624:  00 e0 d0 25 move	k0,a3
 1136: 
 1137:         move	t2,ra
[1137] 0x900000001fc02628:  03 e0 70 25 move	t2,ra
 1138: 
 1139: 	PMESSAGE_PTR(a0); PMESSAGE(" address: "); PHEX(t3); 
[1139] 0x900000001fc0262c:  00 84 20 25 or	a0,a0,a0
[1139] 0x900000001fc02630:  0f f0 15 03 jal		pod_puts
[1139] 0x900000001fc02634:  00 00 00 00 nop
[1139] 0x900000001fc02638:  3c 04 90 00 lui	a0,0x9000
[1139] 0x900000001fc0263c:  64 84 00 00 daddiu	a0,a0,0
[1139] 0x900000001fc02640:  00 04 24 38 dsll	a0,a0,16
[1139] 0x900000001fc02644:  64 84 1f c1 daddiu	a0,a0,8129
[1139] 0x900000001fc02648:  00 04 24 38 dsll	a0,a0,16
[1139] 0x900000001fc0264c:  64 84 76 77 daddiu	a0,a0,30327
[1139] 0x900000001fc02650:  0f f0 15 03 jal		pod_puts
[1139] 0x900000001fc02654:  00 00 00 00 nop
[1139] 0x900000001fc02658:  00 0f 20 25 or	a0,zero,t3
[1139] 0x900000001fc0265c:  0f f0 14 f8 jal		pod_puthex64
[1139] 0x900000001fc02660:  00 00 00 00 nop
 1140:         PMESSAGE("\n\r\twrote(data/ecc): 0x"); PHEX(k1); 
[1140] 0x900000001fc02664:  3c 04 90 00 lui	a0,0x9000
[1140] 0x900000001fc02668:  64 84 00 00 daddiu	a0,a0,0
[1140] 0x900000001fc0266c:  00 04 24 38 dsll	a0,a0,16
[1140] 0x900000001fc02670:  64 84 1f c1 daddiu	a0,a0,8129
[1140] 0x900000001fc02674:  00 04 24 38 dsll	a0,a0,16
[1140] 0x900000001fc02678:  64 84 76 82 daddiu	a0,a0,30338
[1140] 0x900000001fc0267c:  0f f0 15 03 jal		pod_puts
[1140] 0x900000001fc02680:  00 00 00 00 nop
[1140] 0x900000001fc02684:  00 1b 20 25 or	a0,zero,k1
[1140] 0x900000001fc02688:  0f f0 14 f8 jal		pod_puthex64
[1140] 0x900000001fc0268c:  00 00 00 00 nop
 1141:         PMESSAGE("/"); PHEX32(k0); 
[1141] 0x900000001fc02690:  3c 04 90 00 lui	a0,0x9000
[1141] 0x900000001fc02694:  64 84 00 00 daddiu	a0,a0,0
[1141] 0x900000001fc02698:  00 04 24 38 dsll	a0,a0,16
[1141] 0x900000001fc0269c:  64 84 1f c1 daddiu	a0,a0,8129
[1141] 0x900000001fc026a0:  00 04 24 38 dsll	a0,a0,16
[1141] 0x900000001fc026a4:  64 84 76 99 daddiu	a0,a0,30361
[1141] 0x900000001fc026a8:  0f f0 15 03 jal		pod_puts
[1141] 0x900000001fc026ac:  00 00 00 00 nop
[1141] 0x900000001fc026b0:  00 1a 20 25 or	a0,zero,k0
[1141] 0x900000001fc026b4:  0f f0 14 ed jal		pod_puthex32
[1141] 0x900000001fc026b8:  00 00 00 00 nop
 1142:         PMESSAGE("\n\r\tread (data/ecc): 0x"); PHEX(t1);
[1142] 0x900000001fc026bc:  3c 04 90 00 lui	a0,0x9000
[1142] 0x900000001fc026c0:  64 84 00 00 daddiu	a0,a0,0
[1142] 0x900000001fc026c4:  00 04 24 38 dsll	a0,a0,16
[1142] 0x900000001fc026c8:  64 84 1f c1 daddiu	a0,a0,8129
[1142] 0x900000001fc026cc:  00 04 24 38 dsll	a0,a0,16
[1142] 0x900000001fc026d0:  64 84 76 9b daddiu	a0,a0,30363
[1142] 0x900000001fc026d4:  0f f0 15 03 jal		pod_puts
[1142] 0x900000001fc026d8:  00 00 00 00 nop
[1142] 0x900000001fc026dc:  00 0d 20 25 or	a0,zero,t1
[1142] 0x900000001fc026e0:  0f f0 14 f8 jal		pod_puthex64
[1142] 0x900000001fc026e4:  00 00 00 00 nop
 1143:         PMESSAGE("/"); PHEX32(t0); 
[1143] 0x900000001fc026e8:  3c 04 90 00 lui	a0,0x9000
[1143] 0x900000001fc026ec:  64 84 00 00 daddiu	a0,a0,0
[1143] 0x900000001fc026f0:  00 04 24 38 dsll	a0,a0,16
[1143] 0x900000001fc026f4:  64 84 1f c1 daddiu	a0,a0,8129
[1143] 0x900000001fc026f8:  00 04 24 38 dsll	a0,a0,16
[1143] 0x900000001fc026fc:  64 84 76 b2 daddiu	a0,a0,30386
[1143] 0x900000001fc02700:  0f f0 15 03 jal		pod_puts
[1143] 0x900000001fc02704:  00 00 00 00 nop
[1143] 0x900000001fc02708:  00 0c 20 25 or	a0,zero,t0
[1143] 0x900000001fc0270c:  0f f0 14 ed jal		pod_puthex32
[1143] 0x900000001fc02710:  00 00 00 00 nop
 1144:        
 1145: 	PMESSAGE("\n\r")
[1145] 0x900000001fc02714:  3c 04 90 00 lui	a0,0x9000
[1145] 0x900000001fc02718:  64 84 00 00 daddiu	a0,a0,0
[1145] 0x900000001fc0271c:  00 04 24 38 dsll	a0,a0,16
[1145] 0x900000001fc02720:  64 84 1f c1 daddiu	a0,a0,8129
[1145] 0x900000001fc02724:  00 04 24 38 dsll	a0,a0,16
[1145] 0x900000001fc02728:  64 84 76 b4 daddiu	a0,a0,30388
[1145] 0x900000001fc0272c:  0f f0 15 03 jal		pod_puts
[1145] 0x900000001fc02730:  00 00 00 00 nop
 1146: 	
 1147: 	j	t2
[1147] 0x900000001fc02734:  01 c0 00 08 jr	t2
 1148: 	ori	v0,zero,EVDIAG_SCACHE_DATA	/* DELAY */
[1148] 0x900000001fc02738:  34 02 00 03 ori	v0,zero,0x3
 1149: 
 1150: testScacheFailedTagWay0:
 1151: 	MESSAGE(a0, "\r\n  2ndry Tag compare error: way 0:")
[1151] 0x900000001fc0273c:  3c 04 90 00 lui	a0,0x9000
[1151] 0x900000001fc02740:  64 84 00 00 daddiu	a0,a0,0
[1151] 0x900000001fc02744:  00 04 24 38 dsll	a0,a0,16
[1151] 0x900000001fc02748:  64 84 1f c1 daddiu	a0,a0,8129
[1151] 0x900000001fc0274c:  00 04 24 38 dsll	a0,a0,16
[1151] 0x900000001fc02750:  64 84 76 b7 daddiu	a0,a0,30391
 1152: 	b	testScacheFailedTag
[1152] 0x900000001fc02754:  10 00 00 07 b		0x900000001fc02774
 1153: 	nop
[1153] 0x900000001fc02758:  00 00 00 00 nop
 1154: testScacheFailedTagWay1:
 1155: 	MESSAGE(a0, "\r\n  2ndry Tag compare error: way 1:")
[1155] 0x900000001fc0275c:  3c 04 90 00 lui	a0,0x9000
[1155] 0x900000001fc02760:  64 84 00 00 daddiu	a0,a0,0
[1155] 0x900000001fc02764:  00 04 24 38 dsll	a0,a0,16
[1155] 0x900000001fc02768:  64 84 1f c1 daddiu	a0,a0,8129
[1155] 0x900000001fc0276c:  00 04 24 38 dsll	a0,a0,16
[1155] 0x900000001fc02770:  64 84 76 db daddiu	a0,a0,30427
 1156: testScacheFailedTag:	
 1157: 	/*
 1158: 	 * For debug proms, attempt to dump information to
 1159: 	 * CC serial port. At this point,
 1160: 	 *	v1 - address
 1161: 	 *	a1/a2 - pattern read back
 1162: 	 *	t1/t2 - pattern written
 1163: 	 */
 1164: 	dsll	a2,32				/* Top 32 bits */
[1164] 0x900000001fc02774:  00 06 30 3c dsll32	a2,a2,0
 1165: 	dsll	a1,32
[1165] 0x900000001fc02778:  00 05 28 3c dsll32	a1,a1,0
 1166: 	dsrl	a1,32				/* isolate lower 32 bits */
[1166] 0x900000001fc0277c:  00 05 28 3e dsrl32	a1,a1,0
 1167: 	or	k0,a2,a1			/* a2 - read 64-bit value */
[1167] 0x900000001fc02780:  00 c5 d0 25 or	k0,a2,a1
 1168: 	
 1169: 	dsll	t2,32				/* Top 32 bits */
[1169] 0x900000001fc02784:  00 0e 70 3c dsll32	t2,t2,0
 1170: 	dsll	t1,32
[1170] 0x900000001fc02788:  00 0d 68 3c dsll32	t1,t1,0
 1171: 	dsrl	t1,32				/* isolate lower 32 bits */
[1171] 0x900000001fc0278c:  00 0d 68 3e dsrl32	t1,t1,0
 1172: 	or	t1,t2				/* t1 - expected value */
[1172] 0x900000001fc02790:  01 ae 68 25 or	t1,t1,t2
 1173: 
 1174: 	move	t2,ra				/* Save way home */
[1174] 0x900000001fc02794:  03 e0 70 25 move	t2,ra
 1175: 	move	k1,v1
[1175] 0x900000001fc02798:  00 60 d8 25 move	k1,v1
 1176: 
 1177: 	PMESSAGE_PTR(a0); PMESSAGE(" address: "); PHEX(k1); 
[1177] 0x900000001fc0279c:  00 84 20 25 or	a0,a0,a0
[1177] 0x900000001fc027a0:  0f f0 15 03 jal		pod_puts
[1177] 0x900000001fc027a4:  00 00 00 00 nop
[1177] 0x900000001fc027a8:  3c 04 90 00 lui	a0,0x9000
[1177] 0x900000001fc027ac:  64 84 00 00 daddiu	a0,a0,0
[1177] 0x900000001fc027b0:  00 04 24 38 dsll	a0,a0,16
[1177] 0x900000001fc027b4:  64 84 1f c1 daddiu	a0,a0,8129
[1177] 0x900000001fc027b8:  00 04 24 38 dsll	a0,a0,16
[1177] 0x900000001fc027bc:  64 84 76 ff daddiu	a0,a0,30463
[1177] 0x900000001fc027c0:  0f f0 15 03 jal		pod_puts
[1177] 0x900000001fc027c4:  00 00 00 00 nop
[1177] 0x900000001fc027c8:  00 1b 20 25 or	a0,zero,k1
[1177] 0x900000001fc027cc:  0f f0 14 f8 jal		pod_puthex64
[1177] 0x900000001fc027d0:  00 00 00 00 nop
 1178:         PMESSAGE("\r\n\twrote: 0x"); PHEX(t1);
[1178] 0x900000001fc027d4:  3c 04 90 00 lui	a0,0x9000
[1178] 0x900000001fc027d8:  64 84 00 00 daddiu	a0,a0,0
[1178] 0x900000001fc027dc:  00 04 24 38 dsll	a0,a0,16
[1178] 0x900000001fc027e0:  64 84 1f c1 daddiu	a0,a0,8129
[1178] 0x900000001fc027e4:  00 04 24 38 dsll	a0,a0,16
[1178] 0x900000001fc027e8:  64 84 77 0a daddiu	a0,a0,30474
[1178] 0x900000001fc027ec:  0f f0 15 03 jal		pod_puts
[1178] 0x900000001fc027f0:  00 00 00 00 nop
[1178] 0x900000001fc027f4:  00 0d 20 25 or	a0,zero,t1
[1178] 0x900000001fc027f8:  0f f0 14 f8 jal		pod_puthex64
[1178] 0x900000001fc027fc:  00 00 00 00 nop
 1179:         PMESSAGE("\r\n\tread:  0x"); PHEX(k0);
[1179] 0x900000001fc02800:  3c 04 90 00 lui	a0,0x9000
[1179] 0x900000001fc02804:  64 84 00 00 daddiu	a0,a0,0
[1179] 0x900000001fc02808:  00 04 24 38 dsll	a0,a0,16
[1179] 0x900000001fc0280c:  64 84 1f c1 daddiu	a0,a0,8129
[1179] 0x900000001fc02810:  00 04 24 38 dsll	a0,a0,16
[1179] 0x900000001fc02814:  64 84 77 17 daddiu	a0,a0,30487
[1179] 0x900000001fc02818:  0f f0 15 03 jal		pod_puts
[1179] 0x900000001fc0281c:  00 00 00 00 nop
[1179] 0x900000001fc02820:  00 1a 20 25 or	a0,zero,k0
[1179] 0x900000001fc02824:  0f f0 14 f8 jal		pod_puthex64
[1179] 0x900000001fc02828:  00 00 00 00 nop
 1180: 	PMESSAGE("\n\r")
[1180] 0x900000001fc0282c:  3c 04 90 00 lui	a0,0x9000
[1180] 0x900000001fc02830:  64 84 00 00 daddiu	a0,a0,0
[1180] 0x900000001fc02834:  00 04 24 38 dsll	a0,a0,16
[1180] 0x900000001fc02838:  64 84 1f c1 daddiu	a0,a0,8129
[1180] 0x900000001fc0283c:  00 04 24 38 dsll	a0,a0,16
[1180] 0x900000001fc02840:  64 84 77 24 daddiu	a0,a0,30500
[1180] 0x900000001fc02844:  0f f0 15 03 jal		pod_puts
[1180] 0x900000001fc02848:  00 00 00 00 nop
 1181: 
 1182: 	j	t2
[1182] 0x900000001fc0284c:  01 c0 00 08 jr	t2
 1183: 	ori	v0,zero,EVDIAG_SCACHE_TAG	/* DELAY */
[1183] 0x900000001fc02850:  34 02 00 0c ori	v0,zero,0xc
[1183] 0x900000001fc02854:  00 00 00 00 nop
[1183] 0x900000001fc02858:  00 00 00 00 nop
[1183] 0x900000001fc0285c:  00 00 00 00 nop
[1183] 0x900000001fc02860:  00 00 00 00 nop
[1183] 0x900000001fc02864:  00 00 00 00 nop
[1183] 0x900000001fc02868:  00 00 00 00 nop
[1183] 0x900000001fc0286c:  00 00 00 00 nop
[1183] 0x900000001fc02870:  00 00 00 00 nop
[1183] 0x900000001fc02874:  00 00 00 00 nop
[1183] 0x900000001fc02878:  00 00 00 00 nop
[1183] 0x900000001fc0287c:  00 00 00 00 nop
 1184: 	
 1185: 	.set	reorder
 1186: 	END(testScache)
 1187: 
 1188: /*
 1189:  * Function:	testCCtags
 1190:  * Purpose:	verify the duplicate cache tags in the SCC
 1191:  * Parameters:	none
 1192:  * Returns:	0 - OK
 1193:  *		1 - failed
 1194:  * Notes:	The SCC duplicate tages are addressed as follows:
 1195:  *			line	way	address (EV_BTRAM_BASE +)
 1196:  *			0	0	0
 1197:  *			0	1	8
 1198:  *			1	0	16
 1199:  *			1	1	24
 1200:  *			...
 1201:  * Thus, we look at the SCC tags as 1 way for this test, and having
 1202:  * a size of 8 (CTD_SIZE).
 1203:  *
 1204:  */
 1205:         .align	7		/* Align on scache boundary */
 1206: LEAF(testCCtags)
 1207: 	.set	noreorder
 1208: #if !defined(SABLE)
 1209: 	/*
 1210: 	 * Compute SCC cache tag mask ---- use the SR because it has the
 1211: 	 * log2 value as it stands.
 1212: 	 */
 1213: 
 1214: 	MFC0(v0,C0_CONFIG)
testCCtags:
[1214] 0x900000001fc02880:  40 02 80 00 mfc0	v0,config
 1215: 	and	v0,CONFIG_SS
[1215] 0x900000001fc02884:  3c 01 00 07 lui	at,0x7
[1215] 0x900000001fc02888:  00 41 10 24 and	v0,v0,at
 1216: 	srl	v0,CONFIG_SS_SHFT
[1216] 0x900000001fc0288c:  00 02 14 02 srl	v0,v0,16
 1217: 
 1218: 	/*
 1219: 	 * SCC needs to know the size of the secondary cache at
 1220: 	 * this point to correctly mask bits and generate
 1221: 	 * Parity.
 1222: 	 */	
 1223: 
 1224: 	dli	t2,0x00ffffff
[1224] 0x900000001fc02890:  3c 0e 00 ff lui	t2,0xff
[1224] 0x900000001fc02894:  35 ce ff ff ori	t2,t2,0xffff
 1225: 	srl	t2,v0
[1225] 0x900000001fc02898:  00 4e 70 06 srlv	t2,t2,v0
 1226: 	sll	t2,v0				/* Mask for tags */
[1226] 0x900000001fc0289c:  00 4e 70 04 sllv	t2,t2,v0
 1227: 	
 1228: 	li	v1,5
[1228] 0x900000001fc028a0:  24 03 00 05 li	v1,5
 1229: 	sub	v0,v1,v0			/* SCC value:CACHE_SZ */
[1229] 0x900000001fc028a4:  00 62 10 22 sub	v0,v1,v0
 1230: 	EV_GET_SPNUM(k0,k1)			/* our address */
[1230] 0x900000001fc028a8:  3c 1a 90 00 lui	k0,0x9000
[1230] 0x900000001fc028ac:  00 1a d4 38 dsll	k0,k0,16
[1230] 0x900000001fc028b0:  37 5a 18 00 ori	k0,k0,0x1800
[1230] 0x900000001fc028b4:  00 1a d4 38 dsll	k0,k0,16
[1230] 0x900000001fc028b8:  37 5a 00 08 ori	k0,k0,0x8
[1230] 0x900000001fc028bc:  df 5a 00 00 ld	k0,0(k0)
[1230] 0x900000001fc028c0:  00 00 00 00 nop
[1230] 0x900000001fc028c4:  33 5a 00 3f andi	k0,k0,0x3f
[1230] 0x900000001fc028c8:  33 5b 00 03 andi	k1,k0,0x3
[1230] 0x900000001fc028cc:  03 60 d8 21 addu	k1,k1,0
[1230] 0x900000001fc028d0:  00 1a d0 82 srl	k0,k0,2
 1231: 	EV_SET_PROCREG(k0, k1, EV_CFG_CACHE_SZ, v0)
[1231] 0x900000001fc028d4:  00 1b d9 80 sll	k1,k1,6
[1231] 0x900000001fc028d8:  63 7b 00 3e daddi	k1,k1,62
[1231] 0x900000001fc028dc:  00 1a d2 c0 sll	k0,k0,11
[1231] 0x900000001fc028e0:  3c 01 90 00 lui	at,0x9000
[1231] 0x900000001fc028e4:  00 01 0c 38 dsll	at,at,16
[1231] 0x900000001fc028e8:  34 21 18 00 ori	at,at,0x1800
[1231] 0x900000001fc028ec:  00 01 0c 38 dsll	at,at,16
[1231] 0x900000001fc028f0:  34 21 80 00 ori	at,at,0x8000
[1231] 0x900000001fc028f4:  03 41 d0 2c dadd	k0,k0,at
[1231] 0x900000001fc028f8:  00 1b d8 2c dadd	k1,zero,k1
[1231] 0x900000001fc028fc:  00 1b d8 c0 sll	k1,k1,3
[1231] 0x900000001fc02900:  03 5b d0 2c dadd	k0,k0,k1
[1231] 0x900000001fc02904:  00 02 d8 25 or	k1,zero,v0
[1231] 0x900000001fc02908:  ff 5b 00 00 sd	k1,0(k0)
[1231] 0x900000001fc0290c:  00 00 00 00 nop
 1232: 
 1233: 	/*
 1234: 	 * We assume the maximum cache size for the purpose of
 1235: 	 * the testing. The total number of lines is used.
 1236: 	 */
 1237: 	li	v0,1024*1024*4/CACHE_SLINE_SIZE
[1237] 0x900000001fc02910:  34 02 80 00 ori	v0,zero,0x8000
 1238: 		
 1239: 	dla	t0,scctag_patternStart
[1239] 0x900000001fc02914:  3c 0c 90 00 lui	t0,0x9000
[1239] 0x900000001fc02918:  65 8c 00 00 daddiu	t0,t0,0
[1239] 0x900000001fc0291c:  00 0c 64 38 dsll	t0,t0,16
[1239] 0x900000001fc02920:  65 8c 1f c1 daddiu	t0,t0,8129
[1239] 0x900000001fc02924:  00 0c 64 38 dsll	t0,t0,16
[1239] 0x900000001fc02928:  65 8c 74 08 daddiu	t0,t0,29704
 1240: 1:
 1241: 	dla	t1,scctag_patternEnd
[1241] 0x900000001fc0292c:  3c 0d 90 00 lui	t1,0x9000
[1241] 0x900000001fc02930:  65 ad 00 00 daddiu	t1,t1,0
[1241] 0x900000001fc02934:  00 0d 6c 38 dsll	t1,t1,16
[1241] 0x900000001fc02938:  65 ad 1f c1 daddiu	t1,t1,8129
[1241] 0x900000001fc0293c:  00 0d 6c 38 dsll	t1,t1,16
[1241] 0x900000001fc02940:  65 ad 74 28 daddiu	t1,t1,29736
 1242: 	bge	t0,t1,testCCtagsSuccess		/* Done */
[1242] 0x900000001fc02944:  01 8d 08 2a slt	at,t0,t1
[1242] 0x900000001fc02948:  10 20 00 40 beq	at,zero,0x900000001fc02a4c
 1243: 	nop
[1243] 0x900000001fc0294c:  00 00 00 00 nop
 1244: 
 1245: 	/*
 1246: 	 * Fill tag rams with pattern.
 1247: 	 */	
 1248: 	move	a2,v0				/* # lines */
[1248] 0x900000001fc02950:  00 40 30 25 move	a2,v0
 1249: 	ld	v1,0(t0)			/* Current pattern */
[1249] 0x900000001fc02954:  dd 83 00 00 ld	v1,0(t0)
 1250: 	and	v1,t2
[1250] 0x900000001fc02958:  00 6e 18 24 and	v1,v1,t2
 1251: 	dli	a0,EV_BTRAM_BASE
[1251] 0x900000001fc0295c:  3c 04 90 00 lui	a0,0x9000
[1251] 0x900000001fc02960:  00 04 24 38 dsll	a0,a0,16
[1251] 0x900000001fc02964:  34 84 18 1c ori	a0,a0,0x181c
[1251] 0x900000001fc02968:  00 04 24 38 dsll	a0,a0,16
[1251] 0x900000001fc0296c:  34 84 00 00 ori	a0,a0,0
 1252: 2:
 1253: 	sd	v1,0(a0)
[1253] 0x900000001fc02970:  fc 83 00 00 sd	v1,0(a0)
 1254: 	daddiu	a0,CTD_SIZE
[1254] 0x900000001fc02974:  64 84 00 08 daddiu	a0,a0,8
 1255: 	sub	a2,1
[1255] 0x900000001fc02978:  20 c6 ff ff addi	a2,a2,-1
 1256: 	bgtz	a2,2b
[1256] 0x900000001fc0297c:  1c c0 ff fc bgtz	a2,0x900000001fc02970
 1257: 	nop
[1257] 0x900000001fc02980:  00 00 00 00 nop
 1258: 	
 1259: 	/*
 1260: 	 * Due to an SCC problem, we can not read the CC tags to soon after
 1261: 	 * a write from the CPU. For that reason, we serialize, and cause a
 1262: 	 * stall - by loading the cache_size config register.
 1263: 	 */
 1264: 	EV_GET_SPNUM(k0,k1)			/* Cause a stall */
[1264] 0x900000001fc02984:  3c 1a 90 00 lui	k0,0x9000
[1264] 0x900000001fc02988:  00 1a d4 38 dsll	k0,k0,16
[1264] 0x900000001fc0298c:  37 5a 18 00 ori	k0,k0,0x1800
[1264] 0x900000001fc02990:  00 1a d4 38 dsll	k0,k0,16
[1264] 0x900000001fc02994:  37 5a 00 08 ori	k0,k0,0x8
[1264] 0x900000001fc02998:  df 5a 00 00 ld	k0,0(k0)
[1264] 0x900000001fc0299c:  00 00 00 00 nop
[1264] 0x900000001fc029a0:  33 5a 00 3f andi	k0,k0,0x3f
[1264] 0x900000001fc029a4:  33 5b 00 03 andi	k1,k0,0x3
[1264] 0x900000001fc029a8:  03 60 d8 21 addu	k1,k1,0
[1264] 0x900000001fc029ac:  00 1a d0 82 srl	k0,k0,2
 1265: 	EV_GET_PROCREG(k0, k1, EV_CFG_CACHE_SZ, zero)
[1265] 0x900000001fc029b0:  00 1b d9 80 sll	k1,k1,6
[1265] 0x900000001fc029b4:  63 7b 00 3e daddi	k1,k1,62
[1265] 0x900000001fc029b8:  00 1a d2 c0 sll	k0,k0,11
[1265] 0x900000001fc029bc:  3c 01 90 00 lui	at,0x9000
[1265] 0x900000001fc029c0:  00 01 0c 38 dsll	at,at,16
[1265] 0x900000001fc029c4:  34 21 18 00 ori	at,at,0x1800
[1265] 0x900000001fc029c8:  00 01 0c 38 dsll	at,at,16
[1265] 0x900000001fc029cc:  34 21 80 00 ori	at,at,0x8000
[1265] 0x900000001fc029d0:  03 41 d0 2c dadd	k0,k0,at
[1265] 0x900000001fc029d4:  00 1b 00 2c dadd	zero,zero,k1
[1265] 0x900000001fc029d8:  00 00 00 c0 sll	zero,zero,3
[1265] 0x900000001fc029dc:  03 40 d0 2c dadd	k0,k0,zero
[1265] 0x900000001fc029e0:  df 40 00 00 ld	zero,0(k0)
[1265] 0x900000001fc029e4:  00 00 00 00 nop
 1266: 	MFC0(zero, C0_SR)			/* serialize */
[1266] 0x900000001fc029e8:  40 00 60 00 mfc0	zero,sr
 1267: 	
 1268: 	/*
 1269: 	 * Check patterns in tag rams.
 1270: 	 */
 1271: 	dli	a0,EV_BTRAM_BASE
[1271] 0x900000001fc029ec:  3c 04 90 00 lui	a0,0x9000
[1271] 0x900000001fc029f0:  00 04 24 38 dsll	a0,a0,16
[1271] 0x900000001fc029f4:  34 84 18 1c ori	a0,a0,0x181c
[1271] 0x900000001fc029f8:  00 04 24 38 dsll	a0,a0,16
[1271] 0x900000001fc029fc:  34 84 00 00 ori	a0,a0,0
 1272: 	move	a2,v0				/* Count */
[1272] 0x900000001fc02a00:  00 40 30 25 move	a2,v0
 1273: 2:
 1274:  	ld	t1,0(a0)
[1274] 0x900000001fc02a04:  dc 8d 00 00 ld	t1,0(a0)
 1275: 	beq	v1,t1,3f
[1275] 0x900000001fc02a08:  10 6d 00 0a beq	v1,t1,0x900000001fc02a34
 1276: 	DMFC0(zero, C0_SR)			/* Serialize */
[1276] 0x900000001fc02a0c:  40 20 60 00 dmfc0	zero,sr
 1277: 	DMFC0(zero, C0_SR)			/* Serialize */
[1277] 0x900000001fc02a10:  40 20 60 00 dmfc0	zero,sr
 1278: 	dla	t3,testCCtagsFail
[1278] 0x900000001fc02a14:  3c 0f 90 00 lui	t3,0x9000
[1278] 0x900000001fc02a18:  65 ef 00 00 daddiu	t3,t3,0
[1278] 0x900000001fc02a1c:  00 0f 7c 38 dsll	t3,t3,16
[1278] 0x900000001fc02a20:  65 ef 1f c0 daddiu	t3,t3,8128
[1278] 0x900000001fc02a24:  00 0f 7c 38 dsll	t3,t3,16
[1278] 0x900000001fc02a28:  65 ef 2a 80 daddiu	t3,t3,10880
 1279: 	jr	t3
[1279] 0x900000001fc02a2c:  01 e0 00 08 jr	t3
 1280: 	nop
[1280] 0x900000001fc02a30:  00 00 00 00 nop
 1281: 3:	
 1282: 	daddiu	a0,CTD_SIZE			/* DELAY: */
[1282] 0x900000001fc02a34:  64 84 00 08 daddiu	a0,a0,8
 1283: 	sub	a2,1				/* DELAY: */
[1283] 0x900000001fc02a38:  20 c6 ff ff addi	a2,a2,-1
 1284: 	bgtz	a2,2b
[1284] 0x900000001fc02a3c:  1c c0 ff f1 bgtz	a2,0x900000001fc02a04
 1285: 	nop
[1285] 0x900000001fc02a40:  00 00 00 00 nop
 1286: 	b	1b				/* Check for more */
[1286] 0x900000001fc02a44:  10 00 ff b9 b		0x900000001fc0292c
 1287: 	daddiu	t0,SCC_SIZE
[1287] 0x900000001fc02a48:  65 8c 00 08 daddiu	t0,t0,8
 1288: 	
 1289: #endif /* !defined(SABLE) */
 1290: 	
 1291: testCCtagsSuccess:
 1292:         /*
 1293: 	 * Up to 4 instructions after the serialization instruction
 1294: 	 * may be speculated since they are already decoded etc. Thus, 
 1295: 	 * we put nops is just ro be sure we know what is going on.
 1296: 	 */
 1297:         DMFC0(zero, C0_SR)			/* Serialize */
[1297] 0x900000001fc02a4c:  40 20 60 00 dmfc0	zero,sr
 1298:         nop
 1299:         nop
[1299] 0x900000001fc02a50:  00 00 00 00 nop
[1299] 0x900000001fc02a54:  00 00 00 00 nop
 1300: 	j	ra
[1300] 0x900000001fc02a58:  03 e0 00 08 jr	ra
 1301: 	move	v0,zero
[1301] 0x900000001fc02a5c:  00 00 10 25 move	v0,zero
[1301] 0x900000001fc02a60:  00 00 00 00 nop
[1301] 0x900000001fc02a64:  00 00 00 00 nop
[1301] 0x900000001fc02a68:  00 00 00 00 nop
[1301] 0x900000001fc02a6c:  00 00 00 00 nop
[1301] 0x900000001fc02a70:  00 00 00 00 nop
[1301] 0x900000001fc02a74:  00 00 00 00 nop
[1301] 0x900000001fc02a78:  00 00 00 00 nop
[1301] 0x900000001fc02a7c:  00 00 00 00 nop
 1302: 	
 1303:         .align	7		/* Pad out Align on scache boundary */
 1304: 
 1305: testCCtagsFail:
 1306: 	.set	noreorder
 1307: 	/*
 1308: 	 * Attempt to dump the address/wrote/read value to the CC uart. 
 1309: 	 * At this point, registers are as follows:
 1310: 	 *	a0 - address
 1311: 	 *	v1 - pattern written
 1312: 	 *	t1 - pattern read
 1313: 	 */
 1314: 
 1315: 	move	t3, ra				/* save way home */
[1315] 0x900000001fc02a80:  03 e0 78 25 move	t3,ra
 1316: 	move	t2,a0				/* address */
[1316] 0x900000001fc02a84:  00 80 70 25 move	t2,a0
 1317: 
 1318: 	move	t0,v1				/* Pattern written */
[1318] 0x900000001fc02a88:  00 60 60 25 move	t0,v1
 1319: 	PMESSAGE("\r\n  CC Tag Compare Error: Address: ")
[1319] 0x900000001fc02a8c:  3c 04 90 00 lui	a0,0x9000
[1319] 0x900000001fc02a90:  64 84 00 00 daddiu	a0,a0,0
[1319] 0x900000001fc02a94:  00 04 24 38 dsll	a0,a0,16
[1319] 0x900000001fc02a98:  64 84 1f c1 daddiu	a0,a0,8129
[1319] 0x900000001fc02a9c:  00 04 24 38 dsll	a0,a0,16
[1319] 0x900000001fc02aa0:  64 84 77 27 daddiu	a0,a0,30503
[1319] 0x900000001fc02aa4:  0f f0 15 03 jal		pod_puts
[1319] 0x900000001fc02aa8:  00 00 00 00 nop
 1320: 	PHEX(t2)
[1320] 0x900000001fc02aac:  00 0e 20 25 or	a0,zero,t2
[1320] 0x900000001fc02ab0:  0f f0 14 f8 jal		pod_puthex64
[1320] 0x900000001fc02ab4:  00 00 00 00 nop
 1321: 	PMESSAGE("\n\r\tWrote: ")
[1321] 0x900000001fc02ab8:  3c 04 90 00 lui	a0,0x9000
[1321] 0x900000001fc02abc:  64 84 00 00 daddiu	a0,a0,0
[1321] 0x900000001fc02ac0:  00 04 24 38 dsll	a0,a0,16
[1321] 0x900000001fc02ac4:  64 84 1f c1 daddiu	a0,a0,8129
[1321] 0x900000001fc02ac8:  00 04 24 38 dsll	a0,a0,16
[1321] 0x900000001fc02acc:  64 84 77 4b daddiu	a0,a0,30539
[1321] 0x900000001fc02ad0:  0f f0 15 03 jal		pod_puts
[1321] 0x900000001fc02ad4:  00 00 00 00 nop
 1322: 	PHEX32(t0)
[1322] 0x900000001fc02ad8:  00 0c 20 25 or	a0,zero,t0
[1322] 0x900000001fc02adc:  0f f0 14 ed jal		pod_puthex32
[1322] 0x900000001fc02ae0:  00 00 00 00 nop
 1323: 	PMESSAGE( "\r\n\tRead: ")
[1323] 0x900000001fc02ae4:  3c 04 90 00 lui	a0,0x9000
[1323] 0x900000001fc02ae8:  64 84 00 00 daddiu	a0,a0,0
[1323] 0x900000001fc02aec:  00 04 24 38 dsll	a0,a0,16
[1323] 0x900000001fc02af0:  64 84 1f c1 daddiu	a0,a0,8129
[1323] 0x900000001fc02af4:  00 04 24 38 dsll	a0,a0,16
[1323] 0x900000001fc02af8:  64 84 77 56 daddiu	a0,a0,30550
[1323] 0x900000001fc02afc:  0f f0 15 03 jal		pod_puts
[1323] 0x900000001fc02b00:  00 00 00 00 nop
 1324: 	PHEX32(t1)
[1324] 0x900000001fc02b04:  00 0d 20 25 or	a0,zero,t1
[1324] 0x900000001fc02b08:  0f f0 14 ed jal		pod_puthex32
[1324] 0x900000001fc02b0c:  00 00 00 00 nop
 1325: 	PMESSAGE("\n\r")
[1325] 0x900000001fc02b10:  3c 04 90 00 lui	a0,0x9000
[1325] 0x900000001fc02b14:  64 84 00 00 daddiu	a0,a0,0
[1325] 0x900000001fc02b18:  00 04 24 38 dsll	a0,a0,16
[1325] 0x900000001fc02b1c:  64 84 1f c1 daddiu	a0,a0,8129
[1325] 0x900000001fc02b20:  00 04 24 38 dsll	a0,a0,16
[1325] 0x900000001fc02b24:  64 84 77 60 daddiu	a0,a0,30560
[1325] 0x900000001fc02b28:  0f f0 15 03 jal		pod_puts
[1325] 0x900000001fc02b2c:  00 00 00 00 nop
 1326: 	move	ra,t3				/* Restore way home */
[1326] 0x900000001fc02b30:  01 e0 f8 25 move	ra,t3
 1327: 
 1328: 	j	ra
[1328] 0x900000001fc02b34:  03 e0 00 08 jr	ra
 1329: 	ori	v0,zero,EVDIAG_BUSTAG_DATA
[1329] 0x900000001fc02b38:  34 02 00 0e ori	v0,zero,0xe
 1330: 	.globl	testCCtags_END
 1331: testCCtags_END:	
 1332: 	.set	reorder
 1333: 	END(testCCtags)
 1334: 
 1335: /*
 1336:  * Function:	parity
 1337:  * Purpose:	Compute parity of 64-bit value
 1338:  * Parameters:	a0 - 64-bit value to compute parity on
 1339:  * 		a1 - 0 for EVEN parity, 1 for ODD parity
 1340:  * Returns:	v0 - parity bit in LSB
 1341:  * Notes:	uses a0,a1,v0
 1342:  */
 1343: LEAF(parity)
 1344: 	.set	noreorder
 1345: 	dsrl	v0, a0, 32
testCCtags_END:
[1345] 0x900000001fc02b3c:  00 04 10 3e dsrl32	v0,a0,0
 1346: 	xor	a0, v0
[1346] 0x900000001fc02b40:  00 82 20 26 xor	a0,a0,v0
 1347: 	dsrl	v0, a0, 16
[1347] 0x900000001fc02b44:  00 04 14 3a dsrl	v0,a0,16
 1348: 	xor	a0, v0
[1348] 0x900000001fc02b48:  00 82 20 26 xor	a0,a0,v0
 1349: 	dsrl	v0, a0, 8
[1349] 0x900000001fc02b4c:  00 04 12 3a dsrl	v0,a0,8
 1350: 	xor	a0, v0
[1350] 0x900000001fc02b50:  00 82 20 26 xor	a0,a0,v0
 1351: 	dsrl	v0, a0, 4
[1351] 0x900000001fc02b54:  00 04 11 3a dsrl	v0,a0,4
 1352: 	xor	a0, v0
[1352] 0x900000001fc02b58:  00 82 20 26 xor	a0,a0,v0
 1353: 	dsrl	v0, a0, 2
[1353] 0x900000001fc02b5c:  00 04 10 ba dsrl	v0,a0,2
 1354: 	xor	a0, v0
[1354] 0x900000001fc02b60:  00 82 20 26 xor	a0,a0,v0
 1355: 	dsrl	v0, a0, 1
[1355] 0x900000001fc02b64:  00 04 10 7a dsrl	v0,a0,1
 1356: 	xor	a0, v0
[1356] 0x900000001fc02b68:  00 82 20 26 xor	a0,a0,v0
 1357: 	xor	v0, a0, a1
[1357] 0x900000001fc02b6c:  00 85 10 26 xor	v0,a0,a1
 1358: 	j	ra
[1358] 0x900000001fc02b70:  03 e0 00 08 jr	ra
 1359: 	 and	v0, 1
[1359] 0x900000001fc02b74:  30 42 00 01 andi	v0,v0,0x1
 1360: 	.set	reorder
 1361: 	END(parity)
 1362: 
 1363: /*
 1364:  * Function:	initDcacheStack
 1365:  * Purpose:	Set up the primary data cache to has valid (zero'd)
 1366:  *		exlusive dirty cache lines starting at
 1367:  *	 	POD_STACKADDR. Also set stack pointer.
 1368:  * Parameters:	none
 1369:  * Returns:	sp updated.
 1370:  * Notes:	The size of the stack is sizeof(dcache) / 2, ie, we don't
 1371:  * 		bother to initialize both ways.
 1372:  *
 1373:  * 	        Virtual address of stack = POD_STACKADDR
 1374:  *		Physical address of stack = POD_STACKPADDR
 1375:  */
 1376: LEAF(initDcacheStack)
 1377: 	.set	noreorder
 1378: 	move	a3,ra				/* Save RA */
initDcacheStack:
[1378] 0x900000001fc02b78:  03 e0 38 25 move	a3,ra
 1379: 	LEDS(PLED_MAKESTACK)
[1379] 0x900000001fc02b7c:  00 00 00 00 nop
[1379] 0x900000001fc02b80:  34 04 00 23 ori	a0,zero,0x23
[1379] 0x900000001fc02b84:  3c 02 90 00 lui	v0,0x9000
[1379] 0x900000001fc02b88:  00 02 14 38 dsll	v0,v0,16
[1379] 0x900000001fc02b8c:  34 42 19 00 ori	v0,v0,0x1900
[1379] 0x900000001fc02b90:  00 02 14 38 dsll	v0,v0,16
[1379] 0x900000001fc02b94:  34 42 40 00 ori	v0,v0,0x4000
[1379] 0x900000001fc02b98:  fc 44 00 00 sd	a0,0(v0)
 1380: 	dli	t2,POD_STACKSIZE/CACHE_DLINE_SIZE /* #lines */
[1380] 0x900000001fc02b9c:  24 0e 00 80 li	t2,128
 1381: 	dli	sp,POD_STACKVADDR		/* Start of stack */
[1381] 0x900000001fc02ba0:  3c 1d a8 00 lui	sp,0xa800
[1381] 0x900000001fc02ba4:  00 1d ec 38 dsll	sp,sp,16
[1381] 0x900000001fc02ba8:  37 bd 00 0f ori	sp,sp,0xf
[1381] 0x900000001fc02bac:  00 1d ec 38 dsll	sp,sp,16
[1381] 0x900000001fc02bb0:  37 bd e0 00 ori	sp,sp,0xe000
 1382: 	dli	a2,POD_STACKPADDR		/* Stack physical address */
[1382] 0x900000001fc02bb4:  3c 06 00 0f lui	a2,0xf
[1382] 0x900000001fc02bb8:  34 c6 e0 00 ori	a2,a2,0xe000
 1383: 	/*
 1384: 	 * Build tag for virtual address in sp, physical address in
 1385: 	 * a2. State, SC way, State Parity, LRU are constant. We use:
 1386: 	 *
 1387: 	 *	State Mod	= 1 <normal>
 1388: 	 *	State		= dirty, exclusive, inconsistent <CTP_STATE_DEI>
 1389: 	 *	State Parity	= EVEN_PARITY(state) = <constant>
 1390: 	 *	LRU 		= 0
 1391: 	 *	SC way		= 0
 1392: 	 *
 1393: 	 *	TAG[39:36]	= <variable>
 1394: 	 *	TAG[35:	12]	= <variable>
 1395: 	 *	Tag Parity	= <variable>
 1396: 	 */
 1397: 	dli	a0,CTP_STATE_DE
[1397] 0x900000001fc02bbc:  24 04 00 03 li	a0,3
 1398: 	jal	parity				/* Compute state parity */
[1398] 0x900000001fc02bc0:  0f f0 0a cf jal		testCCtags_END
 1399: 	move 	a1,zero				/* DELAY: Even please */
[1399] 0x900000001fc02bc4:  00 00 28 25 move	a1,zero
 1400: 
 1401: 	dsll	v0,CTP_STATEPARITY_SHFT
[1401] 0x900000001fc02bc8:  00 02 10 b8 dsll	v0,v0,2
 1402: 	dli	t1,(CTP_STATE_DE<<CTP_STATE_SHFT) + \
[1402] 0x900000001fc02bcc:  3c 0d 20 00 lui	t1,0x2000
[1402] 0x900000001fc02bd0:  00 0d 68 3c dsll32	t1,t1,0
[1402] 0x900000001fc02bd4:  35 ad 00 c0 ori	t1,t1,0xc0
 1403: 		   (CTP_STATEMOD_N<<CTP_STATEMOD_SHFT)
 1404: 	or	t1,v0				/* State with parity */
[1404] 0x900000001fc02bd8:  01 a2 68 25 or	t1,t1,v0
 1405: 	/*
 1406: 	 * t1 holds the constant parts of the tag, with parity. The actual
 1407: 	 * TAG address must now be computed and loaded.
 1408: 	 */
 1409: 1:
 1410: 	dsrl	t0,a2,4				/* NOTYET */
[1410] 0x900000001fc02bdc:  00 06 61 3a dsrl	t0,a2,4
 1411: 	and	t0,CTP_TAG_MASK			/* Physical address */
[1411] 0x900000001fc02be0:  24 01 ff ff li	at,-1
[1411] 0x900000001fc02be4:  00 01 09 3c dsll32	at,at,4
[1411] 0x900000001fc02be8:  00 01 0f 3a dsrl	at,at,28
[1411] 0x900000001fc02bec:  01 81 60 24 and	t0,t0,at
 1412: 						/*   in correct place */
 1413: 	move	a0,t0
[1413] 0x900000001fc02bf0:  01 80 20 25 move	a0,t0
 1414: 	jal	parity
[1414] 0x900000001fc02bf4:  0f f0 0a cf jal		testCCtags_END
 1415: 	move	a1,zero				/* DELAY: even parity */
[1415] 0x900000001fc02bf8:  00 00 28 25 move	a1,zero
 1416: 	dsll	v0,CTP_TAGPARITY_SHFT
[1416] 0x900000001fc02bfc:  00 40 10 2d move	v0,v0
 1417: 	or	t0,v0				/* Tag with tag parity */
[1417] 0x900000001fc02c00:  01 82 60 25 or	t0,t0,v0
 1418: 	or	t0,t1				/* Tag complete with parity */
[1418] 0x900000001fc02c04:  01 8d 60 25 or	t0,t0,t1
 1419: 
 1420: 	/* Now set the dcache entry for the specified line */
 1421: 
 1422: 	MTC0(t0,C0_TAGLO)			/* Low order 32 bits */
[1422] 0x900000001fc02c08:  40 8c e0 00 mtc0	t0,taglo
 1423: 	dsrl	t0,32
[1423] 0x900000001fc02c0c:  00 0c 60 3e dsrl32	t0,t0,0
 1424: 	MTC0(t0,C0_TAGHI)			/* High orger 32 bits */
[1424] 0x900000001fc02c10:  40 8c e8 00 mtc0	t0,taghi
 1425: 	DCACHE(C_IST, 0(sp))			/* Set tag! */
[1425] 0x900000001fc02c14:  bf a9 00 00 cache	Index_Store_Tag[D],0(sp)
 1426: 
 1427: 	/* 
 1428: 	 * Must be sure data in cache line does not have a parity
 1429:    	 * error.
 1430: 	 */
 1431: 
 1432: 	DMTC0(zero, C0_ECC)			/* Even parity, ECC=0  */
[1432] 0x900000001fc02c18:  40 a0 d0 00 dmtc0	zero,ecc
 1433: 	MTC0(zero, C0_TAGLO)			/* 0 data */
[1433] 0x900000001fc02c1c:  40 80 e0 00 mtc0	zero,taglo
 1434: 
 1435: 	li	a1,CACHE_DLINE_SIZE-4		/* # of stores */
[1435] 0x900000001fc02c20:  24 05 00 1c li	a1,28
 1436: 2:	
 1437: 	daddu	a0,a1,sp			/* Virtual address of word */
[1437] 0x900000001fc02c24:  00 bd 20 2d daddu	a0,a1,sp
 1438: 	DCACHE(C_ISD, 0(a0))			/* Store 0 */
[1438] 0x900000001fc02c28:  bc 9d 00 00 cache	Hit_Set_Virtual[D],0(a0)
 1439: 	daddi	a1,-4				/* DELAY: next word */
[1439] 0x900000001fc02c2c:  60 a5 ff fc daddi	a1,a1,-4
 1440: 	bgez	a1,2b
[1440] 0x900000001fc02c30:  04 a1 ff fc bgez	a1,0x900000001fc02c24
 1441: 	nop
[1441] 0x900000001fc02c34:  00 00 00 00 nop
 1442: 
 1443: 	daddiu	sp,CACHE_DLINE_SIZE		/* Bump virtual	address */
[1443] 0x900000001fc02c38:  67 bd 00 20 daddiu	sp,sp,32
 1444: 	daddiu	a2,CACHE_DLINE_SIZE		/* Bump physical address */
[1444] 0x900000001fc02c3c:  64 c6 00 20 daddiu	a2,a2,32
 1445: 	sub	t2,1
[1445] 0x900000001fc02c40:  21 ce ff ff addi	t2,t2,-1
 1446: 	bgtz	t2,1b				/* next or are we done ? */
[1446] 0x900000001fc02c44:  1d c0 ff e5 bgtz	t2,0x900000001fc02bdc
 1447: 	nop					
[1447] 0x900000001fc02c48:  00 00 00 00 nop
 1448: 
 1449: 	dli	sp,POD_STACKVADDR+POD_STACKSIZE-8
[1449] 0x900000001fc02c4c:  3c 1d a8 00 lui	sp,0xa800
[1449] 0x900000001fc02c50:  00 1d ec 38 dsll	sp,sp,16
[1449] 0x900000001fc02c54:  37 bd 00 0f ori	sp,sp,0xf
[1449] 0x900000001fc02c58:  00 1d ec 38 dsll	sp,sp,16
[1449] 0x900000001fc02c5c:  37 bd ef f8 ori	sp,sp,0xeff8
 1450: 	j	a3				/* Home James */
[1450] 0x900000001fc02c60:  00 e0 00 08 jr	a3
 1451: 	nop
[1451] 0x900000001fc02c64:  00 00 00 00 nop
 1452: 	.set	reorder
 1453: 	END(initDcacheStack)
 1454: /*
 1455:  * Function:	iLine
 1456:  * Purpose:	Fetch an instruction line from the icache.
 1457:  * Parameters:	a0 - vaddr (low order bit signals way)
 1458:  *		a1 - ptr to il_t buffer
 1459:  * Returns:	a1-> filled in.
 1460:  */
 1461: LEAF(iLine)
 1462: 	.set	noreorder
 1463: 
 1464: 	ICACHE(C_ILT, 0(a0))		/* Store Tag */
iLine:
[1464] 0x900000001fc02c68:  bc 84 00 00 cache	Index_Load_Tag[I],0(a0)
 1465: 	MFC0(v0, C0_TAGLO)
[1465] 0x900000001fc02c6c:  40 02 e0 00 mfc0	v0,taglo
 1466: 	MFC0(v1, C0_TAGHI)
[1466] 0x900000001fc02c70:  40 03 e8 00 mfc0	v1,taghi
 1467: 	dsll	v1,32
[1467] 0x900000001fc02c74:  00 03 18 3c dsll32	v1,v1,0
 1468: 	or	v0,v1
[1468] 0x900000001fc02c78:  00 43 10 25 or	v0,v0,v1
 1469: 	sd	v0,IL_TAG(a1)
[1469] 0x900000001fc02c7c:  fc a2 00 00 sd	v0,0(a1)
 1470: 
 1471: 	daddiu	t0,a1,IL_DATA		/* Data pointer   */
[1471] 0x900000001fc02c80:  64 ac 00 08 daddiu	t0,a1,8
 1472: 	daddiu	t1,a1,IL_PARITY		/* Parity pointer */
[1472] 0x900000001fc02c84:  64 ad 00 88 daddiu	t1,a1,136
 1473: 
 1474: 	daddiu	a2,a0,CACHE_ILINE_SIZE
[1474] 0x900000001fc02c88:  64 86 00 40 daddiu	a2,a0,64
 1475: 1:		
 1476: 	ICACHE(C_ILD, 0(a0))
[1476] 0x900000001fc02c8c:  bc 98 00 00 cache	Hit_WriteBack[I],0(a0)
 1477: 	MFC0(v0, C0_TAGLO)
[1477] 0x900000001fc02c90:  40 02 e0 00 mfc0	v0,taglo
 1478: 	MFC0(v1, C0_TAGHI)
[1478] 0x900000001fc02c94:  40 03 e8 00 mfc0	v1,taghi
 1479: 	dsll	v1,32
[1479] 0x900000001fc02c98:  00 03 18 3c dsll32	v1,v1,0
 1480: 	or	v0,v1
[1480] 0x900000001fc02c9c:  00 43 10 25 or	v0,v0,v1
 1481: 	sd	v0,0(t0)
[1481] 0x900000001fc02ca0:  fd 82 00 00 sd	v0,0(t0)
 1482: 	
 1483: 	MFC0(v0, C0_ECC)
[1483] 0x900000001fc02ca4:  40 02 d0 00 mfc0	v0,ecc
 1484: 	sb	v0,0(t1)
[1484] 0x900000001fc02ca8:  a1 a2 00 00 sb	v0,0(t1)
 1485: 	daddiu	t0,8			/* 8-bytes stored */
[1485] 0x900000001fc02cac:  65 8c 00 08 daddiu	t0,t0,8
 1486: 	daddiu	a0,4
[1486] 0x900000001fc02cb0:  64 84 00 04 daddiu	a0,a0,4
 1487: 	blt	a0, a2, 1b
[1487] 0x900000001fc02cb4:  00 86 08 2a slt	at,a0,a2
[1487] 0x900000001fc02cb8:  14 20 ff f4 bne	at,zero,0x900000001fc02c8c
 1488: 	daddiu	t1,1			/* 1-bit of parity */
[1488] 0x900000001fc02cbc:  65 ad 00 01 daddiu	t1,t1,1
 1489: 	
 1490: 	j	ra
[1490] 0x900000001fc02cc0:  03 e0 00 08 jr	ra
 1491: 	nop
[1491] 0x900000001fc02cc4:  00 00 00 00 nop
 1492: 	.set	reorder
 1493: 	END(iLine)
 1494: 
 1495: /*
 1496:  * Function:	dLine
 1497:  * Purpose:	Fetch primary data cache line.
 1498:  * Parameters:	a0 - vaddr (low order bit signals way)
 1499:  *		a1 - ptr to dl_t
 1500:  * Returns:	a1--> filled in.
 1501:  */
 1502: LEAF(dLine)
 1503: 	.set	noreorder
 1504: 	
 1505: 	DCACHE(C_ILT, 0(a0))		/* Read and store tag */
dLine:
[1505] 0x900000001fc02cc8:  bc 85 00 00 cache	Index_Load_Tag[D],0(a0)
 1506: 	MFC0(v0, C0_TAGHI)
[1506] 0x900000001fc02ccc:  40 02 e8 00 mfc0	v0,taghi
 1507: 	MFC0(v1, C0_TAGLO)
[1507] 0x900000001fc02cd0:  40 03 e0 00 mfc0	v1,taglo
 1508: 	dsll	v0,32
[1508] 0x900000001fc02cd4:  00 02 10 3c dsll32	v0,v0,0
 1509: 	or	v0,v1
[1509] 0x900000001fc02cd8:  00 43 10 25 or	v0,v0,v1
 1510: 	sd	v0,DL_TAG(a1)
[1510] 0x900000001fc02cdc:  fc a2 00 00 sd	v0,0(a1)
 1511: 
 1512: 	daddiu	a2,a0,CACHE_DLINE_SIZE
[1512] 0x900000001fc02ce0:  64 86 00 20 daddiu	a2,a0,32
 1513: 	daddiu	t0,a1,DL_DATA		/* Data pointer */
[1513] 0x900000001fc02ce4:  64 ac 00 08 daddiu	t0,a1,8
 1514: 	daddiu	t1,a1,DL_ECC		/* ECC pointer */
[1514] 0x900000001fc02ce8:  64 ad 00 28 daddiu	t1,a1,40
 1515: 
 1516: 1:	
 1517: 	DCACHE(C_ILD, 0(a0))
[1517] 0x900000001fc02cec:  bc 99 00 00 cache	Hit_WriteBack[D],0(a0)
 1518: 	MFC0(v0, C0_TAGLO)
[1518] 0x900000001fc02cf0:  40 02 e0 00 mfc0	v0,taglo
 1519: 	sw	v0,0(t0)
[1519] 0x900000001fc02cf4:  ad 82 00 00 sw	v0,0(t0)
 1520: 	MFC0(v0, C0_ECC)
[1520] 0x900000001fc02cf8:  40 02 d0 00 mfc0	v0,ecc
 1521: 	sb	v0,0(t1)
[1521] 0x900000001fc02cfc:  a1 a2 00 00 sb	v0,0(t1)
 1522: 	daddiu	a0,4			/* Next word - vaddr */
[1522] 0x900000001fc02d00:  64 84 00 04 daddiu	a0,a0,4
 1523: 	daddiu	t0,4			/* Next word - buffer */
[1523] 0x900000001fc02d04:  65 8c 00 04 daddiu	t0,t0,4
 1524: 	blt	a0,a2,1b
[1524] 0x900000001fc02d08:  00 86 08 2a slt	at,a0,a2
[1524] 0x900000001fc02d0c:  14 20 ff f7 bne	at,zero,0x900000001fc02cec
 1525: 	daddiu	t1,1			/* DELAY: Next ECC field */
[1525] 0x900000001fc02d10:  65 ad 00 01 daddiu	t1,t1,1
 1526: 
 1527: 	j	ra
[1527] 0x900000001fc02d14:  03 e0 00 08 jr	ra
 1528: 	nop
[1528] 0x900000001fc02d18:  00 00 00 00 nop
 1529: 	
 1530: 	.set	reorder
 1531: 	END(dLine)
 1532: 	
 1533: /*
 1534:  * Function:	sLine
 1535:  * Purpose:	Fetch a cache line from the secondary cache.
 1536:  * Parameters:	a0 - vaddr (low order bit signals way)
 1537:  *		a1 - pointer to sl_t area.
 1538:  * Returns:	nothing
 1539:  */
 1540: LEAF(sLine)
 1541: 
 1542: 	.set	noreorder
 1543: 
 1544: 	SCACHE(C_ILT, 0(a0))		/* Pick up T5 TAG */
sLine:
[1544] 0x900000001fc02d1c:  bc 87 00 00 cache	Index_Load_Tag[SD],0(a0)
 1545: 	MFC0(v0, C0_TAGHI)
[1545] 0x900000001fc02d20:  40 02 e8 00 mfc0	v0,taghi
 1546: 	MFC0(v1, C0_TAGLO)
[1546] 0x900000001fc02d24:  40 03 e0 00 mfc0	v1,taglo
 1547: 	dsll	v0,32
[1547] 0x900000001fc02d28:  00 02 10 3c dsll32	v0,v0,0
 1548: 	dsll	v1,32			/* Clear high order 32 bits */
[1548] 0x900000001fc02d2c:  00 03 18 3c dsll32	v1,v1,0
 1549: 	dsrl	v1,32
[1549] 0x900000001fc02d30:  00 03 18 3e dsrl32	v1,v1,0
 1550: 	or	v0,v1
[1550] 0x900000001fc02d34:  00 43 10 25 or	v0,v0,v1
 1551: 	sd	v0, SL_TAG(a1)
[1551] 0x900000001fc02d38:  fc a2 00 00 sd	v0,0(a1)
 1552: 	
 1553: 	move	t0,ra			/* Pick up CC tag */
[1553] 0x900000001fc02d3c:  03 e0 60 25 move	t0,ra
 1554: 	jal	sCacheSize
[1554] 0x900000001fc02d40:  0f f0 05 80 jal		sCacheSize
 1555: 	nop
[1555] 0x900000001fc02d44:  00 00 00 00 nop
 1556: 	move	ra,t0
[1556] 0x900000001fc02d48:  01 80 f8 25 move	ra,t0
 1557: 
 1558: 	srl	v0,1			/* div by 2 for # ways */
[1558] 0x900000001fc02d4c:  00 02 10 42 srl	v0,v0,1
 1559: 	sub	v0,1			/* scachesize/2 - 1 */
[1559] 0x900000001fc02d50:  20 42 ff ff addi	v0,v0,-1
 1560: 	and	v0,a0,v0		/* V0 - normalizes virtual address */
[1560] 0x900000001fc02d54:  00 82 10 24 and	v0,a0,v0
 1561: 
 1562: 	divu	v0,CACHE_SLINE_SIZE	/* Compute index */
[1562] 0x900000001fc02d58:  00 02 11 c2 srl	v0,v0,7
 1563: 	sll	v0,4			/* Index into duplicate tags */
[1563] 0x900000001fc02d5c:  00 02 11 00 sll	v0,v0,4
 1564: 	and	v1,a0,1			/* Look at way */
[1564] 0x900000001fc02d60:  30 83 00 01 andi	v1,a0,0x1
 1565: 	sll	v1,3			/* add 8-bytes for way 1 */
[1565] 0x900000001fc02d64:  00 03 18 c0 sll	v1,v1,3
 1566: 	daddu	v1,v0			/* Offset into TAGS */
[1566] 0x900000001fc02d68:  00 62 18 2d daddu	v1,v1,v0
 1567: 	daddu	v1,EV_BTRAM_BASE	/* address of TAG */
[1567] 0x900000001fc02d6c:  3c 01 90 00 lui	at,0x9000
[1567] 0x900000001fc02d70:  00 01 0c 38 dsll	at,at,16
[1567] 0x900000001fc02d74:  34 21 18 1c ori	at,at,0x181c
[1567] 0x900000001fc02d78:  00 01 0c 38 dsll	at,at,16
[1567] 0x900000001fc02d7c:  34 21 00 00 ori	at,at,0
[1567] 0x900000001fc02d80:  00 61 18 2d daddu	v1,v1,at
 1568: #if SABLE
 1569: 	move	v0,zero
 1570: #else
 1571: 	ld	v0,0(v1)		/* duplicate tag */
[1571] 0x900000001fc02d84:  dc 62 00 00 ld	v0,0(v1)
 1572: #endif
 1573: 	sd	v0,SL_CCTAG(a1)		/* and store for the caller */
[1573] 0x900000001fc02d88:  fc a2 00 08 sd	v0,8(a1)
 1574: 
 1575: 	/* OK - lets get the data */
 1576: 
 1577: 	li	v0,CACHE_SLINE_SIZE/16	/* # fetches */
[1577] 0x900000001fc02d8c:  24 02 00 08 li	v0,8
 1578: 	daddiu	t0,a1,SL_DATA
[1578] 0x900000001fc02d90:  64 ac 00 10 daddiu	t0,a1,16
 1579: 	daddiu	t1,a1,SL_ECC
[1579] 0x900000001fc02d94:  64 ad 00 90 daddiu	t1,a1,144
 1580: 2:
 1581: 	SCACHE(C_ILD, 0(a0))
[1581] 0x900000001fc02d98:  bc 9b 00 00 cache	Hit_WriteBack[SD],0(a0)
 1582: 	MFC0(v1, C0_TAGLO)		/* Store 8-bytes of data */
[1582] 0x900000001fc02d9c:  40 03 e0 00 mfc0	v1,taglo
 1583: 	sw	v1,0(t0)
[1583] 0x900000001fc02da0:  ad 83 00 00 sw	v1,0(t0)
 1584: 	MFC0(v1, C0_TAGHI)
[1584] 0x900000001fc02da4:  40 03 e8 00 mfc0	v1,taghi
 1585: 	sw	v1,4(t0)
[1585] 0x900000001fc02da8:  ad 83 00 04 sw	v1,4(t0)
 1586: 	MFC0(v1, C0_ECC)
[1586] 0x900000001fc02dac:  40 03 d0 00 mfc0	v1,ecc
 1587: 	sh	v1,0(t1)		/* Store ECC for this 8 bytes */
[1587] 0x900000001fc02db0:  a5 a3 00 00 sh	v1,0(t1)
 1588: 	
 1589: 	SCACHE(C_ILD, 8(a0))
[1589] 0x900000001fc02db4:  bc 9b 00 08 cache	Hit_WriteBack[SD],8(a0)
 1590: 	MFC0(v1, C0_TAGLO)		/* Store 8-bytes of data */
[1590] 0x900000001fc02db8:  40 03 e0 00 mfc0	v1,taglo
 1591: 	sw	v1,8(t0)
[1591] 0x900000001fc02dbc:  ad 83 00 08 sw	v1,8(t0)
 1592: 	MFC0(v1, C0_TAGHI)
[1592] 0x900000001fc02dc0:  40 03 e8 00 mfc0	v1,taghi
 1593: 	sw	v1,12(t0)
[1593] 0x900000001fc02dc4:  ad 83 00 0c sw	v1,12(t0)
 1594: 	
 1595: 	sub	v0,1
[1595] 0x900000001fc02dc8:  20 42 ff ff addi	v0,v0,-1
 1596: 	daddu	a0,16			/* Increment address */
[1596] 0x900000001fc02dcc:  64 84 00 10 daddiu	a0,a0,16
 1597: 	daddu	t0,16			/* Increment data array. */
[1597] 0x900000001fc02dd0:  65 8c 00 10 daddiu	t0,t0,16
 1598: 	bgt	v0,zero,2b
[1598] 0x900000001fc02dd4:  1c 40 ff f0 bgtz	v0,0x900000001fc02d98
 1599: 	daddiu	t1,2			/* DELAY: Increment ECC array */
[1599] 0x900000001fc02dd8:  65 ad 00 02 daddiu	t1,t1,2
 1600: 1:
 1601: 	/* All done ... */
 1602: 	j	ra
[1602] 0x900000001fc02ddc:  03 e0 00 08 jr	ra
 1603: 	nop
[1603] 0x900000001fc02de0:  00 00 00 00 nop
 1604: 	.set	reorder
 1605: 	END(sLine)
 1606: 
 1607: LEAF(stagECC)
 1608: /*
 1609:  * Function:	stagECC
 1610:  * Purpose:	Compute the secondary cache tag ECC value given
 1611:  *		the tag (without the ECC).
 1612:  * Parameters:	a0 - The 26-bit cache tag value.
 1613:  * Retruns:	v0 - ECC value.
 1614:  *
 1615:  * Notes: The following table is from the "R10000 User's Manual", in the 
 1616:  *	  section on secondary cache error protection handling. It indicates
 1617:  *	  the bits selected to look at for each of the check bits.
 1618:  */
 1619:         .data
 1620: tagECC:
 1621:         .dword	0x00a8f888
 1622:         .dword	0x0114ff04
 1623:         .dword	0x02620f42
 1624:         .dword	0x029184f0
 1625:         .dword	0x010a40ff
 1626:         .dword	0x0245222f
 1627:         .dword	0x01ff1111
 1628: tagECC_end:
 1629: 
 1630:         .text
 1631:         .set	noreorder
 1632: 
 1633:         move	v0,zero			/* Start out with 0 result */
stagECC:
[1633] 0x900000001fc02de4:  00 00 10 25 move	v0,zero
 1634:         dla	a1,tagECC		/* Current bit selector pointer */
[1634] 0x900000001fc02de8:  3c 05 90 00 lui	a1,0x9000
[1634] 0x900000001fc02dec:  64 a5 00 00 daddiu	a1,a1,0
[1634] 0x900000001fc02df0:  00 05 2c 38 dsll	a1,a1,16
[1634] 0x900000001fc02df4:  64 a5 1f c1 daddiu	a1,a1,8129
[1634] 0x900000001fc02df8:  00 05 2c 38 dsll	a1,a1,16
[1634] 0x900000001fc02dfc:  64 a5 77 68 daddiu	a1,a1,30568
 1635: 
 1636: stagECC_loop:				/* Loop for all bits set */
 1637: 
 1638:         dla	a2, tagECC_end
[1638] 0x900000001fc02e00:  3c 06 90 00 lui	a2,0x9000
[1638] 0x900000001fc02e04:  64 c6 00 00 daddiu	a2,a2,0
[1638] 0x900000001fc02e08:  00 06 34 38 dsll	a2,a2,16
[1638] 0x900000001fc02e0c:  64 c6 1f c1 daddiu	a2,a2,8129
[1638] 0x900000001fc02e10:  00 06 34 38 dsll	a2,a2,16
[1638] 0x900000001fc02e14:  64 c6 77 a0 daddiu	a2,a2,30624
 1639:         beq	a1,a2,stagECC_loopDone
[1639] 0x900000001fc02e18:  10 a6 00 10 beq	a1,a2,0x900000001fc02e5c
 1640:         nop
[1640] 0x900000001fc02e1c:  00 00 00 00 nop
 1641:         move	v1,zero			/* Result is always 0 to start */
[1641] 0x900000001fc02e20:  00 00 18 25 move	v1,zero
 1642:         lwu	a2, 0(a1)
[1642] 0x900000001fc02e24:  9c a6 00 00 lwu	a2,0(a1)
 1643:         and	a2,a0			/* Select the bits we want */
[1643] 0x900000001fc02e28:  00 c4 30 24 and	a2,a2,a0
 1644: 1:
 1645:         beqz	a2,2f			/* Done with this one */
[1645] 0x900000001fc02e2c:  10 c0 00 05 beq	a2,zero,0x900000001fc02e44
 1646:         nop
[1646] 0x900000001fc02e30:  00 00 00 00 nop
 1647:         xor	v1,a2
[1647] 0x900000001fc02e34:  00 66 18 26 xor	v1,v1,a2
 1648:         srl	a2,1
[1648] 0x900000001fc02e38:  00 06 30 42 srl	a2,a2,1
 1649:         b	1b
[1649] 0x900000001fc02e3c:  10 00 ff fb b		0x900000001fc02e2c
 1650:         nop
[1650] 0x900000001fc02e40:  00 00 00 00 nop
 1651: 2:
 1652:         /*
 1653:          * Shift the running result, and or the new bit into the bottom
 1654:          * position. This means we actually do bit 6 first, and bit 0 last.
 1655:          */
 1656:         and	v1, 0x1			/* Pick up bit */
[1656] 0x900000001fc02e44:  30 63 00 01 andi	v1,v1,0x1
 1657:         sll	v0,1			/* Shift into position */
[1657] 0x900000001fc02e48:  00 02 10 40 sll	v0,v0,1
 1658:         or	v0,v1			/* And put into result */
[1658] 0x900000001fc02e4c:  00 43 10 25 or	v0,v0,v1
 1659:         daddiu	a1, 4			/* Next check bit please ...  */
[1659] 0x900000001fc02e50:  64 a5 00 04 daddiu	a1,a1,4
 1660:         b	stagECC_loop		/* Next one */
[1660] 0x900000001fc02e54:  10 00 ff ea b		0x900000001fc02e00
 1661:         nop
[1661] 0x900000001fc02e58:  00 00 00 00 nop
 1662: 
 1663: stagECC_loopDone:			/* All done ... */
 1664: 	j	ra
[1664] 0x900000001fc02e5c:  03 e0 00 08 jr	ra
 1665:         nop
[1665] 0x900000001fc02e60:  00 00 00 00 nop
 1666: 	
 1667: 	END(stagECC)
 1668: 
 1669: LEAF(copyToICache)
 1670: /*
 1671:  * Function:	copyToIcache
 1672:  * Purpose:	To copy PIC code to the icache, execute it, and return.
 1673:  * Parameters:	a0 - pointer to address to copy
 1674:  *		a1 - length (# of bytes to copy - must be multiple of
 1675:  *		     4.
 1676:  * Returns:	v0 - virtual address corresponding to first instruction
 1677:  *		     as pointed to by a0.
 1678:  * Notes:	Build texts in primary dcache, then flushes to secondary
 1679:  *		cache.
 1680:  */
 1681: 	.set	noreorder
 1682: 	move	a3,ra			/* save RA */
copyToICache:
[1682] 0x900000001fc02e64:  03 e0 38 25 move	a3,ra
 1683:         move	t0,a0
[1683] 0x900000001fc02e68:  00 80 60 25 move	t0,a0
 1684: 
 1685: 	/*
 1686: 	 * Be sure to fill an entire s-line, otherwise, we could get
 1687: 	 * errors on non-initialized parts of the sline since the T5
 1688: 	 * likes to prefetch stuff.
 1689: 	 */
 1690: 
 1691: 	daddiu	t1, a1, CACHE_SLINE_SIZE-1
[1691] 0x900000001fc02e6c:  64 ad 00 7f daddiu	t1,a1,127
 1692: 	and	t1, ~(CACHE_SLINE_SIZE - 1)	/* Mutiple of s-lines */
[1692] 0x900000001fc02e70:  24 01 ff 80 li	at,-128
[1692] 0x900000001fc02e74:  01 a1 68 24 and	t1,t1,at
 1693: 	divu	t3, t1, CACHE_DLINE_SIZE	/* # primary d-lines. */
[1693] 0x900000001fc02e78:  00 0d 79 42 srl	t3,t1,5
 1694: 
 1695: 	LEDS(PLED_INITICACHE)			/* Do after a0/a1 saved */
[1695] 0x900000001fc02e7c:  00 00 00 00 nop
[1695] 0x900000001fc02e80:  34 04 00 0e ori	a0,zero,0xe
[1695] 0x900000001fc02e84:  3c 02 90 00 lui	v0,0x9000
[1695] 0x900000001fc02e88:  00 02 14 38 dsll	v0,v0,16
[1695] 0x900000001fc02e8c:  34 42 19 00 ori	v0,v0,0x1900
[1695] 0x900000001fc02e90:  00 02 14 38 dsll	v0,v0,16
[1695] 0x900000001fc02e94:  34 42 40 00 ori	v0,v0,0x4000
[1695] 0x900000001fc02e98:  fc 44 00 00 sd	a0,0(v0)
 1696: 
 1697: 	dli	a0, CTP_STATE_DE
[1697] 0x900000001fc02e9c:  24 04 00 03 li	a0,3
 1698: 	jal	parity
[1698] 0x900000001fc02ea0:  0f f0 0a cf jal		testCCtags_END
 1699: 	move	a1,zero
[1699] 0x900000001fc02ea4:  00 00 28 25 move	a1,zero
 1700: 
 1701: 	/* Build constant part of dtag into t2 */
 1702: 
 1703: 	dsll	v0,CTP_STATEPARITY_SHFT
[1703] 0x900000001fc02ea8:  00 02 10 b8 dsll	v0,v0,2
 1704: 	dli	t2,(CTP_STATE_DE<<CTP_STATE_SHFT) + \
[1704] 0x900000001fc02eac:  3c 0e 20 00 lui	t2,0x2000
[1704] 0x900000001fc02eb0:  00 0e 70 3c dsll32	t2,t2,0
[1704] 0x900000001fc02eb4:  35 ce 00 c0 ori	t2,t2,0xc0
 1705: 		   (CTP_STATEMOD_N<<CTP_STATEMOD_SHFT)
 1706: 	or	t2,v0				/* State with parity */
[1706] 0x900000001fc02eb8:  01 c2 70 25 or	t2,t2,v0
 1707: 
 1708: 	/*
 1709: 	 * Loop through the primary d-cache lines marking the tags.
 1710: 	 */
 1711: 	move	ta2,t3
[1711] 0x900000001fc02ebc:  01 e0 50 25 move	a6,t3
 1712: 	dli	t8, POD_CODEVADDR		/* Start of virt address */
[1712] 0x900000001fc02ec0:  3c 18 a8 00 lui	t8,0xa800
[1712] 0x900000001fc02ec4:  00 18 c4 38 dsll	t8,t8,16
[1712] 0x900000001fc02ec8:  37 18 00 0f ori	t8,t8,0xf
[1712] 0x900000001fc02ecc:  00 18 c4 38 dsll	t8,t8,16
[1712] 0x900000001fc02ed0:  37 18 d0 00 ori	t8,t8,0xd000
 1713: 	dli	t9, POD_CODEPADDR		/* Start of phys address */
[1713] 0x900000001fc02ed4:  3c 19 00 0f lui	t9,0xf
[1713] 0x900000001fc02ed8:  37 39 d0 00 ori	t9,t9,0xd000
 1714: 1:
 1715: 	dsrl	ta3, t9, 4
[1715] 0x900000001fc02edc:  00 19 59 3a dsrl	a7,t9,4
 1716: 	and	ta3, CTP_TAG_MASK		/* Physical address portion */
[1716] 0x900000001fc02ee0:  24 01 ff ff li	at,-1
[1716] 0x900000001fc02ee4:  00 01 09 3c dsll32	at,at,4
[1716] 0x900000001fc02ee8:  00 01 0f 3a dsrl	at,at,28
[1716] 0x900000001fc02eec:  01 61 58 24 and	a7,a7,at
 1717: 	move	a0, ta3
[1717] 0x900000001fc02ef0:  01 60 20 25 move	a0,a7
 1718: 	jal	parity
[1718] 0x900000001fc02ef4:  0f f0 0a cf jal		testCCtags_END
 1719: 	move	a1,zero
[1719] 0x900000001fc02ef8:  00 00 28 25 move	a1,zero
 1720: 	dsll	v0,CTP_TAGPARITY_SHFT
[1720] 0x900000001fc02efc:  00 40 10 2d move	v0,v0
 1721: 	or	ta3,v0
[1721] 0x900000001fc02f00:  01 62 58 25 or	a7,a7,v0
 1722: 	or	ta3,t2				/* Tag - with parity */
[1722] 0x900000001fc02f04:  01 6e 58 25 or	a7,a7,t2
 1723: 
 1724: 	MTC0(ta3, C0_TAGLO)
[1724] 0x900000001fc02f08:  40 8b e0 00 mtc0	a7,taglo
 1725: 	dsrl	ta3,32
[1725] 0x900000001fc02f0c:  00 0b 58 3e dsrl32	a7,a7,0
 1726: 	MTC0(ta3, C0_TAGHI)
[1726] 0x900000001fc02f10:  40 8b e8 00 mtc0	a7,taghi
 1727: 	DCACHE(C_IST, 0(t8))
[1727] 0x900000001fc02f14:  bf 09 00 00 cache	Index_Store_Tag[D],0(t8)
 1728: 
 1729: 	daddiu	t8, CACHE_DLINE_SIZE
[1729] 0x900000001fc02f18:  67 18 00 20 daddiu	t8,t8,32
 1730: 	daddiu	t9, CACHE_DLINE_SIZE
[1730] 0x900000001fc02f1c:  67 39 00 20 daddiu	t9,t9,32
 1731: 	sub	ta2, 1
[1731] 0x900000001fc02f20:  21 4a ff ff addi	a6,a6,-1
 1732: 	bgtz	ta2, 1b
[1732] 0x900000001fc02f24:  1d 40 ff ed bgtz	a6,0x900000001fc02edc
 1733: 	nop
[1733] 0x900000001fc02f28:  00 00 00 00 nop
 1734: 
 1735: 	/*
 1736: 	 * Now compute and store the secondary cache tags - first round
 1737: 	 * up # bytes to mutiple of secondary cache lines.
 1738: 	 */
 1739: 
 1740: 	daddiu	ta2, t1, CACHE_SLINE_SIZE - 1
[1740] 0x900000001fc02f2c:  65 aa 00 7f daddiu	a6,t1,127
 1741: 	and	ta2, ~(CACHE_SLINE_SIZE - 1)	/* # secondary bytes */
[1741] 0x900000001fc02f30:  24 01 ff 80 li	at,-128
[1741] 0x900000001fc02f34:  01 41 50 24 and	a6,a6,at
 1742: 	dli	t9, POD_CODEPADDR
[1742] 0x900000001fc02f38:  3c 19 00 0f lui	t9,0xf
[1742] 0x900000001fc02f3c:  37 39 d0 00 ori	t9,t9,0xd000
 1743:         dli	t8, POD_CODEVADDR
[1743] 0x900000001fc02f40:  3c 18 a8 00 lui	t8,0xa800
[1743] 0x900000001fc02f44:  00 18 c4 38 dsll	t8,t8,16
[1743] 0x900000001fc02f48:  37 18 00 0f ori	t8,t8,0xf
[1743] 0x900000001fc02f4c:  00 18 c4 38 dsll	t8,t8,16
[1743] 0x900000001fc02f50:  37 18 d0 00 ori	t8,t8,0xd000
 1744: 
 1745: 	/*
 1746: 	 * Set the phsyical address bits - the secondary cache state
 1747: 	 * is marked XXX to allow a cache HIT in the secondary cache when 
 1748: 	 * we flush the primary cache.
 1749: 	 */
 1750: 1:	
 1751: 	dsrl	ta3, t9, 4
[1751] 0x900000001fc02f54:  00 19 59 3a dsrl	a7,t9,4
 1752: 	and	ta3, CTS_TAG_MASK		/* Physical address bits */
[1752] 0x900000001fc02f58:  24 01 ff ff li	at,-1
[1752] 0x900000001fc02f5c:  00 01 0a bc dsll32	at,at,10
[1752] 0x900000001fc02f60:  00 01 0f 3a dsrl	at,at,28
[1752] 0x900000001fc02f64:  01 61 58 24 and	a7,a7,at
 1753: 		
 1754: 	or	ta3, 3 << CTS_STATE_SHFT
[1754] 0x900000001fc02f68:  35 6b 0c 00 ori	a7,a7,0xc00
 1755: 	or	ta3, /* VIDX %%% */ 0
[1755] 0x900000001fc02f6c:  35 6b 00 00 ori	a7,a7,0
 1756: 
 1757: 	jal	stagECC
[1757] 0x900000001fc02f70:  0f f0 0b 79 jal		stagECC
 1758: 	move	a0, ta3
[1758] 0x900000001fc02f74:  01 60 20 25 move	a0,a7
 1759: 	or	ta3,v0				/* Or in ECC */
[1759] 0x900000001fc02f78:  01 62 58 25 or	a7,a7,v0
 1760: 
 1761: 	/* TAG is now in ta3 with ECC set - write it and continue. */
 1762: 
 1763: 	MTC0(ta3, C0_TAGLO)
[1763] 0x900000001fc02f7c:  40 8b e0 00 mtc0	a7,taglo
 1764: 	dsrl	ta3, 32
[1764] 0x900000001fc02f80:  00 0b 58 3e dsrl32	a7,a7,0
 1765: 	MTC0(ta3, C0_TAGHI)
[1765] 0x900000001fc02f84:  40 8b e8 00 mtc0	a7,taghi
 1766: 	SCACHE(C_IST, 0(t8))
[1766] 0x900000001fc02f88:  bf 0b 00 00 cache	Index_Store_Tag[SD],0(t8)
 1767: 	
 1768:         MTC0(zero, C0_TAGLO)			/* Clear other way */
[1768] 0x900000001fc02f8c:  40 80 e0 00 mtc0	zero,taglo
 1769: 	MTC0(zero, C0_TAGHI)
[1769] 0x900000001fc02f90:  40 80 e8 00 mtc0	zero,taghi
 1770:         MTC0(zero, C0_ECC)
[1770] 0x900000001fc02f94:  40 80 d0 00 mtc0	zero,ecc
 1771:         SCACHE(C_IST, 1(t8))
[1771] 0x900000001fc02f98:  bf 0b 00 01 cache	Index_Store_Tag[SD],1(t8)
 1772: 
 1773: 	daddiu	t9, CACHE_SLINE_SIZE		/* Increment physical addr */
[1773] 0x900000001fc02f9c:  67 39 00 80 daddiu	t9,t9,128
 1774: 	daddiu	t8, CACHE_SLINE_SIZE		/* Increment virtual addr */
[1774] 0x900000001fc02fa0:  67 18 00 80 daddiu	t8,t8,128
 1775: 	sub	ta2, CACHE_SLINE_SIZE
[1775] 0x900000001fc02fa4:  21 4a ff 80 addi	a6,a6,-128
 1776: 	bgtz	ta2, 1b
[1776] 0x900000001fc02fa8:  1d 40 ff ea bgtz	a6,0x900000001fc02f54
 1777: 	nop
[1777] 0x900000001fc02fac:  00 00 00 00 nop
 1778: 
 1779: 	/*
 1780: 	 * At this point, the primary D-cache tags are marked dirty 
 1781: 	 * exclusive, and the secondary cache tags are marked the same.
 1782: 	 * We now copy the data into the primary data cache. Since parity
 1783: 	 * is on a byte basis, we store words - no read/modify/write
 1784: 	 * is required by the R10K.  Here we assume the length is a
 1785: 	 * MULTIPLE NUMBER OF d-cache lines.
 1786: 	 */
 1787: 	dli	t8, POD_CODEVADDR		/* Destination */
[1787] 0x900000001fc02fb0:  3c 18 a8 00 lui	t8,0xa800
[1787] 0x900000001fc02fb4:  00 18 c4 38 dsll	t8,t8,16
[1787] 0x900000001fc02fb8:  37 18 00 0f ori	t8,t8,0xf
[1787] 0x900000001fc02fbc:  00 18 c4 38 dsll	t8,t8,16
[1787] 0x900000001fc02fc0:  37 18 d0 00 ori	t8,t8,0xd000
 1788: 	move	ta3, t0				/* Source */
[1788] 0x900000001fc02fc4:  01 80 58 25 move	a7,t0
 1789: 	move	ta1, t1				/* Length */
[1789] 0x900000001fc02fc8:  01 a0 48 25 move	a5,t1
 1790: 1:	
 1791: 	lw	v0,0(ta3)
[1791] 0x900000001fc02fcc:  8d 62 00 00 lw	v0,0(a7)
 1792: 	sw	v0,0(t8)
[1792] 0x900000001fc02fd0:  af 02 00 00 sw	v0,0(t8)
 1793: 	daddiu	ta3, 4
[1793] 0x900000001fc02fd4:  65 6b 00 04 daddiu	a7,a7,4
 1794: 	daddiu	t8, 4
[1794] 0x900000001fc02fd8:  67 18 00 04 daddiu	t8,t8,4
 1795: 	sub	ta1,4
[1795] 0x900000001fc02fdc:  21 29 ff fc addi	a5,a5,-4
 1796: 	bgtz	ta1,1b
[1796] 0x900000001fc02fe0:  1d 20 ff fa bgtz	a5,0x900000001fc02fcc
 1797: 	nop
[1797] 0x900000001fc02fe4:  00 00 00 00 nop
 1798: 
 1799: 	/*
 1800: 	 * Now flush the newly copied data out of the data cache, 
 1801: 	 * and into the secondary cache.
 1802: 	 */
 1803: 	
 1804: 	dli	t8, POD_CODEVADDR
[1804] 0x900000001fc02fe8:  3c 18 a8 00 lui	t8,0xa800
[1804] 0x900000001fc02fec:  00 18 c4 38 dsll	t8,t8,16
[1804] 0x900000001fc02ff0:  37 18 00 0f ori	t8,t8,0xf
[1804] 0x900000001fc02ff4:  00 18 c4 38 dsll	t8,t8,16
[1804] 0x900000001fc02ff8:  37 18 d0 00 ori	t8,t8,0xd000
 1805: 	move	ta1,t1				/* Length */
[1805] 0x900000001fc02ffc:  01 a0 48 25 move	a5,t1
 1806: 1:	
 1807: 	DCACHE(C_HWBINV, 0(t8))			/* Flush from d-cache */
[1807] 0x900000001fc03000:  bf 15 00 00 cache	Hit_WriteBack_Invalidate[D],0(t8)
 1808: 	ICACHE(C_HINV, 0(t8))			/* Be sure out of i-cache */
[1808] 0x900000001fc03004:  bf 10 00 00 cache	Hit_Invalidate[I],0(t8)
 1809: 	daddiu	t8, CACHE_DLINE_SIZE
[1809] 0x900000001fc03008:  67 18 00 20 daddiu	t8,t8,32
 1810: 	sub	ta1, CACHE_DLINE_SIZE
[1810] 0x900000001fc0300c:  21 29 ff e0 addi	a5,a5,-32
 1811: 	bgtz	ta1, 1b
[1811] 0x900000001fc03010:  1d 20 ff fb bgtz	a5,0x900000001fc03000
 1812: 	nop
[1812] 0x900000001fc03014:  00 00 00 00 nop
 1813: 
 1814: 	/*
 1815: 	 * Everything is now flushed to secondary cache - we can return
 1816: 	 * to the caller and let them know all is OK.
 1817: 	 */
 1818: 
 1819: 	dli	v0,POD_CODEVADDR
[1819] 0x900000001fc03018:  3c 02 a8 00 lui	v0,0xa800
[1819] 0x900000001fc0301c:  00 02 14 38 dsll	v0,v0,16
[1819] 0x900000001fc03020:  34 42 00 0f ori	v0,v0,0xf
[1819] 0x900000001fc03024:  00 02 14 38 dsll	v0,v0,16
[1819] 0x900000001fc03028:  34 42 d0 00 ori	v0,v0,0xd000
 1820: 	j	a3
[1820] 0x900000001fc0302c:  00 e0 00 08 jr	a3
 1821: 	nop
[1821] 0x900000001fc03030:  00 00 00 00 nop
 1822: 	END(copyToICache)
 1823: 	
 1824: LEAF(cacheFlush)
 1825: /*
 1826:  * Routine:	cacheFlush
 1827:  * Purpose:	To flush the current contents of the entire cache.
 1828:  * Parameters:	none
 1829:  * Returns:	Nothing
 1830:  * Notes:	Uses v0, v1, a0, a1
 1831:  */
 1832: 	.set	reorder
 1833: 	move	a0,ra				/* Save way back */
cacheFlush:
[1833] 0x900000001fc03034:  03 e0 20 25 move	a0,ra
 1834: 	jal	sCacheSize
[1834] 0x900000001fc03038:  0f f0 05 80 jal		sCacheSize
[1834] 0x900000001fc0303c:  00 00 00 00 nop
 1835: 	dsrl	v0,1				/* divide by 2 - 2-way */
[1835] 0x900000001fc03040:  00 02 10 7a dsrl	v0,v0,1
 1836: 	dli	v1,K0BASE			/* Use unmapped space */
[1836] 0x900000001fc03044:  24 03 00 15 li	v1,21
[1836] 0x900000001fc03048:  00 03 1e fc dsll32	v1,v1,27
 1837: 	daddu	v0,v1				/* Ending address */
[1837] 0x900000001fc0304c:  00 43 10 2d daddu	v0,v0,v1
 1838: 
 1839: 	.set	noreorder
 1840: 1:	
 1841: 	SCACHE(C_HWBINV, 0(v1))			/* Way 0 */
[1841] 0x900000001fc03050:  bc 77 00 00 cache	Hit_WriteBack_Invalidate[SD],0(v1)
 1842: 	SCACHE(C_HWBINV, 1(v1))			/* Way 1 */
[1842] 0x900000001fc03054:  bc 77 00 01 cache	Hit_WriteBack_Invalidate[SD],1(v1)
 1843: 	daddu	v1,CACHE_SLINE_SIZE
[1843] 0x900000001fc03058:  64 63 00 80 daddiu	v1,v1,128
 1844: 	bltu	v1,v0,1b
[1844] 0x900000001fc0305c:  00 62 08 2b sltu	at,v1,v0
[1844] 0x900000001fc03060:  14 20 ff fb bne	at,zero,0x900000001fc03050
 1845: 	nop
[1845] 0x900000001fc03064:  00 00 00 00 nop
 1846: 	.set	reorder
 1847: 
 1848: 	j	a0
[1848] 0x900000001fc03068:  00 80 00 08 jr	a0
[1848] 0x900000001fc0306c:  00 00 00 00 nop
 1849: 	END(cacheFlush)
 1850: 
 1851: LEAF(cacheError)
 1852: /*
 1853:  * Routine:	cacheError
 1854:  * Purpose:	Process a cache error exception.
 1855:  * Parameters:	None
 1856:  * Returns:	Does not return
 1857:  * Notes:	Since we do not return, no registers need be saved.
 1858:  */
 1859: 	.set	reorder
 1860: #if 0	
 1861: 	MFC0(s0, C0_CACHERR)
 1862: 
 1863: 	/* Check for I-cache/D-cache/S-cache, and do the "right" thing. */
 1864: 
 1865: 	srl	s1,s0,CE_TYPE_SHFT
 1866: 	andi	s1,(CE_TYPE_MASK>>CE_TYPE_SHFT)
 1867: 	be	s1,CE_TYPE_I>>CE_TYPE_SHFT,cacheError_I
 1868: 	nop
 1869: 	be	s1,CE_TYPE_D>>CE_TYPE_SHFT,cacheError_D
 1870: 	nop
 1871: 	be	s1,CE_TYPE_S>>CE_TYPE_SHFT,cacheError_S
 1872: 	nop
 1873: #endif
 1874: 	/* Must be SIE */
 1875: 	END(cacheError)
 1876: 
 1877: LEAF(cacheOP)
 1878: /*
 1879:  * Routine:	cacheOP
 1880:  * Purpose:	Perform a cache operation
 1881:  * Parameters:	a0 - cacheop_t * - pointer to cache op structure.
 1882:  * Returns:	v0 - undefined, for Load data, taghi, taglo, and ECC
 1883:  *		     values filled in.
 1884:  */
 1885: 	.set	noreorder
 1886: 	lw	v0,COP_TAGLO(a0)		/* First setup CP0 */
cacheOP:
[1886] 0x900000001fc03070:  8c 82 00 10 lw	v0,16(a0)
 1887: 	MTC0(v0, C0_TAGLO)
[1887] 0x900000001fc03074:  40 82 e0 00 mtc0	v0,taglo
 1888: 	lw	v0,COP_TAGHI(a0)
[1888] 0x900000001fc03078:  8c 82 00 0c lw	v0,12(a0)
 1889: 	MTC0(v0, C0_TAGHI)
[1889] 0x900000001fc0307c:  40 82 e8 00 mtc0	v0,taghi
 1890: 	lw	v0,COP_ECC(a0)
[1890] 0x900000001fc03080:  8c 82 00 14 lw	v0,20(a0)
 1891: 	MTC0(v0, C0_ECC)
[1891] 0x900000001fc03084:  40 82 d0 00 mtc0	v0,ecc
 1892: 	
 1893: 	ld	a1,COP_ADDRESS(a0)		/* Address to use */
[1893] 0x900000001fc03088:  dc 85 00 00 ld	a1,0(a0)
 1894: 	lw	v1,COP_OP(a0)			/* Operation */
[1894] 0x900000001fc0308c:  8c 83 00 08 lw	v1,8(a0)
 1895: 	dla	v0,cacheOP_table
[1895] 0x900000001fc03090:  3c 02 90 00 lui	v0,0x9000
[1895] 0x900000001fc03094:  64 42 00 00 daddiu	v0,v0,0
[1895] 0x900000001fc03098:  00 02 14 38 dsll	v0,v0,16
[1895] 0x900000001fc0309c:  64 42 1f c0 daddiu	v0,v0,8128
[1895] 0x900000001fc030a0:  00 02 14 38 dsll	v0,v0,16
[1895] 0x900000001fc030a4:  64 42 30 d4 daddiu	v0,v0,12500
 1896: 	sll	v1,3				/* Index into table. */
[1896] 0x900000001fc030a8:  00 03 18 c0 sll	v1,v1,3
 1897: 	daddu	v0,v1
[1897] 0x900000001fc030ac:  00 43 10 2d daddu	v0,v0,v1
 1898: 	jalr	a2,v0
[1898] 0x900000001fc030b0:  00 40 30 09 jalr	a2,v0
 1899: 	nop
[1899] 0x900000001fc030b4:  00 00 00 00 nop
 1900: 	MFC0(v0, C0_TAGLO)
[1900] 0x900000001fc030b8:  40 02 e0 00 mfc0	v0,taglo
 1901: 	sw	v0,COP_TAGLO(a0)
[1901] 0x900000001fc030bc:  ac 82 00 10 sw	v0,16(a0)
 1902: 	MFC0(v0, C0_TAGHI)
[1902] 0x900000001fc030c0:  40 02 e8 00 mfc0	v0,taghi
 1903: 	sw	v0,COP_TAGHI(a0)
[1903] 0x900000001fc030c4:  ac 82 00 0c sw	v0,12(a0)
 1904: 	MFC0(v0, C0_ECC)
[1904] 0x900000001fc030c8:  40 02 d0 00 mfc0	v0,ecc
 1905: 	j	ra
[1905] 0x900000001fc030cc:  03 e0 00 08 jr	ra
 1906: 	sw	v0,COP_ECC(a0)
[1906] 0x900000001fc030d0:  ac 82 00 14 sw	v0,20(a0)
 1907: 	.set	reorder
 1908: 
 1909:         /*
 1910:          * There are 32 possible operations to perform, each is
 1911: 	 * defined in the table below, and uses 2 instructions (8 bytes).
 1912:          */
 1913: 
 1914: cacheOP_table:
 1915: 	.set	noreorder
 1916: 	jr	a2
[1916] 0x900000001fc030d4:  00 c0 00 08 jr	a2
 1917: 	cache	0, 0(a1)
[1917] 0x900000001fc030d8:  bc a0 00 00 cache	Index_Invalidate[I],0(a1)
 1918: 	jr	a2
[1918] 0x900000001fc030dc:  00 c0 00 08 jr	a2
 1919: 	cache	1, 0(a1)
[1919] 0x900000001fc030e0:  bc a1 00 00 cache	Index_WriteBack_Invalidate[D],0(a1)
 1920: 	jr	a2
[1920] 0x900000001fc030e4:  00 c0 00 08 jr	a2
 1921: 	cache	2, 0(a1)
[1921] 0x900000001fc030e8:  bc a2 00 00 cache	Index_Invalidate[SI],0(a1)
 1922: 	jr	a2
[1922] 0x900000001fc030ec:  00 c0 00 08 jr	a2
 1923: 	cache	3, 0(a1)
[1923] 0x900000001fc030f0:  bc a3 00 00 cache	Index_WriteBack_Invalidate[SD],0(a1)
 1924: 	jr	a2
[1924] 0x900000001fc030f4:  00 c0 00 08 jr	a2
 1925: 	cache	4, 0(a1)
[1925] 0x900000001fc030f8:  bc a4 00 00 cache	Index_Load_Tag[I],0(a1)
 1926: 	jr	a2
[1926] 0x900000001fc030fc:  00 c0 00 08 jr	a2
 1927: 	cache	5, 0(a1)
[1927] 0x900000001fc03100:  bc a5 00 00 cache	Index_Load_Tag[D],0(a1)
 1928: 	jr	a2
[1928] 0x900000001fc03104:  00 c0 00 08 jr	a2
 1929: 	cache	6, 0(a1)
[1929] 0x900000001fc03108:  bc a6 00 00 cache	Index_Load_Tag[SI],0(a1)
 1930: 	jr	a2
[1930] 0x900000001fc0310c:  00 c0 00 08 jr	a2
 1931: 	cache	7, 0(a1)
[1931] 0x900000001fc03110:  bc a7 00 00 cache	Index_Load_Tag[SD],0(a1)
 1932: 	jr	a2
[1932] 0x900000001fc03114:  00 c0 00 08 jr	a2
 1933: 	cache	8, 0(a1)
[1933] 0x900000001fc03118:  bc a8 00 00 cache	Index_Store_Tag[I],0(a1)
 1934: 	jr	a2
[1934] 0x900000001fc0311c:  00 c0 00 08 jr	a2
 1935: 	cache	9, 0(a1)
[1935] 0x900000001fc03120:  bc a9 00 00 cache	Index_Store_Tag[D],0(a1)
 1936: 	jr	a2
[1936] 0x900000001fc03124:  00 c0 00 08 jr	a2
 1937: 	cache	10, 0(a1)
[1937] 0x900000001fc03128:  bc aa 00 00 cache	Index_Store_Tag[SI],0(a1)
 1938: 	jr	a2
[1938] 0x900000001fc0312c:  00 c0 00 08 jr	a2
 1939: 	cache	11, 0(a1)
[1939] 0x900000001fc03130:  bc ab 00 00 cache	Index_Store_Tag[SD],0(a1)
 1940: 	jr	a2
[1940] 0x900000001fc03134:  00 c0 00 08 jr	a2
 1941: 	cache	12, 0(a1)
[1941] 0x900000001fc03138:  bc ac 00 00 cache	Create_Dirty_Exclusive[I],0(a1)
 1942: 	jr	a2
[1942] 0x900000001fc0313c:  00 c0 00 08 jr	a2
 1943: 	cache	13, 0(a1)
[1943] 0x900000001fc03140:  bc ad 00 00 cache	Create_Dirty_Exclusive[D],0(a1)
 1944: 	jr	a2
[1944] 0x900000001fc03144:  00 c0 00 08 jr	a2
 1945: 	cache	14, 0(a1)
[1945] 0x900000001fc03148:  bc ae 00 00 cache	Create_Dirty_Exclusive[SI],0(a1)
 1946: 	jr	a2
[1946] 0x900000001fc0314c:  00 c0 00 08 jr	a2
 1947: 	cache	15, 0(a1)
[1947] 0x900000001fc03150:  bc af 00 00 cache	Create_Dirty_Exclusive[SD],0(a1)
 1948: 	jr	a2
[1948] 0x900000001fc03154:  00 c0 00 08 jr	a2
 1949: 	cache	16, 0(a1)
[1949] 0x900000001fc03158:  bc b0 00 00 cache	Hit_Invalidate[I],0(a1)
 1950: 	jr	a2
[1950] 0x900000001fc0315c:  00 c0 00 08 jr	a2
 1951: 	cache	17, 0(a1)
[1951] 0x900000001fc03160:  bc b1 00 00 cache	Hit_Invalidate[D],0(a1)
 1952: 	jr	a2
[1952] 0x900000001fc03164:  00 c0 00 08 jr	a2
 1953: 	cache	18, 0(a1)
[1953] 0x900000001fc03168:  bc b2 00 00 cache	Hit_Invalidate[SI],0(a1)
 1954: 	jr	a2
[1954] 0x900000001fc0316c:  00 c0 00 08 jr	a2
 1955: 	cache	19, 0(a1)
[1955] 0x900000001fc03170:  bc b3 00 00 cache	Hit_Invalidate[SD],0(a1)
 1956: 	jr	a2
[1956] 0x900000001fc03174:  00 c0 00 08 jr	a2
 1957: 	cache	20, 0(a1)
[1957] 0x900000001fc03178:  bc b4 00 00 cache	Fill[I],0(a1)
 1958: 	jr	a2
[1958] 0x900000001fc0317c:  00 c0 00 08 jr	a2
 1959: 	cache	21, 0(a1)
[1959] 0x900000001fc03180:  bc b5 00 00 cache	Hit_WriteBack_Invalidate[D],0(a1)
 1960: 	jr	a2
[1960] 0x900000001fc03184:  00 c0 00 08 jr	a2
 1961: 	cache	22, 0(a1)
[1961] 0x900000001fc03188:  bc b6 00 00 cache	Hit_WriteBack_Invalidate[SI],0(a1)
 1962: 	jr	a2
[1962] 0x900000001fc0318c:  00 c0 00 08 jr	a2
 1963: 	cache	23, 0(a1)
[1963] 0x900000001fc03190:  bc b7 00 00 cache	Hit_WriteBack_Invalidate[SD],0(a1)
 1964: 	jr	a2
[1964] 0x900000001fc03194:  00 c0 00 08 jr	a2
 1965: 	cache	24, 0(a1)
[1965] 0x900000001fc03198:  bc b8 00 00 cache	Hit_WriteBack[I],0(a1)
 1966: 	jr	a2
[1966] 0x900000001fc0319c:  00 c0 00 08 jr	a2
 1967: 	cache	25, 0(a1)
[1967] 0x900000001fc031a0:  bc b9 00 00 cache	Hit_WriteBack[D],0(a1)
 1968: 	jr	a2
[1968] 0x900000001fc031a4:  00 c0 00 08 jr	a2
 1969: 	cache	26, 0(a1)
[1969] 0x900000001fc031a8:  bc ba 00 00 cache	Hit_WriteBack[SI],0(a1)
 1970: 	jr	a2
[1970] 0x900000001fc031ac:  00 c0 00 08 jr	a2
 1971: 	cache	27, 0(a1)
[1971] 0x900000001fc031b0:  bc bb 00 00 cache	Hit_WriteBack[SD],0(a1)
 1972: 	jr	a2
[1972] 0x900000001fc031b4:  00 c0 00 08 jr	a2
 1973: 	cache	28, 0(a1)
[1973] 0x900000001fc031b8:  bc bc 00 00 cache	Hit_Set_Virtual[I],0(a1)
 1974: 	jr	a2
[1974] 0x900000001fc031bc:  00 c0 00 08 jr	a2
 1975: 	cache	29, 0(a1)
[1975] 0x900000001fc031c0:  bc bd 00 00 cache	Hit_Set_Virtual[D],0(a1)
 1976: 	jr	a2
[1976] 0x900000001fc031c4:  00 c0 00 08 jr	a2
 1977: 	cache	30, 0(a1)
[1977] 0x900000001fc031c8:  bc be 00 00 cache	Hit_Set_Virtual[SI],0(a1)
 1978: 	jr	a2
[1978] 0x900000001fc031cc:  00 c0 00 08 jr	a2
 1979: 	cache	31, 0(a1)
[1979] 0x900000001fc031d0:  bc bf 00 00 cache	Hit_Set_Virtual[SD],0(a1)
       0x900000001fc031d4:  00 00 00 00 nop
       0x900000001fc031d8:  00 00 00 00 nop
       0x900000001fc031dc:  00 00 00 00 nop
Skipping source listing to line 29 of /cores/banyan/stand/arcs/IP25prom/ccio.s...
   30:  * Arguments:
   31:  *	a0 -- Value to display on CC leds (0 - 255)
   32:  * Returns:
   33:  *	Nothing.
   34:  * Uses:
   35:  *	a0, v0.
   36:  */
   37: 
   38: LEAF(set_cc_leds)
   39: 	dli	v0, EV_LED_BASE
set_cc_leds:
[  39] 0x900000001fc031e0:  3c 02 90 00 lui	v0,0x9000
[  39] 0x900000001fc031e4:  00 02 14 38 dsll	v0,v0,16
[  39] 0x900000001fc031e8:  34 42 19 00 ori	v0,v0,0x1900
[  39] 0x900000001fc031ec:  00 02 14 38 dsll	v0,v0,16
[  39] 0x900000001fc031f0:  34 42 40 00 ori	v0,v0,0x4000
   40: 	j	ra	
[  40] 0x900000001fc031f4:  03 e0 00 08 jr	ra
   41: 	sd	a0, 0(v0)
[  41] 0x900000001fc031f8:  fc 44 00 00 sd	a0,0(v0)
   42: 	END(set_cc_leds)
   43: 
   44: 
   45: /*
   46:  * Routine flash_cc_leds
   47:  *	Causes a specific value to be flashed on the CC leds.
   48:  *	Note that this routine NEVER RETURNS.
   49:  *
   50:  * Arguments:
   51:  *	a0 -- value to be flashed.
   52:  * Never returns.
   53:  */
   54: 
   55: #ifdef	SABLE
   56: #define	DELAY_COUNTER	1
   57: #else
   58: #define	DELAY_COUNTER	0x30000
   59: #endif
   60: 
   61: LEAF(flash_cc_leds)
   62: 	jal	ccuart_flush		# Get crap out of the CC UART port
flash_cc_leds:
[  62] 0x900000001fc031fc:  0f f0 0c ea jal		ccuart_flush
   63: 	nop				# (BD)
[  63] 0x900000001fc03200:  00 00 00 00 nop
   64: 
   65: 	move	s0, a0
[  65] 0x900000001fc03204:  00 80 80 25 move	s0,a0
   66: 1:					# LOOP FOREVER 
   67: 	jal	set_cc_leds		#   Turn off the LEDS
[  67] 0x900000001fc03208:  0f f0 0c 78 jal		set_cc_leds
   68: 	move	a0, zero		#   (BD)
[  68] 0x900000001fc0320c:  00 00 20 25 move	a0,zero
   69: 	li	a0,DELAY_COUNTER	#    
[  69] 0x900000001fc03210:  3c 04 00 03 lui	a0,0x3
   70: 2: 	subu	a0, 1			#   Decrement loop count	
[  70] 0x900000001fc03214:  24 84 ff ff addiu	a0,a0,-1
   71: 	nop				# Don't want the branch in the
   72: 	nop				# same quad as the target for
   73: 	nop				# predictable branch cache behavior
[  73] 0x900000001fc03218:  00 00 00 00 nop
[  73] 0x900000001fc0321c:  00 00 00 00 nop
[  73] 0x900000001fc03220:  00 00 00 00 nop
   74: 	bne	a0,zero,2b		#   Delay 
[  74] 0x900000001fc03224:  14 80 ff fb bne	a0,zero,0x900000001fc03214
   75: 	nop
[  75] 0x900000001fc03228:  00 00 00 00 nop
   76: 
   77: 	jal	set_cc_leds		#   Turn on value in LEDS
[  77] 0x900000001fc0322c:  0f f0 0c 78 jal		set_cc_leds
   78: 	move	a0, s0			#   (BD)
[  78] 0x900000001fc03230:  02 00 20 25 move	a0,s0
   79: 	li	a0, DELAY_COUNTER
[  79] 0x900000001fc03234:  3c 04 00 03 lui	a0,0x3
   80: 3:	subu	a0, 1			#
[  80] 0x900000001fc03238:  24 84 ff ff addiu	a0,a0,-1
   81: 	nop				# Don't want the branch in the
   82: 	nop				# same quad as the target for
   83: 	nop				# predictable branch cache behavior
[  83] 0x900000001fc0323c:  00 00 00 00 nop
[  83] 0x900000001fc03240:  00 00 00 00 nop
[  83] 0x900000001fc03244:  00 00 00 00 nop
   84: 	bne	a0, zero, 3b		#   Delay
[  84] 0x900000001fc03248:  14 80 ff fb bne	a0,zero,0x900000001fc03238
   85: 	nop
[  85] 0x900000001fc0324c:  00 00 00 00 nop
   86: 
   87:         jal     ccuart_poll        	# See if a character's waiting
[  87] 0x900000001fc03250:  0f f0 0c b6 jal		ccuart_poll
   88:         nop                             # (BD)
[  88] 0x900000001fc03254:  00 00 00 00 nop
   89: 
   90:         beqz    v0, 1b                  # Was one?
[  90] 0x900000001fc03258:  10 40 ff eb beq	v0,zero,0x900000001fc03208
   91:         nop                             # (BD)
[  91] 0x900000001fc0325c:  00 00 00 00 nop
   92: 
   93:         jal     ccuart_getc             # Get it
[  93] 0x900000001fc03260:  0f f0 0c bf jal		ccuart_getc
   94:         nop                             # (BD)
[  94] 0x900000001fc03264:  00 00 00 00 nop
   95: 
   96:         li      v1, 16                  # ^P
[  96] 0x900000001fc03268:  24 03 00 10 li	v1,16
   97:         bne     v1, v0, 1b		# No, don't go into pod mode
[  97] 0x900000001fc0326c:  14 62 ff e6 bne	v1,v0,0x900000001fc03208
   98:         nop
[  98] 0x900000001fc03270:  00 00 00 00 nop
   99: 
  100: 	MESSAGE(a1,"\r\nEntering CPU board debug mode\r\n")	
[ 100] 0x900000001fc03274:  3c 05 90 00 lui	a1,0x9000
[ 100] 0x900000001fc03278:  64 a5 00 00 daddiu	a1,a1,0
[ 100] 0x900000001fc0327c:  00 05 2c 38 dsll	a1,a1,16
[ 100] 0x900000001fc03280:  64 a5 1f c1 daddiu	a1,a1,8129
[ 100] 0x900000001fc03284:  00 05 2c 38 dsll	a1,a1,16
[ 100] 0x900000001fc03288:  64 a5 77 a0 daddiu	a1,a1,30624
  101: 	jal	podMode
[ 101] 0x900000001fc0328c:  0f f0 15 fd jal		podMode
  102: 	li	a0, EVDIAG_DEBUG	# (BD)
[ 102] 0x900000001fc03290:  24 04 00 fd li	a0,253
  103: 	END(flash_cc_leds)
  104: 
  105: 
  106: /*
  107:  * Routine ccuart_init
  108:  *	Initializes the CC chip UART by writing three NULLS to
  109:  *	get it into a known state, doing a soft reset, and then
  110:  *	bringing it into ASYNCHRONOUS mode.  
  111:  * 
  112:  * Arguments:
  113:  *	None.
  114:  * Returns:
  115:  * 	Nothing.
  116:  * Uses:
  117:  *	a0, a1.
  118:  */
  119: #define		CMD	0x0
  120: #define 	DATA	0x8
  121: 
  122: LEAF(ccuart_init) 
  123: 	dli	a1, EV_UART_BASE
ccuart_init:
[ 123] 0x900000001fc03294:  3c 05 90 00 lui	a1,0x9000
[ 123] 0x900000001fc03298:  00 05 2c 38 dsll	a1,a1,16
[ 123] 0x900000001fc0329c:  34 a5 18 00 ori	a1,a1,0x1800
[ 123] 0x900000001fc032a0:  00 05 2c 38 dsll	a1,a1,16
[ 123] 0x900000001fc032a4:  34 a5 04 00 ori	a1,a1,0x400
  124: 	sd	zero, CMD(a1)		# Clear state by writing 3 zero's
[ 124] 0x900000001fc032a8:  fc a0 00 00 sd	zero,0(a1)
  125: 	nop
[ 125] 0x900000001fc032ac:  00 00 00 00 nop
  126: 	sd	zero, CMD(a1)
[ 126] 0x900000001fc032b0:  fc a0 00 00 sd	zero,0(a1)
  127: 	nop
[ 127] 0x900000001fc032b4:  00 00 00 00 nop
  128: 	sd	zero, CMD(a1)
[ 128] 0x900000001fc032b8:  fc a0 00 00 sd	zero,0(a1)
  129: 	li	a0, I8251_RESET		# Soft reset
[ 129] 0x900000001fc032bc:  24 04 00 40 li	a0,64
  130: 	sd	a0, CMD(a1)
[ 130] 0x900000001fc032c0:  fc a4 00 00 sd	a0,0(a1)
  131: 	li	a0, I8251_ASYNC16X | I8251_NOPAR | I8251_8BITS | I8251_STOPB2
[ 131] 0x900000001fc032c4:  24 04 00 ce li	a0,206
  132: 	sd	a0, CMD(a1)
[ 132] 0x900000001fc032c8:  fc a4 00 00 sd	a0,0(a1)
  133: 	li	a0, I8251_TXENB | I8251_RXENB | I8251_RESETERR
[ 133] 0x900000001fc032cc:  24 04 00 15 li	a0,21
  134: 	j	ra 
[ 134] 0x900000001fc032d0:  03 e0 00 08 jr	ra
  135: 	sd	a0, CMD(a1)		# (BD)
[ 135] 0x900000001fc032d4:  fc a4 00 00 sd	a0,0(a1)
  136: 	END(ccuart_init)
  137: 
  138: 
  139: /*
  140:  * Routine ccuart_poll 
  141:  *	Poll the CC UART to see if a charactre is available
  142:  *
  143:  * Arguments:
  144:  * 	None.
  145:  * Returns:
  146:  *	v0 -- Nonzero if a character is available, zero otherwise
  147:  * Uses:
  148:  *	v0.
  149:  */
  150: 
  151: LEAF(ccuart_poll) 
  152: 	dli	v0, EV_UART_BASE
ccuart_poll:
[ 152] 0x900000001fc032d8:  3c 02 90 00 lui	v0,0x9000
[ 152] 0x900000001fc032dc:  00 02 14 38 dsll	v0,v0,16
[ 152] 0x900000001fc032e0:  34 42 18 00 ori	v0,v0,0x1800
[ 152] 0x900000001fc032e4:  00 02 14 38 dsll	v0,v0,16
[ 152] 0x900000001fc032e8:  34 42 04 00 ori	v0,v0,0x400
  153: 	ld	v0, CMD(v0) 		#   Get status bit
[ 153] 0x900000001fc032ec:  dc 42 00 00 ld	v0,0(v0)
  154: 	nop
[ 154] 0x900000001fc032f0:  00 00 00 00 nop
  155: 	j	ra
[ 155] 0x900000001fc032f4:  03 e0 00 08 jr	ra
  156: 	andi	v0, I8251_RXRDY
[ 156] 0x900000001fc032f8:  30 42 00 02 andi	v0,v0,0x2
  157: 	END(ccuart_poll)
  158: 
  159: 
  160: /*
  161:  * Routine ccuart_getc
  162:  *	Reads a single character from the CC UART.
  163:  *
  164:  * Arguments:
  165:  * 	None.
  166:  * Returns:
  167:  *	v0 -- The character read.  
  168:  * Uses:
  169:  *	a0, a1, a2, v0, v1.
  170:  */
  171: 
  172: LEAF(ccuart_getc)
  173: 	dli	v1, EV_UART_BASE
ccuart_getc:
[ 173] 0x900000001fc032fc:  3c 03 90 00 lui	v1,0x9000
[ 173] 0x900000001fc03300:  00 03 1c 38 dsll	v1,v1,16
[ 173] 0x900000001fc03304:  34 63 18 00 ori	v1,v1,0x1800
[ 173] 0x900000001fc03308:  00 03 1c 38 dsll	v1,v1,16
[ 173] 0x900000001fc0330c:  34 63 04 00 ori	v1,v1,0x400
  174: 	li	a1, 1
[ 174] 0x900000001fc03310:  24 05 00 01 li	a1,1
  175: 	move	a2, ra
[ 175] 0x900000001fc03314:  03 e0 30 25 move	a2,ra
  176: 1:
  177: 	li	a0, 200000
[ 177] 0x900000001fc03318:  3c 04 00 03 lui	a0,0x3
[ 177] 0x900000001fc0331c:  34 84 0d 40 ori	a0,a0,0xd40
  178: 2:					# 
  179: 	ld	v0, CMD(v1) 		# DO 
[ 179] 0x900000001fc03320:  dc 62 00 00 ld	v0,0(v1)
  180: 	nop
[ 180] 0x900000001fc03324:  00 00 00 00 nop
  181: 	andi	v0, I8251_RXRDY			
[ 181] 0x900000001fc03328:  30 42 00 02 andi	v0,v0,0x2
  182: 	bne	v0, zero, 20f		# WHILE (not ready && 
[ 182] 0x900000001fc0332c:  14 40 00 08 bne	v0,zero,0x900000001fc03350
  183: 	nop				# (BD)
[ 183] 0x900000001fc03330:  00 00 00 00 nop
  184: 	sub	a0, 1			# (BD)
[ 184] 0x900000001fc03334:  20 84 ff ff addi	a0,a0,-1
  185: 	bnez	a0, 2b			# 	 i-- > 0)
[ 185] 0x900000001fc03338:  14 80 ff f9 bne	a0,zero,0x900000001fc03320
  186: 	nop
[ 186] 0x900000001fc0333c:  00 00 00 00 nop
  187: 	
  188: 	jal	set_cc_leds
[ 188] 0x900000001fc03340:  0f f0 0c 78 jal		set_cc_leds
  189: 	xor	a0, a1, 3		# (BD) 
[ 189] 0x900000001fc03344:  38 a4 00 03 xori	a0,a1,0x3
  190: 	j	1b			# Jump back to the get char loop
[ 190] 0x900000001fc03348:  0b f0 0c c6 j		(ccuart_getc+28)
  191: 	xor	a1, 3				# (BD)
[ 191] 0x900000001fc0334c:  38 a5 00 03 xori	a1,a1,0x3
  192: 20:
  193: 	j	a2			# Return 
[ 193] 0x900000001fc03350:  00 c0 00 08 jr	a2
  194: 	ld	v0, DATA(v1)		# (BD) Read character from register
[ 194] 0x900000001fc03354:  dc 62 00 08 ld	v0,8(v1)
  195: 	
  196: END(ccuart_getc)
  197: 
  198: 
  199: /*
  200:  * Routine ccuart_putc
  201:  * 	Writes a single character to the CC UART.
  202:  *
  203:  * Arguments:
  204:  *	a0 -- ASCII value of character to be written
  205:  * Returns:
  206:  *	v0 -- If non-zero, putc succeeded.
  207:  * Uses:
  208:  *	a0, a1, v0, v1	
  209:  */
  210: 
  211: LEAF(ccuart_putc)
  212: 	dli	a1, EV_UART_BASE
ccuart_putc:
[ 212] 0x900000001fc03358:  3c 05 90 00 lui	a1,0x9000
[ 212] 0x900000001fc0335c:  00 05 2c 38 dsll	a1,a1,16
[ 212] 0x900000001fc03360:  34 a5 18 00 ori	a1,a1,0x1800
[ 212] 0x900000001fc03364:  00 05 2c 38 dsll	a1,a1,16
[ 212] 0x900000001fc03368:  34 a5 04 00 ori	a1,a1,0x400
  213: 	li	v0, 2000000
[ 213] 0x900000001fc0336c:  3c 02 00 1e lui	v0,0x1e
[ 213] 0x900000001fc03370:  34 42 84 80 ori	v0,v0,0x8480
  214: 1:					# DO
  215: 	ld	v1, CMD(a1)		#   Get status register
[ 215] 0x900000001fc03374:  dc a3 00 00 ld	v1,0(a1)
  216: 	nop
[ 216] 0x900000001fc03378:  00 00 00 00 nop
  217: 	andi	v1, I8251_TXRDY		# UNTIL ready to transmit 
[ 217] 0x900000001fc0337c:  30 63 00 01 andi	v1,v1,0x1
  218: 	bne	v1, zero, 2f	 	# OR
[ 218] 0x900000001fc03380:  14 60 00 06 bne	v1,zero,0x900000001fc0339c
  219: 	nop
[ 219] 0x900000001fc03384:  00 00 00 00 nop
  220: 	subu	v0, 1			# (BD) (--cnt == 0)
[ 220] 0x900000001fc03388:  24 42 ff ff addiu	v0,v0,-1
  221: 	bne	v0, zero, 1b
[ 221] 0x900000001fc0338c:  14 40 ff f9 bne	v0,zero,0x900000001fc03374
  222: 	nop
[ 222] 0x900000001fc03390:  00 00 00 00 nop
  223: 	j	ra			# paranoid return without storing
[ 223] 0x900000001fc03394:  03 e0 00 08 jr	ra
  224: 	nop
[ 224] 0x900000001fc03398:  00 00 00 00 nop
  225: 2:
  226: 	sd	a0, DATA(a1)		# (BD) Write char into xmit buf
[ 226] 0x900000001fc0339c:  fc a4 00 08 sd	a0,8(a1)
  227: 	j	ra
[ 227] 0x900000001fc033a0:  03 e0 00 08 jr	ra
  228: 	nop
[ 228] 0x900000001fc033a4:  00 00 00 00 nop
  229: 	END(ccuart_putc)
  230: 
  231: 
  232: /*
  233:  * Routine ccuart_flush
  234:  *	Flushes the input buffer of the UART.
  235:  *
  236:  * Arguments:
  237:  *	None.
  238:  * Returns:
  239:  *	Nothing.
  240:  * Uses:
  241:  *	v0, v1.
  242:  */
  243: 
  244: LEAF(ccuart_flush)
  245: 	dli	v0, EV_UART_BASE	
ccuart_flush:
[ 245] 0x900000001fc033a8:  3c 02 90 00 lui	v0,0x9000
[ 245] 0x900000001fc033ac:  00 02 14 38 dsll	v0,v0,16
[ 245] 0x900000001fc033b0:  34 42 18 00 ori	v0,v0,0x1800
[ 245] 0x900000001fc033b4:  00 02 14 38 dsll	v0,v0,16
[ 245] 0x900000001fc033b8:  34 42 04 00 ori	v0,v0,0x400
  246: 	ld	v1, CMD(v0)		# Read status bits
[ 246] 0x900000001fc033bc:  dc 43 00 00 ld	v1,0(v0)
  247: 	and	v1, I8251_RXRDY		# IF character available
[ 247] 0x900000001fc033c0:  30 63 00 02 andi	v1,v1,0x2
  248: 	beq	v1, zero, 1f		# THEN
[ 248] 0x900000001fc033c4:  10 60 00 03 beq	v1,zero,0x900000001fc033d4
  249: 	nop
[ 249] 0x900000001fc033c8:  00 00 00 00 nop
  250: 	ld	zero, DATA(v0)		#   read character
[ 250] 0x900000001fc033cc:  dc 40 00 08 ld	zero,8(v0)
  251: 	nop
[ 251] 0x900000001fc033d0:  00 00 00 00 nop
  252: 1:					# ENDIF
  253: 	j	ra
[ 253] 0x900000001fc033d4:  03 e0 00 08 jr	ra
  254: 	nop 
[ 254] 0x900000001fc033d8:  00 00 00 00 nop
  255: 	END(ccuart_flush)
  256: 
  257: 	
  258: /* 
  259:  * Routine ccuart_puthex
  260:  *	Writes a 64-bit hexadecimal value to the CC UART.
  261:  *
  262:  * Arguments:
  263:  *	a0 -- the 64-bit hex number to write.
  264:  * Returns:
  265:  *	v0 -- Success.  Non-zero indicates write successful.
  266:  * Uses:
  267:  *	a0, a1, v0, v1, ta1, ta2, ta3, t8, t9	
  268:  */
  269: 
  270: LEAF(ccuart_puthex)
  271: 	move    t9, ra
ccuart_puthex:
[ 271] 0x900000001fc033dc:  03 e0 c8 25 move	t9,ra
  272: 	jal	getendian
[ 272] 0x900000001fc033e0:  0f f0 0d d0 jal		getendian
  273: 	li      t8, 16		# Number of digits to display (BD)
[ 273] 0x900000001fc033e4:  24 18 00 10 li	t8,16
  274: 	move	ta2, v0		# Copy endianness to ta2
[ 274] 0x900000001fc033e8:  00 40 50 25 move	a6,v0
  275: 	move	ta1, a0		# Copy argument to ta1
[ 275] 0x900000001fc033ec:  00 80 48 25 move	a5,a0
  276: 2:
  277: 	dsrl	a0,ta1,30	# Rotate right 60 bits ($@!&*# assembler
[ 277] 0x900000001fc033f0:  00 09 27 ba dsrl	a0,a5,30
  278: 	dsrl	a0,a0,30 	# 	won't assemble srl32 a0,ta1,28)
[ 278] 0x900000001fc033f4:  00 04 27 ba dsrl	a0,a0,30
  279: 				# This isolates the rightmost nibble
  280: 	dla	ta3,hexdigit
[ 280] 0x900000001fc033f8:  3c 0b 90 00 lui	a7,0x9000
[ 280] 0x900000001fc033fc:  65 6b 00 00 daddiu	a7,a7,0
[ 280] 0x900000001fc03400:  00 0b 5c 38 dsll	a7,a7,16
[ 280] 0x900000001fc03404:  65 6b 1f c1 daddiu	a7,a7,8129
[ 280] 0x900000001fc03408:  00 0b 5c 38 dsll	a7,a7,16
[ 280] 0x900000001fc0340c:  65 6b 77 c8 daddiu	a7,a7,30664
  281: 	daddu	a0,ta3		# (BD)
[ 281] 0x900000001fc03410:  00 8b 20 2d daddu	a0,a0,a7
  282: 	beq     ta2,zero,3f	# 0 = big endian
[ 282] 0x900000001fc03414:  11 40 00 02 beq	a6,zero,0x900000001fc03420
  283: 	nop
[ 283] 0x900000001fc03418:  00 00 00 00 nop
  284: 	xor     a0,3		# assumes hexdigit burned in prom in eb order
[ 284] 0x900000001fc0341c:  38 84 00 03 xori	a0,a0,0x3
  285: 3:
  286: 	jal	get_char 
[ 286] 0x900000001fc03420:  0f f0 0d 88 jal		get_char
  287: 	nop			# (BD)
[ 287] 0x900000001fc03424:  00 00 00 00 nop
  288: 	jal     ccuart_putc	# Print it
[ 288] 0x900000001fc03428:  0f f0 0c d6 jal		ccuart_putc
  289: 	move	a0, v0		# (BD)
[ 289] 0x900000001fc0342c:  00 40 20 25 move	a0,v0
  290: 
  291: 	sub     t8,1		# (BD) Entire number printed?
[ 291] 0x900000001fc03430:  23 18 ff ff addi	t8,t8,-1
  292: 	beqz	v0, 4f		# If putc fails, give up on the number.
[ 292] 0x900000001fc03434:  10 40 00 04 beq	v0,zero,0x900000001fc03448
  293: 	nop
[ 293] 0x900000001fc03438:  00 00 00 00 nop
  294: 	
  295: 	dsll	ta1,4		# Set up next nibble
[ 295] 0x900000001fc0343c:  00 09 49 38 dsll	a5,a5,4
  296: 	bne     t8,zero,2b
[ 296] 0x900000001fc03440:  17 00 ff eb bne	t8,zero,0x900000001fc033f0
  297: 	nop
[ 297] 0x900000001fc03444:  00 00 00 00 nop
  298: 4:
  299: 	j       t9		# Yes - done
[ 299] 0x900000001fc03448:  03 20 00 08 jr	t9
  300: 	nop
[ 300] 0x900000001fc0344c:  00 00 00 00 nop
  301: 	END(ccuart_puthex)
  302: 
  303: 
  304: /*
  305:  * Routine ccuart_puts
  306:  *	Writes a null-terminated string to the CC UART.
  307:  *
  308:  * Arguments:
  309:  *	a0 -- the address of the first character of the string.
  310:  * Returns:
  311:  *	v0 -- If non-zero, puts (probably) succeeded.  If zero,
  312:  *	      puts definitely failed. 
  313:  * Uses:
  314:  *	a0, a1, v0, v1, ta2, ta3, t8, t9
  315:  */
  316: 
  317: LEAF(ccuart_puts)
  318: 	.set	noreorder
  319: 	move	t9, ra			# Save the return address
ccuart_puts:
[ 319] 0x900000001fc03450:  03 e0 c8 25 move	t9,ra
  320: 	move	ta3, a0			# Save the argument register
[ 320] 0x900000001fc03454:  00 80 58 25 move	a7,a0
  321: 
  322: 	jal	getendian		# Get endianess
[ 322] 0x900000001fc03458:  0f f0 0d d0 jal		getendian
  323: 	nop	
[ 323] 0x900000001fc0345c:  00 00 00 00 nop
  324: 	move	t8, v0			# Put endianess in t8
[ 324] 0x900000001fc03460:  00 40 c0 25 move	t8,v0
  325: 1:
  326:         move    ta2, ta3  		# (BD) Copy next_char to curr_char
[ 326] 0x900000001fc03464:  01 60 50 25 move	a6,a7
  327:         beq     t8, zero, 2f		# Skip to write char if big-endian
[ 327] 0x900000001fc03468:  13 00 00 02 beq	t8,zero,0x900000001fc03474
  328: 	nop
[ 328] 0x900000001fc0346c:  00 00 00 00 nop
  329:         xor     ta2, 3			# If EL, swizzle the bits
[ 329] 0x900000001fc03470:  39 4a 00 03 xori	a6,a6,0x3
  330: 2:     
  331: 	jal	get_char 
[ 331] 0x900000001fc03474:  0f f0 0d 88 jal		get_char
  332: 	move	a0, ta2
[ 332] 0x900000001fc03478:  01 40 20 25 move	a0,a6
  333: 	move	a0, v0
[ 333] 0x900000001fc0347c:  00 40 20 25 move	a0,v0
  334:         daddiu	ta3, 1			# Increment next char. 
[ 334] 0x900000001fc03480:  65 6b 00 01 daddiu	a7,a7,1
  335:         beq     a0, zero, 3f		# If char == zero, return
[ 335] 0x900000001fc03484:  10 80 00 07 beq	a0,zero,0x900000001fc034a4
  336:         nop				# (BD)
[ 336] 0x900000001fc03488:  00 00 00 00 nop
  337: 
  338:         jal     ccuart_putc		# 
[ 338] 0x900000001fc0348c:  0f f0 0c d6 jal		ccuart_putc
  339:         nop				# (BD)
[ 339] 0x900000001fc03490:  00 00 00 00 nop
  340: 
  341: 	beqz	v0, 3f			# If putc fails, give up on the string
[ 341] 0x900000001fc03494:  10 40 00 03 beq	v0,zero,0x900000001fc034a4
  342: 	nop				# (BD)
[ 342] 0x900000001fc03498:  00 00 00 00 nop
  343: 
  344:         b       1b			# Loop back up
[ 344] 0x900000001fc0349c:  10 00 ff f1 b		0x900000001fc03464
  345:         nop				# (BD)
[ 345] 0x900000001fc034a0:  00 00 00 00 nop
  346: 3:
  347: 	
  348:         j       t9			# Return
[ 348] 0x900000001fc034a4:  03 20 00 08 jr	t9
  349:         nop				# (BD)
[ 349] 0x900000001fc034a8:  00 00 00 00 nop
       0x900000001fc034ac:  00 00 00 00 nop
Skipping source listing to line 28 of /cores/banyan/stand/arcs/IP25prom/libasm.s...
   29: /*
   30:  * Function:	initCPUSpeed
   31:  * Purpose: 	Determines the speed of the current in MHz.
   32:  * Parameters:	none
   33:  * Returns:	Nothing
   34:  */
   35: #if	!defined(SABLE)
   36:         .set	noreorder
   37: #       define	NSEC_PER_SEC	1000000000 /* nano-seconds per second */
   38:         dli	a0,EV_RTC
initCPUSpeed:
[  38] 0x900000001fc034b0:  3c 04 90 00 lui	a0,0x9000
[  38] 0x900000001fc034b4:  00 04 24 38 dsll	a0,a0,16
[  38] 0x900000001fc034b8:  34 84 18 02 ori	a0,a0,0x1802
[  38] 0x900000001fc034bc:  00 04 24 38 dsll	a0,a0,16
[  38] 0x900000001fc034c0:  34 84 00 00 ori	a0,a0,0
   39:         ld	a1,0(a0)
[  39] 0x900000001fc034c4:  dc 85 00 00 ld	a1,0(a0)
   40:         daddu	a1,CYCLE_PER_SEC/8	/* about 1/8 secs should be good */
[  40] 0x900000001fc034c8:  3c 01 00 5a lui	at,0x5a
[  40] 0x900000001fc034cc:  34 21 d3 7c ori	at,at,0xd37c
[  40] 0x900000001fc034d0:  00 a1 28 2d daddu	a1,a1,at
   41:         MTC0(zero, C0_COUNT)		/* Start counting */
[  41] 0x900000001fc034d4:  40 80 48 00 mtc0	zero,count
   42: 1:
   43:         ld	v0,0(a0)		/* Watch it count ... */
[  43] 0x900000001fc034d8:  dc 82 00 00 ld	v0,0(a0)
   44:         blt	v0,a1,1b
[  44] 0x900000001fc034dc:  00 45 08 2a slt	at,v0,a1
[  44] 0x900000001fc034e0:  14 20 ff fd bne	at,zero,0x900000001fc034d8
   45:         nop
[  45] 0x900000001fc034e4:  00 00 00 00 nop
   46:         MFC0(v0, C0_COUNT)		/* Pick up new count */
[  46] 0x900000001fc034e8:  40 02 48 00 mfc0	v0,count
   47: 
   48:         /*
   49: 	 * Now multiply by 8 (<< 3) to get number of count register
   50: 	 * tics per second, each of which corresponds to 2 processor
   51: 	 * clocks. Divide by 1 MHz to get MHz / 2. This leaves 
   52: 	 * the computation at (X << 3) / 1000000. We store MHz/2 to
   53: 	 * allow a 300MHz number to fit in the same "byte" field.
   54: 	 */
   55: 	dsll	v0,3
[  55] 0x900000001fc034ec:  00 02 10 f8 dsll	v0,v0,3
   56: 	ddivu	v0,1000000
[  56] 0x900000001fc034f0:  3c 01 00 0f lui	at,0xf
[  56] 0x900000001fc034f4:  34 21 42 40 ori	at,at,0x4240
[  56] 0x900000001fc034f8:  00 41 00 1f ddivu	v0,at
[  56] 0x900000001fc034fc:  14 20 00 02 bne	at,zero,0x900000001fc03508
[  56] 0x900000001fc03500:  00 00 00 21 nada
[  56] 0x900000001fc03504:  00 07 00 0d break	0x7
[  56] 0x900000001fc03508:  00 00 10 12 mflo	v0
   57: 	mflo	v0
[  57] 0x900000001fc0350c:  00 00 10 12 mflo	v0
   58:         j	ra
[  58] 0x900000001fc03510:  03 e0 00 08 jr	ra
   59:         nop
[  59] 0x900000001fc03514:  00 00 00 00 nop
   60:         .set	reorder
   61: #else
   62: 	j	ra
   63: 	ori	v0,zero,100
   64: #endif
   65:         END(initCPUSpeed)
   66: 
   67: LEAF(getHexChar)
   68: /*
   69:  * Function:	getHexChar
   70:  * Purpose:	Convert binary hex to hex character.
   71:  * Parameters:	a0 - Binary number
   72:  * Returns:	v0 - Character representing lower 4-bits of a0.
   73:  */
   74: 	.set	noreorder
   75: 	and	a0,0xf		/* Isolate character */
getHexChar:
[  75] 0x900000001fc03518:  30 84 00 0f andi	a0,a0,0xf
   76: 	bgt	a0,9,1f		/* Check for character */
[  76] 0x900000001fc0351c:  28 81 00 0a slti	at,a0,10
[  76] 0x900000001fc03520:  10 20 00 03 beq	at,zero,0x900000001fc03530
   77: 	nop
[  77] 0x900000001fc03524:  00 00 00 00 nop
   78: 	jr	ra
[  78] 0x900000001fc03528:  03 e0 00 08 jr	ra
   79: 	add	v0,a0,0x30	/* + '0' */
[  79] 0x900000001fc0352c:  20 82 00 30 addi	v0,a0,48
   80: 1:	jr	ra
[  80] 0x900000001fc03530:  03 e0 00 08 jr	ra
   81: 	add	v0,a0,0x61-0xa	/* + 'a' */
[  81] 0x900000001fc03534:  20 82 00 57 addi	v0,a0,87
   82: 	END(getHexChar)
   83: 
   84: /*
   85:  * load_lwin_half
   86:  * load_lwin_word
   87:  *	Given a region index, these routines read either a halfword or
   88:  * 	a word from the given large window.  They are used primarily
   89:  *	for manipulating the flash eprom.
   90:  * 
   91:  * On entry:
   92:  *	a0 = region #.
   93:  *	a1 = offset within region.
   94:  */
   95: 
   96: LEAF(load_lwin_half)
   97: 	.set 	noreorder
   98: 	daddi	a0, 0x10	# Convert to physical offset
load_lwin_half:
[  98] 0x900000001fc03538:  60 84 00 10 daddi	a0,a0,16
   99: 	dsll	a0, 30		# Shift it up
[  99] 0x900000001fc0353c:  00 04 27 b8 dsll	a0,a0,30
  100: 	dadd	a0, a1		# Merge in the offset
[ 100] 0x900000001fc03540:  00 85 20 2c dadd	a0,a0,a1
  101: 	lui	a1, 0x9000
[ 101] 0x900000001fc03544:  3c 05 90 00 lui	a1,0x9000
  102: 	dsll	a1, 32		# Build the uncached xkphys address
[ 102] 0x900000001fc03548:  00 05 28 3c dsll32	a1,a1,0
  103: 	dadd	a0, a1		# Make LWIN into a real address
[ 103] 0x900000001fc0354c:  00 85 20 2c dadd	a0,a0,a1
  104: 	j	ra		# Return
[ 104] 0x900000001fc03550:  03 e0 00 08 jr	ra
  105: 	lhu	v0, 0(a0)	# (BD) Perform the actual read
[ 105] 0x900000001fc03554:  94 82 00 00 lhu	v0,0(a0)
  106: 	END(load_lwin_half)
  107: 
  108: LEAF(load_lwin_word)
  109: 	.set	noreorder
  110: 	daddi	a0, 0x10	# Convert to physical offset
load_lwin_word:
[ 110] 0x900000001fc03558:  60 84 00 10 daddi	a0,a0,16
  111: 	dsll	a0, 30		# Shift it up
[ 111] 0x900000001fc0355c:  00 04 27 b8 dsll	a0,a0,30
  112: 	dadd	a0, a1		# Merge in the offset
[ 112] 0x900000001fc03560:  00 85 20 2c dadd	a0,a0,a1
  113: 	lui	a1, 0x9000
[ 113] 0x900000001fc03564:  3c 05 90 00 lui	a1,0x9000
  114: 	dsll	a1, 32		# Build the uncached xkphys address
[ 114] 0x900000001fc03568:  00 05 28 3c dsll32	a1,a1,0
  115: 	dadd	a0, a1		# Make LWIN into a real address
[ 115] 0x900000001fc0356c:  00 85 20 2c dadd	a0,a0,a1
  116: 	j	ra
[ 116] 0x900000001fc03570:  03 e0 00 08 jr	ra
  117: 	lw	v0, 0(a0)
[ 117] 0x900000001fc03574:  8c 82 00 00 lw	v0,0(a0)
  118: 	END(load_lwin_word)
  119: 
  120: /*
  121:  * Same as above, but also stores at a2 for a3 counts.
  122:  * Returns checksum.
  123:  * For fast IO4prom copy.
  124:  */
  125: LEAF(load_lwin_half_store_mult)
  126: 	.set 	noreorder
  127: 	move	v0, zero	# init checksum
load_lwin_half_store_mult:
[ 127] 0x900000001fc03578:  00 00 10 25 move	v0,zero
  128: 	daddi	a0, 0x10	# Convert to physical offset
[ 128] 0x900000001fc0357c:  60 84 00 10 daddi	a0,a0,16
  129: 	dsll	a0, 30		# Shift it up
[ 129] 0x900000001fc03580:  00 04 27 b8 dsll	a0,a0,30
  130: 	dadd	a0, a1		# Merge in the offset
[ 130] 0x900000001fc03584:  00 85 20 2c dadd	a0,a0,a1
  131: 	lui	a4, 0x9000
[ 131] 0x900000001fc03588:  3c 08 90 00 lui	a4,0x9000
  132: 	dsll	a4, 32		# Build the uncached xkphys address
[ 132] 0x900000001fc0358c:  00 08 40 3c dsll32	a4,a4,0
  133: 	dadd	a0, a4		# Make LWIN into a real address
[ 133] 0x900000001fc03590:  00 88 20 2c dadd	a0,a0,a4
  134: 1:
  135: 	lhu	t0, 0(a0)	# Perform the actual read
[ 135] 0x900000001fc03594:  94 8c 00 00 lhu	t0,0(a0)
  136: 	sh	t0, 0(a2)	# Perform the actual write
[ 136] 0x900000001fc03598:  a4 cc 00 00 sh	t0,0(a2)
  137: 	addu	v0, t0
[ 137] 0x900000001fc0359c:  00 4c 10 21 addu	v0,v0,t0
  138: 	daddi	a0, 2		# next short
[ 138] 0x900000001fc035a0:  60 84 00 02 daddi	a0,a0,2
  139: 	addi	a3, -2		# decrement count
[ 139] 0x900000001fc035a4:  20 e7 ff fe addi	a3,a3,-2
  140: 	daddi	a2, 2		# (BD) next short
[ 140] 0x900000001fc035a8:  60 c6 00 02 daddi	a2,a2,2
  141: 	bgt	a3, 0, 1b	# loop if not done
[ 141] 0x900000001fc035ac:  1c e0 ff f9 bgtz	a3,0x900000001fc03594
  142: 	nop
[ 142] 0x900000001fc035b0:  00 00 00 00 nop
  143: 	j	ra		# Return
[ 143] 0x900000001fc035b4:  03 e0 00 08 jr	ra
  144: 	nop
[ 144] 0x900000001fc035b8:  00 00 00 00 nop
  145: 	END(load_lwin_half_store_mult)
  146: 
  147: /*
  148:  * store_lwin_half
  149:  * store_lwin_word
  150:  *	Given the region of a large window, this routine writes a
  151:  *	halfword to an offset in the large window.  Used primarily
  152:  *	for manipulating the flash eprom.
  153:  *
  154:  * On entry:
  155:  *	a0 = region #.
  156:  *	a1 = offset.
  157:  *	a2 = value to write.
  158:  */
  159: 
  160: LEAF(store_lwin_half)
  161: 	.set	noreorder
  162: 	daddi	a0, 0x10
store_lwin_half:
[ 162] 0x900000001fc035bc:  60 84 00 10 daddi	a0,a0,16
  163: 	dsll	a0, 30
[ 163] 0x900000001fc035c0:  00 04 27 b8 dsll	a0,a0,30
  164: 	dadd	a0, a1
[ 164] 0x900000001fc035c4:  00 85 20 2c dadd	a0,a0,a1
  165: 	lui	a1, 0x9000
[ 165] 0x900000001fc035c8:  3c 05 90 00 lui	a1,0x9000
  166: 	dsll	a1, 32
[ 166] 0x900000001fc035cc:  00 05 28 3c dsll32	a1,a1,0
  167: 	dadd	a0, a1
[ 167] 0x900000001fc035d0:  00 85 20 2c dadd	a0,a0,a1
  168: 	j	ra
[ 168] 0x900000001fc035d4:  03 e0 00 08 jr	ra
  169: 	sh	a2, 0(a0)
[ 169] 0x900000001fc035d8:  a4 86 00 00 sh	a2,0(a0)
  170: 	END(store_lwin_half)
  171: 
  172: LEAF(store_lwin_word)
  173: 	.set	noreorder
  174: 	daddi	a0, 0x10
store_lwin_word:
[ 174] 0x900000001fc035dc:  60 84 00 10 daddi	a0,a0,16
  175: 	dsll	a0, 30
[ 175] 0x900000001fc035e0:  00 04 27 b8 dsll	a0,a0,30
  176: 	dadd	a0, a1
[ 176] 0x900000001fc035e4:  00 85 20 2c dadd	a0,a0,a1
  177: 	lui	a1, 0x9000
[ 177] 0x900000001fc035e8:  3c 05 90 00 lui	a1,0x9000
  178: 	dsll	a1, 32
[ 178] 0x900000001fc035ec:  00 05 28 3c dsll32	a1,a1,0
  179: 	dadd	a0, a1
[ 179] 0x900000001fc035f0:  00 85 20 2c dadd	a0,a0,a1
  180: 	j	ra
[ 180] 0x900000001fc035f4:  03 e0 00 08 jr	ra
  181: 	sw	a2, 0(a0)
[ 181] 0x900000001fc035f8:  ac 86 00 00 sw	a2,0(a0)
  182: 	END(store_lwin_word)
  183: 
  184: /*
  185:  * store_load_lwin_word
  186:  *	Given the region of a large window, this routine writes a
  187:  *	word to an offset in the large window and then reads it
  188:  *	back. Used for speeding up the POD tests.
  189:  *
  190:  * On entry:
  191:  *	a0 = region #.
  192:  *	a1 = offset.
  193:  *	a2 = value to write.
  194:  */
  195: 
  196: LEAF(store_load_lwin_word)
  197: 	.set	noreorder
  198: 	daddi	a0, 0x10
store_load_lwin_word:
[ 198] 0x900000001fc035fc:  60 84 00 10 daddi	a0,a0,16
  199: 	dsll	a0, 30
[ 199] 0x900000001fc03600:  00 04 27 b8 dsll	a0,a0,30
  200: 	dadd	a0, a1
[ 200] 0x900000001fc03604:  00 85 20 2c dadd	a0,a0,a1
  201: 	lui	a1, 0x9000
[ 201] 0x900000001fc03608:  3c 05 90 00 lui	a1,0x9000
  202: 	dsll	a1, 32
[ 202] 0x900000001fc0360c:  00 05 28 3c dsll32	a1,a1,0
  203: 	dadd	a0, a1
[ 203] 0x900000001fc03610:  00 85 20 2c dadd	a0,a0,a1
  204: 	sw	a2, 0(a0)
[ 204] 0x900000001fc03614:  ac 86 00 00 sw	a2,0(a0)
  205: 	j	ra
[ 205] 0x900000001fc03618:  03 e0 00 08 jr	ra
  206: 	lw	v0, 0(a0)
[ 206] 0x900000001fc0361c:  8c 82 00 00 lw	v0,0(a0)
  207: 	END(store_load_lwin_word)
  208: 
  209: /*
  210:  * Routine get_char
  211:  * 	Given an address, returns the character at that
  212:  *	address.
  213:  */
  214: 
  215: LEAF(get_char)
  216:         MFC0(v0, C0_CONFIG)
get_char:
[ 216] 0x900000001fc03620:  40 02 80 00 mfc0	v0,config
  217:         dsrl    v0, CONFIG_BE_SHFT	# shift BE to bit position 0	
[ 217] 0x900000001fc03624:  00 02 13 fa dsrl	v0,v0,15
  218:         and     v0, 1
[ 218] 0x900000001fc03628:  30 42 00 01 andi	v0,v0,0x1
  219: 	beqz	v0, 1f
[ 219] 0x900000001fc0362c:  10 40 00 04 beq	v0,zero,0x900000001fc03640
  220: 	nop
[ 220] 0x900000001fc03630:  00 00 00 00 nop
  221: 	lwr	v0, 0(a0)		# Read the byte (big endian)
[ 221] 0x900000001fc03634:  98 82 00 00 lwr	v0,0(a0)
  222: 	j	ra
[ 222] 0x900000001fc03638:  03 e0 00 08 jr	ra
  223: 	and	v0, 0xff		# (BD) Mask out rest of word 	
[ 223] 0x900000001fc0363c:  30 42 00 ff andi	v0,v0,0xff
  224: 1:
  225: 	lwl	v0, 0(a0)		# Read the byte (little endian)
[ 225] 0x900000001fc03640:  88 82 00 00 lwl	v0,0(a0)
  226: 	dsrl	v0, 24			# Shift the byte into place
[ 226] 0x900000001fc03644:  00 02 16 3a dsrl	v0,v0,24
  227: 	j	ra			
[ 227] 0x900000001fc03648:  03 e0 00 08 jr	ra
  228: 	and	v0, 0xff		# (BD) Mask out rest of word 	
[ 228] 0x900000001fc0364c:  30 42 00 ff andi	v0,v0,0xff
  229: 	END(get_char)
  230: 
  231: LEAF(set_BSR)
  232: 	.set noreorder
  233: 	DMTBR(a0, BR_BSR)
set_BSR:
[ 233] 0x900000001fc03650:  44 a4 00 00 dmtc1	a0,$f0
  234: 	j	ra
[ 234] 0x900000001fc03654:  03 e0 00 08 jr	ra
  235: 	nop
[ 235] 0x900000001fc03658:  00 00 00 00 nop
  236: 	END(set_BSR)
  237: 
  238: LEAF(get_BSR)
  239: 	.set noreorder
  240: 	DMFBR(v0, BR_BSR)
get_BSR:
[ 240] 0x900000001fc0365c:  44 22 00 00 dmfc1	v0,$f0
  241: 	j	ra
[ 241] 0x900000001fc03660:  03 e0 00 08 jr	ra
  242: 	nop
[ 242] 0x900000001fc03664:  00 00 00 00 nop
  243: 	END(get_BSR)
  244: 
  245: LEAF(get_ERTOIP)
  246: 	.set noreorder
  247: 	j	ra
get_ERTOIP:
[ 247] 0x900000001fc03668:  03 e0 00 08 jr	ra
  248: 	DMFBR(v0, BR_ERTOIP)
[ 248] 0x900000001fc0366c:  44 22 20 00 dmfc1	v0,$f4
  249: 	.set	reorder
  250: 	END(get_ERTOIP)
  251: 
  252: LEAF(set_ERTOIP)
  253: 	.set noreorder
  254: 	j	ra
set_ERTOIP:
[ 254] 0x900000001fc03670:  03 e0 00 08 jr	ra
  255: 	DMTBR(a0, BR_ERTOIP)
[ 255] 0x900000001fc03674:  44 a4 20 00 dmtc1	a0,$f4
  256: 	.set	reorder
  257: 	END(set_ERTOIP)	
  258: 
  259: LEAF(set_epcuart_base)
  260: 	.set noreorder
  261: 	DMTBR(a0, BR_DUARTBASE)
set_epcuart_base:
[ 261] 0x900000001fc03678:  44 a4 18 00 dmtc1	a0,$f3
  262: 	j	ra
[ 262] 0x900000001fc0367c:  03 e0 00 08 jr	ra
  263: 	nop
[ 263] 0x900000001fc03680:  00 00 00 00 nop
  264: 	END(set_epcuart_base)
  265: 
  266: LEAF(get_epcuart_base)
  267: 	.set noreorder
  268: 	DMFBR(v0, BR_DUARTBASE)
get_epcuart_base:
[ 268] 0x900000001fc03684:  44 22 18 00 dmfc1	v0,$f3
  269: 	j       ra
[ 269] 0x900000001fc03688:  03 e0 00 08 jr	ra
  270: 	nop
[ 270] 0x900000001fc0368c:  00 00 00 00 nop
  271: END(get_epcuart_base)
  272: 
  273: 
  274: /*
  275:  * delay for a given number of clicks, where a click is defined
  276:  * as being rough 950 nanoseconds (really 1/(2^20) seconds).
  277:  */
  278: 
  279: LEAF(delay)
  280: 	.set	noreorder
  281: 	dli	a2, 47619048 >> 20	/* Tics per us */
delay:
[ 281] 0x900000001fc03690:  24 06 00 2d li	a2,45
  282: 1:
  283: 	dmultu	a0, a2			/* Delay time */
[ 283] 0x900000001fc03694:  00 86 00 1d dmultu	a0,a2
  284: 	mflo	a0			/* Grab RTC tics */
[ 284] 0x900000001fc03698:  00 00 20 12 mflo	a0
  285: 	
  286: 	dli	a1, EV_RTC
[ 286] 0x900000001fc0369c:  3c 05 90 00 lui	a1,0x9000
[ 286] 0x900000001fc036a0:  00 05 2c 38 dsll	a1,a1,16
[ 286] 0x900000001fc036a4:  34 a5 18 02 ori	a1,a1,0x1802
[ 286] 0x900000001fc036a8:  00 05 2c 38 dsll	a1,a1,16
[ 286] 0x900000001fc036ac:  34 a5 00 00 ori	a1,a1,0
  287: 	ld	a2, 0(a1)		# Read the real time clock
[ 287] 0x900000001fc036b0:  dc a6 00 00 ld	a2,0(a1)
  288: 	daddu	a0, a2			# Calculate the delay time
[ 288] 0x900000001fc036b4:  00 86 20 2d daddu	a0,a0,a2
  289: 2:
  290: 	ld	a2, 0(a1)		# Read the Real time clock
[ 290] 0x900000001fc036b8:  dc a6 00 00 ld	a2,0(a1)
  291: 	dsubu	a2, a0			# Compute time difference
[ 291] 0x900000001fc036bc:  00 c4 30 2f dsubu	a2,a2,a0
  292: #ifndef SABLE
  293: 	bltz	a2, 2b
[ 293] 0x900000001fc036c0:  04 c0 ff fd bltz	a2,0x900000001fc036b8
  294: 	nop
[ 294] 0x900000001fc036c4:  00 00 00 00 nop
  295: #endif
  296: 	j	ra			# Return
[ 296] 0x900000001fc036c8:  03 e0 00 08 jr	ra
  297: 	nop
[ 297] 0x900000001fc036cc:  00 00 00 00 nop
  298: 	END(delay)
  299: 
  300: /*
  301:         int u64lw(int bloc, int offset)
  302:         a0 = bloc
  303:         a1 = offset
  304:         *v0 := *(bloc <<8 + offset)
  305: */
  306: 							
  307: LEAF(u64lw)
  308:         .set    noreorder
  309: 	li	v0, 0x00100000
u64lw:
[ 309] 0x900000001fc036d0:  3c 02 00 10 lui	v0,0x10
  310: 	and	v1, a0, 0xfff00000
[ 310] 0x900000001fc036d4:  24 01 0f ff li	at,4095
[ 310] 0x900000001fc036d8:  00 01 0d 38 dsll	at,at,20
[ 310] 0x900000001fc036dc:  00 81 18 24 and	v1,a0,at
  311: 	bne	v0,v1,1f
[ 311] 0x900000001fc036e0:  14 43 00 02 bne	v0,v1,0x900000001fc036ec
  312: 	lui	v1, 0x0ff0		/* DELAY */
[ 312] 0x900000001fc036e4:  3c 03 0f f0 lui	v1,0xff0
  313: 	or	a0,v1
[ 313] 0x900000001fc036e8:  00 83 20 25 or	a0,a0,v1
  314: 1:	
  315:         dsll	a0, 8                   # a0 := Bits 39-8 of the address (BD)
[ 315] 0x900000001fc036ec:  00 04 22 38 dsll	a0,a0,8
  316:         daddu	a0, a1                  # a0 := Full physical address
[ 316] 0x900000001fc036f0:  00 85 20 2d daddu	a0,a0,a1
  317: 	LI	a1, K1BASE
[ 317] 0x900000001fc036f4:  24 05 00 09 li	a1,9
[ 317] 0x900000001fc036f8:  00 05 2f 3c dsll32	a1,a1,28
  318:         or      a0, a1, a0              # Uncached address of word
[ 318] 0x900000001fc036fc:  00 a4 20 25 or	a0,a1,a0
  319:         j       ra
[ 319] 0x900000001fc03700:  03 e0 00 08 jr	ra
  320:         lw      v0, 0(a0)               # Do load.
[ 320] 0x900000001fc03704:  8c 82 00 00 lw	v0,0(a0)
  321:         .set    reorder
  322: 	END(u64lw)
  323: 
  324: 
  325: /*
  326:         int u64sw(int bloc, int offset, int data)
  327:         a0 = bloc
  328:         a1 = offset
  329: 	a2 = data
  330: */
  331: 
  332: LEAF(u64sw)
  333:         .set    noreorder
  334: 	li	v0, 0x00100000
u64sw:
[ 334] 0x900000001fc03708:  3c 02 00 10 lui	v0,0x10
  335: 	and	v1, a0, 0xfff00000
[ 335] 0x900000001fc0370c:  24 01 0f ff li	at,4095
[ 335] 0x900000001fc03710:  00 01 0d 38 dsll	at,at,20
[ 335] 0x900000001fc03714:  00 81 18 24 and	v1,a0,at
  336: 	bne	v0,v1,1f
[ 336] 0x900000001fc03718:  14 43 00 02 bne	v0,v1,0x900000001fc03724
  337: 	lui	v1, 0x0ff0		/* DELAY */
[ 337] 0x900000001fc0371c:  3c 03 0f f0 lui	v1,0xff0
  338: 	or	a0,v1
[ 338] 0x900000001fc03720:  00 83 20 25 or	a0,a0,v1
  339: 1:	
  340:         dsll	a0, 8			# a0 := Bits 39-8 of the address
[ 340] 0x900000001fc03724:  00 04 22 38 dsll	a0,a0,8
  341:         daddu	a0, a1			# a0 := Full physical address
[ 341] 0x900000001fc03728:  00 85 20 2d daddu	a0,a0,a1
  342: 	LI	a1, K1BASE
[ 342] 0x900000001fc0372c:  24 05 00 09 li	a1,9
[ 342] 0x900000001fc03730:  00 05 2f 3c dsll32	a1,a1,28
  343:         or      a0, a1, a0              # Uncached address of word
[ 343] 0x900000001fc03734:  00 a4 20 25 or	a0,a1,a0
  344:         j       ra
[ 344] 0x900000001fc03738:  03 e0 00 08 jr	ra
  345:         sw      a2, 0(a0)               # Do store
[ 345] 0x900000001fc0373c:  ac 86 00 00 sw	a2,0(a0)
  346:         .set    reorder
  347: 	END(u64sw)
  348: 
  349: 
  350: /* Get the endianness of this cpu from the config register */
  351: LEAF(getendian)
  352: 	.set    noreorder
  353: 	MFC0(v0,C0_CONFIG)
getendian:
[ 353] 0x900000001fc03740:  40 02 80 00 mfc0	v0,config
  354: 	dsrl     v0,CONFIG_BE_SHFT	# shift BE to bit position 0
[ 354] 0x900000001fc03744:  00 02 13 fa dsrl	v0,v0,15
  355: 	and     v0,1
[ 355] 0x900000001fc03748:  30 42 00 01 andi	v0,v0,0x1
  356: 	xor     v0,1                    # big = 0, little = 1
[ 356] 0x900000001fc0374c:  38 42 00 01 xori	v0,v0,0x1
  357: 	j       ra
[ 357] 0x900000001fc03750:  03 e0 00 08 jr	ra
  358: 	nop
[ 358] 0x900000001fc03754:  00 00 00 00 nop
  359: 	.set    reorder
  360: 	END(getendian)
  361: 
  362: /*  pod_jump() - jump to an address possibly flushing and invalidating the
  363:  *	caches.
  364:  *  a0: the address to jump to.
  365:  *  a1: first parameter to pass
  366:  *  a2: second parameter to pass
  367:  *  a3: 1 = flush and invalidate caches, 0 = just jump
  368:  *
  369:  *  Return value:
  370:  *	pod_jump is sneaky.  In order to avoid saving its return address, it
  371:  *	does a jump rather than a jump and link to the routine called.  This
  372:  *	means that the return value is whatever the called function leaves in
  373:  *	v0.
  374:  */
  375: LEAF(pod_jump)
  376: 	.set noreorder
  377: 	move	s6, a0			# Save args
pod_jump:
[ 377] 0x900000001fc03758:  00 80 b0 25 move	s6,a0
  378: 	move	s7, a1			# Kludge: this code knows what regs
[ 378] 0x900000001fc0375c:  00 a0 b8 25 move	s7,a1
  379: 	move	s8, a2			# are not trashed by cache code
[ 379] 0x900000001fc03760:  00 c0 f0 25 move	s8,a2
  380: 	move	Ra_save0, ra		# Save the ra (BD)
[ 380] 0x900000001fc03764:  03 e0 80 25 move	s0,ra
  381: 
  382: 	beq	a3, zero, 1f		# Flush and invalidate caches?
[ 382] 0x900000001fc03768:  10 e0 00 09 beq	a3,zero,0x900000001fc03790
  383: 	nop
[ 383] 0x900000001fc0376c:  00 00 00 00 nop
  384: 	jal	invalidateCCtags
[ 384] 0x900000001fc03770:  0f f0 07 ff jal		invalidateCCtags
  385: 	nop
[ 385] 0x900000001fc03774:  00 00 00 00 nop
  386: 	jal	invalidateScache
[ 386] 0x900000001fc03778:  0f f0 08 c3 jal		invalidateScache
  387: 	nop
[ 387] 0x900000001fc0377c:  00 00 00 00 nop
  388: 	jal	invalidateIDcache
[ 388] 0x900000001fc03780:  0f f0 07 f8 jal		invalidateIDcache
  389: 	nop				# (BD)
[ 389] 0x900000001fc03784:  00 00 00 00 nop
  390: 
  391: 	/* Margie added to allow multiple runs of niblet */
  392: 	jal flushTlb
[ 392] 0x900000001fc03788:  0f f0 17 47 jal		flushTlb
  393: 	nop
[ 393] 0x900000001fc0378c:  00 00 00 00 nop
  394: 1:
  395: 	move	ra, Ra_save0		# Restore ra
[ 395] 0x900000001fc03790:  02 00 f8 25 move	ra,s0
  396: 	move	a0, s7			# Set up parameters
[ 396] 0x900000001fc03794:  02 e0 20 25 move	a0,s7
  397: 	move	a1, s8
[ 397] 0x900000001fc03798:  03 c0 28 25 move	a1,s8
  398: 	move	a2, zero
[ 398] 0x900000001fc0379c:  00 00 30 25 move	a2,zero
  399: 	j	s6
[ 399] 0x900000001fc037a0:  02 c0 00 08 jr	s6
  400: 	move	a3, zero		# (BD)
[ 400] 0x900000001fc037a4:  00 00 38 25 move	a3,zero
  401: 	# Never returns
  402: 	END(pod_jump)
  403: 
  404: 
  405: /* a0 = sregs addr
  406:    a1 = function to call
  407:    a2 = paramater
  408:  */
  409: LEAF(save_and_call)
  410: 	.set reorder
  411: 	daddiu	a0, 4
save_and_call:
[ 411] 0x900000001fc037a8:  64 84 00 04 daddiu	a0,a0,4
  412: 	dli	a3, ~7
[ 412] 0x900000001fc037ac:  24 07 ff f8 li	a3,-8
  413: 	and	a0, a3
[ 413] 0x900000001fc037b0:  00 87 20 24 and	a0,a0,a3
  414: 
  415: 	sd	s0, 0(a0)
[ 415] 0x900000001fc037b4:  fc 90 00 00 sd	s0,0(a0)
  416: 	sd	s1, 8(a0)
[ 416] 0x900000001fc037b8:  fc 91 00 08 sd	s1,8(a0)
  417: 	sd	s2, 16(a0)
[ 417] 0x900000001fc037bc:  fc 92 00 10 sd	s2,16(a0)
  418: 	sd	s3, 24(a0)
[ 418] 0x900000001fc037c0:  fc 93 00 18 sd	s3,24(a0)
  419: 	sd	s4, 32(a0)
[ 419] 0x900000001fc037c4:  fc 94 00 20 sd	s4,32(a0)
  420: 	sd	s5, 40(a0)
[ 420] 0x900000001fc037c8:  fc 95 00 28 sd	s5,40(a0)
  421: 	sd	s6, 48(a0)
[ 421] 0x900000001fc037cc:  fc 96 00 30 sd	s6,48(a0)
  422: 	sd	s7, 56(a0)
[ 422] 0x900000001fc037d0:  fc 97 00 38 sd	s7,56(a0)
  423: 	sd	fp, 64(a0)	# fp == s8
[ 423] 0x900000001fc037d4:  fc 9e 00 40 sd	s8,64(a0)
  424: 	sd	ra, 72(a0)
[ 424] 0x900000001fc037d8:  fc 9f 00 48 sd	ra,72(a0)
  425: 
  426: 	move	s7, a0
[ 426] 0x900000001fc037dc:  00 80 b8 25 move	s7,a0
  427: 
  428: 	move	a0, a2
[ 428] 0x900000001fc037e0:  00 c0 20 25 move	a0,a2
  429: 
  430: 	jal	a1
[ 430] 0x900000001fc037e4:  00 a0 f8 09 jalr	ra,a1
[ 430] 0x900000001fc037e8:  00 00 00 00 nop
  431: 
  432: 	move	a0, s7
[ 432] 0x900000001fc037ec:  02 e0 20 25 move	a0,s7
  433: 	ld	s0, 0(a0)
[ 433] 0x900000001fc037f0:  dc 90 00 00 ld	s0,0(a0)
  434: 	ld	s1, 8(a0)
[ 434] 0x900000001fc037f4:  dc 91 00 08 ld	s1,8(a0)
  435: 	ld	s2, 16(a0)
[ 435] 0x900000001fc037f8:  dc 92 00 10 ld	s2,16(a0)
  436: 	ld	s3, 24(a0)
[ 436] 0x900000001fc037fc:  dc 93 00 18 ld	s3,24(a0)
  437: 	ld	s4, 32(a0)
[ 437] 0x900000001fc03800:  dc 94 00 20 ld	s4,32(a0)
  438: 	ld	s5, 40(a0)
[ 438] 0x900000001fc03804:  dc 95 00 28 ld	s5,40(a0)
  439: 	ld	s6, 48(a0)
[ 439] 0x900000001fc03808:  dc 96 00 30 ld	s6,48(a0)
  440: 	ld	s7, 56(a0)
[ 440] 0x900000001fc0380c:  dc 97 00 38 ld	s7,56(a0)
  441: 	ld	fp, 64(a0)	# fp == s8
[ 441] 0x900000001fc03810:  dc 9e 00 40 ld	s8,64(a0)
  442: 	ld	ra, 72(a0)
[ 442] 0x900000001fc03814:  dc 9f 00 48 ld	ra,72(a0)
  443: 
  444: 	j	ra
[ 444] 0x900000001fc03818:  03 e0 00 08 jr	ra
[ 444] 0x900000001fc0381c:  00 00 00 00 nop
  445: 	END(save_and_call)
  446: 
  447: 
  448: LEAF(save_sregs)
  449: 
  450: 	daddiu	a0, 4
save_sregs:
[ 450] 0x900000001fc03820:  64 84 00 04 daddiu	a0,a0,4
  451: 	dli	a3, ~7
[ 451] 0x900000001fc03824:  24 07 ff f8 li	a3,-8
  452: 	and	a0, a3
[ 452] 0x900000001fc03828:  00 87 20 24 and	a0,a0,a3
  453: 
  454: 	sd	s0, 0(a0)
[ 454] 0x900000001fc0382c:  fc 90 00 00 sd	s0,0(a0)
  455: 	sd	s1, 8(a0)
[ 455] 0x900000001fc03830:  fc 91 00 08 sd	s1,8(a0)
  456: 	sd	s2, 16(a0)
[ 456] 0x900000001fc03834:  fc 92 00 10 sd	s2,16(a0)
  457: 	sd	s3, 24(a0)
[ 457] 0x900000001fc03838:  fc 93 00 18 sd	s3,24(a0)
  458: 	sd	s4, 32(a0)
[ 458] 0x900000001fc0383c:  fc 94 00 20 sd	s4,32(a0)
  459: 	sd	s5, 40(a0)
[ 459] 0x900000001fc03840:  fc 95 00 28 sd	s5,40(a0)
  460: 	sd	s6, 48(a0)
[ 460] 0x900000001fc03844:  fc 96 00 30 sd	s6,48(a0)
  461: 	sd	s7, 56(a0)
[ 461] 0x900000001fc03848:  fc 97 00 38 sd	s7,56(a0)
  462: 	sd	fp, 64(a0)	# fp == s8
[ 462] 0x900000001fc0384c:  fc 9e 00 40 sd	s8,64(a0)
  463: 
  464: 	j	ra
[ 464] 0x900000001fc03850:  03 e0 00 08 jr	ra
[ 464] 0x900000001fc03854:  00 00 00 00 nop
  465: 
  466: 	END(save_sregs)
  467: 	
  468: LEAF(restore_sregs)
  469: 
  470: 	daddiu	a0, 4
restore_sregs:
[ 470] 0x900000001fc03858:  64 84 00 04 daddiu	a0,a0,4
  471: 	dli	a3, ~7
[ 471] 0x900000001fc0385c:  24 07 ff f8 li	a3,-8
  472: 	and	a0, a3
[ 472] 0x900000001fc03860:  00 87 20 24 and	a0,a0,a3
  473: 
  474: 	ld	s0, 0(a0)
[ 474] 0x900000001fc03864:  dc 90 00 00 ld	s0,0(a0)
  475: 	ld	s1, 8(a0)
[ 475] 0x900000001fc03868:  dc 91 00 08 ld	s1,8(a0)
  476: 	ld	s2, 16(a0)
[ 476] 0x900000001fc0386c:  dc 92 00 10 ld	s2,16(a0)
  477: 	ld	s3, 24(a0)
[ 477] 0x900000001fc03870:  dc 93 00 18 ld	s3,24(a0)
  478: 	ld	s4, 32(a0)
[ 478] 0x900000001fc03874:  dc 94 00 20 ld	s4,32(a0)
  479: 	ld	s5, 40(a0)
[ 479] 0x900000001fc03878:  dc 95 00 28 ld	s5,40(a0)
  480: 	ld	s6, 48(a0)
[ 480] 0x900000001fc0387c:  dc 96 00 30 ld	s6,48(a0)
  481: 	ld	s7, 56(a0)
[ 481] 0x900000001fc03880:  dc 97 00 38 ld	s7,56(a0)
  482: 	ld	fp, 64(a0)	# fp == s8
[ 482] 0x900000001fc03884:  dc 9e 00 40 ld	s8,64(a0)
  483: 
  484: 	j	ra
[ 484] 0x900000001fc03888:  03 e0 00 08 jr	ra
[ 484] 0x900000001fc0388c:  00 00 00 00 nop
  485: 
  486: 	END(restore_sregs)
  487: 
  488: LEAF(save_gprs)
  489: 	sd	AT, R1_OFF(a0)
save_gprs:
[ 489] 0x900000001fc03890:  fc 81 00 08 sd	at,8(a0)
  490: 	sd	v0, R2_OFF(a0)
[ 490] 0x900000001fc03894:  fc 82 00 10 sd	v0,16(a0)
  491: 	sd	v1, R3_OFF(a0)
[ 491] 0x900000001fc03898:  fc 83 00 18 sd	v1,24(a0)
  492: 	/* No point in saving a0 */
  493: 	sd	a1, R5_OFF(a0)
[ 493] 0x900000001fc0389c:  fc 85 00 28 sd	a1,40(a0)
  494: 	sd	a2, R6_OFF(a0)
[ 494] 0x900000001fc038a0:  fc 86 00 30 sd	a2,48(a0)
  495: 	sd	a3, R7_OFF(a0)
[ 495] 0x900000001fc038a4:  fc 87 00 38 sd	a3,56(a0)
  496: 	sd	ta0, R8_OFF(a0)
[ 496] 0x900000001fc038a8:  fc 88 00 40 sd	a4,64(a0)
  497: 	sd	ta1, R9_OFF(a0)
[ 497] 0x900000001fc038ac:  fc 89 00 48 sd	a5,72(a0)
  498: 	sd	ta2, R10_OFF(a0)
[ 498] 0x900000001fc038b0:  fc 8a 00 50 sd	a6,80(a0)
  499: 	sd	ta3, R11_OFF(a0)
[ 499] 0x900000001fc038b4:  fc 8b 00 58 sd	a7,88(a0)
  500: 	sd	t0, R12_OFF(a0)
[ 500] 0x900000001fc038b8:  fc 8c 00 60 sd	t0,96(a0)
  501: 	sd	t1, R13_OFF(a0)
[ 501] 0x900000001fc038bc:  fc 8d 00 68 sd	t1,104(a0)
  502: 	sd	t2, R14_OFF(a0)
[ 502] 0x900000001fc038c0:  fc 8e 00 70 sd	t2,112(a0)
  503: 	sd	t3, R15_OFF(a0)
[ 503] 0x900000001fc038c4:  fc 8f 00 78 sd	t3,120(a0)
  504: 	sd	s0, R16_OFF(a0)
[ 504] 0x900000001fc038c8:  fc 90 00 80 sd	s0,128(a0)
  505: 	sd	s1, R17_OFF(a0)
[ 505] 0x900000001fc038cc:  fc 91 00 88 sd	s1,136(a0)
  506: 	sd	s2, R18_OFF(a0)
[ 506] 0x900000001fc038d0:  fc 92 00 90 sd	s2,144(a0)
  507: 	sd	s3, R19_OFF(a0)
[ 507] 0x900000001fc038d4:  fc 93 00 98 sd	s3,152(a0)
  508: 	sd	s4, R20_OFF(a0)
[ 508] 0x900000001fc038d8:  fc 94 00 a0 sd	s4,160(a0)
  509: 	sd	s5, R21_OFF(a0)
[ 509] 0x900000001fc038dc:  fc 95 00 a8 sd	s5,168(a0)
  510: 	sd	s6, R22_OFF(a0)
[ 510] 0x900000001fc038e0:  fc 96 00 b0 sd	s6,176(a0)
  511: 	sd	s7, R23_OFF(a0)
[ 511] 0x900000001fc038e4:  fc 97 00 b8 sd	s7,184(a0)
  512: 	sd	t8, R24_OFF(a0)
[ 512] 0x900000001fc038e8:  fc 98 00 c0 sd	t8,192(a0)
  513: 	sd	t9, R25_OFF(a0)
[ 513] 0x900000001fc038ec:  fc 99 00 c8 sd	t9,200(a0)
  514: 	sd	k0, R26_OFF(a0)
[ 514] 0x900000001fc038f0:  fc 9a 00 d0 sd	k0,208(a0)
  515: 	sd	k1, R27_OFF(a0)
[ 515] 0x900000001fc038f4:  fc 9b 00 d8 sd	k1,216(a0)
  516: 	sd	gp, R28_OFF(a0)
[ 516] 0x900000001fc038f8:  fc 9c 00 e0 sd	gp,224(a0)
  517: 	sd	sp, R29_OFF(a0)
[ 517] 0x900000001fc038fc:  fc 9d 00 e8 sd	sp,232(a0)
  518: 	sd	fp, R30_OFF(a0)
[ 518] 0x900000001fc03900:  fc 9e 00 f0 sd	s8,240(a0)
  519: 	/* No point in saving ra */
  520: 	j	ra
[ 520] 0x900000001fc03904:  03 e0 00 08 jr	ra
[ 520] 0x900000001fc03908:  00 00 00 00 nop
       0x900000001fc0390c:  00 00 00 00 nop
Skipping source listing to line 41 of /cores/banyan/stand/arcs/IP25prom/bmarb.s...
   42: #define RTC_SPEED	50000000	/* RTC will run no faster than this */ 
   43: 
   44: #if SABLE
   45: #define SYSCTLR_TIMEOUT 1		/* Number of iterations to wait */
   46: #else
   47: #define SYSCTLR_TIMEOUT 2000000		/* Number of iterations to wait */
   48: #endif
   49: 
   50: LEAF(arb_bootmaster)
   51: 	LEDS(PLED_BMARB)
arb_bootmaster:
[  51] 0x900000001fc03910:  00 00 00 00 nop
[  51] 0x900000001fc03914:  34 04 00 1d ori	a0,zero,0x1d
[  51] 0x900000001fc03918:  3c 02 90 00 lui	v0,0x9000
[  51] 0x900000001fc0391c:  00 02 14 38 dsll	v0,v0,16
[  51] 0x900000001fc03920:  34 42 19 00 ori	v0,v0,0x1900
[  51] 0x900000001fc03924:  00 02 14 38 dsll	v0,v0,16
[  51] 0x900000001fc03928:  34 42 40 00 ori	v0,v0,0x4000
[  51] 0x900000001fc0392c:  fc 44 00 00 sd	a0,0(v0)
   52: 	DPRINT("Starting Boot Master arbitration...\t")
   53: 	/*
   54: 	 * Get all of the processors in sync by waiting for the
   55: 	 * RTC to reach a specific value. This avoids problems in
   56: 	 * systems in which some processors are much faster than
   57: 	 * others.
   58: 	 */
   59: 	dli	t0, EV_RTC		# Load address of Realtime clock
[  59] 0x900000001fc03930:  3c 0c 90 00 lui	t0,0x9000
[  59] 0x900000001fc03934:  00 0c 64 38 dsll	t0,t0,16
[  59] 0x900000001fc03938:  35 8c 18 02 ori	t0,t0,0x1802
[  59] 0x900000001fc0393c:  00 0c 64 38 dsll	t0,t0,16
[  59] 0x900000001fc03940:  35 8c 00 00 ori	t0,t0,0
   60: 	ld	t3, 0(t0)		# Read clock
[  60] 0x900000001fc03944:  dd 8f 00 00 ld	t3,0(t0)
   61: 	dli	t1, (3 * RTC_SPEED)
[  61] 0x900000001fc03948:  3c 0d 08 f0 lui	t1,0x8f0
[  61] 0x900000001fc0394c:  35 ad d1 80 ori	t1,t1,0xd180
   62: 	dsub	t3, t1			# Subtract barrier time from RTC time
[  62] 0x900000001fc03950:  01 ed 78 2e dsub	t3,t3,t1
   63: #if SABLE
   64: 	li	t3,-1			# Get out of loop (RTC broken in sable)
   65: #endif
   66: 	bltz	t3, 2f			# IF we've already broken wait barrier
[  66] 0x900000001fc03954:  05 e0 00 05 bltz	t3,0x900000001fc0396c
   67: 	nop				# THEN
[  67] 0x900000001fc03958:  00 00 00 00 nop
   68:         FLASH(FLED_BROKEWB)	        #   Flash the LEDS
[  68] 0x900000001fc0395c:  00 00 00 00 nop
[  68] 0x900000001fc03960:  34 04 00 30 ori	a0,zero,0x30
[  68] 0x900000001fc03964:  0f f0 0c 7f jal		flash_cc_leds
[  68] 0x900000001fc03968:  00 00 00 00 nop
   69: 2:
   70: 	ld	t3, 0(t0)		# Read the real-time clock
[  70] 0x900000001fc0396c:  dd 8f 00 00 ld	t3,0(t0)
   71: 	dsubu	t3, t1			# Compute difference 
[  71] 0x900000001fc03970:  01 ed 78 2f dsubu	t3,t3,t1
   72: #if SABLE
   73: 	li	t3,0			# Get out of loop (RTC broken in sable)
   74: #endif
   75: 	bltz	t3, 2b			# Loop back if RTC < BARRIER_PERIOD 
[  75] 0x900000001fc03974:  05 e0 ff fd bltz	t3,0x900000001fc0396c
   76: 	nop
[  76] 0x900000001fc03978:  00 00 00 00 nop
   77: 
   78: 	.globl	rearb_bootmaster
   79: rearb_bootmaster:
   80: 	/*
   81: 	 * Now that everything is quiescent, clear out
   82: 	 * interrupts.
   83: 	 */
   84: 	dli	t0, EV_IGRMASK
rearb_bootmaster:
[  84] 0x900000001fc0397c:  3c 0c 90 00 lui	t0,0x9000
[  84] 0x900000001fc03980:  00 0c 64 38 dsll	t0,t0,16
[  84] 0x900000001fc03984:  35 8c 18 00 ori	t0,t0,0x1800
[  84] 0x900000001fc03988:  00 0c 64 38 dsll	t0,t0,16
[  84] 0x900000001fc0398c:  35 8c 08 38 ori	t0,t0,0x838
   85: 	jal	pod_clear_ints
[  85] 0x900000001fc03990:  0f f0 14 d8 jal		pod_clear_ints
   86: 	sd 	zero, 0(t0)
[  86] 0x900000001fc03994:  fd 80 00 00 sd	zero,0(t0)
   87: 
   88: 	jal	ccuart_flush
[  88] 0x900000001fc03998:  0f f0 0c ea jal		ccuart_flush
   89: 	nop
[  89] 0x900000001fc0399c:  00 00 00 00 nop
   90: 
   91: 	DMFBR(t0, BR_BSR)
[  91] 0x900000001fc039a0:  44 2c 00 00 dmfc1	t0,$f0
   92: 	andi	t0, BSR_ABDICATE	# See if we have already been master
[  92] 0x900000001fc039a4:  31 8c 20 00 andi	t0,t0,0x2000
   93: 	beqz	t0, 1f
[  93] 0x900000001fc039a8:  11 80 00 0c beq	t0,zero,0x900000001fc039dc
   94: 	nop				# (BD)
[  94] 0x900000001fc039ac:  00 00 00 00 nop
   95: 
   96: 	dli	t3, EV_IP0		# Load the interrupt pending addr
[  96] 0x900000001fc039b0:  3c 0f 90 00 lui	t3,0x9000
[  96] 0x900000001fc039b4:  00 0f 7c 38 dsll	t3,t3,16
[  96] 0x900000001fc039b8:  35 ef 18 00 ori	t3,t3,0x1800
[  96] 0x900000001fc039bc:  00 0f 7c 38 dsll	t3,t3,16
[  96] 0x900000001fc039c0:  35 ef 08 00 ori	t3,t3,0x800
   97: 78:					# DO
   98: 	ld	ta0, 0(t3)		#   Get Interrupt Pending mask
[  98] 0x900000001fc039c4:  dd e8 00 00 ld	a4,0(t3)
   99: 	and	ta0, (1 << BOOT_LEVEL)	#   Check to see if intr arrived 
[  99] 0x900000001fc039c8:  31 08 00 20 andi	a4,a4,0x20
  100: 	beq	ta0, zero, 78b		# LOOP UNTIL int or timer expired
[ 100] 0x900000001fc039cc:  11 00 ff fd beq	a4,zero,0x900000001fc039c4
  101: 	nop				# (BD)
[ 101] 0x900000001fc039d0:  00 00 00 00 nop
  102: 
  103: 	j	prom_slave
[ 103] 0x900000001fc039d4:  0b f0 0e e0 j		prom_slave
  104: 	nop
[ 104] 0x900000001fc039d8:  00 00 00 00 nop
  105: 1: 
  106: 	/*
  107: 	 * Calculate the time period during which the processor will
  108: 	 * wait for someone else to claim the role of boot master.
  109: 	 */
  110: 	li 	t2, (RTC_SPEED / 64)	# Time to wait per processor
[ 110] 0x900000001fc039dc:  3c 0e 00 0b lui	t2,0xb
[ 110] 0x900000001fc039e0:  35 ce eb c2 ori	t2,t2,0xebc2
  111: 	dli	t3, EV_SPNUM		#	
[ 111] 0x900000001fc039e4:  3c 0f 90 00 lui	t3,0x9000
[ 111] 0x900000001fc039e8:  00 0f 7c 38 dsll	t3,t3,16
[ 111] 0x900000001fc039ec:  35 ef 18 00 ori	t3,t3,0x1800
[ 111] 0x900000001fc039f0:  00 0f 7c 38 dsll	t3,t3,16
[ 111] 0x900000001fc039f4:  35 ef 00 08 ori	t3,t3,0x8
  112: 	ld	t3, 0(t3)		# Load our slot&proc number
[ 112] 0x900000001fc039f8:  dd ef 00 00 ld	t3,0(t3)
  113: 	and	t3, EV_SPNUM_MASK	# Get our PPID
[ 113] 0x900000001fc039fc:  31 ef 00 3f andi	t3,t3,0x3f
  114: 	multu	t3, t2			# offset = PPID * (CLKFREQ/64)
[ 114] 0x900000001fc03a00:  01 ee 00 19 multu	t3,t2
  115: 	mflo	t1			# Get the result of the multiply
[ 115] 0x900000001fc03a04:  00 00 68 12 mflo	t1
  116: 	dli	t0, EV_RTC
[ 116] 0x900000001fc03a08:  3c 0c 90 00 lui	t0,0x9000
[ 116] 0x900000001fc03a0c:  00 0c 64 38 dsll	t0,t0,16
[ 116] 0x900000001fc03a10:  35 8c 18 02 ori	t0,t0,0x1802
[ 116] 0x900000001fc03a14:  00 0c 64 38 dsll	t0,t0,16
[ 116] 0x900000001fc03a18:  35 8c 00 00 ori	t0,t0,0
  117: 	ld	t2, 0(t0)		# Read the RTC 
[ 117] 0x900000001fc03a1c:  dd 8e 00 00 ld	t2,0(t0)
  118: 	daddu	t2, t1			# Add delay time to current time
[ 118] 0x900000001fc03a20:  01 cd 70 2d daddu	t2,t2,t1
  119: 
  120: 	/*
  121: 	 * Now we hang out in a loop waiting for either an interrupt
  122: 	 * to come in or for the RTC to creep past the timeout period.
  123: 	 */
  124: 	ld	t1, 0(t0)		# Read the RTC
[ 124] 0x900000001fc03a24:  dd 8d 00 00 ld	t1,0(t0)
  125: 	dli	t3, EV_IP0		# Load the interrupt pending addr
[ 125] 0x900000001fc03a28:  3c 0f 90 00 lui	t3,0x9000
[ 125] 0x900000001fc03a2c:  00 0f 7c 38 dsll	t3,t3,16
[ 125] 0x900000001fc03a30:  35 ef 18 00 ori	t3,t3,0x1800
[ 125] 0x900000001fc03a34:  00 0f 7c 38 dsll	t3,t3,16
[ 125] 0x900000001fc03a38:  35 ef 08 00 ori	t3,t3,0x800
  126: 1:					# DO
  127: 	dsub	t1, t1, t2		#   rtc_value -= wait time
[ 127] 0x900000001fc03a3c:  01 ae 68 2e dsub	t1,t1,t2
  128: #if SABLE
  129: 	li	t1, 0
  130: #endif
  131: 	bgez	t1, 2f			#   IF timer expired THEN jump forward 	
[ 131] 0x900000001fc03a40:  05 a1 00 0b bgez	t1,0x900000001fc03a70
  132:         nop
[ 132] 0x900000001fc03a44:  00 00 00 00 nop
  133: 	ld	ta0, 0(t3)		#   Get Interrupt Pending mask
[ 133] 0x900000001fc03a48:  dd e8 00 00 ld	a4,0(t3)
  134: 	and	ta0, (1 << BOOT_LEVEL)	#   Check to see if intr arrived 
[ 134] 0x900000001fc03a4c:  31 08 00 20 andi	a4,a4,0x20
  135: 	ld	t1, 0(t0)		# (BD) reload real-time clock
[ 135] 0x900000001fc03a50:  dd 8d 00 00 ld	t1,0(t0)
  136: 	beq	ta0, zero, 1b		# LOOP UNTIL int or timer expired
[ 136] 0x900000001fc03a54:  11 00 ff f9 beq	a4,zero,0x900000001fc03a3c
  137: 	nop
[ 137] 0x900000001fc03a58:  00 00 00 00 nop
  138: 	/*
  139: 	 * If we get here, we received an interrupt and someone
  140: 	 * else has claimed the role of Boot Master.  Set the slave bit
  141: 	 * and off we go!
  142: 	 */
  143: 	DMFBR(v0, BR_BSR)
[ 143] 0x900000001fc03a5c:  44 22 00 00 dmfc1	v0,$f0
  144: 	ori	v0, BSR_SLAVE
[ 144] 0x900000001fc03a60:  34 42 10 00 ori	v0,v0,0x1000
  145: 	DMTBR(v0, BR_BSR)
[ 145] 0x900000001fc03a64:  44 a2 00 00 dmtc1	v0,$f0
  146: 
  147: 	j	prom_slave
[ 147] 0x900000001fc03a68:  0b f0 0e e0 j		prom_slave
  148: 	nop
[ 148] 0x900000001fc03a6c:  00 00 00 00 nop
  149: 2:
  150: 	/*
  151: 	 * If we get here, no one has assumed boot master responsibility,
  152: 	 * so add this processor to the Master Processor group, broadcast 
  153: 	 * a notification interrupt and return.
  154: 	 */
  155: 	dli	t0, EV_IGRMASK		# Load the Int Group Mask addr
[ 155] 0x900000001fc03a70:  3c 0c 90 00 lui	t0,0x9000
[ 155] 0x900000001fc03a74:  00 0c 64 38 dsll	t0,t0,16
[ 155] 0x900000001fc03a78:  35 8c 18 00 ori	t0,t0,0x1800
[ 155] 0x900000001fc03a7c:  00 0c 64 38 dsll	t0,t0,16
[ 155] 0x900000001fc03a80:  35 8c 08 38 ori	t0,t0,0x838
  156: 	li	t1, IGR_MASTER		# Calculate the MASTER bit
[ 156] 0x900000001fc03a84:  24 0d 00 01 li	t1,1
  157: 	sd	t1, 0(t0)		# Add this processor to Master group
[ 157] 0x900000001fc03a88:  fd 8d 00 00 sd	t1,0(t0)
  158: 
  159: 	dli	t0, EV_SENDINT		
[ 159] 0x900000001fc03a8c:  3c 0c 90 00 lui	t0,0x9000
[ 159] 0x900000001fc03a90:  00 0c 64 38 dsll	t0,t0,16
[ 159] 0x900000001fc03a94:  35 8c 18 00 ori	t0,t0,0x1800
[ 159] 0x900000001fc03a98:  00 0c 64 38 dsll	t0,t0,16
[ 159] 0x900000001fc03a9c:  35 8c 01 00 ori	t0,t0,0x100
  160: 	li	t1, EVINTR_VECTOR(BOOT_LEVEL, EVINTR_GLOBALDEST) 
[ 160] 0x900000001fc03aa0:  24 0d 05 7f li	t1,1407
  161: 	sd	t1, 0(t0)		# Send the interrupt to all procs
[ 161] 0x900000001fc03aa4:  fd 8d 00 00 sd	t1,0(t0)
  162: 
  163: 	DMFBR(t0, BR_BSR)
[ 163] 0x900000001fc03aa8:  44 2c 00 00 dmfc1	t0,$f0
  164: 	li	t1, BSR_SLAVE		# Turn off the slave bit
[ 164] 0x900000001fc03aac:  24 0d 10 00 li	t1,4096
  165: 	not	t1
[ 165] 0x900000001fc03ab0:  01 a0 68 27 nor	t1,t1,zero
  166: 	and	t0, t1
[ 166] 0x900000001fc03ab4:  01 8d 60 24 and	t0,t0,t1
  167: 	DMTBR(t0, BR_BSR)
[ 167] 0x900000001fc03ab8:  44 ac 00 00 dmtc1	t0,$f0
  168: 	/*
  169: 	 * Wait for the SysCtrlr to talk to us, and then
  170: 	 * make it known that we are serving as the boot master.
  171: 	 */
  172: 
  173: 	jal	ccuart_flush		# Get rid of any previous garbage
[ 173] 0x900000001fc03abc:  0f f0 0c ea jal		ccuart_flush
  174: 	nop
[ 174] 0x900000001fc03ac0:  00 00 00 00 nop
  175: 2:
  176: 	li	t1, SYSCTLR_TIMEOUT	# Number of times to wait
[ 176] 0x900000001fc03ac4:  3c 0d 00 1e lui	t1,0x1e
[ 176] 0x900000001fc03ac8:  35 ad 84 80 ori	t1,t1,0x8480
  177: 3:					# DO
  178: 	jal	ccuart_poll		#   Check to see if a char is available
[ 178] 0x900000001fc03acc:  0f f0 0c b6 jal		ccuart_poll
  179: 	sub	t1, 1			#   (BD) Decrement the wait counter
[ 179] 0x900000001fc03ad0:  21 ad ff ff addi	t1,t1,-1
  180: 
  181: 	beqz	t1, 5f			#   If wait == 0 give up on SysCtlr
[ 181] 0x900000001fc03ad4:  11 a0 00 25 beq	t1,zero,0x900000001fc03b6c
  182: 	nop				#   (BD)
[ 182] 0x900000001fc03ad8:  00 00 00 00 nop
  183: 
  184: 	beqz	v0, 3b			# UNTIL a character arrives
[ 184] 0x900000001fc03adc:  10 40 ff fb beq	v0,zero,0x900000001fc03acc
  185: 	nop				# (BD)
[ 185] 0x900000001fc03ae0:  00 00 00 00 nop
  186: 
  187: 	# A character arrived.  [[ We first check to see if the character
  188: 	# is destined for this processor.  If it is, ]] we switch on the 
  189: 	# character itself.
  190: 	# [[ According to John Kraft, this was done to get around a hardware
  191: 	# bug on IP19 board in the way the communication between system
  192: 	# controller and processor(s) is implemented.  This has been fixed (?)
  193: 	# on IP21 and the following code can be simplified.  I will simplify
  194: 	# it after getting confirmation from hardware folks.  I suppose the
  195: 	# system controller software will have to change too. ]] 
  196: 	#
  197: 	jal	ccuart_getc		# Read a character from the CC UART
[ 197] 0x900000001fc03ae4:  0f f0 0c bf jal		ccuart_getc
  198: 	nop				# (BD)
[ 198] 0x900000001fc03ae8:  00 00 00 00 nop
  199: 	
  200: 	andi	t1, v0, 0x0f		# Put processor number into t1
[ 200] 0x900000001fc03aec:  30 4d 00 0f andi	t1,v0,0xf
  201: 	andi	v0, 0xf0		# Put mode (normal or manu) into v0 
[ 201] 0x900000001fc03af0:  30 42 00 f0 andi	v0,v0,0xf0
  202: 
  203: 	dli	t2, EV_SPNUM		# Read the SPNUM
[ 203] 0x900000001fc03af4:  3c 0e 90 00 lui	t2,0x9000
[ 203] 0x900000001fc03af8:  00 0e 74 38 dsll	t2,t2,16
[ 203] 0x900000001fc03afc:  35 ce 18 00 ori	t2,t2,0x1800
[ 203] 0x900000001fc03b00:  00 0e 74 38 dsll	t2,t2,16
[ 203] 0x900000001fc03b04:  35 ce 00 08 ori	t2,t2,0x8
  204: 	ld	t2, 0(t2)		
[ 204] 0x900000001fc03b08:  dd ce 00 00 ld	t2,0(t2)
  205: 	andi	t2, EV_PROCNUM_MASK	# Mask out the processor number
[ 205] 0x900000001fc03b0c:  31 ce 00 03 andi	t2,t2,0x3
  206: 	ori	t0, zero, SC_BMREQ	# (BD) Load the BM request char.
[ 206] 0x900000001fc03b10:  34 0c 00 40 ori	t0,zero,0x40
  207: 	bne	t1, t2, 2b		# If not our processor, ignore
[ 207] 0x900000001fc03b14:  15 ae ff eb bne	t1,t2,0x900000001fc03ac4
  208: 	nop
[ 208] 0x900000001fc03b18:  00 00 00 00 nop
  209: 	bne	t0, v0, 4f		# Jump forward if character isn't '@' 
[ 209] 0x900000001fc03b1c:  15 82 00 08 bne	t0,v0,0x900000001fc03b40
  210: 	nop
[ 210] 0x900000001fc03b20:  00 00 00 00 nop
  211: 	
  212: 	# We got an '@'. Do the right thing.
  213: 	#
  214: 	jal	ccuart_putc		# Write response character
[ 214] 0x900000001fc03b24:  0f f0 0c d6 jal		ccuart_putc
  215: 	ori	a0, zero, SC_BMRESP	# (BD) stuff a 'K' into a0
[ 215] 0x900000001fc03b28:  34 04 00 4b ori	a0,zero,0x4b
  216: 	DELAY(40000)			# 40ms for sysctlr to react
[ 216] 0x900000001fc03b2c:  34 04 9c 40 ori	a0,zero,0x9c40
[ 216] 0x900000001fc03b30:  0f f0 0d a4 jal		delay
[ 216] 0x900000001fc03b34:  00 00 00 00 nop
  217: 
  218: 	j	prom_master
[ 218] 0x900000001fc03b38:  0b f0 12 10 j		prom_master
  219: 	nop
[ 219] 0x900000001fc03b3c:  00 00 00 00 nop
  220: 
  221: 	# We didn't get an '@'. Check to see if it was a 'P'.
  222: 4:	#
  223: 	li	t0, SC_MANUMODE		# (BD) Set up for next comparison
[ 223] 0x900000001fc03b40:  24 0c 00 50 li	t0,80
  224: 	bne	t0, v0, 2b		# If not a 'P' go back to poll loop
[ 224] 0x900000001fc03b44:  15 82 ff df bne	t0,v0,0x900000001fc03ac4
  225: 	nop
[ 225] 0x900000001fc03b48:  00 00 00 00 nop
  226: 
  227: 	jal	ccuart_putc		# Send response to SysCtlr 
[ 227] 0x900000001fc03b4c:  0f f0 0c d6 jal		ccuart_putc
  228: 	ori	a0, zero, SC_BMRESP	# (BD) Stuff a 'K' into a0
[ 228] 0x900000001fc03b50:  34 04 00 4b ori	a0,zero,0x4b
  229: 
  230: 	DMFBR(t0, BR_BSR)		# Set a bit indicating that we're
[ 230] 0x900000001fc03b54:  44 2c 00 00 dmfc1	t0,$f0
  231: 	or	t0, BSR_MANUMODE		#    talking directly to a user
[ 231] 0x900000001fc03b58:  35 8c 00 40 ori	t0,t0,0x40
  232: 	DMTBR(t0, BR_BSR) 		#    rather than the SysCtlr
[ 232] 0x900000001fc03b5c:  44 ac 00 00 dmtc1	t0,$f0
  233: 	DELAY(40000)
[ 233] 0x900000001fc03b60:  34 04 9c 40 ori	a0,zero,0x9c40
[ 233] 0x900000001fc03b64:  0f f0 0d a4 jal		delay
[ 233] 0x900000001fc03b68:  00 00 00 00 nop
  234: 5:	
  235: 	j	prom_master
[ 235] 0x900000001fc03b6c:  0b f0 12 10 j		prom_master
  236: 	nop
[ 236] 0x900000001fc03b70:  00 00 00 00 nop
       0x900000001fc03b74:  00 00 00 00 nop
       0x900000001fc03b78:  00 00 00 00 nop
       0x900000001fc03b7c:  00 00 00 00 nop
Skipping source listing to line 46 of /cores/banyan/stand/arcs/IP25prom/slave.s...
   47:  *	None.
   48:  * Returns:
   49:  *	Never returns.
   50:  */
   51: 
   52: LEAF(prom_slave)
   53: 	/*
   54:  	 * Make sure that our interrupt mask is clear
   55: 	 */
   56: 	LEDS(PLED_INSLAVE)
prom_slave:
[  56] 0x900000001fc03b80:  00 00 00 00 nop
[  56] 0x900000001fc03b84:  34 04 00 28 ori	a0,zero,0x28
[  56] 0x900000001fc03b88:  3c 02 90 00 lui	v0,0x9000
[  56] 0x900000001fc03b8c:  00 02 14 38 dsll	v0,v0,16
[  56] 0x900000001fc03b90:  34 42 19 00 ori	v0,v0,0x1900
[  56] 0x900000001fc03b94:  00 02 14 38 dsll	v0,v0,16
[  56] 0x900000001fc03b98:  34 42 40 00 ori	v0,v0,0x4000
[  56] 0x900000001fc03b9c:  fc 44 00 00 sd	a0,0(v0)
   57: 	DPRINT("\r\nSwitching into slave mode\r\n")
   58: 
   59: 	jal	pod_clear_ints
[  59] 0x900000001fc03ba0:  0f f0 14 d8 jal		pod_clear_ints
   60: 	nop
[  60] 0x900000001fc03ba4:  00 00 00 00 nop
   61: 
   62: 	/*
   63: 	 * Put us in the slave processor group
   64: 	 */
   65: 	dli	t0, EV_IGRMASK
[  65] 0x900000001fc03ba8:  3c 0c 90 00 lui	t0,0x9000
[  65] 0x900000001fc03bac:  00 0c 64 38 dsll	t0,t0,16
[  65] 0x900000001fc03bb0:  35 8c 18 00 ori	t0,t0,0x1800
[  65] 0x900000001fc03bb4:  00 0c 64 38 dsll	t0,t0,16
[  65] 0x900000001fc03bb8:  35 8c 08 38 ori	t0,t0,0x838
   66: 	dli	t1, IGR_SLAVE
[  66] 0x900000001fc03bbc:  24 0d 00 02 li	t1,2
   67: 	sd	t1, 0(t0)
[  67] 0x900000001fc03bc0:  fd 8d 00 00 sd	t1,0(t0)
   68: 	nop
[  68] 0x900000001fc03bc4:  00 00 00 00 nop
   69: 
   70: 	/*
   71: 	 * Tell the Boot master processor that this processor
   72: 	 * lives.
   73: 	 */
   74: 	dli	t0, EV_SPNUM		
[  74] 0x900000001fc03bc8:  3c 0c 90 00 lui	t0,0x9000
[  74] 0x900000001fc03bcc:  00 0c 64 38 dsll	t0,t0,16
[  74] 0x900000001fc03bd0:  35 8c 18 00 ori	t0,t0,0x1800
[  74] 0x900000001fc03bd4:  00 0c 64 38 dsll	t0,t0,16
[  74] 0x900000001fc03bd8:  35 8c 00 08 ori	t0,t0,0x8
   75: 	ld	t0, 0(t0)		# Get the processor SPNUM
[  75] 0x900000001fc03bdc:  dd 8c 00 00 ld	t0,0(t0)
   76: 	nop
[  76] 0x900000001fc03be0:  00 00 00 00 nop
   77: 	and	t0, EV_SPNUM_MASK
[  77] 0x900000001fc03be4:  31 8c 00 3f andi	t0,t0,0x3f
   78: 	sll	t0, EVINTR_LEVEL_SHFT+1	# Set the level (add one for aliveness) 
[  78] 0x900000001fc03be8:  00 0c 62 40 sll	t0,t0,9
   79: 	or	t0, t0, PGRP_MASTER	# Set the destination 
[  79] 0x900000001fc03bec:  35 8c 00 40 ori	t0,t0,0x40
   80: 	dli	t1, EV_SENDINT
[  80] 0x900000001fc03bf0:  3c 0d 90 00 lui	t1,0x9000
[  80] 0x900000001fc03bf4:  00 0d 6c 38 dsll	t1,t1,16
[  80] 0x900000001fc03bf8:  35 ad 18 00 ori	t1,t1,0x1800
[  80] 0x900000001fc03bfc:  00 0d 6c 38 dsll	t1,t1,16
[  80] 0x900000001fc03c00:  35 ad 01 00 ori	t1,t1,0x100
   81: 	sd	t0, 0(t1)		# Send interrupt to boot master
[  81] 0x900000001fc03c04:  fd ac 00 00 sd	t0,0(t1)
   82: 
   83: 	/*
   84: 	 * Main Interrupt polling loop
   85: 	 */
   86: SlaveLoop:
   87: 	jal	change_led
[  87] 0x900000001fc03c08:  0f f0 11 65 jal		change_led
   88: 	ori	a0, zero, 0x9
[  88] 0x900000001fc03c0c:  34 04 00 09 ori	a0,zero,0x9
   89: 
   90: 	dli	t0, EV_IP0		# All requests are in the IP0 range
[  90] 0x900000001fc03c10:  3c 0c 90 00 lui	t0,0x9000
[  90] 0x900000001fc03c14:  00 0c 64 38 dsll	t0,t0,16
[  90] 0x900000001fc03c18:  35 8c 18 00 ori	t0,t0,0x1800
[  90] 0x900000001fc03c1c:  00 0c 64 38 dsll	t0,t0,16
[  90] 0x900000001fc03c20:  35 8c 08 00 ori	t0,t0,0x800
   91: 	ld	t1, 0(t0)		# Get pending interrupt information
[  91] 0x900000001fc03c24:  dd 8d 00 00 ld	t1,0(t0)
   92: 
   93: 	li	t2, (1 << REARB_LEVEL)	
[  93] 0x900000001fc03c28:  24 0e 00 02 li	t2,2
   94: 	and	t3, t2, t1	
[  94] 0x900000001fc03c2c:  01 cd 78 24 and	t3,t2,t1
   95: 	bne	t3, zero, slave_rearb	# IF (IP0 & (1 << REARB_LEVEL))
[  95] 0x900000001fc03c30:  15 e0 00 22 bne	t3,zero,0x900000001fc03cbc
   96:         nop
[  96] 0x900000001fc03c34:  00 00 00 00 nop
   97: 
   98: 	li	t2, (1 << STATUS_LEVEL)	# (BD)
[  98] 0x900000001fc03c38:  24 0e 00 04 li	t2,4
   99: 	and	t3, t2, t1
[  99] 0x900000001fc03c3c:  01 cd 78 24 and	t3,t2,t1
  100: 	bne	t3, zero, slave_status	# Initialize status fields in cfginfo 
[ 100] 0x900000001fc03c40:  15 e0 00 2c bne	t3,zero,0x900000001fc03cf4
  101:         nop
[ 101] 0x900000001fc03c44:  00 00 00 00 nop
  102: 
  103: 	li	t2, (1 << LAUNCH_LEVEL)	# (BD) 
[ 103] 0x900000001fc03c48:  24 0e 00 08 li	t2,8
  104: 	and	t3, t2, t1
[ 104] 0x900000001fc03c4c:  01 cd 78 24 and	t3,t2,t1
  105: 	bne	t3, zero, slave_launch	# Jump through launch vec if intr	
[ 105] 0x900000001fc03c50:  15 e0 00 36 bne	t3,zero,0x900000001fc03d2c
  106:         nop
[ 106] 0x900000001fc03c54:  00 00 00 00 nop
  107: 
  108: 	li	t2, (1 << POD_LEVEL)	# (BD)
[ 108] 0x900000001fc03c58:  24 0e 00 40 li	t2,64
  109: 	and	t3, t2, t1
[ 109] 0x900000001fc03c5c:  01 cd 78 24 and	t3,t2,t1
  110: 	bne	t3, zero, slave_pod	# Jump into POD mode
[ 110] 0x900000001fc03c60:  15 e0 00 7a bne	t3,zero,0x900000001fc03e4c
  111:         nop
[ 111] 0x900000001fc03c64:  00 00 00 00 nop
  112: 
  113: 	li	t2, (1 << MPCONF_INIT_LEVEL)
[ 113] 0x900000001fc03c68:  24 0e 00 80 li	t2,128
  114: 	and	t3, t2, t1
[ 114] 0x900000001fc03c6c:  01 cd 78 24 and	t3,t2,t1
  115: 	bne	t3, zero, mpconf_init
[ 115] 0x900000001fc03c70:  15 e0 00 7e bne	t3,zero,0x900000001fc03e6c
  116:         nop
[ 116] 0x900000001fc03c74:  00 00 00 00 nop
  117:  
  118: 	li	t2, (1 << MPCONF_LAUNCH_LEVEL)
[ 118] 0x900000001fc03c78:  24 0e 01 00 li	t2,256
  119: 	and	t3, t2, t1
[ 119] 0x900000001fc03c7c:  01 cd 78 24 and	t3,t2,t1
  120: 	bne	t3, zero, mpconf_launch 
[ 120] 0x900000001fc03c80:  15 e0 01 c9 bne	t3,zero,0x900000001fc043a8
  121: 	nop
[ 121] 0x900000001fc03c84:  00 00 00 00 nop
  122: 
  123: 	jal	ccuart_poll		# See if a character's waiting
[ 123] 0x900000001fc03c88:  0f f0 0c b6 jal		ccuart_poll
  124: 	nop				# (BD)
[ 124] 0x900000001fc03c8c:  00 00 00 00 nop
  125: 
  126: 	beqz	v0, 1f			# Was one?
[ 126] 0x900000001fc03c90:  10 40 00 06 beq	v0,zero,0x900000001fc03cac
  127: 	nop				# (BD)
[ 127] 0x900000001fc03c94:  00 00 00 00 nop
  128: 
  129: 	jal	ccuart_getc		# Get it
[ 129] 0x900000001fc03c98:  0f f0 0c bf jal		ccuart_getc
  130: 	nop				# (BD)
[ 130] 0x900000001fc03c9c:  00 00 00 00 nop
  131: 
  132: 	li	a0, 16			# ^P
[ 132] 0x900000001fc03ca0:  24 04 00 10 li	a0,16
  133: 	beq	a0, v0, slave_pod	# Go into pod mode
[ 133] 0x900000001fc03ca4:  10 82 00 69 beq	a0,v0,0x900000001fc03e4c
  134: 	nop
[ 134] 0x900000001fc03ca8:  00 00 00 00 nop
  135: 
  136: 1:
  137: 	jal	change_led	
[ 137] 0x900000001fc03cac:  0f f0 11 65 jal		change_led
  138: 	ori	a0, zero, 0x6		# (BD) Toggle the LEDS
[ 138] 0x900000001fc03cb0:  34 04 00 06 ori	a0,zero,0x6
  139: 
[ 139] 0x900000001fc03cb4:  10 00 ff d4 b		0x900000001fc03c08
  140: 	b	SlaveLoop
  141: 	nop				# LOOP again
[ 141] 0x900000001fc03cb8:  00 00 00 00 nop
  142: 
  143: 	/*
  144: 	 * For some reason the Boot Master processor needs to
  145: 	 * resign its position, so we jump back to the boot
  146: 	 * master arbitration code.
  147: 	 */
  148: slave_rearb:
  149: 	LEDS(PLED_BMARB)
[ 149] 0x900000001fc03cbc:  00 00 00 00 nop
[ 149] 0x900000001fc03cc0:  34 04 00 1d ori	a0,zero,0x1d
[ 149] 0x900000001fc03cc4:  3c 02 90 00 lui	v0,0x9000
[ 149] 0x900000001fc03cc8:  00 02 14 38 dsll	v0,v0,16
[ 149] 0x900000001fc03ccc:  34 42 19 00 ori	v0,v0,0x1900
[ 149] 0x900000001fc03cd0:  00 02 14 38 dsll	v0,v0,16
[ 149] 0x900000001fc03cd4:  34 42 40 00 ori	v0,v0,0x4000
[ 149] 0x900000001fc03cd8:  fc 44 00 00 sd	a0,0(v0)
  150: 	DPRINT("Rearbitrating for Boot Master...\r\n")
  151: 	
  152: 	jal	rearb_bootmaster	# Call subroutine to do actual arb
[ 152] 0x900000001fc03cdc:  0f f0 0e 5f jal		rearb_bootmaster
  153: 	nop				# (BD)
[ 153] 0x900000001fc03ce0:  00 00 00 00 nop
  154: 	beq	v0, zero, prom_slave	# Goto prom_slave if v0 == 0
[ 154] 0x900000001fc03ce4:  10 40 ff a6 beq	v0,zero,0x900000001fc03b80
  155: 	nop				# (BD)
[ 155] 0x900000001fc03ce8:  00 00 00 00 nop
  156: 	j	prom_master		# Otherwise goto prom_slave
[ 156] 0x900000001fc03cec:  0b f0 12 10 j		prom_master
  157: 	nop				# (BD)
[ 157] 0x900000001fc03cf0:  00 00 00 00 nop
  158: 
  159: 	/*
  160: 	 * When we receive the STATUS interrupt we update the
  161: 	 * processor status field in the EVCFG data structure.
  162: 	 * Note that we should NOT call this routine if we aren't
  163: 	 * sure that everyone is running with the same endianess,
  164: 	 * since this potentially can fry the evcfginfo data.
  165: 	 */
  166: slave_status:
  167: 	jal	get_cpuinfo		# Get CPU info base addr
[ 167] 0x900000001fc03cf4:  0f f0 11 40 jal		get_cpuinfo
  168: 	nop
[ 168] 0x900000001fc03cf8:  00 00 00 00 nop
  169: 	move	t2, v0
[ 169] 0x900000001fc03cfc:  00 40 70 25 move	t2,v0
  170: 	jal	ccuart_puthex		# Print cpuinfo addr
[ 170] 0x900000001fc03d00:  0f f0 0c f7 jal		ccuart_puthex
  171: 	move	a0, t2			# (BD)
[ 171] 0x900000001fc03d04:  01 c0 20 25 move	a0,t2
  172: 	DPRINT("\r\n")
  173: 
  174: 	move	v0, t2
[ 174] 0x900000001fc03d08:  01 c0 10 25 move	v0,t2
  175: 
  176: 		
  177: 	dli	t0, STATUS_LEVEL	# Get level to be cleared
[ 177] 0x900000001fc03d0c:  24 0c 00 02 li	t0,2
  178: 	dli	t1, EV_CIPL0		# Get clear register address
[ 178] 0x900000001fc03d10:  3c 0d 90 00 lui	t1,0x9000
[ 178] 0x900000001fc03d14:  00 0d 6c 38 dsll	t1,t1,16
[ 178] 0x900000001fc03d18:  35 ad 18 00 ori	t1,t1,0x1800
[ 178] 0x900000001fc03d1c:  00 0d 6c 38 dsll	t1,t1,16
[ 178] 0x900000001fc03d20:  35 ad 08 30 ori	t1,t1,0x830
  179: 	b	SlaveLoop		# Return to the slave loop
[ 179] 0x900000001fc03d24:  10 00 ff b8 b		0x900000001fc03c08
  180: 	sd	t0, 0(t1)		# (BD) Clear the interrupt
[ 180] 0x900000001fc03d28:  fd ac 00 00 sd	t0,0(t1)
  181: 
  182: 
  183: 	/*
  184: 	 * On receipt of the LAUNCH interrupt we
  185: 	 * examine this processor's segment of the
  186: 	 * MPCONF block and jump to the address specified
  187: 	 * in the XXX field.
  188: 	 */
  189: slave_launch:
  190: 	DPRINT("Launching...\r\n")
  191: 
  192: 	# Invalidate all caches
  193: 	# (Things we called before may have left stuff in here...)
  194: 
  195: 	/* Margie added so we can run multiple niblet tests from pod prompt */
  196: 	jal flushTlb
[ 196] 0x900000001fc03d2c:  0f f0 17 47 jal		flushTlb
  197: 	nop
[ 197] 0x900000001fc03d30:  00 00 00 00 nop
  198:         jal	invalidateCCtags
[ 198] 0x900000001fc03d34:  0f f0 07 ff jal		invalidateCCtags
  199:         nop
[ 199] 0x900000001fc03d38:  00 00 00 00 nop
  200: 	jal	invalidateIDcache
[ 200] 0x900000001fc03d3c:  0f f0 07 f8 jal		invalidateIDcache
  201: 	nop
[ 201] 0x900000001fc03d40:  00 00 00 00 nop
  202: 	jal	invalidateScache
[ 202] 0x900000001fc03d44:  0f f0 08 c3 jal		invalidateScache
  203: 	nop
[ 203] 0x900000001fc03d48:  00 00 00 00 nop
  204: 
  205: 	jal	get_cpuinfo
[ 205] 0x900000001fc03d4c:  0f f0 11 40 jal		get_cpuinfo
  206: 	nop
[ 206] 0x900000001fc03d50:  00 00 00 00 nop
  207: 
  208: 	lw	t1, CPULAUNCH_OFF(v0)	# Load launch address
[ 208] 0x900000001fc03d54:  8c 4d 00 00 lw	t1,0(v0)
  209: 	nop
[ 209] 0x900000001fc03d58:  00 00 00 00 nop
  210: 
  211: 	#
  212: 	# Convert the address in t1 into a real 64-bit address.
  213: 	#	Use t0 and t2 as temp registers.
  214: 	#
  215: 	K32TOKPHYS(t1, t0, t2)
[ 215] 0x900000001fc03d5c:  3c 0c 20 00 lui	t0,0x2000
[ 215] 0x900000001fc03d60:  01 8d 60 24 and	t0,t0,t1
[ 215] 0x900000001fc03d64:  3c 0e e0 00 lui	t2,0xe000
[ 215] 0x900000001fc03d68:  01 c0 70 27 nor	t2,t2,zero
[ 215] 0x900000001fc03d6c:  11 80 00 04 beq	t0,zero,0x900000001fc03d80
[ 215] 0x900000001fc03d70:  01 ae 68 24 and	t1,t1,t2
[ 215] 0x900000001fc03d74:  3c 0c 90 00 lui	t0,0x9000
[ 215] 0x900000001fc03d78:  10 00 00 02 b		0x900000001fc03d84
[ 215] 0x900000001fc03d7c:  00 00 00 00 nop
[ 215] 0x900000001fc03d80:  3c 0c a8 00 lui	t0,0xa800
[ 215] 0x900000001fc03d84:  00 0c 60 3c dsll32	t0,t0,0
[ 215] 0x900000001fc03d88:  01 ac 68 25 or	t1,t1,t0
  216: 
  217: 	lw	t2, CPUPARM_OFF(v0)	# Load parameter address
[ 217] 0x900000001fc03d8c:  8c 4e 00 04 lw	t2,4(v0)
  218: 	nop
[ 218] 0x900000001fc03d90:  00 00 00 00 nop
  219: 
  220: 	#
  221: 	# Set up the stack
  222: 	#
  223: 	dli	sp, IP25PROM_STACK
[ 223] 0x900000001fc03d94:  3c 1d a8 00 lui	sp,0xa800
[ 223] 0x900000001fc03d98:  00 1d ec 38 dsll	sp,sp,16
[ 223] 0x900000001fc03d9c:  37 bd 00 98 ori	sp,sp,0x98
[ 223] 0x900000001fc03da0:  00 1d ec 38 dsll	sp,sp,16
[ 223] 0x900000001fc03da4:  37 bd 00 00 ori	sp,sp,0
  224:         dli     t0, 0x9fffffff
[ 224] 0x900000001fc03da8:  34 0c 9f ff ori	t0,zero,0x9fff
[ 224] 0x900000001fc03dac:  00 0c 64 38 dsll	t0,t0,16
[ 224] 0x900000001fc03db0:  35 8c ff ff ori	t0,t0,0xffff
  225: 	and	sp, t0
[ 225] 0x900000001fc03db4:  03 ac e8 24 and	sp,sp,t0
  226: 	or	sp, K0BASE
[ 226] 0x900000001fc03db8:  24 01 00 15 li	at,21
[ 226] 0x900000001fc03dbc:  00 01 0e fc dsll32	at,at,27
[ 226] 0x900000001fc03dc0:  03 a1 e8 25 or	sp,sp,at
  227: 	dli	t0, EV_SPNUM
[ 227] 0x900000001fc03dc4:  3c 0c 90 00 lui	t0,0x9000
[ 227] 0x900000001fc03dc8:  00 0c 64 38 dsll	t0,t0,16
[ 227] 0x900000001fc03dcc:  35 8c 18 00 ori	t0,t0,0x1800
[ 227] 0x900000001fc03dd0:  00 0c 64 38 dsll	t0,t0,16
[ 227] 0x900000001fc03dd4:  35 8c 00 08 ori	t0,t0,0x8
  228: 	ld	t0, 0(t0)
[ 228] 0x900000001fc03dd8:  dd 8c 00 00 ld	t0,0(t0)
  229: 	andi	t0, EV_SPNUM_MASK
[ 229] 0x900000001fc03ddc:  31 8c 00 3f andi	t0,t0,0x3f
  230: 	dsll	t0, 16
[ 230] 0x900000001fc03de0:  00 0c 64 38 dsll	t0,t0,16
  231: 	dadd	sp, t0
[ 231] 0x900000001fc03de4:  03 ac e8 2c dadd	sp,sp,t0
  232: 	
  233: 	#
  234: 	# Perform the actual jump to the subroutine
  235: 	#
  236: 
  237: 	jal	t1			# Jump to the address
[ 237] 0x900000001fc03de8:  01 a0 f8 09 jalr	ra,t1
  238: 	move	a0, t2			# (BD) Load the parameter
[ 238] 0x900000001fc03dec:  01 c0 20 25 move	a0,t2
  239: 
  240: 	.globl slave_return
  241: slave_return:
  242: 	#
  243: 	# We should get here on return
  244: 	#
  245: 	move	s5, v0			# Save the return value
slave_return:
[ 245] 0x900000001fc03df0:  00 40 a8 25 move	s5,v0
  246: 
  247: 	dli	t0, EV_ILE		# Disable interrupts
[ 247] 0x900000001fc03df4:  3c 0c 90 00 lui	t0,0x9000
[ 247] 0x900000001fc03df8:  00 0c 64 38 dsll	t0,t0,16
[ 247] 0x900000001fc03dfc:  35 8c 18 00 ori	t0,t0,0x1800
[ 247] 0x900000001fc03e00:  00 0c 64 38 dsll	t0,t0,16
[ 247] 0x900000001fc03e04:  35 8c 08 40 ori	t0,t0,0x840
  248: 	sd	zero, 0(t0)		# Clear the ILE vector
[ 248] 0x900000001fc03e08:  fd 80 00 00 sd	zero,0(t0)
  249: 
  250: 	# Get the evcpucfg block address
  251: 
  252: 	jal	get_cpuinfo
[ 252] 0x900000001fc03e0c:  0f f0 11 40 jal		get_cpuinfo
  253: 	nop
[ 253] 0x900000001fc03e10:  00 00 00 00 nop
  254: 
  255: 	sw	s5, CPUPARM_OFF(v0)	# Save the returned value in
[ 255] 0x900000001fc03e14:  ac 55 00 04 sw	s5,4(v0)
  256: 	nop				#   the EVCFGINFO parameter slot
[ 256] 0x900000001fc03e18:  00 00 00 00 nop
  257: 	
  258: 	dli	t2, PROM_SR
[ 258] 0x900000001fc03e1c:  3c 0e 24 40 lui	t2,0x2440
[ 258] 0x900000001fc03e20:  35 ce 00 80 ori	t2,t2,0x80
  259: 	MTC0(t2, C0_SR)
[ 259] 0x900000001fc03e24:  40 8e 60 00 mtc0	t2,sr
  260: 
  261: 	dli	t0, LAUNCH_LEVEL
[ 261] 0x900000001fc03e28:  24 0c 00 03 li	t0,3
  262: 	dli	t1, EV_CIPL0
[ 262] 0x900000001fc03e2c:  3c 0d 90 00 lui	t1,0x9000
[ 262] 0x900000001fc03e30:  00 0d 6c 38 dsll	t1,t1,16
[ 262] 0x900000001fc03e34:  35 ad 18 00 ori	t1,t1,0x1800
[ 262] 0x900000001fc03e38:  00 0d 6c 38 dsll	t1,t1,16
[ 262] 0x900000001fc03e3c:  35 ad 08 30 ori	t1,t1,0x830
  263: 	sd	t0, 0(t1)
[ 263] 0x900000001fc03e40:  fd ac 00 00 sd	t0,0(t1)
  264: 	b	SlaveLoop		# Go back to main Slave loop
[ 264] 0x900000001fc03e44:  10 00 ff 70 b		0x900000001fc03c08
  265:         nop
[ 265] 0x900000001fc03e48:  00 00 00 00 nop
  266: 
  267: 	/*
  268: 	 * Jump into POD mode
  269: 	 */
  270: slave_pod:
  271: 	MESSAGE(a1, "Slave processor entering POD mode.\r\n")
[ 271] 0x900000001fc03e4c:  3c 05 90 00 lui	a1,0x9000
[ 271] 0x900000001fc03e50:  64 a5 00 00 daddiu	a1,a1,0
[ 271] 0x900000001fc03e54:  00 05 2c 38 dsll	a1,a1,16
[ 271] 0x900000001fc03e58:  64 a5 1f c1 daddiu	a1,a1,8129
[ 271] 0x900000001fc03e5c:  00 05 2c 38 dsll	a1,a1,16
[ 271] 0x900000001fc03e60:  64 a5 77 d8 daddiu	a1,a1,30680
  272: 	jal	podMode
[ 272] 0x900000001fc03e64:  0f f0 15 fd jal		podMode
  273: 	li	a0, EVDIAG_DEBUG		# (BD)
[ 273] 0x900000001fc03e68:  24 04 00 fd li	a0,253
  274: 	
  275: 	/*
  276: 	 * Update the MPCONF block for this processor
  277: 	 */
  278: 	.globl mpconf_init
  279: mpconf_init:
  280: 
  281: 	jal	get_cpuinfo		# Get out evconfig address
mpconf_init:
[ 281] 0x900000001fc03e6c:  0f f0 11 40 jal		get_cpuinfo
  282: 	nop
[ 282] 0x900000001fc03e70:  00 00 00 00 nop
  283:         move	s1,v0			# Save pointer
[ 283] 0x900000001fc03e74:  00 40 88 25 move	s1,v0
  284: 
  285:         /*
  286:          * Check if we are required to run diags or not.
  287: 	 */
  288: 	dli	t0, EVCFGINFO_ADDR
[ 288] 0x900000001fc03e78:  3c 0c 90 00 lui	t0,0x9000
[ 288] 0x900000001fc03e7c:  00 0c 60 3c dsll32	t0,t0,0
[ 288] 0x900000001fc03e80:  35 8c 20 00 ori	t0,t0,0x2000
  289: 	lw	t1, DEBUGSW_OFF(t0)	# Get debug switches
[ 289] 0x900000001fc03e84:  8d 8d 06 d8 lw	t1,1752(t0)
  290: 
  291: 	li	t0, VDS_NO_DIAGS
[ 291] 0x900000001fc03e88:  24 0c 00 10 li	t0,16
  292: 	and	t0, t1			# Check NO_DIAGS switch
[ 292] 0x900000001fc03e8c:  01 8d 60 24 and	t0,t0,t1
  293: 
  294: 	bnez	t0, 1f			# If it's set jump over diags
[ 294] 0x900000001fc03e90:  15 80 00 74 bne	t0,zero,0x900000001fc04064
  295: 	move	v0,zero			#   do cache init, 0 results
[ 295] 0x900000001fc03e94:  00 00 10 25 move	v0,zero
  296: 
  297: 	/*
  298:          * Test primary and secondary caches.
  299:          */
  300:         PMESSAGE("Testing primary D-cache\n\r")
[ 300] 0x900000001fc03e98:  3c 04 90 00 lui	a0,0x9000
[ 300] 0x900000001fc03e9c:  64 84 00 00 daddiu	a0,a0,0
[ 300] 0x900000001fc03ea0:  00 04 24 38 dsll	a0,a0,16
[ 300] 0x900000001fc03ea4:  64 84 1f c1 daddiu	a0,a0,8129
[ 300] 0x900000001fc03ea8:  00 04 24 38 dsll	a0,a0,16
[ 300] 0x900000001fc03eac:  64 84 77 fd daddiu	a0,a0,30717
[ 300] 0x900000001fc03eb0:  0f f0 15 03 jal		pod_puts
[ 300] 0x900000001fc03eb4:  00 00 00 00 nop
  301: 	li	t1, EVDIAG_TESTING_DCACHE
[ 301] 0x900000001fc03eb8:  24 0d 00 f3 li	t1,243
  302: 	sb	t1, CPUDIAGVAL_OFF(s1)
[ 302] 0x900000001fc03ebc:  a2 2d 00 0b sb	t1,11(s1)
  303:         jal	testDcache
[ 303] 0x900000001fc03ec0:  0f f0 06 a5 jal		testDcache
  304:         nop
[ 304] 0x900000001fc03ec4:  00 00 00 00 nop
  305:         bnez	v0,slaveDiagDone
[ 305] 0x900000001fc03ec8:  14 40 01 27 bne	v0,zero,0x900000001fc04368
  306: 	nop
[ 306] 0x900000001fc03ecc:  00 00 00 00 nop
  307:         PMESSAGE("Testing primary I-cache\n\r")
[ 307] 0x900000001fc03ed0:  3c 04 90 00 lui	a0,0x9000
[ 307] 0x900000001fc03ed4:  64 84 00 00 daddiu	a0,a0,0
[ 307] 0x900000001fc03ed8:  00 04 24 38 dsll	a0,a0,16
[ 307] 0x900000001fc03edc:  64 84 1f c1 daddiu	a0,a0,8129
[ 307] 0x900000001fc03ee0:  00 04 24 38 dsll	a0,a0,16
[ 307] 0x900000001fc03ee4:  64 84 78 17 daddiu	a0,a0,30743
[ 307] 0x900000001fc03ee8:  0f f0 15 03 jal		pod_puts
[ 307] 0x900000001fc03eec:  00 00 00 00 nop
  308: 	li	t1, EVDIAG_TESTING_ICACHE
[ 308] 0x900000001fc03ef0:  24 0d 00 f4 li	t1,244
  309: 	sb	t1, CPUDIAGVAL_OFF(s1)
[ 309] 0x900000001fc03ef4:  a2 2d 00 0b sb	t1,11(s1)
  310:         jal	testIcache
[ 310] 0x900000001fc03ef8:  0f f0 05 99 jal		testIcache
  311:         nop
[ 311] 0x900000001fc03efc:  00 00 00 00 nop
  312:         bnez	v0,slaveDiagDone
[ 312] 0x900000001fc03f00:  14 40 01 19 bne	v0,zero,0x900000001fc04368
  313:         nop
[ 313] 0x900000001fc03f04:  00 00 00 00 nop
  314:         PMESSAGE("Testing secondary cache\n\r")
[ 314] 0x900000001fc03f08:  3c 04 90 00 lui	a0,0x9000
[ 314] 0x900000001fc03f0c:  64 84 00 00 daddiu	a0,a0,0
[ 314] 0x900000001fc03f10:  00 04 24 38 dsll	a0,a0,16
[ 314] 0x900000001fc03f14:  64 84 1f c1 daddiu	a0,a0,8129
[ 314] 0x900000001fc03f18:  00 04 24 38 dsll	a0,a0,16
[ 314] 0x900000001fc03f1c:  64 84 78 31 daddiu	a0,a0,30769
[ 314] 0x900000001fc03f20:  0f f0 15 03 jal		pod_puts
[ 314] 0x900000001fc03f24:  00 00 00 00 nop
  315: 	li	t1, EVDIAG_TESTING_SCACHE
[ 315] 0x900000001fc03f28:  24 0d 00 f5 li	t1,245
  316: 	sb	t1, CPUDIAGVAL_OFF(s1)
[ 316] 0x900000001fc03f2c:  a2 2d 00 0b sb	t1,11(s1)
  317:         jal	testScache
[ 317] 0x900000001fc03f30:  0f f0 08 ed jal		testScache
  318:         nop
[ 318] 0x900000001fc03f34:  00 00 00 00 nop
  319:         bnez	v0,slaveDiagDone
[ 319] 0x900000001fc03f38:  14 40 01 0b bne	v0,zero,0x900000001fc04368
  320:         nop
[ 320] 0x900000001fc03f3c:  00 00 00 00 nop
  321: 
  322:         PMESSAGE("Testing duplicate tags\n\r")
[ 322] 0x900000001fc03f40:  3c 04 90 00 lui	a0,0x9000
[ 322] 0x900000001fc03f44:  64 84 00 00 daddiu	a0,a0,0
[ 322] 0x900000001fc03f48:  00 04 24 38 dsll	a0,a0,16
[ 322] 0x900000001fc03f4c:  64 84 1f c1 daddiu	a0,a0,8129
[ 322] 0x900000001fc03f50:  00 04 24 38 dsll	a0,a0,16
[ 322] 0x900000001fc03f54:  64 84 78 4b daddiu	a0,a0,30795
[ 322] 0x900000001fc03f58:  0f f0 15 03 jal		pod_puts
[ 322] 0x900000001fc03f5c:  00 00 00 00 nop
  323: 	jal	invalidateIcache
[ 323] 0x900000001fc03f60:  0f f0 07 a9 jal		invalidateIcache
  324: 	nop
[ 324] 0x900000001fc03f64:  00 00 00 00 nop
  325: 	jal	invalidateDcache
[ 325] 0x900000001fc03f68:  0f f0 07 d0 jal		invalidateDcache
  326: 	nop
[ 326] 0x900000001fc03f6c:  00 00 00 00 nop
  327: 	jal	invalidateScache
[ 327] 0x900000001fc03f70:  0f f0 08 c3 jal		invalidateScache
  328: 	nop
[ 328] 0x900000001fc03f74:  00 00 00 00 nop
  329: 	/*
  330: 	 * For REV "A" scc, copy test to cache, otherwise,
  331: 	 * run it from prom.
  332: 	 */
  333: 	GET_CC_REV(a0,a1)
[ 333] 0x900000001fc03f78:  3c 04 90 00 lui	a0,0x9000
[ 333] 0x900000001fc03f7c:  00 04 24 38 dsll	a0,a0,16
[ 333] 0x900000001fc03f80:  34 84 18 00 ori	a0,a0,0x1800
[ 333] 0x900000001fc03f84:  00 04 24 38 dsll	a0,a0,16
[ 333] 0x900000001fc03f88:  34 84 00 08 ori	a0,a0,0x8
[ 333] 0x900000001fc03f8c:  dc 84 00 00 ld	a0,0(a0)
[ 333] 0x900000001fc03f90:  00 00 00 00 nop
[ 333] 0x900000001fc03f94:  30 84 00 3f andi	a0,a0,0x3f
[ 333] 0x900000001fc03f98:  30 85 00 03 andi	a1,a0,0x3
[ 333] 0x900000001fc03f9c:  00 a0 28 21 addu	a1,a1,0
[ 333] 0x900000001fc03fa0:  00 04 20 82 srl	a0,a0,2
[ 333] 0x900000001fc03fa4:  00 05 d9 80 sll	k1,a1,6
[ 333] 0x900000001fc03fa8:  63 7b 00 20 daddi	k1,k1,32
[ 333] 0x900000001fc03fac:  00 04 d2 c0 sll	k0,a0,11
[ 333] 0x900000001fc03fb0:  3c 01 90 00 lui	at,0x9000
[ 333] 0x900000001fc03fb4:  00 01 0c 38 dsll	at,at,16
[ 333] 0x900000001fc03fb8:  34 21 18 00 ori	at,at,0x1800
[ 333] 0x900000001fc03fbc:  00 01 0c 38 dsll	at,at,16
[ 333] 0x900000001fc03fc0:  34 21 80 00 ori	at,at,0x8000
[ 333] 0x900000001fc03fc4:  03 41 d0 2c dadd	k0,k0,at
[ 333] 0x900000001fc03fc8:  00 1b 20 2c dadd	a0,zero,k1
[ 333] 0x900000001fc03fcc:  00 04 20 c0 sll	a0,a0,3
[ 333] 0x900000001fc03fd0:  03 44 d0 2c dadd	k0,k0,a0
[ 333] 0x900000001fc03fd4:  df 44 00 00 ld	a0,0(k0)
[ 333] 0x900000001fc03fd8:  00 00 00 00 nop
[ 333] 0x900000001fc03fdc:  00 04 27 3a dsrl	a0,a0,28
[ 333] 0x900000001fc03fe0:  30 84 00 0f andi	a0,a0,0xf
  334: 	bne	a0,zero,doCCTestUncached
[ 334] 0x900000001fc03fe4:  14 80 00 11 bne	a0,zero,0x900000001fc0402c
  335: 	nop
[ 335] 0x900000001fc03fe8:  00 00 00 00 nop
  336: doCCTestCached:	
  337: 	dla	a0,testCCtags
[ 337] 0x900000001fc03fec:  3c 04 90 00 lui	a0,0x9000
[ 337] 0x900000001fc03ff0:  64 84 00 00 daddiu	a0,a0,0
[ 337] 0x900000001fc03ff4:  00 04 24 38 dsll	a0,a0,16
[ 337] 0x900000001fc03ff8:  64 84 1f c0 daddiu	a0,a0,8128
[ 337] 0x900000001fc03ffc:  00 04 24 38 dsll	a0,a0,16
[ 337] 0x900000001fc04000:  64 84 28 80 daddiu	a0,a0,10368
  338: 	dla	a1,testCCtags_END
[ 338] 0x900000001fc04004:  3c 05 90 00 lui	a1,0x9000
[ 338] 0x900000001fc04008:  64 a5 00 00 daddiu	a1,a1,0
[ 338] 0x900000001fc0400c:  00 05 2c 38 dsll	a1,a1,16
[ 338] 0x900000001fc04010:  64 a5 1f c0 daddiu	a1,a1,8128
[ 338] 0x900000001fc04014:  00 05 2c 38 dsll	a1,a1,16
[ 338] 0x900000001fc04018:  64 a5 2b 3c daddiu	a1,a1,11068
  339: 	jal	copyToICache
[ 339] 0x900000001fc0401c:  0f f0 0b 99 jal		copyToICache
  340: 	dsubu	a1,a0
[ 340] 0x900000001fc04020:  00 a4 28 2f dsubu	a1,a1,a0
  341: 	b	doCCTest
[ 341] 0x900000001fc04024:  10 00 00 07 b		0x900000001fc04044
  342: 	nop
[ 342] 0x900000001fc04028:  00 00 00 00 nop
  343: doCCTestUncached:
  344: 	dla	v0,testCCtags
[ 344] 0x900000001fc0402c:  3c 02 90 00 lui	v0,0x9000
[ 344] 0x900000001fc04030:  64 42 00 00 daddiu	v0,v0,0
[ 344] 0x900000001fc04034:  00 02 14 38 dsll	v0,v0,16
[ 344] 0x900000001fc04038:  64 42 1f c0 daddiu	v0,v0,8128
[ 344] 0x900000001fc0403c:  00 02 14 38 dsll	v0,v0,16
[ 344] 0x900000001fc04040:  64 42 28 80 daddiu	v0,v0,10368
  345: doCCTest:
  346: 	jal	v0
[ 346] 0x900000001fc04044:  00 40 f8 09 jalr	ra,v0
  347: 	nop
[ 347] 0x900000001fc04048:  00 00 00 00 nop
  348: 	
  349:         beq	zero,v0,1f
[ 349] 0x900000001fc0404c:  10 02 00 05 beq	zero,v0,0x900000001fc04064
  350: 	nop
[ 350] 0x900000001fc04050:  00 00 00 00 nop
  351: 	/*
  352: 	 * Must invalidateCC tags here, because if we put it in the
  353: 	 * slaveDiagDone routine, it may get called if the D-cache
  354: 	 * or I-cache failed. That would not be good.
  355: 	 */
  356: 	jal	invalidateCCtags
[ 356] 0x900000001fc04054:  0f f0 07 ff jal		invalidateCCtags
  357: 	move	s0,v0			/* Save is safe place */
[ 357] 0x900000001fc04058:  00 40 80 25 move	s0,v0
  358: 	b	slaveDiagDone
[ 358] 0x900000001fc0405c:  10 00 00 c2 b		0x900000001fc04368
  359: 	move	v0,s0			/* Restore for slaveDiagDone */
[ 359] 0x900000001fc04060:  02 00 10 25 move	v0,s0
  360: 
  361: 1:
  362:         /*
  363:          * Invalidate all caches and proceed - this must occur even if no 
  364: 	 * diags are requested.
  365: 	 */
  366:         PMESSAGE("Invalidating duplicate tags\r\n");
[ 366] 0x900000001fc04064:  3c 04 90 00 lui	a0,0x9000
[ 366] 0x900000001fc04068:  64 84 00 00 daddiu	a0,a0,0
[ 366] 0x900000001fc0406c:  00 04 24 38 dsll	a0,a0,16
[ 366] 0x900000001fc04070:  64 84 1f c1 daddiu	a0,a0,8129
[ 366] 0x900000001fc04074:  00 04 24 38 dsll	a0,a0,16
[ 366] 0x900000001fc04078:  64 84 78 64 daddiu	a0,a0,30820
[ 366] 0x900000001fc0407c:  0f f0 15 03 jal		pod_puts
[ 366] 0x900000001fc04080:  00 00 00 00 nop
  367:         jal	invalidateCCtags
[ 367] 0x900000001fc04084:  0f f0 07 ff jal		invalidateCCtags
  368:         nop
[ 368] 0x900000001fc04088:  00 00 00 00 nop
  369:         PMESSAGE("Invalidating primary I&D caches\r\n")
[ 369] 0x900000001fc0408c:  3c 04 90 00 lui	a0,0x9000
[ 369] 0x900000001fc04090:  64 84 00 00 daddiu	a0,a0,0
[ 369] 0x900000001fc04094:  00 04 24 38 dsll	a0,a0,16
[ 369] 0x900000001fc04098:  64 84 1f c1 daddiu	a0,a0,8129
[ 369] 0x900000001fc0409c:  00 04 24 38 dsll	a0,a0,16
[ 369] 0x900000001fc040a0:  64 84 78 82 daddiu	a0,a0,30850
[ 369] 0x900000001fc040a4:  0f f0 15 03 jal		pod_puts
[ 369] 0x900000001fc040a8:  00 00 00 00 nop
  370:         li	t1,EVDIAG_INITING_CACHES
[ 370] 0x900000001fc040ac:  24 0d 00 f6 li	t1,246
  371:         sb	t1,CPUDIAGVAL_OFF(s1)
[ 371] 0x900000001fc040b0:  a2 2d 00 0b sb	t1,11(s1)
  372:         jal	invalidateIDcache
[ 372] 0x900000001fc040b4:  0f f0 07 f8 jal		invalidateIDcache
  373:         nop
[ 373] 0x900000001fc040b8:  00 00 00 00 nop
  374:         PMESSAGE("Invalidating secondary cache\r\n")
[ 374] 0x900000001fc040bc:  3c 04 90 00 lui	a0,0x9000
[ 374] 0x900000001fc040c0:  64 84 00 00 daddiu	a0,a0,0
[ 374] 0x900000001fc040c4:  00 04 24 38 dsll	a0,a0,16
[ 374] 0x900000001fc040c8:  64 84 1f c1 daddiu	a0,a0,8129
[ 374] 0x900000001fc040cc:  00 04 24 38 dsll	a0,a0,16
[ 374] 0x900000001fc040d0:  64 84 78 a4 daddiu	a0,a0,30884
[ 374] 0x900000001fc040d4:  0f f0 15 03 jal		pod_puts
[ 374] 0x900000001fc040d8:  00 00 00 00 nop
  375:         li	t1,EVDIAG_INITING_SCACHE
[ 375] 0x900000001fc040dc:  24 0d 00 f7 li	t1,247
  376:         sb	t1,CPUDIAGVAL_OFF(s1)
[ 376] 0x900000001fc040e0:  a2 2d 00 0b sb	t1,11(s1)
  377: 	jal	invalidateScache
[ 377] 0x900000001fc040e4:  0f f0 08 c3 jal		invalidateScache
  378: 	nop
[ 378] 0x900000001fc040e8:  00 00 00 00 nop
  379: 	PMESSAGE("Checking EROTIP\r\n");
[ 379] 0x900000001fc040ec:  3c 04 90 00 lui	a0,0x9000
[ 379] 0x900000001fc040f0:  64 84 00 00 daddiu	a0,a0,0
[ 379] 0x900000001fc040f4:  00 04 24 38 dsll	a0,a0,16
[ 379] 0x900000001fc040f8:  64 84 1f c1 daddiu	a0,a0,8129
[ 379] 0x900000001fc040fc:  00 04 24 38 dsll	a0,a0,16
[ 379] 0x900000001fc04100:  64 84 78 c3 daddiu	a0,a0,30915
[ 379] 0x900000001fc04104:  0f f0 15 03 jal		pod_puts
[ 379] 0x900000001fc04108:  00 00 00 00 nop
  380: 	dli	a0,EV_ERTOIP
[ 380] 0x900000001fc0410c:  3c 04 90 00 lui	a0,0x9000
[ 380] 0x900000001fc04110:  00 04 24 38 dsll	a0,a0,16
[ 380] 0x900000001fc04114:  34 84 18 00 ori	a0,a0,0x1800
[ 380] 0x900000001fc04118:  00 04 24 38 dsll	a0,a0,16
[ 380] 0x900000001fc0411c:  34 84 09 00 ori	a0,a0,0x900
  381: 	ld	a1,0(a0)
[ 381] 0x900000001fc04120:  dc 85 00 00 ld	a1,0(a0)
  382: 	and	a1,0xffffffff
[ 382] 0x900000001fc04124:  24 01 ff ff li	at,-1
[ 382] 0x900000001fc04128:  00 01 08 3e dsrl32	at,at,0
[ 382] 0x900000001fc0412c:  00 a1 28 24 and	a1,a1,at
  383: 	beqz	a1,1f			/* All clear */
[ 383] 0x900000001fc04130:  10 a0 00 29 beq	a1,zero,0x900000001fc041d8
  384: 	nop
[ 384] 0x900000001fc04134:  00 00 00 00 nop
  385: 	dli	a1,0xffffffff
[ 385] 0x900000001fc04138:  24 05 ff ff li	a1,-1
[ 385] 0x900000001fc0413c:  00 05 28 3e dsrl32	a1,a1,0
  386: 	dli	a2,EV_CERTOIP
[ 386] 0x900000001fc04140:  3c 06 90 00 lui	a2,0x9000
[ 386] 0x900000001fc04144:  00 06 34 38 dsll	a2,a2,16
[ 386] 0x900000001fc04148:  34 c6 18 00 ori	a2,a2,0x1800
[ 386] 0x900000001fc0414c:  00 06 34 38 dsll	a2,a2,16
[ 386] 0x900000001fc04150:  34 c6 09 08 ori	a2,a2,0x908
  387: 	sd	a1,0(a2)
[ 387] 0x900000001fc04154:  fc c5 00 00 sd	a1,0(a2)
  388: 	ld	a1,0(a0)
[ 388] 0x900000001fc04158:  dc 85 00 00 ld	a1,0(a0)
  389: 	
  390: 	beqz	a1,1f			/* All clear now */
[ 390] 0x900000001fc0415c:  10 a0 00 1e beq	a1,zero,0x900000001fc041d8
  391: 	move	s2,zero			/* diag value */
[ 391] 0x900000001fc04160:  00 00 90 25 move	s2,zero
  392: 	/*
  393: 	 * Regardless of recoverability, we save away the ERTOIP
  394: 	 * for reporting. This over-rides the ertoip saved on
  395: 	 * reset - but thats ok since we are still having problems.
  396: 	 */
  397: 	DMTBR(a1, BR_ERTOIP)
[ 397] 0x900000001fc04164:  44 a5 20 00 dmtc1	a1,$f4
  398: 	
  399: 	/*
  400: 	 * Check if the error bits set are recoverable. Basically,
  401: 	 * we can handle singe bit errors on the sysad.
  402: 	 */
  403: #       define	ECC	(IP25_CC_ERROR_SBE_SYSAD\
  404: 			| IP25_CC_ERROR_SBE_INTR \
  405: 			| IP25_CC_ERROR_ME)
  406: 	li	a0,~ECC
[ 406] 0x900000001fc04168:  3c 04 ff ed lui	a0,0xffed
[ 406] 0x900000001fc0416c:  34 84 ff fb ori	a0,a0,0xfffb
  407: 	and	a0,a1
[ 407] 0x900000001fc04170:  00 85 20 24 and	a0,a0,a1
  408: 	bnez	a0,slaveDiagDone
[ 408] 0x900000001fc04174:  14 80 00 7c bne	a0,zero,0x900000001fc04368
  409: 	ori	s2,zero,EVDIAG_ERTOIP
[ 409] 0x900000001fc04178:  34 12 00 81 ori	s2,zero,0x81
  410: 
  411: 	/*
  412: 	 * Bits set are recoverable, so disable reporting of them.
  413: 	 * Then, set the diag value and continue. Be sure to
  414: 	 * write CERTOIP register after disabling the correctable errors
  415: 	 * in case the act of writting them also causes and error.
  416: 	 */
  417: 
  418: 	dli	a0,EV_ECCSB
[ 418] 0x900000001fc0417c:  3c 04 90 00 lui	a0,0x9000
[ 418] 0x900000001fc04180:  00 04 24 38 dsll	a0,a0,16
[ 418] 0x900000001fc04184:  34 84 18 00 ori	a0,a0,0x1800
[ 418] 0x900000001fc04188:  00 04 24 38 dsll	a0,a0,16
[ 418] 0x900000001fc0418c:  34 84 09 10 ori	a0,a0,0x910
  419: 	ld	a1,0(a0)
[ 419] 0x900000001fc04190:  dc 85 00 00 ld	a1,0(a0)
  420: 	ori	a1,EV_ECCSB_DSBECC
[ 420] 0x900000001fc04194:  34 a5 00 01 ori	a1,a1,0x1
  421: 	sd	a1,0(a0)
[ 421] 0x900000001fc04198:  fc 85 00 00 sd	a1,0(a0)
  422: 	dli	a0,EV_CERTOIP		/* Clear the ones we can handle */
[ 422] 0x900000001fc0419c:  3c 04 90 00 lui	a0,0x9000
[ 422] 0x900000001fc041a0:  00 04 24 38 dsll	a0,a0,16
[ 422] 0x900000001fc041a4:  34 84 18 00 ori	a0,a0,0x1800
[ 422] 0x900000001fc041a8:  00 04 24 38 dsll	a0,a0,16
[ 422] 0x900000001fc041ac:  34 84 09 08 ori	a0,a0,0x908
  423: 	li	a1,ECC
[ 423] 0x900000001fc041b0:  3c 05 00 12 lui	a1,0x12
[ 423] 0x900000001fc041b4:  34 a5 00 04 ori	a1,a1,0x4
  424: 	sd	a1,0(a0)
[ 424] 0x900000001fc041b8:  fc 85 00 00 sd	a1,0(a0)
  425: 	dli	a0,EV_ERTOIP		/* Be sure to stall long enough */
[ 425] 0x900000001fc041bc:  3c 04 90 00 lui	a0,0x9000
[ 425] 0x900000001fc041c0:  00 04 24 38 dsll	a0,a0,16
[ 425] 0x900000001fc041c4:  34 84 18 00 ori	a0,a0,0x1800
[ 425] 0x900000001fc041c8:  00 04 24 38 dsll	a0,a0,16
[ 425] 0x900000001fc041cc:  34 84 09 00 ori	a0,a0,0x900
  426: 	ld	zero,0(a0)		
[ 426] 0x900000001fc041d0:  dc 80 00 00 ld	zero,0(a0)
  427: 	li	s2,EVDIAG_ERTOIP_COR	/* Onward - with a diag code */
[ 427] 0x900000001fc041d4:  24 12 00 82 li	s2,130
  428: 1:	
  429: 	# init processor's MPCONF block
  430: 
  431: 	LEDS(PLED_WRCONFIG)
[ 431] 0x900000001fc041d8:  00 00 00 00 nop
[ 431] 0x900000001fc041dc:  34 04 00 2d ori	a0,zero,0x2d
[ 431] 0x900000001fc041e0:  3c 02 90 00 lui	v0,0x9000
[ 431] 0x900000001fc041e4:  00 02 14 38 dsll	v0,v0,16
[ 431] 0x900000001fc041e8:  34 42 19 00 ori	v0,v0,0x1900
[ 431] 0x900000001fc041ec:  00 02 14 38 dsll	v0,v0,16
[ 431] 0x900000001fc041f0:  34 42 40 00 ori	v0,v0,0x4000
[ 431] 0x900000001fc041f4:  fc 44 00 00 sd	a0,0(v0)
  432: 	PMESSAGE("Initializing this processor's MPCONF block\r\n")
[ 432] 0x900000001fc041f8:  3c 04 90 00 lui	a0,0x9000
[ 432] 0x900000001fc041fc:  64 84 00 00 daddiu	a0,a0,0
[ 432] 0x900000001fc04200:  00 04 24 38 dsll	a0,a0,16
[ 432] 0x900000001fc04204:  64 84 1f c1 daddiu	a0,a0,8129
[ 432] 0x900000001fc04208:  00 04 24 38 dsll	a0,a0,16
[ 432] 0x900000001fc0420c:  64 84 78 d5 daddiu	a0,a0,30933
[ 432] 0x900000001fc04210:  0f f0 15 03 jal		pod_puts
[ 432] 0x900000001fc04214:  00 00 00 00 nop
  433: 
  434: 	dla	a0, prom_versnum	# Get address of prom rev num
[ 434] 0x900000001fc04218:  3c 04 90 00 lui	a0,0x9000
[ 434] 0x900000001fc0421c:  64 84 00 00 daddiu	a0,a0,0
[ 434] 0x900000001fc04220:  00 04 24 38 dsll	a0,a0,16
[ 434] 0x900000001fc04224:  64 84 1f c2 daddiu	a0,a0,8130
[ 434] 0x900000001fc04228:  00 04 24 38 dsll	a0,a0,16
[ 434] 0x900000001fc0422c:  64 84 9a 18 daddiu	a0,a0,-26088
  435: 	jal	get_char		# Get value.
[ 435] 0x900000001fc04230:  0f f0 0d 88 jal		get_char
  436: 	nop				# (BD)
[ 436] 0x900000001fc04234:  00 00 00 00 nop
  437:         sb	v0, CPUPROMREV_OFF(s1)	# Record our prom revision
[ 437] 0x900000001fc04238:  a2 22 00 0f sb	v0,15(s1)
  438: 
  439: 	li	t1, EVDIAG_WRCPUINFO	# Tell the master we're writing.
[ 439] 0x900000001fc0423c:  24 0d 00 f0 li	t1,240
  440: 	sb	t1, CPUDIAGVAL_OFF(s1)
[ 440] 0x900000001fc04240:  a2 2d 00 0b sb	t1,11(s1)
  441: 
  442:         jal	initCPUSpeed
[ 442] 0x900000001fc04244:  0f f0 0d 2c jal		initCPUSpeed
  443:         nop
[ 443] 0x900000001fc04248:  00 00 00 00 nop
  444:         sb	v0, CPUSPEED_OFF(s1)
[ 444] 0x900000001fc0424c:  a2 22 00 0d sb	v0,13(s1)
  445: 
  446: 	jal	get_mpconf		# Find this processor's MPCONF block 
[ 446] 0x900000001fc04250:  0f f0 11 58 jal		get_mpconf
  447: 	nop				# (BD)
[ 447] 0x900000001fc04254:  00 00 00 00 nop
  448: 	move	t0, v0
[ 448] 0x900000001fc04258:  00 40 60 25 move	t0,v0
  449: 
  450: 	DPRINT("Doing basic initialization\r\n")
  451: 
  452:         li	t1, EV_CPU_R10000	# Get cpu type value
[ 452] 0x900000001fc0425c:  24 0d 00 03 li	t1,3
  453:         sb	t1, MP_PROCTYPE(t0)     # Store in MPCONF struct
[ 453] 0x900000001fc04260:  a1 8d 00 0b sb	t1,11(t0)
  454: 	DMFC0(v0, C0_PRID)		# Get out implementation/revision num
[ 454] 0x900000001fc04264:  40 22 78 00 dmfc0	v0,prid
  455: 	sw	v0, MP_PRID(t0)		# Save PRID value
[ 455] 0x900000001fc04268:  ad 82 00 34 sw	v0,52(t0)
  456:         sb	zero, MP_ERRNO(t0)      # Clear errno field
[ 456] 0x900000001fc0426c:  a1 80 00 0a sb	zero,10(t0)
  457: 
  458:         sw	zero, MP_LAUNCHOFF(t0)  # Clear launch vector
[ 458] 0x900000001fc04270:  ad 80 00 0c sw	zero,12(t0)
  459:         sw	zero, MP_RNDVZOFF(t0)   # Clear the rendezvous field
[ 459] 0x900000001fc04274:  ad 80 00 10 sw	zero,16(t0)
  460: 					# Use t2 and t3 as temp registers
  461:         sw	zero, MP_BEVUTLB(t0)    # 
[ 461] 0x900000001fc04278:  ad 80 00 14 sw	zero,20(t0)
  462:         sw	zero, MP_BEVNORMAL(t0)  #
[ 462] 0x900000001fc0427c:  ad 80 00 18 sw	zero,24(t0)
  463: 
  464: 	EV_GET_SPNUM(t2, t1)            # t2 gets slot/t1 gets proc
[ 464] 0x900000001fc04280:  3c 0e 90 00 lui	t2,0x9000
[ 464] 0x900000001fc04284:  00 0e 74 38 dsll	t2,t2,16
[ 464] 0x900000001fc04288:  35 ce 18 00 ori	t2,t2,0x1800
[ 464] 0x900000001fc0428c:  00 0e 74 38 dsll	t2,t2,16
[ 464] 0x900000001fc04290:  35 ce 00 08 ori	t2,t2,0x8
[ 464] 0x900000001fc04294:  dd ce 00 00 ld	t2,0(t2)
[ 464] 0x900000001fc04298:  00 00 00 00 nop
[ 464] 0x900000001fc0429c:  31 ce 00 3f andi	t2,t2,0x3f
[ 464] 0x900000001fc042a0:  31 cd 00 03 andi	t1,t2,0x3
[ 464] 0x900000001fc042a4:  01 a0 68 21 addu	t1,t1,0
[ 464] 0x900000001fc042a8:  00 0e 70 82 srl	t2,t2,2
  465: 	EV_GET_PROCREG(t2, t1, EV_CFG_CACHE_SZ, t1) # Get scache size
[ 465] 0x900000001fc042ac:  00 0d d9 80 sll	k1,t1,6
[ 465] 0x900000001fc042b0:  63 7b 00 3e daddi	k1,k1,62
[ 465] 0x900000001fc042b4:  00 0e d2 c0 sll	k0,t2,11
[ 465] 0x900000001fc042b8:  3c 01 90 00 lui	at,0x9000
[ 465] 0x900000001fc042bc:  00 01 0c 38 dsll	at,at,16
[ 465] 0x900000001fc042c0:  34 21 18 00 ori	at,at,0x1800
[ 465] 0x900000001fc042c4:  00 01 0c 38 dsll	at,at,16
[ 465] 0x900000001fc042c8:  34 21 80 00 ori	at,at,0x8000
[ 465] 0x900000001fc042cc:  03 41 d0 2c dadd	k0,k0,at
[ 465] 0x900000001fc042d0:  00 1b 68 2c dadd	t1,zero,k1
[ 465] 0x900000001fc042d4:  00 0d 68 c0 sll	t1,t1,3
[ 465] 0x900000001fc042d8:  03 4d d0 2c dadd	k0,k0,t1
[ 465] 0x900000001fc042dc:  df 4d 00 00 ld	t1,0(k0)
[ 465] 0x900000001fc042e0:  00 00 00 00 nop
  466: 	andi	t1, 0x1f
[ 466] 0x900000001fc042e4:  31 ad 00 1f andi	t1,t1,0x1f
  467: 	dsll	t1, 2			# Word (4-byte) sized entries
[ 467] 0x900000001fc042e8:  00 0d 68 b8 dsll	t1,t1,2
  468: 	dla	t2, log2vals		# Conert to log2 format
[ 468] 0x900000001fc042ec:  3c 0e 90 00 lui	t2,0x9000
[ 468] 0x900000001fc042f0:  65 ce 00 00 daddiu	t2,t2,0
[ 468] 0x900000001fc042f4:  00 0e 74 38 dsll	t2,t2,16
[ 468] 0x900000001fc042f8:  65 ce 1f c2 daddiu	t2,t2,8130
[ 468] 0x900000001fc042fc:  00 0e 74 38 dsll	t2,t2,16
[ 468] 0x900000001fc04300:  65 ce 96 08 daddiu	t2,t2,-27128
  469: 	daddu	t2, t1			# by reading from log2 table
[ 469] 0x900000001fc04304:  01 cd 70 2d daddu	t2,t2,t1
  470: 	lw	t1, 0(t2)		# using register content as index
[ 470] 0x900000001fc04308:  8d cd 00 00 lw	t1,0(t2)
  471:         sw	t1, MP_SCACHESZ(t0)     # Write secondary cache size to MPCONF
[ 471] 0x900000001fc0430c:  ad 8d 00 20 sw	t1,32(t0)
  472: 	sb	t1, CPUCACHE_OFF(s1)
[ 472] 0x900000001fc04310:  a2 2d 00 0e sb	t1,14(s1)
  473: 
  474: 	dli	t2, EV_SPNUM		# Load the SPNUM address
[ 474] 0x900000001fc04314:  3c 0e 90 00 lui	t2,0x9000
[ 474] 0x900000001fc04318:  00 0e 74 38 dsll	t2,t2,16
[ 474] 0x900000001fc0431c:  35 ce 18 00 ori	t2,t2,0x1800
[ 474] 0x900000001fc04320:  00 0e 74 38 dsll	t2,t2,16
[ 474] 0x900000001fc04324:  35 ce 00 08 ori	t2,t2,0x8
  475: 	ld	t1, 0(t2)		# Read the SPNUM
[ 475] 0x900000001fc04328:  dd cd 00 00 ld	t1,0(t2)
  476: 	andi	t1, EV_SPNUM_MASK
[ 476] 0x900000001fc0432c:  31 ad 00 3f andi	t1,t1,0x3f
  477: 	sb	t1, MP_PHYSID(t0)	# Write the physical ID
[ 477] 0x900000001fc04330:  a1 8d 00 08 sb	t1,8(t0)
  478: 
  479: 	DPRINT("More init\r\n")
  480: 
  481:         dli	t1, MPCONF_MAGIC        # Get the magic number
[ 481] 0x900000001fc04334:  34 0d ba dd ori	t1,zero,0xbadd
[ 481] 0x900000001fc04338:  00 0d 6c 38 dsll	t1,t1,16
[ 481] 0x900000001fc0433c:  35 ad ee d2 ori	t1,t1,0xeed2
  482:         sw	t1, MP_MAGICOFF(t0)     # Store the magic number
[ 482] 0x900000001fc04340:  ad 8d 00 00 sw	t1,0(t0)
  483: 
  484: 	lb	t1, CPUVPID_OFF(s1)	# Get the virtual processor ID
[ 484] 0x900000001fc04344:  82 2d 00 0c lb	t1,12(s1)
  485: 	sb	t1, MP_VIRTID(t0)	# Write it to the MPCONF block
[ 485] 0x900000001fc04348:  a1 8d 00 09 sb	t1,9(t0)
  486: 
  487: 	DMFBR(t1, BR_ERTOIP)		/* Reset/Boot ERTOIP value */
[ 487] 0x900000001fc0434c:  44 2d 20 00 dmfc1	t1,$f4
  488: 	sw	t1, MP_ERTOIP(t0)
[ 488] 0x900000001fc04350:  ad 8d 00 14 sw	t1,20(t0)
  489:  
  490: 	/* if we've abdicated write the reason in DIAGVAL */
  491: 
  492: 	DMFBR(t1, BR_BSR)
[ 492] 0x900000001fc04354:  44 2d 00 00 dmfc1	t1,$f0
  493: 	andi	t1, BSR_ABDICATE
[ 493] 0x900000001fc04358:  31 ad 20 00 andi	t1,t1,0x2000
  494: 	beqz	t1, 1f
[ 494] 0x900000001fc0435c:  11 a0 00 02 beq	t1,zero,0x900000001fc04368
  495: 	nop				# (BD)
[ 495] 0x900000001fc04360:  00 00 00 00 nop
  496: 
  497:         DMFBR(s2, BR_DIAG)
[ 497] 0x900000001fc04364:  44 32 28 00 dmfc1	s2,$f5
  498: 1:
  499: 
  500: slaveDiagDone:
  501: 	/*
  502:          * Diag failed, error code in s2 - store it into diag result, 
  503:          * and go back to polling.
  504:          */
  505:         sb	s2,CPUDIAGVAL_OFF(s1)
[ 505] 0x900000001fc04368:  a2 32 00 0b sb	s2,11(s1)
  506:         li 	t0, MPCONF_INIT_LEVEL
[ 506] 0x900000001fc0436c:  24 0c 00 07 li	t0,7
  507:         dli	t1, EV_CIPL0 
[ 507] 0x900000001fc04370:  3c 0d 90 00 lui	t1,0x9000
[ 507] 0x900000001fc04374:  00 0d 6c 38 dsll	t1,t1,16
[ 507] 0x900000001fc04378:  35 ad 18 00 ori	t1,t1,0x1800
[ 507] 0x900000001fc0437c:  00 0d 6c 38 dsll	t1,t1,16
[ 507] 0x900000001fc04380:  35 ad 08 30 ori	t1,t1,0x830
  508:         sd	t0, 0(t1)		/* Clear pending interrupt */
[ 508] 0x900000001fc04384:  fd ac 00 00 sd	t0,0(t1)
  509: 	jal	invalidateScache
[ 509] 0x900000001fc04388:  0f f0 08 c3 jal		invalidateScache
  510: 	nop
[ 510] 0x900000001fc0438c:  00 00 00 00 nop
  511: 	jal	invalidateIcache
[ 511] 0x900000001fc04390:  0f f0 07 a9 jal		invalidateIcache
  512: 	nop
[ 512] 0x900000001fc04394:  00 00 00 00 nop
  513: 	jal	invalidateDcache
[ 513] 0x900000001fc04398:  0f f0 07 d0 jal		invalidateDcache
  514: 	nop
[ 514] 0x900000001fc0439c:  00 00 00 00 nop
  515: 	
  516:         DPRINT("Return to slave loop ...\r\n");
  517:         b	SlaveLoop
[ 517] 0x900000001fc043a0:  10 00 fe 19 b		0x900000001fc03c08
  518:         nop
[ 518] 0x900000001fc043a4:  00 00 00 00 nop
  519:          
  520: 	/*
  521:  	 * Launch using the MPCONF block
  522: 	 */
  523: mpconf_launch:
  524: 	# Set the LED to the launch value
  525: 	#
  526: 	LEDS(PLED_PROMJUMP)
[ 526] 0x900000001fc043a8:  00 00 00 00 nop
[ 526] 0x900000001fc043ac:  34 04 00 29 ori	a0,zero,0x29
[ 526] 0x900000001fc043b0:  3c 02 90 00 lui	v0,0x9000
[ 526] 0x900000001fc043b4:  00 02 14 38 dsll	v0,v0,16
[ 526] 0x900000001fc043b8:  34 42 19 00 ori	v0,v0,0x1900
[ 526] 0x900000001fc043bc:  00 02 14 38 dsll	v0,v0,16
[ 526] 0x900000001fc043c0:  34 42 40 00 ori	v0,v0,0x4000
[ 526] 0x900000001fc043c4:  fc 44 00 00 sd	a0,0(v0)
  527: 
  528: 	DPRINT("Calling MPCONF launch...\r\n")
  529: 
  530: 	# Invalidate the caches
  531:         jal	invalidateCCtags
[ 531] 0x900000001fc043c8:  0f f0 07 ff jal		invalidateCCtags
  532:         nop
[ 532] 0x900000001fc043cc:  00 00 00 00 nop
  533:         jal	invalidateScache
[ 533] 0x900000001fc043d0:  0f f0 08 c3 jal		invalidateScache
  534:         nop
[ 534] 0x900000001fc043d4:  00 00 00 00 nop
  535: 	jal	invalidateIDcache
[ 535] 0x900000001fc043d8:  0f f0 07 f8 jal		invalidateIDcache
  536: 	nop
[ 536] 0x900000001fc043dc:  00 00 00 00 nop
  537: 
  538: 	#	
  539: 	# Read MPCONF for function, parameter, and stack
  540: 	#	
  541: 	jal	get_mpconf		# Find this processor's MPCONF block 
[ 541] 0x900000001fc043e0:  0f f0 11 58 jal		get_mpconf
  542: 	nop				# (SD)
[ 542] 0x900000001fc043e4:  00 00 00 00 nop
  543: 	lw	t0, MP_MAGICOFF(v0)	# Make sure that MPCONF block is valid
[ 543] 0x900000001fc043e8:  8c 4c 00 00 lw	t0,0(v0)
  544: 	lui	t1, MPCONF_MAGIC >> 16	# Load proper magic number
[ 544] 0x900000001fc043ec:  3c 0d ba dd lui	t1,0xbadd
  545:         ori	t1, MPCONF_MAGIC & 0xffff
[ 545] 0x900000001fc043f0:  35 ad ee d2 ori	t1,t1,0xeed2
  546: 	beq	t0, t1, 1f		# IF magic number is bogus THEN
[ 546] 0x900000001fc043f4:  11 8d 00 03 beq	t0,t1,0x900000001fc04404
  547: 	nop				# (bd)
[ 547] 0x900000001fc043f8:  00 00 00 00 nop
  548: 	DPRINT("Invalid MPCONF block\r\n")
  549: 	b	3f
[ 549] 0x900000001fc043fc:  10 00 00 2f b		0x900000001fc044bc
  550: 	nop				# ENDIF
[ 550] 0x900000001fc04400:  00 00 00 00 nop
  551: 1:	
  552: 	lw	t0, MP_LAUNCHOFF(v0)	# Load the address of the launch func
[ 552] 0x900000001fc04404:  8c 4c 00 0c lw	t0,12(v0)
  553: 	nop
[ 553] 0x900000001fc04408:  00 00 00 00 nop
  554: 
  555: 	lw	t1, MP_LPARM(v0)	# Load the parameter
[ 555] 0x900000001fc0440c:  8c 4d 00 2c lw	t1,44(v0)
  556: 	nop
[ 556] 0x900000001fc04410:  00 00 00 00 nop
  557: 	ld	sp, MP_REAL_SP(v0)	# Load the stack
[ 557] 0x900000001fc04414:  dc 5d 00 38 ld	sp,56(v0)
  558: 	nop
[ 558] 0x900000001fc04418:  00 00 00 00 nop
  559: 
  560: 	beq	t0, zero, 2f		# Skip launch if address is zero
[ 560] 0x900000001fc0441c:  11 80 00 11 beq	t0,zero,0x900000001fc04464
  561: 	nop
[ 561] 0x900000001fc04420:  00 00 00 00 nop
  562: 
  563: 	#
  564: 	# Convert the address in t0 into a real 64-bit address.
  565: 	# 	Use t1 and a0 as temp regs.
  566: 	#
  567: 	K32TOKPHYS(t0, t1, a0)
[ 567] 0x900000001fc04424:  3c 0d 20 00 lui	t1,0x2000
[ 567] 0x900000001fc04428:  01 ac 68 24 and	t1,t1,t0
[ 567] 0x900000001fc0442c:  3c 04 e0 00 lui	a0,0xe000
[ 567] 0x900000001fc04430:  00 80 20 27 nor	a0,a0,zero
[ 567] 0x900000001fc04434:  11 a0 00 04 beq	t1,zero,0x900000001fc04448
[ 567] 0x900000001fc04438:  01 84 60 24 and	t0,t0,a0
[ 567] 0x900000001fc0443c:  3c 0d 90 00 lui	t1,0x9000
[ 567] 0x900000001fc04440:  10 00 00 02 b		0x900000001fc0444c
[ 567] 0x900000001fc04444:  00 00 00 00 nop
[ 567] 0x900000001fc04448:  3c 0d a8 00 lui	t1,0xa800
[ 567] 0x900000001fc0444c:  00 0d 68 3c dsll32	t1,t1,0
[ 567] 0x900000001fc04450:  01 8d 60 25 or	t0,t0,t1
  568: 
  569: 	jal	t0			# Call the subroutine
[ 569] 0x900000001fc04454:  01 80 f8 09 jalr	ra,t0
  570: 	move	a0, t1
[ 570] 0x900000001fc04458:  01 a0 20 25 move	a0,t1
  571: 
  572: 	#
  573: 	# Reload the MPCONF, since values may have been trashed
  574: 	#
  575: 	jal	get_mpconf		# Reload MPCONF addr
[ 575] 0x900000001fc0445c:  0f f0 11 58 jal		get_mpconf
  576: 	nop
[ 576] 0x900000001fc04460:  00 00 00 00 nop
  577: 2:
  578: 	lw	t0, MP_RNDVZOFF(v0)	# Load the rendezvous address
[ 578] 0x900000001fc04464:  8c 4c 00 10 lw	t0,16(v0)
  579: 	nop
[ 579] 0x900000001fc04468:  00 00 00 00 nop
  580: 
  581: 	lw	t1, MP_RPARM(v0)	# Load the rendezvous parameter
[ 581] 0x900000001fc0446c:  8c 4d 00 30 lw	t1,48(v0)
  582: 	nop
[ 582] 0x900000001fc04470:  00 00 00 00 nop
  583: 	ld	sp, MP_REAL_SP(v0)	# Reload the stack address
[ 583] 0x900000001fc04474:  dc 5d 00 38 ld	sp,56(v0)
  584: 	nop
[ 584] 0x900000001fc04478:  00 00 00 00 nop
  585: 
  586: 	beq	t0, zero, 3f		# Skip the rendezvous func if zero
[ 586] 0x900000001fc0447c:  11 80 00 0f beq	t0,zero,0x900000001fc044bc
  587: 	nop				# (BD)
[ 587] 0x900000001fc04480:  00 00 00 00 nop
  588: 	
  589: 	DPRINT("Calling MPCONF rendezvous routine.\r\n")
  590: 
  591: 	#
  592: 	# Convert the rendezvous function pointer into a real 64-bit address
  593: 	# 	Use t2 and t3 as temp registers.
  594: 	#
  595: 	K32TOKPHYS(t0, t2, t3)
[ 595] 0x900000001fc04484:  3c 0e 20 00 lui	t2,0x2000
[ 595] 0x900000001fc04488:  01 cc 70 24 and	t2,t2,t0
[ 595] 0x900000001fc0448c:  3c 0f e0 00 lui	t3,0xe000
[ 595] 0x900000001fc04490:  01 e0 78 27 nor	t3,t3,zero
[ 595] 0x900000001fc04494:  11 c0 00 04 beq	t2,zero,0x900000001fc044a8
[ 595] 0x900000001fc04498:  01 8f 60 24 and	t0,t0,t3
[ 595] 0x900000001fc0449c:  3c 0e 90 00 lui	t2,0x9000
[ 595] 0x900000001fc044a0:  10 00 00 02 b		0x900000001fc044ac
[ 595] 0x900000001fc044a4:  00 00 00 00 nop
[ 595] 0x900000001fc044a8:  3c 0e a8 00 lui	t2,0xa800
[ 595] 0x900000001fc044ac:  00 0e 70 3c dsll32	t2,t2,0
[ 595] 0x900000001fc044b0:  01 8e 60 25 or	t0,t0,t2
  596: 
  597: 	jal	t0			# Call the rendezvous function
[ 597] 0x900000001fc044b4:  01 80 f8 09 jalr	ra,t0
  598: 	move	a0, t1			# (BD)		
[ 598] 0x900000001fc044b8:  01 a0 20 25 move	a0,t1
  599: 3:
  600: 	dli	t0, EV_ILE
[ 600] 0x900000001fc044bc:  3c 0c 90 00 lui	t0,0x9000
[ 600] 0x900000001fc044c0:  00 0c 64 38 dsll	t0,t0,16
[ 600] 0x900000001fc044c4:  35 8c 18 00 ori	t0,t0,0x1800
[ 600] 0x900000001fc044c8:  00 0c 64 38 dsll	t0,t0,16
[ 600] 0x900000001fc044cc:  35 8c 08 40 ori	t0,t0,0x840
  601: 	sd	zero, 0(t0)
[ 601] 0x900000001fc044d0:  fd 80 00 00 sd	zero,0(t0)
  602: 	dli	t1, PROM_SR
[ 602] 0x900000001fc044d4:  3c 0d 24 40 lui	t1,0x2440
[ 602] 0x900000001fc044d8:  35 ad 00 80 ori	t1,t1,0x80
  603: 	MTC0(t1, C0_SR)
[ 603] 0x900000001fc044dc:  40 8d 60 00 mtc0	t1,sr
  604: 
  605: 	li	t0, MPCONF_LAUNCH_LEVEL
[ 605] 0x900000001fc044e0:  24 0c 00 08 li	t0,8
  606: 	dli	t1, EV_CIPL0
[ 606] 0x900000001fc044e4:  3c 0d 90 00 lui	t1,0x9000
[ 606] 0x900000001fc044e8:  00 0d 6c 38 dsll	t1,t1,16
[ 606] 0x900000001fc044ec:  35 ad 18 00 ori	t1,t1,0x1800
[ 606] 0x900000001fc044f0:  00 0d 6c 38 dsll	t1,t1,16
[ 606] 0x900000001fc044f4:  35 ad 08 30 ori	t1,t1,0x830
  607: 	b	SlaveLoop
[ 607] 0x900000001fc044f8:  10 00 fd c3 b		0x900000001fc03c08
  608: 	sd	t0, 0(t1)
[ 608] 0x900000001fc044fc:  fd ac 00 00 sd	t0,0(t1)
  609: 
  610: 	END(prom_slave)	
  611: 
  612: 
  613: /* 
  614:  * get_cpuinfo
  615:  *	Returns the address of the evcfginfo cpu information structre
  616:  *	in v0.
  617:  *	Uses registers t0, t1, t2, v0.
  618:  */
  619: LEAF(get_cpuinfo)
  620: 	dli	t0, EV_SPNUM	     	# Load the SPNUM addr 
get_cpuinfo:
[ 620] 0x900000001fc04500:  3c 0c 90 00 lui	t0,0x9000
[ 620] 0x900000001fc04504:  00 0c 64 38 dsll	t0,t0,16
[ 620] 0x900000001fc04508:  35 8c 18 00 ori	t0,t0,0x1800
[ 620] 0x900000001fc0450c:  00 0c 64 38 dsll	t0,t0,16
[ 620] 0x900000001fc04510:  35 8c 00 08 ori	t0,t0,0x8
  621: 	ld      t0, 0(t0)		# Read slot and proc
[ 621] 0x900000001fc04514:  dd 8c 00 00 ld	t0,0(t0)
  622: 	li      t1, CPUINFO_SIZE	# Load the size of the CPUINFO struct
[ 622] 0x900000001fc04518:  24 0d 00 10 li	t1,16
  623: 	and     t2, t0, EV_PROCNUM_MASK # Mask out the processor number
[ 623] 0x900000001fc0451c:  31 8e 00 03 andi	t2,t0,0x3
  624: 	srl	t2, EV_PROCNUM_SHFT	# Grab the slice number
[ 624] 0x900000001fc04520:  01 c0 70 21 addu	t2,t2,0
  625: 	multu   t2, t1		    	# offset1 = proc# * CPU_INFO size
[ 625] 0x900000001fc04524:  01 cd 00 19 multu	t2,t1
  626: 	nop				#
[ 626] 0x900000001fc04528:  00 00 00 00 nop
  627: 	mflo    t2			# Result of multiply
[ 627] 0x900000001fc0452c:  00 00 70 12 mflo	t2
  628: 	and     t1, t0, EV_SLOTNUM_MASK #
[ 628] 0x900000001fc04530:  31 8d 00 3c andi	t1,t0,0x3c
  629: 	srl     t1, EV_SLOTNUM_SHFT     # Grab the slot number
[ 629] 0x900000001fc04534:  00 0d 68 82 srl	t1,t1,2
  630: 	li      t0, BRDINFO_SIZE	# Load the BRDINFO size
[ 630] 0x900000001fc04538:  24 0c 00 6c li	t0,108
  631: 	multu   t1, t0		    	# offset2 = slot# * BRDINFO_SIZE
[ 631] 0x900000001fc0453c:  01 ac 00 19 multu	t1,t0
  632: 	nop				#
[ 632] 0x900000001fc04540:  00 00 00 00 nop
  633: 	mflo    v0			# offset2 = Result of multiply
[ 633] 0x900000001fc04544:  00 00 10 12 mflo	v0
  634: 	addu    v0, t2		    	# Add offsets
[ 634] 0x900000001fc04548:  00 4e 10 21 addu	v0,v0,t2
  635: 	dli	t1, EVCFGINFO_ADDR      # Grab the base config address
[ 635] 0x900000001fc0454c:  3c 0d 90 00 lui	t1,0x9000
[ 635] 0x900000001fc04550:  00 0d 68 3c dsll32	t1,t1,0
[ 635] 0x900000001fc04554:  35 ad 20 00 ori	t1,t1,0x2000
  636: 	j	ra			# Return
[ 636] 0x900000001fc04558:  03 e0 00 08 jr	ra
  637: 	daddu	v0, t1		    	# (BD) Add offsets to get final base
[ 637] 0x900000001fc0455c:  00 4d 10 2d daddu	v0,v0,t1
  638: 	END(get_cpuinfo) 
  639: 
  640: /*
  641:  * get_mpconf
  642:  *	Returns the address of this processor's MPCONF block in v0.
  643:  */
  644: 
  645: LEAF(get_mpconf)
  646: 	move	ta0, ra			# Save the return address	
get_mpconf:
[ 646] 0x900000001fc04560:  03 e0 40 25 move	a4,ra
  647: 	jal     get_cpuinfo		# Find this processor's CPU info
[ 647] 0x900000001fc04564:  0f f0 11 40 jal		get_cpuinfo
  648: 	nop				# (BD)
[ 648] 0x900000001fc04568:  00 00 00 00 nop
  649: 
  650: 	lb	t1, CPUVPID_OFF(v0)	# Load this processor's VPID
[ 650] 0x900000001fc0456c:  80 4d 00 0c lb	t1,12(v0)
  651: 	li	t0, MPCONF_SIZE		# Size of an MPCONF block
[ 651] 0x900000001fc04570:  24 0c 00 40 li	t0,64
  652: 
  653: 	dmultu	t1, t0
[ 653] 0x900000001fc04574:  01 ac 00 1d dmultu	t1,t0
  654: 	nop
[ 654] 0x900000001fc04578:  00 00 00 00 nop
  655: 	dli	t0, MPCONF_ADDR		# Get MPCONF base address
[ 655] 0x900000001fc0457c:  3c 0c 90 00 lui	t0,0x9000
[ 655] 0x900000001fc04580:  00 0c 60 3c dsll32	t0,t0,0
[ 655] 0x900000001fc04584:  35 8c 30 00 ori	t0,t0,0x3000
  656: 	mflo	v0                      # Retrieve the the MPCONF block offset
[ 656] 0x900000001fc04588:  00 00 10 12 mflo	v0
  657: 
  658: 	j	ta0			# Return
[ 658] 0x900000001fc0458c:  01 00 00 08 jr	a4
  659: 	daddu	v0, t0                  # (BD) Add struct offset to base addr
[ 659] 0x900000001fc04590:  00 4c 10 2d daddu	v0,v0,t0
  660: 	END(get_mpconf)
  661: 
  662: /*
  663:  * Routine change_leds
  664:  *	Delays for a period of time and then changes the LEDs
  665:  *	If an interrupt comes in while we are delaying, break  
  666:  *	out of the delay loop and set the value immediately.
  667:  * Parameters:
  668:  *	a0 -- value to set the leds to.
  669:  */
  670: 	
  671: LEAF(change_led)
  672: 	move	ta0, a0
change_led:
[ 672] 0x900000001fc04594:  00 80 40 25 move	a4,a0
  673: 	move	s5, ra			# Save our return address
[ 673] 0x900000001fc04598:  03 e0 a8 25 move	s5,ra
  674: 	dli	t2, EV_IP0	
[ 674] 0x900000001fc0459c:  3c 0e 90 00 lui	t2,0x9000
[ 674] 0x900000001fc045a0:  00 0e 74 38 dsll	t2,t2,16
[ 674] 0x900000001fc045a4:  35 ce 18 00 ori	t2,t2,0x1800
[ 674] 0x900000001fc045a8:  00 0e 74 38 dsll	t2,t2,16
[ 674] 0x900000001fc045ac:  35 ce 08 00 ori	t2,t2,0x800
  675: 	li	t3, 140000 
[ 675] 0x900000001fc045b0:  3c 0f 00 02 lui	t3,0x2
[ 675] 0x900000001fc045b4:  35 ef 22 e0 ori	t3,t3,0x22e0
  676: 1:					# LOOP	
  677: 	ld	t1, 0(t2)		#   Get the pending interrupt mask
[ 677] 0x900000001fc045b8:  dd cd 00 00 ld	t1,0(t2)
  678: 	and	t1, INTR_LEVEL_MASK 
[ 678] 0x900000001fc045bc:  31 ad 01 ee andi	t1,t1,0x1ee
  679: 	bne	t1, zero, 2f		#   IF (interrupt) break
[ 679] 0x900000001fc045c0:  15 a0 00 04 bne	t1,zero,0x900000001fc045d4
  680: 	nop
[ 680] 0x900000001fc045c4:  00 00 00 00 nop
  681: 
  682: 	sub	t3, 1			# (BD) t3-- 
[ 682] 0x900000001fc045c8:  21 ef ff ff addi	t3,t3,-1
  683: 	bne	t3, zero, 1b		# WHILE t3 > 0
[ 683] 0x900000001fc045cc:  15 e0 ff fa bne	t3,zero,0x900000001fc045b8
  684: 	nop
[ 684] 0x900000001fc045d0:  00 00 00 00 nop
  685: 2:
  686: 	jal	set_cc_leds
[ 686] 0x900000001fc045d4:  0f f0 0c 78 jal		set_cc_leds
  687: 	move	a0, ta0
[ 687] 0x900000001fc045d8:  01 00 20 25 move	a0,a4
  688: 	j	s5
[ 688] 0x900000001fc045dc:  02 a0 00 08 jr	s5
  689: 	nop
[ 689] 0x900000001fc045e0:  00 00 00 00 nop
       0x900000001fc045e4:  00 00 00 00 nop
       0x900000001fc045e8:  00 00 00 00 nop
       0x900000001fc045ec:  00 00 00 00 nop
Skipping source listing to line 34 of /cores/banyan/stand/arcs/IP25prom/sysctlr.s...
   35:  *	a0 -- Pointer to message to be displayed (better be less than 
   36:  *	      20 characters in length, or the SysCtlr will freak).
   37:  * Returns:
   38:  *	Not much.
   39:  * Uses:
   40:  *	a0, a1, v0, v1, ta1, ta2, ta3, t8, t9
   41:  */
   42: 
   43: LEAF(sysctlr_message)
   44: 	move	t0, ra			# Save our return address
sysctlr_message:
[  44] 0x900000001fc045f0:  03 e0 60 25 move	t0,ra
   45: 	move	t1, a0			# Save message to be written
[  45] 0x900000001fc045f4:  00 80 68 25 move	t1,a0
   46: 
   47: 	jal	ccuart_putc		# Write the ESCAPE character
[  47] 0x900000001fc045f8:  0f f0 0c d6 jal		ccuart_putc
   48: 	ori	a0, zero, SC_ESCAPE	# (BD)_ Load escape character
[  48] 0x900000001fc045fc:  34 04 00 18 ori	a0,zero,0x18
   49: 	jal	ccuart_putc		# Write a character
[  49] 0x900000001fc04600:  0f f0 0c d6 jal		ccuart_putc
   50: 	ori	a0, zero, SC_SET	# (BD) Set command
[  50] 0x900000001fc04604:  34 04 00 53 ori	a0,zero,0x53
   51: 	jal	ccuart_putc		# Write a character
[  51] 0x900000001fc04608:  0f f0 0c d6 jal		ccuart_putc
   52: 	ori	a0, zero, SC_MESSAGE	# Send a message
[  52] 0x900000001fc0460c:  34 04 00 4d ori	a0,zero,0x4d
   53: 
   54: 	jal	ccuart_puts		# Write out the actual message
[  54] 0x900000001fc04610:  0f f0 0d 14 jal		ccuart_puts
   55: 	move	a0, t1			# (BD) pointer to message
[  55] 0x900000001fc04614:  01 a0 20 25 move	a0,t1
   56: 
   57: 	jal	ccuart_putc		# Write message terminator
[  57] 0x900000001fc04618:  0f f0 0c d6 jal		ccuart_putc
   58: 	ori	a0, zero, SC_TERM	# (BD) Load term into a0 
[  58] 0x900000001fc0461c:  34 04 00 0a ori	a0,zero,0xa
   59: 	j	t0
[  59] 0x900000001fc04620:  01 80 00 08 jr	t0
   60: 	nop
[  60] 0x900000001fc04624:  00 00 00 00 nop
   61: 	END(sysctlr_message)
   62: 
   63: 
   64: /*
   65:  * sysctlr_getdebug
   66:  *	Reads the magic debugging DIP switches from the system controller
   67:  *	and returns them in v0.
   68:  *
   69:  * Returns:
   70:  *	v0 -- current setting of magic DIP switches.
   71:  * Uses:
   72:  *	a0, a1, v0, v1, ta1, ta2, ta3, t8, t9
   73:  */
   74: 
   75: LEAF(sysctlr_getdebug)
   76: 	move 	ta1, ra			# Save our return address
sysctlr_getdebug:
[  76] 0x900000001fc04628:  03 e0 48 25 move	a5,ra
   77: 
   78: 	jal	ccuart_flush		# Flush out the garbage
[  78] 0x900000001fc0462c:  0f f0 0c ea jal		ccuart_flush
   79: 	nop
[  79] 0x900000001fc04630:  00 00 00 00 nop
   80: 
   81: 	jal	ccuart_putc
[  81] 0x900000001fc04634:  0f f0 0c d6 jal		ccuart_putc
   82: 	ori	a0, zero, SC_ESCAPE	# (BD) Load the ESCAPE character
[  82] 0x900000001fc04638:  34 04 00 18 ori	a0,zero,0x18
   83: 	jal	ccuart_putc		# Write command
[  83] 0x900000001fc0463c:  0f f0 0c d6 jal		ccuart_putc
   84: 	ori	a0, zero, SC_GET	# (BD) Get
[  84] 0x900000001fc04640:  34 04 00 47 ori	a0,zero,0x47
   85: 	jal	ccuart_putc		# Write sequence byte
[  85] 0x900000001fc04644:  0f f0 0c d6 jal		ccuart_putc
   86: 	ori	a0, zero, SC_DEBUG	# (BD) Use request type as sequence 	
[  86] 0x900000001fc04648:  34 04 00 44 ori	a0,zero,0x44
   87: 	jal	ccuart_putc		# Write debug
[  87] 0x900000001fc0464c:  0f f0 0c d6 jal		ccuart_putc
   88: 	ori	a0, zero, SC_DEBUG	# (BD) Debug value
[  88] 0x900000001fc04650:  34 04 00 44 ori	a0,zero,0x44
   89: 	jal	ccuart_putc		# Write terminator
[  89] 0x900000001fc04654:  0f f0 0c d6 jal		ccuart_putc
   90: 	ori	a0, zero, SC_TERM	# (BD) send term char. 
[  90] 0x900000001fc04658:  34 04 00 0a ori	a0,zero,0xa
   91: 
   92: 	# Now spin waiting for a reply with the proper sequence
   93:  	# number to come back to us.  Since we don't expect to
   94: 	# have outstanding requests in the prom, we just throw
   95: 	# away responses, alarms or warnings we don't care about.
   96: 	#
   97: #ifdef SABLE
   98: 	li	ta2, 1 
   99: #else
  100: 	li	ta2, 50000
[ 100] 0x900000001fc0465c:  34 0a c3 50 ori	a6,zero,0xc350
  101: #endif
  102: 1:	
  103: 	jal	ccuart_poll		# read a character
[ 103] 0x900000001fc04660:  0f f0 0c b6 jal		ccuart_poll
  104: 	nop
[ 104] 0x900000001fc04664:  00 00 00 00 nop
  105: 	sub	ta2, 1			# (BD)
[ 105] 0x900000001fc04668:  21 4a ff ff addi	a6,a6,-1
  106: 	beqz	ta2, 8f			# If timeout expires goto end
[ 106] 0x900000001fc0466c:  11 40 00 21 beq	a6,zero,0x900000001fc046f4
  107: 	nop				# (BD)
[ 107] 0x900000001fc04670:  00 00 00 00 nop
  108: 	beqz	v0, 1b			# If no character loop
[ 108] 0x900000001fc04674:  10 40 ff fa beq	v0,zero,0x900000001fc04660
  109: 	nop				# (BD) 
[ 109] 0x900000001fc04678:  00 00 00 00 nop
  110: 
  111: 	# Check to see if the first character is
  112:  	# part of response.
  113: 	#
  114: 	jal	ccuart_getc		# Read character
[ 114] 0x900000001fc0467c:  0f f0 0c bf jal		ccuart_getc
  115: 	li	ta3, SC_RESP		# Load response character
[ 115] 0x900000001fc04680:  24 0b 00 52 li	a7,82
  116: 	move	ta2, zero		# (BD)  Make sure we fail cleanly
[ 116] 0x900000001fc04684:  00 00 50 25 move	a6,zero
  117: 	bne	v0, ta3, 8f		# Got the response character
[ 117] 0x900000001fc04688:  14 4b 00 1a bne	v0,a7,0x900000001fc046f4
  118: 	nop
[ 118] 0x900000001fc0468c:  00 00 00 00 nop
  119: 
  120: 	# If we get to this point, we're getting a response.
  121: 	# Check to see if the sequence number matches.
  122: 3:	#
  123: 	jal	ccuart_getc		# Get sequence number
[ 123] 0x900000001fc04690:  0f f0 0c bf jal		ccuart_getc
  124: 	li	ta2, SC_DEBUG		# (BD) Load comparison value
[ 124] 0x900000001fc04694:  24 0a 00 44 li	a6,68
  125: 	bne	v0, ta2, 8f		# Return if values don't match
[ 125] 0x900000001fc04698:  14 4a 00 16 bne	v0,a6,0x900000001fc046f4
  126: 	nop
[ 126] 0x900000001fc0469c:  00 00 00 00 nop
  127: 
  128: 	jal	ccuart_getc		# Get response type
[ 128] 0x900000001fc046a0:  0f f0 0c bf jal		ccuart_getc
  129: 	li	ta2, SC_DEBUG		# (BD) 
[ 129] 0x900000001fc046a4:  24 0a 00 44 li	a6,68
  130: 	bne	ta2, v0, 8f		#  Return if values don't match
[ 130] 0x900000001fc046a8:  15 42 00 12 bne	a6,v0,0x900000001fc046f4
  131: 	nop
[ 131] 0x900000001fc046ac:  00 00 00 00 nop
  132: 
  133: 
  134: 	# Read in four bytes of data from system controller
  135: 	#
  136: 	li	ta3, 3
[ 136] 0x900000001fc046b0:  24 0b 00 03 li	a7,3
  137: 	move	ta2, zero
[ 137] 0x900000001fc046b4:  00 00 50 25 move	a6,zero
  138: 4:					# DO
  139: 	jal	ccuart_getc		#   Read byte of response
[ 139] 0x900000001fc046b8:  0f f0 0c bf jal		ccuart_getc
  140: 	nop				#   (BD)
[ 140] 0x900000001fc046bc:  00 00 00 00 nop
  141: 	beqz	v0, 8f			# If we got the term char (NULL) return
[ 141] 0x900000001fc046c0:  10 40 00 0c beq	v0,zero,0x900000001fc046f4
  142: 	nop				# (BD)
[ 142] 0x900000001fc046c4:  00 00 00 00 nop
  143: 	jal	ascii_to_hex		#   Convert byte to hex
[ 143] 0x900000001fc046c8:  0f f0 11 ed jal		ascii_to_hex
  144: 	move	a0, v0			#   (BD)
[ 144] 0x900000001fc046cc:  00 40 20 25 move	a0,v0
  145: 	sll	ta2, 4			#   Shift prev value over
[ 145] 0x900000001fc046d0:  00 0a 51 00 sll	a6,a6,4
  146: 	or	ta2, v0			#   Merge in current byte
[ 146] 0x900000001fc046d4:  01 42 50 25 or	a6,a6,v0
  147: 	dsub	ta3, 1			#   (BD) decrement counter
[ 147] 0x900000001fc046d8:  61 6b ff ff daddi	a7,a7,-1
  148: 	bgez	ta3, 4b			#   Loop back up to read
[ 148] 0x900000001fc046dc:  05 61 ff f6 bgez	a7,0x900000001fc046b8
  149: 					# UNTIL ta3 is zero
  150: 	nop
[ 150] 0x900000001fc046e0:  00 00 00 00 nop
  151: 	
  152: 	jal	ccuart_getc		# Read terminating character
[ 152] 0x900000001fc046e4:  0f f0 0c bf jal		ccuart_getc
  153: 	nop				# (BD)
[ 153] 0x900000001fc046e8:  00 00 00 00 nop
  154: 	b	9f
[ 154] 0x900000001fc046ec:  10 00 00 02 b		0x900000001fc046f8
  155: 	nop
[ 155] 0x900000001fc046f0:  00 00 00 00 nop
  156: 
  157: 8:	move	ta2,zero
[ 157] 0x900000001fc046f4:  00 00 50 25 move	a6,zero
  158: 
  159: 	# Return to caller
  160: 9:	#
  161: 	j	ta1			# Return	
[ 161] 0x900000001fc046f8:  01 20 00 08 jr	a5
  162: 	move	v0, ta2			# (BD) stuff return value into v0
[ 162] 0x900000001fc046fc:  01 40 10 25 move	v0,a6
  163: 	END(sysctlr_getdebug)
  164: 
  165: 
  166: /*
  167:  * sysctlr_getpanel
  168:  *	Reads the magic debugging DIP switches from the system controller
  169:  *	and returns them in v0.
  170:  *
  171:  * Returns:
  172:  *	v0 -- 'E' (0x45) for the small panel and 'T' (0x54) for the large
  173:  * Uses:
  174:  *	a0, a1, v0, v1, ta1, ta2, ta3, t8, t9
  175:  */
  176: 
  177: LEAF(sysctlr_getpanel)
  178: 	move 	ta1, ra			# Save our return address
sysctlr_getpanel:
[ 178] 0x900000001fc04700:  03 e0 48 25 move	a5,ra
  179: 
  180: 	jal	ccuart_flush		# Flush out the garbage
[ 180] 0x900000001fc04704:  0f f0 0c ea jal		ccuart_flush
  181: 	nop
[ 181] 0x900000001fc04708:  00 00 00 00 nop
  182: 
  183: 	jal	ccuart_putc
[ 183] 0x900000001fc0470c:  0f f0 0c d6 jal		ccuart_putc
  184: 	ori	a0, zero, SC_ESCAPE	# (BD) Load the ESCAPE character
[ 184] 0x900000001fc04710:  34 04 00 18 ori	a0,zero,0x18
  185: 	
  186: 	# Write out the get request
  187: 	#	
  188: 1:
  189: 	jal	ccuart_putc		# Write command
[ 189] 0x900000001fc04714:  0f f0 0c d6 jal		ccuart_putc
  190: 	ori	a0, zero, SC_GET	# (BD) Get
[ 190] 0x900000001fc04718:  34 04 00 47 ori	a0,zero,0x47
  191: 	jal	ccuart_putc		# Write sequence byte
[ 191] 0x900000001fc0471c:  0f f0 0c d6 jal		ccuart_putc
  192: 	ori	a0, zero, SC_PANEL	# (BD) Use request type as sequence 	
[ 192] 0x900000001fc04720:  34 04 00 50 ori	a0,zero,0x50
  193: 	jal	ccuart_putc		# Write debug
[ 193] 0x900000001fc04724:  0f f0 0c d6 jal		ccuart_putc
  194: 	ori	a0, zero, SC_PANEL	# (BD) Panel value
[ 194] 0x900000001fc04728:  34 04 00 50 ori	a0,zero,0x50
  195: 	jal	ccuart_putc		# Write terminator
[ 195] 0x900000001fc0472c:  0f f0 0c d6 jal		ccuart_putc
  196: 	ori	a0, zero, SC_TERM	# (BD) send term char. 
[ 196] 0x900000001fc04730:  34 04 00 0a ori	a0,zero,0xa
  197: 
  198: 	# Now spin waiting for a reply with the proper sequence
  199:  	# number to come back to us.  Since we don't expect to
  200: 	# have outstanding requests in the prom, we just throw
  201: 	# away responses, alarms or warnings we don't care about.
  202: 	#
  203: 	li	ta3, 5000000
[ 203] 0x900000001fc04734:  3c 0b 00 4c lui	a7,0x4c
[ 203] 0x900000001fc04738:  35 6b 4b 40 ori	a7,a7,0x4b40
  204: 	li	ta2, 0x45		# Default return value ('E')
[ 204] 0x900000001fc0473c:  24 0a 00 45 li	a6,69
  205: 1:	
  206: 	jal	ccuart_poll		# read a character
[ 206] 0x900000001fc04740:  0f f0 0c b6 jal		ccuart_poll
  207: 	nop
[ 207] 0x900000001fc04744:  00 00 00 00 nop
  208: 	sub	ta3, 1			# (BD)
[ 208] 0x900000001fc04748:  21 6b ff ff addi	a7,a7,-1
  209: 	beqz	ta3, 8f			# If timeout expires goto end
[ 209] 0x900000001fc0474c:  11 60 00 16 beq	a7,zero,0x900000001fc047a8
  210: 	nop				# (BD)
[ 210] 0x900000001fc04750:  00 00 00 00 nop
  211: 	beqz	v0, 1b			# If no character loop
[ 211] 0x900000001fc04754:  10 40 ff fa beq	v0,zero,0x900000001fc04740
  212: 	nop				# (BD) 
[ 212] 0x900000001fc04758:  00 00 00 00 nop
  213: 
  214: 	# Check to see if the first character is
  215:  	# part of response.
  216: 	#
  217: 	jal	ccuart_getc		# Read character
[ 217] 0x900000001fc0475c:  0f f0 0c bf jal		ccuart_getc
  218: 	li	ta3, SC_RESP		# Load response character
[ 218] 0x900000001fc04760:  24 0b 00 52 li	a7,82
  219: 	bne	v0, ta3, 8f		# Got the response character
[ 219] 0x900000001fc04764:  14 4b 00 10 bne	v0,a7,0x900000001fc047a8
  220: 	nop				# (BD)
[ 220] 0x900000001fc04768:  00 00 00 00 nop
  221: 
  222: 	# If we get to this point, we're getting a response.
  223: 	# Check to see if the sequence number matches.
  224: 3:	#
  225: 	jal	ccuart_getc		# Get sequence number
[ 225] 0x900000001fc0476c:  0f f0 0c bf jal		ccuart_getc
  226: 	li	ta3, SC_PANEL		# (BD) Load comparison value
[ 226] 0x900000001fc04770:  24 0b 00 50 li	a7,80
  227: 	bne	v0, ta3, 8f		# Return if values don't match
[ 227] 0x900000001fc04774:  14 4b 00 0c bne	v0,a7,0x900000001fc047a8
  228: 	nop
[ 228] 0x900000001fc04778:  00 00 00 00 nop
  229: 
  230: 	jal	ccuart_getc		# Get response type
[ 230] 0x900000001fc0477c:  0f f0 0c bf jal		ccuart_getc
  231: 	li	ta3, SC_PANEL		# (BD) 
[ 231] 0x900000001fc04780:  24 0b 00 50 li	a7,80
  232: 	bne	ta3, v0, 8f		#  Return if values don't match 
[ 232] 0x900000001fc04784:  15 62 00 08 bne	a7,v0,0x900000001fc047a8
  233: 	nop
[ 233] 0x900000001fc04788:  00 00 00 00 nop
  234: 
  235: 	jal	ccuart_getc		# Read the actual response
[ 235] 0x900000001fc0478c:  0f f0 0c bf jal		ccuart_getc
  236: 	nop				# (BD)
[ 236] 0x900000001fc04790:  00 00 00 00 nop
  237: 	move	ta2, v0			# Store the byte in t0
[ 237] 0x900000001fc04794:  00 40 50 25 move	a6,v0
  238: 
  239: 	jal	ccuart_getc		# Read the nice terminating NULL
[ 239] 0x900000001fc04798:  0f f0 0c bf jal		ccuart_getc
  240: 	nop
[ 240] 0x900000001fc0479c:  00 00 00 00 nop
  241: 	b	9f
[ 241] 0x900000001fc047a0:  10 00 00 02 b		0x900000001fc047ac
  242: 	nop
[ 242] 0x900000001fc047a4:  00 00 00 00 nop
  243: 8:	
  244: 	move	ta3, zero		# (BD)
[ 244] 0x900000001fc047a8:  00 00 58 25 move	a7,zero
  245: 
  246: 	# Return to caller
  247: 9:	#
  248: 	j	ta1			# Return	
[ 248] 0x900000001fc047ac:  01 20 00 08 jr	a5
  249: 	move	v0, ta2			# (BD) stuff return value into v0
[ 249] 0x900000001fc047b0:  01 40 10 25 move	v0,a6
  250: 	END(sysctlr_getpanel)
  251: 
  252: /*
  253:  * Routine ascii_to_hex
  254:  *	Given an ascii character in a0, this routine
  255:  *	converts it into a single integer value 
  256:  *	between 0 and 15 and returns it in v0.
  257:  */
  258: 
  259: LEAF(ascii_to_hex)
  260: 	move	t8, ra			# Save return address
ascii_to_hex:
[ 260] 0x900000001fc047b4:  03 e0 c0 25 move	t8,ra
  261: 	move	t9, a0			# Character being converted
[ 261] 0x900000001fc047b8:  00 80 c8 25 move	t9,a0
  262: 
  263: 	sub	v0, a0, 0x60		# Check to see if character is
[ 263] 0x900000001fc047bc:  20 82 ff a0 addi	v0,a0,-96
  264: 	ble	v0, zero, 1f		#   lower case 
[ 264] 0x900000001fc047c0:  18 40 00 02 blez	v0,0x900000001fc047cc
  265: 	nop				# (BD)
[ 265] 0x900000001fc047c4:  00 00 00 00 nop
  266: 	sub	t9, a0, 0x20		# If so, convert it to upper	
[ 266] 0x900000001fc047c8:  20 99 ff e0 addi	t9,a0,-32
  267: 1:
  268: 	dla	a0, hexstring		# Load the address of the hex string
[ 268] 0x900000001fc047cc:  3c 04 90 00 lui	a0,0x9000
[ 268] 0x900000001fc047d0:  64 84 00 00 daddiu	a0,a0,0
[ 268] 0x900000001fc047d4:  00 04 24 38 dsll	a0,a0,16
[ 268] 0x900000001fc047d8:  64 84 1f c1 daddiu	a0,a0,8129
[ 268] 0x900000001fc047dc:  00 04 24 38 dsll	a0,a0,16
[ 268] 0x900000001fc047e0:  64 84 79 08 daddiu	a0,a0,30984
  269: 2:
  270: 	jal	get_char		# Read the first hex character
[ 270] 0x900000001fc047e4:  0f f0 0d 88 jal		get_char
  271:         nop				# (BD)
[ 271] 0x900000001fc047e8:  00 00 00 00 nop
  272: 	li	v1, 0x46		# Load capital F
[ 272] 0x900000001fc047ec:  24 03 00 46 li	v1,70
  273: 	beq	v0, t9, 3f		# If characters match, exit loop 
[ 273] 0x900000001fc047f0:  10 59 00 05 beq	v0,t9,0x900000001fc04808
  274: 	nop
[ 274] 0x900000001fc047f4:  00 00 00 00 nop
  275: 	beq	v0, v1, 9f		# If comparison char is 'F' exit loop
[ 275] 0x900000001fc047f8:  10 43 00 0d beq	v0,v1,0x900000001fc04830
  276: 	nop
[ 276] 0x900000001fc047fc:  00 00 00 00 nop
  277: 
  278: 	b	2b			# LOOP and load next character
[ 278] 0x900000001fc04800:  10 00 ff f8 b		0x900000001fc047e4
  279: 	dadd	a0, 1			# (BD) increment character pointer
[ 279] 0x900000001fc04804:  60 84 00 01 daddi	a0,a0,1
  280: 3:
  281: 	dla	v1, hexstring
[ 281] 0x900000001fc04808:  3c 03 90 00 lui	v1,0x9000
[ 281] 0x900000001fc0480c:  64 63 00 00 daddiu	v1,v1,0
[ 281] 0x900000001fc04810:  00 03 1c 38 dsll	v1,v1,16
[ 281] 0x900000001fc04814:  64 63 1f c1 daddiu	v1,v1,8129
[ 281] 0x900000001fc04818:  00 03 1c 38 dsll	v1,v1,16
[ 281] 0x900000001fc0481c:  64 63 79 08 daddiu	v1,v1,30984
  282: 	sub	v0, a0, v1		# Calculate offset
[ 282] 0x900000001fc04820:  00 83 10 22 sub	v0,a0,v1
  283: 	b	9f
[ 283] 0x900000001fc04824:  10 00 00 02 b		0x900000001fc04830
  284: 	nop
[ 284] 0x900000001fc04828:  00 00 00 00 nop
  285: 8:
  286: 	move	v0,zero
[ 286] 0x900000001fc0482c:  00 00 10 25 move	v0,zero
  287: 9:
  288: 	j	t8
[ 288] 0x900000001fc04830:  03 00 00 08 jr	t8
  289: 	nop
[ 289] 0x900000001fc04834:  00 00 00 00 nop
       0x900000001fc04838:  00 00 00 00 nop
       0x900000001fc0483c:  00 00 00 00 nop
Skipping source listing to line 44 of /cores/banyan/stand/arcs/IP25prom/master.s...
   45:  *	None.
   46:  * Returns:
   47:  * 	Never returns.	
   48:  */
   49: 
   50: LEAF(prom_master)
   51: 	/*
   52:  	 * Announce our presence as the boot master
   53: 	 */
   54: 	LEDS(PLED_BMASTER)
prom_master:
[  54] 0x900000001fc04840:  00 00 00 00 nop
[  54] 0x900000001fc04844:  34 04 00 1e ori	a0,zero,0x1e
[  54] 0x900000001fc04848:  3c 02 90 00 lui	v0,0x9000
[  54] 0x900000001fc0484c:  00 02 14 38 dsll	v0,v0,16
[  54] 0x900000001fc04850:  34 42 19 00 ori	v0,v0,0x1900
[  54] 0x900000001fc04854:  00 02 14 38 dsll	v0,v0,16
[  54] 0x900000001fc04858:  34 42 40 00 ori	v0,v0,0x4000
[  54] 0x900000001fc0485c:  fc 44 00 00 sd	a0,0(v0)
   55: 	DPRINT("I am the Boot Master\r\n")
   56: 	DELAY(50000)
[  56] 0x900000001fc04860:  34 04 c3 50 ori	a0,zero,0xc350
[  56] 0x900000001fc04864:  0f f0 0d a4 jal		delay
[  56] 0x900000001fc04868:  00 00 00 00 nop
   57: 
   58: 	SCPRINT("Starting System..")
[  58] 0x900000001fc0486c:  3c 04 90 00 lui	a0,0x9000
[  58] 0x900000001fc04870:  64 84 00 00 daddiu	a0,a0,0
[  58] 0x900000001fc04874:  00 04 24 38 dsll	a0,a0,16
[  58] 0x900000001fc04878:  64 84 1f c1 daddiu	a0,a0,8129
[  58] 0x900000001fc0487c:  00 04 24 38 dsll	a0,a0,16
[  58] 0x900000001fc04880:  64 84 79 18 daddiu	a0,a0,31000
[  58] 0x900000001fc04884:  0f f0 11 7c jal		sysctlr_message
[  58] 0x900000001fc04888:  00 00 00 00 nop
   59: 	DELAY(50000)
[  59] 0x900000001fc0488c:  34 04 c3 50 ori	a0,zero,0xc350
[  59] 0x900000001fc04890:  0f f0 0d a4 jal		delay
[  59] 0x900000001fc04894:  00 00 00 00 nop
   60: 
   61: 	jal	sysctlr_getdebug
[  61] 0x900000001fc04898:  0f f0 11 8a jal		sysctlr_getdebug
   62: 	nop
[  62] 0x900000001fc0489c:  00 00 00 00 nop
   63: 
   64:         andi	v0, VDS_NO_DIAGS
[  64] 0x900000001fc048a0:  30 42 00 10 andi	v0,v0,0x10
   65: 	beqz	v0, 1f
[  65] 0x900000001fc048a4:  10 40 00 0e beq	v0,zero,0x900000001fc048e0
   66: 	nop				# (BD)
[  66] 0x900000001fc048a8:  00 00 00 00 nop
   67: 
   68: 	DMFBR(a1, BR_BSR)
[  68] 0x900000001fc048ac:  44 25 00 00 dmfc1	a1,$f0
   69: 	ori	a1, BSR_NODIAG		# Turn on no diags bit
[  69] 0x900000001fc048b0:  34 a5 00 80 ori	a1,a1,0x80
   70: 	DMTBR(a1, BR_BSR)
[  70] 0x900000001fc048b4:  44 a5 00 00 dmtc1	a1,$f0
   71: 
   72: 	SCPRINT("* DIAGS DISABLED *")
[  72] 0x900000001fc048b8:  3c 04 90 00 lui	a0,0x9000
[  72] 0x900000001fc048bc:  64 84 00 00 daddiu	a0,a0,0
[  72] 0x900000001fc048c0:  00 04 24 38 dsll	a0,a0,16
[  72] 0x900000001fc048c4:  64 84 1f c1 daddiu	a0,a0,8129
[  72] 0x900000001fc048c8:  00 04 24 38 dsll	a0,a0,16
[  72] 0x900000001fc048cc:  64 84 79 2a daddiu	a0,a0,31018
[  72] 0x900000001fc048d0:  0f f0 11 7c jal		sysctlr_message
[  72] 0x900000001fc048d4:  00 00 00 00 nop
   73: 	b	2f
[  73] 0x900000001fc048d8:  10 00 00 24 b		0x900000001fc0496c
   74: 	nop
[  74] 0x900000001fc048dc:  00 00 00 00 nop
   75: 1:	
   76:         /*
   77:          * Do preliminary primary data cache testing before we
   78:          * use it as a stack.
   79:          */
   80: 	LEDS(PLED_CKPDCACHE1)
[  80] 0x900000001fc048e0:  00 00 00 00 nop
[  80] 0x900000001fc048e4:  34 04 00 22 ori	a0,zero,0x22
[  80] 0x900000001fc048e8:  3c 02 90 00 lui	v0,0x9000
[  80] 0x900000001fc048ec:  00 02 14 38 dsll	v0,v0,16
[  80] 0x900000001fc048f0:  34 42 19 00 ori	v0,v0,0x1900
[  80] 0x900000001fc048f4:  00 02 14 38 dsll	v0,v0,16
[  80] 0x900000001fc048f8:  34 42 40 00 ori	v0,v0,0x4000
[  80] 0x900000001fc048fc:  fc 44 00 00 sd	a0,0(v0)
   81:         SCPRINT("Testing D-Cache ..")
[  81] 0x900000001fc04900:  3c 04 90 00 lui	a0,0x9000
[  81] 0x900000001fc04904:  64 84 00 00 daddiu	a0,a0,0
[  81] 0x900000001fc04908:  00 04 24 38 dsll	a0,a0,16
[  81] 0x900000001fc0490c:  64 84 1f c1 daddiu	a0,a0,8129
[  81] 0x900000001fc04910:  00 04 24 38 dsll	a0,a0,16
[  81] 0x900000001fc04914:  64 84 79 3d daddiu	a0,a0,31037
[  81] 0x900000001fc04918:  0f f0 11 7c jal		sysctlr_message
[  81] 0x900000001fc0491c:  00 00 00 00 nop
   82: 	jal	testDcache
[  82] 0x900000001fc04920:  0f f0 06 a5 jal		testDcache
   83: 	nop
[  83] 0x900000001fc04924:  00 00 00 00 nop
   84:         beqz    v0, 2f
[  84] 0x900000001fc04928:  10 40 00 10 beq	v0,zero,0x900000001fc0496c
   85:         nop
[  85] 0x900000001fc0492c:  00 00 00 00 nop
   86: 	SCPRINT("* FAILED *")
[  86] 0x900000001fc04930:  3c 04 90 00 lui	a0,0x9000
[  86] 0x900000001fc04934:  64 84 00 00 daddiu	a0,a0,0
[  86] 0x900000001fc04938:  00 04 24 38 dsll	a0,a0,16
[  86] 0x900000001fc0493c:  64 84 1f c1 daddiu	a0,a0,8129
[  86] 0x900000001fc04940:  00 04 24 38 dsll	a0,a0,16
[  86] 0x900000001fc04944:  64 84 79 50 daddiu	a0,a0,31056
[  86] 0x900000001fc04948:  0f f0 11 7c jal		sysctlr_message
[  86] 0x900000001fc0494c:  00 00 00 00 nop
   87: 	DELAY(50000)
[  87] 0x900000001fc04950:  34 04 c3 50 ori	a0,zero,0xc350
[  87] 0x900000001fc04954:  0f f0 0d a4 jal		delay
[  87] 0x900000001fc04958:  00 00 00 00 nop
   88: 	jal	invalidateDcache
[  88] 0x900000001fc0495c:  0f f0 07 d0 jal		invalidateDcache
   89: 	nop
[  89] 0x900000001fc04960:  00 00 00 00 nop
   90: 
   91: 	/* Abdicate bootmastership.  Send the diagnostic code as the
   92: 	 * reason for abdicatoing.
   93: 	 */
   94: 	b	prom_abdicate
[  94] 0x900000001fc04964:  10 00 00 2e b		0x900000001fc04a20
   95: 	move	a0, v0
[  95] 0x900000001fc04968:  00 40 20 25 move	a0,v0
   96: 2:
   97: 	jal	invalidateDcache
[  97] 0x900000001fc0496c:  0f f0 07 d0 jal		invalidateDcache
   98: 	nop
[  98] 0x900000001fc04970:  00 00 00 00 nop
   99: 	jal	invalidateScache
[  99] 0x900000001fc04974:  0f f0 08 c3 jal		invalidateScache
  100: 	nop
[ 100] 0x900000001fc04978:  00 00 00 00 nop
  101:         jal     invalidateScache
[ 101] 0x900000001fc0497c:  0f f0 08 c3 jal		invalidateScache
  102: 	nop
[ 102] 0x900000001fc04980:  00 00 00 00 nop
  103: 	LEDS(PLED_MAKESTACK)
[ 103] 0x900000001fc04984:  00 00 00 00 nop
[ 103] 0x900000001fc04988:  34 04 00 23 ori	a0,zero,0x23
[ 103] 0x900000001fc0498c:  3c 02 90 00 lui	v0,0x9000
[ 103] 0x900000001fc04990:  00 02 14 38 dsll	v0,v0,16
[ 103] 0x900000001fc04994:  34 42 19 00 ori	v0,v0,0x1900
[ 103] 0x900000001fc04998:  00 02 14 38 dsll	v0,v0,16
[ 103] 0x900000001fc0499c:  34 42 40 00 ori	v0,v0,0x4000
[ 103] 0x900000001fc049a0:  fc 44 00 00 sd	a0,0(v0)
  104: 	SCPRINT("Building stack ... ")
[ 104] 0x900000001fc049a4:  3c 04 90 00 lui	a0,0x9000
[ 104] 0x900000001fc049a8:  64 84 00 00 daddiu	a0,a0,0
[ 104] 0x900000001fc049ac:  00 04 24 38 dsll	a0,a0,16
[ 104] 0x900000001fc049b0:  64 84 1f c1 daddiu	a0,a0,8129
[ 104] 0x900000001fc049b4:  00 04 24 38 dsll	a0,a0,16
[ 104] 0x900000001fc049b8:  64 84 79 5b daddiu	a0,a0,31067
[ 104] 0x900000001fc049bc:  0f f0 11 7c jal		sysctlr_message
[ 104] 0x900000001fc049c0:  00 00 00 00 nop
  105:         jal     initDcacheStack
[ 105] 0x900000001fc049c4:  0f f0 0a de jal		initDcacheStack
  106:         nop
[ 106] 0x900000001fc049c8:  00 00 00 00 nop
  107: 
  108: 	dli	a0, PROM_SR 
[ 108] 0x900000001fc049cc:  3c 04 24 40 lui	a0,0x2440
[ 108] 0x900000001fc049d0:  34 84 00 80 ori	a0,a0,0x80
  109: 	DMTC0(a0, C0_SR)		# Set up the status register
[ 109] 0x900000001fc049d4:  40 a4 60 00 dmtc0	a0,sr
  110: 	
  111: 	SCPRINT("Jumping to MAIN")
[ 111] 0x900000001fc049d8:  3c 04 90 00 lui	a0,0x9000
[ 111] 0x900000001fc049dc:  64 84 00 00 daddiu	a0,a0,0
[ 111] 0x900000001fc049e0:  00 04 24 38 dsll	a0,a0,16
[ 111] 0x900000001fc049e4:  64 84 1f c1 daddiu	a0,a0,8129
[ 111] 0x900000001fc049e8:  00 04 24 38 dsll	a0,a0,16
[ 111] 0x900000001fc049ec:  64 84 79 6f daddiu	a0,a0,31087
[ 111] 0x900000001fc049f0:  0f f0 11 7c jal		sysctlr_message
[ 111] 0x900000001fc049f4:  00 00 00 00 nop
  112: 	LEDS(PLED_MAIN)
[ 112] 0x900000001fc049f8:  00 00 00 00 nop
[ 112] 0x900000001fc049fc:  34 04 00 24 ori	a0,zero,0x24
[ 112] 0x900000001fc04a00:  3c 02 90 00 lui	v0,0x9000
[ 112] 0x900000001fc04a04:  00 02 14 38 dsll	v0,v0,16
[ 112] 0x900000001fc04a08:  34 42 19 00 ori	v0,v0,0x1900
[ 112] 0x900000001fc04a0c:  00 02 14 38 dsll	v0,v0,16
[ 112] 0x900000001fc04a10:  34 42 40 00 ori	v0,v0,0x4000
[ 112] 0x900000001fc04a14:  fc 44 00 00 sd	a0,0(v0)
  113: 	j	main			# Now call the main C routine.
[ 113] 0x900000001fc04a18:  0b f0 57 a5 j		main
  114: 	nop
[ 114] 0x900000001fc04a1c:  00 00 00 00 nop
  115: END(prom_master)
  116: 
  117: 
  118: LEAF(prom_abdicate)
  119: 	# Load diagval reg with the reason we're abdicating 
  120: 	DMTBR(a0, BR_DIAG)
prom_abdicate:
[ 120] 0x900000001fc04a20:  44 a4 28 00 dmtc1	a0,$f5
  121: 
  122: 	# Set BM "I've been master" bit
  123: 	DMFBR(t0, BR_BSR)
[ 123] 0x900000001fc04a24:  44 2c 00 00 dmfc1	t0,$f0
  124: 	ori	t0, BSR_ABDICATE
[ 124] 0x900000001fc04a28:  35 8c 20 00 ori	t0,t0,0x2000
  125: 	ori	t1, zero, BSR_EPCUART
[ 125] 0x900000001fc04a2c:  34 0d 01 00 ori	t1,zero,0x100
  126: 	not	t1
[ 126] 0x900000001fc04a30:  01 a0 68 27 nor	t1,t1,zero
  127: 	and	t0, t1			# Turn off EPC UART bit.
[ 127] 0x900000001fc04a34:  01 8d 60 24 and	t0,t0,t1
  128: 	DMTBR(t0, BR_BSR)
[ 128] 0x900000001fc04a38:  44 ac 00 00 dmtc1	t0,$f0
  129: 
  130: 	# Flush characters out of the CC UART
  131: 	jal	ccuart_flush
[ 131] 0x900000001fc04a3c:  0f f0 0c ea jal		ccuart_flush
  132: 	nop
[ 132] 0x900000001fc04a40:  00 00 00 00 nop
  133: 
  134: 	# Get out of the master group
  135: 	dli	t0, EV_IGRMASK
[ 135] 0x900000001fc04a44:  3c 0c 90 00 lui	t0,0x9000
[ 135] 0x900000001fc04a48:  00 0c 64 38 dsll	t0,t0,16
[ 135] 0x900000001fc04a4c:  35 8c 18 00 ori	t0,t0,0x1800
[ 135] 0x900000001fc04a50:  00 0c 64 38 dsll	t0,t0,16
[ 135] 0x900000001fc04a54:  35 8c 08 38 ori	t0,t0,0x838
  136: 	sd	zero, 0(t0)
[ 136] 0x900000001fc04a58:  fd 80 00 00 sd	zero,0(t0)
  137: 	
  138: 	# Send rearb character to sysctlr
  139: 	jal	ccuart_putc
[ 139] 0x900000001fc04a5c:  0f f0 0c d6 jal		ccuart_putc
  140: 	li	a0, SC_ESCAPE		# (BD)
[ 140] 0x900000001fc04a60:  24 04 00 18 li	a0,24
  141: 	jal	ccuart_putc
[ 141] 0x900000001fc04a64:  0f f0 0c d6 jal		ccuart_putc
  142: 	li	a0, SC_BMRESTART	# (BD)
[ 142] 0x900000001fc04a68:  24 04 00 12 li	a0,18
  143: 
  144: 	jal	pod_clear_ints		# Clear the interrupts the other
[ 144] 0x900000001fc04a6c:  0f f0 14 d8 jal		pod_clear_ints
  145: 	nop				# (BD) CPUs sent us
[ 145] 0x900000001fc04a70:  00 00 00 00 nop
  146: 
  147: 	# Send interrupt to slaves
  148: 	SENDINT_SLAVES(REARB_LEVEL)
[ 148] 0x900000001fc04a74:  3c 1a 90 00 lui	k0,0x9000
[ 148] 0x900000001fc04a78:  00 1a d4 38 dsll	k0,k0,16
[ 148] 0x900000001fc04a7c:  37 5a 18 00 ori	k0,k0,0x1800
[ 148] 0x900000001fc04a80:  00 1a d4 38 dsll	k0,k0,16
[ 148] 0x900000001fc04a84:  37 5a 01 00 ori	k0,k0,0x100
[ 148] 0x900000001fc04a88:  24 1b 01 41 li	k1,321
[ 148] 0x900000001fc04a8c:  ff 5b 00 00 sd	k1,0(k0)
[ 148] 0x900000001fc04a90:  00 00 00 00 nop
  149: 
  150: 	# Jump to slave loop
  151: 	j	rearb_bootmaster	# Join the rearbitartion fun!
[ 151] 0x900000001fc04a94:  0b f0 0e 5f j		rearb_bootmaster
  152: 	nop				# (BD)	
[ 152] 0x900000001fc04a98:  00 00 00 00 nop
       0x900000001fc04a9c:  00 00 00 00 nop
Skipping source listing to line 90 of /cores/banyan/stand/arcs/IP25prom/pod_cc.s...
   91:  * Returns:	0 - success
   92:  *		!0 - failed
   93:  */
   94: LEAF(pod_check_cclocal)
   95: 	.set	noreorder
   96: 	/*
   97: 	 * Using the CCT table, check all of the requested
   98: 	 * read/write registers.
   99: 	 */
  100: 	dla	v0,ccLocalTest
pod_check_cclocal:
[ 100] 0x900000001fc04aa0:  3c 02 90 00 lui	v0,0x9000
[ 100] 0x900000001fc04aa4:  64 42 00 00 daddiu	v0,v0,0
[ 100] 0x900000001fc04aa8:  00 02 14 38 dsll	v0,v0,16
[ 100] 0x900000001fc04aac:  64 42 1f c2 daddiu	v0,v0,8130
[ 100] 0x900000001fc04ab0:  00 02 14 38 dsll	v0,v0,16
[ 100] 0x900000001fc04ab4:  64 42 9a 20 daddiu	v0,v0,-26080
  101: 	dla	v1,ccLocalTestEnd
[ 101] 0x900000001fc04ab8:  3c 03 90 00 lui	v1,0x9000
[ 101] 0x900000001fc04abc:  64 63 00 00 daddiu	v1,v1,0
[ 101] 0x900000001fc04ac0:  00 03 1c 38 dsll	v1,v1,16
[ 101] 0x900000001fc04ac4:  64 63 1f c2 daddiu	v1,v1,8130
[ 101] 0x900000001fc04ac8:  00 03 1c 38 dsll	v1,v1,16
[ 101] 0x900000001fc04acc:  64 63 9b 40 daddiu	v1,v1,-25792
  102: 1:	
  103: 	bgeu	v0,v1,2f
[ 103] 0x900000001fc04ad0:  00 43 08 2b sltu	at,v0,v1
[ 103] 0x900000001fc04ad4:  10 20 00 0a beq	at,zero,0x900000001fc04b00
  104:         nop
[ 104] 0x900000001fc04ad8:  00 00 00 00 nop
  105: 	ld	a0,CCT_ADDRESS(v0)	/* Pick up address */
[ 105] 0x900000001fc04adc:  dc 44 00 00 ld	a0,0(v0)
  106: 	ld	t0,CCT_VALUE(v0)	/* And data */
[ 106] 0x900000001fc04ae0:  dc 4c 00 08 ld	t0,8(v0)
  107: 	sd	t0,0(a0)		/* Bang */
[ 107] 0x900000001fc04ae4:  fc 8c 00 00 sd	t0,0(a0)
  108: 	ld	t1,0(a0)		/* And back */
[ 108] 0x900000001fc04ae8:  dc 8d 00 00 ld	t1,0(a0)
  109: 	bne	t0,t1,ccLocalFailed	/* Error --- */
[ 109] 0x900000001fc04aec:  15 8d 00 38 bne	t0,t1,0x900000001fc04bd0
  110: 	nop
[ 110] 0x900000001fc04af0:  00 00 00 00 nop
  111: 	daddiu	v0,CCT_SIZE		/* Next entry */
[ 111] 0x900000001fc04af4:  64 42 00 10 daddiu	v0,v0,16
  112: 	b	1b		
[ 112] 0x900000001fc04af8:  10 00 ff f5 b		0x900000001fc04ad0
  113: 	nop				/* DELAY: */
[ 113] 0x900000001fc04afc:  00 00 00 00 nop
  114: 	
  115: 2:	
  116: 	/*
  117: 	 * Success so far, continue testing those registers that can't
  118: 	 * be simply table driven.
  119: 	 */	
  120: 	dli	a0, EV_IP0		/* a0 = IP0 addr */
[ 120] 0x900000001fc04b00:  3c 04 90 00 lui	a0,0x9000
[ 120] 0x900000001fc04b04:  00 04 24 38 dsll	a0,a0,16
[ 120] 0x900000001fc04b08:  34 84 18 00 ori	a0,a0,0x1800
[ 120] 0x900000001fc04b0c:  00 04 24 38 dsll	a0,a0,16
[ 120] 0x900000001fc04b10:  34 84 08 00 ori	a0,a0,0x800
  121: 	li	a1, 1
[ 121] 0x900000001fc04b14:  24 05 00 01 li	a1,1
  122: 	sd	a1 0(a0)		/* EV_IP0 = 1 */
[ 122] 0x900000001fc04b18:  fc 85 00 00 sd	a1,0(a0)
  123: 	dli	a2, EV_CIPL0
[ 123] 0x900000001fc04b1c:  3c 06 90 00 lui	a2,0x9000
[ 123] 0x900000001fc04b20:  00 06 34 38 dsll	a2,a2,16
[ 123] 0x900000001fc04b24:  34 c6 18 00 ori	a2,a2,0x1800
[ 123] 0x900000001fc04b28:  00 06 34 38 dsll	a2,a2,16
[ 123] 0x900000001fc04b2c:  34 c6 08 30 ori	a2,a2,0x830
  124: 	sd	zero, 0(a2)		/* Clear level 0 intr., prior 0 */
[ 124] 0x900000001fc04b30:  fc c0 00 00 sd	zero,0(a2)
  125: 	ld	a3, 0(a0)		/* a3 = EV_IP0  */
[ 125] 0x900000001fc04b34:  dc 87 00 00 ld	a3,0(a0)
  126: #ifndef	SABLE
  127: 	bne	a3, zero, ccLocalFailed	/* Should have been cleared */
[ 127] 0x900000001fc04b38:  14 e0 00 25 bne	a3,zero,0x900000001fc04bd0
  128: 	nop
[ 128] 0x900000001fc04b3c:  00 00 00 00 nop
  129: #endif
  130: 
  131: 	dli	a0, EV_IP1		# a0 = IP1 addr
[ 131] 0x900000001fc04b40:  3c 04 90 00 lui	a0,0x9000
[ 131] 0x900000001fc04b44:  00 04 24 38 dsll	a0,a0,16
[ 131] 0x900000001fc04b48:  34 84 18 00 ori	a0,a0,0x1800
[ 131] 0x900000001fc04b4c:  00 04 24 38 dsll	a0,a0,16
[ 131] 0x900000001fc04b50:  34 84 08 08 ori	a0,a0,0x808
  132: 	li	a1, 1
[ 132] 0x900000001fc04b54:  24 05 00 01 li	a1,1
  133: 	sd	a1 0(a0)		# EV_IP1 = 1
[ 133] 0x900000001fc04b58:  fc 85 00 00 sd	a1,0(a0)
  134: 	dli	a2, EV_CIPL0
[ 134] 0x900000001fc04b5c:  3c 06 90 00 lui	a2,0x9000
[ 134] 0x900000001fc04b60:  00 06 34 38 dsll	a2,a2,16
[ 134] 0x900000001fc04b64:  34 c6 18 00 ori	a2,a2,0x1800
[ 134] 0x900000001fc04b68:  00 06 34 38 dsll	a2,a2,16
[ 134] 0x900000001fc04b6c:  34 c6 08 30 ori	a2,a2,0x830
  135: 	li	a3, 64
[ 135] 0x900000001fc04b70:  24 07 00 40 li	a3,64
  136: 	sd	a3, 0(a2)		# Clear level 0 intr., prior 64
[ 136] 0x900000001fc04b74:  fc c7 00 00 sd	a3,0(a2)
  137: 	ld	a3, 0(a0)		# a3 = EV_IP1
[ 137] 0x900000001fc04b78:  dc 87 00 00 ld	a3,0(a0)
  138: #ifndef	SABLE
  139: 	bne	a3, zero, ccLocalFailed	/* Should have been cleared */
[ 139] 0x900000001fc04b7c:  14 e0 00 14 bne	a3,zero,0x900000001fc04bd0
  140: 	nop
[ 140] 0x900000001fc04b80:  00 00 00 00 nop
  141: #endif
  142: 	
  143: 	dli	a2, EV_CERTOIP
[ 143] 0x900000001fc04b84:  3c 06 90 00 lui	a2,0x9000
[ 143] 0x900000001fc04b88:  00 06 34 38 dsll	a2,a2,16
[ 143] 0x900000001fc04b8c:  34 c6 18 00 ori	a2,a2,0x1800
[ 143] 0x900000001fc04b90:  00 06 34 38 dsll	a2,a2,16
[ 143] 0x900000001fc04b94:  34 c6 09 08 ori	a2,a2,0x908
  144: 	dli	a1, EV_CERTOIP_MASK
[ 144] 0x900000001fc04b98:  3c 05 00 1f lui	a1,0x1f
[ 144] 0x900000001fc04b9c:  34 a5 ff ff ori	a1,a1,0xffff
  145: 	dli	a0, EV_ERTOIP
[ 145] 0x900000001fc04ba0:  3c 04 90 00 lui	a0,0x9000
[ 145] 0x900000001fc04ba4:  00 04 24 38 dsll	a0,a0,16
[ 145] 0x900000001fc04ba8:  34 84 18 00 ori	a0,a0,0x1800
[ 145] 0x900000001fc04bac:  00 04 24 38 dsll	a0,a0,16
[ 145] 0x900000001fc04bb0:  34 84 09 00 ori	a0,a0,0x900
  146: 	sd	a1, 0(a2)		# Clear EV_ERTOIP
[ 146] 0x900000001fc04bb4:  fc c5 00 00 sd	a1,0(a2)
  147: 	ld	a3, 0(a0)		# a3 = EV_ERTOIP
[ 147] 0x900000001fc04bb8:  dc 87 00 00 ld	a3,0(a0)
  148: 	nop
[ 148] 0x900000001fc04bbc:  00 00 00 00 nop
  149: 	bne	a3, zero, ccLocalFailed
[ 149] 0x900000001fc04bc0:  14 e0 00 03 bne	a3,zero,0x900000001fc04bd0
  150: 	nop
[ 150] 0x900000001fc04bc4:  00 00 00 00 nop
  151: 
  152: 	j	ra			# Return address is in v1
[ 152] 0x900000001fc04bc8:  03 e0 00 08 jr	ra
  153: 	move	v0, zero		# Return value (BD)
[ 153] 0x900000001fc04bcc:  00 00 10 25 move	v0,zero
  154: 	END(pod_check_cclocal)
  155: 
  156: LEAF(ccLocalFailed)
  157: 	LEDS(PLED_CCLFAILED_INITUART)
ccLocalFailed:
[ 157] 0x900000001fc04bd0:  00 00 00 00 nop
[ 157] 0x900000001fc04bd4:  34 04 00 12 ori	a0,zero,0x12
[ 157] 0x900000001fc04bd8:  3c 02 90 00 lui	v0,0x9000
[ 157] 0x900000001fc04bdc:  00 02 14 38 dsll	v0,v0,16
[ 157] 0x900000001fc04be0:  34 42 19 00 ori	v0,v0,0x1900
[ 157] 0x900000001fc04be4:  00 02 14 38 dsll	v0,v0,16
[ 157] 0x900000001fc04be8:  34 42 40 00 ori	v0,v0,0x4000
[ 157] 0x900000001fc04bec:  fc 44 00 00 sd	a0,0(v0)
  158: 	jal	ccuart_init
[ 158] 0x900000001fc04bf0:  0f f0 0c a5 jal		ccuart_init
  159: 	FLASH(FLED_CCLOCAL)
[ 159] 0x900000001fc04bf4:  00 00 00 00 nop
[ 159] 0x900000001fc04bf8:  34 04 00 31 ori	a0,zero,0x31
[ 159] 0x900000001fc04bfc:  0f f0 0c 7f jal		flash_cc_leds
[ 159] 0x900000001fc04c00:  00 00 00 00 nop
  160: 	END(ccLocalFailed)
  161: 
  162: LEAF(clock_fail)
  163: 	LEDS(PLED_NOCLOCK_INITUART)
clock_fail:
[ 163] 0x900000001fc04c04:  00 00 00 00 nop
[ 163] 0x900000001fc04c08:  34 04 00 15 ori	a0,zero,0x15
[ 163] 0x900000001fc04c0c:  3c 02 90 00 lui	v0,0x9000
[ 163] 0x900000001fc04c10:  00 02 14 38 dsll	v0,v0,16
[ 163] 0x900000001fc04c14:  34 42 19 00 ori	v0,v0,0x1900
[ 163] 0x900000001fc04c18:  00 02 14 38 dsll	v0,v0,16
[ 163] 0x900000001fc04c1c:  34 42 40 00 ori	v0,v0,0x4000
[ 163] 0x900000001fc04c20:  fc 44 00 00 sd	a0,0(v0)
  164: 	jal	ccuart_init 	        # Call the UART configuration code
[ 164] 0x900000001fc04c24:  0f f0 0c a5 jal		ccuart_init
  165: 	nop				# (BD)
[ 165] 0x900000001fc04c28:  00 00 00 00 nop
  166: 	FLASH(FLED_CCCLOCK)
[ 166] 0x900000001fc04c2c:  00 00 00 00 nop
[ 166] 0x900000001fc04c30:  34 04 00 33 ori	a0,zero,0x33
[ 166] 0x900000001fc04c34:  0f f0 0c 7f jal		flash_cc_leds
[ 166] 0x900000001fc04c38:  00 00 00 00 nop
  167: 	END(clock_fail)
  168: 
  169: LEAF(pod_check_ccconfig)
  170: 
  171: 	LEDS(PLED_CKCCCONFIG)
pod_check_ccconfig:
[ 171] 0x900000001fc04c3c:  00 00 00 00 nop
[ 171] 0x900000001fc04c40:  34 04 00 08 ori	a0,zero,0x8
[ 171] 0x900000001fc04c44:  3c 02 90 00 lui	v0,0x9000
[ 171] 0x900000001fc04c48:  00 02 14 38 dsll	v0,v0,16
[ 171] 0x900000001fc04c4c:  34 42 19 00 ori	v0,v0,0x1900
[ 171] 0x900000001fc04c50:  00 02 14 38 dsll	v0,v0,16
[ 171] 0x900000001fc04c54:  34 42 40 00 ori	v0,v0,0x4000
[ 171] 0x900000001fc04c58:  fc 44 00 00 sd	a0,0(v0)
  172: 
  173: 	move	v1, ra			# Save return address
[ 173] 0x900000001fc04c5c:  03 e0 18 25 move	v1,ra
  174: 
  175: 	# Start the clock by sending the sync interrupt
  176: 
  177: 	dli	a0, EV_SENDINT
[ 177] 0x900000001fc04c60:  3c 04 90 00 lui	a0,0x9000
[ 177] 0x900000001fc04c64:  00 04 24 38 dsll	a0,a0,16
[ 177] 0x900000001fc04c68:  34 84 18 00 ori	a0,a0,0x1800
[ 177] 0x900000001fc04c6c:  00 04 24 38 dsll	a0,a0,16
[ 177] 0x900000001fc04c70:  34 84 01 00 ori	a0,a0,0x100
  178: 	li	a1, SYNC_DEST		# Clock sync interrupt number
[ 178] 0x900000001fc04c74:  24 05 00 50 li	a1,80
  179: 	sd	a1, 0(a0)
[ 179] 0x900000001fc04c78:  fc 85 00 00 sd	a1,0(a0)
  180: 
  181: 	# Get our slot and processor number.
  182: 
  183: 	EV_GET_SPNUM(t0, t1)		# t0 = slot number
[ 183] 0x900000001fc04c7c:  3c 0c 90 00 lui	t0,0x9000
[ 183] 0x900000001fc04c80:  00 0c 64 38 dsll	t0,t0,16
[ 183] 0x900000001fc04c84:  35 8c 18 00 ori	t0,t0,0x1800
[ 183] 0x900000001fc04c88:  00 0c 64 38 dsll	t0,t0,16
[ 183] 0x900000001fc04c8c:  35 8c 00 08 ori	t0,t0,0x8
[ 183] 0x900000001fc04c90:  dd 8c 00 00 ld	t0,0(t0)
[ 183] 0x900000001fc04c94:  00 00 00 00 nop
[ 183] 0x900000001fc04c98:  31 8c 00 3f andi	t0,t0,0x3f
[ 183] 0x900000001fc04c9c:  31 8d 00 03 andi	t1,t0,0x3
[ 183] 0x900000001fc04ca0:  01 a0 68 21 addu	t1,t1,0
[ 183] 0x900000001fc04ca4:  00 0c 60 82 srl	t0,t0,2
  184: 					# t1 = processor number
  185: 
  186: 	# Is my board listed in the system configuration information?
  187: 
  188: 	dli	a0, EV_SYSCONFIG
[ 188] 0x900000001fc04ca8:  3c 04 90 00 lui	a0,0x9000
[ 188] 0x900000001fc04cac:  00 04 24 38 dsll	a0,a0,16
[ 188] 0x900000001fc04cb0:  34 84 18 00 ori	a0,a0,0x1800
[ 188] 0x900000001fc04cb4:  00 04 24 38 dsll	a0,a0,16
[ 188] 0x900000001fc04cb8:  34 84 02 00 ori	a0,a0,0x200
  189: 	ld	a1, 0(a0)		# a1 = system configuration bit vector
[ 189] 0x900000001fc04cbc:  dc 85 00 00 ld	a1,0(a0)
  190: 	li	a2, 1
[ 190] 0x900000001fc04cc0:  24 06 00 01 li	a2,1
  191: 	sll	a2, a2, t0		# 1 in position of board in bit vector
[ 191] 0x900000001fc04cc4:  01 86 30 04 sllv	a2,a2,t0
  192: 	sll	a3, a2, 16		# 1 in position of CPU board in vector
[ 192] 0x900000001fc04cc8:  00 06 3c 00 sll	a3,a2,16
  193: 	and	k0, a1, a2
[ 193] 0x900000001fc04ccc:  00 a6 d0 24 and	k0,a1,a2
  194: 	and	k1, a3, a1
[ 194] 0x900000001fc04cd0:  00 e5 d8 24 and	k1,a3,a1
  195: 	bne	k0, a2, ccconfig_fail
[ 195] 0x900000001fc04cd4:  17 46 00 b5 bne	k0,a2,0x900000001fc04fac
  196:         nop
[ 196] 0x900000001fc04cd8:  00 00 00 00 nop
  197: 	bne	k1, a3, ccconfig_fail
[ 197] 0x900000001fc04cdc:  17 67 00 b3 bne	k1,a3,0x900000001fc04fac
  198: 	nop
[ 198] 0x900000001fc04ce0:  00 00 00 00 nop
  199: 
  200: 	# Make sure the clock is running
  201: 
  202: 	dli	a0, EV_RTC
[ 202] 0x900000001fc04ce4:  3c 04 90 00 lui	a0,0x9000
[ 202] 0x900000001fc04ce8:  00 04 24 38 dsll	a0,a0,16
[ 202] 0x900000001fc04cec:  34 84 18 02 ori	a0,a0,0x1802
[ 202] 0x900000001fc04cf0:  00 04 24 38 dsll	a0,a0,16
[ 202] 0x900000001fc04cf4:  34 84 00 00 ori	a0,a0,0
  203: 	ld	a1, 0(a0)		# a1 = time in nanoseconds
[ 203] 0x900000001fc04cf8:  dc 85 00 00 ld	a1,0(a0)
  204: 	nop
[ 204] 0x900000001fc04cfc:  00 00 00 00 nop
  205: 
  206: 	dli	a0, EV_SYSCONFIG
[ 206] 0x900000001fc04d00:  3c 04 90 00 lui	a0,0x9000
[ 206] 0x900000001fc04d04:  00 04 24 38 dsll	a0,a0,16
[ 206] 0x900000001fc04d08:  34 84 18 00 ori	a0,a0,0x1800
[ 206] 0x900000001fc04d0c:  00 04 24 38 dsll	a0,a0,16
[ 206] 0x900000001fc04d10:  34 84 02 00 ori	a0,a0,0x200
  207: 	ld	a0, 0(a0)		# Give the poor guy a chance...
[ 207] 0x900000001fc04d14:  dc 84 00 00 ld	a0,0(a0)
  208: 
  209: 	dli	a0, EV_RTC
[ 209] 0x900000001fc04d18:  3c 04 90 00 lui	a0,0x9000
[ 209] 0x900000001fc04d1c:  00 04 24 38 dsll	a0,a0,16
[ 209] 0x900000001fc04d20:  34 84 18 02 ori	a0,a0,0x1802
[ 209] 0x900000001fc04d24:  00 04 24 38 dsll	a0,a0,16
[ 209] 0x900000001fc04d28:  34 84 00 00 ori	a0,a0,0
  210: 	ld	a2, 0(a0)		# a2 = time a little later 
[ 210] 0x900000001fc04d2c:  dc 86 00 00 ld	a2,0(a0)
  211: 	nop	
[ 211] 0x900000001fc04d30:  00 00 00 00 nop
  212: #ifndef SABLE
  213: 	beq	a1, a2, clock_fail	# if the time hasn't changed, fail
[ 213] 0x900000001fc04d34:  10 a6 ff b3 beq	a1,a2,0x900000001fc04c04
  214: 	nop
[ 214] 0x900000001fc04d38:  00 00 00 00 nop
  215: #endif
  216: 
  217: 	# Test timer config registers
  218: 
  219: 	
  220: 	li	a0, 0x78			# Set LSB
[ 220] 0x900000001fc04d3c:  24 04 00 78 li	a0,120
  221: 	EV_SET_PROCREG(t0, t1, EV_CFG_CMPREG0, a0)
[ 221] 0x900000001fc04d40:  00 0d d9 80 sll	k1,t1,6
[ 221] 0x900000001fc04d44:  63 7b 00 10 daddi	k1,k1,16
[ 221] 0x900000001fc04d48:  00 0c d2 c0 sll	k0,t0,11
[ 221] 0x900000001fc04d4c:  3c 01 90 00 lui	at,0x9000
[ 221] 0x900000001fc04d50:  00 01 0c 38 dsll	at,at,16
[ 221] 0x900000001fc04d54:  34 21 18 00 ori	at,at,0x1800
[ 221] 0x900000001fc04d58:  00 01 0c 38 dsll	at,at,16
[ 221] 0x900000001fc04d5c:  34 21 80 00 ori	at,at,0x8000
[ 221] 0x900000001fc04d60:  03 41 d0 2c dadd	k0,k0,at
[ 221] 0x900000001fc04d64:  00 1b d8 2c dadd	k1,zero,k1
[ 221] 0x900000001fc04d68:  00 1b d8 c0 sll	k1,k1,3
[ 221] 0x900000001fc04d6c:  03 5b d0 2c dadd	k0,k0,k1
[ 221] 0x900000001fc04d70:  00 04 d8 25 or	k1,zero,a0
[ 221] 0x900000001fc04d74:  ff 5b 00 00 sd	k1,0(k0)
[ 221] 0x900000001fc04d78:  00 00 00 00 nop
  222: 
  223: 	li	a0, 0x56			# Set next MS byte
[ 223] 0x900000001fc04d7c:  24 04 00 56 li	a0,86
  224: 	EV_SET_PROCREG(t0, t1, EV_CFG_CMPREG1, a0)
[ 224] 0x900000001fc04d80:  00 0d d9 80 sll	k1,t1,6
[ 224] 0x900000001fc04d84:  63 7b 00 11 daddi	k1,k1,17
[ 224] 0x900000001fc04d88:  00 0c d2 c0 sll	k0,t0,11
[ 224] 0x900000001fc04d8c:  3c 01 90 00 lui	at,0x9000
[ 224] 0x900000001fc04d90:  00 01 0c 38 dsll	at,at,16
[ 224] 0x900000001fc04d94:  34 21 18 00 ori	at,at,0x1800
[ 224] 0x900000001fc04d98:  00 01 0c 38 dsll	at,at,16
[ 224] 0x900000001fc04d9c:  34 21 80 00 ori	at,at,0x8000
[ 224] 0x900000001fc04da0:  03 41 d0 2c dadd	k0,k0,at
[ 224] 0x900000001fc04da4:  00 1b d8 2c dadd	k1,zero,k1
[ 224] 0x900000001fc04da8:  00 1b d8 c0 sll	k1,k1,3
[ 224] 0x900000001fc04dac:  03 5b d0 2c dadd	k0,k0,k1
[ 224] 0x900000001fc04db0:  00 04 d8 25 or	k1,zero,a0
[ 224] 0x900000001fc04db4:  ff 5b 00 00 sd	k1,0(k0)
[ 224] 0x900000001fc04db8:  00 00 00 00 nop
  225: 
  226: 	li	a0, 0x34			# Set next MS byte
[ 226] 0x900000001fc04dbc:  24 04 00 34 li	a0,52
  227: 	EV_SET_PROCREG(t0, t1, EV_CFG_CMPREG2, a0)
[ 227] 0x900000001fc04dc0:  00 0d d9 80 sll	k1,t1,6
[ 227] 0x900000001fc04dc4:  63 7b 00 12 daddi	k1,k1,18
[ 227] 0x900000001fc04dc8:  00 0c d2 c0 sll	k0,t0,11
[ 227] 0x900000001fc04dcc:  3c 01 90 00 lui	at,0x9000
[ 227] 0x900000001fc04dd0:  00 01 0c 38 dsll	at,at,16
[ 227] 0x900000001fc04dd4:  34 21 18 00 ori	at,at,0x1800
[ 227] 0x900000001fc04dd8:  00 01 0c 38 dsll	at,at,16
[ 227] 0x900000001fc04ddc:  34 21 80 00 ori	at,at,0x8000
[ 227] 0x900000001fc04de0:  03 41 d0 2c dadd	k0,k0,at
[ 227] 0x900000001fc04de4:  00 1b d8 2c dadd	k1,zero,k1
[ 227] 0x900000001fc04de8:  00 1b d8 c0 sll	k1,k1,3
[ 227] 0x900000001fc04dec:  03 5b d0 2c dadd	k0,k0,k1
[ 227] 0x900000001fc04df0:  00 04 d8 25 or	k1,zero,a0
[ 227] 0x900000001fc04df4:  ff 5b 00 00 sd	k1,0(k0)
[ 227] 0x900000001fc04df8:  00 00 00 00 nop
  228: 
  229: 	li	a0, 0x12			# Set MSB
[ 229] 0x900000001fc04dfc:  24 04 00 12 li	a0,18
  230: 	EV_SET_PROCREG(t0, t1, EV_CFG_CMPREG3, a0)
[ 230] 0x900000001fc04e00:  00 0d d9 80 sll	k1,t1,6
[ 230] 0x900000001fc04e04:  63 7b 00 13 daddi	k1,k1,19
[ 230] 0x900000001fc04e08:  00 0c d2 c0 sll	k0,t0,11
[ 230] 0x900000001fc04e0c:  3c 01 90 00 lui	at,0x9000
[ 230] 0x900000001fc04e10:  00 01 0c 38 dsll	at,at,16
[ 230] 0x900000001fc04e14:  34 21 18 00 ori	at,at,0x1800
[ 230] 0x900000001fc04e18:  00 01 0c 38 dsll	at,at,16
[ 230] 0x900000001fc04e1c:  34 21 80 00 ori	at,at,0x8000
[ 230] 0x900000001fc04e20:  03 41 d0 2c dadd	k0,k0,at
[ 230] 0x900000001fc04e24:  00 1b d8 2c dadd	k1,zero,k1
[ 230] 0x900000001fc04e28:  00 1b d8 c0 sll	k1,k1,3
[ 230] 0x900000001fc04e2c:  03 5b d0 2c dadd	k0,k0,k1
[ 230] 0x900000001fc04e30:  00 04 d8 25 or	k1,zero,a0
[ 230] 0x900000001fc04e34:  ff 5b 00 00 sd	k1,0(k0)
[ 230] 0x900000001fc04e38:  00 00 00 00 nop
  231: 
  232: 	dli	a0, EV_SYSCONFIG
[ 232] 0x900000001fc04e3c:  3c 04 90 00 lui	a0,0x9000
[ 232] 0x900000001fc04e40:  00 04 24 38 dsll	a0,a0,16
[ 232] 0x900000001fc04e44:  34 84 18 00 ori	a0,a0,0x1800
[ 232] 0x900000001fc04e48:  00 04 24 38 dsll	a0,a0,16
[ 232] 0x900000001fc04e4c:  34 84 02 00 ori	a0,a0,0x200
  233: 	ld	a0, 0(a0)			# Stall until config write
[ 233] 0x900000001fc04e50:  dc 84 00 00 ld	a0,0(a0)
  234: 						# completes...
  235: 
  236: 	li	a0, 0x12345678			# Sign bit needs to be 0
[ 236] 0x900000001fc04e54:  3c 04 12 34 lui	a0,0x1234
[ 236] 0x900000001fc04e58:  34 84 56 78 ori	a0,a0,0x5678
  237: 	dli	a3, EV_RO_COMPARE
[ 237] 0x900000001fc04e5c:  3c 07 90 00 lui	a3,0x9000
[ 237] 0x900000001fc04e60:  00 07 3c 38 dsll	a3,a3,16
[ 237] 0x900000001fc04e64:  34 e7 18 00 ori	a3,a3,0x1800
[ 237] 0x900000001fc04e68:  00 07 3c 38 dsll	a3,a3,16
[ 237] 0x900000001fc04e6c:  34 e7 0a 00 ori	a3,a3,0xa00
  238: 	ld	a1, 0(a3)			# Read back the test value
[ 238] 0x900000001fc04e70:  dc e5 00 00 ld	a1,0(a3)
  239: 	nop
[ 239] 0x900000001fc04e74:  00 00 00 00 nop
  240: #ifndef SABLE
  241: 	bne 	a0, a1, ccconfig_fail
[ 241] 0x900000001fc04e78:  14 85 00 4c bne	a0,a1,0x900000001fc04fac
  242: 	nop
[ 242] 0x900000001fc04e7c:  00 00 00 00 nop
  243: #endif
  244: 
  245: 	move	a0, zero				# Set LSB
[ 245] 0x900000001fc04e80:  00 00 20 25 move	a0,zero
  246: 	EV_SET_PROCREG(t0, t1, EV_CFG_CMPREG0, a0)
[ 246] 0x900000001fc04e84:  00 0d d9 80 sll	k1,t1,6
[ 246] 0x900000001fc04e88:  63 7b 00 10 daddi	k1,k1,16
[ 246] 0x900000001fc04e8c:  00 0c d2 c0 sll	k0,t0,11
[ 246] 0x900000001fc04e90:  3c 01 90 00 lui	at,0x9000
[ 246] 0x900000001fc04e94:  00 01 0c 38 dsll	at,at,16
[ 246] 0x900000001fc04e98:  34 21 18 00 ori	at,at,0x1800
[ 246] 0x900000001fc04e9c:  00 01 0c 38 dsll	at,at,16
[ 246] 0x900000001fc04ea0:  34 21 80 00 ori	at,at,0x8000
[ 246] 0x900000001fc04ea4:  03 41 d0 2c dadd	k0,k0,at
[ 246] 0x900000001fc04ea8:  00 1b d8 2c dadd	k1,zero,k1
[ 246] 0x900000001fc04eac:  00 1b d8 c0 sll	k1,k1,3
[ 246] 0x900000001fc04eb0:  03 5b d0 2c dadd	k0,k0,k1
[ 246] 0x900000001fc04eb4:  00 04 d8 25 or	k1,zero,a0
[ 246] 0x900000001fc04eb8:  ff 5b 00 00 sd	k1,0(k0)
[ 246] 0x900000001fc04ebc:  00 00 00 00 nop
  247: 
  248: 	move	a0, zero				# Set next MS byte
[ 248] 0x900000001fc04ec0:  00 00 20 25 move	a0,zero
  249: 	EV_SET_PROCREG(t0, t1, EV_CFG_CMPREG1, a0)
[ 249] 0x900000001fc04ec4:  00 0d d9 80 sll	k1,t1,6
[ 249] 0x900000001fc04ec8:  63 7b 00 11 daddi	k1,k1,17
[ 249] 0x900000001fc04ecc:  00 0c d2 c0 sll	k0,t0,11
[ 249] 0x900000001fc04ed0:  3c 01 90 00 lui	at,0x9000
[ 249] 0x900000001fc04ed4:  00 01 0c 38 dsll	at,at,16
[ 249] 0x900000001fc04ed8:  34 21 18 00 ori	at,at,0x1800
[ 249] 0x900000001fc04edc:  00 01 0c 38 dsll	at,at,16
[ 249] 0x900000001fc04ee0:  34 21 80 00 ori	at,at,0x8000
[ 249] 0x900000001fc04ee4:  03 41 d0 2c dadd	k0,k0,at
[ 249] 0x900000001fc04ee8:  00 1b d8 2c dadd	k1,zero,k1
[ 249] 0x900000001fc04eec:  00 1b d8 c0 sll	k1,k1,3
[ 249] 0x900000001fc04ef0:  03 5b d0 2c dadd	k0,k0,k1
[ 249] 0x900000001fc04ef4:  00 04 d8 25 or	k1,zero,a0
[ 249] 0x900000001fc04ef8:  ff 5b 00 00 sd	k1,0(k0)
[ 249] 0x900000001fc04efc:  00 00 00 00 nop
  250: 
  251: 	move	a0, zero				# Set next MS byte
[ 251] 0x900000001fc04f00:  00 00 20 25 move	a0,zero
  252: 	EV_SET_PROCREG(t0, t1, EV_CFG_CMPREG2, a0)
[ 252] 0x900000001fc04f04:  00 0d d9 80 sll	k1,t1,6
[ 252] 0x900000001fc04f08:  63 7b 00 12 daddi	k1,k1,18
[ 252] 0x900000001fc04f0c:  00 0c d2 c0 sll	k0,t0,11
[ 252] 0x900000001fc04f10:  3c 01 90 00 lui	at,0x9000
[ 252] 0x900000001fc04f14:  00 01 0c 38 dsll	at,at,16
[ 252] 0x900000001fc04f18:  34 21 18 00 ori	at,at,0x1800
[ 252] 0x900000001fc04f1c:  00 01 0c 38 dsll	at,at,16
[ 252] 0x900000001fc04f20:  34 21 80 00 ori	at,at,0x8000
[ 252] 0x900000001fc04f24:  03 41 d0 2c dadd	k0,k0,at
[ 252] 0x900000001fc04f28:  00 1b d8 2c dadd	k1,zero,k1
[ 252] 0x900000001fc04f2c:  00 1b d8 c0 sll	k1,k1,3
[ 252] 0x900000001fc04f30:  03 5b d0 2c dadd	k0,k0,k1
[ 252] 0x900000001fc04f34:  00 04 d8 25 or	k1,zero,a0
[ 252] 0x900000001fc04f38:  ff 5b 00 00 sd	k1,0(k0)
[ 252] 0x900000001fc04f3c:  00 00 00 00 nop
  253: 
  254: 	move	a0, zero				# Set MSB
[ 254] 0x900000001fc04f40:  00 00 20 25 move	a0,zero
  255: 	EV_SET_PROCREG(t0, t1, EV_CFG_CMPREG3, a0)
[ 255] 0x900000001fc04f44:  00 0d d9 80 sll	k1,t1,6
[ 255] 0x900000001fc04f48:  63 7b 00 13 daddi	k1,k1,19
[ 255] 0x900000001fc04f4c:  00 0c d2 c0 sll	k0,t0,11
[ 255] 0x900000001fc04f50:  3c 01 90 00 lui	at,0x9000
[ 255] 0x900000001fc04f54:  00 01 0c 38 dsll	at,at,16
[ 255] 0x900000001fc04f58:  34 21 18 00 ori	at,at,0x1800
[ 255] 0x900000001fc04f5c:  00 01 0c 38 dsll	at,at,16
[ 255] 0x900000001fc04f60:  34 21 80 00 ori	at,at,0x8000
[ 255] 0x900000001fc04f64:  03 41 d0 2c dadd	k0,k0,at
[ 255] 0x900000001fc04f68:  00 1b d8 2c dadd	k1,zero,k1
[ 255] 0x900000001fc04f6c:  00 1b d8 c0 sll	k1,k1,3
[ 255] 0x900000001fc04f70:  03 5b d0 2c dadd	k0,k0,k1
[ 255] 0x900000001fc04f74:  00 04 d8 25 or	k1,zero,a0
[ 255] 0x900000001fc04f78:  ff 5b 00 00 sd	k1,0(k0)
[ 255] 0x900000001fc04f7c:  00 00 00 00 nop
  256: 
  257: 	dli	a3, EV_RO_COMPARE
[ 257] 0x900000001fc04f80:  3c 07 90 00 lui	a3,0x9000
[ 257] 0x900000001fc04f84:  00 07 3c 38 dsll	a3,a3,16
[ 257] 0x900000001fc04f88:  34 e7 18 00 ori	a3,a3,0x1800
[ 257] 0x900000001fc04f8c:  00 07 3c 38 dsll	a3,a3,16
[ 257] 0x900000001fc04f90:  34 e7 0a 00 ori	a3,a3,0xa00
  258: 	ld	a1, 0(a3)			# Read back the test value
[ 258] 0x900000001fc04f94:  dc e5 00 00 ld	a1,0(a3)
  259: 	nop
[ 259] 0x900000001fc04f98:  00 00 00 00 nop
  260: #ifndef SABLE
  261: 	bne	a0, a1, ccconfig_fail
[ 261] 0x900000001fc04f9c:  14 85 00 03 bne	a0,a1,0x900000001fc04fac
  262: 	nop
[ 262] 0x900000001fc04fa0:  00 00 00 00 nop
  263: #endif
  264: 	j	v1				# Return address is in v1
[ 264] 0x900000001fc04fa4:  00 60 00 08 jr	v1
  265: 	move	v0, zero			# Return value (BD)
[ 265] 0x900000001fc04fa8:  00 00 10 25 move	v0,zero
  266: 
  267: END(pod_check_ccconfig)
  268: 
  269: LEAF(ccconfig_fail)
  270: 	jal	set_cc_leds		# Set the LEDs
ccconfig_fail:
[ 270] 0x900000001fc04fac:  0f f0 0c 78 jal		set_cc_leds
  271: 	li	a0, PLED_CCCFAILED_INITUART	# (BD)
[ 271] 0x900000001fc04fb0:  24 04 00 14 li	a0,20
  272: 	jal	ccuart_init	        # Call the UART configuration code
[ 272] 0x900000001fc04fb4:  0f f0 0c a5 jal		ccuart_init
  273: 	nop				# (BD)
[ 273] 0x900000001fc04fb8:  00 00 00 00 nop
  274: 	j	flash_cc_leds
[ 274] 0x900000001fc04fbc:  0b f0 0c 7f j		flash_cc_leds
  275: 	ori	a0, zero, FLED_CCCONFIG	# Load flash value (BD)
[ 275] 0x900000001fc04fc0:  34 04 00 32 ori	a0,zero,0x32
  276: 	END(ccconfig_fail)
  277: 
  278: LEAF(pod_check_achip)
  279: 	.set	noreorder
  280: 	move	v1, ra			# Save return address
pod_check_achip:
[ 280] 0x900000001fc04fc4:  03 e0 18 25 move	v1,ra
  281: 
  282: 	EV_GET_SPNUM(a0, a1)		# a0 = slot number
[ 282] 0x900000001fc04fc8:  3c 04 90 00 lui	a0,0x9000
[ 282] 0x900000001fc04fcc:  00 04 24 38 dsll	a0,a0,16
[ 282] 0x900000001fc04fd0:  34 84 18 00 ori	a0,a0,0x1800
[ 282] 0x900000001fc04fd4:  00 04 24 38 dsll	a0,a0,16
[ 282] 0x900000001fc04fd8:  34 84 00 08 ori	a0,a0,0x8
[ 282] 0x900000001fc04fdc:  dc 84 00 00 ld	a0,0(a0)
[ 282] 0x900000001fc04fe0:  00 00 00 00 nop
[ 282] 0x900000001fc04fe4:  30 84 00 3f andi	a0,a0,0x3f
[ 282] 0x900000001fc04fe8:  30 85 00 03 andi	a1,a0,0x3
[ 282] 0x900000001fc04fec:  00 a0 28 21 addu	a1,a1,0
[ 282] 0x900000001fc04ff0:  00 04 20 82 srl	a0,a0,2
  283: 					# a1 = processor number
  284: 	dla	v0,aConfigTest
[ 284] 0x900000001fc04ff4:  3c 02 90 00 lui	v0,0x9000
[ 284] 0x900000001fc04ff8:  64 42 00 00 daddiu	v0,v0,0
[ 284] 0x900000001fc04ffc:  00 02 14 38 dsll	v0,v0,16
[ 284] 0x900000001fc05000:  64 42 1f c2 daddiu	v0,v0,8130
[ 284] 0x900000001fc05004:  00 02 14 38 dsll	v0,v0,16
[ 284] 0x900000001fc05008:  64 42 9b 40 daddiu	v0,v0,-25792
  285: 	dla	v1,aConfigTestEnd	
[ 285] 0x900000001fc0500c:  3c 03 90 00 lui	v1,0x9000
[ 285] 0x900000001fc05010:  64 63 00 00 daddiu	v1,v1,0
[ 285] 0x900000001fc05014:  00 03 1c 38 dsll	v1,v1,16
[ 285] 0x900000001fc05018:  64 63 1f c2 daddiu	v1,v1,8130
[ 285] 0x900000001fc0501c:  00 03 1c 38 dsll	v1,v1,16
[ 285] 0x900000001fc05020:  64 63 9b 40 daddiu	v1,v1,-25792
  286: 1:
  287: 	bgeu	v0,v1,2f
[ 287] 0x900000001fc05024:  00 43 08 2b sltu	at,v0,v1
[ 287] 0x900000001fc05028:  10 20 00 23 beq	at,zero,0x900000001fc050b8
  288:         nop
[ 288] 0x900000001fc0502c:  00 00 00 00 nop
  289: 	ld	a1,CCT_ADDRESS(v0)
[ 289] 0x900000001fc05030:  dc 45 00 00 ld	a1,0(v0)
  290: 	ld	t0,CCT_VALUE(v0)
[ 290] 0x900000001fc05034:  dc 4c 00 08 ld	t0,8(v0)
  291: 	EV_SET_CONFIG(a0, a1, t0)
[ 291] 0x900000001fc05038:  00 04 d2 c0 sll	k0,a0,11
[ 291] 0x900000001fc0503c:  3c 01 90 00 lui	at,0x9000
[ 291] 0x900000001fc05040:  00 01 0c 38 dsll	at,at,16
[ 291] 0x900000001fc05044:  34 21 18 00 ori	at,at,0x1800
[ 291] 0x900000001fc05048:  00 01 0c 38 dsll	at,at,16
[ 291] 0x900000001fc0504c:  34 21 80 00 ori	at,at,0x8000
[ 291] 0x900000001fc05050:  03 41 d0 2c dadd	k0,k0,at
[ 291] 0x900000001fc05054:  00 05 d8 2c dadd	k1,zero,a1
[ 291] 0x900000001fc05058:  00 1b d8 c0 sll	k1,k1,3
[ 291] 0x900000001fc0505c:  03 5b d0 2c dadd	k0,k0,k1
[ 291] 0x900000001fc05060:  00 0c d8 25 or	k1,zero,t0
[ 291] 0x900000001fc05064:  ff 5b 00 00 sd	k1,0(k0)
[ 291] 0x900000001fc05068:  00 00 00 00 nop
  292: 	EV_GET_CONFIG(a0, a1, t1)
[ 292] 0x900000001fc0506c:  00 04 d2 c0 sll	k0,a0,11
[ 292] 0x900000001fc05070:  3c 01 90 00 lui	at,0x9000
[ 292] 0x900000001fc05074:  00 01 0c 38 dsll	at,at,16
[ 292] 0x900000001fc05078:  34 21 18 00 ori	at,at,0x1800
[ 292] 0x900000001fc0507c:  00 01 0c 38 dsll	at,at,16
[ 292] 0x900000001fc05080:  34 21 80 00 ori	at,at,0x8000
[ 292] 0x900000001fc05084:  03 41 d0 2c dadd	k0,k0,at
[ 292] 0x900000001fc05088:  00 05 68 2c dadd	t1,zero,a1
[ 292] 0x900000001fc0508c:  00 0d 68 c0 sll	t1,t1,3
[ 292] 0x900000001fc05090:  03 4d d0 2c dadd	k0,k0,t1
[ 292] 0x900000001fc05094:  df 4d 00 00 ld	t1,0(k0)
[ 292] 0x900000001fc05098:  00 00 00 00 nop
  293: 	add	v0,CCT_SIZE
[ 293] 0x900000001fc0509c:  20 42 00 10 addi	v0,v0,16
  294: 	beq	t0,t1,1b
[ 294] 0x900000001fc050a0:  11 8d ff e0 beq	t0,t1,0x900000001fc05024
  295: 	nop
[ 295] 0x900000001fc050a4:  00 00 00 00 nop
  296: 	/* 
  297: 	 * Fall through to here if we failed.
  298: 	 */
  299: 	FLASH(FLED_ACHIP)
[ 299] 0x900000001fc050a8:  00 00 00 00 nop
[ 299] 0x900000001fc050ac:  34 04 00 34 ori	a0,zero,0x34
[ 299] 0x900000001fc050b0:  0f f0 0c 7f jal		flash_cc_leds
[ 299] 0x900000001fc050b4:  00 00 00 00 nop
  300: 2:	/* All OK */
  301: 	j	ra
[ 301] 0x900000001fc050b8:  03 e0 00 08 jr	ra
  302: 	move	v0, zero		/* DELAY: return(0) */
[ 302] 0x900000001fc050bc:  00 00 10 25 move	v0,zero
Skipping source listing to line 21 of /cores/banyan/stand/arcs/IP25prom/pod_ebus.s...
   22: 	.text
   23: 	.set	noreorder
   24: 
   25: /**************************************************************************
   26:  * pod_check_ebus1 is called by all processors.  It will run more or less
   27:  * concurrently but not in lock step so we must keep in mind that parts
   28:  * of the test may run on one CPU while another one runs different parts.
   29:  **************************************************************************/
   30: LEAF(pod_check_ebus1)
   31: 	move	v1, ra			# Save return address
pod_check_ebus1:
[  31] 0x900000001fc050c0:  03 e0 18 25 move	v1,ra
   32: 
   33: 	MFC0(a0, C0_SR)
[  33] 0x900000001fc050c4:  40 04 60 00 mfc0	a0,sr
   34: 	dli	a1, ~SR_IE
[  34] 0x900000001fc050c8:  24 05 ff fe li	a1,-2
   35: 	and	a0, a1
[  35] 0x900000001fc050cc:  00 85 20 24 and	a0,a0,a1
   36: 	MTC0(a0, C0_SR)		# Make sure the IE bit is off.
[  36] 0x900000001fc050d0:  40 84 60 00 mtc0	a0,sr
   37: 
   38: 	dli	a0, EV_CEL
[  38] 0x900000001fc050d4:  3c 04 90 00 lui	a0,0x9000
[  38] 0x900000001fc050d8:  00 04 24 38 dsll	a0,a0,16
[  38] 0x900000001fc050dc:  34 84 18 00 ori	a0,a0,0x1800
[  38] 0x900000001fc050e0:  00 04 24 38 dsll	a0,a0,16
[  38] 0x900000001fc050e4:  34 84 08 28 ori	a0,a0,0x828
   39: 	dli	a1, EV_CELMAX		# Disable interrupts on the
[  39] 0x900000001fc050e8:  24 05 00 7f li	a1,127
   40: 					# IP21 level too.
   41: 	sd	a1, 0(a0)
[  41] 0x900000001fc050ec:  fc 85 00 00 sd	a1,0(a0)
   42: 
   43: 	dli	a0, EV_ILE
[  43] 0x900000001fc050f0:  3c 04 90 00 lui	a0,0x9000
[  43] 0x900000001fc050f4:  00 04 24 38 dsll	a0,a0,16
[  43] 0x900000001fc050f8:  34 84 18 00 ori	a0,a0,0x1800
[  43] 0x900000001fc050fc:  00 04 24 38 dsll	a0,a0,16
[  43] 0x900000001fc05100:  34 84 08 40 ori	a0,a0,0x840
   44: 	dli	a1, 1
[  44] 0x900000001fc05104:  24 05 00 01 li	a1,1
   45: 	sd	a1, 0(a0)		# Enable level 0 Everest interrupts
[  45] 0x900000001fc05108:  fc 85 00 00 sd	a1,0(a0)
   46: 
   47: 	dli	a3, EV_HPIL
[  47] 0x900000001fc0510c:  3c 07 90 00 lui	a3,0x9000
[  47] 0x900000001fc05110:  00 07 3c 38 dsll	a3,a3,16
[  47] 0x900000001fc05114:  34 e7 18 00 ori	a3,a3,0x1800
[  47] 0x900000001fc05118:  00 07 3c 38 dsll	a3,a3,16
[  47] 0x900000001fc0511c:  34 e7 08 20 ori	a3,a3,0x820
   48: 	ld	a1, 0(a3)
[  48] 0x900000001fc05120:  dc e5 00 00 ld	a1,0(a3)
   49: #ifndef SABLE
   50: 	bne	a1, zero, stuck_hipl
[  50] 0x900000001fc05124:  14 a0 00 82 bne	a1,zero,0x900000001fc05330
   51: 	nop
[  51] 0x900000001fc05128:  00 00 00 00 nop
   52: #endif
   53: 
   54: 	jal	pod_clear_ints
[  54] 0x900000001fc0512c:  0f f0 14 d8 jal		pod_clear_ints
   55: 	sd	zero, (a0)		# Remove us from all groups
[  55] 0x900000001fc05130:  fc 80 00 00 sd	zero,0(a0)
   56: 
   57: 	# At this point, all interrupts are clear.
   58: 
   59: 	dli	a0, EV_SPNUM
[  59] 0x900000001fc05134:  3c 04 90 00 lui	a0,0x9000
[  59] 0x900000001fc05138:  00 04 24 38 dsll	a0,a0,16
[  59] 0x900000001fc0513c:  34 84 18 00 ori	a0,a0,0x1800
[  59] 0x900000001fc05140:  00 04 24 38 dsll	a0,a0,16
[  59] 0x900000001fc05144:  34 84 00 08 ori	a0,a0,0x8
   60: 	ld	t0, 0(a0)		# t0 = SPNUM
[  60] 0x900000001fc05148:  dc 8c 00 00 ld	t0,0(a0)
   61: 	li	a0, EV_CELMAX		# (LD)
[  61] 0x900000001fc0514c:  24 04 00 7f li	a0,127
   62: 	andi	t0, EV_SPNUM_MASK	# Mask off appropriate bits
[  62] 0x900000001fc05150:  31 8c 00 3f andi	t0,t0,0x3f
   63: 
   64: 	li	a1, 0
[  64] 0x900000001fc05154:  24 05 00 00 li	a1,0
   65: 	dli	a2, EV_SENDINT
[  65] 0x900000001fc05158:  3c 06 90 00 lui	a2,0x9000
[  65] 0x900000001fc0515c:  00 06 34 38 dsll	a2,a2,16
[  65] 0x900000001fc05160:  34 c6 18 00 ori	a2,a2,0x1800
[  65] 0x900000001fc05164:  00 06 34 38 dsll	a2,a2,16
[  65] 0x900000001fc05168:  34 c6 01 00 ori	a2,a2,0x100
   66: 	# a3 still contains EV_HPIL
   67: check_levels:
   68: 	sll	t1, a1, 8	# Put interrupt level in bits 14..8
[  68] 0x900000001fc0516c:  00 05 6a 00 sll	t1,a1,8
   69: 	or	t1, t0		# Put SPNUM in bits 5..0
[  69] 0x900000001fc05170:  01 ac 68 25 or	t1,t1,t0
   70: 	sd	t1, 0(a2)	# Send ourselves an interrupt
[  70] 0x900000001fc05174:  fc cd 00 00 sd	t1,0(a2)
   71: 	nop
[  71] 0x900000001fc05178:  00 00 00 00 nop
   72: 
   73: 	srl	t1, t0, 2	# Get our slot number
[  73] 0x900000001fc0517c:  00 0c 68 82 srl	t1,t0,2
   74: 	EV_GET_CONFIG(t1, EV_A_LEVEL, t1)	# Get a config reg to stall
[  74] 0x900000001fc05180:  00 0d d2 c0 sll	k0,t1,11
[  74] 0x900000001fc05184:  3c 01 90 00 lui	at,0x9000
[  74] 0x900000001fc05188:  00 01 0c 38 dsll	at,at,16
[  74] 0x900000001fc0518c:  34 21 18 00 ori	at,at,0x1800
[  74] 0x900000001fc05190:  00 01 0c 38 dsll	at,at,16
[  74] 0x900000001fc05194:  34 21 80 00 ori	at,at,0x8000
[  74] 0x900000001fc05198:  03 41 d0 2c dadd	k0,k0,at
[  74] 0x900000001fc0519c:  60 0d 00 02 daddi	t1,zero,2
[  74] 0x900000001fc051a0:  00 0d 68 c0 sll	t1,t1,3
[  74] 0x900000001fc051a4:  03 4d d0 2c dadd	k0,k0,t1
[  74] 0x900000001fc051a8:  df 4d 00 00 ld	t1,0(k0)
[  74] 0x900000001fc051ac:  00 00 00 00 nop
   75: 
   76: 	ld	t2, 0(a3)	# Get HPIL and compare.
[  76] 0x900000001fc051b0:  dc ee 00 00 ld	t2,0(a3)
   77: 	nop
[  77] 0x900000001fc051b4:  00 00 00 00 nop
   78: #ifndef SABLE
   79: 	bne	a1, t2, lost_int
[  79] 0x900000001fc051b8:  14 ae 00 5f bne	a1,t2,0x900000001fc05338
   80: 	nop
[  80] 0x900000001fc051bc:  00 00 00 00 nop
   81: 	addi	a1, 1
[  81] 0x900000001fc051c0:  20 a5 00 01 addi	a1,a1,1
   82: 	ble	a1, a0, check_levels
[  82] 0x900000001fc051c4:  00 85 08 2a slt	at,a0,a1
[  82] 0x900000001fc051c8:  10 20 ff e8 beq	at,zero,0x900000001fc0516c
   83: 	nop
[  83] 0x900000001fc051cc:  00 00 00 00 nop
   84: #endif
   85: 
   86: 	jal	pod_clear_ints	# Clear all the interrupts again.
[  86] 0x900000001fc051d0:  0f f0 14 d8 jal		pod_clear_ints
   87: 	nop
[  87] 0x900000001fc051d4:  00 00 00 00 nop
   88: 
   89: 	dli	a0, EV_IGRMASK
[  89] 0x900000001fc051d8:  3c 04 90 00 lui	a0,0x9000
[  89] 0x900000001fc051dc:  00 04 24 38 dsll	a0,a0,16
[  89] 0x900000001fc051e0:  34 84 18 00 ori	a0,a0,0x1800
[  89] 0x900000001fc051e4:  00 04 24 38 dsll	a0,a0,16
[  89] 0x900000001fc051e8:  34 84 08 38 ori	a0,a0,0x838
   90: 	li	a1, 1 << 15
[  90] 0x900000001fc051ec:  34 05 80 00 ori	a1,zero,0x8000
   91: 	sd	a1, 0(a0)	# Add us to group 15.
[  91] 0x900000001fc051f0:  fc 85 00 00 sd	a1,0(a0)
   92: 	li	t2, 15 | 64	# Group 15 (+ 64 = group interrupt)
[  92] 0x900000001fc051f4:  24 0e 00 4f li	t2,79
   93: 
   94: 	dli	a2, EV_SENDINT
[  94] 0x900000001fc051f8:  3c 06 90 00 lui	a2,0x9000
[  94] 0x900000001fc051fc:  00 06 34 38 dsll	a2,a2,16
[  94] 0x900000001fc05200:  34 c6 18 00 ori	a2,a2,0x1800
[  94] 0x900000001fc05204:  00 06 34 38 dsll	a2,a2,16
[  94] 0x900000001fc05208:  34 c6 01 00 ori	a2,a2,0x100
   95: 	li	t1, EV_CELMAX << 8	# Level 127 interrupt
[  95] 0x900000001fc0520c:  24 0d 7f 00 li	t1,32512
   96: 	or	t2, t1			# Sent to interrupt group 15
[  96] 0x900000001fc05210:  01 cd 70 25 or	t2,t2,t1
   97: 	sd	t2, 0(a2)
[  97] 0x900000001fc05214:  fc ce 00 00 sd	t2,0(a2)
   98: 	nop
[  98] 0x900000001fc05218:  00 00 00 00 nop
   99: 
  100: 	srl	t1, t0, 2
[ 100] 0x900000001fc0521c:  00 0c 68 82 srl	t1,t0,2
  101: 	EV_GET_CONFIG(t1, EV_A_LEVEL, t1)	# Get a config reg to stall
[ 101] 0x900000001fc05220:  00 0d d2 c0 sll	k0,t1,11
[ 101] 0x900000001fc05224:  3c 01 90 00 lui	at,0x9000
[ 101] 0x900000001fc05228:  00 01 0c 38 dsll	at,at,16
[ 101] 0x900000001fc0522c:  34 21 18 00 ori	at,at,0x1800
[ 101] 0x900000001fc05230:  00 01 0c 38 dsll	at,at,16
[ 101] 0x900000001fc05234:  34 21 80 00 ori	at,at,0x8000
[ 101] 0x900000001fc05238:  03 41 d0 2c dadd	k0,k0,at
[ 101] 0x900000001fc0523c:  60 0d 00 02 daddi	t1,zero,2
[ 101] 0x900000001fc05240:  00 0d 68 c0 sll	t1,t1,3
[ 101] 0x900000001fc05244:  03 4d d0 2c dadd	k0,k0,t1
[ 101] 0x900000001fc05248:  df 4d 00 00 ld	t1,0(k0)
[ 101] 0x900000001fc0524c:  00 00 00 00 nop
  102: 
  103: 	ld	t1, 0(a3)		# Get HPIL
[ 103] 0x900000001fc05250:  dc ed 00 00 ld	t1,0(a3)
  104: 	li	t2, EV_CELMAX		# t2 = 127
[ 104] 0x900000001fc05254:  24 0e 00 7f li	t2,127
  105: 
  106: #ifndef SABLE
  107: 	bne	t1, t2, group_fail	# if HPIL isn't 127, fail.
[ 107] 0x900000001fc05258:  15 ae 00 39 bne	t1,t2,0x900000001fc05340
  108: 	nop
[ 108] 0x900000001fc0525c:  00 00 00 00 nop
  109: #endif
  110: 
  111: 	jal	pod_clear_ints		# Clear 'em all out again.
[ 111] 0x900000001fc05260:  0f f0 14 d8 jal		pod_clear_ints
  112: 	sd	zero, 0(a0)		# Remove us from group 15
[ 112] 0x900000001fc05264:  fc 80 00 00 sd	zero,0(a0)
  113: 					# (It's important to do this now
  114: 					#  as some processors may lag behind
  115: 					#  us and try to send the group
  116: 					#  interrupt later.
  117: 	
  118: 	# Enable Everest interrupt level 0
  119: 	dli	t1, EV_CEL
[ 119] 0x900000001fc05268:  3c 0d 90 00 lui	t1,0x9000
[ 119] 0x900000001fc0526c:  00 0d 6c 38 dsll	t1,t1,16
[ 119] 0x900000001fc05270:  35 ad 18 00 ori	t1,t1,0x1800
[ 119] 0x900000001fc05274:  00 0d 6c 38 dsll	t1,t1,16
[ 119] 0x900000001fc05278:  35 ad 08 28 ori	t1,t1,0x828
  120: 	sd	zero, 0(t1)
[ 120] 0x900000001fc0527c:  fd a0 00 00 sd	zero,0(t1)
  121: 
  122: 	li	t0, 1
[ 122] 0x900000001fc05280:  24 0c 00 01 li	t0,1
  123: 	dli	t1, EV_ILE
[ 123] 0x900000001fc05284:  3c 0d 90 00 lui	t1,0x9000
[ 123] 0x900000001fc05288:  00 0d 6c 38 dsll	t1,t1,16
[ 123] 0x900000001fc0528c:  35 ad 18 00 ori	t1,t1,0x1800
[ 123] 0x900000001fc05290:  00 0d 6c 38 dsll	t1,t1,16
[ 123] 0x900000001fc05294:  35 ad 08 40 ori	t1,t1,0x840
  124: 	sd	t0, 0(t1)
[ 124] 0x900000001fc05298:  fd ac 00 00 sd	t0,0(t1)
  125: 
  126: 	sd	zero, 0(a2)		# Send ourselves a lvl 0, #0 interrupt
[ 126] 0x900000001fc0529c:  fc c0 00 00 sd	zero,0(a2)
  127: 
  128: 	dli	t2, EV_SPNUM
[ 128] 0x900000001fc052a0:  3c 0e 90 00 lui	t2,0x9000
[ 128] 0x900000001fc052a4:  00 0e 74 38 dsll	t2,t2,16
[ 128] 0x900000001fc052a8:  35 ce 18 00 ori	t2,t2,0x1800
[ 128] 0x900000001fc052ac:  00 0e 74 38 dsll	t2,t2,16
[ 128] 0x900000001fc052b0:  35 ce 00 08 ori	t2,t2,0x8
  129: 	ld	t0, 0(t2)		# t2 = SPNUM
[ 129] 0x900000001fc052b4:  dd cc 00 00 ld	t0,0(t2)
  130: 	nop
[ 130] 0x900000001fc052b8:  00 00 00 00 nop
  131: 	andi	t2, t0, EV_SPNUM_MASK	# Mask off bottom 6 bits
[ 131] 0x900000001fc052bc:  31 8e 00 3f andi	t2,t0,0x3f
  132: 	ori	t2, 1 << 8		# Interrupt #1
[ 132] 0x900000001fc052c0:  35 ce 01 00 ori	t2,t2,0x100
  133: 
  134: 	dli	t1, EV_SENDINT
[ 134] 0x900000001fc052c4:  3c 0d 90 00 lui	t1,0x9000
[ 134] 0x900000001fc052c8:  00 0d 6c 38 dsll	t1,t1,16
[ 134] 0x900000001fc052cc:  35 ad 18 00 ori	t1,t1,0x1800
[ 134] 0x900000001fc052d0:  00 0d 6c 38 dsll	t1,t1,16
[ 134] 0x900000001fc052d4:  35 ad 01 00 ori	t1,t1,0x100
  135: 	sd	t2, 0(t1)		# Send the interrupt
[ 135] 0x900000001fc052d8:  fd ae 00 00 sd	t2,0(t1)
  136: 
  137: 	dli	t1, EV_IP0
[ 137] 0x900000001fc052dc:  3c 0d 90 00 lui	t1,0x9000
[ 137] 0x900000001fc052e0:  00 0d 6c 38 dsll	t1,t1,16
[ 137] 0x900000001fc052e4:  35 ad 18 00 ori	t1,t1,0x1800
[ 137] 0x900000001fc052e8:  00 0d 6c 38 dsll	t1,t1,16
[ 137] 0x900000001fc052ec:  35 ad 08 00 ori	t1,t1,0x800
  138: 	ld	t1, 0(t1)		# Read reg to force completion of intr
[ 138] 0x900000001fc052f0:  dd ad 00 00 ld	t1,0(t1)
  139: 	nop
[ 139] 0x900000001fc052f4:  00 00 00 00 nop
  140: 
  141: 	MFC0(t0, C0_CAUSE)
[ 141] 0x900000001fc052f8:  40 0c 68 00 mfc0	t0,cause
  142: 
  143: 	andi	t0, CAUSE_IP3		# Check for pending interrupts.
[ 143] 0x900000001fc052fc:  31 8c 04 00 andi	t0,t0,0x400
  144: 
  145: #ifndef SABLE
  146: 	beq	t0, zero, proc_int_fail
[ 146] 0x900000001fc05300:  11 80 00 15 beq	t0,zero,0x900000001fc05358
  147: 	nop
[ 147] 0x900000001fc05304:  00 00 00 00 nop
  148: #endif
  149: 
  150: 	jal	pod_clear_ints	# Clear all the interrupts one last time.
[ 150] 0x900000001fc05308:  0f f0 14 d8 jal		pod_clear_ints
  151: 	nop
[ 151] 0x900000001fc0530c:  00 00 00 00 nop
  152: 	dli	t1, EV_ILE
[ 152] 0x900000001fc05310:  3c 0d 90 00 lui	t1,0x9000
[ 152] 0x900000001fc05314:  00 0d 6c 38 dsll	t1,t1,16
[ 152] 0x900000001fc05318:  35 ad 18 00 ori	t1,t1,0x1800
[ 152] 0x900000001fc0531c:  00 0d 6c 38 dsll	t1,t1,16
[ 152] 0x900000001fc05320:  35 ad 08 40 ori	t1,t1,0x840
  153: 	sd	zero, 0(t1)		# Turn level zero interrupts back off
[ 153] 0x900000001fc05324:  fd a0 00 00 sd	zero,0(t1)
  154: 	
  155: 	# Darn!  Can't test "all CPUs" interrupt here because someone may
  156: 	# 	still be doing the clear interrupts or each-level tests.
  157: 	# Guess this is it for ebus1.
  158: 
  159: 	j	v1	
[ 159] 0x900000001fc05328:  00 60 00 08 jr	v1
  160: 	li	v0, 0		# Return 0 == happy CPU
[ 160] 0x900000001fc0532c:  24 02 00 00 li	v0,0
  161: END(pod_check_ebus1)
  162: 
  163: 
  164: LEAF(stuck_hipl)	
  165: 	j	v1
stuck_hipl:
[ 165] 0x900000001fc05330:  00 60 00 08 jr	v1
  166: 	li	v0, EVDIAG_STUCK_HPIL		# (BD)
[ 166] 0x900000001fc05334:  24 02 00 3f li	v0,63
  167: 
  168: 	END(stuck_hipl)
  169: 
  170: LEAF(lost_int)
  171: 	j	v1
lost_int:
[ 171] 0x900000001fc05338:  00 60 00 08 jr	v1
  172: 	ori	v0, zero, EVDIAG_LOST_INT		# (BD)
[ 172] 0x900000001fc0533c:  34 02 00 3e ori	v0,zero,0x3e
  173: 
  174: 	END(lost_int)
  175: 
  176: LEAF(group_fail)
  177: 	j	ra
group_fail:
[ 177] 0x900000001fc05340:  03 e0 00 08 jr	ra
  178: 	li	v0, 3
[ 178] 0x900000001fc05344:  24 02 00 03 li	v0,3
  179: 
  180: 	jal	clear_ints
[ 180] 0x900000001fc05348:  0f f0 14 de jal		(pod_clear_ints+24)
  181: 	nop
[ 181] 0x900000001fc0534c:  00 00 00 00 nop
  182: 	j	v1
[ 182] 0x900000001fc05350:  00 60 00 08 jr	v1
  183: 	ori	v0, zero, EVDIAG_GROUP_FAIL	# (BD)
[ 183] 0x900000001fc05354:  34 02 00 3d ori	v0,zero,0x3d
  184: 	END(group_fail)
  185: 
  186: LEAF(proc_int_fail)
  187: 	j	v1
proc_int_fail:
[ 187] 0x900000001fc05358:  00 60 00 08 jr	v1
  188: 	ori	v0, zero, EVDIAG_R4K_INTS		# (BD)
[ 188] 0x900000001fc0535c:  34 02 00 3c ori	v0,zero,0x3c
  189: 	END(proc_int_fail)
  190: 
  191: LEAF(pod_clear_ints)
  192: 	dli	a0, EV_CIPL0
pod_clear_ints:
[ 192] 0x900000001fc05360:  3c 04 90 00 lui	a0,0x9000
[ 192] 0x900000001fc05364:  00 04 24 38 dsll	a0,a0,16
[ 192] 0x900000001fc05368:  34 84 18 00 ori	a0,a0,0x1800
[ 192] 0x900000001fc0536c:  00 04 24 38 dsll	a0,a0,16
[ 192] 0x900000001fc05370:  34 84 08 30 ori	a0,a0,0x830
  193: 	li	a1, EV_CELMAX		# Highest interrupt number
[ 193] 0x900000001fc05374:  24 05 00 7f li	a1,127
  194: clear_ints:
  195: 	sd	a1, 0(a0)		# Clear interrupt (BD)
[ 195] 0x900000001fc05378:  fc 85 00 00 sd	a1,0(a0)
  196: 	bne	a1, zero, clear_ints
[ 196] 0x900000001fc0537c:  14 a0 ff fe bne	a1,zero,0x900000001fc05378
  197: 	addi	a1, -1			# Decrement counter (BD)
[ 197] 0x900000001fc05380:  20 a5 ff ff addi	a1,a1,-1
  198: 
  199: 	j	ra
[ 199] 0x900000001fc05384:  03 e0 00 08 jr	ra
  200: 	nop
[ 200] 0x900000001fc05388:  00 00 00 00 nop
       0x900000001fc0538c:  00 00 00 00 nop
Skipping source listing to line 19 of /cores/banyan/stand/arcs/IP25prom/pod_ioasm.s...
   20: 
   21: #include "ip25prom.h"
   22: #include "prom_intr.h"
   23: #include "pod_failure.h"
   24: 
   25: 	.text
   26: 	.set 	noreorder
   27: 
   28: LEAF(pod_puthex)
   29: 	DMFBR(a1, BR_BSR)			# Read the BSR
pod_puthex:
[  29] 0x900000001fc05390:  44 25 00 00 dmfc1	a1,$f0
   30: 	andi	a1, BSR_EPCUART			# Check to for EPC UART
[  30] 0x900000001fc05394:  30 a5 01 00 andi	a1,a1,0x100
   31: 	bnez	a1, 1f
[  31] 0x900000001fc05398:  14 a0 00 03 bne	a1,zero,0x900000001fc053a8
   32: 	nop
[  32] 0x900000001fc0539c:  00 00 00 00 nop
   33: 	j	ccuart_puthex			# Call SysCtlr UART code
[  33] 0x900000001fc053a0:  0b f0 0c f7 j		ccuart_puthex
   34: 	nop
[  34] 0x900000001fc053a4:  00 00 00 00 nop
   35: 1:	
   36: 	ori	a1, zero, CHN_A			# (BD) Write to channel A
[  36] 0x900000001fc053a8:  34 05 60 08 ori	a1,zero,0x6008
   37: 	j	epcuart_puthex			# Call EPC UART code
[  37] 0x900000001fc053ac:  0b f0 15 5c j		epcuart_puthex
   38: 	nop
[  38] 0x900000001fc053b0:  00 00 00 00 nop
   39: 	END(pod_puthex)
   40: 
   41: LEAF(pod_puthex32)
   42: 	move	a3,ra				/* save way home */
pod_puthex32:
[  42] 0x900000001fc053b4:  03 e0 38 25 move	a3,ra
   43: 	move	ta3,a0				/* Save Value */
[  43] 0x900000001fc053b8:  00 80 58 25 move	a7,a0
   44: 	li	ta2,32				/* Shift amount */
[  44] 0x900000001fc053bc:  24 0a 00 20 li	a6,32
   45: 1:
   46: 	sub	ta2,4
[  46] 0x900000001fc053c0:  21 4a ff fc addi	a6,a6,-4
   47: 	jal	getHexChar
[  47] 0x900000001fc053c4:  0f f0 0d 46 jal		getHexChar
   48: 	srl	a0,ta3,ta2
[  48] 0x900000001fc053c8:  01 4b 20 06 srlv	a0,a7,a6
   49: 	jal	pod_putc
[  49] 0x900000001fc053cc:  0f f0 15 13 jal		pod_putc
   50: 	move	a0,v0
[  50] 0x900000001fc053d0:  00 40 20 25 move	a0,v0
   51: 	bnez	ta2,1b
[  51] 0x900000001fc053d4:  15 40 ff fa bne	a6,zero,0x900000001fc053c0
   52: 	nop
[  52] 0x900000001fc053d8:  00 00 00 00 nop
   53: 	j	a3
[  53] 0x900000001fc053dc:  00 e0 00 08 jr	a3
   54: 	END(pod_puthex32)
   55: 
   56: LEAF(pod_puthex64)
   57: 	move	a3,ra				/* save way home */
pod_puthex64:
[  57] 0x900000001fc053e0:  03 e0 38 25 move	a3,ra
   58: 	move	ta3,a0				/* Save Value */
[  58] 0x900000001fc053e4:  00 80 58 25 move	a7,a0
   59: 	li	ta2,64				/* Shift amount */
[  59] 0x900000001fc053e8:  24 0a 00 40 li	a6,64
   60: 1:
   61: 	sub	ta2,4
[  61] 0x900000001fc053ec:  21 4a ff fc addi	a6,a6,-4
   62: 	jal	getHexChar
[  62] 0x900000001fc053f0:  0f f0 0d 46 jal		getHexChar
   63: 	dsrl	a0,ta3,ta2
[  63] 0x900000001fc053f4:  01 4b 20 16 dsrlv	a0,a7,a6
   64: 	jal	pod_putc
[  64] 0x900000001fc053f8:  0f f0 15 13 jal		pod_putc
   65: 	move	a0,v0
[  65] 0x900000001fc053fc:  00 40 20 25 move	a0,v0
   66: 	bnez	ta2,1b
[  66] 0x900000001fc05400:  15 40 ff fa bne	a6,zero,0x900000001fc053ec
   67: 	nop
[  67] 0x900000001fc05404:  00 00 00 00 nop
   68: 	j	a3
[  68] 0x900000001fc05408:  00 e0 00 08 jr	a3
   69: 	END(pod_puthex64)
   70: 
   71: LEAF(pod_puts)
   72: 	DMFBR(a1, BR_BSR)			# Read the BSR
pod_puts:
[  72] 0x900000001fc0540c:  44 25 00 00 dmfc1	a1,$f0
   73: 	and	a1, BSR_EPCUART			# Check for EPC UART use
[  73] 0x900000001fc05410:  30 a5 01 00 andi	a1,a1,0x100
   74: 	bnez	a1, 1f
[  74] 0x900000001fc05414:  14 a0 00 03 bne	a1,zero,0x900000001fc05424
   75: 	nop					# (BD)
[  75] 0x900000001fc05418:  00 00 00 00 nop
   76: 	j	ccuart_puts
[  76] 0x900000001fc0541c:  0b f0 0d 14 j		ccuart_puts
   77: 	nop
[  77] 0x900000001fc05420:  00 00 00 00 nop
   78: 1:	j	epcuart_puts
[  78] 0x900000001fc05424:  0b f0 15 7b j		epcuart_puts
   79: 	ori	a1, zero, CHN_A			# (BD) Write to channel A	
[  79] 0x900000001fc05428:  34 05 60 08 ori	a1,zero,0x6008
   80: 	END(pod_puts)
   81: 
   82: LEAF(pod_getc)
   83: 	DMFBR(a1, BR_BSR)			# Read the BSR
pod_getc:
[  83] 0x900000001fc0542c:  44 25 00 00 dmfc1	a1,$f0
   84: 	andi	a1, BSR_EPCUART
[  84] 0x900000001fc05430:  30 a5 01 00 andi	a1,a1,0x100
   85: 	bnez	a1, 1f
[  85] 0x900000001fc05434:  14 a0 00 03 bne	a1,zero,0x900000001fc05444
   86: 	nop					# (BD)
[  86] 0x900000001fc05438:  00 00 00 00 nop
   87: 	j	ccuart_getc
[  87] 0x900000001fc0543c:  0b f0 0c bf j		ccuart_getc
   88: 	nop
[  88] 0x900000001fc05440:  00 00 00 00 nop
   89: 1:	j	epcuart_getc
[  89] 0x900000001fc05444:  0b f0 15 2c j		epcuart_getc
   90: 	ori 	a0, zero, CHN_A			# (BD) Read from channel A	
[  90] 0x900000001fc05448:  34 04 60 08 ori	a0,zero,0x6008
   91: 	END(pod_getc)
   92: 
   93: LEAF(pod_putc)
   94: 	DMFBR(a1, BR_BSR)			# Read the BSR
pod_putc:
[  94] 0x900000001fc0544c:  44 25 00 00 dmfc1	a1,$f0
   95: 	andi	a1, BSR_EPCUART			# Check for which UART to use
[  95] 0x900000001fc05450:  30 a5 01 00 andi	a1,a1,0x100
   96: 	bnez	a1, 1f
[  96] 0x900000001fc05454:  14 a0 00 03 bne	a1,zero,0x900000001fc05464
   97: 	nop					# (BD)
[  97] 0x900000001fc05458:  00 00 00 00 nop
   98: 	j	ccuart_putc
[  98] 0x900000001fc0545c:  0b f0 0c d6 j		ccuart_putc
   99: 	nop
[  99] 0x900000001fc05460:  00 00 00 00 nop
  100: 1:	j	epcuart_putc
[ 100] 0x900000001fc05464:  0b f0 15 47 j		epcuart_putc
  101: 	ori	a1, zero, CHN_A			# (BD) Write to channel A	
[ 101] 0x900000001fc05468:  34 05 60 08 ori	a1,zero,0x6008
  102: 	END(pod_putc)
  103: 
  104: LEAF(pod_flush)
  105: 	DMFBR(a0, BR_BSR)			# Read the BSR
pod_flush:
[ 105] 0x900000001fc0546c:  44 24 00 00 dmfc1	a0,$f0
  106: 	andi	a0, BSR_EPCUART			# Check for which UART to use
[ 106] 0x900000001fc05470:  30 84 01 00 andi	a0,a0,0x100
  107: 	bnez	a0, 1f				# Jump if not CCUART
[ 107] 0x900000001fc05474:  14 80 00 03 bne	a0,zero,0x900000001fc05484
  108: 	nop					# (BD)
[ 108] 0x900000001fc05478:  00 00 00 00 nop
  109: 	j	ccuart_flush
[ 109] 0x900000001fc0547c:  0b f0 0c ea j		ccuart_flush
  110: 	nop
[ 110] 0x900000001fc05480:  00 00 00 00 nop
  111: 1:	j	epcuart_flush
[ 111] 0x900000001fc05484:  0b f0 15 3e j		epcuart_flush
  112: 	ori	a0, zero, CHN_A			# (BD) Flush channel A	
[ 112] 0x900000001fc05488:  34 04 60 08 ori	a0,zero,0x6008
  113: 	END(pod_flush)
  114: 
  115: LEAF(pod_poll)
  116: 	DMFBR(a1, BR_BSR)			# Read the BSR
pod_poll:
[ 116] 0x900000001fc0548c:  44 25 00 00 dmfc1	a1,$f0
  117: 	andi	a1, BSR_EPCUART
[ 117] 0x900000001fc05490:  30 a5 01 00 andi	a1,a1,0x100
  118: 	bnez	a1, 1f
[ 118] 0x900000001fc05494:  14 a0 00 03 bne	a1,zero,0x900000001fc054a4
  119: 	nop					# (BD)
[ 119] 0x900000001fc05498:  00 00 00 00 nop
  120: 	j	ccuart_poll	
[ 120] 0x900000001fc0549c:  0b f0 0c b6 j		ccuart_poll
  121: 	nop
[ 121] 0x900000001fc054a0:  00 00 00 00 nop
  122: 1:	j	epcuart_poll
[ 122] 0x900000001fc054a4:  0b f0 15 56 j		epcuart_poll
  123: 	ori	a0, zero, CHN_A			# (BD) Poll channel A	
[ 123] 0x900000001fc054a8:  34 04 60 08 ori	a0,zero,0x6008
       0x900000001fc054ac:  00 00 00 00 nop
Skipping source listing to line 35 of /cores/banyan/stand/arcs/IP25prom/epcuart.s...
   36:  *	a0 -- Selected channel 
   37:  * Returns:
   38:  *	v0 -- the character read.
   39:  * Uses registers:
   40:  *	a0, a1, v0, v1.
   41:  */
   42:  
   43: LEAF(epcuart_getc)
   44: 	.set	noreorder
   45: 	DMFBR(a1, BR_DUARTBASE)
epcuart_getc:
[  45] 0x900000001fc054b0:  44 25 18 00 dmfc1	a1,$f3
   46: 	dadd	a0, a1			# Add 
[  46] 0x900000001fc054b4:  00 85 20 2c dadd	a0,a0,a1
   47: 2:
   48: 	lb	a1, CNTRL(a0) 		# Read the EPC UART control reg
[  48] 0x900000001fc054b8:  80 85 00 00 lb	a1,0(a0)
   49: 
   50: 	andi	v0, a1, RR0_RX_CHR	# Check to see if chr was recvd.
[  50] 0x900000001fc054bc:  30 a2 00 01 andi	v0,a1,0x1
   51: 	beqz	v0, 2b			# If not received, jump back to top 
[  51] 0x900000001fc054c0:  10 40 ff fd beq	v0,zero,0x900000001fc054b8
   52: 	nop				# (BD)
[  52] 0x900000001fc054c4:  00 00 00 00 nop
   53: 3:
   54: 	li	a1, RR1
[  54] 0x900000001fc054c8:  24 05 00 01 li	a1,1
   55: 	sb	a1, CNTRL(a0) 		# Tell uart we want the RR1 register
[  55] 0x900000001fc054cc:  a0 85 00 00 sb	a1,0(a0)
   56: 	nop
[  56] 0x900000001fc054d0:  00 00 00 00 nop
   57: 	lb	a1, CNTRL(a0) 		# Actually perform the read
[  57] 0x900000001fc054d4:  80 85 00 00 lb	a1,0(a0)
   58: 	nop
[  58] 0x900000001fc054d8:  00 00 00 00 nop
   59: 	
   60: 	lb	v0, DATA(a0)		# Read the data register.
[  60] 0x900000001fc054dc:  80 82 00 10 lb	v0,16(a0)
   61: 
   62: 	andi	a1, (RR1_RX_ORUN_ERR | RR1_FRAMING_ERR | RR1_PARITY_ERR)
[  62] 0x900000001fc054e0:  30 a5 00 70 andi	a1,a1,0x70
   63: 	beq	a1, zero, 9f		# If an ERROR occurred THEN
[  63] 0x900000001fc054e4:  10 a0 00 02 beq	a1,zero,0x900000001fc054f0
   64: 	nop				# (BD)
[  64] 0x900000001fc054e8:  00 00 00 00 nop
   65: 	move	v0, zero		# Put a zero into the return value
[  65] 0x900000001fc054ec:  00 00 10 25 move	v0,zero
   66: 9:
   67: 	j	ra			# Return
[  67] 0x900000001fc054f0:  03 e0 00 08 jr	ra
   68: 	nop				# (BD)
[  68] 0x900000001fc054f4:  00 00 00 00 nop
   69: 	END(epcuart_getc)
   70: 
   71: /*
   72:  * epcuart_flush
   73:  *	Flushes the input buffer of the UART.
   74:  * Arguments:
   75:  *	a0 -- Selected channel number. 
   76:  * Uses:
   77:  *	a0, v0 
   78:  */
   79: 
   80: LEAF(epcuart_flush)
   81: 	.set	noreorder
   82: 	DMFBR(v0, BR_DUARTBASE)
epcuart_flush:
[  82] 0x900000001fc054f8:  44 22 18 00 dmfc1	v0,$f3
   83: 	dadd	a0, v0			# Add in the channel selector
[  83] 0x900000001fc054fc:  00 82 20 2c dadd	a0,a0,v0
   84: 
   85: 	lb	v0, CNTRL(a0)		# Read the control reg.
[  85] 0x900000001fc05500:  80 82 00 00 lb	v0,0(a0)
   86: 	andi	v0, RR0_RX_CHR		# Check to see if char was recvd.
[  86] 0x900000001fc05504:  30 42 00 01 andi	v0,v0,0x1
   87: 	beqz	v0, 3f			# Goto end if no character.
[  87] 0x900000001fc05508:  10 40 00 02 beq	v0,zero,0x900000001fc05514
   88: 	nop				# 
[  88] 0x900000001fc0550c:  00 00 00 00 nop
   89: 
   90: 	lb	v0, DATA(a0)		# Read the character
[  90] 0x900000001fc05510:  80 82 00 10 lb	v0,16(a0)
   91: 3:
   92: 	j	ra			# Return 
[  92] 0x900000001fc05514:  03 e0 00 08 jr	ra
   93: 	nop				# 
[  93] 0x900000001fc05518:  00 00 00 00 nop
   94: 	END(epcuart_flush)
   95: 		
   96: /*
   97:  * Routine epcuart_putc
   98:  *	Writes a single character to the EPC UART.
   99:  *
  100:  * Arguments:
  101:  *	a0 -- the byte to write. 
  102:  *	a1 -- the channel to write to.
  103:  * Returns:
  104:  *	nothing.
  105:  * Uses registers:
  106:  *	a0, a1, v0, v1.	
  107:  */
  108: 
  109: LEAF(epcuart_putc)
  110: 	.set	noreorder
  111: 	DMFBR(v0, BR_DUARTBASE)
epcuart_putc:
[ 111] 0x900000001fc0551c:  44 22 18 00 dmfc1	v0,$f3
  112: 	dadd	a1, v0			# Add in the channel selector
[ 112] 0x900000001fc05520:  00 a2 28 2c dadd	a1,a1,v0
  113: 
  114: 	li	v0, 10000		# Number of retry attempts
[ 114] 0x900000001fc05524:  24 02 27 10 li	v0,10000
  115: 1: 	
  116: 	lb	v1, CNTRL(a1)		#   Read the control register
[ 116] 0x900000001fc05528:  80 a3 00 00 lb	v1,0(a1)
  117: 	nop
[ 117] 0x900000001fc0552c:  00 00 00 00 nop
  118: 	andi	v1, RR0_TX_EMPTY	# UNTIL ready to transmit
[ 118] 0x900000001fc05530:  30 63 00 04 andi	v1,v1,0x4
  119: 	subu	v0, 1			# (BD) (--cnt == 0)
[ 119] 0x900000001fc05534:  24 42 ff ff addiu	v0,v0,-1
  120: 	bnez	v1, 2f			# OR
[ 120] 0x900000001fc05538:  14 60 00 05 bne	v1,zero,0x900000001fc05550
  121: 	nop
[ 121] 0x900000001fc0553c:  00 00 00 00 nop
  122: 	bnez	v0, 1b			#  
[ 122] 0x900000001fc05540:  14 40 ff f9 bne	v0,zero,0x900000001fc05528
  123: 	nop				# (BD)
[ 123] 0x900000001fc05544:  00 00 00 00 nop
  124: 	j	ra
[ 124] 0x900000001fc05548:  03 e0 00 08 jr	ra
  125: 	nop				# (BD)
[ 125] 0x900000001fc0554c:  00 00 00 00 nop
  126: 2:
  127: 	j	ra			# Return
[ 127] 0x900000001fc05550:  03 e0 00 08 jr	ra
  128: 	sb	a0, DATA(a1)		# Write the character out		
[ 128] 0x900000001fc05554:  a0 a4 00 10 sb	a0,16(a1)
  129: 	END(epcuart_putc)
  130: 
  131: 
  132: /*
  133:  * Routine epcuart_poll
  134:  *	Checks to see whether a character is available for reading.
  135:  *	If a character is available, v0 will be non-zero.
  136:  * Arguments
  137:  *	a0 -- Channel to poll on.
  138:  * Returns:
  139:  *	v0 -- Non-zero if a character is available, zero otherwise.
  140:  * Uses registers:
  141:  *	a0, v0.
  142:  */
  143: 
  144: LEAF(epcuart_poll)
  145: 	.set	noreorder
  146: 	DMFBR(v0, BR_DUARTBASE)
epcuart_poll:
[ 146] 0x900000001fc05558:  44 22 18 00 dmfc1	v0,$f3
  147: 	dadd	v0, a0			# Add in the channel selector
[ 147] 0x900000001fc0555c:  00 44 10 2c dadd	v0,v0,a0
  148: 1:		
  149: 	lb	v0, CNTRL(v0)		# Read	
[ 149] 0x900000001fc05560:  80 42 00 00 lb	v0,0(v0)
  150: 	nop
[ 150] 0x900000001fc05564:  00 00 00 00 nop
  151: 	j	ra			# Return
[ 151] 0x900000001fc05568:  03 e0 00 08 jr	ra
  152: 	andi	v0, RR0_RX_CHR
[ 152] 0x900000001fc0556c:  30 42 00 01 andi	v0,v0,0x1
  153: 	END(epcuart_poll)
  154: 
  155: 
  156: /* 
  157:  * Routine epc_puthex
  158:  *	Writes a 64-bit hex number to EPC UART.
  159:  *
  160:  * Arguments:
  161:  *	a0 -- the 64-bit hex number to write.
  162:  *	a1 -- Channel to write to.
  163:  * Returns:
  164:  *	v0 -- Success.  Non-zero indicates write successful.
  165:  * Uses registers:
  166:  *	a0, a1, a2, v0, v1, ta1, ta2, ta3, t8, t9
  167:  */
  168: 
  169: LEAF(epcuart_puthex)
  170: 	.set	noreorder
  171: 	move	t9, ra
epcuart_puthex:
[ 171] 0x900000001fc05570:  03 e0 c8 25 move	t9,ra
  172: 	jal	getendian
[ 172] 0x900000001fc05574:  0f f0 0d d0 jal		getendian
  173: 	li	t8, 16
[ 173] 0x900000001fc05578:  24 18 00 10 li	t8,16
  174: 	move    ta2, v0
[ 174] 0x900000001fc0557c:  00 40 50 25 move	a6,v0
  175: 	move    ta1, a0	  		# Copy argument to ta1
[ 175] 0x900000001fc05580:  00 80 48 25 move	a5,a0
  176: 	move	a2, a1			# Save channel value
[ 176] 0x900000001fc05584:  00 a0 30 25 move	a2,a1
  177: 2:
  178: 	dsrl    a0,ta1,30		# Shift right 60 bits ($@!&*# assembler
[ 178] 0x900000001fc05588:  00 09 27 ba dsrl	a0,a5,30
  179: 	dsrl    a0,a0,30		#       won't assemble srl32 a0,ta1,28)
[ 179] 0x900000001fc0558c:  00 04 27 ba dsrl	a0,a0,30
  180: 					# This isolates the rightmost nibble
  181: 	dla	ta3,hexdigit
[ 181] 0x900000001fc05590:  3c 0b 90 00 lui	a7,0x9000
[ 181] 0x900000001fc05594:  65 6b 00 00 daddiu	a7,a7,0
[ 181] 0x900000001fc05598:  00 0b 5c 38 dsll	a7,a7,16
[ 181] 0x900000001fc0559c:  65 6b 1f c1 daddiu	a7,a7,8129
[ 181] 0x900000001fc055a0:  00 0b 5c 38 dsll	a7,a7,16
[ 181] 0x900000001fc055a4:  65 6b 77 c8 daddiu	a7,a7,30664
  182: 	daddu	a0,ta3	   		# (BD)
[ 182] 0x900000001fc055a8:  00 8b 20 2d daddu	a0,a0,a7
  183: 	beq     ta2,zero,3f      	# 0 = big endian
[ 183] 0x900000001fc055ac:  11 40 00 02 beq	a6,zero,0x900000001fc055b8
  184: 	nop
[ 184] 0x900000001fc055b0:  00 00 00 00 nop
  185: 	xor     a0,3	    		# assumes hexdigit burned in eb order
[ 185] 0x900000001fc055b4:  38 84 00 03 xori	a0,a0,0x3
  186: 3:
  187: 	jal     get_char 
[ 187] 0x900000001fc055b8:  0f f0 0d 88 jal		get_char
  188: 	nop		     		# (BD)
[ 188] 0x900000001fc055bc:  00 00 00 00 nop
  189: 
  190: 	move	a1, a2			# Reload channel information
[ 190] 0x900000001fc055c0:  00 c0 28 25 move	a1,a2
  191: 	jal     epcuart_putc     	# Print it
[ 191] 0x900000001fc055c4:  0f f0 15 47 jal		epcuart_putc
  192: 	move    a0, v0	  		# (BD) Load character to be written
[ 192] 0x900000001fc055c8:  00 40 20 25 move	a0,v0
  193: 
  194: 	sub     t8,1	    		# Entire number printed?
[ 194] 0x900000001fc055cc:  23 18 ff ff addi	t8,t8,-1
  195: 	beqz	v0, 4f			# If putc fails, give up on the number
[ 195] 0x900000001fc055d0:  10 40 00 04 beq	v0,zero,0x900000001fc055e4
  196: 	nop
[ 196] 0x900000001fc055d4:  00 00 00 00 nop
  197: 	dsll    ta1,4	    		# Set up next nibble
[ 197] 0x900000001fc055d8:  00 09 49 38 dsll	a5,a5,4
  198: 	bne     t8,zero,2b
[ 198] 0x900000001fc055dc:  17 00 ff ea bne	t8,zero,0x900000001fc05588
  199: 	nop
[ 199] 0x900000001fc055e0:  00 00 00 00 nop
  200: 4:
  201: 	j       t9	      		# Yes - done
[ 201] 0x900000001fc055e4:  03 20 00 08 jr	t9
  202: 	nop
[ 202] 0x900000001fc055e8:  00 00 00 00 nop
  203: 	END(epcuart_puthex)
  204: 
  205: 
  206: /*
  207:  * Routine epcuart_puts
  208:  *	Writes a null-terminates string to the EPC UART.
  209:  *
  210:  * Arguments:
  211:  *	a0 -- the address of the first character of the string.
  212:  *	a1 -- The channel to write to.
  213:  * Returns:
  214:  *	v0 -- If non-zero, puts (probably) succeeeded. Otherwise, it failed.
  215:  * Uses:
  216:  *	a0, a1, a2, v0, v1, ta2, ta3, t8, t9
  217:  */
  218: 
  219: LEAF(epcuart_puts)
  220: 	.set    noreorder
  221:         move    t9, ra                  # Save the return address
epcuart_puts:
[ 221] 0x900000001fc055ec:  03 e0 c8 25 move	t9,ra
  222:         move    ta3, a0                  # Save the argument register
[ 222] 0x900000001fc055f0:  00 80 58 25 move	a7,a0
  223: 	move	a2, a1			# Save the channel number
[ 223] 0x900000001fc055f4:  00 a0 30 25 move	a2,a1
  224:         jal     getendian               # Get endianess
[ 224] 0x900000001fc055f8:  0f f0 0d d0 jal		getendian
  225:         nop     
[ 225] 0x900000001fc055fc:  00 00 00 00 nop
  226:         move    t8, v0                  # Put endianess in t8
[ 226] 0x900000001fc05600:  00 40 c0 25 move	t8,v0
  227: 1:
  228:         move    ta2, ta3                  # (BD) Copy next_char to curr_char
[ 228] 0x900000001fc05604:  01 60 50 25 move	a6,a7
  229:         beq     t8, zero, 2f            # Skip to write char if big-endian
[ 229] 0x900000001fc05608:  13 00 00 02 beq	t8,zero,0x900000001fc05614
  230: 	nop
[ 230] 0x900000001fc0560c:  00 00 00 00 nop
  231:         xor     ta2, 3                   # If EL, swizzle the bits
[ 231] 0x900000001fc05610:  39 4a 00 03 xori	a6,a6,0x3
  232: 2:     
  233:         jal     get_char 
[ 233] 0x900000001fc05614:  0f f0 0d 88 jal		get_char
  234:         move    a0, ta2
[ 234] 0x900000001fc05618:  01 40 20 25 move	a0,a6
  235:         move    a0, v0
[ 235] 0x900000001fc0561c:  00 40 20 25 move	a0,v0
  236:         dadd	ta3, 1			# Increment next char. 
[ 236] 0x900000001fc05620:  61 6b 00 01 daddi	a7,a7,1
  237:         beq     a0, zero, 3f            # If char == zero, return
[ 237] 0x900000001fc05624:  10 80 00 07 beq	a0,zero,0x900000001fc05644
  238:         nop                             # (BD)
[ 238] 0x900000001fc05628:  00 00 00 00 nop
  239:         jal     epcuart_putc            # 
[ 239] 0x900000001fc0562c:  0f f0 15 47 jal		epcuart_putc
  240:         move	a1, a2 			# (BD) Reload channel number
[ 240] 0x900000001fc05630:  00 c0 28 25 move	a1,a2
  241: 
  242: 	beqz	v0, 3f       		# If putc fails, give up on the string
[ 242] 0x900000001fc05634:  10 40 00 03 beq	v0,zero,0x900000001fc05644
  243: 	nop				# (BD)
[ 243] 0x900000001fc05638:  00 00 00 00 nop
  244:  
  245:         b       1b                      # Loop back up
[ 245] 0x900000001fc0563c:  10 00 ff f1 b		0x900000001fc05604
  246:         nop                             # (BD)
[ 246] 0x900000001fc05640:  00 00 00 00 nop
  247: 3:
  248:         j       t9                      # Return
[ 248] 0x900000001fc05644:  03 20 00 08 jr	t9
  249:         nop                             # (BD)
[ 249] 0x900000001fc05648:  00 00 00 00 nop
       0x900000001fc0564c:  00 00 00 00 nop
Skipping source listing to line 31 of /cores/banyan/stand/arcs/IP25prom/podasm.s...
   32: /*
   33:  * run_cached
   34:  *      This routine reinitializes the primary and secondary caches,
   35:  *      invalidates the bus tags, then sets up its stack in cached
   36:  *      space and jumps back to the address stored in a0.
   37:  */
   38: 
   39: LEAF(run_cached)
   40: 	.set	noreorder
   41: 	move	s6, a0				# Save jump address
run_cached:
[  41] 0x900000001fc05650:  00 80 b0 25 move	s6,a0
   42: 	DPRINT("Clearing secondary cache\r\n")
   43:    	jal 	invalidateScache
[  43] 0x900000001fc05654:  0f f0 08 c3 jal		invalidateScache
   44: 	nop
[  44] 0x900000001fc05658:  00 00 00 00 nop
   45: 	DPRINT("Invalidating primary i and d caches\r\n")
   46: 	jal	invalidateIDcache
[  46] 0x900000001fc0565c:  0f f0 07 f8 jal		invalidateIDcache
   47: 	nop
[  47] 0x900000001fc05660:  00 00 00 00 nop
   48: 	DPRINT("Building Stack\r\n")
   49: 	jal	initDcacheStack
[  49] 0x900000001fc05664:  0f f0 0a de jal		initDcacheStack
   50: 	nop
[  50] 0x900000001fc05668:  00 00 00 00 nop
   51: 
   52: 	dli	t0, EV_SPNUM
[  52] 0x900000001fc0566c:  3c 0c 90 00 lui	t0,0x9000
[  52] 0x900000001fc05670:  00 0c 64 38 dsll	t0,t0,16
[  52] 0x900000001fc05674:  35 8c 18 00 ori	t0,t0,0x1800
[  52] 0x900000001fc05678:  00 0c 64 38 dsll	t0,t0,16
[  52] 0x900000001fc0567c:  35 8c 00 08 ori	t0,t0,0x8
   53: 	ld	t0, 0(t0)
[  53] 0x900000001fc05680:  dd 8c 00 00 ld	t0,0(t0)
   54: 	andi	t0, EV_SPNUM_MASK
[  54] 0x900000001fc05684:  31 8c 00 3f andi	t0,t0,0x3f
   55: 	dsll	t0, 16
[  55] 0x900000001fc05688:  00 0c 64 38 dsll	t0,t0,16
   56: 	dadd	sp, t0
[  56] 0x900000001fc0568c:  03 ac e8 2c dadd	sp,sp,t0
   57: 
   58: 	DPRINT("Jumping to pod loop\r\n")
   59: 	dli	a1, EVDIAG_DEBUG		# Set second POD parameter.
[  59] 0x900000001fc05690:  24 05 00 fd li	a1,253
   60: 	j	s6
[  60] 0x900000001fc05694:  02 c0 00 08 jr	s6
   61: 	li	a0, 0				# (BD) Send a 0 as a parm.
[  61] 0x900000001fc05698:  24 04 00 00 li	a0,0
   62: 	.set	reorder
   63: 	END(run_cached)
   64: 
   65: LEAF(run_uncached)
   66: 	move	s5, a0
run_uncached:
[  66] 0x900000001fc0569c:  00 80 a8 25 move	s5,a0
   67: 	move	s6, a1
[  67] 0x900000001fc056a0:  00 a0 b0 25 move	s6,a1
   68: 
   69: 	dli	sp, IP25PROM_STACK
[  69] 0x900000001fc056a4:  3c 1d a8 00 lui	sp,0xa800
[  69] 0x900000001fc056a8:  00 1d ec 38 dsll	sp,sp,16
[  69] 0x900000001fc056ac:  37 bd 00 98 ori	sp,sp,0x98
[  69] 0x900000001fc056b0:  00 1d ec 38 dsll	sp,sp,16
[  69] 0x900000001fc056b4:  37 bd 00 00 ori	sp,sp,0
   70: 	dli	t0, 0x9fffffff
[  70] 0x900000001fc056b8:  34 0c 9f ff ori	t0,zero,0x9fff
[  70] 0x900000001fc056bc:  00 0c 64 38 dsll	t0,t0,16
[  70] 0x900000001fc056c0:  35 8c ff ff ori	t0,t0,0xffff
   71: 	and	sp, t0
[  71] 0x900000001fc056c4:  03 ac e8 24 and	sp,sp,t0
   72: 	or	sp, K1BASE
[  72] 0x900000001fc056c8:  24 01 00 09 li	at,9
[  72] 0x900000001fc056cc:  00 01 0f 3c dsll32	at,at,28
[  72] 0x900000001fc056d0:  03 a1 e8 25 or	sp,sp,at
   73: 	dli	t0, EV_SPNUM
[  73] 0x900000001fc056d4:  3c 0c 90 00 lui	t0,0x9000
[  73] 0x900000001fc056d8:  00 0c 64 38 dsll	t0,t0,16
[  73] 0x900000001fc056dc:  35 8c 18 00 ori	t0,t0,0x1800
[  73] 0x900000001fc056e0:  00 0c 64 38 dsll	t0,t0,16
[  73] 0x900000001fc056e4:  35 8c 00 08 ori	t0,t0,0x8
   74: 	ld	t0, 0(t0)
[  74] 0x900000001fc056e8:  dd 8c 00 00 ld	t0,0(t0)
   75: 	andi	t0, EV_SPNUM_MASK
[  75] 0x900000001fc056ec:  31 8c 00 3f andi	t0,t0,0x3f
   76: 	dsll	t0, 16
[  76] 0x900000001fc056f0:  00 0c 64 38 dsll	t0,t0,16
   77: 	dadd	sp, t0
[  77] 0x900000001fc056f4:  03 ac e8 2c dadd	sp,sp,t0
   78: 
   79: 	.set	noreorder
   80: 	DPRINT("Invalidating primary dcache\r\n")
   81: 	.set	reorder
   82: 	jal	invalidateDcache
[  82] 0x900000001fc056f8:  0f f0 07 d0 jal		invalidateDcache
[  82] 0x900000001fc056fc:  00 00 00 00 nop
   83: 
   84: 	move	a0, s6				# retrieve argument
[  84] 0x900000001fc05700:  02 c0 20 25 move	a0,s6
   85: 	j	s5
[  85] 0x900000001fc05704:  02 a0 00 08 jr	s5
[  85] 0x900000001fc05708:  00 00 00 00 nop
   86: 
   87: 	/* Doesn't return */
   88: 
   89: 	END(run_uncached)
   90: 
   91: LEAF(saveGprs)
   92: /*
   93:  * Function: saveGprs
   94:  * Purpose:  To save away the current general registers into the floating
   95:  *		point registers.
   96:  * Parameters:	none
   97:  * Returns:	nothing
   98:  * Notes:	IF YOU CHANGE THIS, CHANGE podResume
   99:  */
  100: 
  101: 	.set	noat
  102: 
  103:         /* Enable floating point registers. */
  104: 
  105:         .set	noreorder
  106:         MFC0(k0, C0_SR)
saveGprs:
[ 106] 0x900000001fc0570c:  40 1a 60 00 mfc0	k0,sr
  107:         li	k1, SR_CU1|SR_FR
[ 107] 0x900000001fc05710:  3c 1b 24 00 lui	k1,0x2400
  108:         or	k0, k1
[ 108] 0x900000001fc05714:  03 5b d0 25 or	k0,k0,k1
  109:         MTC0(k0, C0_SR)
[ 109] 0x900000001fc05718:  40 9a 60 00 mtc0	k0,sr
  110:         .set	reorder
  111: 
  112:         /* Save everything away */
  113: 
  114: 	DMTC1($at, AT_FP)
[ 114] 0x900000001fc0571c:  44 a1 30 00 dmtc1	at,$f6
  115:         DMTC1(a0, A0_FP)
[ 115] 0x900000001fc05720:  44 a4 38 00 dmtc1	a0,$f7
  116: 	DMTC1(a1, A1_FP)
[ 116] 0x900000001fc05724:  44 a5 40 00 dmtc1	a1,$f8
  117: 	DMTC1(a2, A2_FP) 
[ 117] 0x900000001fc05728:  44 a6 48 00 dmtc1	a2,$f9
  118: 	DMTC1(v0, V0_FP)
[ 118] 0x900000001fc0572c:  44 a2 50 00 dmtc1	v0,$f10
  119: 	DMTC1(v1, V1_FP)
[ 119] 0x900000001fc05730:  44 a3 58 00 dmtc1	v1,$f11
  120: 	DMTC1(t0, T0_FP) 
[ 120] 0x900000001fc05734:  44 ac 60 00 dmtc1	t0,$f12
  121: 	DMTC1(t1, T1_FP)
[ 121] 0x900000001fc05738:  44 ad 68 00 dmtc1	t1,$f13
  122: 	DMTC1(t2, T2_FP)
[ 122] 0x900000001fc0573c:  44 ae 70 00 dmtc1	t2,$f14
  123: 	DMTC1(t3, T3_FP)
[ 123] 0x900000001fc05740:  44 af 78 00 dmtc1	t3,$f15
  124:         DMTC1(ta0,T4_FP)
[ 124] 0x900000001fc05744:  44 a8 80 00 dmtc1	a4,$f16
  125: 	DMTC1(ta1,T5_FP)
[ 125] 0x900000001fc05748:  44 a9 88 00 dmtc1	a5,$f17
  126: 	DMTC1(ta2,T6_FP)
[ 126] 0x900000001fc0574c:  44 aa 90 00 dmtc1	a6,$f18
  127: 	DMTC1(ta3,T7_FP)
[ 127] 0x900000001fc05750:  44 ab 98 00 dmtc1	a7,$f19
  128: 	DMTC1(s0, S0_FP)
[ 128] 0x900000001fc05754:  44 b0 a0 00 dmtc1	s0,$f20
  129: 	DMTC1(s1, S1_FP)
[ 129] 0x900000001fc05758:  44 b1 a8 00 dmtc1	s1,$f21
  130: 	DMTC1(s2, S2_FP)
[ 130] 0x900000001fc0575c:  44 b2 b0 00 dmtc1	s2,$f22
  131:  	DMTC1(s3, S3_FP)
[ 131] 0x900000001fc05760:  44 b3 b8 00 dmtc1	s3,$f23
  132: 	DMTC1(s4, S4_FP) 
[ 132] 0x900000001fc05764:  44 b4 c0 00 dmtc1	s4,$f24
  133: 	DMTC1(s5, S5_FP)
[ 133] 0x900000001fc05768:  44 b5 c8 00 dmtc1	s5,$f25
  134: 	DMTC1(t8, T8_FP)
[ 134] 0x900000001fc0576c:  44 b8 d8 00 dmtc1	t8,$f27
  135: 	DMTC1(t9, T9_FP) 
[ 135] 0x900000001fc05770:  44 b9 e0 00 dmtc1	t9,$f28
  136:         DMTC1(sp, SP_FP)
[ 136] 0x900000001fc05774:  44 bd e8 00 dmtc1	sp,$f29
  137: 
  138: 	j	ra
[ 138] 0x900000001fc05778:  03 e0 00 08 jr	ra
[ 138] 0x900000001fc0577c:  00 00 00 00 nop
  139: 	nop
[ 139] 0x900000001fc05780:  00 00 00 00 nop
  140:         .set	at
  141: 
  142: 	END(saveGprs)
  143: 
  144: 
  145: LEAF(podResume)
  146: 	.set	noreorder
  147: 	.set	noat
  148: 	# Stash away GPRs in FPRs
  149: 
  150: 	DMFC0(t9, C0_EPC)
podResume:
[ 150] 0x900000001fc05784:  40 39 70 00 dmfc0	t9,epc
  151: 
  152: 	DMFC1($at, AT_FP)
[ 152] 0x900000001fc05788:  44 21 30 00 dmfc1	at,$f6
  153: 	DMFC1(a0, A0_FP)
[ 153] 0x900000001fc0578c:  44 24 38 00 dmfc1	a0,$f7
  154: 	DMFC1(a1, A1_FP)
[ 154] 0x900000001fc05790:  44 25 40 00 dmfc1	a1,$f8
  155: 	DMFC1(a2, A2_FP)
[ 155] 0x900000001fc05794:  44 26 48 00 dmfc1	a2,$f9
  156: 	DMFC1(v0, V0_FP)
[ 156] 0x900000001fc05798:  44 22 50 00 dmfc1	v0,$f10
  157: 	DMFC1(v1, V1_FP)
[ 157] 0x900000001fc0579c:  44 23 58 00 dmfc1	v1,$f11
  158: 	DMFC1(t0, T0_FP)
[ 158] 0x900000001fc057a0:  44 2c 60 00 dmfc1	t0,$f12
  159: 	
  160: 	daddi	t9, 4
[ 160] 0x900000001fc057a4:  63 39 00 04 daddi	t9,t9,4
  161: 	DMTC0(t9, C0_EPC)
[ 161] 0x900000001fc057a8:  40 b9 70 00 dmtc0	t9,epc
  162: 
  163: 	DMFC1(t1, T1_FP)
[ 163] 0x900000001fc057ac:  44 2d 68 00 dmfc1	t1,$f13
  164: 	DMFC1(t2, T2_FP)
[ 164] 0x900000001fc057b0:  44 2e 70 00 dmfc1	t2,$f14
  165: 	DMFC1(t3, T3_FP)
[ 165] 0x900000001fc057b4:  44 2f 78 00 dmfc1	t3,$f15
  166: 	DMFC1(ta0, T4_FP)
[ 166] 0x900000001fc057b8:  44 28 80 00 dmfc1	a4,$f16
  167: 	DMFC1(ta1, T5_FP)
[ 167] 0x900000001fc057bc:  44 29 88 00 dmfc1	a5,$f17
  168: 	DMFC1(ta2, T6_FP)
[ 168] 0x900000001fc057c0:  44 2a 90 00 dmfc1	a6,$f18
  169: 	DMFC1(ta3, T7_FP)
[ 169] 0x900000001fc057c4:  44 2b 98 00 dmfc1	a7,$f19
  170: 	DMFC1(s0, S0_FP)
[ 170] 0x900000001fc057c8:  44 30 a0 00 dmfc1	s0,$f20
  171: 	DMFC1(s1, S1_FP)
[ 171] 0x900000001fc057cc:  44 31 a8 00 dmfc1	s1,$f21
  172: 	DMFC1(s2, S2_FP)
[ 172] 0x900000001fc057d0:  44 32 b0 00 dmfc1	s2,$f22
  173: 	DMFC1(s3, S3_FP)
[ 173] 0x900000001fc057d4:  44 33 b8 00 dmfc1	s3,$f23
  174: 	DMFC1(s4, S4_FP)
[ 174] 0x900000001fc057d8:  44 34 c0 00 dmfc1	s4,$f24
  175: 	DMFC1(s5, S5_FP)
[ 175] 0x900000001fc057dc:  44 35 c8 00 dmfc1	s5,$f25
  176: 	DMFC1(t8, T8_FP)
[ 176] 0x900000001fc057e0:  44 38 d8 00 dmfc1	t8,$f27
  177: 	DMFC1(t9, T9_FP)
[ 177] 0x900000001fc057e4:  44 39 e0 00 dmfc1	t9,$f28
  178: 	DMFC1(sp, SP_FP)
[ 178] 0x900000001fc057e8:  44 3d e8 00 dmfc1	sp,$f29
  179: 	DMFC1(ra, RA_FP)
[ 179] 0x900000001fc057ec:  44 3f f8 00 dmfc1	ra,$f31
  180: 
  181: 	eret	
[ 181] 0x900000001fc057f0:  42 00 00 18 c0	eret
  182: 
  183: 	# No more GPRs to stash.  If you change this code, be sure to change
  184: 	# 						load_regs as well.
  185: 
  186: 	END(podResume)
  187: 
  188: /* void podMode(uchar code, char *message)
  189:  * 	Configure the primary data cache as a dirty-exclusive stack and 
  190:  *	run a small command interpretor.  Requires no memory or bus access.
  191:  *	Prints "message" and uses "code" to determine what to display on
  192:  *	the system controller. 
  193:  *	Never returns.
  194:  */
  195: LEAF(podMode)
  196: 	.set	noreorder
  197: 	MFC0(s0,C0_SR)
podMode:
[ 197] 0x900000001fc057f4:  40 10 60 00 mfc0	s0,sr
  198: 	dli	v0,POD_SR
[ 198] 0x900000001fc057f8:  3c 02 24 40 lui	v0,0x2440
[ 198] 0x900000001fc057fc:  34 42 7c 80 ori	v0,v0,0x7c80
  199: 	MTC0(v0,C0_SR)
[ 199] 0x900000001fc05800:  40 82 60 00 mtc0	v0,sr
  200: 	
  201: 	move	s1, a1			# Grab argument and save it
[ 201] 0x900000001fc05804:  00 a0 88 25 move	s1,a1
  202: 	move	s6, a0			# Grab failure code and save it
[ 202] 0x900000001fc05808:  00 80 b0 25 move	s6,a0
  203: 	move	s5, ra			# Save RA
[ 203] 0x900000001fc0580c:  03 e0 a8 25 move	s5,ra
  204: 	LEDS(PLED_POD)
[ 204] 0x900000001fc05810:  00 00 00 00 nop
[ 204] 0x900000001fc05814:  34 04 00 20 ori	a0,zero,0x20
[ 204] 0x900000001fc05818:  3c 02 90 00 lui	v0,0x9000
[ 204] 0x900000001fc0581c:  00 02 14 38 dsll	v0,v0,16
[ 204] 0x900000001fc05820:  34 42 19 00 ori	v0,v0,0x1900
[ 204] 0x900000001fc05824:  00 02 14 38 dsll	v0,v0,16
[ 204] 0x900000001fc05828:  34 42 40 00 ori	v0,v0,0x4000
[ 204] 0x900000001fc0582c:  fc 44 00 00 sd	a0,0(v0)
  205: 
  206: 	# 1st argument passed in is a string set by the prom handler.
  207: 	# print that first.
  208: 	move	a0, s1			# restore print string
[ 208] 0x900000001fc05830:  02 20 20 25 move	a0,s1
  209: 	jal	pod_puts		# print string 
[ 209] 0x900000001fc05834:  0f f0 15 03 jal		pod_puts
  210: 
  211: 	li	a1, EVDIAG_DEBUG
[ 211] 0x900000001fc05838:  24 05 00 fd li	a1,253
  212: 	beq	a1, s6, 1f		# On debug, don't print stuff
[ 212] 0x900000001fc0583c:  10 b6 00 88 beq	a1,s6,0x900000001fc05a60
  213: 	nop	
[ 213] 0x900000001fc05840:  00 00 00 00 nop
  214: 
  215: 	PMESSAGE("\n\r EPC:   0x"); DMFC0(a0,C0_EPC); PHEX(a0)
[ 215] 0x900000001fc05844:  3c 04 90 00 lui	a0,0x9000
[ 215] 0x900000001fc05848:  64 84 00 00 daddiu	a0,a0,0
[ 215] 0x900000001fc0584c:  00 04 24 38 dsll	a0,a0,16
[ 215] 0x900000001fc05850:  64 84 1f c1 daddiu	a0,a0,8129
[ 215] 0x900000001fc05854:  00 04 24 38 dsll	a0,a0,16
[ 215] 0x900000001fc05858:  64 84 79 80 daddiu	a0,a0,31104
[ 215] 0x900000001fc0585c:  0f f0 15 03 jal		pod_puts
[ 215] 0x900000001fc05860:  00 00 00 00 nop
[ 215] 0x900000001fc05864:  40 24 70 00 dmfc0	a0,epc
[ 215] 0x900000001fc05868:  00 04 20 25 or	a0,zero,a0
[ 215] 0x900000001fc0586c:  0f f0 14 f8 jal		pod_puthex64
[ 215] 0x900000001fc05870:  00 00 00 00 nop
  216: 	PMESSAGE("   ERROR-EPC: 0x"); DMFC0(a0,C0_ERROR_EPC);PHEX(a0)
[ 216] 0x900000001fc05874:  3c 04 90 00 lui	a0,0x9000
[ 216] 0x900000001fc05878:  64 84 00 00 daddiu	a0,a0,0
[ 216] 0x900000001fc0587c:  00 04 24 38 dsll	a0,a0,16
[ 216] 0x900000001fc05880:  64 84 1f c1 daddiu	a0,a0,8129
[ 216] 0x900000001fc05884:  00 04 24 38 dsll	a0,a0,16
[ 216] 0x900000001fc05888:  64 84 79 8d daddiu	a0,a0,31117
[ 216] 0x900000001fc0588c:  0f f0 15 03 jal		pod_puts
[ 216] 0x900000001fc05890:  00 00 00 00 nop
[ 216] 0x900000001fc05894:  40 24 f0 00 dmfc0	a0,errorepc
[ 216] 0x900000001fc05898:  00 04 20 25 or	a0,zero,a0
[ 216] 0x900000001fc0589c:  0f f0 14 f8 jal		pod_puthex64
[ 216] 0x900000001fc058a0:  00 00 00 00 nop
  217:         PMESSAGE("\n\r");	
[ 217] 0x900000001fc058a4:  3c 04 90 00 lui	a0,0x9000
[ 217] 0x900000001fc058a8:  64 84 00 00 daddiu	a0,a0,0
[ 217] 0x900000001fc058ac:  00 04 24 38 dsll	a0,a0,16
[ 217] 0x900000001fc058b0:  64 84 1f c1 daddiu	a0,a0,8129
[ 217] 0x900000001fc058b4:  00 04 24 38 dsll	a0,a0,16
[ 217] 0x900000001fc058b8:  64 84 79 9e daddiu	a0,a0,31134
[ 217] 0x900000001fc058bc:  0f f0 15 03 jal		pod_puts
[ 217] 0x900000001fc058c0:  00 00 00 00 nop
  218: 
  219: 	PMESSAGE(" BadVA: 0x"); DMFC0(a0,C0_BADVADDR); PHEX(a0);
[ 219] 0x900000001fc058c4:  3c 04 90 00 lui	a0,0x9000
[ 219] 0x900000001fc058c8:  64 84 00 00 daddiu	a0,a0,0
[ 219] 0x900000001fc058cc:  00 04 24 38 dsll	a0,a0,16
[ 219] 0x900000001fc058d0:  64 84 1f c1 daddiu	a0,a0,8129
[ 219] 0x900000001fc058d4:  00 04 24 38 dsll	a0,a0,16
[ 219] 0x900000001fc058d8:  64 84 79 a1 daddiu	a0,a0,31137
[ 219] 0x900000001fc058dc:  0f f0 15 03 jal		pod_puts
[ 219] 0x900000001fc058e0:  00 00 00 00 nop
[ 219] 0x900000001fc058e4:  40 24 40 00 dmfc0	a0,badvaddr
[ 219] 0x900000001fc058e8:  00 04 20 25 or	a0,zero,a0
[ 219] 0x900000001fc058ec:  0f f0 14 f8 jal		pod_puthex64
[ 219] 0x900000001fc058f0:  00 00 00 00 nop
  220: 	PMESSAGE("   Return:    0x"); DMFC1(a0, RA_FP); PHEX(a0);
[ 220] 0x900000001fc058f4:  3c 04 90 00 lui	a0,0x9000
[ 220] 0x900000001fc058f8:  64 84 00 00 daddiu	a0,a0,0
[ 220] 0x900000001fc058fc:  00 04 24 38 dsll	a0,a0,16
[ 220] 0x900000001fc05900:  64 84 1f c1 daddiu	a0,a0,8129
[ 220] 0x900000001fc05904:  00 04 24 38 dsll	a0,a0,16
[ 220] 0x900000001fc05908:  64 84 79 ac daddiu	a0,a0,31148
[ 220] 0x900000001fc0590c:  0f f0 15 03 jal		pod_puts
[ 220] 0x900000001fc05910:  00 00 00 00 nop
[ 220] 0x900000001fc05914:  44 24 f8 00 dmfc1	a0,$f31
[ 220] 0x900000001fc05918:  00 04 20 25 or	a0,zero,a0
[ 220] 0x900000001fc0591c:  0f f0 14 f8 jal		pod_puthex64
[ 220] 0x900000001fc05920:  00 00 00 00 nop
  221: 	
  222: 	PMESSAGE("\r\n SP:    0x"); PHEX(sp); 
[ 222] 0x900000001fc05924:  3c 04 90 00 lui	a0,0x9000
[ 222] 0x900000001fc05928:  64 84 00 00 daddiu	a0,a0,0
[ 222] 0x900000001fc0592c:  00 04 24 38 dsll	a0,a0,16
[ 222] 0x900000001fc05930:  64 84 1f c1 daddiu	a0,a0,8129
[ 222] 0x900000001fc05934:  00 04 24 38 dsll	a0,a0,16
[ 222] 0x900000001fc05938:  64 84 79 bd daddiu	a0,a0,31165
[ 222] 0x900000001fc0593c:  0f f0 15 03 jal		pod_puts
[ 222] 0x900000001fc05940:  00 00 00 00 nop
[ 222] 0x900000001fc05944:  00 1d 20 25 or	a0,zero,sp
[ 222] 0x900000001fc05948:  0f f0 14 f8 jal		pod_puthex64
[ 222] 0x900000001fc0594c:  00 00 00 00 nop
  223:         PMESSAGE("   A0:        0x"); DMFC1(a0, A0_FP); PHEX(a0)
[ 223] 0x900000001fc05950:  3c 04 90 00 lui	a0,0x9000
[ 223] 0x900000001fc05954:  64 84 00 00 daddiu	a0,a0,0
[ 223] 0x900000001fc05958:  00 04 24 38 dsll	a0,a0,16
[ 223] 0x900000001fc0595c:  64 84 1f c1 daddiu	a0,a0,8129
[ 223] 0x900000001fc05960:  00 04 24 38 dsll	a0,a0,16
[ 223] 0x900000001fc05964:  64 84 79 ca daddiu	a0,a0,31178
[ 223] 0x900000001fc05968:  0f f0 15 03 jal		pod_puts
[ 223] 0x900000001fc0596c:  00 00 00 00 nop
[ 223] 0x900000001fc05970:  44 24 38 00 dmfc1	a0,$f7
[ 223] 0x900000001fc05974:  00 04 20 25 or	a0,zero,a0
[ 223] 0x900000001fc05978:  0f f0 14 f8 jal		pod_puthex64
[ 223] 0x900000001fc0597c:  00 00 00 00 nop
  224: 	PMESSAGE("\r\n")
[ 224] 0x900000001fc05980:  3c 04 90 00 lui	a0,0x9000
[ 224] 0x900000001fc05984:  64 84 00 00 daddiu	a0,a0,0
[ 224] 0x900000001fc05988:  00 04 24 38 dsll	a0,a0,16
[ 224] 0x900000001fc0598c:  64 84 1f c1 daddiu	a0,a0,8129
[ 224] 0x900000001fc05990:  00 04 24 38 dsll	a0,a0,16
[ 224] 0x900000001fc05994:  64 84 79 db daddiu	a0,a0,31195
[ 224] 0x900000001fc05998:  0f f0 15 03 jal		pod_puts
[ 224] 0x900000001fc0599c:  00 00 00 00 nop
  225: 
  226: 	PMESSAGE(" Cause: 0x"); MFC0(a0,C0_CAUSE); PHEX32(a0);
[ 226] 0x900000001fc059a0:  3c 04 90 00 lui	a0,0x9000
[ 226] 0x900000001fc059a4:  64 84 00 00 daddiu	a0,a0,0
[ 226] 0x900000001fc059a8:  00 04 24 38 dsll	a0,a0,16
[ 226] 0x900000001fc059ac:  64 84 1f c1 daddiu	a0,a0,8129
[ 226] 0x900000001fc059b0:  00 04 24 38 dsll	a0,a0,16
[ 226] 0x900000001fc059b4:  64 84 79 de daddiu	a0,a0,31198
[ 226] 0x900000001fc059b8:  0f f0 15 03 jal		pod_puts
[ 226] 0x900000001fc059bc:  00 00 00 00 nop
[ 226] 0x900000001fc059c0:  40 04 68 00 mfc0	a0,cause
[ 226] 0x900000001fc059c4:  00 04 20 25 or	a0,zero,a0
[ 226] 0x900000001fc059c8:  0f f0 14 ed jal		pod_puthex32
[ 226] 0x900000001fc059cc:  00 00 00 00 nop
  227: 	PMESSAGE(" Status: 0x"); PHEX32(s0); 
[ 227] 0x900000001fc059d0:  3c 04 90 00 lui	a0,0x9000
[ 227] 0x900000001fc059d4:  64 84 00 00 daddiu	a0,a0,0
[ 227] 0x900000001fc059d8:  00 04 24 38 dsll	a0,a0,16
[ 227] 0x900000001fc059dc:  64 84 1f c1 daddiu	a0,a0,8129
[ 227] 0x900000001fc059e0:  00 04 24 38 dsll	a0,a0,16
[ 227] 0x900000001fc059e4:  64 84 79 e9 daddiu	a0,a0,31209
[ 227] 0x900000001fc059e8:  0f f0 15 03 jal		pod_puts
[ 227] 0x900000001fc059ec:  00 00 00 00 nop
[ 227] 0x900000001fc059f0:  00 10 20 25 or	a0,zero,s0
[ 227] 0x900000001fc059f4:  0f f0 14 ed jal		pod_puthex32
[ 227] 0x900000001fc059f8:  00 00 00 00 nop
  228: 	PMESSAGE(" Cache Error: 0x");	MFC0(a0, C0_CACHE_ERR); PHEX32(a0)
[ 228] 0x900000001fc059fc:  3c 04 90 00 lui	a0,0x9000
[ 228] 0x900000001fc05a00:  64 84 00 00 daddiu	a0,a0,0
[ 228] 0x900000001fc05a04:  00 04 24 38 dsll	a0,a0,16
[ 228] 0x900000001fc05a08:  64 84 1f c1 daddiu	a0,a0,8129
[ 228] 0x900000001fc05a0c:  00 04 24 38 dsll	a0,a0,16
[ 228] 0x900000001fc05a10:  64 84 79 f5 daddiu	a0,a0,31221
[ 228] 0x900000001fc05a14:  0f f0 15 03 jal		pod_puts
[ 228] 0x900000001fc05a18:  00 00 00 00 nop
[ 228] 0x900000001fc05a1c:  40 04 d8 00 mfc0	a0,cacheerr
[ 228] 0x900000001fc05a20:  00 04 20 25 or	a0,zero,a0
[ 228] 0x900000001fc05a24:  0f f0 14 ed jal		pod_puthex32
[ 228] 0x900000001fc05a28:  00 00 00 00 nop
  229:         PMESSAGE("\n\r");	
[ 229] 0x900000001fc05a2c:  3c 04 90 00 lui	a0,0x9000
[ 229] 0x900000001fc05a30:  64 84 00 00 daddiu	a0,a0,0
[ 229] 0x900000001fc05a34:  00 04 24 38 dsll	a0,a0,16
[ 229] 0x900000001fc05a38:  64 84 1f c1 daddiu	a0,a0,8129
[ 229] 0x900000001fc05a3c:  00 04 24 38 dsll	a0,a0,16
[ 229] 0x900000001fc05a40:  64 84 7a 06 daddiu	a0,a0,31238
[ 229] 0x900000001fc05a44:  0f f0 15 03 jal		pod_puts
[ 229] 0x900000001fc05a48:  00 00 00 00 nop
  230: 
  231: 	
  232: 	dli	s1,POD_STACKVADDR-8-1024+4096
[ 232] 0x900000001fc05a4c:  3c 11 a8 00 lui	s1,0xa800
[ 232] 0x900000001fc05a50:  00 11 8c 38 dsll	s1,s1,16
[ 232] 0x900000001fc05a54:  36 31 00 0f ori	s1,s1,0xf
[ 232] 0x900000001fc05a58:  00 11 8c 38 dsll	s1,s1,16
[ 232] 0x900000001fc05a5c:  36 31 eb f8 ori	s1,s1,0xebf8
  233: 1:
  234: 	move	a0, s5
[ 234] 0x900000001fc05a60:  02 a0 20 25 move	a0,s5
  235: 	move	a1, s6
[ 235] 0x900000001fc05a64:  02 c0 28 25 move	a1,s6
  236: 
  237: 	jal	run_incache		# and loop forever in pod_loop....
[ 237] 0x900000001fc05a68:  0f f0 16 9b jal		run_incache
  238: 	.set	reorder
  239: 	END(podMode)
  240: 
  241: /*
  242:  * Function:	run_incache
  243:  * Purpose:	To set up the stack in the primary data cache, and
  244:  * 		branch into pod.
  245:  * Parameters:	None
  246:  * Returns:	Nothing
  247:  * Notes:	Uses initDcacheStack to set up primary data cache 
  248:  *		at POD_STACKADDR.
  249:  */
  250: LEAF(run_incache)
  251: 	/*
  252: 	 * Set up Primary data cache for stack.
  253: 	 */
  254: 	jal	initDcacheStack
run_incache:
[ 254] 0x900000001fc05a6c:  0f f0 0a de jal		initDcacheStack
[ 254] 0x900000001fc05a70:  00 00 00 00 nop
  255: 	dli	t0,POD_SR
[ 255] 0x900000001fc05a74:  3c 0c 24 40 lui	t0,0x2440
[ 255] 0x900000001fc05a78:  35 8c 7c 80 ori	t0,t0,0x7c80
  256: 	.set	noreorder
  257: 	MTC0(t0,C0_SR)
[ 257] 0x900000001fc05a7c:  40 8c 60 00 mtc0	t0,sr
  258: 	.set	reorder
  259: 
  260: 	# and off to pod_loop (won't return)
  261: 	li	a0, 1			# 1 means dirty-exclusive
[ 261] 0x900000001fc05a80:  24 04 00 01 li	a0,1
  262: 	move	a1, s6			# Code passed to pod_handler
[ 262] 0x900000001fc05a84:  02 c0 28 25 move	a1,s6
  263: 	j	pod_loop
[ 263] 0x900000001fc05a88:  0b f0 19 1c j		pod_loop
[ 263] 0x900000001fc05a8c:  00 00 00 00 nop
  264: 	END(run_incache)
  265: 
  266: /*
  267:  * routines added to allow poking CPU registers at pod level
  268:  * rw = 0 --> read
  269:  */
  270: 
  271: /* _sp(rw, val) */
  272: LEAF(_sp)
  273: 	beq	a0,zero,1f
_sp:
[ 273] 0x900000001fc05a90:  10 80 00 04 beq	a0,zero,0x900000001fc05aa4
[ 273] 0x900000001fc05a94:  00 00 00 00 nop
  274: 	# write
  275: 	move	sp,a1
[ 275] 0x900000001fc05a98:  00 a0 e8 25 move	sp,a1
  276: 	j	ra
[ 276] 0x900000001fc05a9c:  03 e0 00 08 jr	ra
[ 276] 0x900000001fc05aa0:  00 00 00 00 nop
  277: 1:	# read only
  278: 	move	v0,sp
[ 278] 0x900000001fc05aa4:  03 a0 10 25 move	v0,sp
  279: 	j	ra
[ 279] 0x900000001fc05aa8:  03 e0 00 08 jr	ra
[ 279] 0x900000001fc05aac:  00 00 00 00 nop
  280: 	END(_sp)
  281: 
  282: /* _sr(rw, val) */
  283: LEAF(_sr)
  284: 	beq	a0,zero,1f
_sr:
[ 284] 0x900000001fc05ab0:  10 80 00 04 beq	a0,zero,0x900000001fc05ac4
[ 284] 0x900000001fc05ab4:  00 00 00 00 nop
  285: 	# write
  286: 	.set	noreorder
  287: 	MTC0(a1,C0_SR)
[ 287] 0x900000001fc05ab8:  40 85 60 00 mtc0	a1,sr
  288: 	.set	reorder
  289: 	j	ra
[ 289] 0x900000001fc05abc:  03 e0 00 08 jr	ra
[ 289] 0x900000001fc05ac0:  00 00 00 00 nop
  290: 1:	# read only
  291: 	.set	noreorder
  292: 	MFC0(v0,C0_SR)
[ 292] 0x900000001fc05ac4:  40 02 60 00 mfc0	v0,sr
  293: 	.set	reorder
  294: 	j	ra
[ 294] 0x900000001fc05ac8:  03 e0 00 08 jr	ra
[ 294] 0x900000001fc05acc:  00 00 00 00 nop
  295: 	END(_sr)
  296: 
  297: 
  298: /* _cause(rw, val) */
  299: LEAF(_cause)
  300: 	beq	a0,zero,1f
_cause:
[ 300] 0x900000001fc05ad0:  10 80 00 04 beq	a0,zero,0x900000001fc05ae4
[ 300] 0x900000001fc05ad4:  00 00 00 00 nop
  301: 	# write
  302: 	.set	noreorder
  303: 	DMTC0(a1,C0_CAUSE)
[ 303] 0x900000001fc05ad8:  40 a5 68 00 dmtc0	a1,cause
  304: 	.set	reorder
  305: 	j	ra
[ 305] 0x900000001fc05adc:  03 e0 00 08 jr	ra
[ 305] 0x900000001fc05ae0:  00 00 00 00 nop
  306: 1:	# read only
  307: 	.set	noreorder
  308: 	MFC0(v0,C0_CAUSE)
[ 308] 0x900000001fc05ae4:  40 02 68 00 mfc0	v0,cause
  309: 	.set	reorder
  310: 	j	ra
[ 310] 0x900000001fc05ae8:  03 e0 00 08 jr	ra
[ 310] 0x900000001fc05aec:  00 00 00 00 nop
  311: 	END(_cause)
  312: 
  313: 
  314: /* _epc(rw, val) */
  315: LEAF(_epc)
  316: 	beq	a0,zero,1f
_epc:
[ 316] 0x900000001fc05af0:  10 80 00 04 beq	a0,zero,0x900000001fc05b04
[ 316] 0x900000001fc05af4:  00 00 00 00 nop
  317: 	# write
  318: 	.set	noreorder
  319: 	DMTC0(a1,C0_EPC)
[ 319] 0x900000001fc05af8:  40 a5 70 00 dmtc0	a1,epc
  320: 	.set	reorder
  321: 	j	ra
[ 321] 0x900000001fc05afc:  03 e0 00 08 jr	ra
[ 321] 0x900000001fc05b00:  00 00 00 00 nop
  322: 1:	# read only
  323: 	.set	noreorder
  324: 	DMFC0(v0,C0_EPC)
[ 324] 0x900000001fc05b04:  40 22 70 00 dmfc0	v0,epc
  325: 	.set	reorder
  326: 	j	ra
[ 326] 0x900000001fc05b08:  03 e0 00 08 jr	ra
[ 326] 0x900000001fc05b0c:  00 00 00 00 nop
  327: 	END(_epc)
  328: 
  329: /* _badvaddr(rw, val) */
  330: LEAF(_badvaddr)
  331: 	beq	a0,zero,1f
_badvaddr:
[ 331] 0x900000001fc05b10:  10 80 00 04 beq	a0,zero,0x900000001fc05b24
[ 331] 0x900000001fc05b14:  00 00 00 00 nop
  332: 	# write
  333: 	.set	noreorder
  334: 	DMTC0(a1,C0_BADVADDR)
[ 334] 0x900000001fc05b18:  40 a5 40 00 dmtc0	a1,badvaddr
  335: 	.set	reorder
  336: 	j	ra
[ 336] 0x900000001fc05b1c:  03 e0 00 08 jr	ra
[ 336] 0x900000001fc05b20:  00 00 00 00 nop
  337: 1:	# read only
  338: 	.set	noreorder
  339: 	DMFC0(v0,C0_BADVADDR)
[ 339] 0x900000001fc05b24:  40 22 40 00 dmfc0	v0,badvaddr
  340: 	.set	reorder
  341: 	j	ra
[ 341] 0x900000001fc05b28:  03 e0 00 08 jr	ra
[ 341] 0x900000001fc05b2c:  00 00 00 00 nop
  342: 	END(_badvaddr)
  343: 
  344: /* _config(rw, val) */
  345: LEAF(_config)
  346: 	beq	a0,zero,1f
_config:
[ 346] 0x900000001fc05b30:  10 80 00 04 beq	a0,zero,0x900000001fc05b44
[ 346] 0x900000001fc05b34:  00 00 00 00 nop
  347: 	# write
  348: 	.set	noreorder
  349: 	DMTC0(a1,C0_CONFIG)
[ 349] 0x900000001fc05b38:  40 a5 80 00 dmtc0	a1,config
  350: 	.set	reorder
  351: 	j	ra
[ 351] 0x900000001fc05b3c:  03 e0 00 08 jr	ra
[ 351] 0x900000001fc05b40:  00 00 00 00 nop
  352: 1:	# read only
  353: 	.set	noreorder
  354: 	MFC0(v0,C0_CONFIG)
[ 354] 0x900000001fc05b44:  40 02 80 00 mfc0	v0,config
  355: 	.set	reorder
  356: 	j	ra
[ 356] 0x900000001fc05b48:  03 e0 00 08 jr	ra
[ 356] 0x900000001fc05b4c:  00 00 00 00 nop
  357: 	END(_config)
  358: 
  359: /* _count(rw, val) */
  360: LEAF(_count)
  361: 	beq	a0,zero,1f
_count:
[ 361] 0x900000001fc05b50:  10 80 00 04 beq	a0,zero,0x900000001fc05b64
[ 361] 0x900000001fc05b54:  00 00 00 00 nop
  362: 	# write
  363: 	.set	noreorder
  364: 	DMTC0(a1,C0_COUNT)
[ 364] 0x900000001fc05b58:  40 a5 48 00 dmtc0	a1,count
  365: 	.set	reorder
  366: 	j	ra
[ 366] 0x900000001fc05b5c:  03 e0 00 08 jr	ra
[ 366] 0x900000001fc05b60:  00 00 00 00 nop
  367: 1:	# read only
  368: 	.set	noreorder
  369: 	MFC0(v0,C0_COUNT)
[ 369] 0x900000001fc05b64:  40 02 48 00 mfc0	v0,count
  370: 	.set	reorder
  371: 	j	ra
[ 371] 0x900000001fc05b68:  03 e0 00 08 jr	ra
[ 371] 0x900000001fc05b6c:  00 00 00 00 nop
  372: 	END(_count)
  373: 
  374: /*
  375:  * Function:	clearIP25State
  376:  * Purpose:	Clears the board local error states.
  377:  * Parameters:	None
  378:  * Returns:	Nothing
  379:  */
  380: LEAF(clearIP25State)
  381: 	.set	noreorder
  382: 	dli	a0, EV_CERTOIP
clearIP25State:
[ 382] 0x900000001fc05b70:  3c 04 90 00 lui	a0,0x9000
[ 382] 0x900000001fc05b74:  00 04 24 38 dsll	a0,a0,16
[ 382] 0x900000001fc05b78:  34 84 18 00 ori	a0,a0,0x1800
[ 382] 0x900000001fc05b7c:  00 04 24 38 dsll	a0,a0,16
[ 382] 0x900000001fc05b80:  34 84 09 08 ori	a0,a0,0x908
  383: 	dli	a1,-1
[ 383] 0x900000001fc05b84:  24 05 ff ff li	a1,-1
  384: 	sd	a1, 0(a0)
[ 384] 0x900000001fc05b88:  fc 85 00 00 sd	a1,0(a0)
  385: 	dli	a0, EV_IP0
[ 385] 0x900000001fc05b8c:  3c 04 90 00 lui	a0,0x9000
[ 385] 0x900000001fc05b90:  00 04 24 38 dsll	a0,a0,16
[ 385] 0x900000001fc05b94:  34 84 18 00 ori	a0,a0,0x1800
[ 385] 0x900000001fc05b98:  00 04 24 38 dsll	a0,a0,16
[ 385] 0x900000001fc05b9c:  34 84 08 00 ori	a0,a0,0x800
  386: 	sd	zero, 0(a0)
[ 386] 0x900000001fc05ba0:  fc 80 00 00 sd	zero,0(a0)
  387: 	dli	a0, EV_IP1
[ 387] 0x900000001fc05ba4:  3c 04 90 00 lui	a0,0x9000
[ 387] 0x900000001fc05ba8:  00 04 24 38 dsll	a0,a0,16
[ 387] 0x900000001fc05bac:  34 84 18 00 ori	a0,a0,0x1800
[ 387] 0x900000001fc05bb0:  00 04 24 38 dsll	a0,a0,16
[ 387] 0x900000001fc05bb4:  34 84 08 08 ori	a0,a0,0x808
  388: 	sd	zero, 0(a0)
[ 388] 0x900000001fc05bb8:  fc 80 00 00 sd	zero,0(a0)
  389: 	j	ra
[ 389] 0x900000001fc05bbc:  03 e0 00 08 jr	ra
  390: 	nop
[ 390] 0x900000001fc05bc0:  00 00 00 00 nop
  391: 	END(clearIP25State)
  392: 
  393: /* This macro is a result of endian confusion...  I left it here in case
  394: 	this doesn't work the way I think it does.  */
  395: #define STORE_HALVES(_reg, _offset, _indirect)	\
  396: 	sd	_reg, _offset(_indirect);
  397: 
  398: #define STORE_FHALVES(_reg, _offset, _indirect)	\
  399: 	sdc1	_reg, _offset(_indirect);
  400: 
  401: LEAF(store_gprs)
  402: 	.set noat
  403: 	.set noreorder
  404: 	sd	zero, R0_OFF(a0)			/* zero */
store_gprs:
[ 404] 0x900000001fc05bc4:  fc 80 00 00 sd	zero,0(a0)
  405: 	STORE_FHALVES(AT_FP, R1_OFF, a0)	/* at */
[ 405] 0x900000001fc05bc8:  f4 86 00 08 sdc1	$f6,8(a0)
  406: 	STORE_FHALVES(V0_FP, R2_OFF, a0)	/* v0 */
[ 406] 0x900000001fc05bcc:  f4 8a 00 10 sdc1	$f10,16(a0)
  407: 	STORE_FHALVES(V1_FP, R3_OFF, a0)	/* v1 */
[ 407] 0x900000001fc05bd0:  f4 8b 00 18 sdc1	$f11,24(a0)
  408: 	STORE_FHALVES(A0_FP, R4_OFF, a0)	/* a0 */
[ 408] 0x900000001fc05bd4:  f4 87 00 20 sdc1	$f7,32(a0)
  409: 	STORE_FHALVES(A1_FP, R5_OFF, a0)	/* a1 */
[ 409] 0x900000001fc05bd8:  f4 88 00 28 sdc1	$f8,40(a0)
  410: 	STORE_FHALVES(A2_FP, R6_OFF, a0)	/* a2 */
[ 410] 0x900000001fc05bdc:  f4 89 00 30 sdc1	$f9,48(a0)
  411: 	STORE_HALVES(a3, R7_OFF, a0)		/* a3 */
[ 411] 0x900000001fc05be0:  fc 87 00 38 sd	a3,56(a0)
  412: 	STORE_FHALVES(T0_FP, R8_OFF, a0)	/* t0 */
[ 412] 0x900000001fc05be4:  f4 8c 00 40 sdc1	$f12,64(a0)
  413: 	STORE_FHALVES(T1_FP, R9_OFF, a0)	/* t1 */
[ 413] 0x900000001fc05be8:  f4 8d 00 48 sdc1	$f13,72(a0)
  414: 	STORE_FHALVES(T2_FP, R10_OFF, a0)	/* t2 */
[ 414] 0x900000001fc05bec:  f4 8e 00 50 sdc1	$f14,80(a0)
  415: 	STORE_FHALVES(T3_FP, R11_OFF, a0)	/* t3 */
[ 415] 0x900000001fc05bf0:  f4 8f 00 58 sdc1	$f15,88(a0)
  416: 	STORE_FHALVES(T4_FP, R12_OFF, a0)	/* ta0 */
[ 416] 0x900000001fc05bf4:  f4 90 00 60 sdc1	$f16,96(a0)
  417: 	STORE_FHALVES(T5_FP, R13_OFF, a0)	/* ta1 */
[ 417] 0x900000001fc05bf8:  f4 91 00 68 sdc1	$f17,104(a0)
  418: 	STORE_FHALVES(T6_FP, R14_OFF, a0)	/* ta2 */
[ 418] 0x900000001fc05bfc:  f4 92 00 70 sdc1	$f18,112(a0)
  419: 	STORE_FHALVES(T7_FP, R15_OFF, a0)	/* ta3 */
[ 419] 0x900000001fc05c00:  f4 93 00 78 sdc1	$f19,120(a0)
  420: 	STORE_FHALVES(S0_FP, R16_OFF, a0)	/* s0 */
[ 420] 0x900000001fc05c04:  f4 94 00 80 sdc1	$f20,128(a0)
  421: 	STORE_FHALVES(S1_FP, R17_OFF, a0)	/* s1 */
[ 421] 0x900000001fc05c08:  f4 95 00 88 sdc1	$f21,136(a0)
  422: 	STORE_FHALVES(S2_FP, R18_OFF, a0)	/* s2 */
[ 422] 0x900000001fc05c0c:  f4 96 00 90 sdc1	$f22,144(a0)
  423: 	STORE_FHALVES(S3_FP, R19_OFF, a0)	/* s3 */
[ 423] 0x900000001fc05c10:  f4 97 00 98 sdc1	$f23,152(a0)
  424: 	STORE_FHALVES(S4_FP, R20_OFF, a0)	/* s4 */
[ 424] 0x900000001fc05c14:  f4 98 00 a0 sdc1	$f24,160(a0)
  425: 	STORE_FHALVES(S5_FP, R21_OFF, a0)	/* s5 */
[ 425] 0x900000001fc05c18:  f4 99 00 a8 sdc1	$f25,168(a0)
  426: 	STORE_FHALVES(S6_FP, R22_OFF, a0)	/* s6 */
[ 426] 0x900000001fc05c1c:  f4 9a 00 b0 sdc1	$f26,176(a0)
  427: 	STORE_HALVES(s7, R23_OFF, a0)		/* s7 */
[ 427] 0x900000001fc05c20:  fc 97 00 b8 sd	s7,184(a0)
  428: 	STORE_FHALVES(T8_FP, R24_OFF, a0)	/* t8 */
[ 428] 0x900000001fc05c24:  f4 9b 00 c0 sdc1	$f27,192(a0)
  429: 	STORE_FHALVES(T9_FP, R25_OFF, a0)	/* t9 */
[ 429] 0x900000001fc05c28:  f4 9c 00 c8 sdc1	$f28,200(a0)
  430: 	STORE_HALVES(k0, R26_OFF, a0)		/* k0 */
[ 430] 0x900000001fc05c2c:  fc 9a 00 d0 sd	k0,208(a0)
  431: 	STORE_HALVES(k1, R27_OFF, a0)		/* k1 */
[ 431] 0x900000001fc05c30:  fc 9b 00 d8 sd	k1,216(a0)
  432: 	STORE_HALVES(gp, R28_OFF, a0)		/* gp */
[ 432] 0x900000001fc05c34:  fc 9c 00 e0 sd	gp,224(a0)
  433: 	STORE_FHALVES(SP_FP, R29_OFF, a0)	/* sp */
[ 433] 0x900000001fc05c38:  f4 9d 00 e8 sdc1	$f29,232(a0)
  434: 	STORE_HALVES(fp, R30_OFF, a0)		/* fp */
[ 434] 0x900000001fc05c3c:  fc 9e 00 f0 sd	s8,240(a0)
  435: 	STORE_FHALVES(RA_FP, R31_OFF, a0)	/* ra */
[ 435] 0x900000001fc05c40:  f4 9f 00 f8 sdc1	$f31,248(a0)
  436: 
  437: 	MFC0($at, C0_SR)
[ 437] 0x900000001fc05c44:  40 01 60 00 mfc0	at,sr
  438: 	sd	$at, SR_OFF(a0)
[ 438] 0x900000001fc05c48:  fc 81 01 00 sd	at,256(a0)
  439: 	MFC0($at, C0_CAUSE)
[ 439] 0x900000001fc05c4c:  40 01 68 00 mfc0	at,cause
  440: 	sd	$at, CAUSE_OFF(a0)
[ 440] 0x900000001fc05c50:  fc 81 01 08 sd	at,264(a0)
  441: 	DMFC0($at, C0_BADVADDR)
[ 441] 0x900000001fc05c54:  40 21 40 00 dmfc0	at,badvaddr
  442: 	STORE_HALVES($at, BADVA_OFF, a0)
[ 442] 0x900000001fc05c58:  fc 81 01 18 sd	at,280(a0)
  443: 	DMFC0($at, C0_EPC)
[ 443] 0x900000001fc05c5c:  40 21 70 00 dmfc0	at,epc
  444: 	STORE_HALVES($at, EPC_OFF, a0)
[ 444] 0x900000001fc05c60:  fc 81 01 10 sd	at,272(a0)
  445: 	j	ra
[ 445] 0x900000001fc05c64:  03 e0 00 08 jr	ra
  446: 	nop
[ 446] 0x900000001fc05c68:  00 00 00 00 nop
  447: 
  448: 	.set reorder
  449: 	.set at
  450: 	END(store_gprs)
  451: 
  452: LEAF(occupied_slots)
  453: 	.set noreorder
  454: 	dli	t0, EV_SYSCONFIG
occupied_slots:
[ 454] 0x900000001fc05c6c:  3c 0c 90 00 lui	t0,0x9000
[ 454] 0x900000001fc05c70:  00 0c 64 38 dsll	t0,t0,16
[ 454] 0x900000001fc05c74:  35 8c 18 00 ori	t0,t0,0x1800
[ 454] 0x900000001fc05c78:  00 0c 64 38 dsll	t0,t0,16
[ 454] 0x900000001fc05c7c:  35 8c 02 00 ori	t0,t0,0x200
  455: 	ld	t1, 0(t0)
[ 455] 0x900000001fc05c80:  dd 8d 00 00 ld	t1,0(t0)
  456: 	nop
[ 456] 0x900000001fc05c84:  00 00 00 00 nop
  457: 	j	ra
[ 457] 0x900000001fc05c88:  03 e0 00 08 jr	ra
  458: 	and	v0, t1, 0Xffff
[ 458] 0x900000001fc05c8c:  31 a2 ff ff andi	v0,t1,0xffff
  459: 	.set reorder
  460: 	END (occupied_slots)
  461: 
  462: LEAF(cpu_slots)
  463: 	.set noreorder
  464: 	dli	t0, EV_SYSCONFIG
cpu_slots:
[ 464] 0x900000001fc05c90:  3c 0c 90 00 lui	t0,0x9000
[ 464] 0x900000001fc05c94:  00 0c 64 38 dsll	t0,t0,16
[ 464] 0x900000001fc05c98:  35 8c 18 00 ori	t0,t0,0x1800
[ 464] 0x900000001fc05c9c:  00 0c 64 38 dsll	t0,t0,16
[ 464] 0x900000001fc05ca0:  35 8c 02 00 ori	t0,t0,0x200
  465: 	ld	t1, 0(t0)
[ 465] 0x900000001fc05ca4:  dd 8d 00 00 ld	t1,0(t0)
  466: 	nop
[ 466] 0x900000001fc05ca8:  00 00 00 00 nop
  467: 	dsrl	t1, t1, 16
[ 467] 0x900000001fc05cac:  00 0d 6c 3a dsrl	t1,t1,16
  468: 	j	ra
[ 468] 0x900000001fc05cb0:  03 e0 00 08 jr	ra
  469: 	and	v0, t1, 0Xffff
[ 469] 0x900000001fc05cb4:  31 a2 ff ff andi	v0,t1,0xffff
  470: 	.set reorder
  471: 	END (cpu_slots)
  472: 
  473: LEAF(memory_slots)
  474: 	.set noreorder
  475: 	dli	t0, EV_SYSCONFIG
memory_slots:
[ 475] 0x900000001fc05cb8:  3c 0c 90 00 lui	t0,0x9000
[ 475] 0x900000001fc05cbc:  00 0c 64 38 dsll	t0,t0,16
[ 475] 0x900000001fc05cc0:  35 8c 18 00 ori	t0,t0,0x1800
[ 475] 0x900000001fc05cc4:  00 0c 64 38 dsll	t0,t0,16
[ 475] 0x900000001fc05cc8:  35 8c 02 00 ori	t0,t0,0x200
  476: 	ld	t1, 0(t0)
[ 476] 0x900000001fc05ccc:  dd 8d 00 00 ld	t1,0(t0)
  477: 	nop
[ 477] 0x900000001fc05cd0:  00 00 00 00 nop
  478: 	dsrl	t1, t1, 32
[ 478] 0x900000001fc05cd4:  00 0d 68 3e dsrl32	t1,t1,0
  479: 	j	ra
[ 479] 0x900000001fc05cd8:  03 e0 00 08 jr	ra
  480: 	and	v0, t1, 0Xffff
[ 480] 0x900000001fc05cdc:  31 a2 ff ff andi	v0,t1,0xffff
  481: 	.set reorder
  482: 	END (memory_slots)
  483: 
  484: /*
  485:  * a0 = index of tlb entry to get
  486:  */
  487: LEAF(get_enhi)
  488: 	.set	noreorder
  489: 	MTC0(a0, C0_INX)
get_enhi:
[ 489] 0x900000001fc05ce0:  40 84 00 00 mtc0	a0,index
  490: 	tlbr
[ 490] 0x900000001fc05ce4:  42 00 00 01 c0	tlbr
  491: 	DMFC0(v0,C0_TLBHI)
[ 491] 0x900000001fc05ce8:  40 22 50 00 dmfc0	v0,tlbhi
  492: 	j	ra
[ 492] 0x900000001fc05cec:  03 e0 00 08 jr	ra
  493: 	nop				# BDSLOT
[ 493] 0x900000001fc05cf0:  00 00 00 00 nop
  494: 	.set	reorder
  495: 	END(get_enhi)
  496: 
  497: /*
  498:  * a0 = index of tlb entry to get
  499:  * a1 = 0 TLBLO0
  500:  *    = 1 TLBLO1
  501:  */
  502: LEAF(get_enlo)
  503: 	.set	noreorder
  504: 	MTC0(a0, C0_INX)
get_enlo:
[ 504] 0x900000001fc05cf4:  40 84 00 00 mtc0	a0,index
  505: 	tlbr
[ 505] 0x900000001fc05cf8:  42 00 00 01 c0	tlbr
  506: 	bnez	a1,1f
[ 506] 0x900000001fc05cfc:  14 a0 00 04 bne	a1,zero,0x900000001fc05d10
  507: 	nop				# BDSLOT
[ 507] 0x900000001fc05d00:  00 00 00 00 nop
  508: 	MFC0(v0, C0_TLBLO_0)
[ 508] 0x900000001fc05d04:  40 02 10 00 mfc0	v0,tlblo
  509: 	j	ra
[ 509] 0x900000001fc05d08:  03 e0 00 08 jr	ra
  510: 	nop				# BDSLOT
[ 510] 0x900000001fc05d0c:  00 00 00 00 nop
  511: 1:	
  512: 	MFC0(v0, C0_TLBLO_1)
[ 512] 0x900000001fc05d10:  40 02 18 00 mfc0	v0,tlblo1
  513: 	j	ra
[ 513] 0x900000001fc05d14:  03 e0 00 08 jr	ra
  514: 	nop				# BDSLOT	
[ 514] 0x900000001fc05d18:  00 00 00 00 nop
  515: 	.set	reorder
  516: 	END(get_enlo)
  517: 
  518: 
  519: /* 
  520:  * Function:	flushTlb
  521:  * Purpose:	Invalidate all TLB entries
  522:  * Paremters:	None
  523:  * Returns:	Nothing
  524:  * Notes:	Uses a0, v0
  525:  */
  526: LEAF(flushTlb)
  527: 	.set    noreorder
  528:         DMTC0(zero, C0_TLBLO_0)		# clear all bits in EntryLo 0
flushTlb:
[ 528] 0x900000001fc05d1c:  40 a0 10 00 dmtc0	zero,tlblo
  529:         DMTC0(zero, C0_TLBLO_1)		# clear all bits in EntryLo 1
[ 529] 0x900000001fc05d20:  40 a0 18 00 dmtc0	zero,tlblo1
  530:         li      v0, NTLBENTRIES - 1     # v0 is set counter
[ 530] 0x900000001fc05d24:  24 02 00 3f li	v0,63
  531:         dli     a0, 0xC000000000000000  # Kernel Global region
[ 531] 0x900000001fc05d28:  24 04 00 03 li	a0,3
[ 531] 0x900000001fc05d2c:  00 04 27 bc dsll32	a0,a0,30
  532:         DMTC0(a0, C0_TLBHI)
[ 532] 0x900000001fc05d30:  40 a4 50 00 dmtc0	a0,tlbhi
  533: 
  534: 1:		
  535:         DMTC0(v0, C0_INX)		# specify which TLB index
[ 535] 0x900000001fc05d34:  40 a2 00 00 dmtc0	v0,index
  536:         tlbwi
[ 536] 0x900000001fc05d38:  42 00 00 02 c0	tlbwi
  537:         bgtz	v0, 1b			# are we done with all indeces?
[ 537] 0x900000001fc05d3c:  1c 40 ff fd bgtz	v0,0x900000001fc05d34
  538:         addi    v0, -1                  # BDSLOT decrement index counter
[ 538] 0x900000001fc05d40:  20 42 ff ff addi	v0,v0,-1
  539: 
  540:         j       ra
[ 540] 0x900000001fc05d44:  03 e0 00 08 jr	ra
  541:         nop
[ 541] 0x900000001fc05d48:  00 00 00 00 nop
  542:         .set    reorder
  543: END(flushTlb)
  544: 
  545: LEAF(readCP0)
  546: /*
  547:  * Function:	readCP0
  548:  * Purpose:	Read a CP0 register.
  549:  * Parameters:	a0 - CP0 register to read.
  550:  * Returns:	v0 - value read
  551:  */
  552:         .set	noreorder
  553: 	dla	v1,readCP0_table
readCP0:
[ 553] 0x900000001fc05d4c:  3c 03 90 00 lui	v1,0x9000
[ 553] 0x900000001fc05d50:  64 63 00 00 daddiu	v1,v1,0
[ 553] 0x900000001fc05d54:  00 03 1c 38 dsll	v1,v1,16
[ 553] 0x900000001fc05d58:  64 63 1f c0 daddiu	v1,v1,8128
[ 553] 0x900000001fc05d5c:  00 03 1c 38 dsll	v1,v1,16
[ 553] 0x900000001fc05d60:  64 63 5d 74 daddiu	v1,v1,23924
  554: 	dsll	a0,4
[ 554] 0x900000001fc05d64:  00 04 21 38 dsll	a0,a0,4
  555: 	daddu	a0,v1
[ 555] 0x900000001fc05d68:  00 83 20 2d daddu	a0,a0,v1
  556: 	j	a0
[ 556] 0x900000001fc05d6c:  00 80 00 08 jr	a0
  557: 	nop
[ 557] 0x900000001fc05d70:  00 00 00 00 nop
  558: 
  559: #define	READCP0(cp0Reg)		DMFC0(v0, $cp0Reg); j ra; nop; nop
  560: 
  561: readCP0_table:
  562: 	READCP0(0)
[ 562] 0x900000001fc05d74:  40 22 00 00 dmfc0	v0,index
[ 562] 0x900000001fc05d78:  03 e0 00 08 jr	ra
[ 562] 0x900000001fc05d7c:  00 00 00 00 nop
[ 562] 0x900000001fc05d80:  00 00 00 00 nop
  563: 	READCP0(1)
[ 563] 0x900000001fc05d84:  40 22 08 00 dmfc0	v0,random
[ 563] 0x900000001fc05d88:  03 e0 00 08 jr	ra
[ 563] 0x900000001fc05d8c:  00 00 00 00 nop
[ 563] 0x900000001fc05d90:  00 00 00 00 nop
  564: 	READCP0(2)
[ 564] 0x900000001fc05d94:  40 22 10 00 dmfc0	v0,tlblo
[ 564] 0x900000001fc05d98:  03 e0 00 08 jr	ra
[ 564] 0x900000001fc05d9c:  00 00 00 00 nop
[ 564] 0x900000001fc05da0:  00 00 00 00 nop
  565: 	READCP0(3)
[ 565] 0x900000001fc05da4:  40 22 18 00 dmfc0	v0,tlblo1
[ 565] 0x900000001fc05da8:  03 e0 00 08 jr	ra
[ 565] 0x900000001fc05dac:  00 00 00 00 nop
[ 565] 0x900000001fc05db0:  00 00 00 00 nop
  566: 	READCP0(4)
[ 566] 0x900000001fc05db4:  40 22 20 00 dmfc0	v0,context
[ 566] 0x900000001fc05db8:  03 e0 00 08 jr	ra
[ 566] 0x900000001fc05dbc:  00 00 00 00 nop
[ 566] 0x900000001fc05dc0:  00 00 00 00 nop
  567: 	READCP0(5)
[ 567] 0x900000001fc05dc4:  40 22 28 00 dmfc0	v0,pagemask
[ 567] 0x900000001fc05dc8:  03 e0 00 08 jr	ra
[ 567] 0x900000001fc05dcc:  00 00 00 00 nop
[ 567] 0x900000001fc05dd0:  00 00 00 00 nop
  568: 	READCP0(6)
[ 568] 0x900000001fc05dd4:  40 22 30 00 dmfc0	v0,wired
[ 568] 0x900000001fc05dd8:  03 e0 00 08 jr	ra
[ 568] 0x900000001fc05ddc:  00 00 00 00 nop
[ 568] 0x900000001fc05de0:  00 00 00 00 nop
  569: 	READCP0(7)
[ 569] 0x900000001fc05de4:  40 22 38 00 dmfc0	v0,c0r7
[ 569] 0x900000001fc05de8:  03 e0 00 08 jr	ra
[ 569] 0x900000001fc05dec:  00 00 00 00 nop
[ 569] 0x900000001fc05df0:  00 00 00 00 nop
  570: 	READCP0(8)
[ 570] 0x900000001fc05df4:  40 22 40 00 dmfc0	v0,badvaddr
[ 570] 0x900000001fc05df8:  03 e0 00 08 jr	ra
[ 570] 0x900000001fc05dfc:  00 00 00 00 nop
[ 570] 0x900000001fc05e00:  00 00 00 00 nop
  571: 	READCP0(9)
[ 571] 0x900000001fc05e04:  40 22 48 00 dmfc0	v0,count
[ 571] 0x900000001fc05e08:  03 e0 00 08 jr	ra
[ 571] 0x900000001fc05e0c:  00 00 00 00 nop
[ 571] 0x900000001fc05e10:  00 00 00 00 nop
  572: 	READCP0(10)
[ 572] 0x900000001fc05e14:  40 22 50 00 dmfc0	v0,tlbhi
[ 572] 0x900000001fc05e18:  03 e0 00 08 jr	ra
[ 572] 0x900000001fc05e1c:  00 00 00 00 nop
[ 572] 0x900000001fc05e20:  00 00 00 00 nop
  573: 	READCP0(11)
[ 573] 0x900000001fc05e24:  40 22 58 00 dmfc0	v0,compare
[ 573] 0x900000001fc05e28:  03 e0 00 08 jr	ra
[ 573] 0x900000001fc05e2c:  00 00 00 00 nop
[ 573] 0x900000001fc05e30:  00 00 00 00 nop
  574: 	READCP0(12)
[ 574] 0x900000001fc05e34:  40 22 60 00 dmfc0	v0,sr
[ 574] 0x900000001fc05e38:  03 e0 00 08 jr	ra
[ 574] 0x900000001fc05e3c:  00 00 00 00 nop
[ 574] 0x900000001fc05e40:  00 00 00 00 nop
  575: 	READCP0(13)
[ 575] 0x900000001fc05e44:  40 22 68 00 dmfc0	v0,cause
[ 575] 0x900000001fc05e48:  03 e0 00 08 jr	ra
[ 575] 0x900000001fc05e4c:  00 00 00 00 nop
[ 575] 0x900000001fc05e50:  00 00 00 00 nop
  576: 	READCP0(14)
[ 576] 0x900000001fc05e54:  40 22 70 00 dmfc0	v0,epc
[ 576] 0x900000001fc05e58:  03 e0 00 08 jr	ra
[ 576] 0x900000001fc05e5c:  00 00 00 00 nop
[ 576] 0x900000001fc05e60:  00 00 00 00 nop
  577: 	READCP0(15)
[ 577] 0x900000001fc05e64:  40 22 78 00 dmfc0	v0,prid
[ 577] 0x900000001fc05e68:  03 e0 00 08 jr	ra
[ 577] 0x900000001fc05e6c:  00 00 00 00 nop
[ 577] 0x900000001fc05e70:  00 00 00 00 nop
  578: 	READCP0(16)
[ 578] 0x900000001fc05e74:  40 22 80 00 dmfc0	v0,config
[ 578] 0x900000001fc05e78:  03 e0 00 08 jr	ra
[ 578] 0x900000001fc05e7c:  00 00 00 00 nop
[ 578] 0x900000001fc05e80:  00 00 00 00 nop
  579: 	READCP0(17)
[ 579] 0x900000001fc05e84:  40 22 88 00 dmfc0	v0,lladdr
[ 579] 0x900000001fc05e88:  03 e0 00 08 jr	ra
[ 579] 0x900000001fc05e8c:  00 00 00 00 nop
[ 579] 0x900000001fc05e90:  00 00 00 00 nop
  580: 	READCP0(18)
[ 580] 0x900000001fc05e94:  40 22 90 00 dmfc0	v0,watchlo
[ 580] 0x900000001fc05e98:  03 e0 00 08 jr	ra
[ 580] 0x900000001fc05e9c:  00 00 00 00 nop
[ 580] 0x900000001fc05ea0:  00 00 00 00 nop
  581: 	READCP0(19)
[ 581] 0x900000001fc05ea4:  40 22 98 00 dmfc0	v0,watchhi
[ 581] 0x900000001fc05ea8:  03 e0 00 08 jr	ra
[ 581] 0x900000001fc05eac:  00 00 00 00 nop
[ 581] 0x900000001fc05eb0:  00 00 00 00 nop
  582: 	READCP0(20)
[ 582] 0x900000001fc05eb4:  40 22 a0 00 dmfc0	v0,c0r20
[ 582] 0x900000001fc05eb8:  03 e0 00 08 jr	ra
[ 582] 0x900000001fc05ebc:  00 00 00 00 nop
[ 582] 0x900000001fc05ec0:  00 00 00 00 nop
  583: 	READCP0(21)
[ 583] 0x900000001fc05ec4:  40 22 a8 00 dmfc0	v0,c0r21
[ 583] 0x900000001fc05ec8:  03 e0 00 08 jr	ra
[ 583] 0x900000001fc05ecc:  00 00 00 00 nop
[ 583] 0x900000001fc05ed0:  00 00 00 00 nop
  584: 	READCP0(22)
[ 584] 0x900000001fc05ed4:  40 22 b0 00 dmfc0	v0,c0r22
[ 584] 0x900000001fc05ed8:  03 e0 00 08 jr	ra
[ 584] 0x900000001fc05edc:  00 00 00 00 nop
[ 584] 0x900000001fc05ee0:  00 00 00 00 nop
  585: 	READCP0(23)
[ 585] 0x900000001fc05ee4:  40 22 b8 00 dmfc0	v0,c0r23
[ 585] 0x900000001fc05ee8:  03 e0 00 08 jr	ra
[ 585] 0x900000001fc05eec:  00 00 00 00 nop
[ 585] 0x900000001fc05ef0:  00 00 00 00 nop
  586: 	READCP0(24)
[ 586] 0x900000001fc05ef4:  40 22 c0 00 dmfc0	v0,c0r24
[ 586] 0x900000001fc05ef8:  03 e0 00 08 jr	ra
[ 586] 0x900000001fc05efc:  00 00 00 00 nop
[ 586] 0x900000001fc05f00:  00 00 00 00 nop
  587: 	READCP0(25)
[ 587] 0x900000001fc05f04:  40 22 c8 00 dmfc0	v0,c0r25
[ 587] 0x900000001fc05f08:  03 e0 00 08 jr	ra
[ 587] 0x900000001fc05f0c:  00 00 00 00 nop
[ 587] 0x900000001fc05f10:  00 00 00 00 nop
  588: 	READCP0(26)
[ 588] 0x900000001fc05f14:  40 22 d0 00 dmfc0	v0,ecc
[ 588] 0x900000001fc05f18:  03 e0 00 08 jr	ra
[ 588] 0x900000001fc05f1c:  00 00 00 00 nop
[ 588] 0x900000001fc05f20:  00 00 00 00 nop
  589: 	READCP0(27)
[ 589] 0x900000001fc05f24:  40 22 d8 00 dmfc0	v0,cacheerr
[ 589] 0x900000001fc05f28:  03 e0 00 08 jr	ra
[ 589] 0x900000001fc05f2c:  00 00 00 00 nop
[ 589] 0x900000001fc05f30:  00 00 00 00 nop
  590: 	READCP0(28)
[ 590] 0x900000001fc05f34:  40 22 e0 00 dmfc0	v0,taglo
[ 590] 0x900000001fc05f38:  03 e0 00 08 jr	ra
[ 590] 0x900000001fc05f3c:  00 00 00 00 nop
[ 590] 0x900000001fc05f40:  00 00 00 00 nop
  591: 	READCP0(29)
[ 591] 0x900000001fc05f44:  40 22 e8 00 dmfc0	v0,taghi
[ 591] 0x900000001fc05f48:  03 e0 00 08 jr	ra
[ 591] 0x900000001fc05f4c:  00 00 00 00 nop
[ 591] 0x900000001fc05f50:  00 00 00 00 nop
  592: 	READCP0(30)
[ 592] 0x900000001fc05f54:  40 22 f0 00 dmfc0	v0,errorepc
[ 592] 0x900000001fc05f58:  03 e0 00 08 jr	ra
[ 592] 0x900000001fc05f5c:  00 00 00 00 nop
[ 592] 0x900000001fc05f60:  00 00 00 00 nop
  593: 	
  594:         .set	reorder
  595:         END(readCP0)
  596: 
  597: LEAF(writeCP0)
  598: /*
  599:  * Function:	writeCP0
  600:  * Purpose:	Write a  CP0 register.
  601:  * Parameters:	a0 - CP0 register to write.
  602:  *		a1 - value to write.
  603:  * Returns:	v0 - value read
  604:  */
  605:         .set	noreorder
  606: 	dla	v1,writeCP0_table
writeCP0:
[ 606] 0x900000001fc05f64:  3c 03 90 00 lui	v1,0x9000
[ 606] 0x900000001fc05f68:  64 63 00 00 daddiu	v1,v1,0
[ 606] 0x900000001fc05f6c:  00 03 1c 38 dsll	v1,v1,16
[ 606] 0x900000001fc05f70:  64 63 1f c0 daddiu	v1,v1,8128
[ 606] 0x900000001fc05f74:  00 03 1c 38 dsll	v1,v1,16
[ 606] 0x900000001fc05f78:  64 63 5f 8c daddiu	v1,v1,24460
  607: 	dsll	a0,4
[ 607] 0x900000001fc05f7c:  00 04 21 38 dsll	a0,a0,4
  608: 	daddu	a0,v1
[ 608] 0x900000001fc05f80:  00 83 20 2d daddu	a0,a0,v1
  609: 	j	a0
[ 609] 0x900000001fc05f84:  00 80 00 08 jr	a0
  610: 	nop
[ 610] 0x900000001fc05f88:  00 00 00 00 nop
  611: 
  612: #define	WRITECP0(cp0Reg)	DMTC0(a1, $cp0Reg); j ra; nop; nop
  613: 
  614: writeCP0_table:
  615: 	WRITECP0(0)
[ 615] 0x900000001fc05f8c:  40 a5 00 00 dmtc0	a1,index
[ 615] 0x900000001fc05f90:  03 e0 00 08 jr	ra
[ 615] 0x900000001fc05f94:  00 00 00 00 nop
[ 615] 0x900000001fc05f98:  00 00 00 00 nop
  616: 	WRITECP0(1)
[ 616] 0x900000001fc05f9c:  40 a5 08 00 dmtc0	a1,random
[ 616] 0x900000001fc05fa0:  03 e0 00 08 jr	ra
[ 616] 0x900000001fc05fa4:  00 00 00 00 nop
[ 616] 0x900000001fc05fa8:  00 00 00 00 nop
  617: 	WRITECP0(2)
[ 617] 0x900000001fc05fac:  40 a5 10 00 dmtc0	a1,tlblo
[ 617] 0x900000001fc05fb0:  03 e0 00 08 jr	ra
[ 617] 0x900000001fc05fb4:  00 00 00 00 nop
[ 617] 0x900000001fc05fb8:  00 00 00 00 nop
  618: 	WRITECP0(3)
[ 618] 0x900000001fc05fbc:  40 a5 18 00 dmtc0	a1,tlblo1
[ 618] 0x900000001fc05fc0:  03 e0 00 08 jr	ra
[ 618] 0x900000001fc05fc4:  00 00 00 00 nop
[ 618] 0x900000001fc05fc8:  00 00 00 00 nop
  619: 	WRITECP0(4)
[ 619] 0x900000001fc05fcc:  40 a5 20 00 dmtc0	a1,context
[ 619] 0x900000001fc05fd0:  03 e0 00 08 jr	ra
[ 619] 0x900000001fc05fd4:  00 00 00 00 nop
[ 619] 0x900000001fc05fd8:  00 00 00 00 nop
  620: 	WRITECP0(5)
[ 620] 0x900000001fc05fdc:  40 a5 28 00 dmtc0	a1,pagemask
[ 620] 0x900000001fc05fe0:  03 e0 00 08 jr	ra
[ 620] 0x900000001fc05fe4:  00 00 00 00 nop
[ 620] 0x900000001fc05fe8:  00 00 00 00 nop
  621: 	WRITECP0(6)
[ 621] 0x900000001fc05fec:  40 a5 30 00 dmtc0	a1,wired
[ 621] 0x900000001fc05ff0:  03 e0 00 08 jr	ra
[ 621] 0x900000001fc05ff4:  00 00 00 00 nop
[ 621] 0x900000001fc05ff8:  00 00 00 00 nop
  622: 	WRITECP0(7)
[ 622] 0x900000001fc05ffc:  40 a5 38 00 dmtc0	a1,c0r7
[ 622] 0x900000001fc06000:  03 e0 00 08 jr	ra
[ 622] 0x900000001fc06004:  00 00 00 00 nop
[ 622] 0x900000001fc06008:  00 00 00 00 nop
  623: 	WRITECP0(8)
[ 623] 0x900000001fc0600c:  40 a5 40 00 dmtc0	a1,badvaddr
[ 623] 0x900000001fc06010:  03 e0 00 08 jr	ra
[ 623] 0x900000001fc06014:  00 00 00 00 nop
[ 623] 0x900000001fc06018:  00 00 00 00 nop
  624: 	WRITECP0(9)
[ 624] 0x900000001fc0601c:  40 a5 48 00 dmtc0	a1,count
[ 624] 0x900000001fc06020:  03 e0 00 08 jr	ra
[ 624] 0x900000001fc06024:  00 00 00 00 nop
[ 624] 0x900000001fc06028:  00 00 00 00 nop
  625: 	WRITECP0(10)
[ 625] 0x900000001fc0602c:  40 a5 50 00 dmtc0	a1,tlbhi
[ 625] 0x900000001fc06030:  03 e0 00 08 jr	ra
[ 625] 0x900000001fc06034:  00 00 00 00 nop
[ 625] 0x900000001fc06038:  00 00 00 00 nop
  626: 	WRITECP0(11)
[ 626] 0x900000001fc0603c:  40 a5 58 00 dmtc0	a1,compare
[ 626] 0x900000001fc06040:  03 e0 00 08 jr	ra
[ 626] 0x900000001fc06044:  00 00 00 00 nop
[ 626] 0x900000001fc06048:  00 00 00 00 nop
  627: 	WRITECP0(12)
[ 627] 0x900000001fc0604c:  40 a5 60 00 dmtc0	a1,sr
[ 627] 0x900000001fc06050:  03 e0 00 08 jr	ra
[ 627] 0x900000001fc06054:  00 00 00 00 nop
[ 627] 0x900000001fc06058:  00 00 00 00 nop
  628: 	WRITECP0(13)
[ 628] 0x900000001fc0605c:  40 a5 68 00 dmtc0	a1,cause
[ 628] 0x900000001fc06060:  03 e0 00 08 jr	ra
[ 628] 0x900000001fc06064:  00 00 00 00 nop
[ 628] 0x900000001fc06068:  00 00 00 00 nop
  629: 	WRITECP0(14)
[ 629] 0x900000001fc0606c:  40 a5 70 00 dmtc0	a1,epc
[ 629] 0x900000001fc06070:  03 e0 00 08 jr	ra
[ 629] 0x900000001fc06074:  00 00 00 00 nop
[ 629] 0x900000001fc06078:  00 00 00 00 nop
  630: 	WRITECP0(15)
[ 630] 0x900000001fc0607c:  40 a5 78 00 dmtc0	a1,prid
[ 630] 0x900000001fc06080:  03 e0 00 08 jr	ra
[ 630] 0x900000001fc06084:  00 00 00 00 nop
[ 630] 0x900000001fc06088:  00 00 00 00 nop
  631: 	WRITECP0(16)
[ 631] 0x900000001fc0608c:  40 a5 80 00 dmtc0	a1,config
[ 631] 0x900000001fc06090:  03 e0 00 08 jr	ra
[ 631] 0x900000001fc06094:  00 00 00 00 nop
[ 631] 0x900000001fc06098:  00 00 00 00 nop
  632: 	WRITECP0(17)
[ 632] 0x900000001fc0609c:  40 a5 88 00 dmtc0	a1,lladdr
[ 632] 0x900000001fc060a0:  03 e0 00 08 jr	ra
[ 632] 0x900000001fc060a4:  00 00 00 00 nop
[ 632] 0x900000001fc060a8:  00 00 00 00 nop
  633: 	WRITECP0(18)
[ 633] 0x900000001fc060ac:  40 a5 90 00 dmtc0	a1,watchlo
[ 633] 0x900000001fc060b0:  03 e0 00 08 jr	ra
[ 633] 0x900000001fc060b4:  00 00 00 00 nop
[ 633] 0x900000001fc060b8:  00 00 00 00 nop
  634: 	WRITECP0(19)
[ 634] 0x900000001fc060bc:  40 a5 98 00 dmtc0	a1,watchhi
[ 634] 0x900000001fc060c0:  03 e0 00 08 jr	ra
[ 634] 0x900000001fc060c4:  00 00 00 00 nop
[ 634] 0x900000001fc060c8:  00 00 00 00 nop
  635: 	WRITECP0(20)
[ 635] 0x900000001fc060cc:  40 a5 a0 00 dmtc0	a1,c0r20
[ 635] 0x900000001fc060d0:  03 e0 00 08 jr	ra
[ 635] 0x900000001fc060d4:  00 00 00 00 nop
[ 635] 0x900000001fc060d8:  00 00 00 00 nop
  636: 	WRITECP0(21)
[ 636] 0x900000001fc060dc:  40 a5 a8 00 dmtc0	a1,c0r21
[ 636] 0x900000001fc060e0:  03 e0 00 08 jr	ra
[ 636] 0x900000001fc060e4:  00 00 00 00 nop
[ 636] 0x900000001fc060e8:  00 00 00 00 nop
  637: 	WRITECP0(22)
[ 637] 0x900000001fc060ec:  40 a5 b0 00 dmtc0	a1,c0r22
[ 637] 0x900000001fc060f0:  03 e0 00 08 jr	ra
[ 637] 0x900000001fc060f4:  00 00 00 00 nop
[ 637] 0x900000001fc060f8:  00 00 00 00 nop
  638: 	WRITECP0(23)
[ 638] 0x900000001fc060fc:  40 a5 b8 00 dmtc0	a1,c0r23
[ 638] 0x900000001fc06100:  03 e0 00 08 jr	ra
[ 638] 0x900000001fc06104:  00 00 00 00 nop
[ 638] 0x900000001fc06108:  00 00 00 00 nop
  639: 	WRITECP0(24)
[ 639] 0x900000001fc0610c:  40 a5 c0 00 dmtc0	a1,c0r24
[ 639] 0x900000001fc06110:  03 e0 00 08 jr	ra
[ 639] 0x900000001fc06114:  00 00 00 00 nop
[ 639] 0x900000001fc06118:  00 00 00 00 nop
  640: 	WRITECP0(25)
[ 640] 0x900000001fc0611c:  40 a5 c8 00 dmtc0	a1,c0r25
[ 640] 0x900000001fc06120:  03 e0 00 08 jr	ra
[ 640] 0x900000001fc06124:  00 00 00 00 nop
[ 640] 0x900000001fc06128:  00 00 00 00 nop
  641: 	WRITECP0(26)
[ 641] 0x900000001fc0612c:  40 a5 d0 00 dmtc0	a1,ecc
[ 641] 0x900000001fc06130:  03 e0 00 08 jr	ra
[ 641] 0x900000001fc06134:  00 00 00 00 nop
[ 641] 0x900000001fc06138:  00 00 00 00 nop
  642: 	WRITECP0(27)
[ 642] 0x900000001fc0613c:  40 a5 d8 00 dmtc0	a1,cacheerr
[ 642] 0x900000001fc06140:  03 e0 00 08 jr	ra
[ 642] 0x900000001fc06144:  00 00 00 00 nop
[ 642] 0x900000001fc06148:  00 00 00 00 nop
  643: 	WRITECP0(28)
[ 643] 0x900000001fc0614c:  40 a5 e0 00 dmtc0	a1,taglo
[ 643] 0x900000001fc06150:  03 e0 00 08 jr	ra
[ 643] 0x900000001fc06154:  00 00 00 00 nop
[ 643] 0x900000001fc06158:  00 00 00 00 nop
  644: 	WRITECP0(29)
[ 644] 0x900000001fc0615c:  40 a5 e8 00 dmtc0	a1,taghi
[ 644] 0x900000001fc06160:  03 e0 00 08 jr	ra
[ 644] 0x900000001fc06164:  00 00 00 00 nop
[ 644] 0x900000001fc06168:  00 00 00 00 nop
  645: 	WRITECP0(30)
[ 645] 0x900000001fc0616c:  40 a5 f0 00 dmtc0	a1,errorepc
[ 645] 0x900000001fc06170:  03 e0 00 08 jr	ra
[ 645] 0x900000001fc06174:  00 00 00 00 nop
[ 645] 0x900000001fc06178:  00 00 00 00 nop
       0x900000001fc0617c:  00 00 00 00 nop
Skipping source listing to line 12 of /cores/banyan/stand/arcs/IP25prom/setjmp.s...
   13: #include <sys/sbd.h>
   14: #include "ip25prom.h"
   15: #include "pod_failure.h"
   16: 
   17: /*
   18:  * setjmp(jmp_buf) -- save current context for non-local goto's
   19:  * return 0
   20:  */
   21: LEAF(setjmp)
   22: 	sd	ra,JB_PC*8(a0)
setjmp:
[  22] 0x900000001fc06180:  fc 9f 00 00 sd	ra,0(a0)
   23: 	sd	sp,JB_SP*8(a0)
[  23] 0x900000001fc06184:  fc 9d 00 08 sd	sp,8(a0)
   24: 	sd	fp,JB_FP*8(a0)
[  24] 0x900000001fc06188:  fc 9e 00 10 sd	s8,16(a0)
   25: 	sd	s0,JB_S0*8(a0)
[  25] 0x900000001fc0618c:  fc 90 00 18 sd	s0,24(a0)
   26: 	sd	s1,JB_S1*8(a0)
[  26] 0x900000001fc06190:  fc 91 00 20 sd	s1,32(a0)
   27: 	sd	s2,JB_S2*8(a0)
[  27] 0x900000001fc06194:  fc 92 00 28 sd	s2,40(a0)
   28: 	sd	s3,JB_S3*8(a0)
[  28] 0x900000001fc06198:  fc 93 00 30 sd	s3,48(a0)
   29: 	sd	s4,JB_S4*8(a0)
[  29] 0x900000001fc0619c:  fc 94 00 38 sd	s4,56(a0)
   30: 	sd	s5,JB_S5*8(a0)
[  30] 0x900000001fc061a0:  fc 95 00 40 sd	s5,64(a0)
   31: 	sd	s6,JB_S6*8(a0)
[  31] 0x900000001fc061a4:  fc 96 00 48 sd	s6,72(a0)
   32: 	sd	s7,JB_S7*8(a0)
[  32] 0x900000001fc061a8:  fc 97 00 50 sd	s7,80(a0)
   33: 	move	v0,zero
[  33] 0x900000001fc061ac:  00 00 10 25 move	v0,zero
   34: 	j	ra
[  34] 0x900000001fc061b0:  03 e0 00 08 jr	ra
[  34] 0x900000001fc061b4:  00 00 00 00 nop
   35: 	END(setjmp)
   36: 
   37: /*
   38:  * longjmp(jmp_buf, rval)
   39:  */
   40: LEAF(longjmp)
   41: 	ld	ra,JB_PC*8(a0)
longjmp:
[  41] 0x900000001fc061b8:  dc 9f 00 00 ld	ra,0(a0)
   42: 	ld	sp,JB_SP*8(a0)
[  42] 0x900000001fc061bc:  dc 9d 00 08 ld	sp,8(a0)
   43: 	ld	fp,JB_FP*8(a0)
[  43] 0x900000001fc061c0:  dc 9e 00 10 ld	s8,16(a0)
   44: 	ld	s0,JB_S0*8(a0)
[  44] 0x900000001fc061c4:  dc 90 00 18 ld	s0,24(a0)
   45: 	ld	s1,JB_S1*8(a0)
[  45] 0x900000001fc061c8:  dc 91 00 20 ld	s1,32(a0)
   46: 	ld	s2,JB_S2*8(a0)
[  46] 0x900000001fc061cc:  dc 92 00 28 ld	s2,40(a0)
   47: 	ld	s3,JB_S3*8(a0)
[  47] 0x900000001fc061d0:  dc 93 00 30 ld	s3,48(a0)
   48: 	ld	s4,JB_S4*8(a0)
[  48] 0x900000001fc061d4:  dc 94 00 38 ld	s4,56(a0)
   49: 	ld	s5,JB_S5*8(a0)
[  49] 0x900000001fc061d8:  dc 95 00 40 ld	s5,64(a0)
   50: 	ld	s6,JB_S6*8(a0)
[  50] 0x900000001fc061dc:  dc 96 00 48 ld	s6,72(a0)
   51: 	ld	s7,JB_S7*8(a0)
[  51] 0x900000001fc061e0:  dc 97 00 50 ld	s7,80(a0)
   52: 	move	v0,a1			/* return rval */
[  52] 0x900000001fc061e4:  00 a0 10 25 move	v0,a1
   53: 	bnez	v0,1f			/* unless rval==0 */
[  53] 0x900000001fc061e8:  14 40 00 02 bne	v0,zero,0x900000001fc061f4
[  53] 0x900000001fc061ec:  00 00 00 00 nop
   54: 	li	v0,1			/* in which case return 1 */
[  54] 0x900000001fc061f0:  24 02 00 01 li	v0,1
   55: 1:	j	ra
[  55] 0x900000001fc061f4:  03 e0 00 08 jr	ra
[  55] 0x900000001fc061f8:  00 00 00 00 nop
   56: 	END(longjmp)
   57: 
   58: /*
   59:  * setfault(jump_buf, *old_buf)
   60:  * 	If jump_buf is non-zero, sets up the jumpbuf and switches
   61:  *	on exception handling.
   62:  */
   63: LEAF(setfault)
   64: 	.set	noreorder
   65: 	.set	noat
   66: 	DMFBR(t0, BR_NOFAULT)
setfault:
[  66] 0x900000001fc061fc:  44 2c 08 00 dmfc1	t0,$f1
   67: 	sd	t0, 0(a1)		# Save previous fault buffer
[  67] 0x900000001fc06200:  fc ac 00 00 sd	t0,0(a1)
   68: 	DMTBR(a0, BR_NOFAULT)
[  68] 0x900000001fc06204:  44 a4 08 00 dmtc1	a0,$f1
   69: 	bnez	a0, setjmp 
[  69] 0x900000001fc06208:  14 80 ff dd bne	a0,zero,0x900000001fc06180
   70: 	nop
[  70] 0x900000001fc0620c:  00 00 00 00 nop
   71: 	j	ra
[  71] 0x900000001fc06210:  03 e0 00 08 jr	ra
   72: 	nop
[  72] 0x900000001fc06214:  00 00 00 00 nop
   73: 	END(setfault)
   74: 
   75: /*
   76:  * restorefault(old_buf)
   77:  *	Simply sets NOFAULT_REG to the value passed.  Used to restore 
   78:  * 	previous fault buffer value.
   79:  */
   80: LEAF(restorefault)
   81: 	.set	noreorder
   82: 	DMTBR(a0, BR_NOFAULT)
restorefault:
[  82] 0x900000001fc06218:  44 a4 08 00 dmtc1	a0,$f1
   83: 	j	ra
[  83] 0x900000001fc0621c:  03 e0 00 08 jr	ra
   84: 	nop
[  84] 0x900000001fc06220:  00 00 00 00 nop
Skipping source listing to line 138 of /cores/banyan/stand/arcs/IP25prom/pod.c...
  139:   "Not defined"					/* 31 */
  140: };
  141: 
  142: 
  143: #define READING 0
  144: #define WRITING 1
  145: 
  146: static void
  147: xlate_cause(__scunsigned_t value)
  148: {
xlate_cause:
[ 148] 0x900000001fc06224:  67 bd ff b0 daddiu	sp,sp,-80
  149:     __scunsigned_t exc_code, int_bits;
  150:     int i;
  151: 
  152:     exc_code = (value & CAUSE_EXCMASK) >> CAUSE_EXCSHIFT;
[ 152] 0x900000001fc06228:  30 83 00 7c andi	v1,a0,0x7c
[ 152] 0x900000001fc0622c:  3c 01 90 00 lui	at,0x9000
  153:     int_bits = (value & CAUSE_IPMASK) >> CAUSE_IPSHIFT;
[ 153] 0x900000001fc06230:  ff b2 00 28 sd	s2,40(sp)
[ 153] 0x900000001fc06234:  30 92 ff 00 andi	s2,a0,0xff00
[ 153] 0x900000001fc06238:  60 21 00 00 daddi	at,at,0
[ 153] 0x900000001fc0623c:  3c 02 1f c2 lui	v0,0x1fc2
[ 153] 0x900000001fc06240:  3c 04 90 00 lui	a0,0x9000
[ 153] 0x900000001fc06244:  ff b6 00 08 sd	s6,8(sp)
[ 153] 0x900000001fc06248:  60 42 a2 09 daddi	v0,v0,-24055
[ 153] 0x900000001fc0624c:  ff b1 00 30 sd	s1,48(sp)
[ 153] 0x900000001fc06250:  60 91 00 00 daddi	s1,a0,0
[ 153] 0x900000001fc06254:  ff b0 00 38 sd	s0,56(sp)
[ 153] 0x900000001fc06258:  3c 10 1f c2 lui	s0,0x1fc2
[ 153] 0x900000001fc0625c:  00 03 b0 ba dsrl	s6,v1,2
[ 153] 0x900000001fc06260:  00 01 08 3c dsll32	at,at,0
[ 153] 0x900000001fc06264:  ff bf 00 40 sd	ra,64(sp)
[ 153] 0x900000001fc06268:  0f f0 2c e3 jal		loprintf
[ 153] 0x900000001fc0626c:  00 22 20 2c dadd	a0,at,v0
[ 153] 0x900000001fc06270:  62 10 9b 40 daddi	s0,s0,-25792
[ 153] 0x900000001fc06274:  00 11 08 3c dsll32	at,s1,0
[ 153] 0x900000001fc06278:  00 12 92 3a dsrl	s2,s2,8
[ 153] 0x900000001fc0627c:  ff b7 00 00 sd	s7,0(sp)
[ 153] 0x900000001fc06280:  00 30 b8 2c dadd	s7,at,s0
  154:     loprintf("( INT:");
  155:     for (i = 8; i > 0; i--) {
[ 155] 0x900000001fc06284:  24 11 00 08 li	s1,8
[ 155] 0x900000001fc06288:  3c 01 90 00 lui	at,0x9000
[ 155] 0x900000001fc0628c:  ff b3 00 20 sd	s3,32(sp)
[ 155] 0x900000001fc06290:  24 13 00 01 li	s3,1
[ 155] 0x900000001fc06294:  60 23 00 00 daddi	v1,at,0
[ 155] 0x900000001fc06298:  3c 01 90 00 lui	at,0x9000
[ 155] 0x900000001fc0629c:  3c 02 1f c2 lui	v0,0x1fc2
[ 155] 0x900000001fc062a0:  60 21 00 00 daddi	at,at,0
[ 155] 0x900000001fc062a4:  60 44 a2 13 daddi	a0,v0,-24045
[ 155] 0x900000001fc062a8:  3c 02 1f c2 lui	v0,0x1fc2
[ 155] 0x900000001fc062ac:  00 03 18 3c dsll32	v1,v1,0
[ 155] 0x900000001fc062b0:  60 42 a2 10 daddi	v0,v0,-24048
[ 155] 0x900000001fc062b4:  00 01 08 3c dsll32	at,at,0
[ 155] 0x900000001fc062b8:  ff b4 00 18 sd	s4,24(sp)
[ 155] 0x900000001fc062bc:  00 64 a0 2c dadd	s4,v1,a0
[ 155] 0x900000001fc062c0:  ff b5 00 10 sd	s5,16(sp)
[ 155] 0x900000001fc062c4:  00 22 a8 2c dadd	s5,at,v0
[ 155] 0x900000001fc062c8:  02 20 28 25 move	a1,s1
  156: 	if ((1 << (i - 1)) & int_bits)
[ 156] 0x900000001fc062cc:  26 30 ff ff addiu	s0,s1,-1
[ 156] 0x900000001fc062d0:  02 13 c0 04 sllv	t8,s3,s0
[ 156] 0x900000001fc062d4:  02 58 c0 24 and	t8,s2,t8
[ 156] 0x900000001fc062d8:  17 00 00 06 bne	t8,zero,0x900000001fc062f4
[ 156] 0x900000001fc062dc:  00 00 00 21 nada
  157: 	    loprintf("%d", i);
  158: 	else
  159: 	    loprintf("-");
[ 159] 0x900000001fc062e0:  0f f0 2c e3 jal		loprintf
[ 159] 0x900000001fc062e4:  02 80 20 25 move	a0,s4
[ 159] 0x900000001fc062e8:  02 00 88 25 move	s1,s0
[ 159] 0x900000001fc062ec:  10 00 00 04 b		0x900000001fc06300
[ 159] 0x900000001fc062f0:  00 00 00 21 nada
[ 157] 0x900000001fc062f4:  0f f0 2c e3 jal		loprintf
[ 157] 0x900000001fc062f8:  02 a0 20 25 move	a0,s5
[ 157] 0x900000001fc062fc:  02 00 88 25 move	s1,s0
[ 155] 0x900000001fc06300:  56 00 ff f2 bnel	s0,zero,0x900000001fc062cc
[ 155] 0x900000001fc06304:  02 20 28 25 move	a1,s1
  160:     }
  161:     if (exc_code)
[ 161] 0x900000001fc06308:  df b0 00 38 ld	s0,56(sp)
[ 161] 0x900000001fc0630c:  16 c0 00 0a bne	s6,zero,0x900000001fc06338
[ 161] 0x900000001fc06310:  df b2 00 28 ld	s2,40(sp)
[ 161] 0x900000001fc06314:  df b5 00 10 ld	s5,16(sp)
[ 161] 0x900000001fc06318:  df b4 00 18 ld	s4,24(sp)
  162: 	loprintf(" <%s> )\n", exc_names[exc_code]);
  163:     else
  164: 	loprintf(" )\n");
[ 164] 0x900000001fc0631c:  0f f0 2c e3 jal		loprintf
[ 164] 0x900000001fc06320:  66 e4 06 e1 daddiu	a0,s7,1761
[ 164] 0x900000001fc06324:  df b3 00 20 ld	s3,32(sp)
[ 164] 0x900000001fc06328:  df b7 00 00 ld	s7,0(sp)
[ 164] 0x900000001fc0632c:  df b1 00 30 ld	s1,48(sp)
[ 164] 0x900000001fc06330:  10 00 00 0d b		0x900000001fc06368
[ 164] 0x900000001fc06334:  df b6 00 08 ld	s6,8(sp)
[ 164] 0x900000001fc06338:  df b4 00 18 ld	s4,24(sp)
[ 162] 0x900000001fc0633c:  00 16 c8 f8 dsll	t9,s6,3
[ 162] 0x900000001fc06340:  de ff 06 e8 ld	ra,1768(s7)
[ 162] 0x900000001fc06344:  df b5 00 10 ld	s5,16(sp)
[ 162] 0x900000001fc06348:  03 3f c8 2d daddu	t9,t9,ra
[ 162] 0x900000001fc0634c:  66 e4 06 d8 daddiu	a0,s7,1752
[ 162] 0x900000001fc06350:  df b7 00 00 ld	s7,0(sp)
[ 162] 0x900000001fc06354:  df b1 00 30 ld	s1,48(sp)
[ 162] 0x900000001fc06358:  df b3 00 20 ld	s3,32(sp)
[ 162] 0x900000001fc0635c:  df b6 00 08 ld	s6,8(sp)
[ 162] 0x900000001fc06360:  0f f0 2c e3 jal		loprintf
[ 162] 0x900000001fc06364:  df 25 00 00 ld	a1,0(t9)
[ 162] 0x900000001fc06368:  df bf 00 40 ld	ra,64(sp)
[ 162] 0x900000001fc0636c:  03 e0 00 08 jr	ra
[ 162] 0x900000001fc06370:  67 bd 00 50 daddiu	sp,sp,80
  165: }
  166: 
  167: void
  168: xlate_ertoip(evreg_t value)
  169: {
xlate_ertoip:
[ 169] 0x900000001fc06374:  3c 01 90 00 lui	at,0x9000
[ 169] 0x900000001fc06378:  67 bd ff b0 daddiu	sp,sp,-80
[ 169] 0x900000001fc0637c:  3c 03 90 00 lui	v1,0x9000
[ 169] 0x900000001fc06380:  3c 02 1f c2 lui	v0,0x1fc2
[ 169] 0x900000001fc06384:  ff b5 00 10 sd	s5,16(sp)
[ 169] 0x900000001fc06388:  00 80 a8 25 move	s5,a0
[ 169] 0x900000001fc0638c:  3c 04 1f c2 lui	a0,0x1fc2
  170:     int i;
  171: 
  172:     if (!value)
[ 172] 0x900000001fc06390:  02 a0 28 25 move	a1,s5
[ 172] 0x900000001fc06394:  ff b0 00 38 sd	s0,56(sp)
[ 172] 0x900000001fc06398:  ff b1 00 30 sd	s1,48(sp)
[ 172] 0x900000001fc0639c:  ff b2 00 28 sd	s2,40(sp)
[ 172] 0x900000001fc063a0:  ff b3 00 20 sd	s3,32(sp)
[ 172] 0x900000001fc063a4:  ff b4 00 18 sd	s4,24(sp)
[ 172] 0x900000001fc063a8:  ff b6 00 08 sd	s6,8(sp)
[ 172] 0x900000001fc063ac:  24 16 00 18 li	s6,24
[ 172] 0x900000001fc063b0:  ff b7 00 00 sd	s7,0(sp)
[ 172] 0x900000001fc063b4:  ff bf 00 40 sd	ra,64(sp)
[ 172] 0x900000001fc063b8:  52 a0 00 23 beql	s5,zero,0x900000001fc06448
[ 172] 0x900000001fc063bc:  df b0 00 38 ld	s0,56(sp)
  173: 	return;
  174: 
  175:     loprintf("*** Error/TimeOut Interrupt(s) Pending: %x ==\n", value);
[ 175] 0x900000001fc063c0:  60 21 00 00 daddi	at,at,0
[ 175] 0x900000001fc063c4:  60 42 a2 30 daddi	v0,v0,-24016
[ 175] 0x900000001fc063c8:  60 63 00 00 daddi	v1,v1,0
[ 175] 0x900000001fc063cc:  60 91 9b 40 daddi	s1,a0,-25792
[ 175] 0x900000001fc063d0:  00 01 08 3c dsll32	at,at,0
[ 175] 0x900000001fc063d4:  00 03 80 3c dsll32	s0,v1,0
[ 175] 0x900000001fc063d8:  0f f0 2c e3 jal		loprintf
[ 175] 0x900000001fc063dc:  00 22 20 2c dadd	a0,at,v0
[ 175] 0x900000001fc063e0:  02 11 18 2c dadd	v1,s0,s1
  176: 
  177:     for (i = 0; i < (sizeof(ertoip_names) / sizeof(ertoip_names[0])); i++)
[ 177] 0x900000001fc063e4:  00 00 98 25 move	s3,zero
[ 177] 0x900000001fc063e8:  00 00 80 25 move	s0,zero
[ 177] 0x900000001fc063ec:  3c 01 90 00 lui	at,0x9000
[ 177] 0x900000001fc063f0:  3c 02 1f c2 lui	v0,0x1fc2
[ 177] 0x900000001fc063f4:  60 21 00 00 daddi	at,at,0
[ 177] 0x900000001fc063f8:  60 42 a2 5f daddi	v0,v0,-23969
[ 177] 0x900000001fc063fc:  dc 63 06 e8 ld	v1,1768(v1)
[ 177] 0x900000001fc06400:  00 01 08 3c dsll32	at,at,0
[ 177] 0x900000001fc06404:  24 14 00 01 li	s4,1
[ 177] 0x900000001fc06408:  64 72 01 00 daddiu	s2,v1,256
[ 177] 0x900000001fc0640c:  00 14 18 04 sllv	v1,s4,zero
[ 177] 0x900000001fc06410:  02 a3 c8 24 and	t9,s5,v1
[ 177] 0x900000001fc06414:  00 22 b8 2c dadd	s7,at,v0
  178: 	if (value & (1 << i))
[ 178] 0x900000001fc06418:  66 10 00 01 daddiu	s0,s0,1
[ 178] 0x900000001fc0641c:  26 73 00 01 addiu	s3,s3,1
[ 178] 0x900000001fc06420:  13 20 00 04 beq	t9,zero,0x900000001fc06434
[ 178] 0x900000001fc06424:  02 74 88 04 sllv	s1,s4,s3
  179: 	    loprintf("\t %s\n", ertoip_names[i]);
[ 179] 0x900000001fc06428:  de 45 00 00 ld	a1,0(s2)
[ 179] 0x900000001fc0642c:  0f f0 2c e3 jal		loprintf
[ 179] 0x900000001fc06430:  02 e0 20 25 move	a0,s7
[ 177] 0x900000001fc06434:  66 52 00 08 daddiu	s2,s2,8
[ 177] 0x900000001fc06438:  02 16 c0 2b sltu	t8,s0,s6
[ 177] 0x900000001fc0643c:  17 00 ff f6 bne	t8,zero,0x900000001fc06418
[ 177] 0x900000001fc06440:  02 b1 c8 24 and	t9,s5,s1
[ 177] 0x900000001fc06444:  df b0 00 38 ld	s0,56(sp)
[ 177] 0x900000001fc06448:  df b2 00 28 ld	s2,40(sp)
[ 177] 0x900000001fc0644c:  df b4 00 18 ld	s4,24(sp)
[ 177] 0x900000001fc06450:  df b7 00 00 ld	s7,0(sp)
[ 177] 0x900000001fc06454:  df bf 00 40 ld	ra,64(sp)
[ 177] 0x900000001fc06458:  df b5 00 10 ld	s5,16(sp)
[ 177] 0x900000001fc0645c:  df b3 00 20 ld	s3,32(sp)
[ 177] 0x900000001fc06460:  df b1 00 30 ld	s1,48(sp)
[ 177] 0x900000001fc06464:  df b6 00 08 ld	s6,8(sp)
[ 177] 0x900000001fc06468:  03 e0 00 08 jr	ra
[ 177] 0x900000001fc0646c:  67 bd 00 50 daddiu	sp,sp,80
  180: }
  181: 
  182: 
  183: /* pod_loop-
  184:  *	dex: 1 == cache has been set up dirty-exclusive.
  185:  *	     0 == stack is in memory	
  186:  *	diagval: Contains a code explaining why we're here.
  187:  *		see pod_failure.h
  188:  */
  189: void pod_loop(int dex, int diagval)
  190: {
pod_loop:
[ 190] 0x900000001fc06470:  67 bd fc 10 daddiu	sp,sp,-1008
[ 190] 0x900000001fc06474:  ff b0 00 70 sd	s0,112(sp)
[ 190] 0x900000001fc06478:  00 80 80 25 move	s0,a0
  191:     int buf[LINESIZE];
  192:     struct reg_struct gpr_space, *gprs = &gpr_space;
  193:     evreg_t ertoip;
  194:     struct flag_struct flags;
  195:     char diag_string[80];
  196: 
  197: 
  198:     sc_disp(diagval);
[ 198] 0x900000001fc0647c:  ff b2 00 60 sd	s2,96(sp)
[ 198] 0x900000001fc06480:  00 a0 90 25 move	s2,a1
[ 198] 0x900000001fc06484:  ff bf 00 78 sd	ra,120(sp)
[ 198] 0x900000001fc06488:  0f f0 3f 12 jal		sc_disp
[ 198] 0x900000001fc0648c:  30 a4 00 ff andi	a0,a1,0xff
[ 192] 0x900000001fc06490:  ff b1 00 68 sd	s1,104(sp)
[ 192] 0x900000001fc06494:  67 b1 00 d0 daddiu	s1,sp,208
  199: 
  200:     /* Get the GPR values from the GPRs and FPRs (FPRs contain the values
  201:        that were in the GPRs when Pod_handler was called). */
  202:     store_gprs(gprs);
[ 202] 0x900000001fc06498:  0f f0 16 f1 jal		store_gprs
[ 202] 0x900000001fc0649c:  67 a4 00 d0 daddiu	a0,sp,208
  203: 
  204:     /* Tell the world we've reached the POD loop
  205:      */
  206:     set_cc_leds(PLED_PODLOOP);
[ 206] 0x900000001fc064a0:  0f f0 0c 78 jal		set_cc_leds
[ 206] 0x900000001fc064a4:  24 04 00 21 li	a0,33
  207: 
  208:     flags.slot  = (char)((LD(EV_SPNUM) & EV_SLOTNUM_MASK) >> EV_SLOTNUM_SHFT);
[ 208] 0x900000001fc064a8:  3c 01 90 00 lui	at,0x9000
[ 208] 0x900000001fc064ac:  60 21 00 00 daddi	at,at,0
[ 208] 0x900000001fc064b0:  3c 02 1f c2 lui	v0,0x1fc2
[ 208] 0x900000001fc064b4:  60 42 9b 40 daddi	v0,v0,-25792
[ 208] 0x900000001fc064b8:  00 01 08 3c dsll32	at,at,0
[ 208] 0x900000001fc064bc:  00 22 08 2c dadd	at,at,v0
[ 208] 0x900000001fc064c0:  ff be 00 30 sd	s8,48(sp)
[ 208] 0x900000001fc064c4:  dc 21 07 a0 ld	at,1952(at)
[ 208] 0x900000001fc064c8:  ff b6 00 40 sd	s6,64(sp)
[ 208] 0x900000001fc064cc:  ff b7 00 38 sd	s7,56(sp)
[ 208] 0x900000001fc064d0:  dc 22 00 00 ld	v0,0(at)
[ 208] 0x900000001fc064d4:  ff b5 00 48 sd	s5,72(sp)
[ 208] 0x900000001fc064d8:  30 42 00 3c andi	v0,v0,0x3c
[ 208] 0x900000001fc064dc:  ff b4 00 50 sd	s4,80(sp)
[ 208] 0x900000001fc064e0:  00 02 10 bb dsra	v0,v0,2
[ 208] 0x900000001fc064e4:  a3 a2 00 14 sb	v0,20(sp)
  209:     flags.slice = (char)((LD(EV_SPNUM) & EV_PROCNUM_MASK) >> EV_PROCNUM_SHFT);
  210: 
  211:     flags.selected = 0xff;		/* No one's selecetd */
[ 211] 0x900000001fc064e8:  dc 21 00 00 ld	at,0(at)
[ 211] 0x900000001fc064ec:  24 02 00 ff li	v0,255
  212:     flags.silent = 0;			/* Normal verbnosity level */
  213: 
  214:     decode_diagval(diag_string, diagval);
[ 214] 0x900000001fc064f0:  02 40 28 25 move	a1,s2
[ 214] 0x900000001fc064f4:  67 a4 00 80 daddiu	a0,sp,128
[ 214] 0x900000001fc064f8:  a3 a2 00 16 sb	v0,22(sp)
[ 212] 0x900000001fc064fc:  30 21 00 03 andi	at,at,0x3
[ 212] 0x900000001fc06500:  a3 a0 00 17 sb	zero,23(sp)
[ 212] 0x900000001fc06504:  0f f0 19 c0 jal		decode_diagval
[ 212] 0x900000001fc06508:  a3 a1 00 15 sb	at,21(sp)
  215:     flags.diag_string = diag_string;
  216:     flags.diagval = diagval;
[ 216] 0x900000001fc0650c:  3c 06 90 00 lui	a2,0x9000
[ 216] 0x900000001fc06510:  67 a1 00 80 daddiu	at,sp,128
[ 216] 0x900000001fc06514:  56 00 00 0c bnel	s0,zero,0x900000001fc06548
[ 216] 0x900000001fc06518:  24 19 00 fd li	t9,253
  217: 
  218:     if (dex) {
  219: 	/* We're running with stack in dirty-exclusive cache lines */
  220: 	flags.mem = 0;
  221:     } else {
  222: 	/* We're running with stack in memory */
  223: 	flags.mem = 1;
[ 223] 0x900000001fc0651c:  60 c6 00 00 daddi	a2,a2,0
[ 223] 0x900000001fc06520:  24 08 00 01 li	a4,1
[ 223] 0x900000001fc06524:  00 06 50 3c dsll32	a6,a2,0
[ 223] 0x900000001fc06528:  3c 07 1f c2 lui	a3,0x1fc2
[ 223] 0x900000001fc0652c:  af a8 00 00 sw	a4,0(sp)
[ 223] 0x900000001fc06530:  60 e9 9b 40 daddi	a5,a3,-25792
[ 223] 0x900000001fc06534:  af b2 00 04 sw	s2,4(sp)
[ 223] 0x900000001fc06538:  ff b3 00 58 sd	s3,88(sp)
[ 223] 0x900000001fc0653c:  10 00 00 0a b		0x900000001fc06568
[ 223] 0x900000001fc06540:  24 19 00 fd li	t9,253
[ 220] 0x900000001fc06544:  24 19 00 fd li	t9,253
[ 220] 0x900000001fc06548:  3c 09 90 00 lui	a5,0x9000
[ 220] 0x900000001fc0654c:  ff b3 00 58 sd	s3,88(sp)
[ 220] 0x900000001fc06550:  61 2a 00 00 daddi	a6,a5,0
[ 220] 0x900000001fc06554:  3c 09 1f c2 lui	a5,0x1fc2
[ 220] 0x900000001fc06558:  af a0 00 00 sw	zero,0(sp)
[ 220] 0x900000001fc0655c:  61 29 9b 40 daddi	a5,a5,-25792
[ 220] 0x900000001fc06560:  00 0a 50 3c dsll32	a6,a6,0
[ 220] 0x900000001fc06564:  af b2 00 04 sw	s2,4(sp)
  224:     }
  225: 
  226:     if(diagval != EVDIAG_DEBUG) {
[ 226] 0x900000001fc06568:  ff a1 00 08 sd	at,8(sp)
[ 226] 0x900000001fc0656c:  52 59 00 11 beql	s2,t9,0x900000001fc065b4
[ 226] 0x900000001fc06570:  01 49 68 2c dadd	t1,a6,a5
  227: 	loprintf("  Cause = %x ", gprs->cause);
[ 227] 0x900000001fc06574:  3c 0b 90 00 lui	a7,0x9000
[ 227] 0x900000001fc06578:  de 25 01 08 ld	a1,264(s1)
[ 227] 0x900000001fc0657c:  61 6b 00 00 daddi	a7,a7,0
[ 227] 0x900000001fc06580:  3c 0c 1f c2 lui	t0,0x1fc2
[ 227] 0x900000001fc06584:  ff a9 00 18 sd	a5,24(sp)
[ 227] 0x900000001fc06588:  61 8c 9b 40 daddi	t0,t0,-25792
[ 227] 0x900000001fc0658c:  00 0b 58 3c dsll32	a7,a7,0
[ 227] 0x900000001fc06590:  ff aa 00 20 sd	a6,32(sp)
[ 227] 0x900000001fc06594:  01 6c 58 2c dadd	a7,a7,t0
[ 227] 0x900000001fc06598:  0f f0 2c e3 jal		loprintf
[ 227] 0x900000001fc0659c:  65 64 07 28 daddiu	a0,a7,1832
  228: 	xlate_cause(gprs->cause);
[ 228] 0x900000001fc065a0:  0f f0 18 89 jal		xlate_cause
[ 228] 0x900000001fc065a4:  de 24 01 08 ld	a0,264(s1)
[ 228] 0x900000001fc065a8:  df a9 00 18 ld	a5,24(sp)
[ 228] 0x900000001fc065ac:  df aa 00 20 ld	a6,32(sp)
[ 228] 0x900000001fc065b0:  01 49 68 2c dadd	t1,a6,a5
  229:     }
  230: 
  231:     if (ertoip = LD(EV_ERTOIP))
[ 231] 0x900000001fc065b4:  3c 0e 90 00 lui	t2,0x9000
[ 231] 0x900000001fc065b8:  61 ce 00 00 daddi	t2,t2,0
[ 231] 0x900000001fc065bc:  3c 0f 1f c2 lui	t3,0x1fc2
[ 231] 0x900000001fc065c0:  dd ad 07 a8 ld	t1,1960(t1)
[ 231] 0x900000001fc065c4:  61 ef 9b 40 daddi	t3,t3,-25792
[ 231] 0x900000001fc065c8:  00 0e 70 3c dsll32	t2,t2,0
[ 231] 0x900000001fc065cc:  01 cf 58 2c dadd	a7,t2,t3
[ 231] 0x900000001fc065d0:  dd ad 00 00 ld	t1,0(t1)
[ 231] 0x900000001fc065d4:  11 a0 00 05 beq	t1,zero,0x900000001fc065ec
[ 231] 0x900000001fc065d8:  01 a0 c8 25 move	t9,t1
  232: 	xlate_ertoip(ertoip);
[ 232] 0x900000001fc065dc:  ff ab 00 28 sd	a7,40(sp)
[ 232] 0x900000001fc065e0:  0f f0 18 dd jal		xlate_ertoip
[ 232] 0x900000001fc065e4:  03 20 20 25 move	a0,t9
[ 232] 0x900000001fc065e8:  df ab 00 28 ld	a7,40(sp)
[ 232] 0x900000001fc065ec:  3c 15 90 00 lui	s5,0x9000
  233: 
  234:     loprintf("Reason for entering POD mode: %s\n", diag_string);
[ 234] 0x900000001fc065f0:  67 a5 00 80 daddiu	a1,sp,128
[ 234] 0x900000001fc065f4:  0f f0 2c e3 jal		loprintf
[ 234] 0x900000001fc065f8:  65 64 07 38 daddiu	a0,a7,1848
  235: 
  236:     /* Display the long message the first time. */
  237:     flags.scroll_msg = 1;
[ 237] 0x900000001fc065fc:  24 14 00 01 li	s4,1
[ 237] 0x900000001fc06600:  24 13 00 fd li	s3,253
[ 237] 0x900000001fc06604:  12 53 00 0f beq	s2,s3,0x900000001fc06644
[ 237] 0x900000001fc06608:  af b4 00 10 sw	s4,16(sp)
  238:  
  239:     if (diagval != EVDIAG_DEBUG) {
  240: 	loprintf("Press ENTER to continue.\n");	
[ 240] 0x900000001fc0660c:  62 b5 00 00 daddi	s5,s5,0
[ 240] 0x900000001fc06610:  3c 16 1f c2 lui	s6,0x1fc2
[ 240] 0x900000001fc06614:  62 d6 9b 40 daddi	s6,s6,-25792
[ 240] 0x900000001fc06618:  00 15 a8 3c dsll32	s5,s5,0
[ 240] 0x900000001fc0661c:  02 b6 a8 2c dadd	s5,s5,s6
[ 240] 0x900000001fc06620:  0f f0 2c e3 jal		loprintf
[ 240] 0x900000001fc06624:  66 a4 07 60 daddiu	a0,s5,1888
  241: 	pod_flush();
[ 241] 0x900000001fc06628:  0f f0 15 1b jal		pod_flush
[ 241] 0x900000001fc0662c:  00 00 00 21 nada
  242: 	scroll_n_print(diagval);
[ 242] 0x900000001fc06630:  32 44 00 ff andi	a0,s2,0xff
[ 242] 0x900000001fc06634:  0f f0 3f 94 jal		scroll_n_print
[ 242] 0x900000001fc06638:  00 00 00 21 nada
  243: 	pod_getc();
[ 243] 0x900000001fc0663c:  0f f0 15 0b jal		pod_getc
[ 243] 0x900000001fc06640:  00 00 00 21 nada
  244:     }
  245: 
  246:     for (;;) {
  247: 	if (dex) {
[ 247] 0x900000001fc06644:  56 00 00 0e bnel	s0,zero,0x900000001fc06680
[ 247] 0x900000001fc06648:  3c 19 90 00 lui	t9,0x9000
  248: 	    loprintf("POD %b/%b> ", flags.slot, flags.slice);
  249: 	} else {
  250: 	    loprintf("Mem %b/%b> ", flags.slot, flags.slice);
[ 250] 0x900000001fc0664c:  3c 17 90 00 lui	s7,0x9000
[ 250] 0x900000001fc06650:  62 f7 00 00 daddi	s7,s7,0
[ 250] 0x900000001fc06654:  3c 18 1f c2 lui	t8,0x1fc2
[ 250] 0x900000001fc06658:  63 18 9b 40 daddi	t8,t8,-25792
[ 250] 0x900000001fc0665c:  00 17 b8 3c dsll32	s7,s7,0
[ 250] 0x900000001fc06660:  02 f8 b8 2c dadd	s7,s7,t8
[ 250] 0x900000001fc06664:  93 a5 00 14 lbu	a1,20(sp)
[ 250] 0x900000001fc06668:  93 a6 00 15 lbu	a2,21(sp)
[ 250] 0x900000001fc0666c:  0f f0 2c e3 jal		loprintf
[ 250] 0x900000001fc06670:  66 e4 07 90 daddiu	a0,s7,1936
[ 250] 0x900000001fc06674:  10 00 00 0c b		0x900000001fc066a8
[ 250] 0x900000001fc06678:  24 05 00 80 li	a1,128
[ 248] 0x900000001fc0667c:  3c 19 90 00 lui	t9,0x9000
[ 248] 0x900000001fc06680:  63 39 00 00 daddi	t9,t9,0
[ 248] 0x900000001fc06684:  3c 1e 1f c2 lui	s8,0x1fc2
[ 248] 0x900000001fc06688:  63 de 9b 40 daddi	s8,s8,-25792
[ 248] 0x900000001fc0668c:  00 19 c8 3c dsll32	t9,t9,0
[ 248] 0x900000001fc06690:  93 a5 00 14 lbu	a1,20(sp)
[ 248] 0x900000001fc06694:  93 a6 00 15 lbu	a2,21(sp)
[ 248] 0x900000001fc06698:  03 3e c8 2c dadd	t9,t9,s8
[ 248] 0x900000001fc0669c:  0f f0 2c e3 jal		loprintf
[ 248] 0x900000001fc066a0:  67 24 07 80 daddiu	a0,t9,1920
[ 248] 0x900000001fc066a4:  24 05 00 80 li	a1,128
  251: 	}
  252: 	logets(buf, LINESIZE);
[ 252] 0x900000001fc066a8:  0f f0 2f 1d jal		logets
[ 252] 0x900000001fc066ac:  67 a4 01 f0 daddiu	a0,sp,496
  253: 	pod_parse(buf, gprs, 0, 0, &flags);
[ 253] 0x900000001fc066b0:  67 a8 00 00 daddiu	a4,sp,0
[ 253] 0x900000001fc066b4:  00 00 38 25 move	a3,zero
[ 253] 0x900000001fc066b8:  00 00 30 25 move	a2,zero
[ 253] 0x900000001fc066bc:  02 20 28 25 move	a1,s1
[ 253] 0x900000001fc066c0:  0f f0 31 ec jal		pod_parse
[ 253] 0x900000001fc066c4:  67 a4 01 f0 daddiu	a0,sp,496
  254: 	if (ertoip = LD(EV_ERTOIP)) {
[ 254] 0x900000001fc066c8:  3c 1f 90 00 lui	ra,0x9000
[ 254] 0x900000001fc066cc:  63 ff 00 00 daddi	ra,ra,0
[ 254] 0x900000001fc066d0:  3c 01 1f c2 lui	at,0x1fc2
[ 254] 0x900000001fc066d4:  60 21 9b 40 daddi	at,at,-25792
[ 254] 0x900000001fc066d8:  00 1f f8 3c dsll32	ra,ra,0
[ 254] 0x900000001fc066dc:  03 e1 f8 2c dadd	ra,ra,at
[ 254] 0x900000001fc066e0:  df ff 07 a8 ld	ra,1960(ra)
[ 254] 0x900000001fc066e4:  df ff 00 00 ld	ra,0(ra)
[ 254] 0x900000001fc066e8:  13 e0 ff d6 beq	ra,zero,0x900000001fc06644
[ 254] 0x900000001fc066ec:  03 e0 c8 25 move	t9,ra
  255: 	    xlate_ertoip(ertoip);
[ 255] 0x900000001fc066f0:  0f f0 18 dd jal		xlate_ertoip
[ 255] 0x900000001fc066f4:  03 20 20 25 move	a0,t9
[ 255] 0x900000001fc066f8:  10 00 ff d2 b		0x900000001fc06644
[ 255] 0x900000001fc066fc:  00 00 00 21 nada
  256: 	}
  257:     }
  258: }
  259: 
  260: /* decode_diagval-
  261:  *	This is _very_ preliminary code for coming up with real
  262:  *		messages to display on the system controller.
  263:  *	We need to do _much_ better.
  264:  *	POD will need another parameter to describe where the error
  265:  *		occurred.
  266:  */
  267: void 
  268: decode_diagval(char *diag_string, int diagval)
  269: {
decode_diagval:
[ 269] 0x900000001fc06700:  67 bd ff f0 daddiu	sp,sp,-16
  270: 	/* We need to get FRU info, location, etc. */
  271: 
  272: 	lo_strcpy(diag_string, get_diag_string(EVDIAG_DIAGCODE(diagval)));
[ 272] 0x900000001fc06704:  30 a1 00 ff andi	at,a1,0xff
[ 272] 0x900000001fc06708:  ff b0 00 08 sd	s0,8(sp)
[ 272] 0x900000001fc0670c:  00 80 80 25 move	s0,a0
[ 272] 0x900000001fc06710:  ff bf 00 00 sd	ra,0(sp)
[ 272] 0x900000001fc06714:  0f f0 3f 6c jal		get_diag_string
[ 272] 0x900000001fc06718:  30 24 00 ff andi	a0,at,0xff
[ 272] 0x900000001fc0671c:  00 40 28 25 move	a1,v0
[ 272] 0x900000001fc06720:  0f f0 36 4b jal		lo_strcpy
[ 272] 0x900000001fc06724:  02 00 20 25 move	a0,s0
  273: 
  274: }
[ 274] 0x900000001fc06728:  df b0 00 08 ld	s0,8(sp)
[ 274] 0x900000001fc0672c:  df bf 00 00 ld	ra,0(sp)
[ 274] 0x900000001fc06730:  03 e0 00 08 jr	ra
[ 274] 0x900000001fc06734:  67 bd 00 10 daddiu	sp,sp,16
  275: 
  276: /* set_unit_enable-
  277:  *	Enables or disables a unit in a particular slot in the evconfig
  278:  * 		structure.
  279:  */
  280: int 
  281: set_unit_enable(uint slot, uint unit, uint enable, uint force)
  282: {
set_unit_enable:
[ 282] 0x900000001fc06738:  67 bd ff c0 daddiu	sp,sp,-64
[ 282] 0x900000001fc0673c:  ff b0 00 30 sd	s0,48(sp)
[ 282] 0x900000001fc06740:  00 a0 80 25 move	s0,a1
[ 282] 0x900000001fc06744:  ff b1 00 28 sd	s1,40(sp)
[ 282] 0x900000001fc06748:  00 80 88 25 move	s1,a0
[ 282] 0x900000001fc0674c:  00 11 20 3c dsll32	a0,s1,0
[ 282] 0x900000001fc06750:  ff b5 00 08 sd	s5,8(sp)
  283:     evbrdinfo_t *brd;
  284:     int conf_reg;
  285:     int myslot;
  286: 
  287:     if (unit > 7) {
[ 287] 0x900000001fc06754:  3c 01 90 00 lui	at,0x9000
[ 287] 0x900000001fc06758:  ff b3 00 18 sd	s3,24(sp)
[ 287] 0x900000001fc0675c:  3c 02 1f c2 lui	v0,0x1fc2
[ 287] 0x900000001fc06760:  60 21 00 00 daddi	at,at,0
[ 287] 0x900000001fc06764:  60 43 9b 40 daddi	v1,v0,-25792
[ 287] 0x900000001fc06768:  00 01 10 3c dsll32	v0,at,0
[ 287] 0x900000001fc0676c:  2e 01 00 08 sltiu	at,s0,8
[ 287] 0x900000001fc06770:  ff b2 00 20 sd	s2,32(sp)
[ 287] 0x900000001fc06774:  00 43 90 2c dadd	s2,v0,v1
[ 287] 0x900000001fc06778:  50 20 00 f8 beql	at,zero,0x900000001fc06b5c
[ 287] 0x900000001fc0677c:  df b1 00 28 ld	s1,40(sp)
  288: 	loprintf("*** Unit out of range!\n");
  289: 	return -1;
  290:     }
  291: 
  292:     brd = &(EVCFGINFO->ecfg_board[slot]);
[ 292] 0x900000001fc06780:  00 04 20 3e dsrl32	a0,a0,0
[ 292] 0x900000001fc06784:  00 c0 a8 25 move	s5,a2
[ 292] 0x900000001fc06788:  00 04 30 b8 dsll	a2,a0,2
[ 292] 0x900000001fc0678c:  00 04 29 38 dsll	a1,a0,4
[ 292] 0x900000001fc06790:  24 19 00 30 li	t9,48
[ 292] 0x900000001fc06794:  00 04 21 f8 dsll	a0,a0,7
[ 292] 0x900000001fc06798:  00 a6 28 2d daddu	a1,a1,a2
[ 292] 0x900000001fc0679c:  00 85 20 2f dsubu	a0,a0,a1
[ 292] 0x900000001fc067a0:  de 45 08 f8 ld	a1,2296(s2)
[ 292] 0x900000001fc067a4:  34 08 ff ff ori	a4,zero,0xffff
[ 292] 0x900000001fc067a8:  00 85 58 2f dsubu	a7,a0,a1
  293:     switch((brd->eb_type) & EVCLASS_MASK) {
[ 293] 0x900000001fc067ac:  02 20 28 25 move	a1,s1
[ 293] 0x900000001fc067b0:  00 08 44 38 dsll	a4,a4,16
[ 293] 0x900000001fc067b4:  24 09 00 10 li	a5,16
[ 293] 0x900000001fc067b8:  91 64 00 64 lbu	a0,100(a7)
[ 293] 0x900000001fc067bc:  24 0a 00 20 li	a6,32
[ 293] 0x900000001fc067c0:  ff b4 00 10 sd	s4,16(sp)
[ 293] 0x900000001fc067c4:  35 08 ff ff ori	a4,a4,0xffff
[ 293] 0x900000001fc067c8:  30 93 00 f0 andi	s3,a0,0xf0
[ 293] 0x900000001fc067cc:  00 e0 a0 25 move	s4,a3
[ 293] 0x900000001fc067d0:  16 60 00 0f bne	s3,zero,0x900000001fc06810
[ 293] 0x900000001fc067d4:  ff bf 00 38 sd	ra,56(sp)
[ 293] 0x900000001fc067d8:  df b3 00 18 ld	s3,24(sp)
  294:     case EVCLASS_NONE:
  295: 	/*
  296: 	 * It may be too early in the boot process for us to
  297: 	 * have initialized the evcfg table or we may be really
  298: 	 * confused. If user is trying to enable the current cpu
  299: 	 * board, let him do it.
  300: 	 */
  301: 	myslot = (int)((LD_LO(EV_SPNUM)&EV_SLOTNUM_MASK) >> EV_SLOTNUM_SHFT);
[ 301] 0x900000001fc067dc:  de 47 07 a0 ld	a3,1952(s2)
[ 301] 0x900000001fc067e0:  dc e7 00 00 ld	a3,0(a3)
[ 301] 0x900000001fc067e4:  00 e8 38 24 and	a3,a3,a4
[ 301] 0x900000001fc067e8:  30 e7 00 3c andi	a3,a3,0x3c
[ 301] 0x900000001fc067ec:  00 07 38 83 sra	a3,a3,2
  302: 	if (myslot == slot)
[ 302] 0x900000001fc067f0:  52 27 00 0a beql	s1,a3,0x900000001fc0681c
[ 302] 0x900000001fc067f4:  00 10 50 3c dsll32	a6,s0,0
  303: 	    goto valid_cpu;
  304: 
  305: 	loprintf("*** Slot %b is empty\n", slot);
[ 305] 0x900000001fc067f8:  df b1 00 28 ld	s1,40(sp)
[ 305] 0x900000001fc067fc:  0f f0 2c e3 jal		loprintf
[ 305] 0x900000001fc06800:  66 44 07 c8 daddiu	a0,s2,1992
  306: 	return -1;
[ 306] 0x900000001fc06804:  24 02 ff ff li	v0,-1
[ 306] 0x900000001fc06808:  10 00 00 da b		0x900000001fc06b74
[ 306] 0x900000001fc0680c:  df b5 00 08 ld	s5,8(sp)
[ 306] 0x900000001fc06810:  16 69 00 35 bne	s3,a5,0x900000001fc068e8
[ 306] 0x900000001fc06814:  00 00 00 21 nada
[ 306] 0x900000001fc06818:  00 10 50 3c dsll32	a6,s0,0
  307:     case EVCLASS_CPU:
  308:     valid_cpu:
  309: 	if (unit >= EV_CPU_PER_BOARD) {
[ 309] 0x900000001fc0681c:  2e 09 00 04 sltiu	a5,s0,4
[ 309] 0x900000001fc06820:  51 20 00 2c beql	a5,zero,0x900000001fc068d4
[ 309] 0x900000001fc06824:  df b1 00 28 ld	s1,40(sp)
  310: 	    loprintf("*** Unit out of range!\n");
  311: 	    return -1;
  312: 	}
  313: 	if ((brd->eb_cpuarr[unit].cpu_diagval ==
[ 313] 0x900000001fc06828:  00 0a 57 3a dsrl	a6,a6,28
[ 313] 0x900000001fc0682c:  01 6a c8 2d daddu	t9,a7,a6
[ 313] 0x900000001fc06830:  24 0b 00 ff li	a7,255
[ 313] 0x900000001fc06834:  93 2a 00 0b lbu	a6,11(t9)
[ 313] 0x900000001fc06838:  df b3 00 18 ld	s3,24(sp)
[ 313] 0x900000001fc0683c:  55 4b 00 04 bnel	a6,a7,0x900000001fc06850
[ 313] 0x900000001fc06840:  02 00 30 25 move	a2,s0
[ 313] 0x900000001fc06844:  52 80 00 1d beql	s4,zero,0x900000001fc068bc
[ 313] 0x900000001fc06848:  df b1 00 28 ld	s1,40(sp)
  314: 	     CPUST_NORESP) && !force) {
  315: 	    loprintf("*** CPU not populated\n");
  316: 	    return -1;
  317: 	}
  318: 	brd->eb_cpuarr[unit].cpu_enable = enable;
  319: 	loprintf("CPU %b/%b", slot, unit);
[ 319] 0x900000001fc0684c:  02 00 30 25 move	a2,s0
[ 319] 0x900000001fc06850:  02 20 28 25 move	a1,s1
[ 318] 0x900000001fc06854:  a3 35 00 09 sb	s5,9(t9)
[ 318] 0x900000001fc06858:  0f f0 2c e3 jal		loprintf
[ 318] 0x900000001fc0685c:  66 44 08 10 daddiu	a0,s2,2064
  320: 	if (force) {
[ 320] 0x900000001fc06860:  00 11 62 c0 sll	t0,s1,11
[ 320] 0x900000001fc06864:  12 80 00 ad beq	s4,zero,0x900000001fc06b1c
[ 320] 0x900000001fc06868:  24 0e 00 01 li	t2,1
  321: 	    conf_reg = (int)*EV_CONFIGADDR(slot, 0, EV_A_ENABLE);
[ 321] 0x900000001fc0686c:  00 0c 60 3c dsll32	t0,t0,0
[ 321] 0x900000001fc06870:  00 0c 60 3e dsrl32	t0,t0,0
[ 321] 0x900000001fc06874:  de 4d 09 00 ld	t1,2304(s2)
[ 321] 0x900000001fc06878:  01 8d 58 2d daddu	a7,t0,t1
  322: 	    if (enable)
[ 322] 0x900000001fc0687c:  02 0e c8 04 sllv	t9,t2,s0
[ 322] 0x900000001fc06880:  03 20 78 27 nor	t3,t9,zero
[ 322] 0x900000001fc06884:  dd 6c 00 00 ld	t0,0(a7)
[ 322] 0x900000001fc06888:  00 0c 98 00 sll	s3,t0,0
[ 322] 0x900000001fc0688c:  02 6f 78 24 and	t3,s3,t3
[ 322] 0x900000001fc06890:  02 79 60 25 or	t0,s3,t9
[ 322] 0x900000001fc06894:  16 a0 00 05 bne	s5,zero,0x900000001fc068ac
[ 322] 0x900000001fc06898:  31 8a 00 0f andi	a6,t0,0xf
  323: 		conf_reg |= 1 << unit;
  324: 	    else
  325: 		conf_reg &= ~(1 << unit);
[ 325] 0x900000001fc0689c:  31 ef 00 0f andi	t3,t3,0xf
[ 325] 0x900000001fc068a0:  fd 6f 00 00 sd	t3,0(a7)
[ 325] 0x900000001fc068a4:  10 00 00 99 b		0x900000001fc06b0c
[ 325] 0x900000001fc068a8:  00 00 00 21 nada
[ 323] 0x900000001fc068ac:  fd 6a 00 00 sd	a6,0(a7)
  326: 	    conf_reg &= 0xf;
  327: 	    EV_SET_CONFIG(slot, EV_A_ENABLE, conf_reg);
[ 327] 0x900000001fc068b0:  10 00 00 96 b		0x900000001fc06b0c
[ 327] 0x900000001fc068b4:  00 00 00 21 nada
[ 326] 0x900000001fc068b8:  df b1 00 28 ld	s1,40(sp)
[ 315] 0x900000001fc068bc:  0f f0 2c e3 jal		loprintf
[ 315] 0x900000001fc068c0:  66 44 07 f8 daddiu	a0,s2,2040
[ 316] 0x900000001fc068c4:  24 02 ff ff li	v0,-1
[ 316] 0x900000001fc068c8:  10 00 00 aa b		0x900000001fc06b74
[ 316] 0x900000001fc068cc:  df b5 00 08 ld	s5,8(sp)
[ 316] 0x900000001fc068d0:  df b1 00 28 ld	s1,40(sp)
[ 310] 0x900000001fc068d4:  0f f0 2c e3 jal		loprintf
[ 310] 0x900000001fc068d8:  66 44 07 e0 daddiu	a0,s2,2016
[ 311] 0x900000001fc068dc:  24 02 ff ff li	v0,-1
[ 311] 0x900000001fc068e0:  10 00 00 a3 b		0x900000001fc06b70
[ 311] 0x900000001fc068e4:  df b3 00 18 ld	s3,24(sp)
[ 311] 0x900000001fc068e8:  16 6a 00 53 bne	s3,a6,0x900000001fc06a38
[ 311] 0x900000001fc068ec:  00 00 00 21 nada
  328: 	}
  329: 	break;
  330:     case EVCLASS_IO:
  331: 	if ((brd->eb_ioarr[unit].ioa_type == 0) && !force) {
[ 331] 0x900000001fc068f0:  00 10 98 3c dsll32	s3,s0,0
[ 331] 0x900000001fc068f4:  00 13 98 3e dsrl32	s3,s3,0
[ 331] 0x900000001fc068f8:  00 13 c0 b8 dsll	t8,s3,2
[ 331] 0x900000001fc068fc:  00 13 98 f8 dsll	s3,s3,3
[ 331] 0x900000001fc06900:  02 78 98 2d daddu	s3,s3,t8
[ 331] 0x900000001fc06904:  01 73 98 2d daddu	s3,a7,s3
[ 331] 0x900000001fc06908:  92 78 00 07 lbu	t8,7(s3)
[ 331] 0x900000001fc0690c:  57 00 00 04 bnel	t8,zero,0x900000001fc06920
[ 331] 0x900000001fc06910:  24 0a 00 0e li	a6,14
[ 331] 0x900000001fc06914:  52 80 00 43 beql	s4,zero,0x900000001fc06a24
[ 331] 0x900000001fc06918:  df b1 00 28 ld	s1,40(sp)
  332: 	    loprintf("*** IOA not populated\n");
  333: 	    return -1;
  334: 	}
  335: 	brd->eb_ioarr[unit].ioa_enable = enable;
  336: 	switch(brd->eb_ioarr[unit].ioa_type) {
[ 336] 0x900000001fc0691c:  24 0a 00 0e li	a6,14
[ 336] 0x900000001fc06920:  92 79 00 07 lbu	t9,7(s3)
[ 336] 0x900000001fc06924:  24 1f 00 0d li	ra,13
[ 335] 0x900000001fc06928:  a2 75 00 04 sb	s5,4(s3)
[ 335] 0x900000001fc0692c:  17 3f 00 07 bne	t9,ra,0x900000001fc0694c
[ 335] 0x900000001fc06930:  24 0b 00 0f li	a7,15
  337: 	case IO4_ADAP_SCSI:
  338: 	    loprintf("SCSI %b/%b", slot,
[ 338] 0x900000001fc06934:  02 00 30 25 move	a2,s0
[ 338] 0x900000001fc06938:  02 20 28 25 move	a1,s1
[ 338] 0x900000001fc0693c:  0f f0 2c e3 jal		loprintf
[ 338] 0x900000001fc06940:  66 44 08 38 daddiu	a0,s2,2104
  339: 		     unit);
  340: 	    break;
[ 340] 0x900000001fc06944:  10 00 00 15 b		0x900000001fc0699c
[ 340] 0x900000001fc06948:  00 00 00 21 nada
[ 340] 0x900000001fc0694c:  17 2a 00 07 bne	t9,a6,0x900000001fc0696c
[ 340] 0x900000001fc06950:  00 00 00 21 nada
  341: 	case IO4_ADAP_EPC:
  342: 	    loprintf("EPC %b/%b", slot,
[ 342] 0x900000001fc06954:  02 00 30 25 move	a2,s0
[ 342] 0x900000001fc06958:  02 20 28 25 move	a1,s1
[ 342] 0x900000001fc0695c:  0f f0 2c e3 jal		loprintf
[ 342] 0x900000001fc06960:  66 44 08 48 daddiu	a0,s2,2120
  343: 		     unit);
  344: 	    break;
[ 344] 0x900000001fc06964:  10 00 00 0d b		0x900000001fc0699c
[ 344] 0x900000001fc06968:  00 00 00 21 nada
[ 344] 0x900000001fc0696c:  57 2b 00 08 bnel	t9,a7,0x900000001fc06990
[ 344] 0x900000001fc06970:  02 00 30 25 move	a2,s0
  345: 	case IO4_ADAP_FCHIP:
  346: 	    loprintf("F chip %b/%b", slot,
[ 346] 0x900000001fc06974:  02 00 30 25 move	a2,s0
[ 346] 0x900000001fc06978:  02 20 28 25 move	a1,s1
[ 346] 0x900000001fc0697c:  0f f0 2c e3 jal		loprintf
[ 346] 0x900000001fc06980:  66 44 08 58 daddiu	a0,s2,2136
  347: 		     unit);
  348: 	    break;
[ 348] 0x900000001fc06984:  10 00 00 05 b		0x900000001fc0699c
[ 348] 0x900000001fc06988:  00 00 00 21 nada
  349: 	default:
  350: 	    loprintf("Device in %b/%b",
[ 350] 0x900000001fc0698c:  02 00 30 25 move	a2,s0
[ 350] 0x900000001fc06990:  02 20 28 25 move	a1,s1
[ 350] 0x900000001fc06994:  0f f0 2c e3 jal		loprintf
[ 350] 0x900000001fc06998:  66 44 08 68 daddiu	a0,s2,2152
  351: 		     slot, unit);
  352: 	    break;
  353: 	}
  354: 	if (force) {
[ 354] 0x900000001fc0699c:  12 80 00 5f beq	s4,zero,0x900000001fc06b1c
[ 354] 0x900000001fc069a0:  00 00 00 21 nada
  355: 	    if (enable) {
[ 355] 0x900000001fc069a4:  56 a0 00 04 bnel	s5,zero,0x900000001fc069b8
[ 355] 0x900000001fc069a8:  00 11 42 c0 sll	a4,s1,11
  356: 		if (unit > 3)
  357: 		    conf_reg = (int)EV_GET_CONFIG(slot, IO4_CONF_IODEV1);
  358: 		else
  359: 		    conf_reg = (int)EV_GET_CONFIG(slot, IO4_CONF_IODEV0);
  360: 		brd->eb_ioarr[unit].ioa_type =
  361: 		    (conf_reg >> ((unit & 3) * 8)) & 0xff;
  362: 	    } else {
  363: 		brd->eb_ioarr[unit].ioa_type = 0;
[ 363] 0x900000001fc069ac:  10 00 00 57 b		0x900000001fc06b0c
[ 363] 0x900000001fc069b0:  a2 60 00 07 sb	zero,7(s3)
[ 356] 0x900000001fc069b4:  00 11 42 c0 sll	a4,s1,11
[ 356] 0x900000001fc069b8:  2e 07 00 04 sltiu	a3,s0,4
[ 356] 0x900000001fc069bc:  00 08 40 3c dsll32	a4,a4,0
[ 356] 0x900000001fc069c0:  10 e0 00 0c beq	a3,zero,0x900000001fc069f4
[ 356] 0x900000001fc069c4:  00 08 c8 3e dsrl32	t9,a4,0
[ 359] 0x900000001fc069c8:  de 4a 09 10 ld	a6,2320(s2)
[ 359] 0x900000001fc069cc:  03 2a 50 2d daddu	a6,t9,a6
[ 359] 0x900000001fc069d0:  32 09 00 03 andi	a5,s0,0x3
[ 359] 0x900000001fc069d4:  dd 4a 00 00 ld	a6,0(a6)
[ 359] 0x900000001fc069d8:  00 09 58 c0 sll	a7,a5,3
[ 359] 0x900000001fc069dc:  00 0a 50 00 sll	a6,a6,0
[ 359] 0x900000001fc069e0:  01 6a 50 07 srav	a6,a6,a7
[ 359] 0x900000001fc069e4:  31 4a 00 ff andi	a6,a6,0xff
[ 359] 0x900000001fc069e8:  a2 6a 00 07 sb	a6,7(s3)
[ 359] 0x900000001fc069ec:  10 00 00 47 b		0x900000001fc06b0c
[ 359] 0x900000001fc069f0:  00 00 00 21 nada
[ 357] 0x900000001fc069f4:  de 4c 09 08 ld	t0,2312(s2)
[ 357] 0x900000001fc069f8:  03 2c 60 2d daddu	t0,t9,t0
[ 357] 0x900000001fc069fc:  32 09 00 03 andi	a5,s0,0x3
[ 357] 0x900000001fc06a00:  dd 8c 00 00 ld	t0,0(t0)
[ 357] 0x900000001fc06a04:  00 09 58 c0 sll	a7,a5,3
[ 357] 0x900000001fc06a08:  00 0c 60 00 sll	t0,t0,0
[ 357] 0x900000001fc06a0c:  01 6c 58 07 srav	a7,t0,a7
[ 357] 0x900000001fc06a10:  31 6b 00 ff andi	a7,a7,0xff
[ 357] 0x900000001fc06a14:  a2 6b 00 07 sb	a7,7(s3)
[ 360] 0x900000001fc06a18:  10 00 00 3c b		0x900000001fc06b0c
[ 360] 0x900000001fc06a1c:  00 00 00 21 nada
[ 360] 0x900000001fc06a20:  df b1 00 28 ld	s1,40(sp)
[ 332] 0x900000001fc06a24:  0f f0 2c e3 jal		loprintf
[ 332] 0x900000001fc06a28:  66 44 08 20 daddiu	a0,s2,2080
[ 333] 0x900000001fc06a2c:  24 02 ff ff li	v0,-1
[ 333] 0x900000001fc06a30:  10 00 00 4f b		0x900000001fc06b70
[ 333] 0x900000001fc06a34:  df b3 00 18 ld	s3,24(sp)
[ 333] 0x900000001fc06a38:  16 79 00 32 bne	s3,t9,0x900000001fc06b04
[ 333] 0x900000001fc06a3c:  00 00 00 21 nada
  364: 	    }
  365: 	}
  366: 	break;
  367:     case EVCLASS_MEM:
  368: 	if ((brd->eb_banks[unit].bnk_size == MC3_NOBANK) &&
[ 368] 0x900000001fc06a40:  00 10 68 3c dsll32	t1,s0,0
[ 368] 0x900000001fc06a44:  00 0d 68 3e dsrl32	t1,t1,0
[ 368] 0x900000001fc06a48:  00 0d 70 b8 dsll	t2,t1,2
[ 368] 0x900000001fc06a4c:  00 0d 68 f8 dsll	t1,t1,3
[ 368] 0x900000001fc06a50:  01 ae 68 2d daddu	t1,t1,t2
[ 368] 0x900000001fc06a54:  01 6d 98 2d daddu	s3,a7,t1
[ 368] 0x900000001fc06a58:  24 0e 00 07 li	t2,7
[ 368] 0x900000001fc06a5c:  92 6d 00 0a lbu	t1,10(s3)
[ 368] 0x900000001fc06a60:  55 ae 00 04 bnel	t1,t2,0x900000001fc06a74
[ 368] 0x900000001fc06a64:  02 00 30 25 move	a2,s0
[ 368] 0x900000001fc06a68:  52 80 00 21 beql	s4,zero,0x900000001fc06af0
[ 368] 0x900000001fc06a6c:  df b1 00 28 ld	s1,40(sp)
  369: 	    !force){
  370: 	    loprintf("*** Bank not populated\n");
  371: 	    return -1;
  372: 	}
  373: 	brd->eb_banks[unit].bnk_enable = enable;
  374: 	loprintf("Slot %b, bank %b", slot, unit);
[ 374] 0x900000001fc06a70:  02 00 30 25 move	a2,s0
[ 374] 0x900000001fc06a74:  02 20 28 25 move	a1,s1
[ 373] 0x900000001fc06a78:  a2 75 00 05 sb	s5,5(s3)
[ 373] 0x900000001fc06a7c:  0f f0 2c e3 jal		loprintf
[ 373] 0x900000001fc06a80:  66 44 08 90 daddiu	a0,s2,2192
  375: 	if (force) {
[ 375] 0x900000001fc06a84:  12 80 00 25 beq	s4,zero,0x900000001fc06b1c
[ 375] 0x900000001fc06a88:  00 00 00 21 nada
  376: 	    if (enable) {
[ 376] 0x900000001fc06a8c:  56 a0 00 06 bnel	s5,zero,0x900000001fc06aa8
[ 376] 0x900000001fc06a90:  00 10 c8 82 srl	t9,s0,2
  377: 		brd->eb_banks[unit].bnk_size = (unsigned char)
  378: 		    EV_GET_CONFIG(slot, MC3_BANK((unit >> 2),(unit & 3), 
  379: 						 BANK_SIZE));
  380: 	    } else {
  381: 		brd->eb_banks[unit].bnk_size =
[ 381] 0x900000001fc06a94:  24 0f 00 07 li	t3,7
[ 381] 0x900000001fc06a98:  a2 6f 00 0a sb	t3,10(s3)
[ 381] 0x900000001fc06a9c:  10 00 00 1b b		0x900000001fc06b0c
[ 381] 0x900000001fc06aa0:  00 00 00 21 nada
[ 377] 0x900000001fc06aa4:  00 10 c8 82 srl	t9,s0,2
[ 377] 0x900000001fc06aa8:  32 18 00 03 andi	t8,s0,0x3
[ 377] 0x900000001fc06aac:  00 11 82 c0 sll	s0,s1,11
[ 377] 0x900000001fc06ab0:  00 19 89 80 sll	s1,t9,6
[ 377] 0x900000001fc06ab4:  00 18 c0 80 sll	t8,t8,2
[ 377] 0x900000001fc06ab8:  00 10 80 3c dsll32	s0,s0,0
[ 377] 0x900000001fc06abc:  02 38 88 21 addu	s1,s1,t8
[ 377] 0x900000001fc06ac0:  00 10 80 3e dsrl32	s0,s0,0
[ 377] 0x900000001fc06ac4:  26 31 00 10 addiu	s1,s1,16
[ 377] 0x900000001fc06ac8:  00 11 88 c0 sll	s1,s1,3
[ 377] 0x900000001fc06acc:  00 11 88 3c dsll32	s1,s1,0
[ 377] 0x900000001fc06ad0:  00 11 88 3e dsrl32	s1,s1,0
[ 377] 0x900000001fc06ad4:  02 11 80 2d daddu	s0,s0,s1
[ 377] 0x900000001fc06ad8:  de 51 09 00 ld	s1,2304(s2)
[ 377] 0x900000001fc06adc:  02 11 80 2d daddu	s0,s0,s1
[ 377] 0x900000001fc06ae0:  de 10 00 00 ld	s0,0(s0)
[ 377] 0x900000001fc06ae4:  10 00 00 09 b		0x900000001fc06b0c
[ 377] 0x900000001fc06ae8:  a2 70 00 0a sb	s0,10(s3)
[ 377] 0x900000001fc06aec:  df b1 00 28 ld	s1,40(sp)
[ 370] 0x900000001fc06af0:  0f f0 2c e3 jal		loprintf
[ 370] 0x900000001fc06af4:  66 44 08 78 daddiu	a0,s2,2168
[ 371] 0x900000001fc06af8:  24 02 ff ff li	v0,-1
[ 371] 0x900000001fc06afc:  10 00 00 1c b		0x900000001fc06b70
[ 371] 0x900000001fc06b00:  df b3 00 18 ld	s3,24(sp)
  382: 		    MC3_NOBANK;
  383: 	    }
  384: 	}
  385: 	break;
  386:     default:
  387: 	loprintf("*** Unknown board class\n");
[ 387] 0x900000001fc06b04:  0f f0 2c e3 jal		loprintf
[ 387] 0x900000001fc06b08:  66 44 08 a8 daddiu	a0,s2,2216
  388: 	break;
  389:     }
  390:     if (force)
[ 390] 0x900000001fc06b0c:  12 80 00 03 beq	s4,zero,0x900000001fc06b1c
[ 390] 0x900000001fc06b10:  00 00 00 21 nada
  391: 	loprintf(" forcibly");
[ 391] 0x900000001fc06b14:  0f f0 2c e3 jal		loprintf
[ 391] 0x900000001fc06b18:  66 44 08 c8 daddiu	a0,s2,2248
  392:     if (enable)
[ 392] 0x900000001fc06b1c:  56 a0 00 09 bnel	s5,zero,0x900000001fc06b44
[ 392] 0x900000001fc06b20:  df b3 00 18 ld	s3,24(sp)
  393: 	loprintf(" enabled.\n");
  394:     else
  395: 	loprintf(" disabled.\n");
[ 395] 0x900000001fc06b24:  df b1 00 28 ld	s1,40(sp)
[ 395] 0x900000001fc06b28:  df b3 00 18 ld	s3,24(sp)
[ 395] 0x900000001fc06b2c:  0f f0 2c e3 jal		loprintf
[ 395] 0x900000001fc06b30:  66 44 08 e8 daddiu	a0,s2,2280
[ 395] 0x900000001fc06b34:  00 00 10 25 move	v0,zero
[ 395] 0x900000001fc06b38:  10 00 00 0e b		0x900000001fc06b74
[ 395] 0x900000001fc06b3c:  df b5 00 08 ld	s5,8(sp)
[ 395] 0x900000001fc06b40:  df b3 00 18 ld	s3,24(sp)
[ 393] 0x900000001fc06b44:  0f f0 2c e3 jal		loprintf
[ 393] 0x900000001fc06b48:  66 44 08 d8 daddiu	a0,s2,2264
  396:     return 0;
[ 396] 0x900000001fc06b4c:  df b1 00 28 ld	s1,40(sp)
[ 396] 0x900000001fc06b50:  10 00 00 07 b		0x900000001fc06b70
[ 396] 0x900000001fc06b54:  00 00 10 25 move	v0,zero
[ 396] 0x900000001fc06b58:  df b1 00 28 ld	s1,40(sp)
[ 288] 0x900000001fc06b5c:  ff bf 00 38 sd	ra,56(sp)
[ 288] 0x900000001fc06b60:  0f f0 2c e3 jal		loprintf
[ 288] 0x900000001fc06b64:  66 44 07 b0 daddiu	a0,s2,1968
[ 289] 0x900000001fc06b68:  24 02 ff ff li	v0,-1
[ 289] 0x900000001fc06b6c:  ff b4 00 10 sd	s4,16(sp)
[ 289] 0x900000001fc06b70:  df b5 00 08 ld	s5,8(sp)
[ 289] 0x900000001fc06b74:  df bf 00 38 ld	ra,56(sp)
[ 289] 0x900000001fc06b78:  df b2 00 20 ld	s2,32(sp)
[ 289] 0x900000001fc06b7c:  df b0 00 30 ld	s0,48(sp)
[ 289] 0x900000001fc06b80:  df b4 00 10 ld	s4,16(sp)
[ 289] 0x900000001fc06b84:  03 e0 00 08 jr	ra
[ 289] 0x900000001fc06b88:  67 bd 00 40 daddiu	sp,sp,64
  397: }
  398: 
  399: void
  400: pod_reconf_mem(void)
  401: {
pod_reconf_mem:
[ 401] 0x900000001fc06b8c:  67 bd f8 d0 daddiu	sp,sp,-1840
  402:     evcfginfo_t evconfig;
  403:     int diagval;
  404:     int c;
  405:     unsigned intlv_type;
  406:     int slot, slice;
  407: 
  408:     loprintf("Enable interleaving (y/n)? ");
[ 408] 0x900000001fc06b90:  3c 01 90 00 lui	at,0x9000
[ 408] 0x900000001fc06b94:  60 21 00 00 daddi	at,at,0
[ 408] 0x900000001fc06b98:  3c 02 1f c2 lui	v0,0x1fc2
[ 408] 0x900000001fc06b9c:  60 42 a4 58 daddi	v0,v0,-23464
[ 408] 0x900000001fc06ba0:  ff b0 00 30 sd	s0,48(sp)
[ 408] 0x900000001fc06ba4:  3c 10 90 00 lui	s0,0x9000
[ 408] 0x900000001fc06ba8:  00 01 08 3c dsll32	at,at,0
[ 408] 0x900000001fc06bac:  ff bf 00 38 sd	ra,56(sp)
[ 408] 0x900000001fc06bb0:  0f f0 2c e3 jal		loprintf
[ 408] 0x900000001fc06bb4:  00 22 20 2c dadd	a0,at,v0
[ 408] 0x900000001fc06bb8:  62 10 00 00 daddi	s0,s0,0
  409:     pod_flush();
[ 409] 0x900000001fc06bbc:  ff b1 00 28 sd	s1,40(sp)
[ 409] 0x900000001fc06bc0:  0f f0 15 1b jal		pod_flush
[ 409] 0x900000001fc06bc4:  3c 11 1f c2 lui	s1,0x1fc2
[ 409] 0x900000001fc06bc8:  62 31 9b 40 daddi	s1,s1,-25792
  410:     c = pod_getc();
[ 410] 0x900000001fc06bcc:  0f f0 15 0b jal		pod_getc
[ 410] 0x900000001fc06bd0:  00 10 80 3c dsll32	s0,s0,0
[ 410] 0x900000001fc06bd4:  02 11 80 2c dadd	s0,s0,s1
  411: 	
  412:     if (c == 'y' || c == 'Y') {
[ 412] 0x900000001fc06bd8:  30 41 00 ff andi	at,v0,0xff
[ 412] 0x900000001fc06bdc:  24 02 00 79 li	v0,121
[ 412] 0x900000001fc06be0:  10 22 00 08 beq	at,v0,0x900000001fc06c04
[ 412] 0x900000001fc06be4:  24 0b 00 59 li	a7,89
[ 412] 0x900000001fc06be8:  10 2b 00 06 beq	at,a7,0x900000001fc06c04
[ 412] 0x900000001fc06bec:  00 00 00 21 nada
  413: 	loprintf("Yes.\n");
  414: 	intlv_type = INTLV_STABLE;
  415:     } else {
  416: 	loprintf("No.\n");
[ 416] 0x900000001fc06bf0:  0f f0 2c e3 jal		loprintf
[ 416] 0x900000001fc06bf4:  66 04 09 3a daddiu	a0,s0,2362
  417: 	intlv_type = INTLV_ONEWAY;
[ 417] 0x900000001fc06bf8:  00 00 88 25 move	s1,zero
[ 417] 0x900000001fc06bfc:  10 00 00 04 b		0x900000001fc06c10
[ 417] 0x900000001fc06c00:  00 00 00 21 nada
[ 413] 0x900000001fc06c04:  0f f0 2c e3 jal		loprintf
[ 413] 0x900000001fc06c08:  66 04 09 34 daddiu	a0,s0,2356
[ 414] 0x900000001fc06c0c:  24 11 00 01 li	s1,1
  418:     }
  419: 
  420:     loprintf("Copying configuration information into cache\n");
[ 420] 0x900000001fc06c10:  0f f0 2c e3 jal		loprintf
[ 420] 0x900000001fc06c14:  66 04 09 40 daddiu	a0,s0,2368
  421:     evconfig = *EVCFGINFO;
[ 421] 0x900000001fc06c18:  3c 18 90 00 lui	t8,0x9000
[ 421] 0x900000001fc06c1c:  ff b2 00 20 sd	s2,32(sp)
[ 421] 0x900000001fc06c20:  67 b2 00 04 daddiu	s2,sp,4
[ 421] 0x900000001fc06c24:  63 1f 00 00 daddi	ra,t8,0
[ 421] 0x900000001fc06c28:  3c 01 1f c2 lui	at,0x1fc2
[ 421] 0x900000001fc06c2c:  de 19 0a 50 ld	t9,2640(s0)
[ 421] 0x900000001fc06c30:  24 0b 01 b8 li	a7,440
[ 421] 0x900000001fc06c34:  24 18 ff fc li	t8,-4
[ 421] 0x900000001fc06c38:  60 22 9b 40 daddi	v0,at,-25792
[ 421] 0x900000001fc06c3c:  01 78 c0 2d daddu	t8,a7,t8
[ 421] 0x900000001fc06c40:  8f 23 00 00 lw	v1,0(t9)
[ 421] 0x900000001fc06c44:  00 1f f8 3c dsll32	ra,ra,0
[ 421] 0x900000001fc06c48:  24 01 00 03 li	at,3
[ 421] 0x900000001fc06c4c:  af a3 00 40 sw	v1,64(sp)
[ 421] 0x900000001fc06c50:  00 38 c0 2a slt	t8,at,t8
[ 421] 0x900000001fc06c54:  03 e2 80 2c dadd	s0,ra,v0
[ 421] 0x900000001fc06c58:  8f 39 00 04 lw	t9,4(t9)
[ 421] 0x900000001fc06c5c:  24 03 ff fc li	v1,-4
[ 421] 0x900000001fc06c60:  67 a9 00 08 daddiu	a5,sp,8
[ 421] 0x900000001fc06c64:  de 0a 1e 00 ld	a6,7680(s0)
[ 421] 0x900000001fc06c68:  13 00 00 31 beq	t8,zero,0x900000001fc06d30
[ 421] 0x900000001fc06c6c:  ae 59 00 40 sw	t9,64(s2)
[ 421] 0x900000001fc06c70:  01 40 20 25 move	a0,a6
[ 421] 0x900000001fc06c74:  01 63 18 2d daddu	v1,a7,v1
[ 421] 0x900000001fc06c78:  8d 42 00 00 lw	v0,0(a6)
[ 421] 0x900000001fc06c7c:  01 20 30 25 move	a2,a5
[ 421] 0x900000001fc06c80:  24 67 ff fc addiu	a3,v1,-4
[ 421] 0x900000001fc06c84:  ac c2 00 40 sw	v0,64(a2)
[ 421] 0x900000001fc06c88:  8c 83 00 04 lw	v1,4(a0)
[ 421] 0x900000001fc06c8c:  ac c3 00 44 sw	v1,68(a2)
[ 421] 0x900000001fc06c90:  8c 83 00 08 lw	v1,8(a0)
[ 421] 0x900000001fc06c94:  ac c3 00 48 sw	v1,72(a2)
[ 421] 0x900000001fc06c98:  64 85 00 10 daddiu	a1,a0,16
[ 421] 0x900000001fc06c9c:  8c 83 00 0c lw	v1,12(a0)
[ 421] 0x900000001fc06ca0:  ac c3 00 4c sw	v1,76(a2)
[ 421] 0x900000001fc06ca4:  64 c6 00 10 daddiu	a2,a2,16
[ 421] 0x900000001fc06ca8:  00 27 18 2a slt	v1,at,a3
[ 421] 0x900000001fc06cac:  24 e7 ff fc addiu	a3,a3,-4
[ 421] 0x900000001fc06cb0:  10 60 00 17 beq	v1,zero,0x900000001fc06d10
[ 421] 0x900000001fc06cb4:  8c a2 00 00 lw	v0,0(a1)
[ 421] 0x900000001fc06cb8:  ac c2 00 40 sw	v0,64(a2)
[ 421] 0x900000001fc06cbc:  8c a3 00 04 lw	v1,4(a1)
[ 421] 0x900000001fc06cc0:  ac c3 00 44 sw	v1,68(a2)
[ 421] 0x900000001fc06cc4:  8c a3 00 08 lw	v1,8(a1)
[ 421] 0x900000001fc06cc8:  ac c3 00 48 sw	v1,72(a2)
[ 421] 0x900000001fc06ccc:  64 a4 00 10 daddiu	a0,a1,16
[ 421] 0x900000001fc06cd0:  8c a3 00 0c lw	v1,12(a1)
[ 421] 0x900000001fc06cd4:  ac c3 00 4c sw	v1,76(a2)
[ 421] 0x900000001fc06cd8:  64 c6 00 10 daddiu	a2,a2,16
[ 421] 0x900000001fc06cdc:  00 27 18 2a slt	v1,at,a3
[ 421] 0x900000001fc06ce0:  24 e7 ff fc addiu	a3,a3,-4
[ 421] 0x900000001fc06ce4:  14 60 ff e7 bne	v1,zero,0x900000001fc06c84
[ 421] 0x900000001fc06ce8:  8c 82 00 00 lw	v0,0(a0)
[ 421] 0x900000001fc06cec:  ac c2 00 40 sw	v0,64(a2)
[ 421] 0x900000001fc06cf0:  8c 85 00 04 lw	a1,4(a0)
[ 421] 0x900000001fc06cf4:  ac c5 00 44 sw	a1,68(a2)
[ 421] 0x900000001fc06cf8:  8c 85 00 08 lw	a1,8(a0)
[ 421] 0x900000001fc06cfc:  ac c5 00 48 sw	a1,72(a2)
[ 421] 0x900000001fc06d00:  8c 84 00 0c lw	a0,12(a0)
[ 421] 0x900000001fc06d04:  ac c4 00 4c sw	a0,76(a2)
[ 421] 0x900000001fc06d08:  10 00 00 17 b		0x900000001fc06d68
[ 421] 0x900000001fc06d0c:  00 00 00 21 nada
[ 421] 0x900000001fc06d10:  ac c2 00 40 sw	v0,64(a2)
[ 421] 0x900000001fc06d14:  8c a7 00 04 lw	a3,4(a1)
[ 421] 0x900000001fc06d18:  ac c7 00 44 sw	a3,68(a2)
[ 421] 0x900000001fc06d1c:  8c a7 00 08 lw	a3,8(a1)
[ 421] 0x900000001fc06d20:  ac c7 00 48 sw	a3,72(a2)
[ 421] 0x900000001fc06d24:  8c a7 00 0c lw	a3,12(a1)
[ 421] 0x900000001fc06d28:  10 00 00 0f b		0x900000001fc06d68
[ 421] 0x900000001fc06d2c:  ac c7 00 4c sw	a3,76(a2)
[ 421] 0x900000001fc06d30:  8d 48 00 00 lw	a4,0(a6)
[ 421] 0x900000001fc06d34:  ad 28 00 40 sw	a4,64(a5)
[ 421] 0x900000001fc06d38:  8d 48 00 04 lw	a4,4(a6)
[ 421] 0x900000001fc06d3c:  ad 28 00 44 sw	a4,68(a5)
[ 421] 0x900000001fc06d40:  8d 48 00 08 lw	a4,8(a6)
[ 421] 0x900000001fc06d44:  ad 28 00 48 sw	a4,72(a5)
[ 421] 0x900000001fc06d48:  25 6b ff fc addiu	a7,a7,-4
[ 421] 0x900000001fc06d4c:  8d 4c 00 0c lw	t0,12(a6)
[ 421] 0x900000001fc06d50:  65 4a 00 10 daddiu	a6,a6,16
[ 421] 0x900000001fc06d54:  00 2b 40 2a slt	a4,at,a7
[ 421] 0x900000001fc06d58:  ad 2c 00 4c sw	t0,76(a5)
[ 421] 0x900000001fc06d5c:  65 29 00 10 daddiu	a5,a5,16
[ 421] 0x900000001fc06d60:  55 00 ff f4 bnel	a4,zero,0x900000001fc06d34
[ 421] 0x900000001fc06d64:  8d 48 00 00 lw	a4,0(a6)
  422: 	
  423:     loprintf("Reconfiguring memory");
[ 423] 0x900000001fc06d68:  0f f0 2c e3 jal		loprintf
[ 423] 0x900000001fc06d6c:  66 04 09 70 daddiu	a0,s0,2416
  424:     if (intlv_type == INTLV_ONEWAY)
[ 424] 0x900000001fc06d70:  12 20 00 05 beq	s1,zero,0x900000001fc06d88
[ 424] 0x900000001fc06d74:  00 00 00 21 nada
  425: 	loprintf(" (Interleaving disabled)\n");
  426:     else
  427: 	loprintf("\n");
[ 427] 0x900000001fc06d78:  0f f0 2c e3 jal		loprintf
[ 427] 0x900000001fc06d7c:  66 04 09 a2 daddiu	a0,s0,2466
[ 427] 0x900000001fc06d80:  10 00 00 04 b		0x900000001fc06d94
[ 427] 0x900000001fc06d84:  02 20 28 25 move	a1,s1
[ 425] 0x900000001fc06d88:  0f f0 2c e3 jal		loprintf
[ 425] 0x900000001fc06d8c:  66 04 09 88 daddiu	a0,s0,2440
[ 425] 0x900000001fc06d90:  02 20 28 25 move	a1,s1
  428:  
  429:     if(diagval = mc3_reconfig(&evconfig, intlv_type))
[ 429] 0x900000001fc06d94:  0f f0 50 2d jal		mc3_reconfig
[ 429] 0x900000001fc06d98:  67 a4 00 40 daddiu	a0,sp,64
[ 429] 0x900000001fc06d9c:  00 40 08 25 move	at,v0
[ 429] 0x900000001fc06da0:  14 20 00 05 bne	at,zero,0x900000001fc06db8
[ 429] 0x900000001fc06da4:  00 00 00 21 nada
  430: 	loprintf(" *** %s\n", get_diag_string(diagval));
  431:     else
  432: 	loprintf("Memory reconfigured\n");
[ 432] 0x900000001fc06da8:  0f f0 2c e3 jal		loprintf
[ 432] 0x900000001fc06dac:  66 04 09 b8 daddiu	a0,s0,2488
[ 432] 0x900000001fc06db0:  10 00 00 06 b		0x900000001fc06dcc
[ 432] 0x900000001fc06db4:  00 00 00 21 nada
[ 430] 0x900000001fc06db8:  0f f0 3f 6c jal		get_diag_string
[ 430] 0x900000001fc06dbc:  00 20 20 25 move	a0,at
[ 430] 0x900000001fc06dc0:  00 40 28 25 move	a1,v0
[ 430] 0x900000001fc06dc4:  0f f0 2c e3 jal		loprintf
[ 430] 0x900000001fc06dc8:  66 04 09 a8 daddiu	a0,s0,2472
  433: 
  434:     loprintf("Restoring configuration information\n");
[ 434] 0x900000001fc06dcc:  0f f0 2c e3 jal		loprintf
[ 434] 0x900000001fc06dd0:  66 04 09 d0 daddiu	a0,s0,2512
  435: 
  436:     *EVCFGINFO = evconfig;
[ 436] 0x900000001fc06dd4:  3c 0d 90 00 lui	t1,0x9000
[ 436] 0x900000001fc06dd8:  61 ae 00 00 daddi	t2,t1,0
[ 436] 0x900000001fc06ddc:  3c 11 1f c2 lui	s1,0x1fc2
[ 436] 0x900000001fc06de0:  24 0b 01 b8 li	a7,440
[ 436] 0x900000001fc06de4:  24 0d ff fc li	t1,-4
[ 436] 0x900000001fc06de8:  de 0f 0a 50 ld	t3,2640(s0)
[ 436] 0x900000001fc06dec:  62 31 9b 40 daddi	s1,s1,-25792
[ 436] 0x900000001fc06df0:  01 6d 68 2d daddu	t1,a7,t1
[ 436] 0x900000001fc06df4:  8f b0 00 40 lw	s0,64(sp)
[ 436] 0x900000001fc06df8:  00 0e 70 3c dsll32	t2,t2,0
[ 436] 0x900000001fc06dfc:  ad f0 00 00 sw	s0,0(t3)
[ 436] 0x900000001fc06e00:  24 01 00 03 li	at,3
[ 436] 0x900000001fc06e04:  00 2d 68 2a slt	t1,at,t1
[ 436] 0x900000001fc06e08:  01 d1 80 2c dadd	s0,t2,s1
[ 436] 0x900000001fc06e0c:  8e 4e 00 40 lw	t2,64(s2)
[ 436] 0x900000001fc06e10:  24 12 ff fc li	s2,-4
[ 436] 0x900000001fc06e14:  67 aa 00 08 daddiu	a6,sp,8
[ 436] 0x900000001fc06e18:  de 09 1e 00 ld	a5,7680(s0)
[ 436] 0x900000001fc06e1c:  11 a0 00 31 beq	t1,zero,0x900000001fc06ee4
[ 436] 0x900000001fc06e20:  ad ee 00 04 sw	t2,4(t3)
[ 436] 0x900000001fc06e24:  01 40 20 25 move	a0,a6
[ 436] 0x900000001fc06e28:  01 72 90 2d daddu	s2,a7,s2
[ 436] 0x900000001fc06e2c:  8d 42 00 40 lw	v0,64(a6)
[ 436] 0x900000001fc06e30:  01 20 30 25 move	a2,a5
[ 436] 0x900000001fc06e34:  26 47 ff fc addiu	a3,s2,-4
[ 436] 0x900000001fc06e38:  ac c2 00 00 sw	v0,0(a2)
[ 436] 0x900000001fc06e3c:  8c 83 00 44 lw	v1,68(a0)
[ 436] 0x900000001fc06e40:  ac c3 00 04 sw	v1,4(a2)
[ 436] 0x900000001fc06e44:  8c 83 00 48 lw	v1,72(a0)
[ 436] 0x900000001fc06e48:  ac c3 00 08 sw	v1,8(a2)
[ 436] 0x900000001fc06e4c:  64 85 00 10 daddiu	a1,a0,16
[ 436] 0x900000001fc06e50:  8c 83 00 4c lw	v1,76(a0)
[ 436] 0x900000001fc06e54:  ac c3 00 0c sw	v1,12(a2)
[ 436] 0x900000001fc06e58:  64 c6 00 10 daddiu	a2,a2,16
[ 436] 0x900000001fc06e5c:  00 27 18 2a slt	v1,at,a3
[ 436] 0x900000001fc06e60:  24 e7 ff fc addiu	a3,a3,-4
[ 436] 0x900000001fc06e64:  10 60 00 17 beq	v1,zero,0x900000001fc06ec4
[ 436] 0x900000001fc06e68:  8c a2 00 40 lw	v0,64(a1)
[ 436] 0x900000001fc06e6c:  ac c2 00 00 sw	v0,0(a2)
[ 436] 0x900000001fc06e70:  8c a3 00 44 lw	v1,68(a1)
[ 436] 0x900000001fc06e74:  ac c3 00 04 sw	v1,4(a2)
[ 436] 0x900000001fc06e78:  8c a3 00 48 lw	v1,72(a1)
[ 436] 0x900000001fc06e7c:  ac c3 00 08 sw	v1,8(a2)
[ 436] 0x900000001fc06e80:  64 a4 00 10 daddiu	a0,a1,16
[ 436] 0x900000001fc06e84:  8c a3 00 4c lw	v1,76(a1)
[ 436] 0x900000001fc06e88:  ac c3 00 0c sw	v1,12(a2)
[ 436] 0x900000001fc06e8c:  64 c6 00 10 daddiu	a2,a2,16
[ 436] 0x900000001fc06e90:  00 27 18 2a slt	v1,at,a3
[ 436] 0x900000001fc06e94:  24 e7 ff fc addiu	a3,a3,-4
[ 436] 0x900000001fc06e98:  14 60 ff e7 bne	v1,zero,0x900000001fc06e38
[ 436] 0x900000001fc06e9c:  8c 82 00 40 lw	v0,64(a0)
[ 436] 0x900000001fc06ea0:  ac c2 00 00 sw	v0,0(a2)
[ 436] 0x900000001fc06ea4:  8c 98 00 44 lw	t8,68(a0)
[ 436] 0x900000001fc06ea8:  ac d8 00 04 sw	t8,4(a2)
[ 436] 0x900000001fc06eac:  8c 98 00 48 lw	t8,72(a0)
[ 436] 0x900000001fc06eb0:  ac d8 00 08 sw	t8,8(a2)
[ 436] 0x900000001fc06eb4:  8c 98 00 4c lw	t8,76(a0)
[ 436] 0x900000001fc06eb8:  ac d8 00 0c sw	t8,12(a2)
[ 436] 0x900000001fc06ebc:  10 00 00 17 b		0x900000001fc06f1c
[ 436] 0x900000001fc06ec0:  00 00 00 21 nada
[ 436] 0x900000001fc06ec4:  ac c2 00 00 sw	v0,0(a2)
[ 436] 0x900000001fc06ec8:  8c b9 00 44 lw	t9,68(a1)
[ 436] 0x900000001fc06ecc:  ac d9 00 04 sw	t9,4(a2)
[ 436] 0x900000001fc06ed0:  8c b9 00 48 lw	t9,72(a1)
[ 436] 0x900000001fc06ed4:  ac d9 00 08 sw	t9,8(a2)
[ 436] 0x900000001fc06ed8:  8c b9 00 4c lw	t9,76(a1)
[ 436] 0x900000001fc06edc:  10 00 00 0f b		0x900000001fc06f1c
[ 436] 0x900000001fc06ee0:  ac d9 00 0c sw	t9,12(a2)
[ 436] 0x900000001fc06ee4:  8d 5f 00 40 lw	ra,64(a6)
[ 436] 0x900000001fc06ee8:  ad 3f 00 00 sw	ra,0(a5)
[ 436] 0x900000001fc06eec:  8d 5f 00 44 lw	ra,68(a6)
[ 436] 0x900000001fc06ef0:  ad 3f 00 04 sw	ra,4(a5)
[ 436] 0x900000001fc06ef4:  8d 5f 00 48 lw	ra,72(a6)
[ 436] 0x900000001fc06ef8:  ad 3f 00 08 sw	ra,8(a5)
[ 436] 0x900000001fc06efc:  25 6b ff fc addiu	a7,a7,-4
[ 436] 0x900000001fc06f00:  8d 42 00 4c lw	v0,76(a6)
[ 436] 0x900000001fc06f04:  65 4a 00 10 daddiu	a6,a6,16
[ 436] 0x900000001fc06f08:  00 2b f8 2a slt	ra,at,a7
[ 436] 0x900000001fc06f0c:  ad 22 00 0c sw	v0,12(a5)
[ 436] 0x900000001fc06f10:  65 29 00 10 daddiu	a5,a5,16
[ 436] 0x900000001fc06f14:  57 e0 ff f4 bnel	ra,zero,0x900000001fc06ee8
[ 436] 0x900000001fc06f18:  8d 5f 00 40 lw	ra,64(a6)
  437: 
  438:     loprintf("Recreating MPCONF blocks ");
[ 438] 0x900000001fc06f1c:  0f f0 2c e3 jal		loprintf
[ 438] 0x900000001fc06f20:  66 04 09 f8 daddiu	a0,s0,2552
  439:     if (evconfig.ecfg_debugsw & VDS_NO_DIAGS)
[ 439] 0x900000001fc06f24:  8f a1 07 18 lw	at,1816(sp)
[ 439] 0x900000001fc06f28:  30 21 00 10 andi	at,at,0x10
[ 439] 0x900000001fc06f2c:  14 20 00 05 bne	at,zero,0x900000001fc06f44
[ 439] 0x900000001fc06f30:  00 00 00 21 nada
  440: 	loprintf(" - NO DIAGS mode\n");
  441:     else
  442: 	loprintf(" and waiting for slaves.\n");
[ 442] 0x900000001fc06f34:  0f f0 2c e3 jal		loprintf
[ 442] 0x900000001fc06f38:  66 04 0a 30 daddiu	a0,s0,2608
[ 442] 0x900000001fc06f3c:  10 00 00 04 b		0x900000001fc06f50
[ 442] 0x900000001fc06f40:  df b1 00 28 ld	s1,40(sp)
[ 440] 0x900000001fc06f44:  0f f0 2c e3 jal		loprintf
[ 440] 0x900000001fc06f48:  66 04 0a 18 daddiu	a0,s0,2584
[ 440] 0x900000001fc06f4c:  df b1 00 28 ld	s1,40(sp)
[ 440] 0x900000001fc06f50:  df b2 00 20 ld	s2,32(sp)
  443: 
  444:     /* Set up mpconf structure and send interrupt to slaves. */
  445:     init_mpconf();
[ 445] 0x900000001fc06f54:  0f f0 54 30 jal		init_mpconf
[ 445] 0x900000001fc06f58:  00 00 00 21 nada
  446:     GDA->g_vds = evconfig.ecfg_debugsw;
[ 446] 0x900000001fc06f5c:  34 08 ff ff ori	a4,zero,0xffff
[ 446] 0x900000001fc06f60:  de 06 0a 58 ld	a2,2648(s0)
[ 446] 0x900000001fc06f64:  8f a5 07 18 lw	a1,1816(sp)
[ 446] 0x900000001fc06f68:  00 08 44 38 dsll	a4,a4,16
[ 446] 0x900000001fc06f6c:  35 09 ff ff ori	a5,a4,0xffff
[ 446] 0x900000001fc06f70:  ac c5 00 28 sw	a1,40(a2)
  447:     if (!(evconfig.ecfg_debugsw & VDS_NO_DIAGS)) {
[ 447] 0x900000001fc06f74:  8f a5 07 18 lw	a1,1816(sp)
[ 447] 0x900000001fc06f78:  30 a5 00 10 andi	a1,a1,0x10
[ 447] 0x900000001fc06f7c:  54 a0 00 0b bnel	a1,zero,0x900000001fc06fac
[ 447] 0x900000001fc06f80:  df bf 00 38 ld	ra,56(sp)
  448: 	slot =  (int)((LD_LO(EV_SPNUM) & EV_SLOTNUM_MASK) >> EV_SLOTNUM_SHFT);
[ 448] 0x900000001fc06f84:  de 07 07 a0 ld	a3,1952(s0)
[ 448] 0x900000001fc06f88:  dc e8 00 00 ld	a4,0(a3)
  449: 	slice = (int)((LD_LO(EV_SPNUM) & EV_PROCNUM_MASK) >> EV_PROCNUM_SHFT);
[ 449] 0x900000001fc06f8c:  01 09 40 24 and	a4,a4,a5
[ 449] 0x900000001fc06f90:  dc e7 00 00 ld	a3,0(a3)
[ 449] 0x900000001fc06f94:  31 08 00 3c andi	a4,a4,0x3c
[ 449] 0x900000001fc06f98:  00 e9 38 24 and	a3,a3,a5
  450: 	check_slaves(slot, slice);
[ 450] 0x900000001fc06f9c:  00 08 20 83 sra	a0,a4,2
[ 450] 0x900000001fc06fa0:  0f f0 38 23 jal		check_slaves
[ 450] 0x900000001fc06fa4:  30 e5 00 03 andi	a1,a3,0x3
[ 450] 0x900000001fc06fa8:  df bf 00 38 ld	ra,56(sp)
[ 450] 0x900000001fc06fac:  df b0 00 30 ld	s0,48(sp)
[ 450] 0x900000001fc06fb0:  03 e0 00 08 jr	ra
[ 450] 0x900000001fc06fb4:  67 bd 07 30 daddiu	sp,sp,1840
  451:     }
  452: }
  453: 
  454: void
  455: pod_bist(void)
  456: {
pod_bist:
[ 456] 0x900000001fc06fb8:  67 bd f8 90 daddiu	sp,sp,-1904
  457:     evcfginfo_t evconfig;
  458:     int diagval;
  459:     unsigned int mem, i, time, timeout;
  460:     int slot, slice;
  461: 
  462:     mem = memory_slots();
[ 462] 0x900000001fc06fbc:  ff bf 00 78 sd	ra,120(sp)
[ 462] 0x900000001fc06fc0:  0f f0 17 2e jal		memory_slots
[ 462] 0x900000001fc06fc4:  00 00 00 21 nada
  463: 
  464:     loprintf("Copying configuration information into cache\n");
[ 464] 0x900000001fc06fc8:  ff b4 00 50 sd	s4,80(sp)
[ 464] 0x900000001fc06fcc:  00 40 a0 25 move	s4,v0
[ 464] 0x900000001fc06fd0:  3c 01 90 00 lui	at,0x9000
[ 464] 0x900000001fc06fd4:  60 23 00 00 daddi	v1,at,0
[ 464] 0x900000001fc06fd8:  3c 01 1f c2 lui	at,0x1fc2
[ 464] 0x900000001fc06fdc:  ff b1 00 68 sd	s1,104(sp)
[ 464] 0x900000001fc06fe0:  60 31 9b 40 daddi	s1,at,-25792
[ 464] 0x900000001fc06fe4:  3c 01 90 00 lui	at,0x9000
[ 464] 0x900000001fc06fe8:  60 21 00 00 daddi	at,at,0
[ 464] 0x900000001fc06fec:  3c 02 1f c2 lui	v0,0x1fc2
[ 464] 0x900000001fc06ff0:  60 42 a5 a0 daddi	v0,v0,-23136
[ 464] 0x900000001fc06ff4:  ff b0 00 70 sd	s0,112(sp)
[ 464] 0x900000001fc06ff8:  00 03 80 3c dsll32	s0,v1,0
[ 464] 0x900000001fc06ffc:  00 01 08 3c dsll32	at,at,0
[ 464] 0x900000001fc07000:  0f f0 2c e3 jal		loprintf
[ 464] 0x900000001fc07004:  00 22 20 2c dadd	a0,at,v0
[ 464] 0x900000001fc07008:  ff be 00 30 sd	s8,48(sp)
[ 464] 0x900000001fc0700c:  ff b7 00 38 sd	s7,56(sp)
[ 464] 0x900000001fc07010:  02 11 18 2c dadd	v1,s0,s1
  465:     evconfig = *EVCFGINFO;
[ 465] 0x900000001fc07014:  3c 01 90 00 lui	at,0x9000
[ 465] 0x900000001fc07018:  ff b6 00 40 sd	s6,64(sp)
[ 465] 0x900000001fc0701c:  60 21 00 00 daddi	at,at,0
[ 465] 0x900000001fc07020:  3c 02 1f c2 lui	v0,0x1fc2
[ 465] 0x900000001fc07024:  ff b5 00 48 sd	s5,72(sp)
[ 465] 0x900000001fc07028:  dc 63 0a 50 ld	v1,2640(v1)
[ 465] 0x900000001fc0702c:  60 46 9b 40 daddi	a2,v0,-25792
[ 465] 0x900000001fc07030:  24 10 01 b8 li	s0,440
[ 465] 0x900000001fc07034:  ff b3 00 58 sd	s3,88(sp)
[ 465] 0x900000001fc07038:  24 02 ff fc li	v0,-4
[ 465] 0x900000001fc0703c:  24 04 00 10 li	a0,16
[ 465] 0x900000001fc07040:  ff b2 00 60 sd	s2,96(sp)
[ 465] 0x900000001fc07044:  02 02 10 2d daddu	v0,s0,v0
[ 465] 0x900000001fc07048:  ff a4 00 28 sd	a0,40(sp)
[ 465] 0x900000001fc0704c:  00 01 20 3c dsll32	a0,at,0
[ 465] 0x900000001fc07050:  8c 65 00 00 lw	a1,0(v1)
[ 465] 0x900000001fc07054:  24 01 00 03 li	at,3
[ 465] 0x900000001fc07058:  00 86 20 2c dadd	a0,a0,a2
[ 465] 0x900000001fc0705c:  af a5 00 80 sw	a1,128(sp)
[ 465] 0x900000001fc07060:  67 b2 00 08 daddiu	s2,sp,8
[ 465] 0x900000001fc07064:  00 22 10 2a slt	v0,at,v0
[ 465] 0x900000001fc07068:  ff a4 00 20 sd	a0,32(sp)
[ 465] 0x900000001fc0706c:  24 15 00 01 li	s5,1
[ 465] 0x900000001fc07070:  02 40 30 25 move	a2,s2
[ 465] 0x900000001fc07074:  dc 91 1e 00 ld	s1,7680(a0)
[ 465] 0x900000001fc07078:  8c 63 00 04 lw	v1,4(v1)
[ 465] 0x900000001fc0707c:  02 20 20 25 move	a0,s1
[ 465] 0x900000001fc07080:  10 40 00 30 beq	v0,zero,0x900000001fc07144
[ 465] 0x900000001fc07084:  af a3 00 84 sw	v1,132(sp)
[ 465] 0x900000001fc07088:  24 12 ff fc li	s2,-4
[ 465] 0x900000001fc0708c:  02 12 90 2d daddu	s2,s0,s2
[ 465] 0x900000001fc07090:  8e 22 00 00 lw	v0,0(s1)
[ 465] 0x900000001fc07094:  26 47 ff fc addiu	a3,s2,-4
[ 465] 0x900000001fc07098:  ac c2 00 80 sw	v0,128(a2)
[ 465] 0x900000001fc0709c:  8c 83 00 04 lw	v1,4(a0)
[ 465] 0x900000001fc070a0:  ac c3 00 84 sw	v1,132(a2)
[ 465] 0x900000001fc070a4:  8c 83 00 08 lw	v1,8(a0)
[ 465] 0x900000001fc070a8:  ac c3 00 88 sw	v1,136(a2)
[ 465] 0x900000001fc070ac:  64 85 00 10 daddiu	a1,a0,16
[ 465] 0x900000001fc070b0:  8c 83 00 0c lw	v1,12(a0)
[ 465] 0x900000001fc070b4:  ac c3 00 8c sw	v1,140(a2)
[ 465] 0x900000001fc070b8:  64 c6 00 10 daddiu	a2,a2,16
[ 465] 0x900000001fc070bc:  00 27 18 2a slt	v1,at,a3
[ 465] 0x900000001fc070c0:  24 e7 ff fc addiu	a3,a3,-4
[ 465] 0x900000001fc070c4:  10 60 00 17 beq	v1,zero,0x900000001fc07124
[ 465] 0x900000001fc070c8:  8c a2 00 00 lw	v0,0(a1)
[ 465] 0x900000001fc070cc:  ac c2 00 80 sw	v0,128(a2)
[ 465] 0x900000001fc070d0:  8c a3 00 04 lw	v1,4(a1)
[ 465] 0x900000001fc070d4:  ac c3 00 84 sw	v1,132(a2)
[ 465] 0x900000001fc070d8:  8c a3 00 08 lw	v1,8(a1)
[ 465] 0x900000001fc070dc:  ac c3 00 88 sw	v1,136(a2)
[ 465] 0x900000001fc070e0:  64 a4 00 10 daddiu	a0,a1,16
[ 465] 0x900000001fc070e4:  8c a3 00 0c lw	v1,12(a1)
[ 465] 0x900000001fc070e8:  ac c3 00 8c sw	v1,140(a2)
[ 465] 0x900000001fc070ec:  64 c6 00 10 daddiu	a2,a2,16
[ 465] 0x900000001fc070f0:  00 27 18 2a slt	v1,at,a3
[ 465] 0x900000001fc070f4:  24 e7 ff fc addiu	a3,a3,-4
[ 465] 0x900000001fc070f8:  14 60 ff e7 bne	v1,zero,0x900000001fc07098
[ 465] 0x900000001fc070fc:  8c 82 00 00 lw	v0,0(a0)
[ 465] 0x900000001fc07100:  ac c2 00 80 sw	v0,128(a2)
[ 465] 0x900000001fc07104:  8c 93 00 04 lw	s3,4(a0)
[ 465] 0x900000001fc07108:  ac d3 00 84 sw	s3,132(a2)
[ 465] 0x900000001fc0710c:  8c 93 00 08 lw	s3,8(a0)
[ 465] 0x900000001fc07110:  ac d3 00 88 sw	s3,136(a2)
[ 465] 0x900000001fc07114:  8c 93 00 0c lw	s3,12(a0)
[ 465] 0x900000001fc07118:  ac d3 00 8c sw	s3,140(a2)
[ 465] 0x900000001fc0711c:  10 00 00 18 b		0x900000001fc07180
[ 465] 0x900000001fc07120:  df be 00 20 ld	s8,32(sp)
[ 465] 0x900000001fc07124:  ac c2 00 80 sw	v0,128(a2)
[ 465] 0x900000001fc07128:  8c b6 00 04 lw	s6,4(a1)
[ 465] 0x900000001fc0712c:  ac d6 00 84 sw	s6,132(a2)
[ 465] 0x900000001fc07130:  8c b6 00 08 lw	s6,8(a1)
[ 465] 0x900000001fc07134:  ac d6 00 88 sw	s6,136(a2)
[ 465] 0x900000001fc07138:  8c b6 00 0c lw	s6,12(a1)
[ 465] 0x900000001fc0713c:  10 00 00 0f b		0x900000001fc0717c
[ 465] 0x900000001fc07140:  ac d6 00 8c sw	s6,140(a2)
[ 465] 0x900000001fc07144:  8e 37 00 00 lw	s7,0(s1)
[ 465] 0x900000001fc07148:  ae 57 00 80 sw	s7,128(s2)
[ 465] 0x900000001fc0714c:  8e 37 00 04 lw	s7,4(s1)
[ 465] 0x900000001fc07150:  ae 57 00 84 sw	s7,132(s2)
[ 465] 0x900000001fc07154:  8e 37 00 08 lw	s7,8(s1)
[ 465] 0x900000001fc07158:  ae 57 00 88 sw	s7,136(s2)
[ 465] 0x900000001fc0715c:  26 10 ff fc addiu	s0,s0,-4
[ 465] 0x900000001fc07160:  8e 38 00 0c lw	t8,12(s1)
[ 465] 0x900000001fc07164:  66 31 00 10 daddiu	s1,s1,16
[ 465] 0x900000001fc07168:  00 30 b8 2a slt	s7,at,s0
[ 465] 0x900000001fc0716c:  ae 58 00 8c sw	t8,140(s2)
[ 465] 0x900000001fc07170:  66 52 00 10 daddiu	s2,s2,16
[ 465] 0x900000001fc07174:  56 e0 ff f4 bnel	s7,zero,0x900000001fc07148
[ 465] 0x900000001fc07178:  8e 37 00 00 lw	s7,0(s1)
  466: 	
  467:     loprintf("Running BIST\n");
[ 467] 0x900000001fc0717c:  df be 00 20 ld	s8,32(sp)
[ 467] 0x900000001fc07180:  0f f0 2c e3 jal		loprintf
[ 467] 0x900000001fc07184:  67 c4 0a 90 daddiu	a0,s8,2704
  468: 
  469:     for (i = 0; i < EV_MAX_SLOTS; i ++) {
[ 469] 0x900000001fc07188:  00 00 98 25 move	s3,zero
[ 469] 0x900000001fc0718c:  67 d1 0a a0 daddiu	s1,s8,2720
[ 469] 0x900000001fc07190:  24 12 00 0f li	s2,15
[ 469] 0x900000001fc07194:  24 16 00 ff li	s6,255
[ 469] 0x900000001fc07198:  00 15 c8 04 sllv	t9,s5,zero
[ 469] 0x900000001fc0719c:  df d7 0b 80 ld	s7,2944(s8)
[ 469] 0x900000001fc071a0:  df de 09 00 ld	s8,2304(s8)
[ 469] 0x900000001fc071a4:  24 10 00 10 li	s0,16
[ 469] 0x900000001fc071a8:  02 99 08 24 and	at,s4,t9
  470: 	if (!((1 << i) & mem)) {
[ 470] 0x900000001fc071ac:  50 20 00 10 beql	at,zero,0x900000001fc071f0
[ 470] 0x900000001fc071b0:  26 73 00 01 addiu	s3,s3,1
  471: 	    continue;
  472: 	}
  473: 	loprintf("Starting BIST on slot %b\n", i); 
[ 473] 0x900000001fc071b4:  02 60 28 25 move	a1,s3
[ 473] 0x900000001fc071b8:  0f f0 2c e3 jal		loprintf
[ 473] 0x900000001fc071bc:  02 20 20 25 move	a0,s1
  474: 	EV_SET_CONFIG(i, MC3_BISTRESULT, 0xf);
[ 474] 0x900000001fc071c0:  00 13 fa c0 sll	ra,s3,11
[ 474] 0x900000001fc071c4:  df a1 00 20 ld	at,32(sp)
[ 474] 0x900000001fc071c8:  00 1f f8 3c dsll32	ra,ra,0
[ 474] 0x900000001fc071cc:  00 1f f8 3e dsrl32	ra,ra,0
[ 474] 0x900000001fc071d0:  dc 21 09 08 ld	at,2312(at)
[ 474] 0x900000001fc071d4:  03 e1 10 2d daddu	v0,ra,at
  475: 	EV_SET_CONFIG(i, MC3_LEAFCTLENB, 0xf);
[ 475] 0x900000001fc071d8:  03 f7 08 2d daddu	at,ra,s7
  476: 	EV_SET_CONFIG(i, MC3_BANKENB, 0xff);
[ 476] 0x900000001fc071dc:  03 fe f8 2d daddu	ra,ra,s8
[ 476] 0x900000001fc071e0:  fc 52 00 00 sd	s2,0(v0)
[ 476] 0x900000001fc071e4:  fc 32 00 00 sd	s2,0(at)
[ 476] 0x900000001fc071e8:  ff f6 00 00 sd	s6,0(ra)
[ 476] 0x900000001fc071ec:  26 73 00 01 addiu	s3,s3,1
[ 469] 0x900000001fc071f0:  02 75 08 04 sllv	at,s5,s3
[ 469] 0x900000001fc071f4:  16 70 ff ed bne	s3,s0,0x900000001fc071ac
[ 469] 0x900000001fc071f8:  02 81 08 24 and	at,s4,at
[ 469] 0x900000001fc071fc:  df a3 00 20 ld	v1,32(sp)
  477: 		
  478:     }
  479: 
  480:     time = LD_RTC();
  481:     timeout = time + MC3_BIST_TOUT;
  482: 
  483:     /* Wait for everyone to finish or a timeout */
  484:     for (i = 0; i < EV_MAX_SLOTS; i++) {
[ 484] 0x900000001fc07200:  64 76 0a c0 daddiu	s6,v1,2752
[ 484] 0x900000001fc07204:  dc 63 0b 88 ld	v1,2952(v1)
[ 484] 0x900000001fc07208:  dc 63 00 00 ld	v1,0(v1)
[ 481] 0x900000001fc0720c:  3c 02 00 b2 lui	v0,0xb2
[ 481] 0x900000001fc07210:  00 15 20 04 sllv	a0,s5,zero
[ 481] 0x900000001fc07214:  00 03 1a 3b dsra	v1,v1,8
[ 481] 0x900000001fc07218:  34 42 d0 50 ori	v0,v0,0xd050
[ 481] 0x900000001fc0721c:  00 03 88 00 sll	s1,v1,0
[ 481] 0x900000001fc07220:  02 84 08 24 and	at,s4,a0
[ 481] 0x900000001fc07224:  02 22 90 21 addu	s2,s1,v0
[ 481] 0x900000001fc07228:  00 00 98 25 move	s3,zero
  485: 	if (!((1 << i) & mem)) {
[ 485] 0x900000001fc0722c:  50 20 00 14 beql	at,zero,0x900000001fc07280
[ 485] 0x900000001fc07230:  26 73 00 01 addiu	s3,s3,1
  486: 	    continue;
  487: 	}
  488: 	loprintf("Waiting for slot %b\n", i);
[ 488] 0x900000001fc07234:  02 60 28 25 move	a1,s3
[ 488] 0x900000001fc07238:  0f f0 2c e3 jal		loprintf
[ 488] 0x900000001fc0723c:  02 c0 20 25 move	a0,s6
  489: 	while ((EV_GET_CONFIG(i, MC3_BISTRESULT) & 3) &&
[ 489] 0x900000001fc07240:  00 13 2a c0 sll	a1,s3,11
[ 489] 0x900000001fc07244:  df a6 00 20 ld	a2,32(sp)
[ 489] 0x900000001fc07248:  00 05 28 3c dsll32	a1,a1,0
[ 489] 0x900000001fc0724c:  00 05 28 3e dsrl32	a1,a1,0
[ 489] 0x900000001fc07250:  dc c6 09 08 ld	a2,2312(a2)
[ 489] 0x900000001fc07254:  00 a6 80 2d daddu	s0,a1,a2
[ 489] 0x900000001fc07258:  de 05 00 00 ld	a1,0(s0)
[ 489] 0x900000001fc0725c:  30 a5 00 03 andi	a1,a1,0x3
[ 489] 0x900000001fc07260:  50 a0 00 07 beql	a1,zero,0x900000001fc07280
[ 489] 0x900000001fc07264:  26 73 00 01 addiu	s3,s3,1
[ 489] 0x900000001fc07268:  02 40 28 25 move	a1,s2
[ 489] 0x900000001fc0726c:  0f f0 40 b6 jal		timed_out
[ 489] 0x900000001fc07270:  02 20 20 25 move	a0,s1
[ 489] 0x900000001fc07274:  50 40 00 9b beql	v0,zero,0x900000001fc074e4
[ 489] 0x900000001fc07278:  02 40 28 25 move	a1,s2
[ 484] 0x900000001fc0727c:  26 73 00 01 addiu	s3,s3,1
[ 484] 0x900000001fc07280:  02 75 40 04 sllv	a4,s5,s3
[ 484] 0x900000001fc07284:  df a7 00 28 ld	a3,40(sp)
[ 484] 0x900000001fc07288:  16 67 ff e8 bne	s3,a3,0x900000001fc0722c
[ 484] 0x900000001fc0728c:  02 88 08 24 and	at,s4,a4
[ 484] 0x900000001fc07290:  02 a0 28 25 move	a1,s5
  490: 	       !(timed_out(time, timeout)))
  491: 	    ;
  492:     }
  493: 	
  494:     if(diagval = mc3_reconfig(&evconfig, INTLV_STABLE))
[ 494] 0x900000001fc07294:  0f f0 50 2d jal		mc3_reconfig
[ 494] 0x900000001fc07298:  67 a4 00 80 daddiu	a0,sp,128
[ 494] 0x900000001fc0729c:  00 40 08 25 move	at,v0
[ 494] 0x900000001fc072a0:  14 20 00 05 bne	at,zero,0x900000001fc072b8
[ 494] 0x900000001fc072a4:  df a9 00 20 ld	a5,32(sp)
  495: 	loprintf(" *** %s\n", get_diag_string(diagval));
  496:     else
  497: 	loprintf("Memory reconfigured\n");
[ 497] 0x900000001fc072a8:  0f f0 2c e3 jal		loprintf
[ 497] 0x900000001fc072ac:  65 24 0a e8 daddiu	a0,a5,2792
[ 497] 0x900000001fc072b0:  10 00 00 08 b		0x900000001fc072d4
[ 497] 0x900000001fc072b4:  24 13 ff fc li	s3,-4
[ 495] 0x900000001fc072b8:  0f f0 3f 6c jal		get_diag_string
[ 495] 0x900000001fc072bc:  00 20 20 25 move	a0,at
[ 495] 0x900000001fc072c0:  00 40 28 25 move	a1,v0
[ 495] 0x900000001fc072c4:  df aa 00 20 ld	a6,32(sp)
[ 495] 0x900000001fc072c8:  0f f0 2c e3 jal		loprintf
[ 495] 0x900000001fc072cc:  65 44 0a d8 daddiu	a0,a6,2776
[ 495] 0x900000001fc072d0:  24 13 ff fc li	s3,-4
  498: 
  499:     loprintf("Restoring configuration information\n");
[ 499] 0x900000001fc072d4:  df b2 00 20 ld	s2,32(sp)
[ 499] 0x900000001fc072d8:  0f f0 2c e3 jal		loprintf
[ 499] 0x900000001fc072dc:  66 44 0b 00 daddiu	a0,s2,2816
  500: 
  501:     *EVCFGINFO = evconfig;
[ 501] 0x900000001fc072e0:  3c 0b 90 00 lui	a7,0x9000
[ 501] 0x900000001fc072e4:  61 6c 00 00 daddi	t0,a7,0
[ 501] 0x900000001fc072e8:  3c 0f 1f c2 lui	t3,0x1fc2
[ 501] 0x900000001fc072ec:  24 10 01 b8 li	s0,440
[ 501] 0x900000001fc072f0:  de 4e 0a 50 ld	t2,2640(s2)
[ 501] 0x900000001fc072f4:  24 0b ff fc li	a7,-4
[ 501] 0x900000001fc072f8:  8f b2 00 80 lw	s2,128(sp)
[ 501] 0x900000001fc072fc:  67 ad 00 04 daddiu	t1,sp,4
[ 501] 0x900000001fc07300:  61 ef 9b 40 daddi	t3,t3,-25792
[ 501] 0x900000001fc07304:  02 0b 58 2d daddu	a7,s0,a7
[ 501] 0x900000001fc07308:  ad d2 00 00 sw	s2,0(t2)
[ 501] 0x900000001fc0730c:  00 0c 60 3c dsll32	t0,t0,0
[ 501] 0x900000001fc07310:  02 13 98 2d daddu	s3,s0,s3
[ 501] 0x900000001fc07314:  24 01 00 03 li	at,3
[ 501] 0x900000001fc07318:  8d ad 00 80 lw	t1,128(t1)
[ 501] 0x900000001fc0731c:  00 2b 58 2a slt	a7,at,a7
[ 501] 0x900000001fc07320:  01 8f 60 2c dadd	t0,t0,t3
[ 501] 0x900000001fc07324:  ad cd 00 04 sw	t1,4(t2)
[ 501] 0x900000001fc07328:  26 67 ff fc addiu	a3,s3,-4
[ 501] 0x900000001fc0732c:  67 b1 00 08 daddiu	s1,sp,8
[ 501] 0x900000001fc07330:  dd 92 1e 00 ld	s2,7680(t0)
[ 501] 0x900000001fc07334:  11 60 00 2f beq	a7,zero,0x900000001fc073f4
[ 501] 0x900000001fc07338:  ff ac 00 20 sd	t0,32(sp)
[ 501] 0x900000001fc0733c:  02 20 20 25 move	a0,s1
[ 501] 0x900000001fc07340:  8e 22 00 80 lw	v0,128(s1)
[ 501] 0x900000001fc07344:  02 40 30 25 move	a2,s2
[ 501] 0x900000001fc07348:  ac c2 00 00 sw	v0,0(a2)
[ 501] 0x900000001fc0734c:  8c 83 00 84 lw	v1,132(a0)
[ 501] 0x900000001fc07350:  ac c3 00 04 sw	v1,4(a2)
[ 501] 0x900000001fc07354:  8c 83 00 88 lw	v1,136(a0)
[ 501] 0x900000001fc07358:  ac c3 00 08 sw	v1,8(a2)
[ 501] 0x900000001fc0735c:  64 85 00 10 daddiu	a1,a0,16
[ 501] 0x900000001fc07360:  8c 83 00 8c lw	v1,140(a0)
[ 501] 0x900000001fc07364:  ac c3 00 0c sw	v1,12(a2)
[ 501] 0x900000001fc07368:  64 c6 00 10 daddiu	a2,a2,16
[ 501] 0x900000001fc0736c:  00 27 18 2a slt	v1,at,a3
[ 501] 0x900000001fc07370:  24 e7 ff fc addiu	a3,a3,-4
[ 501] 0x900000001fc07374:  10 60 00 17 beq	v1,zero,0x900000001fc073d4
[ 501] 0x900000001fc07378:  8c a2 00 80 lw	v0,128(a1)
[ 501] 0x900000001fc0737c:  ac c2 00 00 sw	v0,0(a2)
[ 501] 0x900000001fc07380:  8c a3 00 84 lw	v1,132(a1)
[ 501] 0x900000001fc07384:  ac c3 00 04 sw	v1,4(a2)
[ 501] 0x900000001fc07388:  8c a3 00 88 lw	v1,136(a1)
[ 501] 0x900000001fc0738c:  ac c3 00 08 sw	v1,8(a2)
[ 501] 0x900000001fc07390:  64 a4 00 10 daddiu	a0,a1,16
[ 501] 0x900000001fc07394:  8c a3 00 8c lw	v1,140(a1)
[ 501] 0x900000001fc07398:  ac c3 00 0c sw	v1,12(a2)
[ 501] 0x900000001fc0739c:  64 c6 00 10 daddiu	a2,a2,16
[ 501] 0x900000001fc073a0:  00 27 18 2a slt	v1,at,a3
[ 501] 0x900000001fc073a4:  24 e7 ff fc addiu	a3,a3,-4
[ 501] 0x900000001fc073a8:  14 60 ff e7 bne	v1,zero,0x900000001fc07348
[ 501] 0x900000001fc073ac:  8c 82 00 80 lw	v0,128(a0)
[ 501] 0x900000001fc073b0:  ac c2 00 00 sw	v0,0(a2)
[ 501] 0x900000001fc073b4:  8c 94 00 84 lw	s4,132(a0)
[ 501] 0x900000001fc073b8:  ac d4 00 04 sw	s4,4(a2)
[ 501] 0x900000001fc073bc:  8c 94 00 88 lw	s4,136(a0)
[ 501] 0x900000001fc073c0:  ac d4 00 08 sw	s4,8(a2)
[ 501] 0x900000001fc073c4:  8c 94 00 8c lw	s4,140(a0)
[ 501] 0x900000001fc073c8:  ac d4 00 0c sw	s4,12(a2)
[ 501] 0x900000001fc073cc:  10 00 00 18 b		0x900000001fc07430
[ 501] 0x900000001fc073d0:  df b8 00 20 ld	t8,32(sp)
[ 501] 0x900000001fc073d4:  ac c2 00 00 sw	v0,0(a2)
[ 501] 0x900000001fc073d8:  8c b5 00 84 lw	s5,132(a1)
[ 501] 0x900000001fc073dc:  ac d5 00 04 sw	s5,4(a2)
[ 501] 0x900000001fc073e0:  8c b5 00 88 lw	s5,136(a1)
[ 501] 0x900000001fc073e4:  ac d5 00 08 sw	s5,8(a2)
[ 501] 0x900000001fc073e8:  8c b5 00 8c lw	s5,140(a1)
[ 501] 0x900000001fc073ec:  10 00 00 0f b		0x900000001fc0742c
[ 501] 0x900000001fc073f0:  ac d5 00 0c sw	s5,12(a2)
[ 501] 0x900000001fc073f4:  8e 36 00 80 lw	s6,128(s1)
[ 501] 0x900000001fc073f8:  ae 56 00 00 sw	s6,0(s2)
[ 501] 0x900000001fc073fc:  8e 36 00 84 lw	s6,132(s1)
[ 501] 0x900000001fc07400:  ae 56 00 04 sw	s6,4(s2)
[ 501] 0x900000001fc07404:  8e 36 00 88 lw	s6,136(s1)
[ 501] 0x900000001fc07408:  ae 56 00 08 sw	s6,8(s2)
[ 501] 0x900000001fc0740c:  26 10 ff fc addiu	s0,s0,-4
[ 501] 0x900000001fc07410:  8e 37 00 8c lw	s7,140(s1)
[ 501] 0x900000001fc07414:  66 31 00 10 daddiu	s1,s1,16
[ 501] 0x900000001fc07418:  00 30 b0 2a slt	s6,at,s0
[ 501] 0x900000001fc0741c:  ae 57 00 0c sw	s7,12(s2)
[ 501] 0x900000001fc07420:  66 52 00 10 daddiu	s2,s2,16
[ 501] 0x900000001fc07424:  56 c0 ff f4 bnel	s6,zero,0x900000001fc073f8
[ 501] 0x900000001fc07428:  8e 36 00 80 lw	s6,128(s1)
  502: 
  503:     loprintf("Recreating MPCONF blocks ");
[ 503] 0x900000001fc0742c:  df b8 00 20 ld	t8,32(sp)
[ 503] 0x900000001fc07430:  0f f0 2c e3 jal		loprintf
[ 503] 0x900000001fc07434:  67 04 0b 28 daddiu	a0,t8,2856
  504:     if (evconfig.ecfg_debugsw & VDS_NO_DIAGS)
[ 504] 0x900000001fc07438:  df b9 00 20 ld	t9,32(sp)
[ 504] 0x900000001fc0743c:  8f b8 07 58 lw	t8,1880(sp)
[ 504] 0x900000001fc07440:  33 18 00 10 andi	t8,t8,0x10
[ 504] 0x900000001fc07444:  17 00 00 05 bne	t8,zero,0x900000001fc0745c
[ 504] 0x900000001fc07448:  df be 00 20 ld	s8,32(sp)
  505: 	loprintf(" - NO DIAGS mode\n");
  506:     else
  507: 	loprintf(" and waiting for slaves.\n");
[ 507] 0x900000001fc0744c:  0f f0 2c e3 jal		loprintf
[ 507] 0x900000001fc07450:  67 24 0b 60 daddiu	a0,t9,2912
[ 507] 0x900000001fc07454:  10 00 00 04 b		0x900000001fc07468
[ 507] 0x900000001fc07458:  df b3 00 58 ld	s3,88(sp)
[ 505] 0x900000001fc0745c:  0f f0 2c e3 jal		loprintf
[ 505] 0x900000001fc07460:  67 c4 0b 48 daddiu	a0,s8,2888
[ 505] 0x900000001fc07464:  df b3 00 58 ld	s3,88(sp)
[ 505] 0x900000001fc07468:  df b1 00 68 ld	s1,104(sp)
  508: 
  509:     /* Set up mpconf structure and send interrupt to slaves. */
  510:     init_mpconf();
[ 510] 0x900000001fc0746c:  0f f0 54 30 jal		init_mpconf
[ 510] 0x900000001fc07470:  00 00 00 21 nada
  511:     GDA->g_vds = evconfig.ecfg_debugsw;
[ 511] 0x900000001fc07474:  df b5 00 48 ld	s5,72(sp)
[ 511] 0x900000001fc07478:  df a1 00 20 ld	at,32(sp)
[ 511] 0x900000001fc0747c:  df b6 00 40 ld	s6,64(sp)
[ 511] 0x900000001fc07480:  df be 00 30 ld	s8,48(sp)
[ 511] 0x900000001fc07484:  dc 21 0a 58 ld	at,2648(at)
[ 511] 0x900000001fc07488:  8f bf 07 58 lw	ra,1880(sp)
[ 511] 0x900000001fc0748c:  df b2 00 60 ld	s2,96(sp)
[ 511] 0x900000001fc07490:  df b4 00 50 ld	s4,80(sp)
[ 511] 0x900000001fc07494:  ac 3f 00 28 sw	ra,40(at)
  512:     if (!(evconfig.ecfg_debugsw & VDS_NO_DIAGS)) {
[ 512] 0x900000001fc07498:  8f bf 07 58 lw	ra,1880(sp)
[ 512] 0x900000001fc0749c:  df b7 00 38 ld	s7,56(sp)
[ 512] 0x900000001fc074a0:  33 ff 00 10 andi	ra,ra,0x10
[ 512] 0x900000001fc074a4:  df a1 00 20 ld	at,32(sp)
[ 512] 0x900000001fc074a8:  17 e0 00 0a bne	ra,zero,0x900000001fc074d4
[ 512] 0x900000001fc074ac:  df b0 00 70 ld	s0,112(sp)
  513: 	slot =  (int)((LD(EV_SPNUM) & EV_SLOTNUM_MASK) >> EV_SLOTNUM_SHFT);
[ 513] 0x900000001fc074b0:  dc 21 07 a0 ld	at,1952(at)
[ 513] 0x900000001fc074b4:  dc 22 00 00 ld	v0,0(at)
  514: 	slice = (int)((LD(EV_SPNUM) & EV_PROCNUM_MASK) >> EV_PROCNUM_SHFT);
[ 514] 0x900000001fc074b8:  30 42 00 3c andi	v0,v0,0x3c
[ 514] 0x900000001fc074bc:  dc 21 00 00 ld	at,0(at)
[ 514] 0x900000001fc074c0:  00 02 10 bb dsra	v0,v0,2
[ 514] 0x900000001fc074c4:  30 21 00 03 andi	at,at,0x3
  515: 	check_slaves(slot, slice);
[ 515] 0x900000001fc074c8:  00 02 20 00 sll	a0,v0,0
[ 515] 0x900000001fc074cc:  0f f0 38 23 jal		check_slaves
[ 515] 0x900000001fc074d0:  00 01 28 00 sll	a1,at,0
[ 515] 0x900000001fc074d4:  df bf 00 78 ld	ra,120(sp)
[ 515] 0x900000001fc074d8:  03 e0 00 08 jr	ra
[ 515] 0x900000001fc074dc:  67 bd 07 70 daddiu	sp,sp,1904
[ 515] 0x900000001fc074e0:  02 40 28 25 move	a1,s2
[ 515] 0x900000001fc074e4:  de 06 00 00 ld	a2,0(s0)
[ 515] 0x900000001fc074e8:  30 c6 00 03 andi	a2,a2,0x3
[ 515] 0x900000001fc074ec:  50 c0 ff 64 beql	a2,zero,0x900000001fc07280
[ 515] 0x900000001fc074f0:  26 73 00 01 addiu	s3,s3,1
[ 515] 0x900000001fc074f4:  0f f0 40 b6 jal		timed_out
[ 515] 0x900000001fc074f8:  02 20 20 25 move	a0,s1
[ 515] 0x900000001fc074fc:  10 40 ff f8 beq	v0,zero,0x900000001fc074e0
[ 515] 0x900000001fc07500:  00 00 00 21 nada
[ 515] 0x900000001fc07504:  10 00 ff 5d b		0x900000001fc0727c
[ 515] 0x900000001fc07508:  00 00 00 21 nada
  516:     }
  517: }
  518: #if 0
  519: static int nbpps[] = {
  520:     4  * 1024,
  521:     16 * 1024,
  522:     0
  523: };
  524: 
  525: static int pnumshfts[] = {
  526:     12,
  527:     14,
  528:     0
  529: };
  530: 
  531: static long tlbhi_vpnmasks[] = {
  532:     0xfffffffffffff000,
  533:     0xffffffffffffc000,
  534:     0
  535: };
  536: #endif
  537: 
  538: char *cache_alg[] = {
  539:     "Uncached CPU",
  540:     "Rsrvd Cache Alg",
  541:     "Uncached Seq",
  542:     "Cached Non-coh",
  543:     "Cached Coh Exc",
  544:     "Cached Coh Exc/Wr",
  545:     "Rsrvd Cache Alg",
  546:     "Rsrvd Cache Alg"
  547: };
  548: 
  549: void 
  550: dump_entry(int index)
  551: {
dump_entry:
[ 551] 0x900000001fc0750c:  67 bd ff b0 daddiu	sp,sp,-80
  552:     __uint64_t lo0, lo1, hi;
  553: 
  554:     hi = get_enhi(index);
[ 554] 0x900000001fc07510:  ff b0 00 48 sd	s0,72(sp)
[ 554] 0x900000001fc07514:  00 80 80 25 move	s0,a0
[ 554] 0x900000001fc07518:  ff bf 00 30 sd	ra,48(sp)
[ 554] 0x900000001fc0751c:  0f f0 17 38 jal		get_enhi
[ 554] 0x900000001fc07520:  ff a4 00 20 sd	a0,32(sp)
[ 554] 0x900000001fc07524:  ff a2 00 28 sd	v0,40(sp)
  555:     lo0 = get_enlo(index, 0);
[ 555] 0x900000001fc07528:  00 00 28 25 move	a1,zero
[ 555] 0x900000001fc0752c:  0f f0 17 3d jal		get_enlo
[ 555] 0x900000001fc07530:  02 00 20 25 move	a0,s0
[ 555] 0x900000001fc07534:  ff b1 00 40 sd	s1,64(sp)
[ 555] 0x900000001fc07538:  00 40 88 25 move	s1,v0
  556:     lo1 = get_enlo(index, 1);
[ 556] 0x900000001fc0753c:  24 05 00 01 li	a1,1
[ 556] 0x900000001fc07540:  0f f0 17 3d jal		get_enlo
[ 556] 0x900000001fc07544:  02 00 20 25 move	a0,s0
  557: 
  558:     loprintf("%b: ASID %b, VPN %x -> PFN %x, %c%c%c; PFN %x, %c%c%c\n",
[ 558] 0x900000001fc07548:  00 40 80 25 move	s0,v0
[ 558] 0x900000001fc0754c:  32 21 00 04 andi	at,s1,0x4
[ 558] 0x900000001fc07550:  10 20 00 02 beq	at,zero,0x900000001fc0755c
[ 558] 0x900000001fc07554:  24 19 00 20 li	t9,32
[ 558] 0x900000001fc07558:  24 19 00 44 li	t9,68
[ 558] 0x900000001fc0755c:  03 20 48 25 move	a5,t9
[ 558] 0x900000001fc07560:  32 38 00 02 andi	t8,s1,0x2
[ 558] 0x900000001fc07564:  ff b2 00 38 sd	s2,56(sp)
[ 558] 0x900000001fc07568:  13 00 00 02 beq	t8,zero,0x900000001fc07574
[ 558] 0x900000001fc0756c:  24 12 00 20 li	s2,32
[ 558] 0x900000001fc07570:  24 12 00 56 li	s2,86
[ 558] 0x900000001fc07574:  32 39 00 01 andi	t9,s1,0x1
[ 558] 0x900000001fc07578:  02 40 50 25 move	a6,s2
[ 558] 0x900000001fc0757c:  24 0b 00 20 li	a7,32
[ 558] 0x900000001fc07580:  00 19 c8 00 sll	t9,t9,0
[ 558] 0x900000001fc07584:  53 20 00 03 beql	t9,zero,0x900000001fc07594
[ 558] 0x900000001fc07588:  01 60 90 25 move	s2,a7
[ 558] 0x900000001fc0758c:  24 0b 00 47 li	a7,71
[ 558] 0x900000001fc07590:  01 60 90 25 move	s2,a7
[ 558] 0x900000001fc07594:  32 1f 00 04 andi	ra,s0,0x4
[ 558] 0x900000001fc07598:  13 e0 00 02 beq	ra,zero,0x900000001fc075a4
[ 558] 0x900000001fc0759c:  24 19 00 20 li	t9,32
[ 558] 0x900000001fc075a0:  24 19 00 44 li	t9,68
[ 558] 0x900000001fc075a4:  03 20 10 25 move	v0,t9
[ 558] 0x900000001fc075a8:  32 01 00 02 andi	at,s0,0x2
[ 558] 0x900000001fc075ac:  10 20 00 02 beq	at,zero,0x900000001fc075b8
[ 558] 0x900000001fc075b0:  24 0b 00 20 li	a7,32
[ 558] 0x900000001fc075b4:  24 0b 00 56 li	a7,86
[ 558] 0x900000001fc075b8:  32 04 00 01 andi	a0,s0,0x1
[ 558] 0x900000001fc075bc:  24 19 00 20 li	t9,32
[ 558] 0x900000001fc075c0:  00 04 20 00 sll	a0,a0,0
[ 558] 0x900000001fc075c4:  af a2 00 0c sw	v0,12(sp)
[ 558] 0x900000001fc075c8:  50 80 00 03 beql	a0,zero,0x900000001fc075d8
[ 558] 0x900000001fc075cc:  00 11 41 ba dsrl	a4,s1,6
[ 558] 0x900000001fc075d0:  24 19 00 47 li	t9,71
[ 558] 0x900000001fc075d4:  00 11 41 ba dsrl	a4,s1,6
[ 558] 0x900000001fc075d8:  df b1 00 40 ld	s1,64(sp)
[ 558] 0x900000001fc075dc:  01 60 18 25 move	v1,a7
[ 558] 0x900000001fc075e0:  00 10 29 ba dsrl	a1,s0,6
[ 558] 0x900000001fc075e4:  df b0 00 48 ld	s0,72(sp)
[ 558] 0x900000001fc075e8:  02 40 58 25 move	a7,s2
[ 558] 0x900000001fc075ec:  df b2 00 38 ld	s2,56(sp)
[ 558] 0x900000001fc075f0:  3c 06 90 00 lui	a2,0x9000
[ 558] 0x900000001fc075f4:  af b9 00 1c sw	t9,28(sp)
[ 558] 0x900000001fc075f8:  60 cc 00 00 daddi	t0,a2,0
[ 558] 0x900000001fc075fc:  3c 07 1f c2 lui	a3,0x1fc2
[ 558] 0x900000001fc07600:  df a6 00 28 ld	a2,40(sp)
[ 558] 0x900000001fc07604:  60 ed a6 d0 daddi	t1,a3,-22832
[ 558] 0x900000001fc07608:  00 06 3b 7a dsrl	a3,a2,13
[ 558] 0x900000001fc0760c:  30 c6 00 ff andi	a2,a2,0xff
[ 558] 0x900000001fc07610:  00 0c 60 3c dsll32	t0,t0,0
[ 558] 0x900000001fc07614:  ff a5 00 00 sd	a1,0(sp)
[ 558] 0x900000001fc07618:  df a5 00 20 ld	a1,32(sp)
[ 558] 0x900000001fc0761c:  00 07 38 78 dsll	a3,a3,1
[ 558] 0x900000001fc07620:  af a3 00 14 sw	v1,20(sp)
[ 558] 0x900000001fc07624:  0f f0 2c e3 jal		loprintf
[ 558] 0x900000001fc07628:  01 8d 20 2c dadd	a0,t0,t1
  559: 	     index,
  560: 	     hi & 0xff,
  561: 	     (hi >> 13) << 1,
  562: 	     lo0 >>6,
  563: 	     lo0 & TLBLO_D ? (int)'D' : 0x20,
  564: 	     lo0 & TLBLO_V ? (int)'V' : 0x20,
  565: 	     lo0 & TLBLO_G ? (int)'G' : 0x20,
  566: 	     lo1 >>6,
  567: 	     lo1 & TLBLO_D ? (int)'D' : 0x20,
  568: 	     lo1 & TLBLO_V ? (int)'V' : 0x20,
  569: 	     lo1 & TLBLO_G ? (int)'G' : 0x20);
  570: }
[ 570] 0x900000001fc0762c:  df bf 00 30 ld	ra,48(sp)
[ 570] 0x900000001fc07630:  03 e0 00 08 jr	ra
[ 570] 0x900000001fc07634:  67 bd 00 50 daddiu	sp,sp,80
  571: 
  572: void 
  573: tlb_dump(int *arg, int arg_val)
  574: {
tlb_dump:
[ 574] 0x900000001fc07638:  67 bd ff d0 daddiu	sp,sp,-48
  575:     int i;
  576: 
  577:     if (!lo_strcmp(arg, "all")) {
[ 577] 0x900000001fc0763c:  3c 01 90 00 lui	at,0x9000
[ 577] 0x900000001fc07640:  ff b2 00 10 sd	s2,16(sp)
[ 577] 0x900000001fc07644:  00 a0 90 25 move	s2,a1
[ 577] 0x900000001fc07648:  60 21 00 00 daddi	at,at,0
[ 577] 0x900000001fc0764c:  3c 02 1f c2 lui	v0,0x1fc2
[ 577] 0x900000001fc07650:  3c 03 90 00 lui	v1,0x9000
[ 577] 0x900000001fc07654:  60 42 a7 07 daddi	v0,v0,-22777
[ 577] 0x900000001fc07658:  ff b0 00 20 sd	s0,32(sp)
[ 577] 0x900000001fc0765c:  60 70 00 00 daddi	s0,v1,0
[ 577] 0x900000001fc07660:  00 01 08 3c dsll32	at,at,0
[ 577] 0x900000001fc07664:  ff bf 00 28 sd	ra,40(sp)
[ 577] 0x900000001fc07668:  0f f0 35 f5 jal		lo_strcmp
[ 577] 0x900000001fc0766c:  00 22 28 2c dadd	a1,at,v0
[ 577] 0x900000001fc07670:  3c 03 1f c2 lui	v1,0x1fc2
[ 577] 0x900000001fc07674:  00 10 08 3c dsll32	at,s0,0
[ 577] 0x900000001fc07678:  ff b3 00 08 sd	s3,8(sp)
[ 577] 0x900000001fc0767c:  00 00 80 25 move	s0,zero
[ 577] 0x900000001fc07680:  60 73 9b 40 daddi	s3,v1,-25792
[ 577] 0x900000001fc07684:  ff b1 00 18 sd	s1,24(sp)
[ 577] 0x900000001fc07688:  24 11 00 40 li	s1,64
[ 577] 0x900000001fc0768c:  00 33 08 2c dadd	at,at,s3
[ 577] 0x900000001fc07690:  df b3 00 08 ld	s3,8(sp)
[ 577] 0x900000001fc07694:  ff a1 00 00 sd	at,0(sp)
[ 577] 0x900000001fc07698:  10 40 00 0e beq	v0,zero,0x900000001fc076d4
[ 577] 0x900000001fc0769c:  2a 59 00 40 slti	t9,s2,64
  578: 	for (i=0; i < NTLBENTRIES; i++)
  579: 	    dump_entry(i);
  580:     } else if (arg_val >= 0 && arg_val < NTLBENTRIES) {
[ 580] 0x900000001fc076a0:  06 42 00 04 bltzl	s2,0x900000001fc076b4
[ 580] 0x900000001fc076a4:  df b8 00 00 ld	t8,0(sp)
[ 580] 0x900000001fc076a8:  17 20 00 06 bne	t9,zero,0x900000001fc076c4
[ 580] 0x900000001fc076ac:  00 00 00 21 nada
  581: 	dump_entry(arg_val);
  582:     } else
  583: 	loprintf("*** TLB slot out of range.\n");
[ 583] 0x900000001fc076b0:  df b8 00 00 ld	t8,0(sp)
[ 583] 0x900000001fc076b4:  0f f0 2c e3 jal		loprintf
[ 583] 0x900000001fc076b8:  67 04 0b d0 daddiu	a0,t8,3024
[ 583] 0x900000001fc076bc:  10 00 00 0b b		0x900000001fc076ec
[ 583] 0x900000001fc076c0:  df b0 00 20 ld	s0,32(sp)
[ 581] 0x900000001fc076c4:  0f f0 1d 43 jal		dump_entry
[ 581] 0x900000001fc076c8:  02 40 20 25 move	a0,s2
[ 581] 0x900000001fc076cc:  10 00 00 07 b		0x900000001fc076ec
[ 581] 0x900000001fc076d0:  df b0 00 20 ld	s0,32(sp)
[ 579] 0x900000001fc076d4:  0f f0 1d 43 jal		dump_entry
[ 579] 0x900000001fc076d8:  02 00 20 25 move	a0,s0
[ 578] 0x900000001fc076dc:  26 10 00 01 addiu	s0,s0,1
[ 578] 0x900000001fc076e0:  16 11 ff fc bne	s0,s1,0x900000001fc076d4
[ 578] 0x900000001fc076e4:  00 00 00 21 nada
[ 578] 0x900000001fc076e8:  df b0 00 20 ld	s0,32(sp)
[ 578] 0x900000001fc076ec:  df bf 00 28 ld	ra,40(sp)
[ 578] 0x900000001fc076f0:  df b1 00 18 ld	s1,24(sp)
[ 578] 0x900000001fc076f4:  df b2 00 10 ld	s2,16(sp)
[ 578] 0x900000001fc076f8:  03 e0 00 08 jr	ra
[ 578] 0x900000001fc076fc:  67 bd 00 30 daddiu	sp,sp,48
  584: }
  585: 
  586: 
  587: void 
  588: dump_evcfg(int *arg, int arg_val)
  589: {
dump_evcfg:
[ 589] 0x900000001fc07700:  67 bd ff d0 daddiu	sp,sp,-48
[ 589] 0x900000001fc07704:  ff b2 00 10 sd	s2,16(sp)
[ 589] 0x900000001fc07708:  00 a0 90 25 move	s2,a1
  590:     uint slot = 0;
[ 590] 0x900000001fc0770c:  ff b0 00 20 sd	s0,32(sp)
  591:     uint present;
  592:     uint mask = 1;
  593: 
  594:     if (!lo_strcmp(arg, "all")) {
[ 594] 0x900000001fc07710:  3c 01 90 00 lui	at,0x9000
[ 594] 0x900000001fc07714:  3c 02 1f c2 lui	v0,0x1fc2
[ 594] 0x900000001fc07718:  60 21 00 00 daddi	at,at,0
[ 594] 0x900000001fc0771c:  60 42 a7 2c daddi	v0,v0,-22740
[ 594] 0x900000001fc07720:  3c 05 90 00 lui	a1,0x9000
[ 594] 0x900000001fc07724:  ff b4 00 00 sd	s4,0(sp)
[ 594] 0x900000001fc07728:  3c 03 1f c2 lui	v1,0x1fc2
[ 594] 0x900000001fc0772c:  60 b4 00 00 daddi	s4,a1,0
[ 594] 0x900000001fc07730:  ff b3 00 08 sd	s3,8(sp)
[ 594] 0x900000001fc07734:  60 73 9b 40 daddi	s3,v1,-25792
[ 594] 0x900000001fc07738:  00 00 80 25 move	s0,zero
[ 594] 0x900000001fc0773c:  00 01 08 3c dsll32	at,at,0
[ 594] 0x900000001fc07740:  ff bf 00 28 sd	ra,40(sp)
[ 594] 0x900000001fc07744:  0f f0 35 f5 jal		lo_strcmp
[ 594] 0x900000001fc07748:  00 22 28 2c dadd	a1,at,v0
[ 594] 0x900000001fc0774c:  ff b1 00 18 sd	s1,24(sp)
[ 594] 0x900000001fc07750:  2a 51 00 10 slti	s1,s2,16
[ 594] 0x900000001fc07754:  00 14 08 3c dsll32	at,s4,0
[ 594] 0x900000001fc07758:  00 33 98 2c dadd	s3,at,s3
[ 594] 0x900000001fc0775c:  10 40 00 0d beq	v0,zero,0x900000001fc07794
[ 594] 0x900000001fc07760:  df b4 00 00 ld	s4,0(sp)
  595: 
  596: 	loprintf("Memory size: %d M\n", EVCFGINFO->ecfg_memsize >> 12);
  597: 	loprintf("Bus clock frequency: %d MHz\n", 
  598: 	       EVCFGINFO->ecfg_clkfreq / 1000000);
  599: 	loprintf("Virtual dip switches: 0x%x\n", EVCFGINFO->ecfg_debugsw);
  600: 
  601: 	/* Rick assures us there'll never be a slot 0.
  602: 	 * I'm not counting on it.
  603: 	 */
  604: 	present = occupied_slots();
  605: 
  606: 	for (;present != 0; slot++, mask <<= 1) {
  607: 	    /* Don't print slot 0 unless it actually has something in it */
  608: 	    if ((slot != 0) || (present & 0x01))
  609: 		dump_evconfig_entry(slot);
  610: 	    present >>= 1;
  611: 	} /* for ... */
  612: 
  613:     } else if (arg_val >= 0 && arg_val < EV_MAX_SLOTS) {
[ 613] 0x900000001fc07764:  06 40 00 03 bltz	s2,0x900000001fc07774
[ 613] 0x900000001fc07768:  00 00 00 21 nada
[ 613] 0x900000001fc0776c:  16 20 00 05 bne	s1,zero,0x900000001fc07784
[ 613] 0x900000001fc07770:  00 00 00 21 nada
  614: 	dump_evconfig_entry(arg_val);
  615:     } else {
  616: 	loprintf("*** Slot out of range\n");
[ 616] 0x900000001fc07774:  0f f0 2c e3 jal		loprintf
[ 616] 0x900000001fc07778:  66 64 0c 48 daddiu	a0,s3,3144
[ 616] 0x900000001fc0777c:  10 00 00 24 b		0x900000001fc07810
[ 616] 0x900000001fc07780:  df b1 00 18 ld	s1,24(sp)
[ 614] 0x900000001fc07784:  0f f0 45 a9 jal		dump_evconfig_entry
[ 614] 0x900000001fc07788:  02 40 20 25 move	a0,s2
[ 614] 0x900000001fc0778c:  10 00 00 20 b		0x900000001fc07810
[ 614] 0x900000001fc07790:  df b1 00 18 ld	s1,24(sp)
[ 596] 0x900000001fc07794:  de 71 0a 50 ld	s1,2640(s3)
[ 596] 0x900000001fc07798:  66 64 0b f0 daddiu	a0,s3,3056
[ 596] 0x900000001fc0779c:  8e 38 06 d0 lw	t8,1744(s1)
[ 596] 0x900000001fc077a0:  0f f0 2c e3 jal		loprintf
[ 596] 0x900000001fc077a4:  00 18 2b 02 srl	a1,t8,12
[ 597] 0x900000001fc077a8:  3c 18 00 0f lui	t8,0xf
[ 597] 0x900000001fc077ac:  37 19 42 40 ori	t9,t8,0x4240
[ 597] 0x900000001fc077b0:  8e 38 06 cc lw	t8,1740(s1)
[ 597] 0x900000001fc077b4:  03 19 00 1b divu	t8,t9
[ 597] 0x900000001fc077b8:  66 64 0c 08 daddiu	a0,s3,3080
[ 597] 0x900000001fc077bc:  0f f0 2c e3 jal		loprintf
[ 597] 0x900000001fc077c0:  00 00 28 12 mflo	a1
[ 599] 0x900000001fc077c4:  8e 25 06 d8 lw	a1,1752(s1)
[ 599] 0x900000001fc077c8:  0f f0 2c e3 jal		loprintf
[ 599] 0x900000001fc077cc:  66 64 0c 28 daddiu	a0,s3,3112
[ 604] 0x900000001fc077d0:  0f f0 17 1b jal		occupied_slots
[ 604] 0x900000001fc077d4:  00 00 00 21 nada
[ 604] 0x900000001fc077d8:  00 40 88 25 move	s1,v0
[ 606] 0x900000001fc077dc:  52 20 00 0c beql	s1,zero,0x900000001fc07810
[ 606] 0x900000001fc077e0:  df b1 00 18 ld	s1,24(sp)
[ 608] 0x900000001fc077e4:  16 00 00 03 bne	s0,zero,0x900000001fc077f4
[ 608] 0x900000001fc077e8:  32 32 00 01 andi	s2,s1,0x1
[ 608] 0x900000001fc077ec:  52 40 00 04 beql	s2,zero,0x900000001fc07800
[ 608] 0x900000001fc077f0:  26 10 00 01 addiu	s0,s0,1
[ 609] 0x900000001fc077f4:  0f f0 45 a9 jal		dump_evconfig_entry
[ 609] 0x900000001fc077f8:  02 00 20 25 move	a0,s0
[ 609] 0x900000001fc077fc:  26 10 00 01 addiu	s0,s0,1
[ 610] 0x900000001fc07800:  00 11 88 42 srl	s1,s1,1
[ 606] 0x900000001fc07804:  16 20 ff f7 bne	s1,zero,0x900000001fc077e4
[ 606] 0x900000001fc07808:  00 00 00 21 nada
[ 606] 0x900000001fc0780c:  df b1 00 18 ld	s1,24(sp)
[ 606] 0x900000001fc07810:  df bf 00 28 ld	ra,40(sp)
[ 606] 0x900000001fc07814:  df b2 00 10 ld	s2,16(sp)
[ 606] 0x900000001fc07818:  df b0 00 20 ld	s0,32(sp)
[ 606] 0x900000001fc0781c:  df b3 00 08 ld	s3,8(sp)
[ 606] 0x900000001fc07820:  03 e0 00 08 jr	ra
[ 606] 0x900000001fc07824:  67 bd 00 30 daddiu	sp,sp,48
  617:     }
  618: }
  619: 
  620: 
  621: void 
  622: dump_mpconf(uint arg_val)
  623: {
dump_mpconf:
[ 623] 0x900000001fc07828:  67 bd ff e0 daddiu	sp,sp,-32
[ 623] 0x900000001fc0782c:  00 80 28 25 move	a1,a0
  624:     mpconf_t *mpc;
  625: 
  626:     if (arg_val > EV_MAX_CPUS) {
[ 626] 0x900000001fc07830:  3c 01 90 00 lui	at,0x9000
[ 626] 0x900000001fc07834:  3c 02 1f c2 lui	v0,0x1fc2
[ 626] 0x900000001fc07838:  ff b1 00 00 sd	s1,0(sp)
[ 626] 0x900000001fc0783c:  60 21 00 00 daddi	at,at,0
[ 626] 0x900000001fc07840:  60 43 9b 40 daddi	v1,v0,-25792
[ 626] 0x900000001fc07844:  00 01 10 3c dsll32	v0,at,0
[ 626] 0x900000001fc07848:  2c a1 00 35 sltiu	at,a1,53
[ 626] 0x900000001fc0784c:  ff b0 00 08 sd	s0,8(sp)
[ 626] 0x900000001fc07850:  10 20 00 24 beq	at,zero,0x900000001fc078e4
[ 626] 0x900000001fc07854:  00 43 80 2c dadd	s0,v0,v1
  627:        loprintf("*** VPID out of range\n");
  628:         return;
  629:     }
  630: 
  631:     mpc = &(MPCONF[arg_val]);
[ 631] 0x900000001fc07858:  00 05 30 3c dsll32	a2,a1,0
  632: 
  633:    loprintf("MPCONF entry for VPID %b (0x%x):\n", arg_val, mpc);
[ 633] 0x900000001fc0785c:  66 04 0c 78 daddiu	a0,s0,3192
[ 633] 0x900000001fc07860:  00 06 36 ba dsrl	a2,a2,26
[ 633] 0x900000001fc07864:  de 07 0d 48 ld	a3,3400(s0)
[ 633] 0x900000001fc07868:  00 c7 88 2f dsubu	s1,a2,a3
[ 633] 0x900000001fc0786c:  ff bf 00 10 sd	ra,16(sp)
[ 633] 0x900000001fc07870:  0f f0 2c e3 jal		loprintf
[ 633] 0x900000001fc07874:  02 20 30 25 move	a2,s1
  634: 
  635:    loprintf("  Magic:       %x\n", mpc->mpconf_magic);
[ 635] 0x900000001fc07878:  8e 25 00 00 lw	a1,0(s1)
[ 635] 0x900000001fc0787c:  0f f0 2c e3 jal		loprintf
[ 635] 0x900000001fc07880:  66 04 0c a0 daddiu	a0,s0,3232
  636:    loprintf("  Phys ID:     %b/%b\n",
[ 636] 0x900000001fc07884:  92 26 00 08 lbu	a2,8(s1)
[ 636] 0x900000001fc07888:  66 04 0c b8 daddiu	a0,s0,3256
[ 636] 0x900000001fc0788c:  30 c5 00 3c andi	a1,a2,0x3c
[ 636] 0x900000001fc07890:  30 c6 00 03 andi	a2,a2,0x3
[ 636] 0x900000001fc07894:  0f f0 2c e3 jal		loprintf
[ 636] 0x900000001fc07898:  00 05 28 83 sra	a1,a1,2
  637:                         (EV_SLOTNUM_MASK & mpc->phys_id) >> EV_SLOTNUM_SHFT,
  638:                         (EV_PROCNUM_MASK & mpc->phys_id) >> EV_PROCNUM_SHFT);
  639:    loprintf("  Virt ID:     %b\n", mpc->virt_id);
[ 639] 0x900000001fc0789c:  92 25 00 09 lbu	a1,9(s1)
[ 639] 0x900000001fc078a0:  0f f0 2c e3 jal		loprintf
[ 639] 0x900000001fc078a4:  66 04 0c d0 daddiu	a0,s0,3280
  640:    loprintf("  Launch:      %x\n", mpc->launch);
[ 640] 0x900000001fc078a8:  8e 25 00 0c lw	a1,12(s1)
[ 640] 0x900000001fc078ac:  0f f0 2c e3 jal		loprintf
[ 640] 0x900000001fc078b0:  66 04 0c e8 daddiu	a0,s0,3304
  641:    loprintf("  Launch parm: %x\n", mpc->lnch_parm);
[ 641] 0x900000001fc078b4:  8e 25 00 2c lw	a1,44(s1)
[ 641] 0x900000001fc078b8:  0f f0 2c e3 jal		loprintf
[ 641] 0x900000001fc078bc:  66 04 0d 00 daddiu	a0,s0,3328
  642:    loprintf("  ERTOIP:      %x\n", mpc->ertoip);
[ 642] 0x900000001fc078c0:  8e 25 00 14 lw	a1,20(s1)
[ 642] 0x900000001fc078c4:  0f f0 2c e3 jal		loprintf
[ 642] 0x900000001fc078c8:  66 04 0d 18 daddiu	a0,s0,3352
  643:    loprintf("  CPU Rev:     %x\n", mpc->pr_id);
[ 643] 0x900000001fc078cc:  8e 25 00 34 lw	a1,52(s1)
[ 643] 0x900000001fc078d0:  df b1 00 00 ld	s1,0(sp)
[ 643] 0x900000001fc078d4:  0f f0 2c e3 jal		loprintf
[ 643] 0x900000001fc078d8:  66 04 0d 30 daddiu	a0,s0,3376
  644: }
[ 644] 0x900000001fc078dc:  10 00 00 05 b		0x900000001fc078f4
[ 644] 0x900000001fc078e0:  df b0 00 08 ld	s0,8(sp)
[ 627] 0x900000001fc078e4:  ff bf 00 10 sd	ra,16(sp)
[ 627] 0x900000001fc078e8:  0f f0 2c e3 jal		loprintf
[ 627] 0x900000001fc078ec:  66 04 0c 60 daddiu	a0,s0,3168
[ 628] 0x900000001fc078f0:  df b0 00 08 ld	s0,8(sp)
[ 628] 0x900000001fc078f4:  df bf 00 10 ld	ra,16(sp)
[ 628] 0x900000001fc078f8:  03 e0 00 08 jr	ra
[ 628] 0x900000001fc078fc:  67 bd 00 20 daddiu	sp,sp,32
  645: 
  646: #define	ICACHE_ADDR(line, way)	(((line) * CACHE_ILINE_SIZE) + K0BASE + (way))
  647: #define	DCACHE_ADDR(line, way)  (((line) * CACHE_DLINE_SIZE) + K0BASE + (way))
  648: #define	SCACHE_ADDR(line, way)  (((line) * CACHE_SLINE_SIZE) + K0BASE + (way))
  649: #define	HEX(x)	((x) > 9 ? ('a' - 10 + (x)) : '0' + (x))
  650: 
  651: static	void
  652: printPrimaryInstructionCacheLine(il_t *il, __uint64_t addr, int contents)
  653: /*
  654:  * Function: printPrimaryInstructionCacheLine
  655:  * Purpose: To print out a primary cache line
  656:  * Parameters:	il - pointer to fillled in "i-cache" struct.
  657:  *		addr - address used
  658:  *		contents - if true, contents of line are displayed.
  659:  * Returns: nothing
  660:  */
  661: {
printPrimaryInstructionCacheLine:
[ 661] 0x900000001fc07900:  67 bd ff 80 daddiu	sp,sp,-128
[ 661] 0x900000001fc07904:  ff b0 00 68 sd	s0,104(sp)
[ 661] 0x900000001fc07908:  00 80 80 25 move	s0,a0
[ 661] 0x900000001fc0790c:  ff b3 00 50 sd	s3,80(sp)
[ 661] 0x900000001fc07910:  00 a0 98 25 move	s3,a1
[ 661] 0x900000001fc07914:  ff b2 00 58 sd	s2,88(sp)
[ 661] 0x900000001fc07918:  00 c0 90 25 move	s2,a2
  662: #   define	STATEMOD(t) (((t) & CTP_STATEMOD_MASK) >> CTP_STATEMOD_SHFT)
  663:     static char * stateMod[] = {
  664: 	"invalid", 
  665: 	"normal ",
  666: 	"incon  ",
  667: 	"invalid",
  668: 	"refill ",
  669: 	"invalid",
  670: 	"invalid"
  671:     };
  672: 
  673: #   define	STATE(t) (((t) & CTP_STATE_MASK) >> CTP_STATE_SHFT)
  674:     static char * state[] = {
  675: 	"invalid  ",
  676: 	"shared   ",
  677: 	"clean-ex ",
  678: 	"dirty-ex "
  679:     };
  680:     int	i;
  681: 
  682:     loprintf("Tag 0x%x address=0x%x s=(%d)%s sm=(%d)%s ",
[ 682] 0x900000001fc0791c:  3c 01 90 00 lui	at,0x9000
[ 682] 0x900000001fc07920:  3c 02 1f c2 lui	v0,0x1fc2
[ 682] 0x900000001fc07924:  60 21 00 00 daddi	at,at,0
[ 682] 0x900000001fc07928:  ff b6 00 38 sd	s6,56(sp)
[ 682] 0x900000001fc0792c:  60 42 9b 40 daddi	v0,v0,-25792
[ 682] 0x900000001fc07930:  3c 03 90 00 lui	v1,0x9000
[ 682] 0x900000001fc07934:  ff b4 00 48 sd	s4,72(sp)
[ 682] 0x900000001fc07938:  00 01 08 3c dsll32	at,at,0
[ 682] 0x900000001fc0793c:  dc 96 00 00 ld	s6,0(a0)
[ 682] 0x900000001fc07940:  60 63 00 00 daddi	v1,v1,0
[ 682] 0x900000001fc07944:  ff b1 00 60 sd	s1,96(sp)
[ 682] 0x900000001fc07948:  00 22 88 2c dadd	s1,at,v0
[ 682] 0x900000001fc0794c:  ff a6 00 10 sd	a2,16(sp)
[ 682] 0x900000001fc07950:  00 03 a0 3c dsll32	s4,v1,0
[ 682] 0x900000001fc07954:  ff b7 00 30 sd	s7,48(sp)
[ 682] 0x900000001fc07958:  ff bf 00 70 sd	ra,112(sp)
[ 682] 0x900000001fc0795c:  0f f0 05 88 jal		iCacheSize
[ 682] 0x900000001fc07960:  de 37 0d c8 ld	s7,3528(s1)
[ 682] 0x900000001fc07964:  de 05 00 00 ld	a1,0(s0)
[ 682] 0x900000001fc07968:  24 43 00 01 addiu	v1,v0,1
[ 682] 0x900000001fc0796c:  02 d7 08 24 and	at,s6,s7
[ 682] 0x900000001fc07970:  30 a6 00 c0 andi	a2,a1,0xc0
[ 682] 0x900000001fc07974:  00 40 38 2a slt	a3,v0,zero
[ 682] 0x900000001fc07978:  00 47 18 0a movz	v1,v0,a3
[ 682] 0x900000001fc0797c:  00 00 00 21 nada
[ 682] 0x900000001fc07980:  00 00 00 21 nada
[ 682] 0x900000001fc07984:  00 00 00 21 nada
[ 682] 0x900000001fc07988:  de 22 0d d0 ld	v0,3536(s1)
[ 682] 0x900000001fc0798c:  00 01 0a 3a dsrl	at,at,8
[ 682] 0x900000001fc07990:  00 a2 10 24 and	v0,a1,v0
[ 682] 0x900000001fc07994:  00 06 39 ba dsrl	a3,a2,6
[ 682] 0x900000001fc07998:  ff b5 00 40 sd	s5,64(sp)
[ 682] 0x900000001fc0799c:  3c 15 1f c2 lui	s5,0x1fc2
[ 682] 0x900000001fc079a0:  00 02 4f 7e dsrl32	a5,v0,29
[ 682] 0x900000001fc079a4:  62 b5 a8 90 daddi	s5,s5,-22384
[ 682] 0x900000001fc079a8:  00 03 30 43 sra	a2,v1,1
[ 682] 0x900000001fc079ac:  02 95 20 2c dadd	a0,s4,s5
[ 682] 0x900000001fc079b0:  de 28 06 e8 ld	a4,1768(s1)
[ 682] 0x900000001fc079b4:  00 01 1b 38 dsll	v1,at,12
[ 682] 0x900000001fc079b8:  65 0a 02 78 daddiu	a6,a4,632
[ 682] 0x900000001fc079bc:  00 07 10 f8 dsll	v0,a3,3
[ 682] 0x900000001fc079c0:  65 08 02 40 daddiu	a4,a4,576
[ 682] 0x900000001fc079c4:  00 09 08 f8 dsll	at,a5,3
[ 682] 0x900000001fc079c8:  24 c6 ff ff addiu	a2,a2,-1
[ 682] 0x900000001fc079cc:  00 4a 10 2d daddu	v0,v0,a6
[ 682] 0x900000001fc079d0:  00 28 08 2d daddu	at,at,a4
[ 682] 0x900000001fc079d4:  02 66 30 24 and	a2,s3,a2
[ 682] 0x900000001fc079d8:  00 00 b0 25 move	s6,zero
[ 682] 0x900000001fc079dc:  00 66 30 2d daddu	a2,v1,a2
[ 682] 0x900000001fc079e0:  dc 48 00 00 ld	a4,0(v0)
[ 682] 0x900000001fc079e4:  02 00 98 25 move	s3,s0
[ 682] 0x900000001fc079e8:  0f f0 2c e3 jal		loprintf
[ 682] 0x900000001fc079ec:  dc 2a 00 00 ld	a6,0(at)
  683: 	     il->il_tag, 
  684: 	     (((il->il_tag & CTP_TAG_MASK) >> CTP_TAG_SHFT) << 12)
  685: 	         + (addr & (iCacheSize() / 2 -1)),
  686: 	     STATE(il->il_tag), state[STATE(il->il_tag)], 
  687: 	     STATEMOD(il->il_tag), stateMod[STATEMOD(il->il_tag)]);
  688:     loprintf("sp(%d) scw(%d) lru(%d)\n",
[ 688] 0x900000001fc079f0:  3c 01 90 00 lui	at,0x9000
[ 688] 0x900000001fc079f4:  3c 02 1f c2 lui	v0,0x1fc2
[ 688] 0x900000001fc079f8:  60 21 00 00 daddi	at,at,0
[ 688] 0x900000001fc079fc:  60 42 a8 c0 daddi	v0,v0,-22336
[ 688] 0x900000001fc07a00:  de 03 00 00 ld	v1,0(s0)
[ 688] 0x900000001fc07a04:  30 65 00 04 andi	a1,v1,0x4
[ 688] 0x900000001fc07a08:  30 64 00 02 andi	a0,v1,0x2
[ 688] 0x900000001fc07a0c:  30 63 00 08 andi	v1,v1,0x8
[ 688] 0x900000001fc07a10:  00 01 08 3c dsll32	at,at,0
[ 688] 0x900000001fc07a14:  00 05 28 ba dsrl	a1,a1,2
[ 688] 0x900000001fc07a18:  00 04 30 2b sltu	a2,zero,a0
[ 688] 0x900000001fc07a1c:  02 00 b8 25 move	s7,s0
[ 688] 0x900000001fc07a20:  00 03 38 2b sltu	a3,zero,v1
[ 688] 0x900000001fc07a24:  0f f0 2c e3 jal		loprintf
[ 688] 0x900000001fc07a28:  00 22 20 2c dadd	a0,at,v0
  689: 	     (il->il_tag & CTP_STATEPARITY_MASK) >> CTP_STATEPARITY_SHFT,
  690: 	     (il->il_tag & CTP_SCW) ? 1 : 0, (il->il_tag & CTP_LRU) ? 1 : 0);
  691: 
  692:     for (i = 0; contents && (i < IL_ENTRIES); i += 4) {
[ 692] 0x900000001fc07a2c:  66 38 0d b8 daddiu	t8,s1,3512
[ 692] 0x900000001fc07a30:  24 01 00 10 li	at,16
[ 692] 0x900000001fc07a34:  ff be 00 28 sd	s8,40(sp)
[ 692] 0x900000001fc07a38:  ff a1 00 18 sd	at,24(sp)
[ 692] 0x900000001fc07a3c:  52 40 00 4d beql	s2,zero,0x900000001fc07b74
[ 692] 0x900000001fc07a40:  df b1 00 60 ld	s1,96(sp)
[ 692] 0x900000001fc07a44:  66 3e 0d 98 daddiu	s8,s1,3480
[ 692] 0x900000001fc07a48:  ff b8 00 20 sd	t8,32(sp)
[ 692] 0x900000001fc07a4c:  de 65 00 10 ld	a1,16(s3)
  693: 	loprintf("\t0x%c%x  0x%c%x  0x%c%x 0x%c%x",
[ 693] 0x900000001fc07a50:  de 66 00 08 ld	a2,8(s3)
[ 693] 0x900000001fc07a54:  00 06 c8 3e dsrl32	t9,a2,0
[ 693] 0x900000001fc07a58:  67 2b 00 30 daddiu	a7,t9,48
[ 693] 0x900000001fc07a5c:  2f 3f 00 0a sltiu	ra,t9,10
[ 693] 0x900000001fc07a60:  17 e0 00 07 bne	ra,zero,0x900000001fc07a80
[ 693] 0x900000001fc07a64:  00 05 80 3e dsrl32	s0,a1,0
[ 693] 0x900000001fc07a68:  67 35 00 57 daddiu	s5,t9,87
[ 693] 0x900000001fc07a6c:  2e 0a 00 0a sltiu	a6,s0,10
[ 693] 0x900000001fc07a70:  de 64 00 18 ld	a0,24(s3)
[ 693] 0x900000001fc07a74:  de 74 00 20 ld	s4,32(s3)
[ 693] 0x900000001fc07a78:  10 00 00 06 b		0x900000001fc07a94
[ 693] 0x900000001fc07a7c:  66 11 00 30 daddiu	s1,s0,48
[ 693] 0x900000001fc07a80:  2e 0a 00 0a sltiu	a6,s0,10
[ 693] 0x900000001fc07a84:  01 60 a8 25 move	s5,a7
[ 693] 0x900000001fc07a88:  66 11 00 30 daddiu	s1,s0,48
[ 693] 0x900000001fc07a8c:  de 64 00 18 ld	a0,24(s3)
[ 693] 0x900000001fc07a90:  de 74 00 20 ld	s4,32(s3)
[ 693] 0x900000001fc07a94:  15 40 00 05 bne	a6,zero,0x900000001fc07aac
[ 693] 0x900000001fc07a98:  00 04 40 3e dsrl32	a4,a0,0
[ 693] 0x900000001fc07a9c:  66 12 00 57 daddiu	s2,s0,87
[ 693] 0x900000001fc07aa0:  2d 19 00 0a sltiu	t9,a4,10
[ 693] 0x900000001fc07aa4:  10 00 00 04 b		0x900000001fc07ab8
[ 693] 0x900000001fc07aa8:  65 0a 00 30 daddiu	a6,a4,48
[ 693] 0x900000001fc07aac:  2d 19 00 0a sltiu	t9,a4,10
[ 693] 0x900000001fc07ab0:  02 20 90 25 move	s2,s1
[ 693] 0x900000001fc07ab4:  65 0a 00 30 daddiu	a6,a4,48
[ 693] 0x900000001fc07ab8:  17 20 00 05 bne	t9,zero,0x900000001fc07ad0
[ 693] 0x900000001fc07abc:  00 14 38 3e dsrl32	a3,s4,0
[ 693] 0x900000001fc07ac0:  65 09 00 57 daddiu	a5,a4,87
[ 693] 0x900000001fc07ac4:  2c f9 00 0a sltiu	t9,a3,10
[ 693] 0x900000001fc07ac8:  10 00 00 04 b		0x900000001fc07adc
[ 693] 0x900000001fc07acc:  64 eb 00 30 daddiu	a7,a3,48
[ 693] 0x900000001fc07ad0:  2c f9 00 0a sltiu	t9,a3,10
[ 693] 0x900000001fc07ad4:  01 40 48 25 move	a5,a6
[ 693] 0x900000001fc07ad8:  64 eb 00 30 daddiu	a7,a3,48
[ 693] 0x900000001fc07adc:  57 20 00 09 bnel	t9,zero,0x900000001fc07b04
[ 693] 0x900000001fc07ae0:  02 40 38 25 move	a3,s2
[ 693] 0x900000001fc07ae4:  00 06 18 3c dsll32	v1,a2,0
[ 693] 0x900000001fc07ae8:  00 05 10 3c dsll32	v0,a1,0
[ 693] 0x900000001fc07aec:  64 eb 00 57 daddiu	a7,a3,87
[ 693] 0x900000001fc07af0:  02 40 38 25 move	a3,s2
[ 693] 0x900000001fc07af4:  00 04 80 3c dsll32	s0,a0,0
[ 693] 0x900000001fc07af8:  10 00 00 06 b		0x900000001fc07b14
[ 693] 0x900000001fc07afc:  00 14 88 3c dsll32	s1,s4,0
[ 693] 0x900000001fc07b00:  02 40 38 25 move	a3,s2
[ 693] 0x900000001fc07b04:  00 06 18 3c dsll32	v1,a2,0
[ 693] 0x900000001fc07b08:  00 05 10 3c dsll32	v0,a1,0
[ 693] 0x900000001fc07b0c:  00 04 80 3c dsll32	s0,a0,0
[ 693] 0x900000001fc07b10:  00 14 88 3c dsll32	s1,s4,0
[ 693] 0x900000001fc07b14:  00 02 40 3e dsrl32	a4,v0,0
[ 693] 0x900000001fc07b18:  00 10 50 3e dsrl32	a6,s0,0
[ 693] 0x900000001fc07b1c:  00 11 08 3e dsrl32	at,s1,0
[ 693] 0x900000001fc07b20:  02 a0 28 25 move	a1,s5
[ 693] 0x900000001fc07b24:  03 c0 20 25 move	a0,s8
[ 693] 0x900000001fc07b28:  00 03 30 3e dsrl32	a2,v1,0
[ 693] 0x900000001fc07b2c:  0f f0 2c e3 jal		loprintf
[ 693] 0x900000001fc07b30:  ff a1 00 00 sd	at,0(sp)
  694: 		 HEX(il->il_data[i] >> 32), 
  695: 		 ((__uint64_t)(__uint32_t)il->il_data[i]), 
  696: 		 HEX(il->il_data[i+1] >> 32), 
  697: 		 ((__uint64_t)(__uint32_t)il->il_data[i+1]),
  698: 		 HEX(il->il_data[i+2] >> 32), 
  699: 		 ((__uint64_t)(__uint32_t)il->il_data[i+2]),
  700: 		 HEX(il->il_data[i+3] >> 32), 
  701: 		 ((__uint64_t)(__uint32_t)il->il_data[i+3]));
  702: 	loprintf(" [%d %d %d %d]\n",
[ 702] 0x900000001fc07b34:  92 e5 00 88 lbu	a1,136(s7)
[ 702] 0x900000001fc07b38:  92 e6 00 89 lbu	a2,137(s7)
[ 702] 0x900000001fc07b3c:  92 e7 00 8a lbu	a3,138(s7)
[ 702] 0x900000001fc07b40:  92 e8 00 8b lbu	a4,139(s7)
[ 702] 0x900000001fc07b44:  0f f0 2c e3 jal		loprintf
[ 702] 0x900000001fc07b48:  df a4 00 20 ld	a0,32(sp)
[ 692] 0x900000001fc07b4c:  66 73 00 20 daddiu	s3,s3,32
[ 692] 0x900000001fc07b50:  66 f7 00 04 daddiu	s7,s7,4
[ 692] 0x900000001fc07b54:  66 d6 00 04 daddiu	s6,s6,4
[ 692] 0x900000001fc07b58:  df a2 00 18 ld	v0,24(sp)
[ 692] 0x900000001fc07b5c:  df a1 00 10 ld	at,16(sp)
[ 692] 0x900000001fc07b60:  10 20 00 03 beq	at,zero,0x900000001fc07b70
[ 692] 0x900000001fc07b64:  02 c2 c8 2b sltu	t9,s6,v0
[ 692] 0x900000001fc07b68:  57 20 ff b9 bnel	t9,zero,0x900000001fc07a50
[ 692] 0x900000001fc07b6c:  de 65 00 10 ld	a1,16(s3)
[ 692] 0x900000001fc07b70:  df b1 00 60 ld	s1,96(sp)
[ 692] 0x900000001fc07b74:  df b3 00 50 ld	s3,80(sp)
[ 692] 0x900000001fc07b78:  df b5 00 40 ld	s5,64(sp)
[ 692] 0x900000001fc07b7c:  df be 00 28 ld	s8,40(sp)
[ 692] 0x900000001fc07b80:  df bf 00 70 ld	ra,112(sp)
[ 692] 0x900000001fc07b84:  df b6 00 38 ld	s6,56(sp)
[ 692] 0x900000001fc07b88:  df b4 00 48 ld	s4,72(sp)
[ 692] 0x900000001fc07b8c:  df b2 00 58 ld	s2,88(sp)
[ 692] 0x900000001fc07b90:  df b0 00 68 ld	s0,104(sp)
[ 692] 0x900000001fc07b94:  df b7 00 30 ld	s7,48(sp)
[ 692] 0x900000001fc07b98:  03 e0 00 08 jr	ra
[ 692] 0x900000001fc07b9c:  67 bd 00 80 daddiu	sp,sp,128
  703: 		 il->il_parity[i], il->il_parity[i+1], 
  704: 		 il->il_parity[i+2], il->il_parity[i+3]);
  705:     }
  706: #   undef	STATEMOD
  707: #   undef	STATE
  708: }
  709: static	void
  710: printPrimaryDataCacheLine(dl_t *dl, __uint64_t addr, int contents)
  711: /*
  712:  * Function: printPrimaryDataCacheLine
  713:  * Purpose: To print out a primary cache line
  714:  * Parameters:	dl - pointer to fillled in "d-cache" struct.
  715:  *		addr - address used
  716:  *		contents - if true, contents of line are displayed.
  717:  * Returns: nothing
  718:  */
  719: {
printPrimaryDataCacheLine:
[ 719] 0x900000001fc07ba0:  67 bd ff 90 daddiu	sp,sp,-112
[ 719] 0x900000001fc07ba4:  ff b4 00 40 sd	s4,64(sp)
[ 719] 0x900000001fc07ba8:  00 80 a0 25 move	s4,a0
[ 719] 0x900000001fc07bac:  ff b1 00 58 sd	s1,88(sp)
[ 719] 0x900000001fc07bb0:  00 a0 88 25 move	s1,a1
[ 719] 0x900000001fc07bb4:  ff be 00 20 sd	s8,32(sp)
[ 719] 0x900000001fc07bb8:  00 c0 f0 25 move	s8,a2
  720: #   define	STATEMOD(t) (((t) & CTP_STATEMOD_MASK) >> CTP_STATEMOD_SHFT)
  721:     static char * stateMod[] = {
  722: 	"invalid", 
  723: 	"normal ",
  724: 	"incon  ",
  725: 	"invalid",
  726: 	"refill ",
  727: 	"invalid",
  728: 	"invalid"
  729:     };
  730: 
  731: #   define	STATE(t) (((t) & CTP_STATE_MASK) >> CTP_STATE_SHFT)
  732:     static char * state[] = {
  733: 	"invalid  ",
  734: 	"shared   ",
  735: 	"clean-ex ",
  736: 	"dirty-ex "
  737:     };
  738:     int	i;
  739:     __uint32_t	*d;
  740: 
  741:     loprintf("Tag 0x%x address=0x%x s=(%d)%s sm=(%d)%s ",
[ 741] 0x900000001fc07bbc:  3c 01 90 00 lui	at,0x9000
[ 741] 0x900000001fc07bc0:  3c 02 1f c2 lui	v0,0x1fc2
[ 741] 0x900000001fc07bc4:  60 21 00 00 daddi	at,at,0
[ 741] 0x900000001fc07bc8:  60 42 9b 40 daddi	v0,v0,-25792
[ 741] 0x900000001fc07bcc:  3c 03 90 00 lui	v1,0x9000
[ 741] 0x900000001fc07bd0:  ff bf 00 68 sd	ra,104(sp)
[ 741] 0x900000001fc07bd4:  00 01 08 3c dsll32	at,at,0
[ 741] 0x900000001fc07bd8:  ff b5 00 38 sd	s5,56(sp)
[ 741] 0x900000001fc07bdc:  60 63 00 00 daddi	v1,v1,0
[ 741] 0x900000001fc07be0:  ff b0 00 60 sd	s0,96(sp)
[ 741] 0x900000001fc07be4:  00 22 80 2c dadd	s0,at,v0
[ 741] 0x900000001fc07be8:  dc 95 00 00 ld	s5,0(a0)
[ 741] 0x900000001fc07bec:  ff b2 00 50 sd	s2,80(sp)
[ 741] 0x900000001fc07bf0:  00 03 90 3c dsll32	s2,v1,0
[ 741] 0x900000001fc07bf4:  ff b6 00 30 sd	s6,48(sp)
[ 741] 0x900000001fc07bf8:  0f f0 05 91 jal		dCacheSize
[ 741] 0x900000001fc07bfc:  de 16 0d c8 ld	s6,3528(s0)
[ 741] 0x900000001fc07c00:  de 85 00 00 ld	a1,0(s4)
[ 741] 0x900000001fc07c04:  24 43 00 01 addiu	v1,v0,1
[ 741] 0x900000001fc07c08:  02 b6 08 24 and	at,s5,s6
[ 741] 0x900000001fc07c0c:  30 a6 00 c0 andi	a2,a1,0xc0
[ 741] 0x900000001fc07c10:  00 40 38 2a slt	a3,v0,zero
[ 741] 0x900000001fc07c14:  00 47 18 0a movz	v1,v0,a3
[ 741] 0x900000001fc07c18:  00 00 00 21 nada
[ 741] 0x900000001fc07c1c:  00 00 00 21 nada
[ 741] 0x900000001fc07c20:  00 00 00 21 nada
[ 741] 0x900000001fc07c24:  de 02 0d d0 ld	v0,3536(s0)
[ 741] 0x900000001fc07c28:  00 01 0a 3a dsrl	at,at,8
[ 741] 0x900000001fc07c2c:  00 a2 10 24 and	v0,a1,v0
[ 741] 0x900000001fc07c30:  00 06 39 ba dsrl	a3,a2,6
[ 741] 0x900000001fc07c34:  ff b3 00 48 sd	s3,72(sp)
[ 741] 0x900000001fc07c38:  3c 13 1f c2 lui	s3,0x1fc2
[ 741] 0x900000001fc07c3c:  00 02 4f 7e dsrl32	a5,v0,29
[ 741] 0x900000001fc07c40:  62 73 a9 18 daddi	s3,s3,-22248
[ 741] 0x900000001fc07c44:  00 03 30 43 sra	a2,v1,1
[ 741] 0x900000001fc07c48:  02 53 20 2c dadd	a0,s2,s3
[ 741] 0x900000001fc07c4c:  de 08 06 e8 ld	a4,1768(s0)
[ 741] 0x900000001fc07c50:  00 01 1b 38 dsll	v1,at,12
[ 741] 0x900000001fc07c54:  65 0a 02 d0 daddiu	a6,a4,720
[ 741] 0x900000001fc07c58:  00 07 10 f8 dsll	v0,a3,3
[ 741] 0x900000001fc07c5c:  65 08 02 98 daddiu	a4,a4,664
[ 741] 0x900000001fc07c60:  00 09 08 f8 dsll	at,a5,3
[ 741] 0x900000001fc07c64:  24 c6 ff ff addiu	a2,a2,-1
[ 741] 0x900000001fc07c68:  00 4a 10 2d daddu	v0,v0,a6
[ 741] 0x900000001fc07c6c:  00 28 08 2d daddu	at,at,a4
[ 741] 0x900000001fc07c70:  02 26 30 24 and	a2,s1,a2
[ 741] 0x900000001fc07c74:  00 66 30 2d daddu	a2,v1,a2
[ 741] 0x900000001fc07c78:  dc 48 00 00 ld	a4,0(v0)
[ 741] 0x900000001fc07c7c:  0f f0 2c e3 jal		loprintf
[ 741] 0x900000001fc07c80:  dc 2a 00 00 ld	a6,0(at)
  742: 	     dl->dl_tag,
  743: 	     (((dl->dl_tag & CTP_TAG_MASK) >> CTP_TAG_SHFT) << 12)
  744: 	         + (addr & (dCacheSize() / 2 -1)),
  745: 	     STATE(dl->dl_tag), state[STATE(dl->dl_tag)], 
  746: 	     STATEMOD(dl->dl_tag), stateMod[STATEMOD(dl->dl_tag)]);
  747:     loprintf("sp(%d) scw(%d) lru(%d)\n",
[ 747] 0x900000001fc07c84:  3c 01 90 00 lui	at,0x9000
[ 747] 0x900000001fc07c88:  3c 02 1f c2 lui	v0,0x1fc2
[ 747] 0x900000001fc07c8c:  60 21 00 00 daddi	at,at,0
[ 747] 0x900000001fc07c90:  60 42 a9 48 daddi	v0,v0,-22200
[ 747] 0x900000001fc07c94:  de 83 00 00 ld	v1,0(s4)
[ 747] 0x900000001fc07c98:  30 65 00 04 andi	a1,v1,0x4
[ 747] 0x900000001fc07c9c:  30 64 00 02 andi	a0,v1,0x2
[ 747] 0x900000001fc07ca0:  30 63 00 08 andi	v1,v1,0x8
[ 747] 0x900000001fc07ca4:  00 01 08 3c dsll32	at,at,0
[ 747] 0x900000001fc07ca8:  00 05 28 ba dsrl	a1,a1,2
[ 747] 0x900000001fc07cac:  00 04 30 2b sltu	a2,zero,a0
[ 747] 0x900000001fc07cb0:  00 03 38 2b sltu	a3,zero,v1
[ 747] 0x900000001fc07cb4:  0f f0 2c e3 jal		loprintf
[ 747] 0x900000001fc07cb8:  00 22 20 2c dadd	a0,at,v0
  748: 	     (dl->dl_tag & CTP_STATEPARITY_MASK) >> CTP_STATEPARITY_SHFT,
  749: 	     (dl->dl_tag & CTP_SCW) ? 1 : 0, (dl->dl_tag & CTP_LRU) ? 1 : 0);
  750: 
  751:     d = (__uint32_t *)dl->dl_data;
  752:     for (i = 0; contents && (i < DL_ENTRIES); i += 2) {
[ 752] 0x900000001fc07cbc:  66 01 0e 20 daddiu	at,s0,3616
[ 751] 0x900000001fc07cc0:  66 96 00 08 daddiu	s6,s4,8
[ 751] 0x900000001fc07cc4:  24 02 00 04 li	v0,4
[ 751] 0x900000001fc07cc8:  ff b7 00 28 sd	s7,40(sp)
[ 751] 0x900000001fc07ccc:  00 00 b8 25 move	s7,zero
[ 751] 0x900000001fc07cd0:  ff a2 00 10 sd	v0,16(sp)
[ 752] 0x900000001fc07cd4:  13 c0 00 4d beq	s8,zero,0x900000001fc07e0c
[ 752] 0x900000001fc07cd8:  ff a1 00 18 sd	at,24(sp)
  753: 	loprintf("\t0x%x 0x%x 0x%x 0x%x [0x%c 0x%c 0x%c 0x%c]\n", 
[ 753] 0x900000001fc07cdc:  92 99 00 28 lbu	t9,40(s4)
[ 753] 0x900000001fc07ce0:  92 90 00 29 lbu	s0,41(s4)
[ 753] 0x900000001fc07ce4:  27 2b 00 30 addiu	a7,t9,48
[ 753] 0x900000001fc07ce8:  2b 38 00 0a slti	t8,t9,10
[ 753] 0x900000001fc07cec:  57 00 00 08 bnel	t8,zero,0x900000001fc07d10
[ 753] 0x900000001fc07cf0:  2a 0a 00 0a slti	a6,s0,10
[ 753] 0x900000001fc07cf4:  27 35 00 57 addiu	s5,t9,87
[ 753] 0x900000001fc07cf8:  2a 0a 00 0a slti	a6,s0,10
[ 753] 0x900000001fc07cfc:  92 88 00 2b lbu	a4,43(s4)
[ 753] 0x900000001fc07d00:  92 89 00 2a lbu	a5,42(s4)
[ 753] 0x900000001fc07d04:  10 00 00 06 b		0x900000001fc07d20
[ 753] 0x900000001fc07d08:  26 11 00 30 addiu	s1,s0,48
[ 753] 0x900000001fc07d0c:  2a 0a 00 0a slti	a6,s0,10
[ 753] 0x900000001fc07d10:  01 60 a8 25 move	s5,a7
[ 753] 0x900000001fc07d14:  26 11 00 30 addiu	s1,s0,48
[ 753] 0x900000001fc07d18:  92 88 00 2b lbu	a4,43(s4)
[ 753] 0x900000001fc07d1c:  92 89 00 2a lbu	a5,42(s4)
[ 753] 0x900000001fc07d20:  55 40 00 06 bnel	a6,zero,0x900000001fc07d3c
[ 753] 0x900000001fc07d24:  29 39 00 0a slti	t9,a5,10
[ 753] 0x900000001fc07d28:  26 0a 00 57 addiu	a6,s0,87
[ 753] 0x900000001fc07d2c:  29 39 00 0a slti	t9,a5,10
[ 753] 0x900000001fc07d30:  10 00 00 04 b		0x900000001fc07d44
[ 753] 0x900000001fc07d34:  25 2b 00 30 addiu	a7,a5,48
[ 753] 0x900000001fc07d38:  29 39 00 0a slti	t9,a5,10
[ 753] 0x900000001fc07d3c:  02 20 50 25 move	a6,s1
[ 753] 0x900000001fc07d40:  25 2b 00 30 addiu	a7,a5,48
[ 753] 0x900000001fc07d44:  57 20 00 06 bnel	t9,zero,0x900000001fc07d60
[ 753] 0x900000001fc07d48:  29 19 00 0a slti	t9,a4,10
[ 753] 0x900000001fc07d4c:  25 33 00 57 addiu	s3,a5,87
[ 753] 0x900000001fc07d50:  29 19 00 0a slti	t9,a4,10
[ 753] 0x900000001fc07d54:  10 00 00 04 b		0x900000001fc07d68
[ 753] 0x900000001fc07d58:  25 12 00 30 addiu	s2,a4,48
[ 753] 0x900000001fc07d5c:  29 19 00 0a slti	t9,a4,10
[ 753] 0x900000001fc07d60:  01 60 98 25 move	s3,a7
[ 753] 0x900000001fc07d64:  25 12 00 30 addiu	s2,a4,48
[ 753] 0x900000001fc07d68:  57 20 00 10 bnel	t9,zero,0x900000001fc07dac
[ 753] 0x900000001fc07d6c:  02 a0 48 25 move	a5,s5
[ 753] 0x900000001fc07d70:  02 a0 48 25 move	a5,s5
[ 753] 0x900000001fc07d74:  02 60 58 25 move	a7,s3
[ 753] 0x900000001fc07d78:  8e df 00 00 lw	ra,0(s6)
[ 753] 0x900000001fc07d7c:  00 1f 18 3c dsll32	v1,ra,0
[ 753] 0x900000001fc07d80:  8e df 00 04 lw	ra,4(s6)
[ 753] 0x900000001fc07d84:  25 12 00 57 addiu	s2,a4,87
[ 753] 0x900000001fc07d88:  00 1f 10 3c dsll32	v0,ra,0
[ 753] 0x900000001fc07d8c:  8e df 00 08 lw	ra,8(s6)
[ 753] 0x900000001fc07d90:  8e d9 00 0c lw	t9,12(s6)
[ 753] 0x900000001fc07d94:  af b2 00 04 sw	s2,4(sp)
[ 753] 0x900000001fc07d98:  66 d6 00 10 daddiu	s6,s6,16
[ 753] 0x900000001fc07d9c:  00 19 88 3c dsll32	s1,t9,0
[ 753] 0x900000001fc07da0:  10 00 00 0d b		0x900000001fc07dd8
[ 753] 0x900000001fc07da4:  00 1f 80 3c dsll32	s0,ra,0
[ 753] 0x900000001fc07da8:  02 a0 48 25 move	a5,s5
[ 753] 0x900000001fc07dac:  02 60 58 25 move	a7,s3
[ 753] 0x900000001fc07db0:  8e c2 00 00 lw	v0,0(s6)
[ 753] 0x900000001fc07db4:  00 02 18 3c dsll32	v1,v0,0
[ 753] 0x900000001fc07db8:  8e c2 00 04 lw	v0,4(s6)
[ 753] 0x900000001fc07dbc:  00 02 10 3c dsll32	v0,v0,0
[ 753] 0x900000001fc07dc0:  8e c4 00 08 lw	a0,8(s6)
[ 753] 0x900000001fc07dc4:  8e c1 00 0c lw	at,12(s6)
[ 753] 0x900000001fc07dc8:  00 04 80 3c dsll32	s0,a0,0
[ 753] 0x900000001fc07dcc:  af b2 00 04 sw	s2,4(sp)
[ 753] 0x900000001fc07dd0:  66 d6 00 10 daddiu	s6,s6,16
[ 753] 0x900000001fc07dd4:  00 01 88 3c dsll32	s1,at,0
[ 753] 0x900000001fc07dd8:  00 02 30 3e dsrl32	a2,v0,0
[ 753] 0x900000001fc07ddc:  00 10 38 3e dsrl32	a3,s0,0
[ 753] 0x900000001fc07de0:  00 11 40 3e dsrl32	a4,s1,0
[ 753] 0x900000001fc07de4:  00 03 28 3e dsrl32	a1,v1,0
[ 753] 0x900000001fc07de8:  0f f0 2c e3 jal		loprintf
[ 753] 0x900000001fc07dec:  df a4 00 18 ld	a0,24(sp)
[ 752] 0x900000001fc07df0:  66 94 00 04 daddiu	s4,s4,4
[ 752] 0x900000001fc07df4:  66 f7 00 02 daddiu	s7,s7,2
[ 752] 0x900000001fc07df8:  df a5 00 10 ld	a1,16(sp)
[ 752] 0x900000001fc07dfc:  13 c0 00 03 beq	s8,zero,0x900000001fc07e0c
[ 752] 0x900000001fc07e00:  02 e5 c8 2b sltu	t9,s7,a1
[ 752] 0x900000001fc07e04:  57 20 ff b6 bnel	t9,zero,0x900000001fc07ce0
[ 752] 0x900000001fc07e08:  92 99 00 28 lbu	t9,40(s4)
[ 752] 0x900000001fc07e0c:  df b1 00 58 ld	s1,88(sp)
[ 752] 0x900000001fc07e10:  df b3 00 48 ld	s3,72(sp)
[ 752] 0x900000001fc07e14:  df b5 00 38 ld	s5,56(sp)
[ 752] 0x900000001fc07e18:  df be 00 20 ld	s8,32(sp)
[ 752] 0x900000001fc07e1c:  df bf 00 68 ld	ra,104(sp)
[ 752] 0x900000001fc07e20:  df b6 00 30 ld	s6,48(sp)
[ 752] 0x900000001fc07e24:  df b4 00 40 ld	s4,64(sp)
[ 752] 0x900000001fc07e28:  df b2 00 50 ld	s2,80(sp)
[ 752] 0x900000001fc07e2c:  df b0 00 60 ld	s0,96(sp)
[ 752] 0x900000001fc07e30:  df b7 00 28 ld	s7,40(sp)
[ 752] 0x900000001fc07e34:  03 e0 00 08 jr	ra
[ 752] 0x900000001fc07e38:  67 bd 00 70 daddiu	sp,sp,112
  754: 		 (__uint64_t)d[i*2], (__uint64_t)d[i*2+1], 
  755: 		 (__uint64_t)d[i*2+2], (__uint64_t)d[i*2+3],
  756: 		 HEX(dl->dl_ecc[i*2]), HEX(dl->dl_ecc[i*2+1]),
  757: 		 HEX(dl->dl_ecc[i*2+2]), HEX(dl->dl_ecc[i*2+3]));
  758:     }
  759: #   undef	STATEMOD
  760: #   undef	STATE
  761: }
  762: 
  763: #define	SC_STATE(t) ((__uint32_t)(((t) & CTS_STATE_MASK) >> CTS_STATE_SHFT))
  764: static char * sc_state[] = {
  765:     "invalid ", "shared  ", "clean-ex", "dirty-ex",
  766: };
  767: #define	SC_CC_STATE(t) ((__uint32_t)(((t) & CTD_STATE_MASK) >> CTD_STATE_SHFT))
  768: static char * sc_cc_state[] = {
  769:     "invalid", "shared", "*****", "exclusive"
  770: };
  771: 
  772: static	void
  773: printSecondaryCacheLine(sl_t *sl, __uint64_t addr, int contents)
  774: /*
  775:  * Function: printSecondaryCacheLine
  776:  * Purpose: To print out a secondary cache line
  777:  * Parameters:	sl - pointer to secondary line
  778:  *		addr - address used.
  779:  *		contents - if true, contents of line are displayed.
  780:  * Returns: nothing
  781:  */
  782: {
printSecondaryCacheLine:
[ 782] 0x900000001fc07e3c:  67 bd ff a0 daddiu	sp,sp,-96
[ 782] 0x900000001fc07e40:  ff b3 00 30 sd	s3,48(sp)
[ 782] 0x900000001fc07e44:  00 80 98 25 move	s3,a0
  783:     int		i;
  784:     __uint32_t	*d;
  785:     __uint64_t	tmpAddr;
  786: #   define	HEX_ECC(x)	HEX(((x) >> 8) & 3), \
  787:                                 HEX(((x) >> 4) & 0xf), \
  788:                                 HEX((x) & 0xf)
  789:     __uint64_t	maskAddr = ~((sCacheSize() / 2) - 1);
[ 789] 0x900000001fc07e48:  ff b0 00 48 sd	s0,72(sp)
[ 789] 0x900000001fc07e4c:  00 a0 80 25 move	s0,a1
[ 789] 0x900000001fc07e50:  ff b5 00 20 sd	s5,32(sp)
[ 789] 0x900000001fc07e54:  ff bf 00 50 sd	ra,80(sp)
[ 789] 0x900000001fc07e58:  0f f0 05 80 jal		sCacheSize
[ 789] 0x900000001fc07e5c:  00 c0 a8 25 move	s5,a2
[ 789] 0x900000001fc07e60:  24 46 00 01 addiu	a2,v0,1
  790: 
  791:     tmpAddr = (((sl->sl_tag & CTS_TAG_MASK) >> CTS_TAG_SHFT) << 18) & maskAddr;
[ 791] 0x900000001fc07e64:  3c 01 90 00 lui	at,0x9000
[ 791] 0x900000001fc07e68:  3c 03 1f c2 lui	v1,0x1fc2
[ 791] 0x900000001fc07e6c:  60 69 9b 40 daddi	a5,v1,-25792
[ 791] 0x900000001fc07e70:  00 40 18 2a slt	v1,v0,zero
[ 791] 0x900000001fc07e74:  00 43 30 0a movz	a2,v0,v1
[ 791] 0x900000001fc07e78:  00 00 00 21 nada
[ 791] 0x900000001fc07e7c:  00 00 00 21 nada
[ 791] 0x900000001fc07e80:  00 00 00 21 nada
[ 791] 0x900000001fc07e84:  60 22 00 00 daddi	v0,at,0
[ 791] 0x900000001fc07e88:  de 61 00 00 ld	at,0(s3)
  792:     tmpAddr += addr & ~maskAddr;
  793: 
  794:     loprintf("T5 (0x%x%x): addr 0x%x state=(%d)%s Vidx(%d) ECC(0x%b) MRU(%d)\n",
[ 794] 0x900000001fc07e8c:  3c 03 90 00 lui	v1,0x9000
[ 794] 0x900000001fc07e90:  00 01 28 3e dsrl32	a1,at,0
[ 794] 0x900000001fc07e94:  60 64 00 00 daddi	a0,v1,0
[ 794] 0x900000001fc07e98:  00 02 18 3c dsll32	v1,v0,0
[ 794] 0x900000001fc07e9c:  00 06 10 43 sra	v0,a2,1
[ 794] 0x900000001fc07ea0:  30 26 0c 00 andi	a2,at,0xc00
[ 794] 0x900000001fc07ea4:  3c 08 1f c2 lui	a4,0x1fc2
[ 794] 0x900000001fc07ea8:  00 06 3a ba dsrl	a3,a2,10
[ 794] 0x900000001fc07eac:  61 08 a9 90 daddi	a4,a4,-22128
[ 794] 0x900000001fc07eb0:  00 04 20 3c dsll32	a0,a0,0
[ 794] 0x900000001fc07eb4:  28 2c 00 00 slti	t0,at,0
[ 794] 0x900000001fc07eb8:  00 01 30 3c dsll32	a2,at,0
[ 794] 0x900000001fc07ebc:  00 06 30 3e dsrl32	a2,a2,0
[ 794] 0x900000001fc07ec0:  30 2a 01 80 andi	a6,at,0x180
[ 794] 0x900000001fc07ec4:  30 2b 00 7f andi	a7,at,0x7f
[ 794] 0x900000001fc07ec8:  00 0a 51 fa dsrl	a6,a6,7
[ 794] 0x900000001fc07ecc:  ff b6 00 18 sd	s6,24(sp)
[ 794] 0x900000001fc07ed0:  00 69 b0 2c dadd	s6,v1,a5
[ 794] 0x900000001fc07ed4:  24 43 ff ff addiu	v1,v0,-1
[ 794] 0x900000001fc07ed8:  00 07 10 3c dsll32	v0,a3,0
[ 794] 0x900000001fc07edc:  00 88 20 2c dadd	a0,a0,a4
[ 794] 0x900000001fc07ee0:  00 07 40 00 sll	a4,a3,0
[ 794] 0x900000001fc07ee4:  ff b1 00 40 sd	s1,64(sp)
[ 794] 0x900000001fc07ee8:  00 60 88 27 nor	s1,v1,zero
[ 794] 0x900000001fc07eec:  de c3 0e e0 ld	v1,3808(s6)
[ 794] 0x900000001fc07ef0:  00 02 17 7a dsrl	v0,v0,29
[ 794] 0x900000001fc07ef4:  00 23 08 24 and	at,at,v1
[ 794] 0x900000001fc07ef8:  ff b2 00 38 sd	s2,56(sp)
[ 794] 0x900000001fc07efc:  de d2 06 e8 ld	s2,1768(s6)
[ 792] 0x900000001fc07f00:  02 20 38 27 nor	a3,s1,zero
[ 792] 0x900000001fc07f04:  66 43 02 00 daddiu	v1,s2,512
[ 792] 0x900000001fc07f08:  00 01 0b ba dsrl	at,at,14
[ 792] 0x900000001fc07f0c:  00 43 10 2d daddu	v0,v0,v1
[ 792] 0x900000001fc07f10:  02 07 80 24 and	s0,s0,a3
[ 792] 0x900000001fc07f14:  00 01 0c b8 dsll	at,at,18
[ 792] 0x900000001fc07f18:  af ac 00 04 sw	t0,4(sp)
[ 792] 0x900000001fc07f1c:  02 21 08 24 and	at,s1,at
[ 792] 0x900000001fc07f20:  dc 49 00 00 ld	a5,0(v0)
[ 792] 0x900000001fc07f24:  0f f0 2c e3 jal		loprintf
[ 792] 0x900000001fc07f28:  00 30 38 2d daddu	a3,at,s0
  795: 	     (sl->sl_tag >> 32), ((__uint64_t)(__uint32_t)(sl->sl_tag)),
  796: 	     tmpAddr,
  797: 	     SC_STATE(sl->sl_tag), sc_state[SC_STATE(sl->sl_tag)], 
  798: 	     (sl->sl_tag & CTS_VIDX_MASK) >> CTS_VIDX_SHFT,
  799: 	     sl->sl_tag & CTS_ECC_MASK, (sl->sl_tag & CTS_MRU) ? 1 : 0);
  800: 
  801:     tmpAddr = ((sl->sl_cctag & CTD_TAG_MASK) << 18) & maskAddr;
  802:     tmpAddr += addr & ~maskAddr;
  803: 
  804:     loprintf("CC (0x%x%x): addr 0x%x state=(%d)%s\n",
[ 804] 0x900000001fc07f2c:  66 43 02 20 daddiu	v1,s2,544
[ 804] 0x900000001fc07f30:  de 62 00 08 ld	v0,8(s3)
[ 804] 0x900000001fc07f34:  3c 01 00 c0 lui	at,0xc0
[ 804] 0x900000001fc07f38:  00 41 30 24 and	a2,v0,at
[ 804] 0x900000001fc07f3c:  00 02 08 3c dsll32	at,v0,0
[ 804] 0x900000001fc07f40:  3c 04 90 00 lui	a0,0x9000
[ 804] 0x900000001fc07f44:  00 02 28 3e dsrl32	a1,v0,0
[ 804] 0x900000001fc07f48:  60 84 00 00 daddi	a0,a0,0
[ 804] 0x900000001fc07f4c:  00 06 3d ba dsrl	a3,a2,22
[ 804] 0x900000001fc07f50:  3c 08 00 1f lui	a4,0x1f
[ 804] 0x900000001fc07f54:  00 04 20 3c dsll32	a0,a0,0
[ 804] 0x900000001fc07f58:  35 08 ff ff ori	a4,a4,0xffff
[ 804] 0x900000001fc07f5c:  00 01 30 3e dsrl32	a2,at,0
[ 804] 0x900000001fc07f60:  00 48 10 24 and	v0,v0,a4
[ 804] 0x900000001fc07f64:  00 07 08 3c dsll32	at,a3,0
[ 804] 0x900000001fc07f68:  3c 09 1f c2 lui	a5,0x1fc2
[ 804] 0x900000001fc07f6c:  00 02 14 b8 dsll	v0,v0,18
[ 804] 0x900000001fc07f70:  61 29 a9 d0 daddi	a5,a5,-22064
[ 804] 0x900000001fc07f74:  00 07 40 00 sll	a4,a3,0
[ 804] 0x900000001fc07f78:  00 89 20 2c dadd	a0,a0,a5
[ 804] 0x900000001fc07f7c:  00 01 0f 7a dsrl	at,at,29
[ 804] 0x900000001fc07f80:  02 22 10 24 and	v0,s1,v0
[ 804] 0x900000001fc07f84:  00 23 08 2d daddu	at,at,v1
[ 802] 0x900000001fc07f88:  00 50 38 2d daddu	a3,v0,s0
[ 802] 0x900000001fc07f8c:  0f f0 2c e3 jal		loprintf
[ 802] 0x900000001fc07f90:  dc 29 00 00 ld	a5,0(at)
  805: 	     sl->sl_cctag >> 32, ((__uint64_t)(__uint32_t)(sl->sl_cctag)),
  806: 	     tmpAddr,
  807: 	     SC_CC_STATE(sl->sl_cctag), 
  808: 	     sc_cc_state[SC_CC_STATE(sl->sl_cctag)]);
  809: 
  810:     d = (__uint32_t *)sl->sl_data;
[ 810] 0x900000001fc07f94:  66 71 00 10 daddiu	s1,s3,16
  811:     for (i = 0; contents && (i < SL_ENTRIES); i += 2) {
[ 811] 0x900000001fc07f98:  00 00 80 25 move	s0,zero
[ 811] 0x900000001fc07f9c:  ff b7 00 10 sd	s7,16(sp)
[ 811] 0x900000001fc07fa0:  24 17 00 10 li	s7,16
[ 811] 0x900000001fc07fa4:  00 00 90 25 move	s2,zero
[ 811] 0x900000001fc07fa8:  ff b4 00 28 sd	s4,40(sp)
[ 811] 0x900000001fc07fac:  66 d4 0e b8 daddiu	s4,s6,3768
[ 811] 0x900000001fc07fb0:  66 d6 0e d0 daddiu	s6,s6,3792
[ 811] 0x900000001fc07fb4:  52 a0 00 3e beql	s5,zero,0x900000001fc080b0
[ 811] 0x900000001fc07fb8:  df b0 00 48 ld	s0,72(sp)
  812: 	loprintf("\t0x%x 0x%x 0x%x 0x%x  ",  
[ 812] 0x900000001fc07fbc:  8e 38 00 00 lw	t8,0(s1)
[ 812] 0x900000001fc07fc0:  00 18 08 3c dsll32	at,t8,0
[ 812] 0x900000001fc07fc4:  8e 38 00 04 lw	t8,4(s1)
[ 812] 0x900000001fc07fc8:  00 18 f8 3c dsll32	ra,t8,0
[ 812] 0x900000001fc07fcc:  8e 38 00 08 lw	t8,8(s1)
[ 812] 0x900000001fc07fd0:  00 18 c8 3c dsll32	t9,t8,0
[ 812] 0x900000001fc07fd4:  8e 38 00 0c lw	t8,12(s1)
[ 812] 0x900000001fc07fd8:  00 18 c0 3c dsll32	t8,t8,0
[ 812] 0x900000001fc07fdc:  00 01 28 3e dsrl32	a1,at,0
[ 812] 0x900000001fc07fe0:  02 80 20 25 move	a0,s4
[ 812] 0x900000001fc07fe4:  00 1f 30 3e dsrl32	a2,ra,0
[ 812] 0x900000001fc07fe8:  00 19 38 3e dsrl32	a3,t9,0
[ 812] 0x900000001fc07fec:  0f f0 2c e3 jal		loprintf
[ 812] 0x900000001fc07ff0:  00 18 40 3e dsrl32	a4,t8,0
  813: 		 (__uint64_t)d[i*2], (__uint64_t)d[i*2+1],
  814: 		 (__uint64_t)d[i*2+2], (__uint64_t)d[i*2+3]);
  815: 	loprintf("[0x%c%c%c]\n", HEX_ECC(sl->sl_ecc[i/2]));;
[ 815] 0x900000001fc07ff4:  26 18 00 01 addiu	t8,s0,1
[ 815] 0x900000001fc07ff8:  02 00 c8 2a slt	t9,s0,zero
[ 815] 0x900000001fc07ffc:  02 19 c0 0a movz	t8,s0,t9
[ 815] 0x900000001fc08000:  00 00 00 21 nada
[ 815] 0x900000001fc08004:  00 00 00 21 nada
[ 815] 0x900000001fc08008:  00 00 00 21 nada
[ 815] 0x900000001fc0800c:  00 18 c0 43 sra	t8,t8,1
[ 815] 0x900000001fc08010:  03 18 c0 2d daddu	t8,t8,t8
[ 815] 0x900000001fc08014:  02 78 c0 2d daddu	t8,s3,t8
[ 815] 0x900000001fc08018:  97 1f 00 90 lhu	ra,144(t8)
[ 815] 0x900000001fc0801c:  00 1f ca 03 sra	t9,ra,8
[ 815] 0x900000001fc08020:  00 1f c1 03 sra	t8,ra,4
[ 815] 0x900000001fc08024:  33 39 00 03 andi	t9,t9,0x3
[ 815] 0x900000001fc08028:  33 09 00 0f andi	a5,t8,0xf
[ 815] 0x900000001fc0802c:  2b 38 00 0a slti	t8,t9,10
[ 815] 0x900000001fc08030:  17 00 00 05 bne	t8,zero,0x900000001fc08048
[ 815] 0x900000001fc08034:  27 2b 00 30 addiu	a7,t9,48
[ 815] 0x900000001fc08038:  27 25 00 57 addiu	a1,t9,87
[ 815] 0x900000001fc0803c:  29 2a 00 0a slti	a6,a5,10
[ 815] 0x900000001fc08040:  10 00 00 04 b		0x900000001fc08054
[ 815] 0x900000001fc08044:  25 28 00 30 addiu	a4,a5,48
[ 815] 0x900000001fc08048:  29 2a 00 0a slti	a6,a5,10
[ 815] 0x900000001fc0804c:  01 60 28 25 move	a1,a7
[ 815] 0x900000001fc08050:  25 28 00 30 addiu	a4,a5,48
[ 815] 0x900000001fc08054:  15 40 00 05 bne	a6,zero,0x900000001fc0806c
[ 815] 0x900000001fc08058:  33 e3 00 0f andi	v1,ra,0xf
[ 815] 0x900000001fc0805c:  25 26 00 57 addiu	a2,a5,87
[ 815] 0x900000001fc08060:  28 79 00 0a slti	t9,v1,10
[ 815] 0x900000001fc08064:  10 00 00 04 b		0x900000001fc08078
[ 815] 0x900000001fc08068:  24 67 00 30 addiu	a3,v1,48
[ 815] 0x900000001fc0806c:  28 79 00 0a slti	t9,v1,10
[ 815] 0x900000001fc08070:  01 00 30 25 move	a2,a4
[ 815] 0x900000001fc08074:  24 67 00 30 addiu	a3,v1,48
[ 815] 0x900000001fc08078:  17 20 00 03 bne	t9,zero,0x900000001fc08088
[ 815] 0x900000001fc0807c:  00 00 00 21 nada
[ 815] 0x900000001fc08080:  10 00 00 01 b		0x900000001fc08088
[ 815] 0x900000001fc08084:  24 67 00 57 addiu	a3,v1,87
[ 815] 0x900000001fc08088:  0f f0 2c e3 jal		loprintf
[ 815] 0x900000001fc0808c:  02 c0 20 25 move	a0,s6
[ 811] 0x900000001fc08090:  26 10 00 02 addiu	s0,s0,2
[ 811] 0x900000001fc08094:  66 31 00 10 daddiu	s1,s1,16
[ 811] 0x900000001fc08098:  66 52 00 02 daddiu	s2,s2,2
[ 811] 0x900000001fc0809c:  12 a0 00 03 beq	s5,zero,0x900000001fc080ac
[ 811] 0x900000001fc080a0:  02 57 c8 2b sltu	t9,s2,s7
[ 811] 0x900000001fc080a4:  57 20 ff c6 bnel	t9,zero,0x900000001fc07fc0
[ 811] 0x900000001fc080a8:  8e 38 00 00 lw	t8,0(s1)
[ 811] 0x900000001fc080ac:  df b0 00 48 ld	s0,72(sp)
[ 811] 0x900000001fc080b0:  df b2 00 38 ld	s2,56(sp)
[ 811] 0x900000001fc080b4:  df b4 00 28 ld	s4,40(sp)
[ 811] 0x900000001fc080b8:  df b7 00 10 ld	s7,16(sp)
[ 811] 0x900000001fc080bc:  df bf 00 50 ld	ra,80(sp)
[ 811] 0x900000001fc080c0:  df b5 00 20 ld	s5,32(sp)
[ 811] 0x900000001fc080c4:  df b3 00 30 ld	s3,48(sp)
[ 811] 0x900000001fc080c8:  df b1 00 40 ld	s1,64(sp)
[ 811] 0x900000001fc080cc:  df b6 00 18 ld	s6,24(sp)
[ 811] 0x900000001fc080d0:  03 e0 00 08 jr	ra
[ 811] 0x900000001fc080d4:  67 bd 00 60 daddiu	sp,sp,96
  816:     }
  817: #   undef	HEX_ECC
  818: }
  819: 
  820: void
  821: dumpSecondaryLine(int line, int way, int contents)
  822: /*
  823:  * Function: dumpSecondaryLine
  824:  * Purpose: To display a secondary cache line contents.
  825:  * Parameters:  line - line # (Index) to dump
  826:  *		way - cahe line way
  827:  *		contents - if true, dump contexts of line with tags.
  828:  * Returns: nothing
  829:  */
  830: {
dumpSecondaryLine:
[ 830] 0x900000001fc080d8:  67 bd ff 40 daddiu	sp,sp,-192
  831:     sl_t	sl;
  832:     __uint64_t	addr;
  833: 
  834:     addr = SCACHE_ADDR(line, 0);
[ 834] 0x900000001fc080dc:  3c 02 90 00 lui	v0,0x9000
[ 834] 0x900000001fc080e0:  60 42 00 00 daddi	v0,v0,0
[ 834] 0x900000001fc080e4:  3c 03 1f c2 lui	v1,0x1fc2
[ 834] 0x900000001fc080e8:  60 63 9b 40 daddi	v1,v1,-25792
[ 834] 0x900000001fc080ec:  00 02 10 3c dsll32	v0,v0,0
[ 834] 0x900000001fc080f0:  00 43 10 2c dadd	v0,v0,v1
[ 834] 0x900000001fc080f4:  00 04 09 c0 sll	at,a0,7
[ 834] 0x900000001fc080f8:  ff b1 00 10 sd	s1,16(sp)
[ 834] 0x900000001fc080fc:  dc 42 0e e8 ld	v0,3816(v0)
  835:     sLine(addr + way, &sl);
[ 835] 0x900000001fc08100:  ff b0 00 08 sd	s0,8(sp)
[ 835] 0x900000001fc08104:  67 b0 00 20 daddiu	s0,sp,32
[ 835] 0x900000001fc08108:  00 22 88 2f dsubu	s1,at,v0
[ 835] 0x900000001fc0810c:  ff a6 00 18 sd	a2,24(sp)
[ 835] 0x900000001fc08110:  02 25 20 2d daddu	a0,s1,a1
[ 835] 0x900000001fc08114:  ff bf 00 00 sd	ra,0(sp)
[ 835] 0x900000001fc08118:  0f f0 0b 47 jal		sLine
[ 835] 0x900000001fc0811c:  67 a5 00 20 daddiu	a1,sp,32
[ 835] 0x900000001fc08120:  df a6 00 18 ld	a2,24(sp)
  836:     printSecondaryCacheLine(&sl, addr, contents);
[ 836] 0x900000001fc08124:  02 20 28 25 move	a1,s1
[ 836] 0x900000001fc08128:  df b1 00 10 ld	s1,16(sp)
[ 836] 0x900000001fc0812c:  0f f0 1f 8f jal		printSecondaryCacheLine
[ 836] 0x900000001fc08130:  02 00 20 25 move	a0,s0
  837: }
[ 837] 0x900000001fc08134:  df b0 00 08 ld	s0,8(sp)
[ 837] 0x900000001fc08138:  df bf 00 00 ld	ra,0(sp)
[ 837] 0x900000001fc0813c:  03 e0 00 08 jr	ra
[ 837] 0x900000001fc08140:  67 bd 00 c0 daddiu	sp,sp,192
  838: 
  839: void
  840: dumpSecondaryLineAddr(__uint64_t addr, int way, int contents)
  841: {
dumpSecondaryLineAddr:
[ 841] 0x900000001fc08144:  67 bd ff 40 daddiu	sp,sp,-192
  842:     sl_t	sl;
  843: 
  844:     addr |= K0BASE;
[ 844] 0x900000001fc08148:  3c 01 90 00 lui	at,0x9000
[ 844] 0x900000001fc0814c:  60 21 00 00 daddi	at,at,0
[ 844] 0x900000001fc08150:  3c 02 1f c2 lui	v0,0x1fc2
[ 844] 0x900000001fc08154:  60 42 9b 40 daddi	v0,v0,-25792
[ 844] 0x900000001fc08158:  00 01 08 3c dsll32	at,at,0
[ 844] 0x900000001fc0815c:  00 22 08 2c dadd	at,at,v0
[ 844] 0x900000001fc08160:  dc 21 0e f0 ld	at,3824(at)
  845:     addr &= ~(CACHE_SLINE_SIZE-1);
[ 845] 0x900000001fc08164:  ff b1 00 10 sd	s1,16(sp)
[ 845] 0x900000001fc08168:  00 81 08 25 or	at,a0,at
[ 845] 0x900000001fc0816c:  24 02 ff 80 li	v0,-128
  846:     sLine(addr + way, &sl);
[ 846] 0x900000001fc08170:  ff b0 00 08 sd	s0,8(sp)
[ 846] 0x900000001fc08174:  67 b0 00 20 daddiu	s0,sp,32
[ 846] 0x900000001fc08178:  00 22 88 24 and	s1,at,v0
[ 846] 0x900000001fc0817c:  ff a6 00 18 sd	a2,24(sp)
[ 846] 0x900000001fc08180:  02 25 20 2d daddu	a0,s1,a1
[ 846] 0x900000001fc08184:  ff bf 00 00 sd	ra,0(sp)
[ 846] 0x900000001fc08188:  0f f0 0b 47 jal		sLine
[ 846] 0x900000001fc0818c:  67 a5 00 20 daddiu	a1,sp,32
[ 846] 0x900000001fc08190:  df a6 00 18 ld	a2,24(sp)
  847:     printSecondaryCacheLine(&sl, addr, contents);
[ 847] 0x900000001fc08194:  02 20 28 25 move	a1,s1
[ 847] 0x900000001fc08198:  df b1 00 10 ld	s1,16(sp)
[ 847] 0x900000001fc0819c:  0f f0 1f 8f jal		printSecondaryCacheLine
[ 847] 0x900000001fc081a0:  02 00 20 25 move	a0,s0
  848: }
[ 848] 0x900000001fc081a4:  df b0 00 08 ld	s0,8(sp)
[ 848] 0x900000001fc081a8:  df bf 00 00 ld	ra,0(sp)
[ 848] 0x900000001fc081ac:  03 e0 00 08 jr	ra
[ 848] 0x900000001fc081b0:  67 bd 00 c0 daddiu	sp,sp,192
  849: 
  850: int
  851: dumpPrimaryInstructionLine(int line, int way, int contents)
  852: /*
  853:  * Function: dumpPrimaryLine
  854:  * Purpose: To retireve and dump a primary cache line.
  855:  * Parameters:  line- line number to dump
  856:  *		way - which cache way 0/1
  857:  *		contents - 0 - tags only, 1 - data too.
  858:  * Returns: 0 OK, !0 failed
  859:  */
  860: {
dumpPrimaryInstructionLine:
[ 860] 0x900000001fc081b4:  67 bd ff 30 daddiu	sp,sp,-208
[ 860] 0x900000001fc081b8:  ff a4 00 00 sd	a0,0(sp)
  861:     il_t	il;
  862:     __uint64_t	addr;
  863: 
  864:     if (line >= iCacheSize() / CACHE_ILINE_SIZE) {
[ 864] 0x900000001fc081bc:  ff b0 00 18 sd	s0,24(sp)
[ 864] 0x900000001fc081c0:  00 80 80 25 move	s0,a0
[ 864] 0x900000001fc081c4:  ff a5 00 08 sd	a1,8(sp)
[ 864] 0x900000001fc081c8:  ff bf 00 20 sd	ra,32(sp)
[ 864] 0x900000001fc081cc:  0f f0 05 88 jal		iCacheSize
[ 864] 0x900000001fc081d0:  ff a6 00 10 sd	a2,16(sp)
[ 864] 0x900000001fc081d4:  24 41 00 3f addiu	at,v0,63
[ 864] 0x900000001fc081d8:  00 40 18 2a slt	v1,v0,zero
[ 864] 0x900000001fc081dc:  24 19 00 01 li	t9,1
[ 864] 0x900000001fc081e0:  00 43 08 0a movz	at,v0,v1
[ 864] 0x900000001fc081e4:  00 00 00 21 nada
[ 864] 0x900000001fc081e8:  00 00 00 21 nada
[ 864] 0x900000001fc081ec:  00 00 00 21 nada
[ 864] 0x900000001fc081f0:  3c 18 90 00 lui	t8,0x9000
[ 864] 0x900000001fc081f4:  00 01 09 83 sra	at,at,6
[ 864] 0x900000001fc081f8:  67 a5 00 30 daddiu	a1,sp,48
[ 864] 0x900000001fc081fc:  02 01 08 2a slt	at,s0,at
[ 864] 0x900000001fc08200:  50 20 00 15 beql	at,zero,0x900000001fc08258
[ 864] 0x900000001fc08204:  df b0 00 18 ld	s0,24(sp)
  865: 	return(1);
  866:     }
  867: 
  868:     addr = ICACHE_ADDR(line, 0);
[ 868] 0x900000001fc08208:  63 19 00 00 daddi	t9,t8,0
[ 868] 0x900000001fc0820c:  3c 18 1f c2 lui	t8,0x1fc2
[ 868] 0x900000001fc08210:  63 1f 9b 40 daddi	ra,t8,-25792
[ 868] 0x900000001fc08214:  00 19 c8 3c dsll32	t9,t9,0
[ 868] 0x900000001fc08218:  03 3f c8 2c dadd	t9,t9,ra
[ 868] 0x900000001fc0821c:  df b8 00 00 ld	t8,0(sp)
  869:     iLine(addr+way, &il);
[ 869] 0x900000001fc08220:  00 18 c1 80 sll	t8,t8,6
[ 869] 0x900000001fc08224:  df 39 0e e8 ld	t9,3816(t9)
[ 869] 0x900000001fc08228:  03 19 80 2f dsubu	s0,t8,t9
[ 869] 0x900000001fc0822c:  df b8 00 08 ld	t8,8(sp)
[ 869] 0x900000001fc08230:  0f f0 0b 1a jal		iLine
[ 869] 0x900000001fc08234:  02 18 20 2d daddu	a0,s0,t8
  870:     printPrimaryInstructionCacheLine(&il, addr, contents);
[ 870] 0x900000001fc08238:  02 00 28 25 move	a1,s0
[ 870] 0x900000001fc0823c:  df a6 00 10 ld	a2,16(sp)
[ 870] 0x900000001fc08240:  0f f0 1e 40 jal		printPrimaryInstructionCacheLine
[ 870] 0x900000001fc08244:  67 a4 00 30 daddiu	a0,sp,48
  871:     return(0);
[ 871] 0x900000001fc08248:  00 00 c8 25 move	t9,zero
[ 871] 0x900000001fc0824c:  10 00 00 02 b		0x900000001fc08258
[ 871] 0x900000001fc08250:  df b0 00 18 ld	s0,24(sp)
[ 865] 0x900000001fc08254:  df b0 00 18 ld	s0,24(sp)
[ 865] 0x900000001fc08258:  df bf 00 20 ld	ra,32(sp)
[ 865] 0x900000001fc0825c:  03 20 10 25 move	v0,t9
[ 865] 0x900000001fc08260:  03 e0 00 08 jr	ra
[ 865] 0x900000001fc08264:  67 bd 00 d0 daddiu	sp,sp,208
  872: }
  873: int
  874: dumpPrimaryInstructionLineAddr(__uint64_t addr, int way, int contents)
  875: /*
  876:  * Function: dumpPrimaryLine
  877:  * Purpose: To retireve and dump a primary cache line.
  878:  * Parameters:  line- line number to dump
  879:  *		way - which cache way 0/1
  880:  *		contents - 0 - tags only, 1 - data too.
  881:  * Returns: 0 OK, !0 failed
  882:  */
  883: {
dumpPrimaryInstructionLineAddr:
[ 883] 0x900000001fc08268:  67 bd ff 40 daddiu	sp,sp,-192
  884:     il_t	il;
  885: 
  886:     addr |= K0BASE;
[ 886] 0x900000001fc0826c:  3c 01 90 00 lui	at,0x9000
[ 886] 0x900000001fc08270:  60 21 00 00 daddi	at,at,0
[ 886] 0x900000001fc08274:  3c 02 1f c2 lui	v0,0x1fc2
[ 886] 0x900000001fc08278:  60 42 9b 40 daddi	v0,v0,-25792
[ 886] 0x900000001fc0827c:  00 01 08 3c dsll32	at,at,0
[ 886] 0x900000001fc08280:  00 22 08 2c dadd	at,at,v0
[ 886] 0x900000001fc08284:  dc 21 0e f0 ld	at,3824(at)
  887:     addr &= ~(CACHE_ILINE_SIZE - 1);
[ 887] 0x900000001fc08288:  ff b1 00 10 sd	s1,16(sp)
[ 887] 0x900000001fc0828c:  00 81 08 25 or	at,a0,at
[ 887] 0x900000001fc08290:  24 02 ff c0 li	v0,-64
  888:     iLine(addr + way, &il);
[ 888] 0x900000001fc08294:  ff b0 00 08 sd	s0,8(sp)
[ 888] 0x900000001fc08298:  67 b0 00 20 daddiu	s0,sp,32
[ 888] 0x900000001fc0829c:  00 22 88 24 and	s1,at,v0
[ 888] 0x900000001fc082a0:  ff a6 00 18 sd	a2,24(sp)
[ 888] 0x900000001fc082a4:  02 25 20 2d daddu	a0,s1,a1
[ 888] 0x900000001fc082a8:  ff bf 00 00 sd	ra,0(sp)
[ 888] 0x900000001fc082ac:  0f f0 0b 1a jal		iLine
[ 888] 0x900000001fc082b0:  67 a5 00 20 daddiu	a1,sp,32
[ 888] 0x900000001fc082b4:  df a6 00 18 ld	a2,24(sp)
  889:     printPrimaryInstructionCacheLine(&il, addr, contents);
[ 889] 0x900000001fc082b8:  02 20 28 25 move	a1,s1
[ 889] 0x900000001fc082bc:  df b1 00 10 ld	s1,16(sp)
[ 889] 0x900000001fc082c0:  0f f0 1e 40 jal		printPrimaryInstructionCacheLine
[ 889] 0x900000001fc082c4:  02 00 20 25 move	a0,s0
  890:     return(0);
[ 890] 0x900000001fc082c8:  df b0 00 08 ld	s0,8(sp)
[ 890] 0x900000001fc082cc:  df bf 00 00 ld	ra,0(sp)
[ 890] 0x900000001fc082d0:  00 00 10 25 move	v0,zero
[ 890] 0x900000001fc082d4:  03 e0 00 08 jr	ra
[ 890] 0x900000001fc082d8:  67 bd 00 c0 daddiu	sp,sp,192
  891: }
  892: 
  893: int
  894: dumpPrimaryDataLine(int line, int way, int contents)
  895: /*
  896:  * Function: dumpPrimaryDataLine
  897:  * Purpose: To retireve and dump a primary cache line.
  898:  * Parameters:  line- line number to dump
  899:  *		way - which cache way 0/1
  900:  *		contents - 0 - tags only, 1 - data too.
  901:  * Returns: 0 OK, !0 failed
  902:  */
  903: {	
dumpPrimaryDataLine:
[ 903] 0x900000001fc082dc:  67 bd ff a0 daddiu	sp,sp,-96
[ 903] 0x900000001fc082e0:  ff a4 00 30 sd	a0,48(sp)
  904:     dl_t	dl;
  905:     __uint64_t	addr;
  906: 
  907:     if (line >= dCacheSize() / CACHE_DLINE_SIZE) {
[ 907] 0x900000001fc082e4:  ff b0 00 48 sd	s0,72(sp)
[ 907] 0x900000001fc082e8:  00 80 80 25 move	s0,a0
[ 907] 0x900000001fc082ec:  ff a5 00 38 sd	a1,56(sp)
[ 907] 0x900000001fc082f0:  ff bf 00 50 sd	ra,80(sp)
[ 907] 0x900000001fc082f4:  0f f0 05 91 jal		dCacheSize
[ 907] 0x900000001fc082f8:  ff a6 00 40 sd	a2,64(sp)
[ 907] 0x900000001fc082fc:  24 41 00 1f addiu	at,v0,31
[ 907] 0x900000001fc08300:  00 40 18 2a slt	v1,v0,zero
[ 907] 0x900000001fc08304:  24 19 00 01 li	t9,1
[ 907] 0x900000001fc08308:  00 43 08 0a movz	at,v0,v1
[ 907] 0x900000001fc0830c:  00 00 00 21 nada
[ 907] 0x900000001fc08310:  00 00 00 21 nada
[ 907] 0x900000001fc08314:  00 00 00 21 nada
[ 907] 0x900000001fc08318:  3c 18 90 00 lui	t8,0x9000
[ 907] 0x900000001fc0831c:  00 01 09 43 sra	at,at,5
[ 907] 0x900000001fc08320:  67 a5 00 00 daddiu	a1,sp,0
[ 907] 0x900000001fc08324:  02 01 08 2a slt	at,s0,at
[ 907] 0x900000001fc08328:  50 20 00 16 beql	at,zero,0x900000001fc08384
[ 907] 0x900000001fc0832c:  df b0 00 48 ld	s0,72(sp)
  908: 	return(1);
  909:     }
  910: 
  911:     addr = DCACHE_ADDR(line, way);
[ 911] 0x900000001fc08330:  63 19 00 00 daddi	t9,t8,0
[ 911] 0x900000001fc08334:  3c 18 1f c2 lui	t8,0x1fc2
[ 911] 0x900000001fc08338:  63 1f 9b 40 daddi	ra,t8,-25792
[ 911] 0x900000001fc0833c:  00 19 c8 3c dsll32	t9,t9,0
[ 911] 0x900000001fc08340:  df b8 00 30 ld	t8,48(sp)
[ 911] 0x900000001fc08344:  03 3f c8 2c dadd	t9,t9,ra
[ 911] 0x900000001fc08348:  00 18 c1 40 sll	t8,t8,5
[ 911] 0x900000001fc0834c:  df a1 00 38 ld	at,56(sp)
  912:     dLine(addr, &dl);
[ 912] 0x900000001fc08350:  03 01 c0 2d daddu	t8,t8,at
[ 912] 0x900000001fc08354:  df 39 0e e8 ld	t9,3816(t9)
[ 912] 0x900000001fc08358:  03 19 80 2f dsubu	s0,t8,t9
[ 912] 0x900000001fc0835c:  0f f0 0b 32 jal		dLine
[ 912] 0x900000001fc08360:  02 00 20 25 move	a0,s0
  913:     printPrimaryDataCacheLine(&dl, addr, contents);
[ 913] 0x900000001fc08364:  02 00 28 25 move	a1,s0
[ 913] 0x900000001fc08368:  df a6 00 40 ld	a2,64(sp)
[ 913] 0x900000001fc0836c:  0f f0 1e e8 jal		printPrimaryDataCacheLine
[ 913] 0x900000001fc08370:  67 a4 00 00 daddiu	a0,sp,0
  914:     return(0);
[ 914] 0x900000001fc08374:  00 00 c8 25 move	t9,zero
[ 914] 0x900000001fc08378:  10 00 00 02 b		0x900000001fc08384
[ 914] 0x900000001fc0837c:  df b0 00 48 ld	s0,72(sp)
[ 908] 0x900000001fc08380:  df b0 00 48 ld	s0,72(sp)
[ 908] 0x900000001fc08384:  df bf 00 50 ld	ra,80(sp)
[ 908] 0x900000001fc08388:  03 20 10 25 move	v0,t9
[ 908] 0x900000001fc0838c:  03 e0 00 08 jr	ra
[ 908] 0x900000001fc08390:  67 bd 00 60 daddiu	sp,sp,96
  915: }
  916: int
  917: dumpPrimaryDataLineAddr(__uint64_t addr, int way, int contents)
  918: /*
  919:  * Function: dumpPrimaryDataLine
  920:  * Purpose: To retireve and dump a primary cache line.
  921:  * Parameters:  line- line number to dump
  922:  *		way - which cache way 0/1
  923:  *		contents - 0 - tags only, 1 - data too.
  924:  * Returns: 0 OK, !0 failed
  925:  */
  926: {	
dumpPrimaryDataLineAddr:
[ 926] 0x900000001fc08394:  67 bd ff b0 daddiu	sp,sp,-80
  927:     dl_t	dl;
  928: 
  929:     addr |= K0BASE;
[ 929] 0x900000001fc08398:  3c 01 90 00 lui	at,0x9000
[ 929] 0x900000001fc0839c:  60 21 00 00 daddi	at,at,0
[ 929] 0x900000001fc083a0:  3c 02 1f c2 lui	v0,0x1fc2
[ 929] 0x900000001fc083a4:  60 42 9b 40 daddi	v0,v0,-25792
[ 929] 0x900000001fc083a8:  00 01 08 3c dsll32	at,at,0
[ 929] 0x900000001fc083ac:  00 22 08 2c dadd	at,at,v0
[ 929] 0x900000001fc083b0:  dc 21 0e f0 ld	at,3824(at)
  930:     addr &= ~(CACHE_DLINE_SIZE - 1);
[ 930] 0x900000001fc083b4:  ff b1 00 40 sd	s1,64(sp)
[ 930] 0x900000001fc083b8:  00 81 08 25 or	at,a0,at
[ 930] 0x900000001fc083bc:  24 02 ff e0 li	v0,-32
  931:     
  932:     dLine(addr + way, &dl);
[ 932] 0x900000001fc083c0:  ff b0 00 38 sd	s0,56(sp)
[ 932] 0x900000001fc083c4:  67 b0 00 00 daddiu	s0,sp,0
[ 932] 0x900000001fc083c8:  00 22 88 24 and	s1,at,v0
[ 932] 0x900000001fc083cc:  ff a6 00 48 sd	a2,72(sp)
[ 932] 0x900000001fc083d0:  02 25 20 2d daddu	a0,s1,a1
[ 932] 0x900000001fc083d4:  ff bf 00 30 sd	ra,48(sp)
[ 932] 0x900000001fc083d8:  0f f0 0b 32 jal		dLine
[ 932] 0x900000001fc083dc:  67 a5 00 00 daddiu	a1,sp,0
[ 932] 0x900000001fc083e0:  df a6 00 48 ld	a2,72(sp)
  933:     printPrimaryDataCacheLine(&dl, addr, contents);
[ 933] 0x900000001fc083e4:  02 20 28 25 move	a1,s1
[ 933] 0x900000001fc083e8:  df b1 00 40 ld	s1,64(sp)
[ 933] 0x900000001fc083ec:  0f f0 1e e8 jal		printPrimaryDataCacheLine
[ 933] 0x900000001fc083f0:  02 00 20 25 move	a0,s0
  934:     return(0);
[ 934] 0x900000001fc083f4:  df b0 00 38 ld	s0,56(sp)
[ 934] 0x900000001fc083f8:  df bf 00 30 ld	ra,48(sp)
[ 934] 0x900000001fc083fc:  00 00 10 25 move	v0,zero
[ 934] 0x900000001fc08400:  03 e0 00 08 jr	ra
[ 934] 0x900000001fc08404:  67 bd 00 50 daddiu	sp,sp,80
  935: }
  936: 
  937: void
  938: dumpPrimaryCache(int contents)
  939: /*
  940:  * Function: dumpPrimaryCache
  941:  * Purpose: Display the entire primary data Cache
  942:  * Parameters: contents - if true, display cache contents
  943:  * Returns: nothing
  944:  */
  945: {
dumpPrimaryCache:
[ 945] 0x900000001fc08408:  67 bd ff d0 daddiu	sp,sp,-48
  946:     int	lines, i;
  947: 
  948:     lines = (dCacheSize() / CACHE_DLINE_SIZE) / 2;
[ 948] 0x900000001fc0840c:  ff b1 00 10 sd	s1,16(sp)
[ 948] 0x900000001fc08410:  ff bf 00 20 sd	ra,32(sp)
[ 948] 0x900000001fc08414:  0f f0 05 91 jal		dCacheSize
[ 948] 0x900000001fc08418:  00 80 88 25 move	s1,a0
[ 948] 0x900000001fc0841c:  24 41 00 1f addiu	at,v0,31
[ 948] 0x900000001fc08420:  00 40 18 2a slt	v1,v0,zero
[ 948] 0x900000001fc08424:  00 00 28 25 move	a1,zero
[ 948] 0x900000001fc08428:  00 43 08 0a movz	at,v0,v1
[ 948] 0x900000001fc0842c:  00 00 00 21 nada
[ 948] 0x900000001fc08430:  00 00 00 21 nada
[ 948] 0x900000001fc08434:  00 00 00 21 nada
[ 948] 0x900000001fc08438:  02 20 30 25 move	a2,s1
[ 948] 0x900000001fc0843c:  00 01 11 43 sra	v0,at,5
[ 948] 0x900000001fc08440:  24 41 00 01 addiu	at,v0,1
[ 948] 0x900000001fc08444:  00 40 18 2a slt	v1,v0,zero
[ 948] 0x900000001fc08448:  00 43 08 0a movz	at,v0,v1
[ 948] 0x900000001fc0844c:  00 00 00 21 nada
[ 948] 0x900000001fc08450:  00 00 00 21 nada
[ 948] 0x900000001fc08454:  00 00 00 21 nada
  949: 
  950:     for (i = 0; i < lines; i++) {
[ 950] 0x900000001fc08458:  ff b0 00 18 sd	s0,24(sp)
[ 950] 0x900000001fc0845c:  00 00 80 25 move	s0,zero
[ 950] 0x900000001fc08460:  ff b2 00 08 sd	s2,8(sp)
[ 950] 0x900000001fc08464:  00 01 90 43 sra	s2,at,1
[ 950] 0x900000001fc08468:  ff b3 00 00 sd	s3,0(sp)
[ 950] 0x900000001fc0846c:  1a 40 00 0b blez	s2,0x900000001fc0849c
[ 950] 0x900000001fc08470:  24 13 00 01 li	s3,1
  951: 	dumpPrimaryDataLine(i, 0, contents);
[ 951] 0x900000001fc08474:  0f f0 20 b7 jal		dumpPrimaryDataLine
[ 951] 0x900000001fc08478:  02 00 20 25 move	a0,s0
  952: 	dumpPrimaryDataLine(i, 1, contents);
[ 952] 0x900000001fc0847c:  02 20 30 25 move	a2,s1
[ 952] 0x900000001fc08480:  02 60 28 25 move	a1,s3
[ 952] 0x900000001fc08484:  0f f0 20 b7 jal		dumpPrimaryDataLine
[ 952] 0x900000001fc08488:  02 00 20 25 move	a0,s0
[ 950] 0x900000001fc0848c:  00 00 28 25 move	a1,zero
[ 950] 0x900000001fc08490:  26 10 00 01 addiu	s0,s0,1
[ 950] 0x900000001fc08494:  16 12 ff f7 bne	s0,s2,0x900000001fc08474
[ 950] 0x900000001fc08498:  02 20 30 25 move	a2,s1
[ 950] 0x900000001fc0849c:  df b0 00 18 ld	s0,24(sp)
[ 950] 0x900000001fc084a0:  df b3 00 00 ld	s3,0(sp)
[ 950] 0x900000001fc084a4:  df bf 00 20 ld	ra,32(sp)
[ 950] 0x900000001fc084a8:  df b1 00 10 ld	s1,16(sp)
[ 950] 0x900000001fc084ac:  df b2 00 08 ld	s2,8(sp)
[ 950] 0x900000001fc084b0:  03 e0 00 08 jr	ra
[ 950] 0x900000001fc084b4:  67 bd 00 30 daddiu	sp,sp,48
  953:     }
  954: }
  955: 
  956: void
  957: dumpSecondaryCache(int contents)
  958: /*
  959:  * Function: dumpSecondaryCache
  960:  * Purpose: To dump the secondary cache tags and contents
  961:  * Parameters: contents - true--> dump tags + DATA,
  962:  * Returns: nothing
  963:  */
  964: {
dumpSecondaryCache:
[ 964] 0x900000001fc084b8:  67 bd ff d0 daddiu	sp,sp,-48
  965:     int	lines, i;
  966: 
  967:     lines  = (sCacheSize() / CACHE_SLINE_SIZE) / 2;
[ 967] 0x900000001fc084bc:  ff b1 00 10 sd	s1,16(sp)
[ 967] 0x900000001fc084c0:  ff bf 00 20 sd	ra,32(sp)
[ 967] 0x900000001fc084c4:  0f f0 05 80 jal		sCacheSize
[ 967] 0x900000001fc084c8:  00 80 88 25 move	s1,a0
[ 967] 0x900000001fc084cc:  24 41 00 7f addiu	at,v0,127
[ 967] 0x900000001fc084d0:  00 40 18 2a slt	v1,v0,zero
[ 967] 0x900000001fc084d4:  00 00 28 25 move	a1,zero
[ 967] 0x900000001fc084d8:  00 43 08 0a movz	at,v0,v1
[ 967] 0x900000001fc084dc:  00 00 00 21 nada
[ 967] 0x900000001fc084e0:  00 00 00 21 nada
[ 967] 0x900000001fc084e4:  00 00 00 21 nada
[ 967] 0x900000001fc084e8:  02 20 30 25 move	a2,s1
[ 967] 0x900000001fc084ec:  00 01 11 c3 sra	v0,at,7
[ 967] 0x900000001fc084f0:  24 41 00 01 addiu	at,v0,1
[ 967] 0x900000001fc084f4:  00 40 18 2a slt	v1,v0,zero
[ 967] 0x900000001fc084f8:  00 43 08 0a movz	at,v0,v1
[ 967] 0x900000001fc084fc:  00 00 00 21 nada
[ 967] 0x900000001fc08500:  00 00 00 21 nada
[ 967] 0x900000001fc08504:  00 00 00 21 nada
  968: 
  969:     for (i = 0; i < lines; i++) {
[ 969] 0x900000001fc08508:  ff b0 00 18 sd	s0,24(sp)
[ 969] 0x900000001fc0850c:  00 00 80 25 move	s0,zero
[ 969] 0x900000001fc08510:  ff b2 00 08 sd	s2,8(sp)
[ 969] 0x900000001fc08514:  00 01 90 43 sra	s2,at,1
[ 969] 0x900000001fc08518:  ff b3 00 00 sd	s3,0(sp)
[ 969] 0x900000001fc0851c:  1a 40 00 0b blez	s2,0x900000001fc0854c
[ 969] 0x900000001fc08520:  24 13 00 01 li	s3,1
  970: 	dumpSecondaryLine(i, 0, contents); /* way 0 */
[ 970] 0x900000001fc08524:  0f f0 20 36 jal		dumpSecondaryLine
[ 970] 0x900000001fc08528:  02 00 20 25 move	a0,s0
  971: 	dumpSecondaryLine(i, 1, contents); /* way 1 */
[ 971] 0x900000001fc0852c:  02 20 30 25 move	a2,s1
[ 971] 0x900000001fc08530:  02 60 28 25 move	a1,s3
[ 971] 0x900000001fc08534:  0f f0 20 36 jal		dumpSecondaryLine
[ 971] 0x900000001fc08538:  02 00 20 25 move	a0,s0
[ 969] 0x900000001fc0853c:  00 00 28 25 move	a1,zero
[ 969] 0x900000001fc08540:  26 10 00 01 addiu	s0,s0,1
[ 969] 0x900000001fc08544:  16 12 ff f7 bne	s0,s2,0x900000001fc08524
[ 969] 0x900000001fc08548:  02 20 30 25 move	a2,s1
[ 969] 0x900000001fc0854c:  df b0 00 18 ld	s0,24(sp)
[ 969] 0x900000001fc08550:  df b3 00 00 ld	s3,0(sp)
[ 969] 0x900000001fc08554:  df bf 00 20 ld	ra,32(sp)
[ 969] 0x900000001fc08558:  df b1 00 10 ld	s1,16(sp)
[ 969] 0x900000001fc0855c:  df b2 00 08 ld	s2,8(sp)
[ 969] 0x900000001fc08560:  03 e0 00 08 jr	ra
[ 969] 0x900000001fc08564:  67 bd 00 30 daddiu	sp,sp,48
  972:     }
  973: }
  974: 
  975: static	int
  976: compareTag(__uint64_t a, int strict)
  977: /*
  978:  * Function: compareTag
  979:  * Purpose:  To compare the addressess in a CC tag/T5 tag
  980:  * Parameters: a - address to compare
  981:  *   	 	strict - if true, complain about anything even if invalid.
  982:  * Returns: 0 - compare equal, !0 not equal.
  983:  */
  984: {
compareTag:
[ 984] 0x900000001fc08568:  67 bd ff 10 daddiu	sp,sp,-240
[ 984] 0x900000001fc0856c:  ff a4 00 08 sd	a0,8(sp)
  985:     sl_t	sl;
  986:     __uint64_t	t5Addr, ccAddr, maskAddr;
  987:     __uint32_t	ccState, t5State, stateEqual;
  988: 
  989:     sLine(a, &sl);
[ 989] 0x900000001fc08570:  ff b2 00 30 sd	s2,48(sp)
[ 989] 0x900000001fc08574:  00 a0 90 25 move	s2,a1
[ 989] 0x900000001fc08578:  ff a5 00 10 sd	a1,16(sp)
[ 989] 0x900000001fc0857c:  ff bf 00 48 sd	ra,72(sp)
[ 989] 0x900000001fc08580:  0f f0 0b 47 jal		sLine
[ 989] 0x900000001fc08584:  67 a5 00 50 daddiu	a1,sp,80
  990:     maskAddr = ~((sCacheSize() / 2) - 1);
[ 990] 0x900000001fc08588:  0f f0 05 80 jal		sCacheSize
[ 990] 0x900000001fc0858c:  00 00 00 21 nada
  991: 
  992:     /* Convert to addresses - and compare */
  993: 
  994:     t5Addr = (((sl.sl_tag & CTS_TAG_MASK) >> CTS_TAG_SHFT) << 18) & maskAddr;
[ 994] 0x900000001fc08590:  3c 01 90 00 lui	at,0x9000
[ 994] 0x900000001fc08594:  00 40 48 25 move	a5,v0
[ 994] 0x900000001fc08598:  60 22 00 00 daddi	v0,at,0
[ 994] 0x900000001fc0859c:  3c 07 1f c2 lui	a3,0x1fc2
[ 994] 0x900000001fc085a0:  25 21 00 01 addiu	at,a5,1
  995:     ccAddr = (((sl.sl_cctag & CTD_TAG_MASK) >> CTD_TAG_SHFT) << 18) & maskAddr;
  996: 
  997:     t5State = SC_STATE(sl.sl_tag);
  998:     ccState = SC_CC_STATE(sl.sl_cctag);
[ 998] 0x900000001fc085a4:  3c 05 00 1f lui	a1,0x1f
[ 998] 0x900000001fc085a8:  df a4 00 58 ld	a0,88(sp)
[ 998] 0x900000001fc085ac:  3c 03 00 c0 lui	v1,0xc0
[ 998] 0x900000001fc085b0:  34 a8 ff ff ori	a4,a1,0xffff
[ 998] 0x900000001fc085b4:  00 83 18 24 and	v1,a0,v1
[ 998] 0x900000001fc085b8:  00 02 28 3c dsll32	a1,v0,0
[ 998] 0x900000001fc085bc:  01 20 50 2a slt	a6,a5,zero
[ 998] 0x900000001fc085c0:  df a2 00 50 ld	v0,80(sp)
[ 997] 0x900000001fc085c4:  00 03 1d ba dsrl	v1,v1,22
[ 997] 0x900000001fc085c8:  30 46 0c 00 andi	a2,v0,0xc00
[ 997] 0x900000001fc085cc:  01 2a 08 0a movz	at,a5,a6
[ 997] 0x900000001fc085d0:  00 00 00 21 nada
[ 997] 0x900000001fc085d4:  00 00 00 21 nada
[ 997] 0x900000001fc085d8:  00 00 00 21 nada
[ 997] 0x900000001fc085dc:  00 06 32 ba dsrl	a2,a2,10
[ 997] 0x900000001fc085e0:  00 88 20 24 and	a0,a0,a4
[ 997] 0x900000001fc085e4:  00 01 08 43 sra	at,at,1
[ 997] 0x900000001fc085e8:  60 e7 9b 40 daddi	a3,a3,-25792
[ 997] 0x900000001fc085ec:  00 04 24 b8 dsll	a0,a0,18
[ 997] 0x900000001fc085f0:  00 a7 28 2c dadd	a1,a1,a3
[ 997] 0x900000001fc085f4:  24 09 00 01 li	a5,1
[ 997] 0x900000001fc085f8:  00 03 18 00 sll	v1,v1,0
[ 997] 0x900000001fc085fc:  00 06 50 00 sll	a6,a2,0
  999: 
 1000:     if (!strict && t5State == CTS_STATE_I) {
[1000] 0x900000001fc08600:  24 21 ff ff addiu	at,at,-1
[1000] 0x900000001fc08604:  2c 6b 00 01 sltiu	a7,v1,1
[1000] 0x900000001fc08608:  ff a5 00 18 sd	a1,24(sp)
[1000] 0x900000001fc0860c:  dc a5 0e e0 ld	a1,3808(a1)
[1000] 0x900000001fc08610:  00 20 08 27 nor	at,at,zero
[1000] 0x900000001fc08614:  00 45 10 24 and	v0,v0,a1
[1000] 0x900000001fc08618:  ff b1 00 38 sd	s1,56(sp)
[1000] 0x900000001fc0861c:  00 24 88 24 and	s1,at,a0
[1000] 0x900000001fc08620:  00 02 13 ba dsrl	v0,v0,14
[1000] 0x900000001fc08624:  00 02 14 b8 dsll	v0,v0,18
[1000] 0x900000001fc08628:  ff b0 00 40 sd	s0,64(sp)
[1000] 0x900000001fc0862c:  16 40 00 07 bne	s2,zero,0x900000001fc0864c
[1000] 0x900000001fc08630:  00 22 80 24 and	s0,at,v0
[1000] 0x900000001fc08634:  df b2 00 30 ld	s2,48(sp)
[1000] 0x900000001fc08638:  df bf 00 48 ld	ra,72(sp)
[1000] 0x900000001fc0863c:  11 40 00 55 beq	a6,zero,0x900000001fc08794
[1000] 0x900000001fc08640:  00 00 c8 25 move	t9,zero
[1000] 0x900000001fc08644:  10 00 00 05 b		0x900000001fc0865c
[1000] 0x900000001fc08648:  00 00 00 21 nada
 1001: 	/* Who cares what thr T5 says then */
 1002: 	return(0);
 1003:     }
 1004: 
 1005:     switch(t5State) {
[1005] 0x900000001fc0864c:  15 40 00 03 bne	a6,zero,0x900000001fc0865c
[1005] 0x900000001fc08650:  24 09 00 01 li	a5,1
 1006:     case CTS_STATE_I:
 1007: 	stateEqual = (ccState == CTD_STATE_I);
 1008: 	break;
[1008] 0x900000001fc08654:  10 00 00 1b b		0x900000001fc086c4
[1008] 0x900000001fc08658:  00 00 c8 25 move	t9,zero
[1007] 0x900000001fc0865c:  df b8 00 10 ld	t8,16(sp)
[1007] 0x900000001fc08660:  15 49 00 0d bne	a6,a5,0x900000001fc08698
[1007] 0x900000001fc08664:  24 19 00 02 li	t9,2
[1007] 0x900000001fc08668:  24 19 00 03 li	t9,3
[1007] 0x900000001fc0866c:  24 0b 00 01 li	a7,1
 1009:     case CTS_STATE_S:
 1010: 	if (!strict && ccState == CTD_STATE_X) {
[1010] 0x900000001fc08670:  57 00 00 04 bnel	t8,zero,0x900000001fc08684
[1010] 0x900000001fc08674:  00 00 c8 25 move	t9,zero
[1010] 0x900000001fc08678:  10 79 00 05 beq	v1,t9,0x900000001fc08690
[1010] 0x900000001fc0867c:  00 00 00 21 nada
 1011: 	    stateEqual = 1;
 1012: 	} else {
 1013: 	    stateEqual = (ccState == CTD_STATE_S);
[1013] 0x900000001fc08680:  00 00 c8 25 move	t9,zero
[1013] 0x900000001fc08684:  38 7f 00 01 xori	ra,v1,0x1
[1013] 0x900000001fc08688:  10 00 00 0e b		0x900000001fc086c4
[1013] 0x900000001fc0868c:  2f eb 00 01 sltiu	a7,ra,1
[1011] 0x900000001fc08690:  10 00 00 0c b		0x900000001fc086c4
[1011] 0x900000001fc08694:  00 00 c8 25 move	t9,zero
[1011] 0x900000001fc08698:  51 59 00 06 beql	a6,t9,0x900000001fc086b4
[1011] 0x900000001fc0869c:  00 00 c8 25 move	t9,zero
[1011] 0x900000001fc086a0:  00 00 58 25 move	a7,zero
[1011] 0x900000001fc086a4:  24 01 00 03 li	at,3
[1011] 0x900000001fc086a8:  55 41 00 06 bnel	a6,at,0x900000001fc086c4
[1011] 0x900000001fc086ac:  00 00 c8 25 move	t9,zero
 1014: 	}
 1015: 	break;
 1016:     case CTS_STATE_CE:
 1017:     case CTS_STATE_DE:
 1018: 	stateEqual = (ccState == CTD_STATE_X);
 1019: 	break;
[1019] 0x900000001fc086b0:  00 00 c8 25 move	t9,zero
[1018] 0x900000001fc086b4:  38 62 00 03 xori	v0,v1,0x3
[1018] 0x900000001fc086b8:  10 00 00 02 b		0x900000001fc086c4
[1018] 0x900000001fc086bc:  2c 4b 00 01 sltiu	a7,v0,1
 1020:     default:
 1021: 	stateEqual = 0;
 1022: 	break;
[1022] 0x900000001fc086c0:  00 00 c8 25 move	t9,zero
[1022] 0x900000001fc086c4:  df bf 00 48 ld	ra,72(sp)
 1023:     }
 1024:     
 1025:     if ((t5Addr != ccAddr) || !stateEqual) {
[1025] 0x900000001fc086c8:  16 30 00 05 bne	s1,s0,0x900000001fc086e0
[1025] 0x900000001fc086cc:  df b2 00 30 ld	s2,48(sp)
[1025] 0x900000001fc086d0:  11 60 00 03 beq	a7,zero,0x900000001fc086e0
[1025] 0x900000001fc086d4:  00 00 00 21 nada
 1026: 	loprintf("CC/T5 tag mismatch: vaddr=0x%x index=%d way=%d\n",
 1027: 		 a & ~1, (a % (sCacheSize() >> 1)) / CACHE_SLINE_SIZE, a & 1);
 1028: 	loprintf("\tT5[0x%x%x] address=0x%x, state=%s(%d)\n", 
 1029: 		 sl.sl_tag >> 32, (__uint64_t)(__uint32_t)sl.sl_tag,
 1030: 		 t5Addr, sc_state[t5State], t5State);
 1031: 	loprintf("\tCC[0x%x%x] address=0x%x, state=%s(%d)\n",
 1032: 		 sl.sl_cctag >> 32, (__uint64_t)(__uint32_t)sl.sl_cctag,
 1033: 		 ccAddr, sc_cc_state[ccState], ccState);
 1034: 	return(1);
 1035:     }
 1036:     return(0);
[1036] 0x900000001fc086d8:  10 00 00 2f b		0x900000001fc08798
[1036] 0x900000001fc086dc:  03 20 10 25 move	v0,t9
[1026] 0x900000001fc086e0:  ff aa 00 28 sd	a6,40(sp)
[1026] 0x900000001fc086e4:  0f f0 05 80 jal		sCacheSize
[1026] 0x900000001fc086e8:  ff a3 00 20 sd	v1,32(sp)
[1026] 0x900000001fc086ec:  00 02 30 43 sra	a2,v0,1
[1026] 0x900000001fc086f0:  df a3 00 08 ld	v1,8(sp)
[1026] 0x900000001fc086f4:  00 66 00 1f ddivu	v1,a2
[1026] 0x900000001fc086f8:  24 04 ff fe li	a0,-2
[1026] 0x900000001fc086fc:  00 64 28 24 and	a1,v1,a0
[1026] 0x900000001fc08700:  df b2 00 18 ld	s2,24(sp)
[1026] 0x900000001fc08704:  30 67 00 01 andi	a3,v1,0x1
[1026] 0x900000001fc08708:  66 44 0e f8 daddiu	a0,s2,3832
[1026] 0x900000001fc0870c:  00 00 18 10 mfhi	v1
[1026] 0x900000001fc08710:  0f f0 2c e3 jal		loprintf
[1026] 0x900000001fc08714:  00 03 31 fa dsrl	a2,v1,7
[1028] 0x900000001fc08718:  df a9 00 28 ld	a5,40(sp)
[1028] 0x900000001fc0871c:  02 00 38 25 move	a3,s0
[1028] 0x900000001fc08720:  00 09 18 3c dsll32	v1,a5,0
[1028] 0x900000001fc08724:  df a5 00 50 ld	a1,80(sp)
[1028] 0x900000001fc08728:  66 44 0f 28 daddiu	a0,s2,3880
[1028] 0x900000001fc0872c:  00 05 30 3c dsll32	a2,a1,0
[1028] 0x900000001fc08730:  de 50 06 e8 ld	s0,1768(s2)
[1028] 0x900000001fc08734:  00 03 1f 7a dsrl	v1,v1,29
[1028] 0x900000001fc08738:  66 08 02 00 daddiu	a4,s0,512
[1028] 0x900000001fc0873c:  00 05 28 3e dsrl32	a1,a1,0
[1028] 0x900000001fc08740:  00 68 18 2d daddu	v1,v1,a4
[1028] 0x900000001fc08744:  00 06 30 3e dsrl32	a2,a2,0
[1028] 0x900000001fc08748:  0f f0 2c e3 jal		loprintf
[1028] 0x900000001fc0874c:  dc 68 00 00 ld	a4,0(v1)
[1031] 0x900000001fc08750:  df a9 00 20 ld	a5,32(sp)
[1031] 0x900000001fc08754:  66 08 02 20 daddiu	a4,s0,544
[1031] 0x900000001fc08758:  00 09 18 3c dsll32	v1,a5,0
[1031] 0x900000001fc0875c:  df a5 00 58 ld	a1,88(sp)
[1031] 0x900000001fc08760:  02 20 38 25 move	a3,s1
[1031] 0x900000001fc08764:  00 05 30 3c dsll32	a2,a1,0
[1031] 0x900000001fc08768:  66 44 0f 50 daddiu	a0,s2,3920
[1031] 0x900000001fc0876c:  df b2 00 30 ld	s2,48(sp)
[1031] 0x900000001fc08770:  00 03 1f 7a dsrl	v1,v1,29
[1031] 0x900000001fc08774:  00 05 28 3e dsrl32	a1,a1,0
[1031] 0x900000001fc08778:  00 68 18 2d daddu	v1,v1,a4
[1031] 0x900000001fc0877c:  00 06 30 3e dsrl32	a2,a2,0
[1031] 0x900000001fc08780:  0f f0 2c e3 jal		loprintf
[1031] 0x900000001fc08784:  dc 68 00 00 ld	a4,0(v1)
[1034] 0x900000001fc08788:  24 19 00 01 li	t9,1
[1034] 0x900000001fc0878c:  10 00 00 01 b		0x900000001fc08794
[1034] 0x900000001fc08790:  df bf 00 48 ld	ra,72(sp)
[1002] 0x900000001fc08794:  03 20 10 25 move	v0,t9
[1002] 0x900000001fc08798:  df b0 00 40 ld	s0,64(sp)
[1002] 0x900000001fc0879c:  df b1 00 38 ld	s1,56(sp)
[1002] 0x900000001fc087a0:  03 e0 00 08 jr	ra
[1002] 0x900000001fc087a4:  67 bd 00 f0 daddiu	sp,sp,240
 1037: }
 1038: 
 1039: void
 1040: compareSecondaryTags(int all, int strict)
 1041: /*
 1042:  * Function: compareSecondaryTags
 1043:  * Purpose: To compare the contents of the secondary cache tags with the
 1044:  *	    SCC duplicate tags.
 1045:  * Parameters: all - if true, print all tags that mis-compare, if false, 
 1046:  *	  	     stop on the first error.
 1047:  *		strict - if true, complain about all mismatches, even if
 1048:  *			they would not cause an operational problem.
 1049:  * Returns: nothing
 1050:  */
 1051: {
compareSecondaryTags:
[1051] 0x900000001fc087a8:  67 bd ff c0 daddiu	sp,sp,-64
 1052:     int		lines, curLine;
 1053: 	
 1054:     lines = sCacheSize() / CACHE_SLINE_SIZE; /* number of cache lines */
[1054] 0x900000001fc087ac:  ff b3 00 18 sd	s3,24(sp)
[1054] 0x900000001fc087b0:  00 80 98 25 move	s3,a0
[1054] 0x900000001fc087b4:  ff b2 00 20 sd	s2,32(sp)
[1054] 0x900000001fc087b8:  ff bf 00 38 sd	ra,56(sp)
[1054] 0x900000001fc087bc:  0f f0 05 80 jal		sCacheSize
[1054] 0x900000001fc087c0:  00 a0 90 25 move	s2,a1
[1054] 0x900000001fc087c4:  ff b5 00 08 sd	s5,8(sp)
[1054] 0x900000001fc087c8:  24 41 00 7f addiu	at,v0,127
[1054] 0x900000001fc087cc:  00 40 18 2a slt	v1,v0,zero
[1054] 0x900000001fc087d0:  ff b0 00 30 sd	s0,48(sp)
[1054] 0x900000001fc087d4:  3c 04 90 00 lui	a0,0x9000
[1054] 0x900000001fc087d8:  00 43 08 0a movz	at,v0,v1
[1054] 0x900000001fc087dc:  00 00 00 21 nada
[1054] 0x900000001fc087e0:  00 00 00 21 nada
[1054] 0x900000001fc087e4:  00 00 00 21 nada
[1054] 0x900000001fc087e8:  ff b1 00 28 sd	s1,40(sp)
[1054] 0x900000001fc087ec:  3c 06 1f c2 lui	a2,0x1fc2
[1054] 0x900000001fc087f0:  00 01 09 c3 sra	at,at,7
 1055:     lines >>= 1;			/* 2-way */
[1055] 0x900000001fc087f4:  ff b4 00 10 sd	s4,16(sp)
[1055] 0x900000001fc087f8:  00 01 c8 43 sra	t9,at,1
 1056: 
 1057:     for (curLine = 0; curLine < lines; curLine++) {
[1057] 0x900000001fc087fc:  5b 20 00 2a blezl	t9,0x900000001fc088a8
[1057] 0x900000001fc08800:  df b3 00 18 ld	s3,24(sp)
[1057] 0x900000001fc08804:  60 87 00 00 daddi	a3,a0,0
[1057] 0x900000001fc08808:  3c 04 1f c2 lui	a0,0x1fc2
[1057] 0x900000001fc0880c:  60 88 9b 40 daddi	a4,a0,-25792
[1057] 0x900000001fc08810:  3c 04 90 00 lui	a0,0x9000
[1057] 0x900000001fc08814:  60 84 00 00 daddi	a0,a0,0
[1057] 0x900000001fc08818:  00 07 38 3c dsll32	a3,a3,0
[1057] 0x900000001fc0881c:  00 e8 38 2c dadd	a3,a3,a4
[1057] 0x900000001fc08820:  60 c6 9b 40 daddi	a2,a2,-25792
[1057] 0x900000001fc08824:  00 04 20 3c dsll32	a0,a0,0
[1057] 0x900000001fc08828:  dc f5 0f 78 ld	s5,3960(a3)
[1057] 0x900000001fc0882c:  00 86 20 2c dadd	a0,a0,a2
[1057] 0x900000001fc08830:  00 19 28 3c dsll32	a1,t9,0
[1057] 0x900000001fc08834:  dc 90 1e 08 ld	s0,7688(a0)
[1057] 0x900000001fc08838:  00 05 2e 7a dsrl	a1,a1,25
[1057] 0x900000001fc0883c:  ff a4 00 00 sd	a0,0(sp)
[1057] 0x900000001fc08840:  dc 84 0e f0 ld	a0,3824(a0)
[1057] 0x900000001fc08844:  00 00 88 25 move	s1,zero
[1057] 0x900000001fc08848:  00 85 a0 2d daddu	s4,a0,a1
[1057] 0x900000001fc0884c:  02 40 28 25 move	a1,s2
 1058: 	if (compareTag(SCACHE_ADDR(curLine, 0), strict) && !all) {
[1058] 0x900000001fc08850:  0f f0 21 5a jal		compareTag
[1058] 0x900000001fc08854:  02 00 20 25 move	a0,s0
[1058] 0x900000001fc08858:  50 40 00 04 beql	v0,zero,0x900000001fc0886c
[1058] 0x900000001fc0885c:  02 35 20 2f dsubu	a0,s1,s5
[1058] 0x900000001fc08860:  52 60 00 0d beql	s3,zero,0x900000001fc08898
[1058] 0x900000001fc08864:  df b1 00 28 ld	s1,40(sp)
 1059: 	    return;
 1060: 	}
 1061: 	if (compareTag(SCACHE_ADDR(curLine, 1), strict) && !all) {
[1061] 0x900000001fc08868:  02 35 20 2f dsubu	a0,s1,s5
[1061] 0x900000001fc0886c:  0f f0 21 5a jal		compareTag
[1061] 0x900000001fc08870:  02 40 28 25 move	a1,s2
[1061] 0x900000001fc08874:  50 40 00 04 beql	v0,zero,0x900000001fc08888
[1061] 0x900000001fc08878:  66 31 00 80 daddiu	s1,s1,128
[1061] 0x900000001fc0887c:  52 60 00 06 beql	s3,zero,0x900000001fc08898
[1061] 0x900000001fc08880:  df b1 00 28 ld	s1,40(sp)
[1061] 0x900000001fc08884:  66 31 00 80 daddiu	s1,s1,128
[1057] 0x900000001fc08888:  66 10 00 80 daddiu	s0,s0,128
[1057] 0x900000001fc0888c:  56 14 ff f0 bnel	s0,s4,0x900000001fc08850
[1057] 0x900000001fc08890:  02 40 28 25 move	a1,s2
[1057] 0x900000001fc08894:  df b1 00 28 ld	s1,40(sp)
[1057] 0x900000001fc08898:  df b4 00 10 ld	s4,16(sp)
[1057] 0x900000001fc0889c:  df b0 00 30 ld	s0,48(sp)
[1057] 0x900000001fc088a0:  df b5 00 08 ld	s5,8(sp)
[1057] 0x900000001fc088a4:  df b3 00 18 ld	s3,24(sp)
[1057] 0x900000001fc088a8:  df bf 00 38 ld	ra,56(sp)
[1057] 0x900000001fc088ac:  df b2 00 20 ld	s2,32(sp)
[1057] 0x900000001fc088b0:  03 e0 00 08 jr	ra
[1057] 0x900000001fc088b4:  67 bd 00 40 daddiu	sp,sp,64
 1062: 	    return;
 1063: 	}
 1064:     }
 1065: }
 1066: 
 1067: void
 1068: setSecondaryECC(__uint64_t a)
 1069: {
setSecondaryECC:
[1069] 0x900000001fc088b8:  67 bd ff 30 daddiu	sp,sp,-208
 1070:     sl_t	sl;
 1071:     cacheop_t	cop;
 1072: 
 1073:     *(((__uint64_t *)a) + 1) = 0;
 1074:     a &= ~(CACHE_SLINE_SIZE-1) + 1;
[1074] 0x900000001fc088bc:  24 01 ff 81 li	at,-127
[1073] 0x900000001fc088c0:  fc 80 00 08 sd	zero,8(a0)
[1073] 0x900000001fc088c4:  00 81 20 24 and	a0,a0,at
 1075: 
 1076:     sLine(a, &sl);
[1076] 0x900000001fc088c8:  67 a5 00 30 daddiu	a1,sp,48
[1076] 0x900000001fc088cc:  ff b0 00 20 sd	s0,32(sp)
[1076] 0x900000001fc088d0:  ff bf 00 18 sd	ra,24(sp)
[1076] 0x900000001fc088d4:  0f f0 0b 47 jal		sLine
[1076] 0x900000001fc088d8:  00 80 80 25 move	s0,a0
 1077:     cop.cop_address = a;
 1078:     cop.cop_operation = C_ISD + CACH_S;
 1079:     cop.cop_taghi = (__uint32_t)(sl.sl_data[0] >> 32);
 1080:     cop.cop_taglo = (__uint32_t)(sl.sl_data[0] & 0xffffffff);
[1080] 0x900000001fc088dc:  34 01 ff ff ori	at,zero,0xffff
 1081:     cop.cop_ecc   = sl.sl_ecc[0] ^ 3;
 1082:     cacheOP(&cop);
[1082] 0x900000001fc088e0:  67 a4 00 00 daddiu	a0,sp,0
[1082] 0x900000001fc088e4:  00 01 14 38 dsll	v0,at,16
[1082] 0x900000001fc088e8:  97 a1 00 c0 lhu	at,192(sp)
[1077] 0x900000001fc088ec:  ff b0 00 00 sd	s0,0(sp)
[1077] 0x900000001fc088f0:  df b0 00 20 ld	s0,32(sp)
[1077] 0x900000001fc088f4:  38 25 00 03 xori	a1,at,0x3
[1077] 0x900000001fc088f8:  24 03 00 1f li	v1,31
[1077] 0x900000001fc088fc:  df a1 00 40 ld	at,64(sp)
[1077] 0x900000001fc08900:  af a3 00 08 sw	v1,8(sp)
[1077] 0x900000001fc08904:  34 43 ff ff ori	v1,v0,0xffff
[1077] 0x900000001fc08908:  00 01 10 3e dsrl32	v0,at,0
[1077] 0x900000001fc0890c:  00 02 10 00 sll	v0,v0,0
[1077] 0x900000001fc08910:  af a5 00 14 sw	a1,20(sp)
[1077] 0x900000001fc08914:  00 23 08 24 and	at,at,v1
[1077] 0x900000001fc08918:  af a2 00 0c sw	v0,12(sp)
[1077] 0x900000001fc0891c:  00 01 08 00 sll	at,at,0
[1077] 0x900000001fc08920:  0f f0 0c 1c jal		cacheOP
[1077] 0x900000001fc08924:  af a1 00 10 sw	at,16(sp)
 1083: }
[1083] 0x900000001fc08928:  df bf 00 18 ld	ra,24(sp)
[1083] 0x900000001fc0892c:  03 e0 00 08 jr	ra
[1083] 0x900000001fc08930:  67 bd 00 d0 daddiu	sp,sp,208
 1084: 
 1085: void 
 1086: _register(int rw, int *reg_name, __scunsigned_t val, struct reg_struct *gprs)
 1087: {
_register:
[1087] 0x900000001fc08934:  67 bd ff b0 daddiu	sp,sp,-80
[1087] 0x900000001fc08938:  ff b2 00 30 sd	s2,48(sp)
[1087] 0x900000001fc0893c:  00 a0 90 25 move	s2,a1
[1087] 0x900000001fc08940:  ff b4 00 20 sd	s4,32(sp)
[1087] 0x900000001fc08944:  00 80 a0 25 move	s4,a0
[1087] 0x900000001fc08948:  ff b5 00 18 sd	s5,24(sp)
[1087] 0x900000001fc0894c:  00 c0 a8 25 move	s5,a2
[1087] 0x900000001fc08950:  ff be 00 00 sd	s8,0(sp)
[1087] 0x900000001fc08954:  00 e0 f0 25 move	s8,a3
 1088:     register __scunsigned_t tmp;
 1089:     int number;
 1090:     evreg_t ertoip;
 1091:     static char *softwareRegisters[] = {
 1092: 	"z ", "at", "v0", "v1", "a0", "a1", "a2", "a3", 
 1093:         "a4", "a5", "a6", "a7", "t0", "t1", "t2", "t3", 
 1094: 	"s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7", 
 1095: 	"t8", "t9", "k0", "k1", "gp", "sp", "fp", "ra"
 1096:     };
 1097: 
 1098:     if (*reg_name == 'r' || *reg_name == 'R'|| *reg_name == '$') {
[1098] 0x900000001fc08958:  ff b1 00 38 sd	s1,56(sp)
[1098] 0x900000001fc0895c:  24 11 00 52 li	s1,82
[1098] 0x900000001fc08960:  ff b3 00 28 sd	s3,40(sp)
[1098] 0x900000001fc08964:  24 13 00 24 li	s3,36
[1098] 0x900000001fc08968:  3c 01 90 00 lui	at,0x9000
[1098] 0x900000001fc0896c:  3c 02 1f c2 lui	v0,0x1fc2
[1098] 0x900000001fc08970:  60 21 00 00 daddi	at,at,0
[1098] 0x900000001fc08974:  ff bf 00 48 sd	ra,72(sp)
[1098] 0x900000001fc08978:  60 43 9b 40 daddi	v1,v0,-25792
[1098] 0x900000001fc0897c:  00 01 10 3c dsll32	v0,at,0
[1098] 0x900000001fc08980:  ff b7 00 08 sd	s7,8(sp)
[1098] 0x900000001fc08984:  00 43 b8 2c dadd	s7,v0,v1
[1098] 0x900000001fc08988:  24 01 00 72 li	at,114
[1098] 0x900000001fc0898c:  ff b0 00 40 sd	s0,64(sp)
[1098] 0x900000001fc08990:  8e 50 00 00 lw	s0,0(s2)
[1098] 0x900000001fc08994:  12 01 00 85 beq	s0,at,0x900000001fc08bac
[1098] 0x900000001fc08998:  ff b6 00 10 sd	s6,16(sp)
[1098] 0x900000001fc0899c:  12 11 00 83 beq	s0,s1,0x900000001fc08bac
[1098] 0x900000001fc089a0:  00 00 00 21 nada
[1098] 0x900000001fc089a4:  12 13 00 81 beq	s0,s3,0x900000001fc08bac
[1098] 0x900000001fc089a8:  00 00 00 21 nada
 1099: 	number = lo_atoi(reg_name + 1);
 1100: 	if (number <= 0 || number > 31) {
 1101: 	    loprintf("*** Invalid register name.\n");
 1102: 	    return;
 1103: 	}
 1104: 	loprintf("r%a: %y\n", number, gprs->gpr[number]);
 1105:     } else if (lo_strcmp(reg_name,"sp") == 0) {
[1105] 0x900000001fc089ac:  66 e5 0f a9 daddiu	a1,s7,4009
[1105] 0x900000001fc089b0:  0f f0 35 f5 jal		lo_strcmp
[1105] 0x900000001fc089b4:  02 40 20 25 move	a0,s2
[1105] 0x900000001fc089b8:  66 e5 0f b8 daddiu	a1,s7,4024
[1105] 0x900000001fc089bc:  50 40 00 72 beql	v0,zero,0x900000001fc08b88
[1105] 0x900000001fc089c0:  02 a0 28 25 move	a1,s5
 1106: 	tmp = _sp(rw,val);
 1107: 	if (rw == 0)
 1108: 	    loprintf("SP: %y\n",tmp);
 1109:     } else if (lo_strcmp(reg_name,"sr") == 0) {
[1109] 0x900000001fc089c4:  0f f0 35 f5 jal		lo_strcmp
[1109] 0x900000001fc089c8:  02 40 20 25 move	a0,s2
[1109] 0x900000001fc089cc:  50 40 00 64 beql	v0,zero,0x900000001fc08b60
[1109] 0x900000001fc089d0:  02 a0 28 25 move	a1,s5
 1110: 	tmp = _sr(rw,val);
 1111: 	if (rw == 0)
 1112: 	    loprintf("SR: %y\n",tmp);
 1113:     } else if (lo_strcmp(reg_name,"cause") == 0) {
[1113] 0x900000001fc089d4:  66 e5 0f c8 daddiu	a1,s7,4040
[1113] 0x900000001fc089d8:  0f f0 35 f5 jal		lo_strcmp
[1113] 0x900000001fc089dc:  02 40 20 25 move	a0,s2
[1113] 0x900000001fc089e0:  66 e5 0f db daddiu	a1,s7,4059
[1113] 0x900000001fc089e4:  50 40 00 54 beql	v0,zero,0x900000001fc08b38
[1113] 0x900000001fc089e8:  02 a0 28 25 move	a1,s5
 1114: 	tmp = _cause(rw,val);
 1115: 	if (rw == 0)
 1116: 	    loprintf("Cause: %y\n",tmp);
 1117:     } else if (lo_strcmp(reg_name,"epc") == 0) {
[1117] 0x900000001fc089ec:  0f f0 35 f5 jal		lo_strcmp
[1117] 0x900000001fc089f0:  02 40 20 25 move	a0,s2
[1117] 0x900000001fc089f4:  66 e5 0f e9 daddiu	a1,s7,4073
[1117] 0x900000001fc089f8:  50 40 00 45 beql	v0,zero,0x900000001fc08b10
[1117] 0x900000001fc089fc:  02 a0 28 25 move	a1,s5
 1118: 	tmp = _epc(rw,val);
 1119: 	if (rw == 0)
 1120: 	    loprintf("EPC: %y\n",tmp);
 1121:     } else if (lo_strcmp(reg_name,"config") == 0) {
[1121] 0x900000001fc08a00:  0f f0 35 f5 jal		lo_strcmp
[1121] 0x900000001fc08a04:  02 40 20 25 move	a0,s2
[1121] 0x900000001fc08a08:  66 e5 0f fc daddiu	a1,s7,4092
[1121] 0x900000001fc08a0c:  50 40 00 36 beql	v0,zero,0x900000001fc08ae8
[1121] 0x900000001fc08a10:  02 a0 28 25 move	a1,s5
 1122: 	tmp = _config(rw,val);
 1123: 	if (rw == 0)
 1124: 	    loprintf("Config: %y\n",tmp);
 1125:     } else if (lo_strcmp(reg_name,"all") == 0) {
[1125] 0x900000001fc08a14:  0f f0 35 f5 jal		lo_strcmp
[1125] 0x900000001fc08a18:  02 40 20 25 move	a0,s2
[1125] 0x900000001fc08a1c:  00 00 98 25 move	s3,zero
[1125] 0x900000001fc08a20:  de e6 06 e8 ld	a2,1768(s7)
[1125] 0x900000001fc08a24:  66 f6 10 0d daddiu	s6,s7,4109
[1125] 0x900000001fc08a28:  50 40 00 06 beql	v0,zero,0x900000001fc08a44
[1125] 0x900000001fc08a2c:  03 c0 80 25 move	s0,s8
 1126: 	for (number = 0; number < 32; number ++) {
 1127: 	    loprintf("r%a/%s: %y  ", number, softwareRegisters[number], 
 1128: 		     gprs->gpr[number]);
 1129: 	    if (!((number + 1) % 3))
 1130: 		loprintf("\n");
 1131: 	}
 1132: 	loprintf("BVA: %y\n", gprs->badva);
 1133: 	loprintf("EPC: %y   SR: %y\n", gprs->epc, gprs->sr);
 1134: 	loprintf("Cause: %y  ", gprs->cause);
 1135: 	xlate_cause(gprs->cause);
 1136: 	if (ertoip = get_ERTOIP()) {	/* pick up saved ERTOIP */
 1137: 	    xlate_ertoip(ertoip);
 1138: 	}
 1139:     } else {
 1140: 	loprintf("*** Invalid register name.\n");
[1140] 0x900000001fc08a30:  0f f0 2c e3 jal		loprintf
[1140] 0x900000001fc08a34:  66 e4 10 48 daddiu	a0,s7,4168
[1140] 0x900000001fc08a38:  10 00 00 6f b		0x900000001fc08bf8
[1140] 0x900000001fc08a3c:  df b1 00 38 ld	s1,56(sp)
[1126] 0x900000001fc08a40:  03 c0 80 25 move	s0,s8
[1126] 0x900000001fc08a44:  64 d1 02 f0 daddiu	s1,a2,752
[1126] 0x900000001fc08a48:  64 d5 03 f0 daddiu	s5,a2,1008
[1126] 0x900000001fc08a4c:  66 f4 10 00 daddiu	s4,s7,4096
[1126] 0x900000001fc08a50:  de 26 00 00 ld	a2,0(s1)
[1127] 0x900000001fc08a54:  66 31 00 08 daddiu	s1,s1,8
[1127] 0x900000001fc08a58:  de 07 00 00 ld	a3,0(s0)
[1127] 0x900000001fc08a5c:  02 60 28 25 move	a1,s3
[1127] 0x900000001fc08a60:  0f f0 2c e3 jal		loprintf
[1127] 0x900000001fc08a64:  02 80 20 25 move	a0,s4
[1129] 0x900000001fc08a68:  26 72 00 01 addiu	s2,s3,1
[1129] 0x900000001fc08a6c:  24 07 00 03 li	a3,3
[1129] 0x900000001fc08a70:  66 10 00 08 daddiu	s0,s0,8
[1129] 0x900000001fc08a74:  02 47 00 1a div	s2,a3
[1129] 0x900000001fc08a78:  00 00 38 10 mfhi	a3
[1129] 0x900000001fc08a7c:  14 e0 00 03 bne	a3,zero,0x900000001fc08a8c
[1129] 0x900000001fc08a80:  02 40 98 25 move	s3,s2
[1130] 0x900000001fc08a84:  0f f0 2c e3 jal		loprintf
[1130] 0x900000001fc08a88:  02 c0 20 25 move	a0,s6
[1126] 0x900000001fc08a8c:  56 35 ff f1 bnel	s1,s5,0x900000001fc08a54
[1126] 0x900000001fc08a90:  de 26 00 00 ld	a2,0(s1)
[1126] 0x900000001fc08a94:  df c5 01 18 ld	a1,280(s8)
[1132] 0x900000001fc08a98:  0f f0 2c e3 jal		loprintf
[1132] 0x900000001fc08a9c:  66 e4 10 10 daddiu	a0,s7,4112
[1133] 0x900000001fc08aa0:  df c5 01 10 ld	a1,272(s8)
[1133] 0x900000001fc08aa4:  df c6 01 00 ld	a2,256(s8)
[1133] 0x900000001fc08aa8:  0f f0 2c e3 jal		loprintf
[1133] 0x900000001fc08aac:  66 e4 10 20 daddiu	a0,s7,4128
[1134] 0x900000001fc08ab0:  df c5 01 08 ld	a1,264(s8)
[1134] 0x900000001fc08ab4:  0f f0 2c e3 jal		loprintf
[1134] 0x900000001fc08ab8:  66 e4 10 38 daddiu	a0,s7,4152
[1135] 0x900000001fc08abc:  0f f0 18 89 jal		xlate_cause
[1135] 0x900000001fc08ac0:  df c4 01 08 ld	a0,264(s8)
[1136] 0x900000001fc08ac4:  0f f0 0d 9a jal		get_ERTOIP
[1136] 0x900000001fc08ac8:  00 00 00 21 nada
[1136] 0x900000001fc08acc:  50 40 00 4a beql	v0,zero,0x900000001fc08bf8
[1136] 0x900000001fc08ad0:  df b1 00 38 ld	s1,56(sp)
[1137] 0x900000001fc08ad4:  0f f0 18 dd jal		xlate_ertoip
[1137] 0x900000001fc08ad8:  00 40 20 25 move	a0,v0
[1137] 0x900000001fc08adc:  10 00 00 46 b		0x900000001fc08bf8
[1137] 0x900000001fc08ae0:  df b1 00 38 ld	s1,56(sp)
[1122] 0x900000001fc08ae4:  02 a0 28 25 move	a1,s5
[1122] 0x900000001fc08ae8:  0f f0 16 cc jal		_config
[1122] 0x900000001fc08aec:  02 80 20 25 move	a0,s4
[1123] 0x900000001fc08af0:  00 40 28 25 move	a1,v0
[1123] 0x900000001fc08af4:  56 80 00 40 bnel	s4,zero,0x900000001fc08bf8
[1123] 0x900000001fc08af8:  df b1 00 38 ld	s1,56(sp)
[1124] 0x900000001fc08afc:  0f f0 2c e3 jal		loprintf
[1124] 0x900000001fc08b00:  66 e4 0f f0 daddiu	a0,s7,4080
[1124] 0x900000001fc08b04:  10 00 00 3c b		0x900000001fc08bf8
[1124] 0x900000001fc08b08:  df b1 00 38 ld	s1,56(sp)
[1118] 0x900000001fc08b0c:  02 a0 28 25 move	a1,s5
[1118] 0x900000001fc08b10:  0f f0 16 bc jal		_epc
[1118] 0x900000001fc08b14:  02 80 20 25 move	a0,s4
[1119] 0x900000001fc08b18:  00 40 28 25 move	a1,v0
[1119] 0x900000001fc08b1c:  56 80 00 36 bnel	s4,zero,0x900000001fc08bf8
[1119] 0x900000001fc08b20:  df b1 00 38 ld	s1,56(sp)
[1120] 0x900000001fc08b24:  0f f0 2c e3 jal		loprintf
[1120] 0x900000001fc08b28:  66 e4 0f e0 daddiu	a0,s7,4064
[1120] 0x900000001fc08b2c:  10 00 00 32 b		0x900000001fc08bf8
[1120] 0x900000001fc08b30:  df b1 00 38 ld	s1,56(sp)
[1114] 0x900000001fc08b34:  02 a0 28 25 move	a1,s5
[1114] 0x900000001fc08b38:  0f f0 16 b4 jal		_cause
[1114] 0x900000001fc08b3c:  02 80 20 25 move	a0,s4
[1115] 0x900000001fc08b40:  00 40 28 25 move	a1,v0
[1115] 0x900000001fc08b44:  56 80 00 2c bnel	s4,zero,0x900000001fc08bf8
[1115] 0x900000001fc08b48:  df b1 00 38 ld	s1,56(sp)
[1116] 0x900000001fc08b4c:  0f f0 2c e3 jal		loprintf
[1116] 0x900000001fc08b50:  66 e4 0f d0 daddiu	a0,s7,4048
[1116] 0x900000001fc08b54:  10 00 00 28 b		0x900000001fc08bf8
[1116] 0x900000001fc08b58:  df b1 00 38 ld	s1,56(sp)
[1110] 0x900000001fc08b5c:  02 a0 28 25 move	a1,s5
[1110] 0x900000001fc08b60:  0f f0 16 ac jal		_sr
[1110] 0x900000001fc08b64:  02 80 20 25 move	a0,s4
[1111] 0x900000001fc08b68:  00 40 28 25 move	a1,v0
[1111] 0x900000001fc08b6c:  56 80 00 22 bnel	s4,zero,0x900000001fc08bf8
[1111] 0x900000001fc08b70:  df b1 00 38 ld	s1,56(sp)
[1112] 0x900000001fc08b74:  0f f0 2c e3 jal		loprintf
[1112] 0x900000001fc08b78:  66 e4 0f c0 daddiu	a0,s7,4032
[1112] 0x900000001fc08b7c:  10 00 00 1e b		0x900000001fc08bf8
[1112] 0x900000001fc08b80:  df b1 00 38 ld	s1,56(sp)
[1106] 0x900000001fc08b84:  02 a0 28 25 move	a1,s5
[1106] 0x900000001fc08b88:  0f f0 16 a4 jal		_sp
[1106] 0x900000001fc08b8c:  02 80 20 25 move	a0,s4
[1107] 0x900000001fc08b90:  00 40 28 25 move	a1,v0
[1107] 0x900000001fc08b94:  56 80 00 18 bnel	s4,zero,0x900000001fc08bf8
[1107] 0x900000001fc08b98:  df b1 00 38 ld	s1,56(sp)
[1108] 0x900000001fc08b9c:  0f f0 2c e3 jal		loprintf
[1108] 0x900000001fc08ba0:  66 e4 0f b0 daddiu	a0,s7,4016
[1108] 0x900000001fc08ba4:  10 00 00 14 b		0x900000001fc08bf8
[1108] 0x900000001fc08ba8:  df b1 00 38 ld	s1,56(sp)
[1099] 0x900000001fc08bac:  0f f0 36 bd jal		lo_atoi
[1099] 0x900000001fc08bb0:  66 44 00 04 daddiu	a0,s2,4
[1100] 0x900000001fc08bb4:  28 50 00 20 slti	s0,v0,32
[1100] 0x900000001fc08bb8:  18 40 00 0c blez	v0,0x900000001fc08bec
[1100] 0x900000001fc08bbc:  00 40 98 25 move	s3,v0
[1100] 0x900000001fc08bc0:  12 00 00 0a beq	s0,zero,0x900000001fc08bec
[1100] 0x900000001fc08bc4:  00 00 00 21 nada
[1104] 0x900000001fc08bc8:  00 02 40 00 sll	a4,v0,0
[1104] 0x900000001fc08bcc:  00 08 40 f8 dsll	a4,a4,3
[1104] 0x900000001fc08bd0:  02 60 28 25 move	a1,s3
[1104] 0x900000001fc08bd4:  03 c8 40 2d daddu	a4,s8,a4
[1104] 0x900000001fc08bd8:  66 e4 0f a0 daddiu	a0,s7,4000
[1104] 0x900000001fc08bdc:  0f f0 2c e3 jal		loprintf
[1104] 0x900000001fc08be0:  dd 06 00 00 ld	a2,0(a4)
[1104] 0x900000001fc08be4:  10 00 00 04 b		0x900000001fc08bf8
[1104] 0x900000001fc08be8:  df b1 00 38 ld	s1,56(sp)
[1101] 0x900000001fc08bec:  0f f0 2c e3 jal		loprintf
[1101] 0x900000001fc08bf0:  66 e4 0f 80 daddiu	a0,s7,3968
[1102] 0x900000001fc08bf4:  df b1 00 38 ld	s1,56(sp)
[1102] 0x900000001fc08bf8:  df b3 00 28 ld	s3,40(sp)
[1102] 0x900000001fc08bfc:  df b5 00 18 ld	s5,24(sp)
[1102] 0x900000001fc08c00:  df be 00 00 ld	s8,0(sp)
[1102] 0x900000001fc08c04:  df bf 00 48 ld	ra,72(sp)
[1102] 0x900000001fc08c08:  df b6 00 10 ld	s6,16(sp)
[1102] 0x900000001fc08c0c:  df b4 00 20 ld	s4,32(sp)
[1102] 0x900000001fc08c10:  df b2 00 30 ld	s2,48(sp)
[1102] 0x900000001fc08c14:  df b0 00 40 ld	s0,64(sp)
[1102] 0x900000001fc08c18:  df b7 00 08 ld	s7,8(sp)
[1102] 0x900000001fc08c1c:  03 e0 00 08 jr	ra
[1102] 0x900000001fc08c20:  67 bd 00 50 daddiu	sp,sp,80
 1141:     }
 1142: }
 1143: 
 1144: void 
 1145: send_int(int slot, int cpu, int number)
 1146: {
 1147:     SD_LO(EV_SENDINT,  ((slot&0xf)<<2) | (cpu&0x3) | (number<<8));
send_int:
[1147] 0x900000001fc08c24:  30 81 00 0f andi	at,a0,0xf
[1147] 0x900000001fc08c28:  30 a5 00 03 andi	a1,a1,0x3
[1147] 0x900000001fc08c2c:  00 06 22 00 sll	a0,a2,8
[1147] 0x900000001fc08c30:  00 01 08 80 sll	at,at,2
[1147] 0x900000001fc08c34:  3c 02 90 00 lui	v0,0x9000
[1147] 0x900000001fc08c38:  60 42 00 00 daddi	v0,v0,0
[1147] 0x900000001fc08c3c:  3c 03 1f c2 lui	v1,0x1fc2
[1147] 0x900000001fc08c40:  60 63 9b 40 daddi	v1,v1,-25792
[1147] 0x900000001fc08c44:  00 25 08 25 or	at,at,a1
[1147] 0x900000001fc08c48:  00 02 10 3c dsll32	v0,v0,0
[1147] 0x900000001fc08c4c:  00 24 08 25 or	at,at,a0
[1147] 0x900000001fc08c50:  00 43 10 2c dadd	v0,v0,v1
[1147] 0x900000001fc08c54:  24 03 ff ff li	v1,-1
[1147] 0x900000001fc08c58:  00 23 08 24 and	at,at,v1
[1147] 0x900000001fc08c5c:  00 01 08 3c dsll32	at,at,0
[1147] 0x900000001fc08c60:  dc 42 10 68 ld	v0,4200(v0)
[1147] 0x900000001fc08c64:  00 01 08 3e dsrl32	at,at,0
 1148: }
[1148] 0x900000001fc08c68:  03 e0 00 08 jr	ra
[1148] 0x900000001fc08c6c:  fc 41 00 00 sd	at,0(v0)
 1149: 
 1150: 
 1151: void 
 1152: conf_register(int rw, uint slot, uint reg_num, __uint64_t data, int repeat)
 1153: {
conf_register:
[1153] 0x900000001fc08c70:  67 bd ff f0 daddiu	sp,sp,-16
 1154:     volatile __uint64_t *address;
 1155: 
 1156:     if (slot > 15) {
[1156] 0x900000001fc08c74:  3c 01 90 00 lui	at,0x9000
[1156] 0x900000001fc08c78:  60 21 00 00 daddi	at,at,0
[1156] 0x900000001fc08c7c:  3c 02 1f c2 lui	v0,0x1fc2
[1156] 0x900000001fc08c80:  60 43 9b 40 daddi	v1,v0,-25792
[1156] 0x900000001fc08c84:  2c d9 01 00 sltiu	t9,a2,256
[1156] 0x900000001fc08c88:  00 01 10 3c dsll32	v0,at,0
[1156] 0x900000001fc08c8c:  2c a1 00 10 sltiu	at,a1,16
[1156] 0x900000001fc08c90:  ff bf 00 00 sd	ra,0(sp)
[1156] 0x900000001fc08c94:  10 20 00 1a beq	at,zero,0x900000001fc08d00
[1156] 0x900000001fc08c98:  00 43 58 2c dadd	a7,v0,v1
 1157: 	loprintf("*** Slot out of range\n");
 1158: 	return;
 1159:     }
 1160:     if (reg_num > 255) {
[1160] 0x900000001fc08c9c:  13 20 00 14 beq	t9,zero,0x900000001fc08cf0
[1160] 0x900000001fc08ca0:  00 00 00 21 nada
 1161: 	loprintf("*** Reg. num. out of range\n");
 1162: 	return;
 1163:     }
 1164: 
 1165:     address = (volatile __uint64_t *)
[1165] 0x900000001fc08ca4:  00 05 4a c0 sll	a5,a1,11
[1165] 0x900000001fc08ca8:  00 09 48 3c dsll32	a5,a5,0
[1165] 0x900000001fc08cac:  00 06 50 c0 sll	a6,a2,3
[1165] 0x900000001fc08cb0:  00 0a 50 3c dsll32	a6,a6,0
[1165] 0x900000001fc08cb4:  00 09 48 3e dsrl32	a5,a5,0
[1165] 0x900000001fc08cb8:  00 0a 50 3e dsrl32	a6,a6,0
 1166: 	(EV_CONFIGREG_BASE + (slot << 11) + (reg_num << 3));
 1167: 
 1168:     if (rw)
[1168] 0x900000001fc08cbc:  01 2a 48 2d daddu	a5,a5,a6
[1168] 0x900000001fc08cc0:  dd 6a 10 c0 ld	a6,4288(a7)
[1168] 0x900000001fc08cc4:  14 80 00 03 bne	a0,zero,0x900000001fc08cd4
[1168] 0x900000001fc08cc8:  01 2a c8 2f dsubu	t9,a5,a6
 1169: 	*address = data;
 1170:     else
 1171: 	data = *address;
[1171] 0x900000001fc08ccc:  10 00 00 02 b		0x900000001fc08cd8
[1171] 0x900000001fc08cd0:  df 27 00 00 ld	a3,0(t9)
[1169] 0x900000001fc08cd4:  ff 27 00 00 sd	a3,0(t9)
 1172: #ifdef NOPRINT
 1173:     if (!repeat)
[1173] 0x900000001fc08cd8:  55 00 00 0c bnel	a4,zero,0x900000001fc08d0c
[1173] 0x900000001fc08cdc:  df bf 00 00 ld	ra,0(sp)
 1174: #endif /* NOPRINT */
 1175: 	loprintf("Slot %b, Reg %b: %y\n", slot, reg_num, data);
[1175] 0x900000001fc08ce0:  0f f0 2c e3 jal		loprintf
[1175] 0x900000001fc08ce4:  65 64 10 a8 daddiu	a0,a7,4264
[1175] 0x900000001fc08ce8:  10 00 00 08 b		0x900000001fc08d0c
[1175] 0x900000001fc08cec:  df bf 00 00 ld	ra,0(sp)
[1161] 0x900000001fc08cf0:  0f f0 2c e3 jal		loprintf
[1161] 0x900000001fc08cf4:  65 64 10 88 daddiu	a0,a7,4232
[1162] 0x900000001fc08cf8:  10 00 00 04 b		0x900000001fc08d0c
[1162] 0x900000001fc08cfc:  df bf 00 00 ld	ra,0(sp)
[1157] 0x900000001fc08d00:  0f f0 2c e3 jal		loprintf
[1157] 0x900000001fc08d04:  65 64 10 70 daddiu	a0,a7,4208
[1158] 0x900000001fc08d08:  df bf 00 00 ld	ra,0(sp)
[1158] 0x900000001fc08d0c:  03 e0 00 08 jr	ra
[1158] 0x900000001fc08d10:  67 bd 00 10 daddiu	sp,sp,16
 1176: }
 1177: 
 1178: /*
 1179:  * Display the state of the IO4 board in the specified slot.  Used
 1180:  */
 1181: 
 1182: void 
 1183: dump_io4(uint slot)
 1184: {
dump_io4:
[1184] 0x900000001fc08d14:  67 bd ff e0 daddiu	sp,sp,-32
[1184] 0x900000001fc08d18:  00 80 28 25 move	a1,a0
 1185:     evreg_t value;
 1186: 
 1187:     /*
 1188:      * First we insure that the slot specified by the user is
 1189:      * valid and actually contains an IO-type board.
 1190:      */
 1191:     if (slot > 15) {
[1191] 0x900000001fc08d1c:  3c 01 90 00 lui	at,0x9000
[1191] 0x900000001fc08d20:  3c 02 1f c2 lui	v0,0x1fc2
[1191] 0x900000001fc08d24:  60 21 00 00 daddi	at,at,0
[1191] 0x900000001fc08d28:  60 43 9b 40 daddi	v1,v0,-25792
[1191] 0x900000001fc08d2c:  00 01 10 3c dsll32	v0,at,0
[1191] 0x900000001fc08d30:  2c a1 00 10 sltiu	at,a1,16
[1191] 0x900000001fc08d34:  ff b0 00 10 sd	s0,16(sp)
[1191] 0x900000001fc08d38:  10 20 00 5e beq	at,zero,0x900000001fc08eb4
[1191] 0x900000001fc08d3c:  00 43 80 2c dadd	s0,v0,v1
[1191] 0x900000001fc08d40:  ff b1 00 08 sd	s1,8(sp)
[1191] 0x900000001fc08d44:  00 05 3a c0 sll	a3,a1,11
 1192: 	loprintf("*** Slot 0x%b is out of range.\n", slot);
 1193: 	return;
 1194:     }
 1195: 	
 1196:     if ( !(LD(EV_SYSCONFIG) & (1 << slot))) {
[1196] 0x900000001fc08d48:  de 04 12 c8 ld	a0,4808(s0)
[1196] 0x900000001fc08d4c:  24 06 00 01 li	a2,1
[1196] 0x900000001fc08d50:  00 a6 30 04 sllv	a2,a2,a1
[1196] 0x900000001fc08d54:  dc 84 00 00 ld	a0,0(a0)
[1196] 0x900000001fc08d58:  00 86 20 24 and	a0,a0,a2
[1196] 0x900000001fc08d5c:  10 80 00 50 beq	a0,zero,0x900000001fc08ea0
[1196] 0x900000001fc08d60:  00 07 38 3c dsll32	a3,a3,0
 1197: 	loprintf("*** Slot 0x%b is empty.\n", slot);
 1198: 	return;
 1199:     }
 1200:  
 1201:     value = EV_GET_CONFIG(slot, IO4_CONF_REVTYPE) & IO4_TYPE_MASK;
[1201] 0x900000001fc08d64:  00 07 88 3e dsrl32	s1,a3,0
[1201] 0x900000001fc08d68:  de 07 12 d0 ld	a3,4816(s0)
[1201] 0x900000001fc08d6c:  02 27 c8 2d daddu	t9,s1,a3
[1201] 0x900000001fc08d70:  ff bf 00 18 sd	ra,24(sp)
[1201] 0x900000001fc08d74:  df 27 00 00 ld	a3,0(t9)
 1202:     if (value != IO4_TYPE_VALUE) {
[1202] 0x900000001fc08d78:  30 e7 00 0f andi	a3,a3,0xf
[1202] 0x900000001fc08d7c:  24 08 00 03 li	a4,3
[1202] 0x900000001fc08d80:  54 e8 00 43 bnel	a3,a4,0x900000001fc08e90
[1202] 0x900000001fc08d84:  df b1 00 08 ld	s1,8(sp)
 1203: 	loprintf("*** Slot 0x%b does not contain an IO board\n", slot);
 1204: 	return;
 1205:     }
 1206: 
 1207:     /*
 1208:      * Now dump the actual registers.
 1209:      */
 1210:     loprintf("Configuration of the IO board in slot 0x%b\n", slot);
[1210] 0x900000001fc08d88:  ff b9 00 00 sd	t9,0(sp)
[1210] 0x900000001fc08d8c:  0f f0 2c e3 jal		loprintf
[1210] 0x900000001fc08d90:  66 04 11 38 daddiu	a0,s0,4408
 1211:     loprintf("  Large Window: %d,     Small Window: %d\n",
[1211] 0x900000001fc08d94:  de 09 09 00 ld	a5,2304(s0)
[1211] 0x900000001fc08d98:  02 29 50 2d daddu	a6,s1,a5
[1211] 0x900000001fc08d9c:  df a9 00 00 ld	a5,0(sp)
[1211] 0x900000001fc08da0:  dd 45 00 00 ld	a1,0(a6)
[1211] 0x900000001fc08da4:  66 04 11 68 daddiu	a0,s0,4456
[1211] 0x900000001fc08da8:  dd 29 00 00 ld	a5,0(a5)
[1211] 0x900000001fc08dac:  0f f0 2c e3 jal		loprintf
[1211] 0x900000001fc08db0:  00 09 32 3b dsra	a2,a5,8
 1212: 	     EV_GET_CONFIG(slot, IO4_CONF_LW), 
 1213: 	     EV_GET_CONFIG(slot, IO4_CONF_SW) >> 8);
 1214:     loprintf("  Endianness:          %s Endian\n", 
[1214] 0x900000001fc08db4:  66 0b 11 be daddiu	a7,s0,4542
[1214] 0x900000001fc08db8:  de 09 12 d8 ld	a5,4824(s0)
[1214] 0x900000001fc08dbc:  02 29 48 2d daddu	a5,s1,a5
[1214] 0x900000001fc08dc0:  dd 29 00 00 ld	a5,0(a5)
[1214] 0x900000001fc08dc4:  51 20 00 04 beql	a5,zero,0x900000001fc08dd8
[1214] 0x900000001fc08dc8:  01 60 28 25 move	a1,a7
[1214] 0x900000001fc08dcc:  10 00 00 01 b		0x900000001fc08dd4
[1214] 0x900000001fc08dd0:  66 0b 11 ba daddiu	a7,s0,4538
[1214] 0x900000001fc08dd4:  01 60 28 25 move	a1,a7
[1214] 0x900000001fc08dd8:  0f f0 2c e3 jal		loprintf
[1214] 0x900000001fc08ddc:  66 04 11 98 daddiu	a0,s0,4504
 1215: 	     (EV_GET_CONFIG(slot, IO4_CONF_ENDIAN) ? "Big" : "Little"));
 1216:     loprintf("  Adapter Control:     0x%x\n", 
[1216] 0x900000001fc08de0:  de 0b 12 e0 ld	a7,4832(s0)
[1216] 0x900000001fc08de4:  02 2b 58 2d daddu	a7,s1,a7
[1216] 0x900000001fc08de8:  66 04 11 c8 daddiu	a0,s0,4552
[1216] 0x900000001fc08dec:  0f f0 2c e3 jal		loprintf
[1216] 0x900000001fc08df0:  dd 65 00 00 ld	a1,0(a7)
 1217: 	     EV_GET_CONFIG(slot, IO4_CONF_ADAP));
 1218:     value = EV_GET_CONFIG(slot, IO4_CONF_INTRVECTOR);
[1218] 0x900000001fc08df4:  de 0b 12 e8 ld	a7,4840(s0)
[1218] 0x900000001fc08df8:  02 2b 58 2d daddu	a7,s1,a7
 1219:     loprintf("  Interrupt Vector:    Level 0x%x, Destination 0x%x\n",
[1219] 0x900000001fc08dfc:  66 04 11 e8 daddiu	a0,s0,4584
[1219] 0x900000001fc08e00:  dd 6b 00 00 ld	a7,0(a7)
[1219] 0x900000001fc08e04:  00 0b 2a 3a dsrl	a1,a7,8
[1219] 0x900000001fc08e08:  0f f0 2c e3 jal		loprintf
[1219] 0x900000001fc08e0c:  31 66 00 7f andi	a2,a7,0x7f
 1220: 	     EVINTR_LEVEL(value), EVINTR_DEST(value));
 1221:     loprintf("  Config status:       HI: 0x%x, LO: 0x%x\n",
[1221] 0x900000001fc08e10:  de 0b 09 08 ld	a7,2312(s0)
[1221] 0x900000001fc08e14:  02 2b 60 2d daddu	t0,s1,a7
[1221] 0x900000001fc08e18:  de 0b 09 10 ld	a7,2320(s0)
[1221] 0x900000001fc08e1c:  02 2b 58 2d daddu	a7,s1,a7
[1221] 0x900000001fc08e20:  66 04 12 20 daddiu	a0,s0,4640
[1221] 0x900000001fc08e24:  dd 85 00 00 ld	a1,0(t0)
[1221] 0x900000001fc08e28:  0f f0 2c e3 jal		loprintf
[1221] 0x900000001fc08e2c:  dd 66 00 00 ld	a2,0(a7)
 1222: 	     EV_GET_CONFIG(slot, IO4_CONF_IODEV1), 
 1223: 	     EV_GET_CONFIG(slot, IO4_CONF_IODEV0));
 1224:     loprintf("  IBUS Error:          0x%x\n", 
[1224] 0x900000001fc08e30:  de 0b 12 f0 ld	a7,4848(s0)
[1224] 0x900000001fc08e34:  02 2b 58 2d daddu	a7,s1,a7
[1224] 0x900000001fc08e38:  66 04 12 50 daddiu	a0,s0,4688
[1224] 0x900000001fc08e3c:  0f f0 2c e3 jal		loprintf
[1224] 0x900000001fc08e40:  dd 65 00 00 ld	a1,0(a7)
 1225: 	     EV_GET_CONFIG(slot, IO4_CONF_IBUSERROR));
 1226:     loprintf("  EBUS Error1:          0x%x\n", 
[1226] 0x900000001fc08e44:  de 0b 12 f8 ld	a7,4856(s0)
[1226] 0x900000001fc08e48:  02 2b 58 2d daddu	a7,s1,a7
[1226] 0x900000001fc08e4c:  66 04 12 70 daddiu	a0,s0,4720
[1226] 0x900000001fc08e50:  0f f0 2c e3 jal		loprintf
[1226] 0x900000001fc08e54:  dd 65 00 00 ld	a1,0(a7)
 1227: 	     EV_GET_CONFIG(slot, IO4_CONF_EBUSERROR));
 1228:     loprintf("          EBUS Err2Hi: 0x%x  EBUS Err2Lo: 0x%x\n",
[1228] 0x900000001fc08e58:  de 0b 13 00 ld	a7,4864(s0)
[1228] 0x900000001fc08e5c:  02 2b 60 2d daddu	t0,s1,a7
[1228] 0x900000001fc08e60:  de 0b 13 08 ld	a7,4872(s0)
[1228] 0x900000001fc08e64:  02 2b 58 2d daddu	a7,s1,a7
[1228] 0x900000001fc08e68:  df b1 00 08 ld	s1,8(sp)
[1228] 0x900000001fc08e6c:  66 04 12 90 daddiu	a0,s0,4752
[1228] 0x900000001fc08e70:  dd 85 00 00 ld	a1,0(t0)
[1228] 0x900000001fc08e74:  0f f0 2c e3 jal		loprintf
[1228] 0x900000001fc08e78:  dd 66 00 00 ld	a2,0(a7)
 1229: 	     EV_GET_CONFIG(slot, IO4_CONF_EBUSERROR2), 
 1230: 	     EV_GET_CONFIG(slot, IO4_CONF_EBUSERROR1));
 1231: 
 1232:     loprintf("\n");
[1232] 0x900000001fc08e7c:  0f f0 2c e3 jal		loprintf
[1232] 0x900000001fc08e80:  66 04 12 c0 daddiu	a0,s0,4800
 1233: }	
[1233] 0x900000001fc08e84:  10 00 00 0f b		0x900000001fc08ec4
[1233] 0x900000001fc08e88:  df b0 00 10 ld	s0,16(sp)
[1233] 0x900000001fc08e8c:  df b1 00 08 ld	s1,8(sp)
[1203] 0x900000001fc08e90:  0f f0 2c e3 jal		loprintf
[1203] 0x900000001fc08e94:  66 04 11 08 daddiu	a0,s0,4360
[1204] 0x900000001fc08e98:  10 00 00 0a b		0x900000001fc08ec4
[1204] 0x900000001fc08e9c:  df b0 00 10 ld	s0,16(sp)
[1197] 0x900000001fc08ea0:  ff bf 00 18 sd	ra,24(sp)
[1197] 0x900000001fc08ea4:  0f f0 2c e3 jal		loprintf
[1197] 0x900000001fc08ea8:  66 04 10 e8 daddiu	a0,s0,4328
[1198] 0x900000001fc08eac:  10 00 00 05 b		0x900000001fc08ec4
[1198] 0x900000001fc08eb0:  df b0 00 10 ld	s0,16(sp)
[1192] 0x900000001fc08eb4:  ff bf 00 18 sd	ra,24(sp)
[1192] 0x900000001fc08eb8:  0f f0 2c e3 jal		loprintf
[1192] 0x900000001fc08ebc:  66 04 10 c8 daddiu	a0,s0,4296
[1193] 0x900000001fc08ec0:  df b0 00 10 ld	s0,16(sp)
[1193] 0x900000001fc08ec4:  df bf 00 18 ld	ra,24(sp)
[1193] 0x900000001fc08ec8:  03 e0 00 08 jr	ra
[1193] 0x900000001fc08ecc:  67 bd 00 20 daddiu	sp,sp,32
 1234: 
 1235: 
 1236: /*
 1237:  * Displays the contents of the major MC3 device registers.
 1238:  */
 1239: 
 1240: void dump_mc3(uint slot)
 1241: {
dump_mc3:
[1241] 0x900000001fc08ed0:  67 bd ff 00 daddiu	sp,sp,-256
 1242:     uint mem;
 1243:     int i, j;
 1244: 
 1245:     mem = memory_slots();
[1245] 0x900000001fc08ed4:  ff be 00 a8 sd	s8,168(sp)
[1245] 0x900000001fc08ed8:  ff bf 00 f0 sd	ra,240(sp)
[1245] 0x900000001fc08edc:  0f f0 17 2e jal		memory_slots
[1245] 0x900000001fc08ee0:  00 80 f0 25 move	s8,a0
 1246: 
 1247:     if (slot > 15) {
[1247] 0x900000001fc08ee4:  00 40 08 25 move	at,v0
[1247] 0x900000001fc08ee8:  3c 02 90 00 lui	v0,0x9000
[1247] 0x900000001fc08eec:  60 42 00 00 daddi	v0,v0,0
[1247] 0x900000001fc08ef0:  24 04 00 01 li	a0,1
[1247] 0x900000001fc08ef4:  3c 03 1f c2 lui	v1,0x1fc2
[1247] 0x900000001fc08ef8:  03 c4 20 04 sllv	a0,a0,s8
[1247] 0x900000001fc08efc:  60 63 9b 40 daddi	v1,v1,-25792
[1247] 0x900000001fc08f00:  00 02 10 3c dsll32	v0,v0,0
[1247] 0x900000001fc08f04:  ff b0 00 e8 sd	s0,232(sp)
[1247] 0x900000001fc08f08:  00 24 80 24 and	s0,at,a0
[1247] 0x900000001fc08f0c:  2f c1 00 10 sltiu	at,s8,16
[1247] 0x900000001fc08f10:  ff b1 00 e0 sd	s1,224(sp)
[1247] 0x900000001fc08f14:  10 20 00 c1 beq	at,zero,0x900000001fc0921c
[1247] 0x900000001fc08f18:  00 43 88 2c dadd	s1,v0,v1
 1248: 	loprintf("*** Slot out of range\n");
 1249: 	return;
 1250:     }
 1251: 
 1252:     if (!((1 << slot) & mem)) {
[1252] 0x900000001fc08f1c:  52 00 00 bb beql	s0,zero,0x900000001fc0920c
[1252] 0x900000001fc08f20:  03 c0 28 25 move	a1,s8
 1253: 	loprintf("*** Slot %b has no memory board.\n", slot);
 1254: 	return;
 1255:     }
 1256:     loprintf("Configuration of the memory board in slot %b\n", slot);
[1256] 0x900000001fc08f24:  03 c0 28 25 move	a1,s8
[1256] 0x900000001fc08f28:  0f f0 2c e3 jal		loprintf
[1256] 0x900000001fc08f2c:  66 24 13 50 daddiu	a0,s1,4944
 1257:     loprintf(" EBus Error:   %x\n", read_reg(slot, MC3_EBUSERROR));
[1257] 0x900000001fc08f30:  24 05 00 08 li	a1,8
[1257] 0x900000001fc08f34:  0f f0 24 8f jal		read_reg
[1257] 0x900000001fc08f38:  03 c0 20 25 move	a0,s8
[1257] 0x900000001fc08f3c:  00 40 28 25 move	a1,v0
[1257] 0x900000001fc08f40:  0f f0 2c e3 jal		loprintf
[1257] 0x900000001fc08f44:  66 24 13 80 daddiu	a0,s1,4992
 1258:     loprintf(" Leaf Enable:  %x\n", read_reg(slot, MC3_LEAFCTLENB));
[1258] 0x900000001fc08f48:  24 05 00 0a li	a1,10
[1258] 0x900000001fc08f4c:  0f f0 24 8f jal		read_reg
[1258] 0x900000001fc08f50:  03 c0 20 25 move	a0,s8
[1258] 0x900000001fc08f54:  00 40 28 25 move	a1,v0
[1258] 0x900000001fc08f58:  0f f0 2c e3 jal		loprintf
[1258] 0x900000001fc08f5c:  66 24 13 98 daddiu	a0,s1,5016
 1259:     loprintf(" Bank Enable:  %x\n", read_reg(slot, MC3_BANKENB));
[1259] 0x900000001fc08f60:  00 00 28 25 move	a1,zero
[1259] 0x900000001fc08f64:  0f f0 24 8f jal		read_reg
[1259] 0x900000001fc08f68:  03 c0 20 25 move	a0,s8
[1259] 0x900000001fc08f6c:  00 40 28 25 move	a1,v0
[1259] 0x900000001fc08f70:  0f f0 2c e3 jal		loprintf
[1259] 0x900000001fc08f74:  66 24 13 b0 daddiu	a0,s1,5040
 1260:     loprintf(" BIST Result:  %x\n", read_reg(slot, MC3_BISTRESULT));
[1260] 0x900000001fc08f78:  24 05 00 06 li	a1,6
[1260] 0x900000001fc08f7c:  0f f0 24 8f jal		read_reg
[1260] 0x900000001fc08f80:  03 c0 20 25 move	a0,s8
[1260] 0x900000001fc08f84:  00 40 28 25 move	a1,v0
[1260] 0x900000001fc08f88:  0f f0 2c e3 jal		loprintf
[1260] 0x900000001fc08f8c:  66 24 13 c8 daddiu	a0,s1,5064
 1261:     for (i = 0; i < 2; i++) {
[1261] 0x900000001fc08f90:  ff b7 00 b0 sd	s7,176(sp)
[1261] 0x900000001fc08f94:  ff b6 00 b8 sd	s6,184(sp)
[1261] 0x900000001fc08f98:  ff b5 00 c0 sd	s5,192(sp)
[1261] 0x900000001fc08f9c:  ff b4 00 c8 sd	s4,200(sp)
[1261] 0x900000001fc08fa0:  ff b3 00 d0 sd	s3,208(sp)
[1261] 0x900000001fc08fa4:  ff b2 00 d8 sd	s2,216(sp)
[1261] 0x900000001fc08fa8:  ff a0 00 00 sd	zero,0(sp)
[1261] 0x900000001fc08fac:  66 27 13 e0 daddiu	a3,s1,5088
[1261] 0x900000001fc08fb0:  ff a0 00 20 sd	zero,32(sp)
[1261] 0x900000001fc08fb4:  66 26 13 f0 daddiu	a2,s1,5104
[1261] 0x900000001fc08fb8:  ff a7 00 08 sd	a3,8(sp)
[1261] 0x900000001fc08fbc:  66 25 14 30 daddiu	a1,s1,5168
[1261] 0x900000001fc08fc0:  ff a6 00 10 sd	a2,16(sp)
[1261] 0x900000001fc08fc4:  ff a5 00 18 sd	a1,24(sp)
[1261] 0x900000001fc08fc8:  24 05 00 24 li	a1,36
[1261] 0x900000001fc08fcc:  ff a5 00 28 sd	a1,40(sp)
[1261] 0x900000001fc08fd0:  24 05 00 20 li	a1,32
[1261] 0x900000001fc08fd4:  ff a5 00 30 sd	a1,48(sp)
[1261] 0x900000001fc08fd8:  24 05 00 22 li	a1,34
[1261] 0x900000001fc08fdc:  ff a5 00 38 sd	a1,56(sp)
[1261] 0x900000001fc08fe0:  24 05 00 23 li	a1,35
[1261] 0x900000001fc08fe4:  ff a5 00 40 sd	a1,64(sp)
[1261] 0x900000001fc08fe8:  24 05 00 30 li	a1,48
[1261] 0x900000001fc08fec:  ff a5 00 48 sd	a1,72(sp)
[1261] 0x900000001fc08ff0:  24 05 00 31 li	a1,49
[1261] 0x900000001fc08ff4:  ff a5 00 50 sd	a1,80(sp)
[1261] 0x900000001fc08ff8:  24 05 00 32 li	a1,50
[1261] 0x900000001fc08ffc:  ff a5 00 58 sd	a1,88(sp)
[1261] 0x900000001fc09000:  24 05 00 33 li	a1,51
[1261] 0x900000001fc09004:  ff a5 00 60 sd	a1,96(sp)
[1261] 0x900000001fc09008:  24 05 00 b3 li	a1,179
[1261] 0x900000001fc0900c:  66 36 14 78 daddiu	s6,s1,5240
[1261] 0x900000001fc09010:  66 37 14 88 daddiu	s7,s1,5256
[1261] 0x900000001fc09014:  ff a5 00 68 sd	a1,104(sp)
[1261] 0x900000001fc09018:  df a5 00 00 ld	a1,0(sp)
 1262: 	loprintf(" Leaf %d:\n", i);
[1262] 0x900000001fc0901c:  0f f0 2c e3 jal		loprintf
[1262] 0x900000001fc09020:  df a4 00 08 ld	a0,8(sp)
 1263: 	loprintf("  BIST = %x, Error = %x, ErrAddrHi = %x, ErrAddrLo = %x\n",
[1263] 0x900000001fc09024:  df a5 00 28 ld	a1,40(sp)
[1263] 0x900000001fc09028:  0f f0 24 8f jal		read_reg
[1263] 0x900000001fc0902c:  03 c0 20 25 move	a0,s8
[1263] 0x900000001fc09030:  00 40 80 25 move	s0,v0
[1263] 0x900000001fc09034:  df a5 00 30 ld	a1,48(sp)
[1263] 0x900000001fc09038:  0f f0 24 8f jal		read_reg
[1263] 0x900000001fc0903c:  03 c0 20 25 move	a0,s8
[1263] 0x900000001fc09040:  ff a2 00 80 sd	v0,128(sp)
[1263] 0x900000001fc09044:  df a5 00 38 ld	a1,56(sp)
[1263] 0x900000001fc09048:  0f f0 24 8f jal		read_reg
[1263] 0x900000001fc0904c:  03 c0 20 25 move	a0,s8
[1263] 0x900000001fc09050:  ff a2 00 88 sd	v0,136(sp)
[1263] 0x900000001fc09054:  df a5 00 40 ld	a1,64(sp)
[1263] 0x900000001fc09058:  0f f0 24 8f jal		read_reg
[1263] 0x900000001fc0905c:  03 c0 20 25 move	a0,s8
[1263] 0x900000001fc09060:  00 40 40 25 move	a4,v0
[1263] 0x900000001fc09064:  df a7 00 88 ld	a3,136(sp)
[1263] 0x900000001fc09068:  df a6 00 80 ld	a2,128(sp)
[1263] 0x900000001fc0906c:  02 00 28 25 move	a1,s0
[1263] 0x900000001fc09070:  0f f0 2c e3 jal		loprintf
[1263] 0x900000001fc09074:  df a4 00 10 ld	a0,16(sp)
 1264: 		 read_reg(slot, MC3_LEAF(i, MC3LF_BIST)),
 1265: 		 read_reg(slot, MC3_LEAF(i, MC3LF_ERROR)),
 1266: 		 read_reg(slot, MC3_LEAF(i, MC3LF_ERRADDRHI)),
 1267: 		 read_reg(slot, MC3_LEAF(i, MC3LF_ERRADDRLO)));
 1268: 	loprintf("  Syndrome 0: %h, Syndrome 1: %h, Syndrome 2: %h, Syndrome 3: %h\n",
[1268] 0x900000001fc09078:  df a5 00 48 ld	a1,72(sp)
[1268] 0x900000001fc0907c:  0f f0 24 8f jal		read_reg
[1268] 0x900000001fc09080:  03 c0 20 25 move	a0,s8
[1268] 0x900000001fc09084:  00 40 80 25 move	s0,v0
[1268] 0x900000001fc09088:  df a5 00 50 ld	a1,80(sp)
[1268] 0x900000001fc0908c:  0f f0 24 8f jal		read_reg
[1268] 0x900000001fc09090:  03 c0 20 25 move	a0,s8
[1268] 0x900000001fc09094:  ff a2 00 70 sd	v0,112(sp)
[1268] 0x900000001fc09098:  df a5 00 58 ld	a1,88(sp)
[1268] 0x900000001fc0909c:  0f f0 24 8f jal		read_reg
[1268] 0x900000001fc090a0:  03 c0 20 25 move	a0,s8
[1268] 0x900000001fc090a4:  ff a2 00 78 sd	v0,120(sp)
[1268] 0x900000001fc090a8:  df a5 00 60 ld	a1,96(sp)
[1268] 0x900000001fc090ac:  0f f0 24 8f jal		read_reg
[1268] 0x900000001fc090b0:  03 c0 20 25 move	a0,s8
[1268] 0x900000001fc090b4:  00 40 40 25 move	a4,v0
[1268] 0x900000001fc090b8:  df a7 00 78 ld	a3,120(sp)
[1268] 0x900000001fc090bc:  df a6 00 70 ld	a2,112(sp)
[1268] 0x900000001fc090c0:  02 00 28 25 move	a1,s0
[1268] 0x900000001fc090c4:  0f f0 2c e3 jal		loprintf
[1268] 0x900000001fc090c8:  df a4 00 18 ld	a0,24(sp)
 1269: 		 read_reg(slot, MC3_LEAF(i, MC3LF_SYNDROME0)),
 1270: 		 read_reg(slot, MC3_LEAF(i, MC3LF_SYNDROME1)),
 1271: 		 read_reg(slot, MC3_LEAF(i, MC3LF_SYNDROME2)),
 1272: 		 read_reg(slot, MC3_LEAF(i, MC3LF_SYNDROME3)));
 1273: 	for (j = 0; j < 4; j++) {
[1273] 0x900000001fc090cc:  df a8 00 20 ld	a4,32(sp)
[1273] 0x900000001fc090d0:  00 00 80 25 move	s0,zero
[1273] 0x900000001fc090d4:  25 11 00 10 addiu	s1,a4,16
[1273] 0x900000001fc090d8:  25 12 00 11 addiu	s2,a4,17
[1273] 0x900000001fc090dc:  25 13 00 12 addiu	s3,a4,18
[1273] 0x900000001fc090e0:  25 14 00 13 addiu	s4,a4,19
[1273] 0x900000001fc090e4:  02 00 28 25 move	a1,s0
[1273] 0x900000001fc090e8:  25 15 00 23 addiu	s5,a4,35
 1274: 	    loprintf("  Bank %d: ", j);
[1274] 0x900000001fc090ec:  0f f0 2c e3 jal		loprintf
[1274] 0x900000001fc090f0:  02 c0 20 25 move	a0,s6
 1275: 	    loprintf("Size = %x, Base = %x, IF = %x, IP = %x\n",
[1275] 0x900000001fc090f4:  02 20 28 25 move	a1,s1
[1275] 0x900000001fc090f8:  0f f0 24 8f jal		read_reg
[1275] 0x900000001fc090fc:  03 c0 20 25 move	a0,s8
[1275] 0x900000001fc09100:  ff a2 00 a0 sd	v0,160(sp)
[1275] 0x900000001fc09104:  02 40 28 25 move	a1,s2
[1275] 0x900000001fc09108:  0f f0 24 8f jal		read_reg
[1275] 0x900000001fc0910c:  03 c0 20 25 move	a0,s8
[1275] 0x900000001fc09110:  ff a2 00 90 sd	v0,144(sp)
[1275] 0x900000001fc09114:  02 60 28 25 move	a1,s3
[1275] 0x900000001fc09118:  26 73 00 04 addiu	s3,s3,4
[1275] 0x900000001fc0911c:  0f f0 24 8f jal		read_reg
[1275] 0x900000001fc09120:  03 c0 20 25 move	a0,s8
[1275] 0x900000001fc09124:  ff a2 00 98 sd	v0,152(sp)
[1275] 0x900000001fc09128:  02 80 28 25 move	a1,s4
[1275] 0x900000001fc0912c:  0f f0 24 8f jal		read_reg
[1275] 0x900000001fc09130:  03 c0 20 25 move	a0,s8
[1275] 0x900000001fc09134:  df b8 00 a0 ld	t8,160(sp)
[1275] 0x900000001fc09138:  00 40 40 25 move	a4,v0
[1275] 0x900000001fc0913c:  df a7 00 98 ld	a3,152(sp)
[1275] 0x900000001fc09140:  df a6 00 90 ld	a2,144(sp)
[1275] 0x900000001fc09144:  03 00 28 25 move	a1,t8
[1275] 0x900000001fc09148:  0f f0 2c e3 jal		loprintf
[1275] 0x900000001fc0914c:  02 e0 20 25 move	a0,s7
[1273] 0x900000001fc09150:  26 10 00 01 addiu	s0,s0,1
[1273] 0x900000001fc09154:  26 31 00 04 addiu	s1,s1,4
[1273] 0x900000001fc09158:  26 52 00 04 addiu	s2,s2,4
[1273] 0x900000001fc0915c:  26 94 00 04 addiu	s4,s4,4
[1273] 0x900000001fc09160:  16 95 ff e2 bne	s4,s5,0x900000001fc090ec
[1273] 0x900000001fc09164:  02 00 28 25 move	a1,s0
[1273] 0x900000001fc09168:  df bf 00 00 ld	ra,0(sp)
[1261] 0x900000001fc0916c:  df a7 00 20 ld	a3,32(sp)
[1261] 0x900000001fc09170:  df a6 00 28 ld	a2,40(sp)
[1261] 0x900000001fc09174:  df a5 00 30 ld	a1,48(sp)
[1261] 0x900000001fc09178:  df a4 00 38 ld	a0,56(sp)
[1261] 0x900000001fc0917c:  df a3 00 40 ld	v1,64(sp)
[1261] 0x900000001fc09180:  df a2 00 48 ld	v0,72(sp)
[1261] 0x900000001fc09184:  27 e8 00 01 addiu	a4,ra,1
[1261] 0x900000001fc09188:  df a1 00 50 ld	at,80(sp)
[1261] 0x900000001fc0918c:  df bf 00 58 ld	ra,88(sp)
[1261] 0x900000001fc09190:  24 e7 00 40 addiu	a3,a3,64
[1261] 0x900000001fc09194:  ff a8 00 00 sd	a4,0(sp)
[1261] 0x900000001fc09198:  24 c6 00 40 addiu	a2,a2,64
[1261] 0x900000001fc0919c:  ff a7 00 20 sd	a3,32(sp)
[1261] 0x900000001fc091a0:  24 a5 00 40 addiu	a1,a1,64
[1261] 0x900000001fc091a4:  ff a6 00 28 sd	a2,40(sp)
[1261] 0x900000001fc091a8:  24 84 00 40 addiu	a0,a0,64
[1261] 0x900000001fc091ac:  ff a5 00 30 sd	a1,48(sp)
[1261] 0x900000001fc091b0:  df a5 00 00 ld	a1,0(sp)
[1261] 0x900000001fc091b4:  24 63 00 40 addiu	v1,v1,64
[1261] 0x900000001fc091b8:  ff a4 00 38 sd	a0,56(sp)
[1261] 0x900000001fc091bc:  24 42 00 40 addiu	v0,v0,64
[1261] 0x900000001fc091c0:  ff a3 00 40 sd	v1,64(sp)
[1261] 0x900000001fc091c4:  24 21 00 40 addiu	at,at,64
[1261] 0x900000001fc091c8:  ff a2 00 48 sd	v0,72(sp)
[1261] 0x900000001fc091cc:  27 ff 00 40 addiu	ra,ra,64
[1261] 0x900000001fc091d0:  df b9 00 60 ld	t9,96(sp)
[1261] 0x900000001fc091d4:  27 39 00 40 addiu	t9,t9,64
[1261] 0x900000001fc091d8:  ff bf 00 58 sd	ra,88(sp)
[1261] 0x900000001fc091dc:  df bf 00 68 ld	ra,104(sp)
[1261] 0x900000001fc091e0:  ff b9 00 60 sd	t9,96(sp)
[1261] 0x900000001fc091e4:  17 3f ff 8d bne	t9,ra,0x900000001fc0901c
[1261] 0x900000001fc091e8:  ff a1 00 50 sd	at,80(sp)
[1261] 0x900000001fc091ec:  df b3 00 d0 ld	s3,208(sp)
[1261] 0x900000001fc091f0:  df b5 00 c0 ld	s5,192(sp)
[1261] 0x900000001fc091f4:  df b6 00 b8 ld	s6,184(sp)
[1261] 0x900000001fc091f8:  df b4 00 c8 ld	s4,200(sp)
[1261] 0x900000001fc091fc:  df b7 00 b0 ld	s7,176(sp)
[1261] 0x900000001fc09200:  10 00 00 08 b		0x900000001fc09224
[1261] 0x900000001fc09204:  df b2 00 d8 ld	s2,216(sp)
[1253] 0x900000001fc09208:  03 c0 28 25 move	a1,s8
[1253] 0x900000001fc0920c:  0f f0 2c e3 jal		loprintf
[1253] 0x900000001fc09210:  66 24 13 28 daddiu	a0,s1,4904
[1254] 0x900000001fc09214:  10 00 00 04 b		0x900000001fc09228
[1254] 0x900000001fc09218:  df be 00 a8 ld	s8,168(sp)
[1248] 0x900000001fc0921c:  0f f0 2c e3 jal		loprintf
[1248] 0x900000001fc09220:  66 24 13 10 daddiu	a0,s1,4880
[1249] 0x900000001fc09224:  df be 00 a8 ld	s8,168(sp)
[1249] 0x900000001fc09228:  df bf 00 f0 ld	ra,240(sp)
[1249] 0x900000001fc0922c:  df b0 00 e8 ld	s0,232(sp)
[1249] 0x900000001fc09230:  df b1 00 e0 ld	s1,224(sp)
[1249] 0x900000001fc09234:  03 e0 00 08 jr	ra
[1249] 0x900000001fc09238:  67 bd 01 00 daddiu	sp,sp,256
 1276: 		     read_reg(slot, MC3_BANK(i, j, BANK_SIZE)),	
 1277: 		     read_reg(slot, MC3_BANK(i, j, BANK_BASE)),	
 1278: 		     read_reg(slot, MC3_BANK(i, j, BANK_IF)),	
 1279: 		     read_reg(slot, MC3_BANK(i, j, BANK_IP)));
 1280: 	}
 1281:     }
 1282: }
 1283: 
 1284: uint read_reg(uint slot, uint reg_num)
 1285: {
 1286:     return (int)LD((EV_CONFIGREG_BASE + (slot << 11) + (reg_num << 3)));
read_reg:
[1286] 0x900000001fc0923c:  00 04 0a c0 sll	at,a0,11
[1286] 0x900000001fc09240:  00 05 18 c0 sll	v1,a1,3
[1286] 0x900000001fc09244:  3c 02 90 00 lui	v0,0x9000
[1286] 0x900000001fc09248:  60 42 00 00 daddi	v0,v0,0
[1286] 0x900000001fc0924c:  00 01 08 3c dsll32	at,at,0
[1286] 0x900000001fc09250:  3c 04 1f c2 lui	a0,0x1fc2
[1286] 0x900000001fc09254:  00 03 18 3c dsll32	v1,v1,0
[1286] 0x900000001fc09258:  60 84 9b 40 daddi	a0,a0,-25792
[1286] 0x900000001fc0925c:  00 02 10 3c dsll32	v0,v0,0
[1286] 0x900000001fc09260:  00 01 08 3e dsrl32	at,at,0
[1286] 0x900000001fc09264:  00 44 10 2c dadd	v0,v0,a0
[1286] 0x900000001fc09268:  00 03 18 3e dsrl32	v1,v1,0
[1286] 0x900000001fc0926c:  00 23 08 2d daddu	at,at,v1
[1286] 0x900000001fc09270:  dc 42 09 00 ld	v0,2304(v0)
[1286] 0x900000001fc09274:  00 22 08 2d daddu	at,at,v0
[1286] 0x900000001fc09278:  dc 21 00 00 ld	at,0(at)
[1286] 0x900000001fc0927c:  03 e0 00 08 jr	ra
[1286] 0x900000001fc09280:  00 01 10 00 sll	v0,at,0
 1287: }
 1288: 
 1289: void
 1290: clear_mc3_state(void)
 1291: {
clear_mc3_state:
[1291] 0x900000001fc09284:  67 bd ff c0 daddiu	sp,sp,-64
 1292:     uint mem;
 1293:     int slot = 0;
 1294:     int leaf;
 1295: 
 1296:     mem = memory_slots();
[1296] 0x900000001fc09288:  ff bf 00 38 sd	ra,56(sp)
[1296] 0x900000001fc0928c:  0f f0 17 2e jal		memory_slots
[1296] 0x900000001fc09290:  00 00 00 21 nada
[1293] 0x900000001fc09294:  ff b2 00 20 sd	s2,32(sp)
[1293] 0x900000001fc09298:  00 00 90 25 move	s2,zero
[1293] 0x900000001fc0929c:  ff b3 00 18 sd	s3,24(sp)
[1293] 0x900000001fc092a0:  00 40 98 25 move	s3,v0
 1297: 
 1298:     for (slot = 0; slot < 16; slot++) {
[1298] 0x900000001fc092a4:  ff b4 00 10 sd	s4,16(sp)
[1298] 0x900000001fc092a8:  24 14 00 10 li	s4,16
[1298] 0x900000001fc092ac:  3c 01 90 00 lui	at,0x9000
[1298] 0x900000001fc092b0:  60 21 00 00 daddi	at,at,0
[1298] 0x900000001fc092b4:  3c 02 1f c2 lui	v0,0x1fc2
[1298] 0x900000001fc092b8:  ff b6 00 00 sd	s6,0(sp)
[1298] 0x900000001fc092bc:  00 01 08 3c dsll32	at,at,0
[1298] 0x900000001fc092c0:  ff b5 00 08 sd	s5,8(sp)
[1298] 0x900000001fc092c4:  24 15 00 01 li	s5,1
[1298] 0x900000001fc092c8:  60 42 af f0 daddi	v0,v0,-20496
[1298] 0x900000001fc092cc:  00 15 18 04 sllv	v1,s5,zero
[1298] 0x900000001fc092d0:  ff b1 00 28 sd	s1,40(sp)
[1298] 0x900000001fc092d4:  24 11 00 a1 li	s1,161
[1298] 0x900000001fc092d8:  02 63 c8 24 and	t9,s3,v1
[1298] 0x900000001fc092dc:  00 22 b0 2c dadd	s6,at,v0
[1298] 0x900000001fc092e0:  ff b0 00 30 sd	s0,48(sp)
[1298] 0x900000001fc092e4:  24 10 00 21 li	s0,33
 1299: 	if (mem & (1 << slot)) {
[1299] 0x900000001fc092e8:  53 20 00 0b beql	t9,zero,0x900000001fc09318
[1299] 0x900000001fc092ec:  24 11 00 a1 li	s1,161
[1299] 0x900000001fc092f0:  02 00 28 25 move	a1,s0
 1300: 	    for (leaf = 0; leaf < MC3_NUM_LEAVES; leaf++)
 1301: 		read_reg(slot, MC3_LEAF(leaf, MC3LF_ERRORCLR));
[1301] 0x900000001fc092f4:  0f f0 24 8f jal		read_reg
[1301] 0x900000001fc092f8:  02 40 20 25 move	a0,s2
[1300] 0x900000001fc092fc:  26 10 00 40 addiu	s0,s0,64
[1300] 0x900000001fc09300:  16 11 ff fc bne	s0,s1,0x900000001fc092f4
[1300] 0x900000001fc09304:  02 00 28 25 move	a1,s0
[1300] 0x900000001fc09308:  02 40 28 25 move	a1,s2
 1302: 	    loprintf("  Cleared memory board %b's error registers\n", slot);
[1302] 0x900000001fc0930c:  0f f0 2c e3 jal		loprintf
[1302] 0x900000001fc09310:  02 c0 20 25 move	a0,s6
[1302] 0x900000001fc09314:  24 11 00 a1 li	s1,161
[1298] 0x900000001fc09318:  26 52 00 01 addiu	s2,s2,1
[1298] 0x900000001fc0931c:  24 10 00 21 li	s0,33
[1298] 0x900000001fc09320:  02 55 30 04 sllv	a2,s5,s2
[1298] 0x900000001fc09324:  16 54 ff f0 bne	s2,s4,0x900000001fc092e8
[1298] 0x900000001fc09328:  02 66 c8 24 and	t9,s3,a2
[1298] 0x900000001fc0932c:  df b3 00 18 ld	s3,24(sp)
[1298] 0x900000001fc09330:  df b1 00 28 ld	s1,40(sp)
[1298] 0x900000001fc09334:  df b6 00 00 ld	s6,0(sp)
[1298] 0x900000001fc09338:  df bf 00 38 ld	ra,56(sp)
[1298] 0x900000001fc0933c:  df b4 00 10 ld	s4,16(sp)
[1298] 0x900000001fc09340:  df b2 00 20 ld	s2,32(sp)
[1298] 0x900000001fc09344:  df b0 00 30 ld	s0,48(sp)
[1298] 0x900000001fc09348:  df b5 00 08 ld	s5,8(sp)
[1298] 0x900000001fc0934c:  03 e0 00 08 jr	ra
[1298] 0x900000001fc09350:  67 bd 00 40 daddiu	sp,sp,64
 1303: 	}
 1304:     }
 1305: }
 1306: 
 1307: void
 1308: clear_io4_state(void)
 1309: {
clear_io4_state:
[1309] 0x900000001fc09354:  67 bd ff c0 daddiu	sp,sp,-64
 1310:     uint io;
 1311:     int slot = 0;
 1312: 
 1313:     io = occupied_slots() & ~(cpu_slots() | memory_slots());
[1313] 0x900000001fc09358:  ff bf 00 38 sd	ra,56(sp)
[1313] 0x900000001fc0935c:  0f f0 17 1b jal		occupied_slots
[1313] 0x900000001fc09360:  00 00 00 21 nada
[1313] 0x900000001fc09364:  ff b1 00 28 sd	s1,40(sp)
[1313] 0x900000001fc09368:  00 40 88 25 move	s1,v0
[1313] 0x900000001fc0936c:  0f f0 17 24 jal		cpu_slots
[1313] 0x900000001fc09370:  00 00 00 21 nada
[1313] 0x900000001fc09374:  ff b6 00 00 sd	s6,0(sp)
[1313] 0x900000001fc09378:  ff b5 00 08 sd	s5,8(sp)
[1313] 0x900000001fc0937c:  ff b3 00 18 sd	s3,24(sp)
[1313] 0x900000001fc09380:  00 40 98 25 move	s3,v0
[1311] 0x900000001fc09384:  ff b0 00 30 sd	s0,48(sp)
[1311] 0x900000001fc09388:  0f f0 17 2e jal		memory_slots
[1311] 0x900000001fc0938c:  00 00 80 25 move	s0,zero
 1314: 
 1315:     for (slot = 0; slot < 16; slot++) {
[1315] 0x900000001fc09390:  24 15 00 08 li	s5,8
[1315] 0x900000001fc09394:  24 16 00 0a li	s6,10
[1315] 0x900000001fc09398:  ff b2 00 20 sd	s2,32(sp)
[1315] 0x900000001fc0939c:  24 12 00 10 li	s2,16
[1315] 0x900000001fc093a0:  02 62 20 27 nor	a0,s3,v0
[1315] 0x900000001fc093a4:  3c 01 90 00 lui	at,0x9000
[1315] 0x900000001fc093a8:  3c 02 1f c2 lui	v0,0x1fc2
[1315] 0x900000001fc093ac:  60 21 00 00 daddi	at,at,0
[1315] 0x900000001fc093b0:  60 43 b0 20 daddi	v1,v0,-20448
[1315] 0x900000001fc093b4:  00 01 10 3c dsll32	v0,at,0
[1315] 0x900000001fc093b8:  24 13 00 01 li	s3,1
[1315] 0x900000001fc093bc:  02 24 88 24 and	s1,s1,a0
[1315] 0x900000001fc093c0:  00 13 08 04 sllv	at,s3,zero
[1315] 0x900000001fc093c4:  ff b4 00 10 sd	s4,16(sp)
[1315] 0x900000001fc093c8:  00 43 a0 2c dadd	s4,v0,v1
[1315] 0x900000001fc093cc:  02 21 c8 24 and	t9,s1,at
 1316: 	if (io & (1 << slot)) {
[1316] 0x900000001fc093d0:  53 20 00 0b beql	t9,zero,0x900000001fc09400
[1316] 0x900000001fc093d4:  26 10 00 01 addiu	s0,s0,1
 1317: 	    read_reg(slot, IO4_CONF_IBUSERRORCLR);
[1317] 0x900000001fc093d8:  02 a0 28 25 move	a1,s5
[1317] 0x900000001fc093dc:  0f f0 24 8f jal		read_reg
[1317] 0x900000001fc093e0:  02 00 20 25 move	a0,s0
 1318: 	    read_reg(slot, IO4_CONF_EBUSERRORCLR);
[1318] 0x900000001fc093e4:  02 c0 28 25 move	a1,s6
[1318] 0x900000001fc093e8:  0f f0 24 8f jal		read_reg
[1318] 0x900000001fc093ec:  02 00 20 25 move	a0,s0
 1319: 	    loprintf("  Cleared IO board %b's error registers\n", slot);
[1319] 0x900000001fc093f0:  02 00 28 25 move	a1,s0
[1319] 0x900000001fc093f4:  0f f0 2c e3 jal		loprintf
[1319] 0x900000001fc093f8:  02 80 20 25 move	a0,s4
[1319] 0x900000001fc093fc:  26 10 00 01 addiu	s0,s0,1
[1315] 0x900000001fc09400:  02 13 c0 04 sllv	t8,s3,s0
[1315] 0x900000001fc09404:  16 12 ff f2 bne	s0,s2,0x900000001fc093d0
[1315] 0x900000001fc09408:  02 38 c8 24 and	t9,s1,t8
[1315] 0x900000001fc0940c:  df b3 00 18 ld	s3,24(sp)
[1315] 0x900000001fc09410:  df b1 00 28 ld	s1,40(sp)
[1315] 0x900000001fc09414:  df b6 00 00 ld	s6,0(sp)
[1315] 0x900000001fc09418:  df bf 00 38 ld	ra,56(sp)
[1315] 0x900000001fc0941c:  df b4 00 10 ld	s4,16(sp)
[1315] 0x900000001fc09420:  df b2 00 20 ld	s2,32(sp)
[1315] 0x900000001fc09424:  df b0 00 30 ld	s0,48(sp)
[1315] 0x900000001fc09428:  df b5 00 08 ld	s5,8(sp)
[1315] 0x900000001fc0942c:  03 e0 00 08 jr	ra
[1315] 0x900000001fc09430:  67 bd 00 40 daddiu	sp,sp,64
 1320: 	}
 1321:     }
 1322: }
 1323: 
 1324: void memory(int rw, int size, __scunsigned_t addr, __uint64_t data, int repeat)
 1325: {
memory:
[1325] 0x900000001fc09434:  67 bd fe c0 daddiu	sp,sp,-320
[1325] 0x900000001fc09438:  ff b1 00 a0 sd	s1,160(sp)
[1325] 0x900000001fc0943c:  00 80 88 25 move	s1,a0
[1325] 0x900000001fc09440:  01 00 78 25 move	t3,a4
[1325] 0x900000001fc09444:  ff b3 00 90 sd	s3,144(sp)
[1325] 0x900000001fc09448:  00 a0 98 25 move	s3,a1
[1325] 0x900000001fc0944c:  ff b2 00 98 sd	s2,152(sp)
[1325] 0x900000001fc09450:  00 c0 90 25 move	s2,a2
[1325] 0x900000001fc09454:  ff b4 00 88 sd	s4,136(sp)
[1325] 0x900000001fc09458:  00 e0 a0 25 move	s4,a3
 1326:     __scunsigned_t old_addr;
 1327:     int c = 0;
[1327] 0x900000001fc0945c:  ff b7 00 70 sd	s7,112(sp)
[1327] 0x900000001fc09460:  00 00 b8 25 move	s7,zero
 1328:     int buf[SHORTBUFF_LENGTH];
 1329:     int verbose = 1;
 1330:     int looping = 0;
[1330] 0x900000001fc09464:  3c 02 90 00 lui	v0,0x9000
[1330] 0x900000001fc09468:  3c 01 90 00 lui	at,0x9000
[1330] 0x900000001fc0946c:  60 47 00 00 daddi	a3,v0,0
[1330] 0x900000001fc09470:  60 26 00 00 daddi	a2,at,0
[1330] 0x900000001fc09474:  3c 02 90 00 lui	v0,0x9000
[1330] 0x900000001fc09478:  3c 01 90 00 lui	at,0x9000
[1330] 0x900000001fc0947c:  60 45 00 00 daddi	a1,v0,0
[1330] 0x900000001fc09480:  60 24 00 00 daddi	a0,at,0
[1330] 0x900000001fc09484:  3c 02 90 00 lui	v0,0x9000
[1330] 0x900000001fc09488:  3c 01 90 00 lui	at,0x9000
[1330] 0x900000001fc0948c:  60 43 00 00 daddi	v1,v0,0
[1330] 0x900000001fc09490:  60 22 00 00 daddi	v0,at,0
[1330] 0x900000001fc09494:  3c 01 90 00 lui	at,0x9000
[1330] 0x900000001fc09498:  3c 08 1f c2 lui	a4,0x1fc2
[1330] 0x900000001fc0949c:  60 21 00 00 daddi	at,at,0
[1330] 0x900000001fc094a0:  61 0e b0 88 daddi	t2,a4,-20344
[1330] 0x900000001fc094a4:  3c 09 1f c2 lui	a5,0x1fc2
[1330] 0x900000001fc094a8:  3c 08 1f c2 lui	a4,0x1fc2
[1330] 0x900000001fc094ac:  61 2d b0 80 daddi	t1,a5,-20352
[1330] 0x900000001fc094b0:  61 0c b0 78 daddi	t0,a4,-20360
[1330] 0x900000001fc094b4:  3c 09 1f c2 lui	a5,0x1fc2
[1330] 0x900000001fc094b8:  ff bf 00 b0 sd	ra,176(sp)
[1330] 0x900000001fc094bc:  3c 08 1f c2 lui	a4,0x1fc2
[1330] 0x900000001fc094c0:  61 2b b0 70 daddi	a7,a5,-20368
[1330] 0x900000001fc094c4:  ff be 00 68 sd	s8,104(sp)
[1330] 0x900000001fc094c8:  61 0a b0 90 daddi	a6,a4,-20336
[1330] 0x900000001fc094cc:  ff b6 00 78 sd	s6,120(sp)
[1330] 0x900000001fc094d0:  3c 09 1f c2 lui	a5,0x1fc2
[1330] 0x900000001fc094d4:  3c 08 1f c2 lui	a4,0x1fc2
[1330] 0x900000001fc094d8:  ff b5 00 80 sd	s5,128(sp)
[1330] 0x900000001fc094dc:  61 29 b0 60 daddi	a5,a5,-20384
[1330] 0x900000001fc094e0:  ff b0 00 a8 sd	s0,168(sp)
[1330] 0x900000001fc094e4:  61 08 b0 50 daddi	a4,a4,-20400
[1330] 0x900000001fc094e8:  ff b1 00 18 sd	s1,24(sp)
[1329] 0x900000001fc094ec:  00 07 38 3c dsll32	a3,a3,0
[1329] 0x900000001fc094f0:  ff af 00 20 sd	t3,32(sp)
[1329] 0x900000001fc094f4:  24 0f 00 01 li	t3,1
[1329] 0x900000001fc094f8:  00 06 30 3c dsll32	a2,a2,0
[1329] 0x900000001fc094fc:  ff af 00 28 sd	t3,40(sp)
[1329] 0x900000001fc09500:  00 ee 38 2c dadd	a3,a3,t2
[1329] 0x900000001fc09504:  00 05 28 3c dsll32	a1,a1,0
[1329] 0x900000001fc09508:  00 cd 30 2c dadd	a2,a2,t1
[1329] 0x900000001fc0950c:  ff a7 00 30 sd	a3,48(sp)
[1329] 0x900000001fc09510:  00 04 20 3c dsll32	a0,a0,0
[1329] 0x900000001fc09514:  00 ac 28 2c dadd	a1,a1,t0
[1329] 0x900000001fc09518:  ff a6 00 38 sd	a2,56(sp)
[1329] 0x900000001fc0951c:  00 03 18 3c dsll32	v1,v1,0
[1329] 0x900000001fc09520:  00 8b 20 2c dadd	a0,a0,a7
[1329] 0x900000001fc09524:  ff a5 00 40 sd	a1,64(sp)
[1329] 0x900000001fc09528:  00 02 10 3c dsll32	v0,v0,0
[1329] 0x900000001fc0952c:  00 6a 18 2c dadd	v1,v1,a6
[1329] 0x900000001fc09530:  ff a4 00 48 sd	a0,72(sp)
[1329] 0x900000001fc09534:  00 01 08 3c dsll32	at,at,0
[1329] 0x900000001fc09538:  00 49 10 2c dadd	v0,v0,a5
[1329] 0x900000001fc0953c:  ff a3 00 50 sd	v1,80(sp)
[1329] 0x900000001fc09540:  24 16 00 01 li	s6,1
[1329] 0x900000001fc09544:  00 28 08 2c dadd	at,at,a4
[1329] 0x900000001fc09548:  ff a2 00 58 sd	v0,88(sp)
[1329] 0x900000001fc0954c:  00 00 f0 25 move	s8,zero
[1329] 0x900000001fc09550:  24 10 00 03 li	s0,3
[1329] 0x900000001fc09554:  ff a1 00 60 sd	at,96(sp)
[1329] 0x900000001fc09558:  02 40 a8 25 move	s5,s2
 1331: 
 1332:     for (;;) {
 1333: 	old_addr = addr;
 1334: 	if (rw == READ) {
[1334] 0x900000001fc0955c:  df b8 00 18 ld	t8,24(sp)
[1333] 0x900000001fc09560:  13 00 00 17 beq	t8,zero,0x900000001fc095c0
[1333] 0x900000001fc09564:  24 10 00 03 li	s0,3
 1335: 	    data = 0;
 1336: 	    switch (size) {
 1337: 	    case BYTE:
 1338: 		data = LBU((char *)addr);
 1339: 		addr ++;
 1340: 		break;
 1341: 	    case HALF:
 1342: 		data = LHU((unsigned short *)addr);
 1343: 		addr += 2;
 1344: 		break;
 1345: 	    case WORD:
 1346: 		data = LW(addr);
 1347: 		addr += 4;
 1348: 		break;
 1349: 	    case DOUBLE:
 1350: 		data = *(__uint64_t *)addr;
 1351: 		addr += 8;
 1352: 		break;
 1353: 	    default:
 1354: 		break;
 1355: 	    }
 1356: 	}
 1357: 	else {
 1358: 	    switch (size) {
[1358] 0x900000001fc09568:  16 60 00 04 bne	s3,zero,0x900000001fc0957c
[1358] 0x900000001fc0956c:  00 00 00 21 nada
 1359: 	    case BYTE:
 1360: 		SB(addr, data);
[1360] 0x900000001fc09570:  a2 54 00 00 sb	s4,0(s2)
 1361: 		addr ++;
[1361] 0x900000001fc09574:  10 00 00 28 b		0x900000001fc09618
[1361] 0x900000001fc09578:  66 52 00 01 daddiu	s2,s2,1
[1361] 0x900000001fc0957c:  56 76 00 05 bnel	s3,s6,0x900000001fc09594
[1361] 0x900000001fc09580:  00 14 f8 00 sll	ra,s4,0
 1362: 		break;
 1363: 	    case HALF:
 1364: 		SH(addr, data);
[1364] 0x900000001fc09584:  a6 54 00 00 sh	s4,0(s2)
 1365: 		addr += 2;
[1365] 0x900000001fc09588:  10 00 00 23 b		0x900000001fc09618
[1365] 0x900000001fc0958c:  66 52 00 02 daddiu	s2,s2,2
[1365] 0x900000001fc09590:  00 14 f8 00 sll	ra,s4,0
[1365] 0x900000001fc09594:  24 19 00 02 li	t9,2
[1365] 0x900000001fc09598:  16 79 00 04 bne	s3,t9,0x900000001fc095ac
[1365] 0x900000001fc0959c:  00 00 00 21 nada
 1366: 		break;
 1367: 	    case WORD:
 1368: 		SW((__uint32_t *)addr, (__uint32_t)data);
 1369: 		addr += 4;
 1370: 		break;
[1370] 0x900000001fc095a0:  ae 5f 00 00 sw	ra,0(s2)
[1369] 0x900000001fc095a4:  10 00 00 1c b		0x900000001fc09618
[1369] 0x900000001fc095a8:  66 52 00 04 daddiu	s2,s2,4
[1369] 0x900000001fc095ac:  16 70 00 1a bne	s3,s0,0x900000001fc09618
[1369] 0x900000001fc095b0:  00 00 00 21 nada
 1371: 	    case DOUBLE:
 1372: 		SD((__uint64_t *)addr, data);
[1372] 0x900000001fc095b4:  fe 54 00 00 sd	s4,0(s2)
 1373: 		addr += 8;
[1373] 0x900000001fc095b8:  10 00 00 17 b		0x900000001fc09618
[1373] 0x900000001fc095bc:  66 52 00 08 daddiu	s2,s2,8
[1335] 0x900000001fc095c0:  16 60 00 05 bne	s3,zero,0x900000001fc095d8
[1335] 0x900000001fc095c4:  00 00 a0 25 move	s4,zero
[1338] 0x900000001fc095c8:  92 41 00 00 lbu	at,0(s2)
[1339] 0x900000001fc095cc:  66 52 00 01 daddiu	s2,s2,1
[1339] 0x900000001fc095d0:  10 00 00 11 b		0x900000001fc09618
[1339] 0x900000001fc095d4:  30 34 00 ff andi	s4,at,0xff
[1339] 0x900000001fc095d8:  56 76 00 06 bnel	s3,s6,0x900000001fc095f4
[1339] 0x900000001fc095dc:  24 03 00 02 li	v1,2
[1342] 0x900000001fc095e0:  96 42 00 00 lhu	v0,0(s2)
[1343] 0x900000001fc095e4:  66 52 00 02 daddiu	s2,s2,2
[1343] 0x900000001fc095e8:  10 00 00 0b b		0x900000001fc09618
[1343] 0x900000001fc095ec:  30 54 ff ff andi	s4,v0,0xffff
[1343] 0x900000001fc095f0:  24 03 00 02 li	v1,2
[1343] 0x900000001fc095f4:  16 63 00 04 bne	s3,v1,0x900000001fc09608
[1343] 0x900000001fc095f8:  00 00 00 21 nada
[1346] 0x900000001fc095fc:  8e 54 00 00 lw	s4,0(s2)
[1347] 0x900000001fc09600:  10 00 00 05 b		0x900000001fc09618
[1347] 0x900000001fc09604:  66 52 00 04 daddiu	s2,s2,4
[1347] 0x900000001fc09608:  16 70 00 03 bne	s3,s0,0x900000001fc09618
[1347] 0x900000001fc0960c:  00 00 00 21 nada
[1350] 0x900000001fc09610:  de 54 00 00 ld	s4,0(s2)
[1351] 0x900000001fc09614:  66 52 00 08 daddiu	s2,s2,8
 1374: 		break;
 1375: 	    default:
 1376: 		break;
 1377: 	    }
 1378: 	}
 1379: 	if (looping) {			/* if != 0 will loop until key is hit */
[1379] 0x900000001fc09618:  17 c0 00 5b bne	s8,zero,0x900000001fc09788
[1379] 0x900000001fc0961c:  00 00 00 21 nada
 1380: 	    int c2;
 1381: 
 1382: 	    if (size == DOUBLE) {
 1383: 		if (verbose)
 1384: 		    loprintf("\n%x: %y ", old_addr, data);
 1385: 	    } else {
 1386: 		if (verbose)
 1387: 		    loprintf("\n%x: %x ", old_addr, data);
 1388: 	    }
 1389: 	    if (pod_poll() != 0) {
 1390: 		c2 = pod_getc();
 1391: 		switch (c2) {
 1392: 		case 'v':
 1393: 		    verbose = 1;
 1394: 		    break;
 1395: 		case 's':
 1396: 		    verbose = 0;
 1397: 		    break;
 1398: 		default:
 1399: 		    /*no looping, verbose on */
 1400: 		    looping = 0;
 1401: 		    verbose = 1;
 1402: 		    break;
 1403: 		}
 1404: 	    }
 1405: 	    if (c == 'l')		/* loop at same address */
 1406: 		addr = old_addr;	/* keep same address */
 1407: 	} else {			/* if (looping) */
 1408: 	    /* Don't print stuff when writing in a loop. */
 1409: #ifdef NOPRINT
 1410: 	    if (!repeat)
[1410] 0x900000001fc09620:  df b7 00 20 ld	s7,32(sp)
[1410] 0x900000001fc09624:  56 e0 00 4d bnel	s7,zero,0x900000001fc0975c
[1410] 0x900000001fc09628:  df b1 00 a0 ld	s1,160(sp)
 1411: #else
 1412: 		if (rw == READ || !repeat)
 1413: #endif /* NOPRINT */
 1414: 		    switch (size) {
[1414] 0x900000001fc0962c:  16 60 00 07 bne	s3,zero,0x900000001fc0964c
[1414] 0x900000001fc09630:  00 00 00 21 nada
 1415: 		    case DOUBLE:
 1416: 			loprintf("%x: %y ", old_addr, data);
 1417: 			break;
 1418: 		    case WORD:
 1419: 			loprintf("%x: %x ", old_addr, data);
 1420: 			break;
 1421: 		    case HALF:
 1422: 			loprintf("%x: %h ", old_addr, data);
 1423: 			break;
 1424: 		    case BYTE:
 1425: 			loprintf("%x: %b ", old_addr, data);
[1425] 0x900000001fc09634:  02 80 30 25 move	a2,s4
[1425] 0x900000001fc09638:  02 a0 28 25 move	a1,s5
[1425] 0x900000001fc0963c:  0f f0 2c e3 jal		loprintf
[1425] 0x900000001fc09640:  df a4 00 30 ld	a0,48(sp)
 1426: 			break;
[1426] 0x900000001fc09644:  10 00 00 19 b		0x900000001fc096ac
[1426] 0x900000001fc09648:  df bf 00 18 ld	ra,24(sp)
[1426] 0x900000001fc0964c:  56 76 00 08 bnel	s3,s6,0x900000001fc09670
[1426] 0x900000001fc09650:  02 80 30 25 move	a2,s4
[1422] 0x900000001fc09654:  02 80 30 25 move	a2,s4
[1422] 0x900000001fc09658:  02 a0 28 25 move	a1,s5
[1422] 0x900000001fc0965c:  0f f0 2c e3 jal		loprintf
[1422] 0x900000001fc09660:  df a4 00 38 ld	a0,56(sp)
[1423] 0x900000001fc09664:  10 00 00 11 b		0x900000001fc096ac
[1423] 0x900000001fc09668:  df bf 00 18 ld	ra,24(sp)
[1423] 0x900000001fc0966c:  02 80 30 25 move	a2,s4
[1423] 0x900000001fc09670:  24 18 00 02 li	t8,2
[1423] 0x900000001fc09674:  16 78 00 06 bne	s3,t8,0x900000001fc09690
[1423] 0x900000001fc09678:  00 00 00 21 nada
[1419] 0x900000001fc0967c:  02 a0 28 25 move	a1,s5
[1419] 0x900000001fc09680:  0f f0 2c e3 jal		loprintf
[1419] 0x900000001fc09684:  df a4 00 40 ld	a0,64(sp)
[1420] 0x900000001fc09688:  10 00 00 08 b		0x900000001fc096ac
[1420] 0x900000001fc0968c:  df bf 00 18 ld	ra,24(sp)
[1420] 0x900000001fc09690:  56 70 00 06 bnel	s3,s0,0x900000001fc096ac
[1420] 0x900000001fc09694:  df bf 00 18 ld	ra,24(sp)
[1416] 0x900000001fc09698:  02 80 30 25 move	a2,s4
[1416] 0x900000001fc0969c:  02 a0 28 25 move	a1,s5
[1416] 0x900000001fc096a0:  0f f0 2c e3 jal		loprintf
[1416] 0x900000001fc096a4:  df a4 00 48 ld	a0,72(sp)
[1417] 0x900000001fc096a8:  df bf 00 18 ld	ra,24(sp)
[1417] 0x900000001fc096ac:  67 b1 00 c0 daddiu	s1,sp,192
[1417] 0x900000001fc096b0:  02 40 28 25 move	a1,s2
 1427: 		    }
 1428: #ifndef NOPRINT
 1429: 	    if (repeat) {
 1430: 		if (rw == READ)
 1431: 		    loprintf("\n");
 1432: 		return;
 1433: 	    }
 1434: #else
 1435: 	    if (repeat)
[1435] 0x900000001fc096b4:  df b9 00 20 ld	t9,32(sp)
[1435] 0x900000001fc096b8:  57 20 00 28 bnel	t9,zero,0x900000001fc0975c
[1435] 0x900000001fc096bc:  df b1 00 a0 ld	s1,160(sp)
 1436: 		return;
 1437: #endif /* NOPRINT */
 1438: 	    if (rw == WRITE) {
[1438] 0x900000001fc096c0:  57 f6 00 04 bnel	ra,s6,0x900000001fc096d4
[1438] 0x900000001fc096c4:  24 05 00 20 li	a1,32
 1439: 		loprintf("\n\r%x: ", addr);
[1439] 0x900000001fc096c8:  0f f0 2c e3 jal		loprintf
[1439] 0x900000001fc096cc:  df a4 00 50 ld	a0,80(sp)
[1439] 0x900000001fc096d0:  24 05 00 20 li	a1,32
 1440: 	    } 
 1441: 
 1442: 	    /* after executing the command, check for input */
 1443: 	    logets(buf, SHORTBUFF_LENGTH);
[1443] 0x900000001fc096d4:  0f f0 2f 1d jal		logets
[1443] 0x900000001fc096d8:  67 a4 00 c0 daddiu	a0,sp,192
 1444: 	    c = *buf;
[1444] 0x900000001fc096dc:  8e 37 00 00 lw	s7,0(s1)
 1445: 	    switch (c) {
[1445] 0x900000001fc096e0:  16 e0 00 05 bne	s7,zero,0x900000001fc096f8
[1445] 0x900000001fc096e4:  02 e0 c8 25 move	t9,s7
[1445] 0x900000001fc096e8:  00 00 f0 25 move	s8,zero
 1446: 	    case 0:			/* return */
 1447: 		c = 0;			/* next addr, if write use old data */
[1447] 0x900000001fc096ec:  00 00 b8 25 move	s7,zero
 1448: 		looping = 0;
[1448] 0x900000001fc096f0:  10 00 ff 9a b		0x900000001fc0955c
[1448] 0x900000001fc096f4:  02 40 a8 25 move	s5,s2
[1448] 0x900000001fc096f8:  24 18 00 2e li	t8,46
[1448] 0x900000001fc096fc:  57 38 00 04 bnel	t9,t8,0x900000001fc09710
[1448] 0x900000001fc09700:  24 1f 00 6c li	ra,108
 1449: 		break;
 1450: 	    case '.':			/* continue infinitely, same pattern */
 1451: 		looping = 1;
[1451] 0x900000001fc09704:  10 00 ff 94 b		0x900000001fc09558
[1451] 0x900000001fc09708:  02 c0 f0 25 move	s8,s6
[1451] 0x900000001fc0970c:  24 1f 00 6c li	ra,108
[1451] 0x900000001fc09710:  57 3f 00 06 bnel	t9,ra,0x900000001fc0972c
[1451] 0x900000001fc09714:  df a1 00 18 ld	at,24(sp)
[1451] 0x900000001fc09718:  02 c0 f0 25 move	s8,s6
 1452: 		break;
 1453: 	    case 'l':			/*loop at same location, same pattern */
 1454: 		addr = old_addr;
[1454] 0x900000001fc0971c:  02 a0 90 25 move	s2,s5
 1455: 		looping = 1;
[1455] 0x900000001fc09720:  10 00 ff 8e b		0x900000001fc0955c
[1455] 0x900000001fc09724:  02 40 a8 25 move	s5,s2
 1456: 		break;
 1457: 	    default:
 1458: 		if (rw == WRITE) {
[1458] 0x900000001fc09728:  df a1 00 18 ld	at,24(sp)
[1458] 0x900000001fc0972c:  54 36 00 0b bnel	at,s6,0x900000001fc0975c
[1458] 0x900000001fc09730:  df b1 00 a0 ld	s1,160(sp)
 1459: 		    if (!lo_ishex(c))
[1459] 0x900000001fc09734:  0f f0 36 d4 jal		lo_ishex
[1459] 0x900000001fc09738:  02 e0 20 25 move	a0,s7
[1459] 0x900000001fc0973c:  50 40 00 07 beql	v0,zero,0x900000001fc0975c
[1459] 0x900000001fc09740:  df b1 00 a0 ld	s1,160(sp)
 1460: 			return;
 1461: 		    data = lo_atoh(buf);
[1461] 0x900000001fc09744:  0f f0 36 85 jal		lo_atoh
[1461] 0x900000001fc09748:  67 a4 00 c0 daddiu	a0,sp,192
 1462: 		    break;
[1462] 0x900000001fc0974c:  00 40 a0 25 move	s4,v0
[1462] 0x900000001fc09750:  10 00 ff 82 b		0x900000001fc0955c
[1462] 0x900000001fc09754:  02 40 a8 25 move	s5,s2
[1462] 0x900000001fc09758:  df b1 00 a0 ld	s1,160(sp)
[1462] 0x900000001fc0975c:  df b3 00 90 ld	s3,144(sp)
[1462] 0x900000001fc09760:  df b5 00 80 ld	s5,128(sp)
[1462] 0x900000001fc09764:  df be 00 68 ld	s8,104(sp)
[1462] 0x900000001fc09768:  df bf 00 b0 ld	ra,176(sp)
[1462] 0x900000001fc0976c:  df b6 00 78 ld	s6,120(sp)
[1462] 0x900000001fc09770:  df b4 00 88 ld	s4,136(sp)
[1462] 0x900000001fc09774:  df b2 00 98 ld	s2,152(sp)
[1462] 0x900000001fc09778:  df b0 00 a8 ld	s0,168(sp)
[1462] 0x900000001fc0977c:  df b7 00 70 ld	s7,112(sp)
[1462] 0x900000001fc09780:  03 e0 00 08 jr	ra
[1462] 0x900000001fc09784:  67 bd 01 40 daddiu	sp,sp,320
[1382] 0x900000001fc09788:  52 70 00 0a beql	s3,s0,0x900000001fc097b4
[1382] 0x900000001fc0978c:  02 a0 28 25 move	a1,s5
[1386] 0x900000001fc09790:  df a5 00 28 ld	a1,40(sp)
[1386] 0x900000001fc09794:  10 a0 00 0c beq	a1,zero,0x900000001fc097c8
[1386] 0x900000001fc09798:  02 80 30 25 move	a2,s4
[1387] 0x900000001fc0979c:  02 a0 28 25 move	a1,s5
[1387] 0x900000001fc097a0:  0f f0 2c e3 jal		loprintf
[1387] 0x900000001fc097a4:  df a4 00 58 ld	a0,88(sp)
[1387] 0x900000001fc097a8:  10 00 00 07 b		0x900000001fc097c8
[1387] 0x900000001fc097ac:  00 00 00 21 nada
[1387] 0x900000001fc097b0:  02 a0 28 25 move	a1,s5
[1383] 0x900000001fc097b4:  df a7 00 28 ld	a3,40(sp)
[1383] 0x900000001fc097b8:  10 e0 00 03 beq	a3,zero,0x900000001fc097c8
[1383] 0x900000001fc097bc:  02 80 30 25 move	a2,s4
[1384] 0x900000001fc097c0:  0f f0 2c e3 jal		loprintf
[1384] 0x900000001fc097c4:  df a4 00 60 ld	a0,96(sp)
[1389] 0x900000001fc097c8:  0f f0 15 23 jal		pod_poll
[1389] 0x900000001fc097cc:  3a f1 00 6c xori	s1,s7,0x6c
[1389] 0x900000001fc097d0:  02 a0 80 25 move	s0,s5
[1389] 0x900000001fc097d4:  10 40 00 11 beq	v0,zero,0x900000001fc0981c
[1389] 0x900000001fc097d8:  00 00 00 21 nada
[1390] 0x900000001fc097dc:  0f f0 15 0b jal		pod_getc
[1390] 0x900000001fc097e0:  00 00 00 21 nada
[1391] 0x900000001fc097e4:  ff b6 00 28 sd	s6,40(sp)
[1391] 0x900000001fc097e8:  30 59 00 ff andi	t9,v0,0xff
[1391] 0x900000001fc097ec:  24 08 00 73 li	a4,115
[1391] 0x900000001fc097f0:  57 28 00 04 bnel	t9,a4,0x900000001fc09804
[1391] 0x900000001fc097f4:  24 09 00 76 li	a5,118
[1396] 0x900000001fc097f8:  10 00 00 08 b		0x900000001fc0981c
[1396] 0x900000001fc097fc:  ff a0 00 28 sd	zero,40(sp)
[1396] 0x900000001fc09800:  24 09 00 76 li	a5,118
[1396] 0x900000001fc09804:  57 29 00 04 bnel	t9,a5,0x900000001fc09818
[1396] 0x900000001fc09808:  00 00 f0 25 move	s8,zero
[1394] 0x900000001fc0980c:  10 00 00 03 b		0x900000001fc0981c
[1394] 0x900000001fc09810:  00 00 00 21 nada
[1400] 0x900000001fc09814:  00 00 f0 25 move	s8,zero
[1401] 0x900000001fc09818:  ff b6 00 28 sd	s6,40(sp)
[1406] 0x900000001fc0981c:  02 51 80 0b movn	s0,s2,s1
[1406] 0x900000001fc09820:  00 00 00 21 nada
[1406] 0x900000001fc09824:  00 00 00 21 nada
[1406] 0x900000001fc09828:  00 00 00 21 nada
[1405] 0x900000001fc0982c:  10 00 ff 4a b		0x900000001fc09558
[1405] 0x900000001fc09830:  02 00 90 25 move	s2,s0
 1463: 		}
 1464: 		else
 1465: 		    return;
 1466: 	    }
 1467: 	}
 1468:     }
 1469: }
 1470: 
 1471: 
 1472: /* Provide system configuration information. */
 1473: void info(void)
 1474: {
info:
[1474] 0x900000001fc09834:  67 bd ff 90 daddiu	sp,sp,-112
 1475:     int cpu, mem, io, present;
 1476:     int slot = 0;	/* Slot 0 doesn't exist on any of our machines */
 1477:     int mask = 1;	/*   so skip over it to avoid confusion */
 1478: 
 1479:     cpu = cpu_slots();
[1479] 0x900000001fc09838:  ff bf 00 18 sd	ra,24(sp)
[1479] 0x900000001fc0983c:  0f f0 17 24 jal		cpu_slots
[1479] 0x900000001fc09840:  00 00 00 21 nada
[1479] 0x900000001fc09844:  ff b4 00 40 sd	s4,64(sp)
[1479] 0x900000001fc09848:  00 40 a0 25 move	s4,v0
 1480:     mem = memory_slots();
[1480] 0x900000001fc0984c:  0f f0 17 2e jal		memory_slots
[1480] 0x900000001fc09850:  00 00 00 21 nada
[1480] 0x900000001fc09854:  ff b6 00 30 sd	s6,48(sp)
[1480] 0x900000001fc09858:  00 40 b0 25 move	s6,v0
 1481:     present = occupied_slots();
[1481] 0x900000001fc0985c:  0f f0 17 1b jal		occupied_slots
[1481] 0x900000001fc09860:  00 00 00 21 nada
 1482: 
 1483:     io = present ^ (cpu | mem);
 1484: 
 1485:    loprintf("System physical configuration:\n");
[1485] 0x900000001fc09864:  ff b0 00 60 sd	s0,96(sp)
[1485] 0x900000001fc09868:  00 40 80 25 move	s0,v0
[1485] 0x900000001fc0986c:  3c 01 90 00 lui	at,0x9000
[1485] 0x900000001fc09870:  60 21 00 00 daddi	at,at,0
[1485] 0x900000001fc09874:  3c 03 90 00 lui	v1,0x9000
[1483] 0x900000001fc09878:  ff b7 00 28 sd	s7,40(sp)
[1483] 0x900000001fc0987c:  60 77 00 00 daddi	s7,v1,0
[1483] 0x900000001fc09880:  02 96 18 25 or	v1,s4,s6
[1483] 0x900000001fc09884:  ff b5 00 38 sd	s5,56(sp)
[1483] 0x900000001fc09888:  00 43 a8 26 xor	s5,v0,v1
[1483] 0x900000001fc0988c:  3c 02 1f c2 lui	v0,0x1fc2
[1483] 0x900000001fc09890:  60 42 b0 98 daddi	v0,v0,-20328
[1483] 0x900000001fc09894:  ff b3 00 48 sd	s3,72(sp)
[1483] 0x900000001fc09898:  3c 13 1f c2 lui	s3,0x1fc2
[1483] 0x900000001fc0989c:  00 01 08 3c dsll32	at,at,0
[1483] 0x900000001fc098a0:  0f f0 2c e3 jal		loprintf
[1483] 0x900000001fc098a4:  00 22 20 2c dadd	a0,at,v0
[1483] 0x900000001fc098a8:  62 73 9b 40 daddi	s3,s3,-25792
[1483] 0x900000001fc098ac:  00 17 08 3c dsll32	at,s7,0
[1476] 0x900000001fc098b0:  ff b1 00 58 sd	s1,88(sp)
[1476] 0x900000001fc098b4:  00 00 88 25 move	s1,zero
[1476] 0x900000001fc098b8:  00 33 08 2c dadd	at,at,s3
[1477] 0x900000001fc098bc:  ff b2 00 50 sd	s2,80(sp)
[1477] 0x900000001fc098c0:  32 19 00 01 andi	t9,s0,0x1
 1486:     
 1487:     for (;present != 0; slot++, mask <<= 1) {
[1487] 0x900000001fc098c4:  ff a1 00 00 sd	at,0(sp)
[1487] 0x900000001fc098c8:  ff be 00 20 sd	s8,32(sp)
[1487] 0x900000001fc098cc:  df be 00 00 ld	s8,0(sp)
[1487] 0x900000001fc098d0:  12 00 00 29 beq	s0,zero,0x900000001fc09978
[1487] 0x900000001fc098d4:  24 12 00 01 li	s2,1
[1487] 0x900000001fc098d8:  67 df 15 98 daddiu	ra,s8,5528
[1487] 0x900000001fc098dc:  67 d8 15 88 daddiu	t8,s8,5512
[1487] 0x900000001fc098e0:  67 d3 15 78 daddiu	s3,s8,5496
[1487] 0x900000001fc098e4:  67 d7 15 b6 daddiu	s7,s8,5558
[1487] 0x900000001fc098e8:  ff bf 00 08 sd	ra,8(sp)
[1487] 0x900000001fc098ec:  67 de 15 a8 daddiu	s8,s8,5544
[1487] 0x900000001fc098f0:  02 39 c8 25 or	t9,s1,t9
[1487] 0x900000001fc098f4:  ff b8 00 10 sd	t8,16(sp)
 1488: 
 1489: 	/* Don't print slot 0 unless it actually has something
 1490: 	   in it.  Current hardware doesn't have a slot 0 */
 1491:         if (slot != 0 || (present & 0x1)) { 
[1491] 0x900000001fc098f8:  13 20 00 1a beq	t9,zero,0x900000001fc09964
[1491] 0x900000001fc098fc:  00 10 80 43 sra	s0,s0,1
 1492: 	   loprintf("  Slot %b:\t", slot);
[1492] 0x900000001fc09900:  02 20 28 25 move	a1,s1
[1492] 0x900000001fc09904:  0f f0 2c e3 jal		loprintf
[1492] 0x900000001fc09908:  02 60 20 25 move	a0,s3
 1493: 	    if (cpu & mask)
[1493] 0x900000001fc0990c:  02 b2 c8 24 and	t9,s5,s2
[1493] 0x900000001fc09910:  02 92 08 24 and	at,s4,s2
[1493] 0x900000001fc09914:  14 20 00 11 bne	at,zero,0x900000001fc0995c
[1493] 0x900000001fc09918:  02 56 58 24 and	a7,s2,s6
 1494: 		   loprintf("CPU board\n");
 1495: 	    else if (io & mask)
[1495] 0x900000001fc0991c:  17 20 00 0b bne	t9,zero,0x900000001fc0994c
[1495] 0x900000001fc09920:  00 00 00 21 nada
 1496: 		   loprintf("I/O board\n");
 1497: 	    else if (mem & mask)
[1497] 0x900000001fc09924:  15 60 00 05 bne	a7,zero,0x900000001fc0993c
[1497] 0x900000001fc09928:  00 00 00 21 nada
 1498: 		   loprintf("Memory board\n");
 1499: 	    else
 1500: 		   loprintf("Empty\n");
[1500] 0x900000001fc0992c:  0f f0 2c e3 jal		loprintf
[1500] 0x900000001fc09930:  02 e0 20 25 move	a0,s7
[1500] 0x900000001fc09934:  10 00 00 0c b		0x900000001fc09968
[1500] 0x900000001fc09938:  00 12 90 40 sll	s2,s2,1
[1498] 0x900000001fc0993c:  0f f0 2c e3 jal		loprintf
[1498] 0x900000001fc09940:  03 c0 20 25 move	a0,s8
[1498] 0x900000001fc09944:  10 00 00 08 b		0x900000001fc09968
[1498] 0x900000001fc09948:  00 12 90 40 sll	s2,s2,1
[1496] 0x900000001fc0994c:  0f f0 2c e3 jal		loprintf
[1496] 0x900000001fc09950:  df a4 00 08 ld	a0,8(sp)
[1496] 0x900000001fc09954:  10 00 00 04 b		0x900000001fc09968
[1496] 0x900000001fc09958:  00 12 90 40 sll	s2,s2,1
[1494] 0x900000001fc0995c:  0f f0 2c e3 jal		loprintf
[1494] 0x900000001fc09960:  df a4 00 10 ld	a0,16(sp)
[1487] 0x900000001fc09964:  00 12 90 40 sll	s2,s2,1
[1487] 0x900000001fc09968:  26 31 00 01 addiu	s1,s1,1
[1487] 0x900000001fc0996c:  32 06 00 01 andi	a2,s0,0x1
 1501: 	 }   
 1502: 	present >>= 1;
[1502] 0x900000001fc09970:  16 00 ff e1 bne	s0,zero,0x900000001fc098f8
[1502] 0x900000001fc09974:  02 26 c8 25 or	t9,s1,a2
[1502] 0x900000001fc09978:  df be 00 20 ld	s8,32(sp)
 1503:     }	
 1504:    loprintf("This processor is slot %b, cpu %b.\n",
[1504] 0x900000001fc0997c:  df a7 00 00 ld	a3,0(sp)
[1504] 0x900000001fc09980:  df b6 00 30 ld	s6,48(sp)
[1504] 0x900000001fc09984:  df b7 00 28 ld	s7,40(sp)
[1504] 0x900000001fc09988:  64 e4 15 c0 daddiu	a0,a3,5568
[1504] 0x900000001fc0998c:  df b5 00 38 ld	s5,56(sp)
[1504] 0x900000001fc09990:  dc e7 07 a0 ld	a3,1952(a3)
[1504] 0x900000001fc09994:  df b3 00 48 ld	s3,72(sp)
[1504] 0x900000001fc09998:  df b4 00 40 ld	s4,64(sp)
[1504] 0x900000001fc0999c:  df b2 00 50 ld	s2,80(sp)
[1504] 0x900000001fc099a0:  dc e8 00 00 ld	a4,0(a3)
[1504] 0x900000001fc099a4:  df b0 00 60 ld	s0,96(sp)
[1504] 0x900000001fc099a8:  df b1 00 58 ld	s1,88(sp)
[1504] 0x900000001fc099ac:  31 08 00 3c andi	a4,a4,0x3c
[1504] 0x900000001fc099b0:  00 08 28 bb dsra	a1,a4,2
[1504] 0x900000001fc099b4:  dc e7 00 00 ld	a3,0(a3)
[1504] 0x900000001fc099b8:  0f f0 2c e3 jal		loprintf
[1504] 0x900000001fc099bc:  30 e6 00 03 andi	a2,a3,0x3
 1505: 		(LD(EV_SPNUM) &  EV_SLOTNUM_MASK) >> EV_SLOTNUM_SHFT,
 1506: 		(LD(EV_SPNUM) &  EV_PROCNUM_MASK) >> EV_PROCNUM_SHFT);
 1507: }
[1507] 0x900000001fc099c0:  df bf 00 18 ld	ra,24(sp)
[1507] 0x900000001fc099c4:  03 e0 00 08 jr	ra
[1507] 0x900000001fc099c8:  67 bd 00 70 daddiu	sp,sp,112
 1508: 
 1509: int
 1510: ip25Registers(int slot, int slice)
 1511: /*
 1512:  * Function: ip25Registers
 1513:  * Purpose: To print all known information about stuff on the bus
 1514:  * Parameters: slot - if !0 slot/slice is cpu slot/slice to get ertoip of.
 1515:  *			dump register values.
 1516:  * Returns: 0 - OK, !0 - failed to access some/all registers.
 1517:  */
 1518: {
ip25Registers:
[1518] 0x900000001fc099cc:  67 bd ff 40 daddiu	sp,sp,-192
[1518] 0x900000001fc099d0:  ff a4 00 08 sd	a0,8(sp)
 1519:     jmp_buf 	fault_buf; /* Status buffer */
 1520:     uint 	*old_buf; /* Previous fault buffer */
 1521:     evreg_t	r;
 1522: 
 1523:     if (setfault(fault_buf, &old_buf)) {
[1523] 0x900000001fc099d4:  ff a5 00 10 sd	a1,16(sp)
[1523] 0x900000001fc099d8:  67 a5 00 00 daddiu	a1,sp,0
[1523] 0x900000001fc099dc:  ff bf 00 48 sd	ra,72(sp)
[1523] 0x900000001fc099e0:  0f f0 18 7f jal		setfault
[1523] 0x900000001fc099e4:  67 a4 00 50 daddiu	a0,sp,80
[1523] 0x900000001fc099e8:  3c 0a 1f c2 lui	a6,0x1fc2
[1523] 0x900000001fc099ec:  3c 06 90 00 lui	a2,0x9000
[1523] 0x900000001fc099f0:  14 40 00 9f bne	v0,zero,0x900000001fc09c70
[1523] 0x900000001fc099f4:  ff b2 00 30 sd	s2,48(sp)
 1524: 	restorefault(old_buf);
 1525: 	return(1);
 1526:     }
 1527:     loprintf("CPU[0x%b/0x%b]\n\t", slot, slice);
[1527] 0x900000001fc099f8:  60 c7 00 00 daddi	a3,a2,0
[1527] 0x900000001fc099fc:  3c 06 1f c2 lui	a2,0x1fc2
[1527] 0x900000001fc09a00:  60 c8 b1 28 daddi	a4,a2,-20184
[1527] 0x900000001fc09a04:  3c 06 90 00 lui	a2,0x9000
[1527] 0x900000001fc09a08:  df b2 00 10 ld	s2,16(sp)
[1527] 0x900000001fc09a0c:  60 c9 00 00 daddi	a5,a2,0
[1527] 0x900000001fc09a10:  02 40 30 25 move	a2,s2
[1527] 0x900000001fc09a14:  ff b1 00 28 sd	s1,40(sp)
[1527] 0x900000001fc09a18:  df b1 00 08 ld	s1,8(sp)
[1527] 0x900000001fc09a1c:  02 20 28 25 move	a1,s1
[1527] 0x900000001fc09a20:  ff b3 00 38 sd	s3,56(sp)
[1527] 0x900000001fc09a24:  61 53 9b 40 daddi	s3,a6,-25792
[1527] 0x900000001fc09a28:  00 07 38 3c dsll32	a3,a3,0
[1527] 0x900000001fc09a2c:  ff b0 00 40 sd	s0,64(sp)
[1527] 0x900000001fc09a30:  00 09 80 3c dsll32	s0,a5,0
[1527] 0x900000001fc09a34:  0f f0 2c e3 jal		loprintf
[1527] 0x900000001fc09a38:  00 e8 20 2c dadd	a0,a3,a4
[1527] 0x900000001fc09a3c:  02 13 80 2c dadd	s0,s0,s3
 1528: 
 1529:     r = EV_GETCONFIG_REG(slot, slice, EV_CFG_ERTOIP);
[1529] 0x900000001fc09a40:  00 12 41 80 sll	a4,s2,6
[1529] 0x900000001fc09a44:  00 11 32 c0 sll	a2,s1,11
[1529] 0x900000001fc09a48:  25 07 00 28 addiu	a3,a4,40
[1529] 0x900000001fc09a4c:  00 07 38 c0 sll	a3,a3,3
[1529] 0x900000001fc09a50:  ff a6 00 18 sd	a2,24(sp)
[1529] 0x900000001fc09a54:  00 c7 30 2d daddu	a2,a2,a3
[1529] 0x900000001fc09a58:  de 07 09 00 ld	a3,2304(s0)
[1529] 0x900000001fc09a5c:  00 c7 30 2d daddu	a2,a2,a3
[1529] 0x900000001fc09a60:  ff a8 00 20 sd	a4,32(sp)
[1529] 0x900000001fc09a64:  dc c6 00 00 ld	a2,0(a2)
 1530:     if (r) {
[1530] 0x900000001fc09a68:  10 c0 00 05 beq	a2,zero,0x900000001fc09a80
[1530] 0x900000001fc09a6c:  00 c0 c8 25 move	t9,a2
 1531: 	xlate_ertoip(r);
[1531] 0x900000001fc09a70:  0f f0 18 dd jal		xlate_ertoip
[1531] 0x900000001fc09a74:  03 20 20 25 move	a0,t9
 1532: 	loprintf("\t");
[1532] 0x900000001fc09a78:  0f f0 2c e3 jal		loprintf
[1532] 0x900000001fc09a7c:  66 04 15 f9 daddiu	a0,s0,5625
 1533:     }
 1534:     r = EV_GETCONFIG_REG(slot, slice, EV_CFG_ERADDR_HI) << 32
[1534] 0x900000001fc09a80:  df b3 00 20 ld	s3,32(sp)
[1534] 0x900000001fc09a84:  26 78 00 2b addiu	t8,s3,43
[1534] 0x900000001fc09a88:  00 18 c0 c0 sll	t8,t8,3
[1534] 0x900000001fc09a8c:  26 79 00 2a addiu	t9,s3,42
[1534] 0x900000001fc09a90:  df b2 00 18 ld	s2,24(sp)
[1534] 0x900000001fc09a94:  00 19 c8 c0 sll	t9,t9,3
[1534] 0x900000001fc09a98:  02 58 c0 2d daddu	t8,s2,t8
[1534] 0x900000001fc09a9c:  de 11 09 00 ld	s1,2304(s0)
[1534] 0x900000001fc09aa0:  02 59 c8 2d daddu	t9,s2,t9
[1534] 0x900000001fc09aa4:  03 11 c0 2d daddu	t8,t8,s1
[1534] 0x900000001fc09aa8:  03 31 c8 2d daddu	t9,t9,s1
[1534] 0x900000001fc09aac:  df 18 00 00 ld	t8,0(t8)
 1535: 	| EV_GETCONFIG_REG(slot, slice, EV_CFG_ERADDR_LO);
 1536:     loprintf("eraddr=0x%x,", r);
[1536] 0x900000001fc09ab0:  66 04 16 00 daddiu	a0,s0,5632
[1536] 0x900000001fc09ab4:  df 39 00 00 ld	t9,0(t9)
[1536] 0x900000001fc09ab8:  00 19 c8 3c dsll32	t9,t9,0
[1536] 0x900000001fc09abc:  0f f0 2c e3 jal		loprintf
[1536] 0x900000001fc09ac0:  03 19 28 25 or	a1,t8,t9
 1537:     r = EV_GETCONFIG_REG(slot, slice, EV_CFG_CACHE_SZ);
[1537] 0x900000001fc09ac4:  26 78 00 3e addiu	t8,s3,62
[1537] 0x900000001fc09ac8:  00 18 c0 c0 sll	t8,t8,3
[1537] 0x900000001fc09acc:  02 58 c0 2d daddu	t8,s2,t8
[1537] 0x900000001fc09ad0:  03 11 c0 2d daddu	t8,t8,s1
 1538:     loprintf("cachesz=%d,", r);
[1538] 0x900000001fc09ad4:  66 04 16 10 daddiu	a0,s0,5648
[1538] 0x900000001fc09ad8:  0f f0 2c e3 jal		loprintf
[1538] 0x900000001fc09adc:  df 05 00 00 ld	a1,0(t8)
 1539:     r = EV_GETCONFIG_REG(slot, slice, EV_CFG_PGBRDEN);
[1539] 0x900000001fc09ae0:  26 78 00 14 addiu	t8,s3,20
[1539] 0x900000001fc09ae4:  00 18 c0 c0 sll	t8,t8,3
[1539] 0x900000001fc09ae8:  02 58 c0 2d daddu	t8,s2,t8
[1539] 0x900000001fc09aec:  03 11 c0 2d daddu	t8,t8,s1
 1540:     loprintf("pgbrden=%d,", r);
[1540] 0x900000001fc09af0:  66 04 16 20 daddiu	a0,s0,5664
[1540] 0x900000001fc09af4:  0f f0 2c e3 jal		loprintf
[1540] 0x900000001fc09af8:  df 05 00 00 ld	a1,0(t8)
 1541:     r = EV_GETCONFIG_REG(slot, slice, EV_CFG_ECCHKDIS);
[1541] 0x900000001fc09afc:  26 78 00 15 addiu	t8,s3,21
[1541] 0x900000001fc09b00:  00 18 c0 c0 sll	t8,t8,3
[1541] 0x900000001fc09b04:  02 58 c0 2d daddu	t8,s2,t8
[1541] 0x900000001fc09b08:  03 11 c0 2d daddu	t8,t8,s1
 1542:     loprintf("\n\tecchkdis=0x%x,", r);
[1542] 0x900000001fc09b0c:  66 04 16 30 daddiu	a0,s0,5680
[1542] 0x900000001fc09b10:  0f f0 2c e3 jal		loprintf
[1542] 0x900000001fc09b14:  df 05 00 00 ld	a1,0(t8)
 1543:     r = EV_GETCONFIG_REG(slot, slice, EV_CFG_IWTRIG);
[1543] 0x900000001fc09b18:  26 78 00 20 addiu	t8,s3,32
[1543] 0x900000001fc09b1c:  00 18 c0 c0 sll	t8,t8,3
[1543] 0x900000001fc09b20:  02 58 c0 2d daddu	t8,s2,t8
[1543] 0x900000001fc09b24:  03 11 c0 2d daddu	t8,t8,s1
 1544:     loprintf("iwtrig=0x%x,", r);
[1544] 0x900000001fc09b28:  66 04 16 48 daddiu	a0,s0,5704
[1544] 0x900000001fc09b2c:  0f f0 2c e3 jal		loprintf
[1544] 0x900000001fc09b30:  df 05 00 00 ld	a1,0(t8)
 1545:     r = EV_GETCONFIG_REG(slot, slice, EV_CFG_ERTAG);
[1545] 0x900000001fc09b34:  26 78 00 2c addiu	t8,s3,44
[1545] 0x900000001fc09b38:  00 18 c0 c0 sll	t8,t8,3
[1545] 0x900000001fc09b3c:  02 58 c0 2d daddu	t8,s2,t8
[1545] 0x900000001fc09b40:  03 11 c0 2d daddu	t8,t8,s1
 1546:     loprintf("ertag=0x%x", r);
[1546] 0x900000001fc09b44:  66 04 16 58 daddiu	a0,s0,5720
[1546] 0x900000001fc09b48:  0f f0 2c e3 jal		loprintf
[1546] 0x900000001fc09b4c:  df 05 00 00 ld	a1,0(t8)
 1547:     r = EV_GETCONFIG_REG(slot, slice, EV_CFG_ERSYSBUS_HI);
[1547] 0x900000001fc09b50:  26 78 00 2d addiu	t8,s3,45
[1547] 0x900000001fc09b54:  00 18 c0 c0 sll	t8,t8,3
[1547] 0x900000001fc09b58:  02 58 c0 2d daddu	t8,s2,t8
[1547] 0x900000001fc09b5c:  03 11 c0 2d daddu	t8,t8,s1
 1548:     loprintf("\n\tersysbushi/lo=0x%x/", r);
[1548] 0x900000001fc09b60:  66 04 16 68 daddiu	a0,s0,5736
[1548] 0x900000001fc09b64:  0f f0 2c e3 jal		loprintf
[1548] 0x900000001fc09b68:  df 05 00 00 ld	a1,0(t8)
 1549:     r = (EV_GETCONFIG_REG(slot, slice, EV_CFG_ERSYSBUS_LO_HI) << 32) | 
[1549] 0x900000001fc09b6c:  26 78 00 2e addiu	t8,s3,46
[1549] 0x900000001fc09b70:  00 18 c0 c0 sll	t8,t8,3
[1549] 0x900000001fc09b74:  26 79 00 2f addiu	t9,s3,47
[1549] 0x900000001fc09b78:  00 19 c8 c0 sll	t9,t9,3
[1549] 0x900000001fc09b7c:  02 58 c0 2d daddu	t8,s2,t8
[1549] 0x900000001fc09b80:  02 59 c8 2d daddu	t9,s2,t9
[1549] 0x900000001fc09b84:  03 11 c0 2d daddu	t8,t8,s1
[1549] 0x900000001fc09b88:  03 31 c8 2d daddu	t9,t9,s1
[1549] 0x900000001fc09b8c:  df 18 00 00 ld	t8,0(t8)
 1550: 	(EV_GETCONFIG_REG(slot, slice, EV_CFG_ERSYSBUS_LO_LO));
 1551:     loprintf("0x%x", r);
[1551] 0x900000001fc09b90:  66 04 16 7e daddiu	a0,s0,5758
[1551] 0x900000001fc09b94:  df 39 00 00 ld	t9,0(t9)
[1551] 0x900000001fc09b98:  00 19 c8 3c dsll32	t9,t9,0
[1551] 0x900000001fc09b9c:  0f f0 2c e3 jal		loprintf
[1551] 0x900000001fc09ba0:  03 19 28 25 or	a1,t8,t9
 1552:     r = (EV_GETCONFIG_REG(slot, slice, EV_CFG_DEBUG0_MSW) << 32) | 
[1552] 0x900000001fc09ba4:  26 78 00 1b addiu	t8,s3,27
[1552] 0x900000001fc09ba8:  00 18 c0 c0 sll	t8,t8,3
[1552] 0x900000001fc09bac:  26 79 00 1a addiu	t9,s3,26
[1552] 0x900000001fc09bb0:  00 19 c8 c0 sll	t9,t9,3
[1552] 0x900000001fc09bb4:  02 58 c0 2d daddu	t8,s2,t8
[1552] 0x900000001fc09bb8:  02 59 c8 2d daddu	t9,s2,t9
[1552] 0x900000001fc09bbc:  03 11 c0 2d daddu	t8,t8,s1
[1552] 0x900000001fc09bc0:  03 31 c8 2d daddu	t9,t9,s1
[1552] 0x900000001fc09bc4:  df 18 00 00 ld	t8,0(t8)
 1553: 	(EV_GETCONFIG_REG(slot, slice, EV_CFG_DEBUG0_LSW));
 1554:     loprintf("\n\tDebug: [0]=0x%x ", r);
[1554] 0x900000001fc09bc8:  66 04 16 88 daddiu	a0,s0,5768
[1554] 0x900000001fc09bcc:  df 39 00 00 ld	t9,0(t9)
[1554] 0x900000001fc09bd0:  00 19 c8 3c dsll32	t9,t9,0
[1554] 0x900000001fc09bd4:  0f f0 2c e3 jal		loprintf
[1554] 0x900000001fc09bd8:  03 19 28 25 or	a1,t8,t9
 1555:     r = (EV_GETCONFIG_REG(slot, slice, EV_CFG_DEBUG1_MSW) << 32) | 
[1555] 0x900000001fc09bdc:  26 78 00 1d addiu	t8,s3,29
[1555] 0x900000001fc09be0:  00 18 c0 c0 sll	t8,t8,3
[1555] 0x900000001fc09be4:  26 79 00 1c addiu	t9,s3,28
[1555] 0x900000001fc09be8:  00 19 c8 c0 sll	t9,t9,3
[1555] 0x900000001fc09bec:  02 58 c0 2d daddu	t8,s2,t8
[1555] 0x900000001fc09bf0:  02 59 c8 2d daddu	t9,s2,t9
[1555] 0x900000001fc09bf4:  03 11 c0 2d daddu	t8,t8,s1
[1555] 0x900000001fc09bf8:  03 31 c8 2d daddu	t9,t9,s1
[1555] 0x900000001fc09bfc:  df 18 00 00 ld	t8,0(t8)
 1556: 	(EV_GETCONFIG_REG(slot, slice, EV_CFG_DEBUG1_LSW));
 1557:     loprintf("[1]=0x%x ", r);
[1557] 0x900000001fc09c00:  66 04 16 a0 daddiu	a0,s0,5792
[1557] 0x900000001fc09c04:  df 39 00 00 ld	t9,0(t9)
[1557] 0x900000001fc09c08:  00 19 c8 3c dsll32	t9,t9,0
[1557] 0x900000001fc09c0c:  0f f0 2c e3 jal		loprintf
[1557] 0x900000001fc09c10:  03 19 28 25 or	a1,t8,t9
 1558:     r = (EV_GETCONFIG_REG(slot, slice, EV_CFG_DEBUG2_MSW) << 32) | 
[1558] 0x900000001fc09c14:  26 78 00 1f addiu	t8,s3,31
[1558] 0x900000001fc09c18:  26 79 00 1e addiu	t9,s3,30
[1558] 0x900000001fc09c1c:  df b3 00 38 ld	s3,56(sp)
[1558] 0x900000001fc09c20:  00 18 c0 c0 sll	t8,t8,3
[1558] 0x900000001fc09c24:  00 19 c8 c0 sll	t9,t9,3
[1558] 0x900000001fc09c28:  02 58 c0 2d daddu	t8,s2,t8
[1558] 0x900000001fc09c2c:  02 59 c8 2d daddu	t9,s2,t9
[1558] 0x900000001fc09c30:  df b2 00 30 ld	s2,48(sp)
[1558] 0x900000001fc09c34:  03 11 c0 2d daddu	t8,t8,s1
[1558] 0x900000001fc09c38:  03 31 c8 2d daddu	t9,t9,s1
[1558] 0x900000001fc09c3c:  df b1 00 28 ld	s1,40(sp)
[1558] 0x900000001fc09c40:  df 18 00 00 ld	t8,0(t8)
 1559: 	(EV_GETCONFIG_REG(slot, slice, EV_CFG_DEBUG2_LSW));
 1560:     loprintf("[2]=0x%x\n", r);
[1560] 0x900000001fc09c44:  66 04 16 b0 daddiu	a0,s0,5808
[1560] 0x900000001fc09c48:  df b0 00 40 ld	s0,64(sp)
[1560] 0x900000001fc09c4c:  df 39 00 00 ld	t9,0(t9)
[1560] 0x900000001fc09c50:  00 19 c8 3c dsll32	t9,t9,0
[1560] 0x900000001fc09c54:  0f f0 2c e3 jal		loprintf
[1560] 0x900000001fc09c58:  03 19 28 25 or	a1,t8,t9
 1561:     restorefault(old_buf);
[1561] 0x900000001fc09c5c:  0f f0 18 86 jal		restorefault
[1561] 0x900000001fc09c60:  df a4 00 00 ld	a0,0(sp)
 1562:     return(0);
[1562] 0x900000001fc09c64:  00 00 10 25 move	v0,zero
[1562] 0x900000001fc09c68:  10 00 00 06 b		0x900000001fc09c84
[1562] 0x900000001fc09c6c:  df bf 00 48 ld	ra,72(sp)
[1524] 0x900000001fc09c70:  ff b1 00 28 sd	s1,40(sp)
[1524] 0x900000001fc09c74:  0f f0 18 86 jal		restorefault
[1524] 0x900000001fc09c78:  df a4 00 00 ld	a0,0(sp)
[1525] 0x900000001fc09c7c:  df bf 00 48 ld	ra,72(sp)
[1525] 0x900000001fc09c80:  24 02 00 01 li	v0,1
[1525] 0x900000001fc09c84:  03 e0 00 08 jr	ra
[1525] 0x900000001fc09c88:  67 bd 00 c0 daddiu	sp,sp,192
 1563: }
 1564: 
 1565: void
 1566: dumpSlice(int slot, int slice)
 1567: /*
 1568:  * Function: dumpSlice
 1569:  * Purpose: 	To dump the SCC registers assocated with a slice.
 1570:  * Parameters:	slot/slice to query
 1571:  * Returns:
 1572:  */
 1573: {
dumpSlice:
[1573] 0x900000001fc09c8c:  67 bd ff e0 daddiu	sp,sp,-32
[1573] 0x900000001fc09c90:  00 80 c8 25 move	t9,a0
[1573] 0x900000001fc09c94:  00 a0 30 25 move	a2,a1
 1574:     evreg_t	r;
 1575: 
 1576:     if ((slot < 1) || (slot > 15) || (slice < 0) || (slice > 3)) {
[1576] 0x900000001fc09c98:  3c 01 90 00 lui	at,0x9000
[1576] 0x900000001fc09c9c:  3c 02 1f c2 lui	v0,0x1fc2
[1576] 0x900000001fc09ca0:  60 21 00 00 daddi	at,at,0
[1576] 0x900000001fc09ca4:  60 42 9b 40 daddi	v0,v0,-25792
[1576] 0x900000001fc09ca8:  2b 29 00 10 slti	a5,t9,16
[1576] 0x900000001fc09cac:  28 ca 00 04 slti	a6,a2,4
[1576] 0x900000001fc09cb0:  00 01 08 3c dsll32	at,at,0
[1576] 0x900000001fc09cb4:  ff bf 00 18 sd	ra,24(sp)
[1576] 0x900000001fc09cb8:  1b 20 00 34 blez	t9,0x900000001fc09d8c
[1576] 0x900000001fc09cbc:  00 22 58 2c dadd	a7,at,v0
[1576] 0x900000001fc09cc0:  51 20 00 33 beql	a5,zero,0x900000001fc09d90
[1576] 0x900000001fc09cc4:  03 20 28 25 move	a1,t9
[1576] 0x900000001fc09cc8:  04 c2 00 31 bltzl	a2,0x900000001fc09d90
[1576] 0x900000001fc09ccc:  03 20 28 25 move	a1,t9
[1576] 0x900000001fc09cd0:  51 40 00 2f beql	a6,zero,0x900000001fc09d90
[1576] 0x900000001fc09cd4:  03 20 28 25 move	a1,t9
 1577: 	loprintf("*** invalid slot/slice: 0x%a/0x%a\n", slot, slice);
 1578: 	return;
 1579:     }
 1580: 
 1581:     /* Check if achip enabled */
 1582: 
 1583:     if (!(cpu_slots() & (1 << slot))) {
[1583] 0x900000001fc09cd8:  ff a6 00 00 sd	a2,0(sp)
[1583] 0x900000001fc09cdc:  ff b9 00 08 sd	t9,8(sp)
[1583] 0x900000001fc09ce0:  0f f0 17 24 jal		cpu_slots
[1583] 0x900000001fc09ce4:  ff ab 00 10 sd	a7,16(sp)
[1583] 0x900000001fc09ce8:  df ab 00 10 ld	a7,16(sp)
[1583] 0x900000001fc09cec:  24 0a 00 01 li	a6,1
[1583] 0x900000001fc09cf0:  df b9 00 08 ld	t9,8(sp)
[1583] 0x900000001fc09cf4:  03 2a 18 04 sllv	v1,a6,t9
[1583] 0x900000001fc09cf8:  00 43 18 24 and	v1,v0,v1
[1583] 0x900000001fc09cfc:  10 60 00 1f beq	v1,zero,0x900000001fc09d7c
[1583] 0x900000001fc09d00:  03 20 28 25 move	a1,t9
 1584: 	loprintf("*** slot 0x%a is not a CPU board\n", slot);
 1585: 	return;
 1586:     }
 1587: 
 1588:     r = EV_GETCONFIG_REG(slot, 0, EV_A_ENABLE);
[1588] 0x900000001fc09d04:  dd 67 09 00 ld	a3,2304(a7)
[1588] 0x900000001fc09d08:  df a6 00 00 ld	a2,0(sp)
[1588] 0x900000001fc09d0c:  00 19 22 c0 sll	a0,t9,11
[1588] 0x900000001fc09d10:  00 87 20 2d daddu	a0,a0,a3
 1589: 
 1590:     if (!(r & (1 << slice))) {
[1590] 0x900000001fc09d14:  00 ca 28 04 sllv	a1,a6,a2
[1590] 0x900000001fc09d18:  dc 84 00 00 ld	a0,0(a0)
[1590] 0x900000001fc09d1c:  00 85 20 24 and	a0,a0,a1
[1590] 0x900000001fc09d20:  50 80 00 12 beql	a0,zero,0x900000001fc09d6c
[1590] 0x900000001fc09d24:  03 20 28 25 move	a1,t9
 1591: 	loprintf("*** cpu 0x%a/0x%a is not enabled in A-chip\n", 
 1592: 		 slot, slice);
 1593: 	return;
 1594:     }
 1595: 
 1596:     if (ip25Registers(slot, slice)) {
[1596] 0x900000001fc09d28:  ff a6 00 00 sd	a2,0(sp)
[1596] 0x900000001fc09d2c:  ff b9 00 08 sd	t9,8(sp)
[1596] 0x900000001fc09d30:  00 c0 28 25 move	a1,a2
[1596] 0x900000001fc09d34:  ff ab 00 10 sd	a7,16(sp)
[1596] 0x900000001fc09d38:  0f f0 26 73 jal		ip25Registers
[1596] 0x900000001fc09d3c:  03 20 20 25 move	a0,t9
[1596] 0x900000001fc09d40:  df a6 00 00 ld	a2,0(sp)
[1596] 0x900000001fc09d44:  df b9 00 08 ld	t9,8(sp)
[1596] 0x900000001fc09d48:  df ab 00 10 ld	a7,16(sp)
[1596] 0x900000001fc09d4c:  50 40 00 13 beql	v0,zero,0x900000001fc09d9c
[1596] 0x900000001fc09d50:  df bf 00 18 ld	ra,24(sp)
 1597: 	loprintf("\n\n*** cpu 0x%a/0x%a: EXCEPTION reading registers\n",
[1597] 0x900000001fc09d54:  03 20 28 25 move	a1,t9
[1597] 0x900000001fc09d58:  0f f0 2c e3 jal		loprintf
[1597] 0x900000001fc09d5c:  65 64 17 40 daddiu	a0,a7,5952
 1598: 		 slot, slice);
 1599: 	return;
[1599] 0x900000001fc09d60:  10 00 00 0e b		0x900000001fc09d9c
[1599] 0x900000001fc09d64:  df bf 00 18 ld	ra,24(sp)
[1591] 0x900000001fc09d68:  03 20 28 25 move	a1,t9
[1591] 0x900000001fc09d6c:  0f f0 2c e3 jal		loprintf
[1591] 0x900000001fc09d70:  65 64 17 10 daddiu	a0,a7,5904
[1593] 0x900000001fc09d74:  10 00 00 09 b		0x900000001fc09d9c
[1593] 0x900000001fc09d78:  df bf 00 18 ld	ra,24(sp)
[1584] 0x900000001fc09d7c:  0f f0 2c e3 jal		loprintf
[1584] 0x900000001fc09d80:  65 64 16 e8 daddiu	a0,a7,5864
[1585] 0x900000001fc09d84:  10 00 00 05 b		0x900000001fc09d9c
[1585] 0x900000001fc09d88:  df bf 00 18 ld	ra,24(sp)
[1577] 0x900000001fc09d8c:  03 20 28 25 move	a1,t9
[1577] 0x900000001fc09d90:  0f f0 2c e3 jal		loprintf
[1577] 0x900000001fc09d94:  65 64 16 c0 daddiu	a0,a7,5824
[1578] 0x900000001fc09d98:  df bf 00 18 ld	ra,24(sp)
[1578] 0x900000001fc09d9c:  03 e0 00 08 jr	ra
[1578] 0x900000001fc09da0:  67 bd 00 20 daddiu	sp,sp,32
 1600:     }
 1601: }
 1602: void
 1603: dumpSlot(int slot)
 1604: /*
 1605:  * Function: dumpSlot
 1606:  * Purpose: 	To dump the SCC registers assocated with a slot.
 1607:  * Parameters:	slot/slice to query
 1608:  * Returns:
 1609:  */
 1610: {
dumpSlot:
[1610] 0x900000001fc09da4:  67 bd ff 30 daddiu	sp,sp,-208
[1610] 0x900000001fc09da8:  ff b4 00 28 sd	s4,40(sp)
[1610] 0x900000001fc09dac:  00 80 a0 25 move	s4,a0
 1611:     static char *margin[] = {"0%", "+5%", "-5%", "***"};
 1612:     evreg_t	r, rt;
 1613:     int		slice, rtValid;
 1614: 
 1615:     if ((slot < 1) || (slot > 15)) {
[1615] 0x900000001fc09db0:  ff b3 00 30 sd	s3,48(sp)
[1615] 0x900000001fc09db4:  24 13 00 04 li	s3,4
[1615] 0x900000001fc09db8:  3c 01 90 00 lui	at,0x9000
[1615] 0x900000001fc09dbc:  60 21 00 00 daddi	at,at,0
[1615] 0x900000001fc09dc0:  3c 02 1f c2 lui	v0,0x1fc2
[1615] 0x900000001fc09dc4:  60 42 9b 40 daddi	v0,v0,-25792
[1615] 0x900000001fc09dc8:  ff b0 00 48 sd	s0,72(sp)
[1615] 0x900000001fc09dcc:  2a 90 00 10 slti	s0,s4,16
[1615] 0x900000001fc09dd0:  00 01 08 3c dsll32	at,at,0
[1615] 0x900000001fc09dd4:  ff b5 00 20 sd	s5,32(sp)
[1615] 0x900000001fc09dd8:  ff bf 00 50 sd	ra,80(sp)
[1615] 0x900000001fc09ddc:  1a 80 00 72 blez	s4,0x900000001fc09fa8
[1615] 0x900000001fc09de0:  00 22 a8 2c dadd	s5,at,v0
[1615] 0x900000001fc09de4:  ff b2 00 38 sd	s2,56(sp)
[1615] 0x900000001fc09de8:  52 00 00 70 beql	s0,zero,0x900000001fc09fac
[1615] 0x900000001fc09dec:  02 80 28 25 move	a1,s4
 1616: 	loprintf("*** invalid slot: 0x%a\n", slot);
 1617: 	return;
 1618:     }
 1619: 
 1620:     /* Check if achip enabled */
 1621: 
 1622:     if (!(cpu_slots() & (1 << slot))) {
[1622] 0x900000001fc09df0:  0f f0 17 24 jal		cpu_slots
[1622] 0x900000001fc09df4:  24 12 00 01 li	s2,1
[1622] 0x900000001fc09df8:  02 92 18 04 sllv	v1,s2,s4
[1622] 0x900000001fc09dfc:  00 43 18 24 and	v1,v0,v1
[1622] 0x900000001fc09e00:  50 60 00 63 beql	v1,zero,0x900000001fc09f90
[1622] 0x900000001fc09e04:  df b2 00 38 ld	s2,56(sp)
 1623: 	loprintf("*** slot 0x%a is not a CPU board\n", slot);
 1624: 	return;
 1625:     }
 1626: 
 1627:     r = EV_GETCONFIG_REG(slot, 0, EV_A_ENABLE);
[1627] 0x900000001fc09e08:  de a6 09 00 ld	a2,2304(s5)
 1628: 
 1629:     loprintf("Slot 0x%a A-chip: enable=0x%b, type=0x%b, lvl=0x%d, err=0x%x\n",
[1629] 0x900000001fc09e0c:  00 14 82 c0 sll	s0,s4,11
[1629] 0x900000001fc09e10:  02 06 38 2d daddu	a3,s0,a2
[1629] 0x900000001fc09e14:  de a6 12 d0 ld	a2,4816(s5)
[1629] 0x900000001fc09e18:  de a8 12 e0 ld	a4,4832(s5)
[1629] 0x900000001fc09e1c:  02 06 30 2d daddu	a2,s0,a2
[1629] 0x900000001fc09e20:  ff a7 00 08 sd	a3,8(sp)
[1629] 0x900000001fc09e24:  02 08 40 2d daddu	a4,s0,a4
[1629] 0x900000001fc09e28:  de a9 09 08 ld	a5,2312(s5)
[1629] 0x900000001fc09e2c:  ff b1 00 40 sd	s1,64(sp)
[1629] 0x900000001fc09e30:  dc f1 00 00 ld	s1,0(a3)
[1629] 0x900000001fc09e34:  02 09 48 2d daddu	a5,s0,a5
[1629] 0x900000001fc09e38:  02 80 28 25 move	a1,s4
[1629] 0x900000001fc09e3c:  dc c7 00 00 ld	a3,0(a2)
[1629] 0x900000001fc09e40:  66 a4 17 b8 daddiu	a0,s5,6072
[1629] 0x900000001fc09e44:  dd 08 00 00 ld	a4,0(a4)
[1629] 0x900000001fc09e48:  02 20 30 25 move	a2,s1
[1629] 0x900000001fc09e4c:  dd 29 00 00 ld	a5,0(a5)
[1629] 0x900000001fc09e50:  0f f0 2c e3 jal		loprintf
[1629] 0x900000001fc09e54:  00 00 00 21 nada
 1630: 	     slot, r, 
 1631: 	     EV_GETCONFIG_REG(slot, 0, EV_A_BOARD_TYPE),
 1632: 	     EV_GETCONFIG_REG(slot, 0, EV_A_LEVEL),
 1633: 	     EV_GETCONFIG_REG(slot, 0, EV_A_ERROR));
 1634:     if (r & 1) {			/* Slice 0 - voltage margin */
[1634] 0x900000001fc09e58:  df b9 00 08 ld	t9,8(sp)
[1634] 0x900000001fc09e5c:  32 24 00 01 andi	a0,s1,0x1
[1634] 0x900000001fc09e60:  54 80 00 19 bnel	a0,zero,0x900000001fc09ec8
[1634] 0x900000001fc09e64:  de a5 18 60 ld	a1,6240(s5)
 1635: 	rt = EV_GETCONFIG_REG(slot, 0, EV_ECCHKDIS);
 1636: 	rtValid = 1;
 1637:     } else {
 1638: 	/* Try to enable it but don't complain if doe snot appear there. */
 1639: 	jmp_buf	fault_buf;
 1640: 	uint	*old_buf;
 1641: 	EV_SETCONFIG_REG(slot, 0, EV_A_ENABLE, r | 1);
 1642: 	if (!setfault(fault_buf, &old_buf)) {
[1642] 0x900000001fc09e68:  67 a4 00 60 daddiu	a0,sp,96
[1642] 0x900000001fc09e6c:  36 38 00 01 ori	t8,s1,0x1
[1642] 0x900000001fc09e70:  67 a5 00 00 daddiu	a1,sp,0
[1642] 0x900000001fc09e74:  0f f0 18 7f jal		setfault
[1642] 0x900000001fc09e78:  ff 38 00 00 sd	t8,0(t9)
[1642] 0x900000001fc09e7c:  00 00 c8 25 move	t9,zero
[1642] 0x900000001fc09e80:  50 40 00 04 beql	v0,zero,0x900000001fc09e94
[1642] 0x900000001fc09e84:  de bf 18 60 ld	ra,6240(s5)
 1643: 	    rt = EV_GETCONFIG_REG(slot, 0, EV_ECCHKDIS);
 1644: 	    rtValid = 1;
 1645: 	} else {
 1646: 	    rtValid = 0;
[1646] 0x900000001fc09e88:  10 00 00 05 b		0x900000001fc09ea0
[1646] 0x900000001fc09e8c:  00 00 00 21 nada
[1643] 0x900000001fc09e90:  de bf 18 60 ld	ra,6240(s5)
[1643] 0x900000001fc09e94:  02 1f f8 2d daddu	ra,s0,ra
[1644] 0x900000001fc09e98:  02 40 c8 25 move	t9,s2
[1644] 0x900000001fc09e9c:  df eb 00 00 ld	a7,0(ra)
 1647: 	}
 1648: 	restorefault(old_buf);
[1648] 0x900000001fc09ea0:  ff ab 00 10 sd	a7,16(sp)
[1648] 0x900000001fc09ea4:  df a4 00 00 ld	a0,0(sp)
[1648] 0x900000001fc09ea8:  0f f0 18 86 jal		restorefault
[1648] 0x900000001fc09eac:  ff b9 00 18 sd	t9,24(sp)
 1649: 	EV_SETCONFIG_REG(slot, 0, EV_A_ENABLE, r);
[1649] 0x900000001fc09eb0:  df a1 00 08 ld	at,8(sp)
[1649] 0x900000001fc09eb4:  fc 31 00 00 sd	s1,0(at)
[1649] 0x900000001fc09eb8:  df ab 00 10 ld	a7,16(sp)
[1649] 0x900000001fc09ebc:  10 00 00 05 b		0x900000001fc09ed4
[1649] 0x900000001fc09ec0:  df b9 00 18 ld	t9,24(sp)
[1635] 0x900000001fc09ec4:  de a5 18 60 ld	a1,6240(s5)
[1635] 0x900000001fc09ec8:  02 05 28 2d daddu	a1,s0,a1
[1636] 0x900000001fc09ecc:  02 40 c8 25 move	t9,s2
[1636] 0x900000001fc09ed0:  dc ab 00 00 ld	a7,0(a1)
[1636] 0x900000001fc09ed4:  de af 06 e8 ld	t3,1768(s5)
 1650:     }
 1651: 
 1652:     if (rtValid) {
[1652] 0x900000001fc09ed8:  53 20 00 14 beql	t9,zero,0x900000001fc09f2c
[1652] 0x900000001fc09edc:  00 12 c0 04 sllv	t8,s2,zero
 1653: 	loprintf("        Voltage: 1.5 (%s) 3.3 (%s) 5.0 (%s)\n", 
[1653] 0x900000001fc09ee0:  31 6e 30 00 andi	t2,a7,0x3000
[1653] 0x900000001fc09ee4:  31 6d 03 00 andi	t1,a7,0x300
[1653] 0x900000001fc09ee8:  00 0e 73 3a dsrl	t2,t2,12
[1653] 0x900000001fc09eec:  31 6c 0c 00 andi	t0,a7,0xc00
[1653] 0x900000001fc09ef0:  00 0d 6a 3a dsrl	t1,t1,8
[1653] 0x900000001fc09ef4:  00 0c 62 ba dsrl	t0,t0,10
[1653] 0x900000001fc09ef8:  00 0e 70 f8 dsll	t2,t2,3
[1653] 0x900000001fc09efc:  00 0d 68 f8 dsll	t1,t1,3
[1653] 0x900000001fc09f00:  65 ef 03 f0 daddiu	t3,t3,1008
[1653] 0x900000001fc09f04:  00 0c 60 f8 dsll	t0,t0,3
[1653] 0x900000001fc09f08:  01 cf 70 2d daddu	t2,t2,t3
[1653] 0x900000001fc09f0c:  01 af 68 2d daddu	t1,t1,t3
[1653] 0x900000001fc09f10:  01 8f 60 2d daddu	t0,t0,t3
[1653] 0x900000001fc09f14:  66 a4 17 f8 daddiu	a0,s5,6136
[1653] 0x900000001fc09f18:  dd c5 00 00 ld	a1,0(t2)
[1653] 0x900000001fc09f1c:  dd a6 00 00 ld	a2,0(t1)
[1653] 0x900000001fc09f20:  0f f0 2c e3 jal		loprintf
[1653] 0x900000001fc09f24:  dd 87 00 00 ld	a3,0(t0)
[1653] 0x900000001fc09f28:  00 12 c0 04 sllv	t8,s2,zero
 1654: 		 margin[(rt & EV_ECCHKDIS_15_MASK) >> EV_ECCHKDIS_15_SHFT],
 1655: 		 margin[(rt & EV_ECCHKDIS_33_MASK) >> EV_ECCHKDIS_33_SHFT],
 1656: 		 margin[(rt & EV_ECCHKDIS_50_MASK) >> EV_ECCHKDIS_50_SHFT]);
 1657:     }
 1658: 
 1659:     for (slice = 0; slice < EV_MAX_CPUS_BOARD; slice++) {
[1659] 0x900000001fc09f2c:  00 00 80 25 move	s0,zero
[1659] 0x900000001fc09f30:  02 38 c8 24 and	t9,s1,t8
 1660: 	if ((r & (1 << slice))) {
[1660] 0x900000001fc09f34:  53 20 00 07 beql	t9,zero,0x900000001fc09f54
[1660] 0x900000001fc09f38:  26 10 00 01 addiu	s0,s0,1
 1661: 	    if (ip25Registers(slot, slice)) {
[1661] 0x900000001fc09f3c:  02 00 28 25 move	a1,s0
[1661] 0x900000001fc09f40:  0f f0 26 73 jal		ip25Registers
[1661] 0x900000001fc09f44:  02 80 20 25 move	a0,s4
[1661] 0x900000001fc09f48:  54 40 00 09 bnel	v0,zero,0x900000001fc09f70
[1661] 0x900000001fc09f4c:  df b1 00 40 ld	s1,64(sp)
[1659] 0x900000001fc09f50:  26 10 00 01 addiu	s0,s0,1
[1659] 0x900000001fc09f54:  02 12 c8 04 sllv	t9,s2,s0
[1659] 0x900000001fc09f58:  16 13 ff f6 bne	s0,s3,0x900000001fc09f34
[1659] 0x900000001fc09f5c:  02 39 c8 24 and	t9,s1,t9
[1659] 0x900000001fc09f60:  df b2 00 38 ld	s2,56(sp)
[1659] 0x900000001fc09f64:  10 00 00 13 b		0x900000001fc09fb4
[1659] 0x900000001fc09f68:  df b1 00 40 ld	s1,64(sp)
[1659] 0x900000001fc09f6c:  df b1 00 40 ld	s1,64(sp)
[1659] 0x900000001fc09f70:  df b2 00 38 ld	s2,56(sp)
 1662: 		loprintf("\n\n*** cpu 0x%a/0x%a: EXCEPTION reading registers\n",
[1662] 0x900000001fc09f74:  02 00 30 25 move	a2,s0
[1662] 0x900000001fc09f78:  02 80 28 25 move	a1,s4
[1662] 0x900000001fc09f7c:  0f f0 2c e3 jal		loprintf
[1662] 0x900000001fc09f80:  66 a4 18 28 daddiu	a0,s5,6184
 1663: 			 slot, slice);
 1664: 		return;
[1664] 0x900000001fc09f84:  10 00 00 0c b		0x900000001fc09fb8
[1664] 0x900000001fc09f88:  df b0 00 48 ld	s0,72(sp)
[1664] 0x900000001fc09f8c:  df b2 00 38 ld	s2,56(sp)
[1623] 0x900000001fc09f90:  02 80 28 25 move	a1,s4
[1623] 0x900000001fc09f94:  ff b1 00 40 sd	s1,64(sp)
[1623] 0x900000001fc09f98:  0f f0 2c e3 jal		loprintf
[1623] 0x900000001fc09f9c:  66 a4 17 90 daddiu	a0,s5,6032
[1624] 0x900000001fc09fa0:  10 00 00 05 b		0x900000001fc09fb8
[1624] 0x900000001fc09fa4:  df b0 00 48 ld	s0,72(sp)
[1616] 0x900000001fc09fa8:  02 80 28 25 move	a1,s4
[1616] 0x900000001fc09fac:  0f f0 2c e3 jal		loprintf
[1616] 0x900000001fc09fb0:  66 a4 17 78 daddiu	a0,s5,6008
[1617] 0x900000001fc09fb4:  df b0 00 48 ld	s0,72(sp)
[1617] 0x900000001fc09fb8:  df b5 00 20 ld	s5,32(sp)
[1617] 0x900000001fc09fbc:  df bf 00 50 ld	ra,80(sp)
[1617] 0x900000001fc09fc0:  df b3 00 30 ld	s3,48(sp)
[1617] 0x900000001fc09fc4:  df b4 00 28 ld	s4,40(sp)
[1617] 0x900000001fc09fc8:  03 e0 00 08 jr	ra
[1617] 0x900000001fc09fcc:  67 bd 00 d0 daddiu	sp,sp,208
 1665: 	    }
 1666: 	}
 1667:     }
 1668: }
 1669: void
 1670: dumpAll(void)
 1671: /*
 1672:  * Function: dumpAll
 1673:  * Purpose: 	To dump the SCC registers assocated with a slot.
 1674:  * Parameters:	slot/slice to query
 1675:  * Returns:
 1676:  */
 1677: {
dumpAll:
[1677] 0x900000001fc09fd0:  67 bd ff d0 daddiu	sp,sp,-48
 1678:     int	 slot;
 1679:     int	cpu = cpu_slots();
[1679] 0x900000001fc09fd4:  ff bf 00 20 sd	ra,32(sp)
[1679] 0x900000001fc09fd8:  0f f0 17 24 jal		cpu_slots
[1679] 0x900000001fc09fdc:  00 00 00 21 nada
 1680: 
 1681:     for (slot = 1; slot <=15; slot++) {
[1681] 0x900000001fc09fe0:  ff b3 00 00 sd	s3,0(sp)
[1681] 0x900000001fc09fe4:  24 13 00 01 li	s3,1
[1681] 0x900000001fc09fe8:  ff b0 00 18 sd	s0,24(sp)
[1681] 0x900000001fc09fec:  24 10 00 01 li	s0,1
[1681] 0x900000001fc09ff0:  ff b1 00 10 sd	s1,16(sp)
[1681] 0x900000001fc09ff4:  00 40 88 25 move	s1,v0
[1681] 0x900000001fc09ff8:  02 13 08 04 sllv	at,s3,s0
[1681] 0x900000001fc09ffc:  ff b2 00 08 sd	s2,8(sp)
[1681] 0x900000001fc0a000:  24 12 00 0f li	s2,15
[1681] 0x900000001fc0a004:  02 21 c8 24 and	t9,s1,at
 1682: 	if (cpu & (1 << slot)) {
[1682] 0x900000001fc0a008:  53 20 00 04 beql	t9,zero,0x900000001fc0a01c
[1682] 0x900000001fc0a00c:  26 10 00 01 addiu	s0,s0,1
 1683: 	    dumpSlot(slot);
[1683] 0x900000001fc0a010:  0f f0 27 69 jal		dumpSlot
[1683] 0x900000001fc0a014:  02 00 20 25 move	a0,s0
[1683] 0x900000001fc0a018:  26 10 00 01 addiu	s0,s0,1
[1681] 0x900000001fc0a01c:  02 13 30 04 sllv	a2,s3,s0
[1681] 0x900000001fc0a020:  02 50 28 2a slt	a1,s2,s0
[1681] 0x900000001fc0a024:  10 a0 ff f8 beq	a1,zero,0x900000001fc0a008
[1681] 0x900000001fc0a028:  02 26 c8 24 and	t9,s1,a2
[1681] 0x900000001fc0a02c:  df b3 00 00 ld	s3,0(sp)
[1681] 0x900000001fc0a030:  df bf 00 20 ld	ra,32(sp)
[1681] 0x900000001fc0a034:  df b1 00 10 ld	s1,16(sp)
[1681] 0x900000001fc0a038:  df b2 00 08 ld	s2,8(sp)
[1681] 0x900000001fc0a03c:  df b0 00 18 ld	s0,24(sp)
[1681] 0x900000001fc0a040:  03 e0 00 08 jr	ra
[1681] 0x900000001fc0a044:  67 bd 00 30 daddiu	sp,sp,48
 1684: 	}
 1685:     }
 1686: }
 1687: 
 1688: void 
 1689: margin(__uint64_t slot, int *v, int *d)
 1690: {
margin:
[1690] 0x900000001fc0a048:  67 bd ff 30 daddiu	sp,sp,-208
[1690] 0x900000001fc0a04c:  ff b2 00 38 sd	s2,56(sp)
[1690] 0x900000001fc0a050:  00 80 90 25 move	s2,a0
[1690] 0x900000001fc0a054:  ff b4 00 28 sd	s4,40(sp)
[1690] 0x900000001fc0a058:  00 a0 a0 25 move	s4,a1
[1690] 0x900000001fc0a05c:  ff b0 00 48 sd	s0,72(sp)
[1690] 0x900000001fc0a060:  00 c0 80 25 move	s0,a2
 1691:     int		dir;
 1692:     evreg_t	cr, r;			/* current value */
 1693:     jmp_buf	fault_buf;
 1694:     int		*old_buf;
 1695: 
 1696:     if (!lo_strcmp(d, "0")) {
[1696] 0x900000001fc0a064:  00 c0 20 25 move	a0,a2
[1696] 0x900000001fc0a068:  3c 01 90 00 lui	at,0x9000
[1696] 0x900000001fc0a06c:  ff b7 00 10 sd	s7,16(sp)
[1696] 0x900000001fc0a070:  00 00 b8 25 move	s7,zero
[1696] 0x900000001fc0a074:  60 21 00 00 daddi	at,at,0
[1696] 0x900000001fc0a078:  3c 02 1f c2 lui	v0,0x1fc2
[1696] 0x900000001fc0a07c:  3c 03 90 00 lui	v1,0x9000
[1696] 0x900000001fc0a080:  60 42 b3 a8 daddi	v0,v0,-19544
[1696] 0x900000001fc0a084:  ff b1 00 40 sd	s1,64(sp)
[1696] 0x900000001fc0a088:  60 71 00 00 daddi	s1,v1,0
[1696] 0x900000001fc0a08c:  00 01 08 3c dsll32	at,at,0
[1696] 0x900000001fc0a090:  ff bf 00 50 sd	ra,80(sp)
[1696] 0x900000001fc0a094:  0f f0 35 f5 jal		lo_strcmp
[1696] 0x900000001fc0a098:  00 22 28 2c dadd	a1,at,v0
[1696] 0x900000001fc0a09c:  ff b3 00 30 sd	s3,48(sp)
[1696] 0x900000001fc0a0a0:  3c 13 1f c2 lui	s3,0x1fc2
[1696] 0x900000001fc0a0a4:  00 11 08 3c dsll32	at,s1,0
[1696] 0x900000001fc0a0a8:  24 03 00 01 li	v1,1
[1696] 0x900000001fc0a0ac:  00 12 20 00 sll	a0,s2,0
[1696] 0x900000001fc0a0b0:  62 73 9b 40 daddi	s3,s3,-25792
[1696] 0x900000001fc0a0b4:  00 83 88 04 sllv	s1,v1,a0
[1696] 0x900000001fc0a0b8:  ff b5 00 20 sd	s5,32(sp)
[1696] 0x900000001fc0a0bc:  ff b6 00 18 sd	s6,24(sp)
[1696] 0x900000001fc0a0c0:  10 40 00 19 beq	v0,zero,0x900000001fc0a128
[1696] 0x900000001fc0a0c4:  00 33 98 2c dadd	s3,at,s3
 1697: 	dir = EV_MGN_NOM;
 1698:     } else if (!lo_strcmp(d, "+")) {
[1698] 0x900000001fc0a0c8:  66 65 18 6a daddiu	a1,s3,6250
[1698] 0x900000001fc0a0cc:  02 00 20 25 move	a0,s0
[1698] 0x900000001fc0a0d0:  0f f0 35 f5 jal		lo_strcmp
[1698] 0x900000001fc0a0d4:  24 17 00 01 li	s7,1
[1698] 0x900000001fc0a0d8:  66 65 18 6c daddiu	a1,s3,6252
[1698] 0x900000001fc0a0dc:  00 12 a8 00 sll	s5,s2,0
[1698] 0x900000001fc0a0e0:  02 b7 88 04 sllv	s1,s7,s5
[1698] 0x900000001fc0a0e4:  10 40 00 10 beq	v0,zero,0x900000001fc0a128
[1698] 0x900000001fc0a0e8:  02 00 20 25 move	a0,s0
 1699: 	dir = EV_MGN_HI;
 1700:     } else if (!lo_strcmp(d, "-")) {
[1700] 0x900000001fc0a0ec:  0f f0 35 f5 jal		lo_strcmp
[1700] 0x900000001fc0a0f0:  24 17 00 02 li	s7,2
[1700] 0x900000001fc0a0f4:  24 16 00 01 li	s6,1
[1700] 0x900000001fc0a0f8:  00 12 c0 00 sll	t8,s2,0
[1700] 0x900000001fc0a0fc:  02 00 28 25 move	a1,s0
[1700] 0x900000001fc0a100:  03 16 88 04 sllv	s1,s6,t8
[1700] 0x900000001fc0a104:  10 40 00 08 beq	v0,zero,0x900000001fc0a128
[1700] 0x900000001fc0a108:  df b0 00 48 ld	s0,72(sp)
[1700] 0x900000001fc0a10c:  df b2 00 38 ld	s2,56(sp)
 1701: 	dir = EV_MGN_LO;
 1702:     } else {
 1703: 	loprintf("Invalid margin direction '%p': must be +/-/0\n", d);
[1703] 0x900000001fc0a110:  df b7 00 10 ld	s7,16(sp)
[1703] 0x900000001fc0a114:  df b4 00 28 ld	s4,40(sp)
[1703] 0x900000001fc0a118:  0f f0 2c e3 jal		loprintf
[1703] 0x900000001fc0a11c:  66 64 18 70 daddiu	a0,s3,6256
 1704: 	return;
[1704] 0x900000001fc0a120:  10 00 00 58 b		0x900000001fc0a284
[1704] 0x900000001fc0a124:  df bf 00 50 ld	ra,80(sp)
[1697] 0x900000001fc0a128:  ff be 00 08 sd	s8,8(sp)
 1705:     }
 1706: 
 1707:     /* Verify CPU board, and be sure A-chip has slice 0 enabled */
 1708: 
 1709: 
 1710:     if (!(cpu_slots() & (1 << slot))) {
[1710] 0x900000001fc0a12c:  0f f0 17 24 jal		cpu_slots
[1710] 0x900000001fc0a130:  00 00 00 21 nada
[1710] 0x900000001fc0a134:  00 51 c8 24 and	t9,v0,s1
[1710] 0x900000001fc0a138:  53 20 00 4b beql	t9,zero,0x900000001fc0a268
[1710] 0x900000001fc0a13c:  02 40 28 25 move	a1,s2
 1711: 	loprintf("*** slot 0x%a is not a CPU board\n", slot);
 1712: 	return;
 1713:     }
 1714: 
 1715:     r = EV_GETCONFIG_REG(slot, 0, EV_A_ENABLE);
[1715] 0x900000001fc0a140:  00 12 82 f8 dsll	s0,s2,11
[1715] 0x900000001fc0a144:  de 7e 09 00 ld	s8,2304(s3)
[1715] 0x900000001fc0a148:  02 1e a8 2d daddu	s5,s0,s8
[1715] 0x900000001fc0a14c:  de b6 00 00 ld	s6,0(s5)
 1716: 
 1717:     if (!(r & 1)) {
[1717] 0x900000001fc0a150:  32 de 00 01 andi	s8,s6,0x1
[1717] 0x900000001fc0a154:  00 1e f0 00 sll	s8,s8,0
[1717] 0x900000001fc0a158:  67 a5 00 00 daddiu	a1,sp,0
[1717] 0x900000001fc0a15c:  17 c0 00 02 bne	s8,zero,0x900000001fc0a168
[1717] 0x900000001fc0a160:  36 df 00 01 ori	ra,s6,0x1
 1718: 	/* Try to enable SCC for marginning */
 1719: 	EV_SETCONFIG_REG(slot, 0, EV_A_ENABLE, r | 1);
[1719] 0x900000001fc0a164:  fe bf 00 00 sd	ra,0(s5)
 1720:     }
 1721: 
 1722:     if (!setfault(fault_buf, &old_buf)) {
[1722] 0x900000001fc0a168:  0f f0 18 7f jal		setfault
[1722] 0x900000001fc0a16c:  67 a4 00 60 daddiu	a0,sp,96
[1722] 0x900000001fc0a170:  02 40 28 25 move	a1,s2
[1722] 0x900000001fc0a174:  50 40 00 06 beql	v0,zero,0x900000001fc0a190
[1722] 0x900000001fc0a178:  de 66 18 60 ld	a2,6240(s3)
 1723: 	cr = EV_GETCONFIG_REG(slot, 0, EV_ECCHKDIS);
 1724: 	if (!lo_strcmp(v, "1.5")) {
 1725: 	    cr = (cr & ~EV_ECCHKDIS_15_MASK) | dir << EV_ECCHKDIS_15_SHFT;
 1726: 	} else if (!lo_strcmp(v, "3.3")) {
 1727: 	    cr = (cr & ~EV_ECCHKDIS_33_MASK) | dir << EV_ECCHKDIS_33_SHFT;
 1728: 	} else if (!lo_strcmp(v, "5.0")) {
 1729: 	    cr = (cr & ~EV_ECCHKDIS_50_MASK) | dir << EV_ECCHKDIS_50_SHFT;
 1730: 	} else {
 1731: 	    loprintf("Invalid power brick '%p': must be 1.5, 3.3, or 5.0\n", 
 1732: 		     v);
 1733: 	}	
 1734: 
 1735: 	EV_SETCONFIG_REG(slot, 0, EV_ECCHKDIS, cr);
 1736:     } else {
 1737: 	loprintf("Unable to access power margin for slot %a\n", slot);
[1737] 0x900000001fc0a17c:  0f f0 2c e3 jal		loprintf
[1737] 0x900000001fc0a180:  66 64 19 08 daddiu	a0,s3,6408
[1737] 0x900000001fc0a184:  10 00 00 2c b		0x900000001fc0a238
[1737] 0x900000001fc0a188:  00 00 00 21 nada
[1723] 0x900000001fc0a18c:  de 66 18 60 ld	a2,6240(s3)
[1724] 0x900000001fc0a190:  66 65 18 c2 daddiu	a1,s3,6338
[1724] 0x900000001fc0a194:  02 06 90 2d daddu	s2,s0,a2
[1724] 0x900000001fc0a198:  02 80 20 25 move	a0,s4
[1724] 0x900000001fc0a19c:  0f f0 35 f5 jal		lo_strcmp
[1724] 0x900000001fc0a1a0:  de 51 00 00 ld	s1,0(s2)
[1724] 0x900000001fc0a1a4:  24 1f cf ff li	ra,-12289
[1724] 0x900000001fc0a1a8:  66 65 18 c6 daddiu	a1,s3,6342
[1724] 0x900000001fc0a1ac:  50 40 00 1f beql	v0,zero,0x900000001fc0a22c
[1724] 0x900000001fc0a1b0:  00 17 cb 00 sll	t9,s7,12
[1726] 0x900000001fc0a1b4:  0f f0 35 f5 jal		lo_strcmp
[1726] 0x900000001fc0a1b8:  02 80 20 25 move	a0,s4
[1726] 0x900000001fc0a1bc:  24 18 fc ff li	t8,-769
[1726] 0x900000001fc0a1c0:  66 65 18 ca daddiu	a1,s3,6346
[1726] 0x900000001fc0a1c4:  50 40 00 13 beql	v0,zero,0x900000001fc0a214
[1726] 0x900000001fc0a1c8:  00 17 ba 00 sll	s7,s7,8
[1728] 0x900000001fc0a1cc:  0f f0 35 f5 jal		lo_strcmp
[1728] 0x900000001fc0a1d0:  02 80 20 25 move	a0,s4
[1728] 0x900000001fc0a1d4:  02 80 28 25 move	a1,s4
[1728] 0x900000001fc0a1d8:  24 14 f3 ff li	s4,-3073
[1728] 0x900000001fc0a1dc:  50 40 00 07 beql	v0,zero,0x900000001fc0a1fc
[1728] 0x900000001fc0a1e0:  00 17 9a 80 sll	s3,s7,10
[1731] 0x900000001fc0a1e4:  0f f0 2c e3 jal		loprintf
[1731] 0x900000001fc0a1e8:  66 64 18 d0 daddiu	a0,s3,6352
[1731] 0x900000001fc0a1ec:  fe 51 00 00 sd	s1,0(s2)
[1731] 0x900000001fc0a1f0:  10 00 00 11 b		0x900000001fc0a238
[1731] 0x900000001fc0a1f4:  00 00 00 21 nada
[1729] 0x900000001fc0a1f8:  00 17 9a 80 sll	s3,s7,10
[1729] 0x900000001fc0a1fc:  02 34 a0 24 and	s4,s1,s4
[1729] 0x900000001fc0a200:  02 74 98 25 or	s3,s3,s4
[1729] 0x900000001fc0a204:  fe 53 00 00 sd	s3,0(s2)
[1729] 0x900000001fc0a208:  10 00 00 0b b		0x900000001fc0a238
[1729] 0x900000001fc0a20c:  00 00 00 21 nada
[1727] 0x900000001fc0a210:  00 17 ba 00 sll	s7,s7,8
[1727] 0x900000001fc0a214:  02 38 c0 24 and	t8,s1,t8
[1727] 0x900000001fc0a218:  02 f8 b8 25 or	s7,s7,t8
[1727] 0x900000001fc0a21c:  fe 57 00 00 sd	s7,0(s2)
[1727] 0x900000001fc0a220:  10 00 00 05 b		0x900000001fc0a238
[1727] 0x900000001fc0a224:  00 00 00 21 nada
[1725] 0x900000001fc0a228:  00 17 cb 00 sll	t9,s7,12
[1725] 0x900000001fc0a22c:  02 3f f8 24 and	ra,s1,ra
[1725] 0x900000001fc0a230:  03 3f c8 25 or	t9,t9,ra
[1725] 0x900000001fc0a234:  fe 59 00 00 sd	t9,0(s2)
 1738:     }
 1739: 
 1740:     if (!(r & 1)) {
[1740] 0x900000001fc0a238:  57 c0 00 03 bnel	s8,zero,0x900000001fc0a248
[1740] 0x900000001fc0a23c:  df be 00 08 ld	s8,8(sp)
 1741: 	/* disable it now */
 1742: 	EV_SETCONFIG_REG(slot, 0, EV_A_ENABLE, r);
[1742] 0x900000001fc0a240:  fe b6 00 00 sd	s6,0(s5)
[1742] 0x900000001fc0a244:  df be 00 08 ld	s8,8(sp)
 1743:     }
 1744:     restorefault(old_buf);
[1744] 0x900000001fc0a248:  0f f0 18 86 jal		restorefault
[1744] 0x900000001fc0a24c:  df a4 00 00 ld	a0,0(sp)
 1745: }
[1745] 0x900000001fc0a250:  df b2 00 38 ld	s2,56(sp)
[1745] 0x900000001fc0a254:  df b0 00 48 ld	s0,72(sp)
[1745] 0x900000001fc0a258:  df b4 00 28 ld	s4,40(sp)
[1745] 0x900000001fc0a25c:  10 00 00 08 b		0x900000001fc0a280
[1745] 0x900000001fc0a260:  df b7 00 10 ld	s7,16(sp)
[1711] 0x900000001fc0a264:  02 40 28 25 move	a1,s2
[1711] 0x900000001fc0a268:  df b2 00 38 ld	s2,56(sp)
[1711] 0x900000001fc0a26c:  df b7 00 10 ld	s7,16(sp)
[1711] 0x900000001fc0a270:  df b4 00 28 ld	s4,40(sp)
[1711] 0x900000001fc0a274:  df b0 00 48 ld	s0,72(sp)
[1711] 0x900000001fc0a278:  0f f0 2c e3 jal		loprintf
[1711] 0x900000001fc0a27c:  66 64 18 a0 daddiu	a0,s3,6304
[1712] 0x900000001fc0a280:  df bf 00 50 ld	ra,80(sp)
[1712] 0x900000001fc0a284:  df b5 00 20 ld	s5,32(sp)
[1712] 0x900000001fc0a288:  df b3 00 30 ld	s3,48(sp)
[1712] 0x900000001fc0a28c:  df b1 00 40 ld	s1,64(sp)
[1712] 0x900000001fc0a290:  df b6 00 18 ld	s6,24(sp)
[1712] 0x900000001fc0a294:  03 e0 00 08 jr	ra
[1712] 0x900000001fc0a298:  67 bd 00 d0 daddiu	sp,sp,208
 1746: 
 1747: /*
 1748:  * POD memory test
 1749:  */
 1750: 
 1751: #define	BIT_TRUE	0
 1752: #define BIT_INVERT	1
 1753: 
 1754: /* struct addr to pass to generic memory test routines */
 1755: struct addr_range {
 1756: 	uint	*lomem;	/* starting location */
 1757: 	uint	*himem;	/* end location */
 1758: 	int	dmask;	/* data bit fields to be masked off when reading back */
 1759: 	int	inc;	/* word or half or byte */
 1760: 	int	pattern;/* 0 means no special pattern to be written */
 1761: 	int	invert;
 1762: };
 1763: 
 1764: static int read_wr(volatile struct addr_range *);
 1765: static int bwalking_addr(volatile struct addr_range *);
 1766: static int addr_pattern(volatile struct addr_range *);
 1767: 
 1768: 
 1769: /*
 1770:  * called by POD command mode.
 1771:  */
 1772: int mem_test(__psunsigned_t lo, __psunsigned_t hi)
 1773: {
mem_test:
[1773] 0x900000001fc0a29c:  67 bd ff b0 daddiu	sp,sp,-80
 1774:     volatile struct addr_range addr;
 1775:     volatile int fail;
 1776: 
 1777:     if (!IS_KSEG1(lo))
[1777] 0x900000001fc0a2a0:  3c 01 90 00 lui	at,0x9000
[1777] 0x900000001fc0a2a4:  60 21 00 00 daddi	at,at,0
[1777] 0x900000001fc0a2a8:  3c 02 1f c2 lui	v0,0x1fc2
[1777] 0x900000001fc0a2ac:  60 42 9b 40 daddi	v0,v0,-25792
[1777] 0x900000001fc0a2b0:  00 01 08 3c dsll32	at,at,0
[1777] 0x900000001fc0a2b4:  ff b0 00 38 sd	s0,56(sp)
[1777] 0x900000001fc0a2b8:  00 22 80 2c dadd	s0,at,v0
[1777] 0x900000001fc0a2bc:  ff b2 00 28 sd	s2,40(sp)
[1777] 0x900000001fc0a2c0:  24 12 00 01 li	s2,1
[1777] 0x900000001fc0a2c4:  de 19 1a 28 ld	t9,6696(s0)
[1777] 0x900000001fc0a2c8:  ff b1 00 30 sd	s1,48(sp)
[1777] 0x900000001fc0a2cc:  00 b9 58 2b sltu	a7,a1,t9
[1777] 0x900000001fc0a2d0:  00 99 08 2b sltu	at,a0,t9
[1777] 0x900000001fc0a2d4:  54 20 00 08 bnel	at,zero,0x900000001fc0a2f8
[1777] 0x900000001fc0a2d8:  00 99 30 25 or	a2,a0,t9
[1777] 0x900000001fc0a2dc:  de 03 1a 30 ld	v1,6704(s0)
[1777] 0x900000001fc0a2e0:  00 83 18 2b sltu	v1,a0,v1
[1777] 0x900000001fc0a2e4:  50 60 00 04 beql	v1,zero,0x900000001fc0a2f8
[1777] 0x900000001fc0a2e8:  00 99 30 25 or	a2,a0,t9
 1778: 	addr.lomem = (uint *)PHYS_TO_K1(lo);
 1779:     else
 1780: 	addr.lomem = (uint *)lo;
[1780] 0x900000001fc0a2ec:  10 00 00 03 b		0x900000001fc0a2fc
[1780] 0x900000001fc0a2f0:  ff a4 00 00 sd	a0,0(sp)
[1778] 0x900000001fc0a2f4:  00 99 30 25 or	a2,a0,t9
[1778] 0x900000001fc0a2f8:  ff a6 00 00 sd	a2,0(sp)
 1781:     if (!IS_KSEG1(hi))
[1781] 0x900000001fc0a2fc:  ff bf 00 40 sd	ra,64(sp)
[1781] 0x900000001fc0a300:  15 60 00 0a bne	a7,zero,0x900000001fc0a32c
[1781] 0x900000001fc0a304:  67 b1 00 00 daddiu	s1,sp,0
[1781] 0x900000001fc0a308:  de 07 1a 30 ld	a3,6704(s0)
[1781] 0x900000001fc0a30c:  00 a7 38 2b sltu	a3,a1,a3
[1781] 0x900000001fc0a310:  50 e0 00 07 beql	a3,zero,0x900000001fc0a330
[1781] 0x900000001fc0a314:  00 b9 48 25 or	a5,a1,t9
 1782: 	addr.himem = (uint *)PHYS_TO_K1(hi);
 1783:     else
 1784: 	addr.himem = (uint *)hi;
[1784] 0x900000001fc0a318:  ff a5 00 08 sd	a1,8(sp)
[1784] 0x900000001fc0a31c:  de 08 1a 38 ld	a4,6712(s0)
[1784] 0x900000001fc0a320:  00 88 40 24 and	a4,a0,a4
[1784] 0x900000001fc0a324:  10 00 00 06 b		0x900000001fc0a340
[1784] 0x900000001fc0a328:  2d 0b 40 00 sltiu	a7,a4,16384
[1782] 0x900000001fc0a32c:  00 b9 48 25 or	a5,a1,t9
[1782] 0x900000001fc0a330:  ff a9 00 08 sd	a5,8(sp)
[1782] 0x900000001fc0a334:  de 09 1a 38 ld	a5,6712(s0)
[1782] 0x900000001fc0a338:  00 89 48 24 and	a5,a0,a5
[1782] 0x900000001fc0a33c:  2d 2b 40 00 sltiu	a7,a5,16384
 1785: 
 1786:     if (K1_TO_PHYS(lo) < LOMEM_STRUCT_END)
[1786] 0x900000001fc0a340:  11 60 00 03 beq	a7,zero,0x900000001fc0a350
[1786] 0x900000001fc0a344:  00 00 00 21 nada
 1787: 	loprintf("*** This test will overwrite PROM data structures.  Type reset to recover.\n");
[1787] 0x900000001fc0a348:  0f f0 2c e3 jal		loprintf
[1787] 0x900000001fc0a34c:  66 04 19 38 daddiu	a0,s0,6456
 1788: 
 1789:     addr.inc = 1;			/* word test */
[1789] 0x900000001fc0a350:  af b2 00 14 sw	s2,20(sp)
 1790:     addr.invert = BIT_TRUE;
 1791:     addr.dmask = 0xffffffff;		/* check them all */
 1792: 
 1793:     /* walking addr */
 1794:     loprintf("Walking address...\t");
[1794] 0x900000001fc0a354:  66 04 19 88 daddiu	a0,s0,6536
[1791] 0x900000001fc0a358:  af a0 00 1c sw	zero,28(sp)
[1791] 0x900000001fc0a35c:  24 0a ff ff li	a6,-1
[1791] 0x900000001fc0a360:  0f f0 2c e3 jal		loprintf
[1791] 0x900000001fc0a364:  af aa 00 10 sw	a6,16(sp)
 1795:     fail = bwalking_addr(&addr);
[1795] 0x900000001fc0a368:  0f f0 29 10 jal		bwalking_addr
[1795] 0x900000001fc0a36c:  02 20 20 25 move	a0,s1
[1795] 0x900000001fc0a370:  af a2 00 20 sw	v0,32(sp)
 1796:     if (fail) {
[1796] 0x900000001fc0a374:  8f aa 00 20 lw	a6,32(sp)
[1796] 0x900000001fc0a378:  15 40 00 05 bne	a6,zero,0x900000001fc0a390
[1796] 0x900000001fc0a37c:  00 00 00 21 nada
 1797: 	loprintf("Failed!\n");
 1798: 	pon_memerror();
 1799:     } else
 1800: 	loprintf("Passed!\n");
[1800] 0x900000001fc0a380:  0f f0 2c e3 jal		loprintf
[1800] 0x900000001fc0a384:  66 04 19 b0 daddiu	a0,s0,6576
[1800] 0x900000001fc0a388:  10 00 00 05 b		0x900000001fc0a3a0
[1800] 0x900000001fc0a38c:  00 00 00 21 nada
[1797] 0x900000001fc0a390:  0f f0 2c e3 jal		loprintf
[1797] 0x900000001fc0a394:  66 04 19 a0 daddiu	a0,s0,6560
[1798] 0x900000001fc0a398:  0f f0 2b 09 jal		pon_memerror
[1798] 0x900000001fc0a39c:  00 00 00 21 nada
 1801:     loprintf("Read/Write Test");
[1801] 0x900000001fc0a3a0:  0f f0 2c e3 jal		loprintf
[1801] 0x900000001fc0a3a4:  66 04 19 c0 daddiu	a0,s0,6592
 1802:     if (read_wr(&addr)) {
[1802] 0x900000001fc0a3a8:  0f f0 2a ab jal		read_wr
[1802] 0x900000001fc0a3ac:  02 20 20 25 move	a0,s1
[1802] 0x900000001fc0a3b0:  14 40 00 05 bne	v0,zero,0x900000001fc0a3c8
[1802] 0x900000001fc0a3b4:  00 00 00 21 nada
 1803: 	fail = 1;
 1804: 	loprintf("\tFailed!\n");
 1805: 	pon_memerror();
 1806:     } else
 1807: 	loprintf("\tPassed!\n");
[1807] 0x900000001fc0a3b8:  0f f0 2c e3 jal		loprintf
[1807] 0x900000001fc0a3bc:  66 04 19 e0 daddiu	a0,s0,6624
[1807] 0x900000001fc0a3c0:  10 00 00 06 b		0x900000001fc0a3dc
[1807] 0x900000001fc0a3c4:  00 00 00 21 nada
[1803] 0x900000001fc0a3c8:  af b2 00 20 sw	s2,32(sp)
[1803] 0x900000001fc0a3cc:  0f f0 2c e3 jal		loprintf
[1803] 0x900000001fc0a3d0:  66 04 19 d0 daddiu	a0,s0,6608
[1805] 0x900000001fc0a3d4:  0f f0 2b 09 jal		pon_memerror
[1805] 0x900000001fc0a3d8:  00 00 00 21 nada
 1808:     loprintf("Addr Pattern Test");
[1808] 0x900000001fc0a3dc:  0f f0 2c e3 jal		loprintf
[1808] 0x900000001fc0a3e0:  66 04 19 f0 daddiu	a0,s0,6640
 1809:     if (addr_pattern(&addr)) {
[1809] 0x900000001fc0a3e4:  0f f0 29 b1 jal		addr_pattern
[1809] 0x900000001fc0a3e8:  02 20 20 25 move	a0,s1
[1809] 0x900000001fc0a3ec:  df b1 00 30 ld	s1,48(sp)
[1809] 0x900000001fc0a3f0:  14 40 00 08 bne	v0,zero,0x900000001fc0a414
[1809] 0x900000001fc0a3f4:  00 00 00 21 nada
[1809] 0x900000001fc0a3f8:  df b2 00 28 ld	s2,40(sp)
 1810: 	fail = 1;
 1811: 	loprintf("..\tFailed!\n");
 1812: 	pon_memerror();
 1813:     } else
 1814: 	loprintf("..\tPassed!\n");
[1814] 0x900000001fc0a3fc:  0f f0 2c e3 jal		loprintf
[1814] 0x900000001fc0a400:  66 04 1a 18 daddiu	a0,s0,6680
[1814] 0x900000001fc0a404:  df bf 00 40 ld	ra,64(sp)
[1814] 0x900000001fc0a408:  df b0 00 38 ld	s0,56(sp)
[1814] 0x900000001fc0a40c:  10 00 00 0a b		0x900000001fc0a438
[1814] 0x900000001fc0a410:  8f a2 00 20 lw	v0,32(sp)
[1810] 0x900000001fc0a414:  af b2 00 20 sw	s2,32(sp)
[1810] 0x900000001fc0a418:  df b2 00 28 ld	s2,40(sp)
[1810] 0x900000001fc0a41c:  0f f0 2c e3 jal		loprintf
[1810] 0x900000001fc0a420:  66 04 1a 08 daddiu	a0,s0,6664
[1812] 0x900000001fc0a424:  df b0 00 38 ld	s0,56(sp)
[1812] 0x900000001fc0a428:  0f f0 2b 09 jal		pon_memerror
[1812] 0x900000001fc0a42c:  00 00 00 21 nada
[1812] 0x900000001fc0a430:  df bf 00 40 ld	ra,64(sp)
[1812] 0x900000001fc0a434:  8f a2 00 20 lw	v0,32(sp)
 1815: 		
 1816:     return fail;
[1816] 0x900000001fc0a438:  03 e0 00 08 jr	ra
[1816] 0x900000001fc0a43c:  67 bd 00 50 daddiu	sp,sp,80
 1817: }
 1818: 
 1819: static int bwalking_addr(volatile struct addr_range *addr)
 1820: {
bwalking_addr:
[1820] 0x900000001fc0a440:  67 bd ff 00 daddiu	sp,sp,-256
 1821:     register unsigned char k;
 1822:     volatile uint testline;
 1823:     int fail = 0;
 1824:     volatile caddr_t pmem, refmem;
 1825:     caddr_t lomem = (caddr_t)addr->lomem;
[1825] 0x900000001fc0a444:  ff b1 00 78 sd	s1,120(sp)
[1825] 0x900000001fc0a448:  dc 91 00 00 ld	s1,0(a0)
 1826:     caddr_t himem = (caddr_t)addr->himem;
 1827:     jmp_buf fault_buf;			/* Status buffer */
 1828:     uint *prev_fault;			/* Previous fault buffer */
 1829:     volatile int mode;
 1830: 
 1831: #define WRITE_PMEM	0
 1832: #define WRITE_RMEM	1
 1833: #define READ_PMEM	2
 1834: 
 1835:     /* If an exception occurs, return to the following block */
 1836:     if (setfault(fault_buf, &prev_fault)) {
[1836] 0x900000001fc0a44c:  ff b7 00 48 sd	s7,72(sp)
[1836] 0x900000001fc0a450:  00 80 b8 25 move	s7,a0
[1836] 0x900000001fc0a454:  67 a5 00 00 daddiu	a1,sp,0
[1826] 0x900000001fc0a458:  ff b4 00 60 sd	s4,96(sp)
[1826] 0x900000001fc0a45c:  dc 94 00 08 ld	s4,8(a0)
[1826] 0x900000001fc0a460:  67 a4 00 90 daddiu	a0,sp,144
[1826] 0x900000001fc0a464:  ff bf 00 88 sd	ra,136(sp)
[1826] 0x900000001fc0a468:  0f f0 18 7f jal		setfault
[1826] 0x900000001fc0a46c:  ff a0 00 28 sd	zero,40(sp)
[1826] 0x900000001fc0a470:  ff b3 00 68 sd	s3,104(sp)
[1826] 0x900000001fc0a474:  14 40 00 65 bne	v0,zero,0x900000001fc0a60c
[1826] 0x900000001fc0a478:  00 00 00 21 nada
[1823] 0x900000001fc0a47c:  24 13 00 01 li	s3,1
 1837: 	restorefault(prev_fault);
 1838: 	if (mode == WRITE_PMEM) {
 1839: 	    loprintf("\n*** Took an exception at 0x%x\n", pmem);
 1840: 	    loprintf("    Writing 0x55\n");
 1841: 	} else if (mode == WRITE_RMEM) {
 1842: 	    loprintf("\n*** Took an exception at 0x%x\n", refmem);
 1843: 	    loprintf("    Writing 0xaa\n");
 1844: 	} else {
 1845: 	    loprintf("\n*** Took an exception at 0x%x\n", pmem);
 1846: 	    loprintf("    Reading (should have been 0xaa)\n");
 1847: 	}
 1848: 	loprintf("    Testing line 0x%x\n", testline);
 1849: 	return 1;			/* FAILED! */
 1850:     }
 1851: 
 1852:     refmem = lomem;
[1852] 0x900000001fc0a480:  df b9 00 28 ld	t9,40(sp)
[1852] 0x900000001fc0a484:  ff b1 00 18 sd	s1,24(sp)
 1853:     for (testline = 1;
[1853] 0x900000001fc0a488:  ff b5 00 58 sd	s5,88(sp)
[1853] 0x900000001fc0a48c:  24 15 00 01 li	s5,1
[1853] 0x900000001fc0a490:  af b5 00 20 sw	s5,32(sp)
[1853] 0x900000001fc0a494:  8f b5 00 20 lw	s5,32(sp)
[1853] 0x900000001fc0a498:  00 15 a8 3c dsll32	s5,s5,0
[1853] 0x900000001fc0a49c:  3c 01 1f c2 lui	at,0x1fc2
[1853] 0x900000001fc0a4a0:  00 15 a8 3e dsrl32	s5,s5,0
[1853] 0x900000001fc0a4a4:  ff b0 00 80 sd	s0,128(sp)
[1853] 0x900000001fc0a4a8:  3c 18 90 00 lui	t8,0x9000
[1853] 0x900000001fc0a4ac:  02 35 a8 25 or	s5,s1,s5
[1853] 0x900000001fc0a4b0:  ff be 00 40 sd	s8,64(sp)
[1853] 0x900000001fc0a4b4:  3c 1e 90 00 lui	s8,0x9000
[1853] 0x900000001fc0a4b8:  02 95 a8 2b sltu	s5,s4,s5
[1853] 0x900000001fc0a4bc:  ff b2 00 70 sd	s2,112(sp)
[1853] 0x900000001fc0a4c0:  24 12 00 55 li	s2,85
[1853] 0x900000001fc0a4c4:  ff b6 00 50 sd	s6,80(sp)
[1853] 0x900000001fc0a4c8:  56 a0 00 47 bnel	s5,zero,0x900000001fc0a5e8
[1853] 0x900000001fc0a4cc:  df b2 00 70 ld	s2,112(sp)
[1853] 0x900000001fc0a4d0:  24 15 00 aa li	s5,170
[1853] 0x900000001fc0a4d4:  63 1f 00 00 daddi	ra,t8,0
[1853] 0x900000001fc0a4d8:  3c 18 90 00 lui	t8,0x9000
[1853] 0x900000001fc0a4dc:  63 18 00 00 daddi	t8,t8,0
[1853] 0x900000001fc0a4e0:  63 de 00 00 daddi	s8,s8,0
[1853] 0x900000001fc0a4e4:  60 23 b6 78 daddi	v1,at,-18824
[1853] 0x900000001fc0a4e8:  3c 01 1f c2 lui	at,0x1fc2
[1853] 0x900000001fc0a4ec:  60 22 b6 90 daddi	v0,at,-18800
[1853] 0x900000001fc0a4f0:  3c 01 1f c2 lui	at,0x1fc2
[1853] 0x900000001fc0a4f4:  60 21 b6 50 daddi	at,at,-18864
[1853] 0x900000001fc0a4f8:  00 1f f8 3c dsll32	ra,ra,0
[1853] 0x900000001fc0a4fc:  00 18 c0 3c dsll32	t8,t8,0
[1853] 0x900000001fc0a500:  03 e3 f8 2c dadd	ra,ra,v1
[1853] 0x900000001fc0a504:  00 1e f0 3c dsll32	s8,s8,0
[1853] 0x900000001fc0a508:  03 02 c0 2c dadd	t8,t8,v0
[1853] 0x900000001fc0a50c:  ff bf 00 30 sd	ra,48(sp)
[1853] 0x900000001fc0a510:  24 16 00 02 li	s6,2
[1853] 0x900000001fc0a514:  03 c1 f0 2c dadd	s8,s8,at
[1853] 0x900000001fc0a518:  ff b8 00 38 sd	t8,56(sp)
 1854: 	 ((__scunsigned_t)lomem | testline) <= (__scunsigned_t)himem;
 1855: 	 testline <<= 1)
 1856:     {
 1857: 	mode = WRITE_RMEM;
[1857] 0x900000001fc0a51c:  af b3 00 08 sw	s3,8(sp)
 1858: 	*(unsigned char *)refmem = 0x55;
[1858] 0x900000001fc0a520:  df a1 00 18 ld	at,24(sp)
[1858] 0x900000001fc0a524:  a0 32 00 00 sb	s2,0(at)
 1859: 	pmem = (caddr_t)((__scunsigned_t)lomem | testline);
[1859] 0x900000001fc0a528:  8f a1 00 20 lw	at,32(sp)
[1859] 0x900000001fc0a52c:  00 01 08 3c dsll32	at,at,0
[1859] 0x900000001fc0a530:  00 01 08 3e dsrl32	at,at,0
[1859] 0x900000001fc0a534:  02 21 08 25 or	at,s1,at
[1859] 0x900000001fc0a538:  ff a1 00 10 sd	at,16(sp)
 1860: 	if (pmem == refmem)
[1860] 0x900000001fc0a53c:  df a1 00 10 ld	at,16(sp)
[1860] 0x900000001fc0a540:  df a2 00 18 ld	v0,24(sp)
[1860] 0x900000001fc0a544:  50 22 00 1e beql	at,v0,0x900000001fc0a5c0
[1860] 0x900000001fc0a548:  8f a7 00 20 lw	a3,32(sp)
 1861: 	    continue;
 1862: 	mode = WRITE_PMEM;
[1862] 0x900000001fc0a54c:  af a0 00 08 sw	zero,8(sp)
 1863: 	*(unsigned char *)pmem = 0xaa;
[1863] 0x900000001fc0a550:  df a3 00 10 ld	v1,16(sp)
[1863] 0x900000001fc0a554:  a0 75 00 00 sb	s5,0(v1)
 1864: 	mode = READ_PMEM;
[1864] 0x900000001fc0a558:  af b6 00 08 sw	s6,8(sp)
 1865: 	k = LBU(refmem) & addr->dmask;
[1865] 0x900000001fc0a55c:  8e e3 00 10 lw	v1,16(s7)
[1865] 0x900000001fc0a560:  df a4 00 18 ld	a0,24(sp)
[1865] 0x900000001fc0a564:  90 84 00 00 lbu	a0,0(a0)
[1865] 0x900000001fc0a568:  00 64 18 24 and	v1,v1,a0
 1866: 	if (k != (0x55 & addr->dmask)) {
[1866] 0x900000001fc0a56c:  30 64 00 ff andi	a0,v1,0xff
[1866] 0x900000001fc0a570:  8e e3 00 10 lw	v1,16(s7)
[1866] 0x900000001fc0a574:  30 63 00 55 andi	v1,v1,0x55
[1866] 0x900000001fc0a578:  30 90 00 ff andi	s0,a0,0xff
[1866] 0x900000001fc0a57c:  52 03 00 10 beql	s0,v1,0x900000001fc0a5c0
[1866] 0x900000001fc0a580:  8f a7 00 20 lw	a3,32(sp)
 1867: 	    loprintf(
[1867] 0x900000001fc0a584:  df a5 00 18 ld	a1,24(sp)
[1867] 0x900000001fc0a588:  03 c0 20 25 move	a0,s8
[1867] 0x900000001fc0a58c:  0f f0 2c e3 jal		loprintf
[1867] 0x900000001fc0a590:  df a6 00 10 ld	a2,16(sp)
 1868: 		     "*** Wrote 0x55 to %x, wrote 0xAA to %x\n",
 1869: 		     refmem, pmem);
 1870: 	    loprintf("read %x from %x\n", k, refmem);
[1870] 0x900000001fc0a594:  df a6 00 18 ld	a2,24(sp)
[1870] 0x900000001fc0a598:  02 00 28 25 move	a1,s0
[1870] 0x900000001fc0a59c:  0f f0 2c e3 jal		loprintf
[1870] 0x900000001fc0a5a0:  df a4 00 30 ld	a0,48(sp)
 1871: 	    loprintf("    Testing line 0x%x\n", testline);
[1871] 0x900000001fc0a5a4:  8f a5 00 20 lw	a1,32(sp)
[1871] 0x900000001fc0a5a8:  0f f0 2c e3 jal		loprintf
[1871] 0x900000001fc0a5ac:  df a4 00 38 ld	a0,56(sp)
 1872: 	    pon_memerror();
[1872] 0x900000001fc0a5b0:  0f f0 2b 09 jal		pon_memerror
[1872] 0x900000001fc0a5b4:  00 00 00 21 nada
 1873: 	    fail = 1;
[1873] 0x900000001fc0a5b8:  02 60 c8 25 move	t9,s3
[1873] 0x900000001fc0a5bc:  8f a7 00 20 lw	a3,32(sp)
[1855] 0x900000001fc0a5c0:  00 07 38 40 sll	a3,a3,1
[1855] 0x900000001fc0a5c4:  af a7 00 20 sw	a3,32(sp)
[1853] 0x900000001fc0a5c8:  8f a7 00 20 lw	a3,32(sp)
[1853] 0x900000001fc0a5cc:  00 07 38 3c dsll32	a3,a3,0
[1853] 0x900000001fc0a5d0:  00 07 38 3e dsrl32	a3,a3,0
[1853] 0x900000001fc0a5d4:  02 27 38 25 or	a3,s1,a3
[1853] 0x900000001fc0a5d8:  02 87 38 2b sltu	a3,s4,a3
[1853] 0x900000001fc0a5dc:  10 e0 ff cf beq	a3,zero,0x900000001fc0a51c
[1853] 0x900000001fc0a5e0:  00 00 00 21 nada
[1853] 0x900000001fc0a5e4:  df b2 00 70 ld	s2,112(sp)
[1853] 0x900000001fc0a5e8:  df a4 00 00 ld	a0,0(sp)
 1874: 	}
 1875:     }
 1876:     restorefault(prev_fault);
[1876] 0x900000001fc0a5ec:  df b1 00 78 ld	s1,120(sp)
[1876] 0x900000001fc0a5f0:  0f f0 18 86 jal		restorefault
[1876] 0x900000001fc0a5f4:  ff b9 00 28 sd	t9,40(sp)
 1877:     return fail;
[1877] 0x900000001fc0a5f8:  df b6 00 50 ld	s6,80(sp)
[1877] 0x900000001fc0a5fc:  df be 00 40 ld	s8,64(sp)
[1877] 0x900000001fc0a600:  df b5 00 58 ld	s5,88(sp)
[1877] 0x900000001fc0a604:  10 00 00 28 b		0x900000001fc0a6a8
[1877] 0x900000001fc0a608:  df a2 00 28 ld	v0,40(sp)
[1837] 0x900000001fc0a60c:  0f f0 18 86 jal		restorefault
[1837] 0x900000001fc0a610:  df a4 00 00 ld	a0,0(sp)
[1838] 0x900000001fc0a614:  3c 08 90 00 lui	a4,0x9000
[1838] 0x900000001fc0a618:  61 08 00 00 daddi	a4,a4,0
[1838] 0x900000001fc0a61c:  3c 09 1f c2 lui	a5,0x1fc2
[1838] 0x900000001fc0a620:  61 2a 9b 40 daddi	a6,a5,-25792
[1838] 0x900000001fc0a624:  00 08 48 3c dsll32	a5,a4,0
[1838] 0x900000001fc0a628:  8f a8 00 08 lw	a4,8(sp)
[1838] 0x900000001fc0a62c:  ff b0 00 80 sd	s0,128(sp)
[1838] 0x900000001fc0a630:  11 00 00 13 beq	a4,zero,0x900000001fc0a680
[1838] 0x900000001fc0a634:  01 2a 80 2c dadd	s0,a5,a6
[1841] 0x900000001fc0a638:  8f ab 00 08 lw	a7,8(sp)
[1841] 0x900000001fc0a63c:  24 13 00 01 li	s3,1
[1841] 0x900000001fc0a640:  51 73 00 09 beql	a7,s3,0x900000001fc0a668
[1841] 0x900000001fc0a644:  df a5 00 18 ld	a1,24(sp)
[1845] 0x900000001fc0a648:  df a5 00 10 ld	a1,16(sp)
[1845] 0x900000001fc0a64c:  0f f0 2c e3 jal		loprintf
[1845] 0x900000001fc0a650:  66 04 1a b0 daddiu	a0,s0,6832
[1846] 0x900000001fc0a654:  0f f0 2c e3 jal		loprintf
[1846] 0x900000001fc0a658:  66 04 1a d0 daddiu	a0,s0,6864
[1846] 0x900000001fc0a65c:  10 00 00 0e b		0x900000001fc0a698
[1846] 0x900000001fc0a660:  df b1 00 78 ld	s1,120(sp)
[1842] 0x900000001fc0a664:  df a5 00 18 ld	a1,24(sp)
[1842] 0x900000001fc0a668:  0f f0 2c e3 jal		loprintf
[1842] 0x900000001fc0a66c:  66 04 1a 78 daddiu	a0,s0,6776
[1843] 0x900000001fc0a670:  0f f0 2c e3 jal		loprintf
[1843] 0x900000001fc0a674:  66 04 1a 98 daddiu	a0,s0,6808
[1843] 0x900000001fc0a678:  10 00 00 07 b		0x900000001fc0a698
[1843] 0x900000001fc0a67c:  df b1 00 78 ld	s1,120(sp)
[1839] 0x900000001fc0a680:  df a5 00 10 ld	a1,16(sp)
[1839] 0x900000001fc0a684:  0f f0 2c e3 jal		loprintf
[1839] 0x900000001fc0a688:  66 04 1a 40 daddiu	a0,s0,6720
[1840] 0x900000001fc0a68c:  0f f0 2c e3 jal		loprintf
[1840] 0x900000001fc0a690:  66 04 1a 60 daddiu	a0,s0,6752
[1840] 0x900000001fc0a694:  df b1 00 78 ld	s1,120(sp)
[1848] 0x900000001fc0a698:  8f a5 00 20 lw	a1,32(sp)
[1848] 0x900000001fc0a69c:  0f f0 2c e3 jal		loprintf
[1848] 0x900000001fc0a6a0:  66 04 1a f8 daddiu	a0,s0,6904
[1849] 0x900000001fc0a6a4:  24 02 00 01 li	v0,1
[1849] 0x900000001fc0a6a8:  df b7 00 48 ld	s7,72(sp)
[1849] 0x900000001fc0a6ac:  df bf 00 88 ld	ra,136(sp)
[1849] 0x900000001fc0a6b0:  df b3 00 68 ld	s3,104(sp)
[1849] 0x900000001fc0a6b4:  df b0 00 80 ld	s0,128(sp)
[1849] 0x900000001fc0a6b8:  df b4 00 60 ld	s4,96(sp)
[1849] 0x900000001fc0a6bc:  03 e0 00 08 jr	ra
[1849] 0x900000001fc0a6c0:  67 bd 01 00 daddiu	sp,sp,256
 1878: }
 1879: 
 1880: /* Use current addr as the test pattern */
 1881: static int 
 1882: addr_pattern(volatile struct addr_range *addr)
 1883: {
addr_pattern:
[1883] 0x900000001fc0a6c4:  67 bd ff 20 daddiu	sp,sp,-224
 1884:     register int inc = (int)(addr->inc * sizeof(uint));
[1884] 0x900000001fc0a6c8:  ff b0 00 60 sd	s0,96(sp)
[1884] 0x900000001fc0a6cc:  8c 90 00 14 lw	s0,20(a0)
 1885:     uint mask = addr->dmask;
 1886:     volatile caddr_t pmem;
 1887:     volatile caddr_t pmemhi;
 1888:     volatile int data;
 1889:     int fail = 0;
 1890:     jmp_buf fault_buf;			/* Status buffer */
 1891:     uint *prev_fault;			/* Previous fault buffer */
 1892:     volatile int mode;
 1893: 
 1894:     /* If an exception occurs, return to the following block */
 1895:     if (setfault(fault_buf, &prev_fault)) {
[1895] 0x900000001fc0a6d0:  ff b5 00 38 sd	s5,56(sp)
[1895] 0x900000001fc0a6d4:  00 80 a8 25 move	s5,a0
[1895] 0x900000001fc0a6d8:  67 a5 00 00 daddiu	a1,sp,0
[1885] 0x900000001fc0a6dc:  ff b2 00 50 sd	s2,80(sp)
[1885] 0x900000001fc0a6e0:  8c 92 00 10 lw	s2,16(a0)
[1885] 0x900000001fc0a6e4:  67 a4 00 70 daddiu	a0,sp,112
[1889] 0x900000001fc0a6e8:  ff b4 00 40 sd	s4,64(sp)
[1889] 0x900000001fc0a6ec:  ff bf 00 68 sd	ra,104(sp)
[1889] 0x900000001fc0a6f0:  0f f0 18 7f jal		setfault
[1889] 0x900000001fc0a6f4:  00 00 a0 25 move	s4,zero
[1889] 0x900000001fc0a6f8:  ff b1 00 58 sd	s1,88(sp)
[1889] 0x900000001fc0a6fc:  3c 01 90 00 lui	at,0x9000
[1889] 0x900000001fc0a700:  ff b3 00 48 sd	s3,72(sp)
[1889] 0x900000001fc0a704:  60 21 00 00 daddi	at,at,0
[1889] 0x900000001fc0a708:  3c 03 1f c2 lui	v1,0x1fc2
[1889] 0x900000001fc0a70c:  00 01 08 3c dsll32	at,at,0
[1889] 0x900000001fc0a710:  60 63 9b 40 daddi	v1,v1,-25792
[1889] 0x900000001fc0a714:  ff b7 00 28 sd	s7,40(sp)
[1889] 0x900000001fc0a718:  14 40 00 50 bne	v0,zero,0x900000001fc0a85c
[1889] 0x900000001fc0a71c:  00 23 b8 2c dadd	s7,at,v1
 1896: 	restorefault(prev_fault);
 1897: 	loprintf("\n*** Took an exception checking addr 0x%x\n", pmem);
 1898: 	if (mode == WRITING)
 1899: 	    loprintf("    Writing 0x%x\n", pmem);
 1900: 	else
 1901: 	    loprintf("    Reading (should have been 0x%x)\n",
 1902: 		     pmem);
 1903: 	return 1;			/* FAILED! */
 1904:     }
 1905: 
 1906: 
 1907:     pmem = (caddr_t)addr->lomem;
[1907] 0x900000001fc0a720:  de b3 00 00 ld	s3,0(s5)
[1907] 0x900000001fc0a724:  ff b6 00 30 sd	s6,48(sp)
[1907] 0x900000001fc0a728:  ff b3 00 08 sd	s3,8(sp)
 1908:     pmemhi = (caddr_t)addr->himem;
[1908] 0x900000001fc0a72c:  de b8 00 08 ld	t8,8(s5)
[1908] 0x900000001fc0a730:  00 10 20 b8 dsll	a0,s0,2
[1908] 0x900000001fc0a734:  ff b8 00 18 sd	t8,24(sp)
 1909: 
 1910:     mode = WRITING;
[1910] 0x900000001fc0a738:  00 04 b0 00 sll	s6,a0,0
[1910] 0x900000001fc0a73c:  24 11 00 01 li	s1,1
[1910] 0x900000001fc0a740:  af b1 00 10 sw	s1,16(sp)
 1911:     while ((__scunsigned_t)pmem < (__scunsigned_t)pmemhi) {
[1911] 0x900000001fc0a744:  df b8 00 08 ld	t8,8(sp)
[1911] 0x900000001fc0a748:  02 c0 80 25 move	s0,s6
[1911] 0x900000001fc0a74c:  34 13 ff ff ori	s3,zero,0xffff
[1911] 0x900000001fc0a750:  df b9 00 18 ld	t9,24(sp)
[1911] 0x900000001fc0a754:  00 13 9c 38 dsll	s3,s3,16
[1911] 0x900000001fc0a758:  03 19 c0 2b sltu	t8,t8,t9
[1911] 0x900000001fc0a75c:  13 00 00 0e beq	t8,zero,0x900000001fc0a798
[1911] 0x900000001fc0a760:  36 73 ff ff ori	s3,s3,0xffff
 1912: 	*(volatile uint *)pmem = 
[1912] 0x900000001fc0a764:  df bf 00 08 ld	ra,8(sp)
[1912] 0x900000001fc0a768:  03 f3 f8 24 and	ra,ra,s3
[1912] 0x900000001fc0a76c:  df a1 00 08 ld	at,8(sp)
[1912] 0x900000001fc0a770:  00 1f f8 00 sll	ra,ra,0
[1912] 0x900000001fc0a774:  ac 3f 00 00 sw	ra,0(at)
 1913: 	    (uint)((__scunsigned_t)pmem & 0xffffffff);
 1914: 	pmem += inc;
[1914] 0x900000001fc0a778:  df bf 00 08 ld	ra,8(sp)
[1914] 0x900000001fc0a77c:  03 f0 f8 2d daddu	ra,ra,s0
[1914] 0x900000001fc0a780:  ff bf 00 08 sd	ra,8(sp)
[1911] 0x900000001fc0a784:  df bf 00 08 ld	ra,8(sp)
[1911] 0x900000001fc0a788:  df a1 00 18 ld	at,24(sp)
[1911] 0x900000001fc0a78c:  03 e1 f8 2b sltu	ra,ra,at
[1911] 0x900000001fc0a790:  57 e0 ff f5 bnel	ra,zero,0x900000001fc0a768
[1911] 0x900000001fc0a794:  df bf 00 08 ld	ra,8(sp)
 1915:     }
 1916: 
 1917:     loprintf(".");
[1917] 0x900000001fc0a798:  0f f0 2c e3 jal		loprintf
[1917] 0x900000001fc0a79c:  66 e4 1b d5 daddiu	a0,s7,7125
 1918:     pmem = (caddr_t)addr->lomem;
[1918] 0x900000001fc0a7a0:  de a1 00 00 ld	at,0(s5)
[1918] 0x900000001fc0a7a4:  ff a1 00 08 sd	at,8(sp)
 1919: 
 1920:     mode = READING;
[1920] 0x900000001fc0a7a8:  af a0 00 10 sw	zero,16(sp)
 1921:     while ((__scunsigned_t)pmem < (__scunsigned_t)pmemhi) {
[1921] 0x900000001fc0a7ac:  df a1 00 08 ld	at,8(sp)
[1921] 0x900000001fc0a7b0:  66 f3 1b d8 daddiu	s3,s7,7128
[1921] 0x900000001fc0a7b4:  02 c0 80 25 move	s0,s6
[1921] 0x900000001fc0a7b8:  df a2 00 18 ld	v0,24(sp)
[1921] 0x900000001fc0a7bc:  00 12 18 3c dsll32	v1,s2,0
[1921] 0x900000001fc0a7c0:  00 03 88 3e dsrl32	s1,v1,0
[1921] 0x900000001fc0a7c4:  00 22 08 2b sltu	at,at,v0
[1921] 0x900000001fc0a7c8:  50 20 00 1c beql	at,zero,0x900000001fc0a83c
[1921] 0x900000001fc0a7cc:  df b3 00 48 ld	s3,72(sp)
[1921] 0x900000001fc0a7d0:  02 60 20 25 move	a0,s3
 1922: 	if ((data = (LW(pmem) & mask)) != 
[1922] 0x900000001fc0a7d4:  df a5 00 08 ld	a1,8(sp)
[1922] 0x900000001fc0a7d8:  8c a5 00 00 lw	a1,0(a1)
[1922] 0x900000001fc0a7dc:  02 45 28 24 and	a1,s2,a1
[1922] 0x900000001fc0a7e0:  af a5 00 20 sw	a1,32(sp)
[1922] 0x900000001fc0a7e4:  8f a5 00 20 lw	a1,32(sp)
[1922] 0x900000001fc0a7e8:  df a6 00 08 ld	a2,8(sp)
[1922] 0x900000001fc0a7ec:  00 d1 30 24 and	a2,a2,s1
[1922] 0x900000001fc0a7f0:  50 a6 00 0a beql	a1,a2,0x900000001fc0a81c
[1922] 0x900000001fc0a7f4:  df a8 00 08 ld	a4,8(sp)
 1923: 	    ((__scunsigned_t)pmem & mask)) {
 1924: 	    loprintf(
[1924] 0x900000001fc0a7f8:  df a7 00 08 ld	a3,8(sp)
[1924] 0x900000001fc0a7fc:  00 e0 28 25 move	a1,a3
[1924] 0x900000001fc0a800:  df a6 00 08 ld	a2,8(sp)
[1924] 0x900000001fc0a804:  0f f0 2c e3 jal		loprintf
[1924] 0x900000001fc0a808:  8f a7 00 20 lw	a3,32(sp)
 1925: 		     "\tError\n\tWrote %x to %x,\tread back %x\n",
 1926: 		     pmem, pmem, data);
 1927: 	    pon_memerror();
[1927] 0x900000001fc0a80c:  0f f0 2b 09 jal		pon_memerror
[1927] 0x900000001fc0a810:  00 00 00 21 nada
 1928: 	    fail = 1;
[1928] 0x900000001fc0a814:  24 14 00 01 li	s4,1
[1928] 0x900000001fc0a818:  df a8 00 08 ld	a4,8(sp)
 1929: 	}
 1930: 	pmem += inc;
[1930] 0x900000001fc0a81c:  01 10 40 2d daddu	a4,a4,s0
[1930] 0x900000001fc0a820:  ff a8 00 08 sd	a4,8(sp)
[1921] 0x900000001fc0a824:  df a8 00 08 ld	a4,8(sp)
[1921] 0x900000001fc0a828:  df a9 00 18 ld	a5,24(sp)
[1921] 0x900000001fc0a82c:  01 09 40 2b sltu	a4,a4,a5
[1921] 0x900000001fc0a830:  55 00 ff e8 bnel	a4,zero,0x900000001fc0a7d4
[1921] 0x900000001fc0a834:  02 60 20 25 move	a0,s3
[1921] 0x900000001fc0a838:  df b3 00 48 ld	s3,72(sp)
 1931:     }
 1932:     restorefault(prev_fault);
[1932] 0x900000001fc0a83c:  0f f0 18 86 jal		restorefault
[1932] 0x900000001fc0a840:  df a4 00 00 ld	a0,0(sp)
 1933:     return fail;
[1933] 0x900000001fc0a844:  df b1 00 58 ld	s1,88(sp)
[1933] 0x900000001fc0a848:  02 80 10 25 move	v0,s4
[1933] 0x900000001fc0a84c:  df b4 00 40 ld	s4,64(sp)
[1933] 0x900000001fc0a850:  df b7 00 28 ld	s7,40(sp)
[1933] 0x900000001fc0a854:  10 00 00 1b b		0x900000001fc0a8c4
[1933] 0x900000001fc0a858:  df bf 00 68 ld	ra,104(sp)
[1896] 0x900000001fc0a85c:  0f f0 18 86 jal		restorefault
[1896] 0x900000001fc0a860:  df a4 00 00 ld	a0,0(sp)
[1897] 0x900000001fc0a864:  df a5 00 08 ld	a1,8(sp)
[1897] 0x900000001fc0a868:  0f f0 2c e3 jal		loprintf
[1897] 0x900000001fc0a86c:  66 e4 1b 68 daddiu	a0,s7,7016
[1898] 0x900000001fc0a870:  8f aa 00 10 lw	a6,16(sp)
[1898] 0x900000001fc0a874:  ff b6 00 30 sd	s6,48(sp)
[1898] 0x900000001fc0a878:  24 11 00 01 li	s1,1
[1898] 0x900000001fc0a87c:  51 51 00 0a beql	a6,s1,0x900000001fc0a8a8
[1898] 0x900000001fc0a880:  df b1 00 58 ld	s1,88(sp)
[1898] 0x900000001fc0a884:  df b1 00 58 ld	s1,88(sp)
[1901] 0x900000001fc0a888:  df a5 00 08 ld	a1,8(sp)
[1901] 0x900000001fc0a88c:  0f f0 2c e3 jal		loprintf
[1901] 0x900000001fc0a890:  66 e4 1b b0 daddiu	a0,s7,7088
[1901] 0x900000001fc0a894:  df b7 00 28 ld	s7,40(sp)
[1901] 0x900000001fc0a898:  24 02 00 01 li	v0,1
[1901] 0x900000001fc0a89c:  10 00 00 08 b		0x900000001fc0a8c0
[1901] 0x900000001fc0a8a0:  df b4 00 40 ld	s4,64(sp)
[1901] 0x900000001fc0a8a4:  df b1 00 58 ld	s1,88(sp)
[1899] 0x900000001fc0a8a8:  df a5 00 08 ld	a1,8(sp)
[1899] 0x900000001fc0a8ac:  0f f0 2c e3 jal		loprintf
[1899] 0x900000001fc0a8b0:  66 e4 1b 98 daddiu	a0,s7,7064
[1899] 0x900000001fc0a8b4:  df b7 00 28 ld	s7,40(sp)
[1899] 0x900000001fc0a8b8:  df b4 00 40 ld	s4,64(sp)
[1899] 0x900000001fc0a8bc:  24 02 00 01 li	v0,1
[1903] 0x900000001fc0a8c0:  df bf 00 68 ld	ra,104(sp)
[1903] 0x900000001fc0a8c4:  df b5 00 38 ld	s5,56(sp)
[1903] 0x900000001fc0a8c8:  df b2 00 50 ld	s2,80(sp)
[1903] 0x900000001fc0a8cc:  df b0 00 60 ld	s0,96(sp)
[1903] 0x900000001fc0a8d0:  df b6 00 30 ld	s6,48(sp)
[1903] 0x900000001fc0a8d4:  03 e0 00 08 jr	ra
[1903] 0x900000001fc0a8d8:  67 bd 00 e0 daddiu	sp,sp,224
 1934: }
 1935: 
 1936: 
 1937: int rw_loop(volatile struct addr_range *addr, uint old_pat, uint new_pat)
 1938: {
rw_loop:
[1938] 0x900000001fc0a8dc:  67 bd ff 20 daddiu	sp,sp,-224
 1939:     register uint inc = (uint)addr->inc * (uint)sizeof(uint);
[1939] 0x900000001fc0a8e0:  ff b1 00 50 sd	s1,80(sp)
[1939] 0x900000001fc0a8e4:  8c 91 00 14 lw	s1,20(a0)
 1940:     volatile uint data;
 1941:     volatile caddr_t ptr;
 1942:     caddr_t himem = (caddr_t)addr->himem;
[1942] 0x900000001fc0a8e8:  ff b3 00 40 sd	s3,64(sp)
[1942] 0x900000001fc0a8ec:  00 a0 98 25 move	s3,a1
[1942] 0x900000001fc0a8f0:  ff b2 00 48 sd	s2,72(sp)
[1942] 0x900000001fc0a8f4:  dc 92 00 08 ld	s2,8(a0)
 1943:     caddr_t lomem = (caddr_t)addr->lomem;
[1943] 0x900000001fc0a8f8:  ff b5 00 30 sd	s5,48(sp)
[1943] 0x900000001fc0a8fc:  00 c0 a8 25 move	s5,a2
 1944:     uint mask = (uint)addr->dmask;
 1945:     int fail = 0;
[1945] 0x900000001fc0a900:  ff b0 00 58 sd	s0,88(sp)
[1945] 0x900000001fc0a904:  dc 90 00 00 ld	s0,0(a0)
[1944] 0x900000001fc0a908:  67 a5 00 00 daddiu	a1,sp,0
[1944] 0x900000001fc0a90c:  ff b4 00 38 sd	s4,56(sp)
[1944] 0x900000001fc0a910:  8c 94 00 10 lw	s4,16(a0)
[1944] 0x900000001fc0a914:  ff bf 00 60 sd	ra,96(sp)
[1944] 0x900000001fc0a918:  0f f0 18 7f jal		setfault
[1944] 0x900000001fc0a91c:  67 a4 00 70 daddiu	a0,sp,112
[1944] 0x900000001fc0a920:  ff be 00 18 sd	s8,24(sp)
[1944] 0x900000001fc0a924:  ff b6 00 28 sd	s6,40(sp)
[1944] 0x900000001fc0a928:  14 40 00 32 bne	v0,zero,0x900000001fc0a9f4
[1944] 0x900000001fc0a92c:  00 11 f0 80 sll	s8,s1,2
[1944] 0x900000001fc0a930:  00 1e f0 3c dsll32	s8,s8,0
 1946:     jmp_buf fault_buf;			/* Status buffer */
 1947:     uint *prev_fault;			/* Previous fault buffer */
 1948:     volatile int mode;
 1949: 
 1950:     /* If an exception occurs, return to the following block */
 1951:     if (setfault(fault_buf, &prev_fault)) {
 1952: 	restorefault(prev_fault);
 1953: 	loprintf("\n*** Took an exception checking addr 0x%x\n", ptr);
 1954: 	if (mode == WRITING)
 1955: 	    loprintf("    Writing 0x%x\n", new_pat);
 1956: 	else
 1957: 	    loprintf("    Reading (should have been 0x%x)\n",
 1958: 		     old_pat);
 1959: 	return 1;			/* FAILED! */
 1960:     }
 1961: 
 1962:     for (ptr = lomem ; ptr < himem; ptr += inc) {
[1962] 0x900000001fc0a934:  ff b0 00 08 sd	s0,8(sp)
[1962] 0x900000001fc0a938:  24 10 00 01 li	s0,1
[1962] 0x900000001fc0a93c:  3c 18 90 00 lui	t8,0x9000
[1962] 0x900000001fc0a940:  df b6 00 08 ld	s6,8(sp)
[1962] 0x900000001fc0a944:  00 1e 88 3e dsrl32	s1,s8,0
[1962] 0x900000001fc0a948:  02 d2 b0 2b sltu	s6,s6,s2
[1962] 0x900000001fc0a94c:  3c 19 1f c2 lui	t9,0x1fc2
[1962] 0x900000001fc0a950:  ff b7 00 20 sd	s7,32(sp)
[1962] 0x900000001fc0a954:  12 c0 00 1e beq	s6,zero,0x900000001fc0a9d0
[1962] 0x900000001fc0a958:  00 00 b8 25 move	s7,zero
[1962] 0x900000001fc0a95c:  63 18 00 00 daddi	t8,t8,0
[1962] 0x900000001fc0a960:  63 39 b7 b0 daddi	t9,t9,-18512
[1962] 0x900000001fc0a964:  00 18 c0 3c dsll32	t8,t8,0
[1962] 0x900000001fc0a968:  03 19 b0 2c dadd	s6,t8,t9
[1962] 0x900000001fc0a96c:  02 c0 20 25 move	a0,s6
 1963: 	mode = READING;
[1963] 0x900000001fc0a970:  af a0 00 10 sw	zero,16(sp)
 1964: 	data = LW(ptr) & mask;
[1964] 0x900000001fc0a974:  df bf 00 08 ld	ra,8(sp)
[1964] 0x900000001fc0a978:  8f ff 00 00 lw	ra,0(ra)
[1964] 0x900000001fc0a97c:  02 9f f8 24 and	ra,s4,ra
[1964] 0x900000001fc0a980:  af bf 00 14 sw	ra,20(sp)
 1965: 	if (data != old_pat) {
[1965] 0x900000001fc0a984:  8f bf 00 14 lw	ra,20(sp)
[1965] 0x900000001fc0a988:  13 f3 00 07 beq	ra,s3,0x900000001fc0a9a8
[1965] 0x900000001fc0a98c:  02 60 28 25 move	a1,s3
 1966: 	    loprintf(
[1966] 0x900000001fc0a990:  df a6 00 08 ld	a2,8(sp)
[1966] 0x900000001fc0a994:  0f f0 2c e3 jal		loprintf
[1966] 0x900000001fc0a998:  8f a7 00 14 lw	a3,20(sp)
 1967: 		     "\tError\n\tWrote 0x%x to 0x%x; read 0x%x\n",
 1968: 		     old_pat, ptr, data);
 1969: 	    pon_memerror();
[1969] 0x900000001fc0a99c:  0f f0 2b 09 jal		pon_memerror
[1969] 0x900000001fc0a9a0:  00 00 00 21 nada
 1970: 	    fail = 1;
[1970] 0x900000001fc0a9a4:  02 00 b8 25 move	s7,s0
 1971: 	}
 1972: 	mode = WRITING;
[1972] 0x900000001fc0a9a8:  af b0 00 10 sw	s0,16(sp)
 1973: 	*(volatile uint *)ptr = new_pat;
[1973] 0x900000001fc0a9ac:  df a8 00 08 ld	a4,8(sp)
[1973] 0x900000001fc0a9b0:  ad 15 00 00 sw	s5,0(a4)
[1962] 0x900000001fc0a9b4:  df a8 00 08 ld	a4,8(sp)
[1962] 0x900000001fc0a9b8:  01 11 40 2d daddu	a4,a4,s1
[1962] 0x900000001fc0a9bc:  ff a8 00 08 sd	a4,8(sp)
[1962] 0x900000001fc0a9c0:  df a8 00 08 ld	a4,8(sp)
[1962] 0x900000001fc0a9c4:  01 12 40 2b sltu	a4,a4,s2
[1962] 0x900000001fc0a9c8:  55 00 ff e9 bnel	a4,zero,0x900000001fc0a970
[1962] 0x900000001fc0a9cc:  02 c0 20 25 move	a0,s6
[1962] 0x900000001fc0a9d0:  df b6 00 28 ld	s6,40(sp)
 1974:     }
 1975:     restorefault(prev_fault);
[1975] 0x900000001fc0a9d4:  0f f0 18 86 jal		restorefault
[1975] 0x900000001fc0a9d8:  df a4 00 00 ld	a0,0(sp)
 1976:     return fail;
[1976] 0x900000001fc0a9dc:  df b2 00 48 ld	s2,72(sp)
[1976] 0x900000001fc0a9e0:  df b0 00 58 ld	s0,88(sp)
[1976] 0x900000001fc0a9e4:  02 e0 10 25 move	v0,s7
[1976] 0x900000001fc0a9e8:  df b4 00 38 ld	s4,56(sp)
[1976] 0x900000001fc0a9ec:  10 00 00 28 b		0x900000001fc0aa90
[1976] 0x900000001fc0a9f0:  df be 00 18 ld	s8,24(sp)
[1952] 0x900000001fc0a9f4:  0f f0 18 86 jal		restorefault
[1952] 0x900000001fc0a9f8:  df a4 00 00 ld	a0,0(sp)
[1953] 0x900000001fc0a9fc:  3c 09 90 00 lui	a5,0x9000
[1953] 0x900000001fc0aa00:  3c 0a 1f c2 lui	a6,0x1fc2
[1953] 0x900000001fc0aa04:  61 29 00 00 daddi	a5,a5,0
[1953] 0x900000001fc0aa08:  61 4a b7 40 daddi	a6,a6,-18624
[1953] 0x900000001fc0aa0c:  3c 0c 90 00 lui	t0,0x9000
[1953] 0x900000001fc0aa10:  3c 0b 1f c2 lui	a7,0x1fc2
[1953] 0x900000001fc0aa14:  61 91 00 00 daddi	s1,t0,0
[1953] 0x900000001fc0aa18:  61 70 9b 40 daddi	s0,a7,-25792
[1953] 0x900000001fc0aa1c:  df a5 00 08 ld	a1,8(sp)
[1953] 0x900000001fc0aa20:  00 09 48 3c dsll32	a5,a5,0
[1953] 0x900000001fc0aa24:  0f f0 2c e3 jal		loprintf
[1953] 0x900000001fc0aa28:  01 2a 20 2c dadd	a0,a5,a6
[1953] 0x900000001fc0aa2c:  df b4 00 38 ld	s4,56(sp)
[1953] 0x900000001fc0aa30:  00 11 58 3c dsll32	a7,s1,0
[1954] 0x900000001fc0aa34:  8f a9 00 10 lw	a5,16(sp)
[1954] 0x900000001fc0aa38:  24 0a 00 01 li	a6,1
[1954] 0x900000001fc0aa3c:  df be 00 18 ld	s8,24(sp)
[1954] 0x900000001fc0aa40:  02 60 28 25 move	a1,s3
[1954] 0x900000001fc0aa44:  01 70 80 2c dadd	s0,a7,s0
[1954] 0x900000001fc0aa48:  51 2a 00 09 beql	a5,a6,0x900000001fc0aa70
[1954] 0x900000001fc0aa4c:  df b4 00 38 ld	s4,56(sp)
[1957] 0x900000001fc0aa50:  ff b7 00 20 sd	s7,32(sp)
[1957] 0x900000001fc0aa54:  df b2 00 48 ld	s2,72(sp)
[1957] 0x900000001fc0aa58:  0f f0 2c e3 jal		loprintf
[1957] 0x900000001fc0aa5c:  66 04 1c 48 daddiu	a0,s0,7240
[1957] 0x900000001fc0aa60:  24 02 00 01 li	v0,1
[1957] 0x900000001fc0aa64:  10 00 00 0a b		0x900000001fc0aa90
[1957] 0x900000001fc0aa68:  df b0 00 58 ld	s0,88(sp)
[1957] 0x900000001fc0aa6c:  df b4 00 38 ld	s4,56(sp)
[1957] 0x900000001fc0aa70:  df b2 00 48 ld	s2,72(sp)
[1955] 0x900000001fc0aa74:  02 a0 28 25 move	a1,s5
[1955] 0x900000001fc0aa78:  df be 00 18 ld	s8,24(sp)
[1955] 0x900000001fc0aa7c:  ff b7 00 20 sd	s7,32(sp)
[1955] 0x900000001fc0aa80:  0f f0 2c e3 jal		loprintf
[1955] 0x900000001fc0aa84:  66 04 1c 30 daddiu	a0,s0,7216
[1955] 0x900000001fc0aa88:  df b0 00 58 ld	s0,88(sp)
[1955] 0x900000001fc0aa8c:  24 02 00 01 li	v0,1
[1959] 0x900000001fc0aa90:  df bf 00 60 ld	ra,96(sp)
[1959] 0x900000001fc0aa94:  df b5 00 30 ld	s5,48(sp)
[1959] 0x900000001fc0aa98:  df b3 00 40 ld	s3,64(sp)
[1959] 0x900000001fc0aa9c:  df b1 00 50 ld	s1,80(sp)
[1959] 0x900000001fc0aaa0:  df b7 00 20 ld	s7,32(sp)
[1959] 0x900000001fc0aaa4:  03 e0 00 08 jr	ra
[1959] 0x900000001fc0aaa8:  67 bd 00 e0 daddiu	sp,sp,224
 1977: }
 1978: 
 1979: 
 1980: static int read_wr(volatile struct addr_range *addr)
 1981: {
read_wr:
[1981] 0x900000001fc0aaac:  67 bd ff c0 daddiu	sp,sp,-64
[1981] 0x900000001fc0aab0:  ff b0 00 28 sd	s0,40(sp)
[1981] 0x900000001fc0aab4:  00 80 80 25 move	s0,a0
 1982:     int fail = 0;
 1983:     volatile uint *ptr;
 1984: 
 1985:     for(ptr = addr->lomem; ptr < addr->himem; ptr += addr->inc)
[1985] 0x900000001fc0aab8:  3c 01 90 00 lui	at,0x9000
[1985] 0x900000001fc0aabc:  60 22 00 00 daddi	v0,at,0
[1985] 0x900000001fc0aac0:  3c 03 1f c2 lui	v1,0x1fc2
[1985] 0x900000001fc0aac4:  de 01 00 00 ld	at,0(s0)
[1985] 0x900000001fc0aac8:  60 64 9b 40 daddi	a0,v1,-25792
[1985] 0x900000001fc0aacc:  00 02 18 3c dsll32	v1,v0,0
[1985] 0x900000001fc0aad0:  de 02 00 08 ld	v0,8(s0)
[1985] 0x900000001fc0aad4:  00 20 c8 25 move	t9,at
[1985] 0x900000001fc0aad8:  00 22 08 2b sltu	at,at,v0
[1985] 0x900000001fc0aadc:  ff b1 00 20 sd	s1,32(sp)
[1985] 0x900000001fc0aae0:  10 20 00 09 beq	at,zero,0x900000001fc0ab08
[1985] 0x900000001fc0aae4:  00 64 88 2c dadd	s1,v1,a0
 1986: 	*ptr = 0;
[1986] 0x900000001fc0aae8:  af 20 00 00 sw	zero,0(t9)
[1985] 0x900000001fc0aaec:  8e 05 00 14 lw	a1,20(s0)
[1985] 0x900000001fc0aaf0:  00 05 28 b8 dsll	a1,a1,2
[1985] 0x900000001fc0aaf4:  03 25 c8 2d daddu	t9,t9,a1
[1985] 0x900000001fc0aaf8:  de 05 00 08 ld	a1,8(s0)
[1985] 0x900000001fc0aafc:  03 25 28 2b sltu	a1,t9,a1
[1985] 0x900000001fc0ab00:  14 a0 ff f9 bne	a1,zero,0x900000001fc0aae8
[1985] 0x900000001fc0ab04:  00 00 00 21 nada
 1987: 	
 1988:     loprintf(".");
[1988] 0x900000001fc0ab08:  ff bf 00 30 sd	ra,48(sp)
[1988] 0x900000001fc0ab0c:  0f f0 2c e3 jal		loprintf
[1988] 0x900000001fc0ab10:  66 24 1c 97 daddiu	a0,s1,7319
 1989: 
 1990:     /* from lomem to himem read and verify 0's, then
 1991:      * write -1's
 1992:      */
 1993:     fail |= rw_loop(addr, 0U, 0xffffffffU);
[1993] 0x900000001fc0ab14:  24 06 ff ff li	a2,-1
[1993] 0x900000001fc0ab18:  00 00 28 25 move	a1,zero
[1993] 0x900000001fc0ab1c:  0f f0 2a 37 jal		rw_loop
[1993] 0x900000001fc0ab20:  02 00 20 25 move	a0,s0
[1993] 0x900000001fc0ab24:  00 40 c8 25 move	t9,v0
 1994: 
 1995:     if (fail)
[1995] 0x900000001fc0ab28:  17 20 00 38 bne	t9,zero,0x900000001fc0ac0c
[1995] 0x900000001fc0ab2c:  03 20 50 25 move	a6,t9
 1996: 	return fail;
 1997: 
 1998:     loprintf(".");
[1998] 0x900000001fc0ab30:  ff b9 00 00 sd	t9,0(sp)
[1998] 0x900000001fc0ab34:  0f f0 2c e3 jal		loprintf
[1998] 0x900000001fc0ab38:  66 24 1c 99 daddiu	a0,s1,7321
 1999: 
 2000:     /* from lomem to himem read and verify 1's, then
 2001:      * write 0x5a5a5a5a
 2002:      */
 2003: 
 2004:     fail |= rw_loop(addr, 0xffffffffU, 0x5a5a5a5aU);
[2004] 0x900000001fc0ab3c:  24 05 ff ff li	a1,-1
[2004] 0x900000001fc0ab40:  02 00 20 25 move	a0,s0
[2004] 0x900000001fc0ab44:  3c 07 5a 5a lui	a3,0x5a5a
[2004] 0x900000001fc0ab48:  0f f0 2a 37 jal		rw_loop
[2004] 0x900000001fc0ab4c:  34 e6 5a 5a ori	a2,a3,0x5a5a
[2004] 0x900000001fc0ab50:  df a7 00 00 ld	a3,0(sp)
[2004] 0x900000001fc0ab54:  00 e2 58 25 or	a7,a3,v0
 2005: 
 2006:     if (fail)
[2006] 0x900000001fc0ab58:  15 60 00 2c bne	a7,zero,0x900000001fc0ac0c
[2006] 0x900000001fc0ab5c:  01 60 50 25 move	a6,a7
 2007: 	return fail;
 2008: 
 2009:     loprintf(".");
[2009] 0x900000001fc0ab60:  ff ab 00 08 sd	a7,8(sp)
[2009] 0x900000001fc0ab64:  0f f0 2c e3 jal		loprintf
[2009] 0x900000001fc0ab68:  66 24 1c 9b daddiu	a0,s1,7323
 2010: 
 2011:     /* from lomem to himem read and verify 0x5a5a5a5a's, then
 2012:      * write 0x55555555
 2013:      */
 2014: 
 2015:     fail |= rw_loop(addr, 0x5a5a5a5aU, 0x55555555U);
[2015] 0x900000001fc0ab6c:  3c 08 55 55 lui	a4,0x5555
[2015] 0x900000001fc0ab70:  02 00 20 25 move	a0,s0
[2015] 0x900000001fc0ab74:  35 06 55 55 ori	a2,a4,0x5555
[2015] 0x900000001fc0ab78:  3c 08 5a 5a lui	a4,0x5a5a
[2015] 0x900000001fc0ab7c:  0f f0 2a 37 jal		rw_loop
[2015] 0x900000001fc0ab80:  35 05 5a 5a ori	a1,a4,0x5a5a
[2015] 0x900000001fc0ab84:  df a8 00 08 ld	a4,8(sp)
[2015] 0x900000001fc0ab88:  01 02 c8 25 or	t9,a4,v0
 2016: 
 2017:     if (fail)
[2017] 0x900000001fc0ab8c:  17 20 00 1f bne	t9,zero,0x900000001fc0ac0c
[2017] 0x900000001fc0ab90:  03 20 50 25 move	a6,t9
 2018: 	return fail;
 2019: 
 2020:     loprintf(".");
[2020] 0x900000001fc0ab94:  ff b9 00 10 sd	t9,16(sp)
[2020] 0x900000001fc0ab98:  0f f0 2c e3 jal		loprintf
[2020] 0x900000001fc0ab9c:  66 24 1c 9d daddiu	a0,s1,7325
 2021: 
 2022:     /* from lomem to himem read and verify 0x55555555, then
 2023:      * write 0xaaaaaaaa
 2024:      */
 2025:     fail |= rw_loop(addr, 0x55555555U, 0xaaaaaaaaU);
[2025] 0x900000001fc0aba0:  3c 09 aa aa lui	a5,0xaaaa
[2025] 0x900000001fc0aba4:  02 00 20 25 move	a0,s0
[2025] 0x900000001fc0aba8:  35 26 aa aa ori	a2,a5,0xaaaa
[2025] 0x900000001fc0abac:  3c 09 55 55 lui	a5,0x5555
[2025] 0x900000001fc0abb0:  0f f0 2a 37 jal		rw_loop
[2025] 0x900000001fc0abb4:  35 25 55 55 ori	a1,a5,0x5555
[2025] 0x900000001fc0abb8:  df a9 00 10 ld	a5,16(sp)
[2025] 0x900000001fc0abbc:  01 22 58 25 or	a7,a5,v0
 2026: 
 2027:     if (fail)
[2027] 0x900000001fc0abc0:  15 60 00 12 bne	a7,zero,0x900000001fc0ac0c
[2027] 0x900000001fc0abc4:  01 60 50 25 move	a6,a7
 2028: 	return fail;
 2029: 
 2030:     loprintf(".");
[2030] 0x900000001fc0abc8:  ff ab 00 18 sd	a7,24(sp)
[2030] 0x900000001fc0abcc:  0f f0 2c e3 jal		loprintf
[2030] 0x900000001fc0abd0:  66 24 1c 9f daddiu	a0,s1,7327
 2031: 
 2032:     /* from lomem to himem read and verify 0xaaaaaaaa, then
 2033:      * write 0x00000000
 2034:      */
 2035:     fail |= rw_loop(addr, 0xaaaaaaaaU, 0);
[2035] 0x900000001fc0abd4:  00 00 30 25 move	a2,zero
[2035] 0x900000001fc0abd8:  02 00 20 25 move	a0,s0
[2035] 0x900000001fc0abdc:  3c 0a aa aa lui	a6,0xaaaa
[2035] 0x900000001fc0abe0:  0f f0 2a 37 jal		rw_loop
[2035] 0x900000001fc0abe4:  35 45 aa aa ori	a1,a6,0xaaaa
[2035] 0x900000001fc0abe8:  df aa 00 18 ld	a6,24(sp)
[2035] 0x900000001fc0abec:  01 42 50 25 or	a6,a6,v0
 2036: 
 2037:     if (fail)
[2037] 0x900000001fc0abf0:  55 40 00 07 bnel	a6,zero,0x900000001fc0ac10
[2037] 0x900000001fc0abf4:  df b1 00 20 ld	s1,32(sp)
 2038: 	return fail;
 2039: 
 2040:     loprintf(".");
[2040] 0x900000001fc0abf8:  0f f0 2c e3 jal		loprintf
[2040] 0x900000001fc0abfc:  66 24 1c a1 daddiu	a0,s1,7329
 2041: 
 2042:     return 0;
[2042] 0x900000001fc0ac00:  00 00 50 25 move	a6,zero
[2042] 0x900000001fc0ac04:  10 00 00 02 b		0x900000001fc0ac10
[2042] 0x900000001fc0ac08:  df b1 00 20 ld	s1,32(sp)
[1996] 0x900000001fc0ac0c:  df b1 00 20 ld	s1,32(sp)
[1996] 0x900000001fc0ac10:  df bf 00 30 ld	ra,48(sp)
[1996] 0x900000001fc0ac14:  01 40 10 25 move	v0,a6
[1996] 0x900000001fc0ac18:  df b0 00 28 ld	s0,40(sp)
[1996] 0x900000001fc0ac1c:  03 e0 00 08 jr	ra
[1996] 0x900000001fc0ac20:  67 bd 00 40 daddiu	sp,sp,64
 2043: }
 2044: 
 2045: /*
 2046:  * Error handling routines when running with stack on the 1st level cache
 2047:  */
 2048: void pon_memerror(void)
 2049: {
pon_memerror:
[2049] 0x900000001fc0ac24:  67 bd ff d0 daddiu	sp,sp,-48
[2049] 0x900000001fc0ac28:  ff b2 00 10 sd	s2,16(sp)
[2049] 0x900000001fc0ac2c:  24 12 00 79 li	s2,121
[2049] 0x900000001fc0ac30:  3c 01 90 00 lui	at,0x9000
[2049] 0x900000001fc0ac34:  ff b3 00 08 sd	s3,8(sp)
[2049] 0x900000001fc0ac38:  24 13 00 6e li	s3,110
[2049] 0x900000001fc0ac3c:  60 25 00 00 daddi	a1,at,0
[2049] 0x900000001fc0ac40:  3c 02 90 00 lui	v0,0x9000
[2049] 0x900000001fc0ac44:  3c 01 90 00 lui	at,0x9000
[2049] 0x900000001fc0ac48:  60 43 00 00 daddi	v1,v0,0
[2049] 0x900000001fc0ac4c:  60 21 00 00 daddi	at,at,0
[2049] 0x900000001fc0ac50:  3c 04 1f c2 lui	a0,0x1fc2
[2049] 0x900000001fc0ac54:  3c 02 1f c2 lui	v0,0x1fc2
[2049] 0x900000001fc0ac58:  60 86 9b 40 daddi	a2,a0,-25792
[2049] 0x900000001fc0ac5c:  60 44 b7 e8 daddi	a0,v0,-18456
[2049] 0x900000001fc0ac60:  3c 02 1f c2 lui	v0,0x1fc2
[2049] 0x900000001fc0ac64:  00 05 28 3c dsll32	a1,a1,0
[2049] 0x900000001fc0ac68:  ff bf 00 28 sd	ra,40(sp)
[2049] 0x900000001fc0ac6c:  60 42 b8 00 daddi	v0,v0,-18432
[2049] 0x900000001fc0ac70:  00 03 18 3c dsll32	v1,v1,0
[2049] 0x900000001fc0ac74:  ff b4 00 00 sd	s4,0(sp)
[2049] 0x900000001fc0ac78:  00 01 08 3c dsll32	at,at,0
[2049] 0x900000001fc0ac7c:  00 a6 a0 2c dadd	s4,a1,a2
[2049] 0x900000001fc0ac80:  ff b0 00 20 sd	s0,32(sp)
[2049] 0x900000001fc0ac84:  00 64 80 2c dadd	s0,v1,a0
[2049] 0x900000001fc0ac88:  ff b1 00 18 sd	s1,24(sp)
[2049] 0x900000001fc0ac8c:  00 22 88 2c dadd	s1,at,v0
 2050:     int c;
 2051: 
 2052:  err_loop:
 2053:     loprintf("\nContinue test?\n");
[2053] 0x900000001fc0ac90:  0f f0 2c e3 jal		loprintf
[2053] 0x900000001fc0ac94:  02 00 20 25 move	a0,s0
 2054:     loprintf("(y = continue test, n = reinvoke POD mode)");
[2054] 0x900000001fc0ac98:  0f f0 2c e3 jal		loprintf
[2054] 0x900000001fc0ac9c:  02 20 20 25 move	a0,s1
 2055: 
 2056:     while((c = pod_poll()) == 0)
[2056] 0x900000001fc0aca0:  0f f0 15 23 jal		pod_poll
[2056] 0x900000001fc0aca4:  00 00 00 21 nada
[2056] 0x900000001fc0aca8:  14 40 00 05 bne	v0,zero,0x900000001fc0acc0
[2056] 0x900000001fc0acac:  00 00 00 21 nada
[2056] 0x900000001fc0acb0:  0f f0 15 23 jal		pod_poll
[2056] 0x900000001fc0acb4:  00 00 00 21 nada
[2056] 0x900000001fc0acb8:  10 40 ff fd beq	v0,zero,0x900000001fc0acb0
[2056] 0x900000001fc0acbc:  00 00 00 21 nada
 2057: 	;
 2058:     c = pod_getc();
[2058] 0x900000001fc0acc0:  0f f0 15 0b jal		pod_getc
[2058] 0x900000001fc0acc4:  00 00 00 21 nada
[2058] 0x900000001fc0acc8:  30 59 00 ff andi	t9,v0,0xff
 2059:     if( c == 'y' ) {
[2059] 0x900000001fc0accc:  53 32 00 0c beql	t9,s2,0x900000001fc0ad00
[2059] 0x900000001fc0acd0:  df b2 00 10 ld	s2,16(sp)
 2060: 	loprintf("\n");
 2061: 	return;
 2062:     } else if( c == 'n' ) {
[2062] 0x900000001fc0acd4:  17 33 ff ee bne	t9,s3,0x900000001fc0ac90
[2062] 0x900000001fc0acd8:  00 00 00 21 nada
[2062] 0x900000001fc0acdc:  df b2 00 10 ld	s2,16(sp)
[2062] 0x900000001fc0ace0:  df b1 00 18 ld	s1,24(sp)
 2063: 	loprintf("\n");
[2063] 0x900000001fc0ace4:  0f f0 2c e3 jal		loprintf
[2063] 0x900000001fc0ace8:  66 84 1c ed daddiu	a0,s4,7405
 2064: 	run_incache();
[2064] 0x900000001fc0acec:  0f f0 16 9b jal		run_incache
[2064] 0x900000001fc0acf0:  00 00 00 21 nada
[2064] 0x900000001fc0acf4:  10 00 00 06 b		0x900000001fc0ad10
[2064] 0x900000001fc0acf8:  df b4 00 00 ld	s4,0(sp)
[2064] 0x900000001fc0acfc:  df b2 00 10 ld	s2,16(sp)
[2064] 0x900000001fc0ad00:  df b1 00 18 ld	s1,24(sp)
[2060] 0x900000001fc0ad04:  0f f0 2c e3 jal		loprintf
[2060] 0x900000001fc0ad08:  66 84 1c eb daddiu	a0,s4,7403
[2061] 0x900000001fc0ad0c:  df b4 00 00 ld	s4,0(sp)
[2061] 0x900000001fc0ad10:  df bf 00 28 ld	ra,40(sp)
[2061] 0x900000001fc0ad14:  df b0 00 20 ld	s0,32(sp)
[2061] 0x900000001fc0ad18:  df b3 00 08 ld	s3,8(sp)
[2061] 0x900000001fc0ad1c:  03 e0 00 08 jr	ra
[2061] 0x900000001fc0ad20:  67 bd 00 30 daddiu	sp,sp,48
 2065:     } else {
 2066: 	goto err_loop;
 2067:     }
 2068: }
 2069: 
 2070: /*
 2071:  * Version of sload for downloading code via RS232
 2072:  * Assume RS232 port has been initialized
 2073:  */
 2074: 
 2075: #define	ACK	0x6
 2076: #define	NAK	0x15
 2077: 
 2078: #define DIGIT(c)	((c)>'9'?((c)>='a'?(c)-'a':(c)-'A')+10:(c)-'0')
 2079: 
 2080: int jump_addr(__psunsigned_t address, uint parm1, uint parm2,
 2081: 	      struct flag_struct *flags)
 2082: {
jump_addr:
[2082] 0x900000001fc0ad24:  3c 08 90 00 lui	a4,0x9000
[2082] 0x900000001fc0ad28:  67 bd ff 30 daddiu	sp,sp,-208
[2082] 0x900000001fc0ad2c:  3c 09 1f c2 lui	a5,0x1fc2
[2082] 0x900000001fc0ad30:  ff a4 00 00 sd	a0,0(sp)
[2082] 0x900000001fc0ad34:  ff a5 00 08 sd	a1,8(sp)
[2082] 0x900000001fc0ad38:  df a5 00 00 ld	a1,0(sp)
 2083:     uint ret_val;
 2084:     int sregs[40];	/* 9 sregs, ra * 2 ints + one spare for alignment */
 2085: 
 2086:     if (!flags->silent)
[2086] 0x900000001fc0ad3c:  ff a6 00 10 sd	a2,16(sp)
[2086] 0x900000001fc0ad40:  90 e1 00 17 lbu	at,23(a3)
[2086] 0x900000001fc0ad44:  ff bf 00 28 sd	ra,40(sp)
[2086] 0x900000001fc0ad48:  14 20 00 06 bne	at,zero,0x900000001fc0ad64
[2086] 0x900000001fc0ad4c:  ff a7 00 18 sd	a3,24(sp)
 2087: 	loprintf("Jumping to %x\n", address);
[2087] 0x900000001fc0ad50:  61 08 00 00 daddi	a4,a4,0
[2087] 0x900000001fc0ad54:  61 29 b8 30 daddi	a5,a5,-18384
[2087] 0x900000001fc0ad58:  00 08 40 3c dsll32	a4,a4,0
[2087] 0x900000001fc0ad5c:  0f f0 2c e3 jal		loprintf
[2087] 0x900000001fc0ad60:  01 09 20 2c dadd	a0,a4,a5
 2088: 
 2089:     save_sregs(sregs);
[2089] 0x900000001fc0ad64:  0f f0 0e 08 jal		save_sregs
[2089] 0x900000001fc0ad68:  67 a4 00 30 daddiu	a0,sp,48
 2090: 
 2091:     /* Jump to the address passing the appropriate parameters.
 2092:      * If flags->mem is one, flush and invalidate the caches first.
 2093:      */
 2094:     ret_val = pod_jump(address, parm1, parm2, flags->mem);
[2094] 0x900000001fc0ad6c:  df a6 00 10 ld	a2,16(sp)
[2094] 0x900000001fc0ad70:  df aa 00 18 ld	a6,24(sp)
[2094] 0x900000001fc0ad74:  df a5 00 08 ld	a1,8(sp)
[2094] 0x900000001fc0ad78:  df a4 00 00 ld	a0,0(sp)
[2094] 0x900000001fc0ad7c:  0f f0 0d d6 jal		pod_jump
[2094] 0x900000001fc0ad80:  8d 47 00 00 lw	a3,0(a6)
[2094] 0x900000001fc0ad84:  ff a2 00 20 sd	v0,32(sp)
 2095: 
 2096:     restore_sregs(sregs);
[2096] 0x900000001fc0ad88:  0f f0 0e 16 jal		restore_sregs
[2096] 0x900000001fc0ad8c:  67 a4 00 30 daddiu	a0,sp,48
[2096] 0x900000001fc0ad90:  df bf 00 28 ld	ra,40(sp)
[2096] 0x900000001fc0ad94:  df a2 00 20 ld	v0,32(sp)
 2097:     return ret_val;
[2097] 0x900000001fc0ad98:  03 e0 00 08 jr	ra
[2097] 0x900000001fc0ad9c:  67 bd 00 d0 daddiu	sp,sp,208
 2098: }
 2099: 
 2100: int 
 2101: call_asm(uint (*function)(__scunsigned_t), __scunsigned_t parm) 
 2102: {
call_asm:
[2102] 0x900000001fc0ada0:  67 bd ff 50 daddiu	sp,sp,-176
 2103: 
 2104:     int sregs[40];	/* 9 sregs, ra * 2 ints + one spare for alignment */
 2105:     int result;
 2106: 
 2107:     result = save_and_call(sregs, function, parm);
[2107] 0x900000001fc0ada4:  00 a0 30 25 move	a2,a1
[2107] 0x900000001fc0ada8:  00 80 28 25 move	a1,a0
[2107] 0x900000001fc0adac:  ff bf 00 00 sd	ra,0(sp)
[2107] 0x900000001fc0adb0:  0f f0 0d ea jal		save_and_call
[2107] 0x900000001fc0adb4:  67 a4 00 10 daddiu	a0,sp,16
 2108: 
 2109:     return result;
[2109] 0x900000001fc0adb8:  df bf 00 00 ld	ra,0(sp)
[2109] 0x900000001fc0adbc:  03 e0 00 08 jr	ra
[2109] 0x900000001fc0adc0:  67 bd 00 b0 daddiu	sp,sp,176
 2110: }
 2111: 
 2112: /* Write to the Everest System Reset register. */
 2113: 
 2114: void reset_system()
 2115: {
 2116:     SD_LO(EV_KZRESET, 0);
reset_system:
[2116] 0x900000001fc0adc4:  3c 01 90 00 lui	at,0x9000
[2116] 0x900000001fc0adc8:  60 21 00 00 daddi	at,at,0
[2116] 0x900000001fc0adcc:  3c 02 1f c2 lui	v0,0x1fc2
[2116] 0x900000001fc0add0:  60 42 9b 40 daddi	v0,v0,-25792
[2116] 0x900000001fc0add4:  00 01 08 3c dsll32	at,at,0
[2116] 0x900000001fc0add8:  00 22 08 2c dadd	at,at,v0
[2116] 0x900000001fc0addc:  dc 21 1d 00 ld	at,7424(at)
 2117: }
[2117] 0x900000001fc0ade0:  03 e0 00 08 jr	ra
[2117] 0x900000001fc0ade4:  fc 20 00 00 sd	zero,0(at)
 2118: 
 2119: 
 2120: void zap_inventory()
 2121: {
zap_inventory:
[2121] 0x900000001fc0ade8:  67 bd ff f0 daddiu	sp,sp,-16
 2122: 
 2123:     if (!nvram_okay()) {
[2123] 0x900000001fc0adec:  ff bf 00 00 sd	ra,0(sp)
[2123] 0x900000001fc0adf0:  0f f0 30 ed jal		nvram_okay
[2123] 0x900000001fc0adf4:  00 00 00 21 nada
[2123] 0x900000001fc0adf8:  3c 06 90 00 lui	a2,0x9000
[2123] 0x900000001fc0adfc:  00 00 28 25 move	a1,zero
[2123] 0x900000001fc0ae00:  50 40 00 0b beql	v0,zero,0x900000001fc0ae30
[2123] 0x900000001fc0ae04:  3c 07 1f c2 lui	a3,0x1fc2
 2124: 	loprintf("NVRAM inventory is already invalid.\n");
 2125: 	return;
 2126:     }
 2127:     set_nvreg(NVOFF_INVENT_VALID, 0);
[2127] 0x900000001fc0ae08:  0f f0 30 29 jal		set_nvreg
[2127] 0x900000001fc0ae0c:  24 04 01 14 li	a0,276
 2128:     set_nvreg(NVOFF_NEW_CHECKSUM, nvchecksum());
[2128] 0x900000001fc0ae10:  0f f0 30 6f jal		nvchecksum
[2128] 0x900000001fc0ae14:  00 00 00 21 nada
[2128] 0x900000001fc0ae18:  00 40 28 25 move	a1,v0
[2128] 0x900000001fc0ae1c:  0f f0 30 29 jal		set_nvreg
[2128] 0x900000001fc0ae20:  24 04 03 68 li	a0,872
 2129: }
[2129] 0x900000001fc0ae24:  10 00 00 08 b		0x900000001fc0ae48
[2129] 0x900000001fc0ae28:  df bf 00 00 ld	ra,0(sp)
[2124] 0x900000001fc0ae2c:  3c 07 1f c2 lui	a3,0x1fc2
[2124] 0x900000001fc0ae30:  60 c6 00 00 daddi	a2,a2,0
[2124] 0x900000001fc0ae34:  60 e7 b8 48 daddi	a3,a3,-18360
[2124] 0x900000001fc0ae38:  00 06 30 3c dsll32	a2,a2,0
[2124] 0x900000001fc0ae3c:  0f f0 2c e3 jal		loprintf
[2124] 0x900000001fc0ae40:  00 c7 20 2c dadd	a0,a2,a3
[2125] 0x900000001fc0ae44:  df bf 00 00 ld	ra,0(sp)
[2125] 0x900000001fc0ae48:  03 e0 00 08 jr	ra
[2125] 0x900000001fc0ae4c:  67 bd 00 10 daddiu	sp,sp,16
 2130: 
 2131: int
 2132: testScacheFlipBits(__uint64_t p, int stopOnError)
 2133: {
testScacheFlipBits:
[2133] 0x900000001fc0ae50:  67 bd ff 30 daddiu	sp,sp,-208
 2134:     cacheop_t	cop;
 2135:     __uint64_t	a;
 2136:     __uint32_t	taghi, taglo, ecc;
 2137:     int		way, offset;
 2138: 
 2139: #   define 	TAGHI_MASK	(CTS_TAGHI_MASK & (__uint32_t)(~CTS_MRU>>32))
 2140: #   define	TAGLO_MASK	CTS_TAGLO_MASK
 2141: 
 2142:     /* First check tags */
 2143: 
 2144:     taghi = (__uint32_t)(p >> 32) & TAGHI_MASK;
[2144] 0x900000001fc0ae54:  ff b1 00 b0 sd	s1,176(sp)
[2144] 0x900000001fc0ae58:  00 04 88 3e dsrl32	s1,a0,0
 2145:     taglo = (__uint32_t)p & TAGLO_MASK;
[2145] 0x900000001fc0ae5c:  ff b0 00 b8 sd	s0,184(sp)
[2145] 0x900000001fc0ae60:  00 04 80 00 sll	s0,a0,0
[2145] 0x900000001fc0ae64:  ff bf 00 c0 sd	ra,192(sp)
[2145] 0x900000001fc0ae68:  0f f0 05 80 jal		sCacheSize
[2145] 0x900000001fc0ae6c:  ff a5 00 18 sd	a1,24(sp)
[2145] 0x900000001fc0ae70:  3c 01 90 00 lui	at,0x9000
[2145] 0x900000001fc0ae74:  ff b7 00 80 sd	s7,128(sp)
[2145] 0x900000001fc0ae78:  60 21 00 00 daddi	at,at,0
[2145] 0x900000001fc0ae7c:  00 11 20 00 sll	a0,s1,0
[2145] 0x900000001fc0ae80:  ff b4 00 98 sd	s4,152(sp)
[2145] 0x900000001fc0ae84:  32 34 00 0f andi	s4,s1,0xf
[2145] 0x900000001fc0ae88:  00 40 18 25 move	v1,v0
[2145] 0x900000001fc0ae8c:  ff b6 00 88 sd	s6,136(sp)
[2145] 0x900000001fc0ae90:  3c 02 1f c2 lui	v0,0x1fc2
[2145] 0x900000001fc0ae94:  00 01 08 3c dsll32	at,at,0
[2145] 0x900000001fc0ae98:  ff b5 00 90 sd	s5,144(sp)
[2145] 0x900000001fc0ae9c:  60 42 9b 40 daddi	v0,v0,-25792
[2145] 0x900000001fc0aea0:  24 05 cd ff li	a1,-12801
[2145] 0x900000001fc0aea4:  ff b3 00 a0 sd	s3,160(sp)
[2145] 0x900000001fc0aea8:  00 22 10 2c dadd	v0,at,v0
[2145] 0x900000001fc0aeac:  ff a4 00 20 sd	a0,32(sp)
[2145] 0x900000001fc0aeb0:  24 61 00 01 addiu	at,v1,1
[2145] 0x900000001fc0aeb4:  00 60 20 2a slt	a0,v1,zero
[2145] 0x900000001fc0aeb8:  02 05 a8 24 and	s5,s0,a1
[2145] 0x900000001fc0aebc:  ff b0 00 28 sd	s0,40(sp)
[2145] 0x900000001fc0aec0:  00 64 08 0a movz	at,v1,a0
[2145] 0x900000001fc0aec4:  00 00 00 21 nada
[2145] 0x900000001fc0aec8:  00 00 00 21 nada
[2145] 0x900000001fc0aecc:  00 00 00 21 nada
[2145] 0x900000001fc0aed0:  67 b7 00 00 daddiu	s7,sp,0
[2145] 0x900000001fc0aed4:  ff b2 00 a8 sd	s2,168(sp)
[2145] 0x900000001fc0aed8:  02 e0 20 25 move	a0,s7
[2145] 0x900000001fc0aedc:  00 01 08 43 sra	at,at,1
[2145] 0x900000001fc0aee0:  ff a2 00 38 sd	v0,56(sp)
[2145] 0x900000001fc0aee4:  dc 42 0e e8 ld	v0,3816(v0)
 2146: 
 2147:     for (a =0; a < sCacheSize() / 2; a += CACHE_SLINE_SIZE) {
[2147] 0x900000001fc0aee8:  00 02 88 2f dsubu	s1,zero,v0
[2147] 0x900000001fc0aeec:  ff be 00 78 sd	s8,120(sp)
[2147] 0x900000001fc0aef0:  10 20 00 23 beq	at,zero,0x900000001fc0af80
[2147] 0x900000001fc0aef4:  ff a0 00 30 sd	zero,48(sp)
 2148: 	for (way = 0; way <= 1; way++) {
[2148] 0x900000001fc0aef8:  66 30 00 02 daddiu	s0,s1,2
 2149: 	    cop.cop_address 	= K0BASE + a + way;
 2150: 	    cop.cop_operation	= C_IST+CACH_S;
 2151: 	    cop.cop_taghi	= taghi;
 2152: 	    cop.cop_taglo	= taglo;
 2153: 	    cacheOP(&cop);
[2153] 0x900000001fc0aefc:  af b5 00 10 sw	s5,16(sp)
[2151] 0x900000001fc0af00:  ff b1 00 00 sd	s1,0(sp)
[2151] 0x900000001fc0af04:  02 80 90 25 move	s2,s4
[2151] 0x900000001fc0af08:  af b2 00 0c sw	s2,12(sp)
[2151] 0x900000001fc0af0c:  24 12 00 0b li	s2,11
[2151] 0x900000001fc0af10:  0f f0 0c 1c jal		cacheOP
[2151] 0x900000001fc0af14:  af b2 00 08 sw	s2,8(sp)
[2148] 0x900000001fc0af18:  66 31 00 01 daddiu	s1,s1,1
[2148] 0x900000001fc0af1c:  16 30 ff f7 bne	s1,s0,0x900000001fc0aefc
[2148] 0x900000001fc0af20:  02 e0 20 25 move	a0,s7
 2154: 	}
 2155: 	taghi = ~taghi & TAGHI_MASK;
[2155] 0x900000001fc0af24:  0f f0 05 80 jal		sCacheSize
[2155] 0x900000001fc0af28:  02 80 a0 27 nor	s4,s4,zero
[2155] 0x900000001fc0af2c:  02 e0 20 25 move	a0,s7
[2155] 0x900000001fc0af30:  df b3 00 30 ld	s3,48(sp)
 2156: 	taglo = ~taglo & TAGLO_MASK;
[2156] 0x900000001fc0af34:  02 a0 a8 27 nor	s5,s5,zero
[2156] 0x900000001fc0af38:  66 73 00 80 daddiu	s3,s3,128
[2156] 0x900000001fc0af3c:  24 56 00 01 addiu	s6,v0,1
[2156] 0x900000001fc0af40:  df b9 00 38 ld	t9,56(sp)
[2156] 0x900000001fc0af44:  00 40 c0 2a slt	t8,v0,zero
[2156] 0x900000001fc0af48:  32 94 00 0f andi	s4,s4,0xf
[2156] 0x900000001fc0af4c:  00 58 b0 0a movz	s6,v0,t8
[2156] 0x900000001fc0af50:  00 00 00 21 nada
[2156] 0x900000001fc0af54:  00 00 00 21 nada
[2156] 0x900000001fc0af58:  00 00 00 21 nada
[2156] 0x900000001fc0af5c:  24 1e cd ff li	s8,-12801
[2156] 0x900000001fc0af60:  df 39 0e e8 ld	t9,3816(t9)
[2156] 0x900000001fc0af64:  00 16 b0 43 sra	s6,s6,1
[2156] 0x900000001fc0af68:  02 79 88 2f dsubu	s1,s3,t9
[2156] 0x900000001fc0af6c:  ff b3 00 30 sd	s3,48(sp)
[2156] 0x900000001fc0af70:  02 76 98 2b sltu	s3,s3,s6
[2156] 0x900000001fc0af74:  02 be a8 24 and	s5,s5,s8
[2156] 0x900000001fc0af78:  56 60 ff e0 bnel	s3,zero,0x900000001fc0aefc
[2156] 0x900000001fc0af7c:  66 30 00 02 daddiu	s0,s1,2
 2157:     }
 2158: 
 2159:     for (a = 0; a < sCacheSize() / 2; a += CACHE_SLINE_SIZE) {
[2159] 0x900000001fc0af80:  0f f0 05 80 jal		sCacheSize
[2159] 0x900000001fc0af84:  00 00 00 21 nada
[2159] 0x900000001fc0af88:  df a5 00 38 ld	a1,56(sp)
[2159] 0x900000001fc0af8c:  64 a4 1d 68 daddiu	a0,a1,7528
[2159] 0x900000001fc0af90:  24 5f 00 01 addiu	ra,v0,1
[2159] 0x900000001fc0af94:  00 40 08 2a slt	at,v0,zero
[2159] 0x900000001fc0af98:  ff a0 00 30 sd	zero,48(sp)
[2159] 0x900000001fc0af9c:  64 a3 1d 78 daddiu	v1,a1,7544
[2159] 0x900000001fc0afa0:  00 41 f8 0a movz	ra,v0,at
[2159] 0x900000001fc0afa4:  00 00 00 21 nada
[2159] 0x900000001fc0afa8:  00 00 00 21 nada
[2159] 0x900000001fc0afac:  00 00 00 21 nada
[2159] 0x900000001fc0afb0:  64 b3 1d 30 daddiu	s3,a1,7472
[2159] 0x900000001fc0afb4:  ff a4 00 40 sd	a0,64(sp)
[2159] 0x900000001fc0afb8:  df a4 00 38 ld	a0,56(sp)
[2159] 0x900000001fc0afbc:  ff a3 00 48 sd	v1,72(sp)
[2159] 0x900000001fc0afc0:  df a3 00 30 ld	v1,48(sp)
[2159] 0x900000001fc0afc4:  00 1f f8 43 sra	ra,ra,1
[2159] 0x900000001fc0afc8:  64 be 1d 58 daddiu	s8,a1,7512
[2159] 0x900000001fc0afcc:  53 e0 00 48 beql	ra,zero,0x900000001fc0b0f0
[2159] 0x900000001fc0afd0:  df b4 00 20 ld	s4,32(sp)
[2159] 0x900000001fc0afd4:  00 14 08 3c dsll32	at,s4,0
[2159] 0x900000001fc0afd8:  00 01 08 3e dsrl32	at,at,0
 2160: 	for (way = 0; way <= 1; way++) {
[2160] 0x900000001fc0afdc:  00 15 10 3c dsll32	v0,s5,0
[2160] 0x900000001fc0afe0:  00 00 80 25 move	s0,zero
[2160] 0x900000001fc0afe4:  00 02 10 3e dsrl32	v0,v0,0
[2160] 0x900000001fc0afe8:  dc 84 0e e8 ld	a0,3816(a0)
[2160] 0x900000001fc0afec:  00 01 08 3c dsll32	at,at,0
[2160] 0x900000001fc0aff0:  00 64 88 2f dsubu	s1,v1,a0
[2160] 0x900000001fc0aff4:  00 22 b0 2d daddu	s6,at,v0
[2160] 0x900000001fc0aff8:  66 32 00 02 daddiu	s2,s1,2
[2160] 0x900000001fc0affc:  02 e0 20 25 move	a0,s7
 2161: 	    cop.cop_address = K0BASE + a + way;
 2162: 	    cop.cop_operation	= C_ILT+CACH_S;
 2163: 	    cacheOP(&cop);
[2163] 0x900000001fc0b000:  ff b1 00 00 sd	s1,0(sp)
[2163] 0x900000001fc0b004:  24 05 00 07 li	a1,7
[2163] 0x900000001fc0b008:  0f f0 0c 1c jal		cacheOP
[2163] 0x900000001fc0b00c:  af a5 00 08 sw	a1,8(sp)
[2163] 0x900000001fc0b010:  8f b9 00 10 lw	t9,16(sp)
[2163] 0x900000001fc0b014:  8f a5 00 0c lw	a1,12(sp)
 2164: 	    if ((cop.cop_taghi != taghi) || (cop.cop_taglo != taglo)) {
[2164] 0x900000001fc0b018:  56 85 00 04 bnel	s4,a1,0x900000001fc0b02c
[2164] 0x900000001fc0b01c:  02 00 28 25 move	a1,s0
[2162] 0x900000001fc0b020:  52 b9 00 18 beql	s5,t9,0x900000001fc0b084
[2162] 0x900000001fc0b024:  26 10 00 01 addiu	s0,s0,1
 2165: 		loprintf(" 2ndry tag compare error: Way %d:", way);
[2165] 0x900000001fc0b028:  02 00 28 25 move	a1,s0
[2165] 0x900000001fc0b02c:  0f f0 2c e3 jal		loprintf
[2165] 0x900000001fc0b030:  02 60 20 25 move	a0,s3
 2166: 		loprintf(" address: 0x%x\n", a);
[2166] 0x900000001fc0b034:  df a5 00 30 ld	a1,48(sp)
[2166] 0x900000001fc0b038:  0f f0 2c e3 jal		loprintf
[2166] 0x900000001fc0b03c:  03 c0 20 25 move	a0,s8
 2167: 		loprintf("\twrote: 0x%x\n", 
[2167] 0x900000001fc0b040:  02 c0 28 25 move	a1,s6
[2167] 0x900000001fc0b044:  0f f0 2c e3 jal		loprintf
[2167] 0x900000001fc0b048:  df a4 00 40 ld	a0,64(sp)
[2167] 0x900000001fc0b04c:  8f a6 00 0c lw	a2,12(sp)
 2168: 			 ((__uint64_t)taghi << 32) + taglo);
 2169: 		loprintf("\tread : 0x%x\n", 
[2169] 0x900000001fc0b050:  00 06 30 3c dsll32	a2,a2,0
[2169] 0x900000001fc0b054:  8f a7 00 10 lw	a3,16(sp)
[2169] 0x900000001fc0b058:  00 07 38 3c dsll32	a3,a3,0
[2169] 0x900000001fc0b05c:  00 06 30 3e dsrl32	a2,a2,0
[2169] 0x900000001fc0b060:  00 07 38 3e dsrl32	a3,a3,0
[2169] 0x900000001fc0b064:  df a4 00 48 ld	a0,72(sp)
[2169] 0x900000001fc0b068:  00 06 30 3c dsll32	a2,a2,0
[2169] 0x900000001fc0b06c:  0f f0 2c e3 jal		loprintf
[2169] 0x900000001fc0b070:  00 c7 28 2d daddu	a1,a2,a3
 2170: 			 ((__uint64_t)cop.cop_taghi << 32) + cop.cop_taglo);
 2171: 		if (stopOnError) {
[2171] 0x900000001fc0b074:  df a6 00 18 ld	a2,24(sp)
[2171] 0x900000001fc0b078:  54 c0 00 b8 bnel	a2,zero,0x900000001fc0b35c
[2171] 0x900000001fc0b07c:  24 02 00 01 li	v0,1
[2171] 0x900000001fc0b080:  26 10 00 01 addiu	s0,s0,1
[2160] 0x900000001fc0b084:  66 31 00 01 daddiu	s1,s1,1
[2160] 0x900000001fc0b088:  56 32 ff dd bnel	s1,s2,0x900000001fc0b000
[2160] 0x900000001fc0b08c:  02 e0 20 25 move	a0,s7
[2159] 0x900000001fc0b090:  0f f0 05 80 jal		sCacheSize
[2159] 0x900000001fc0b094:  00 00 00 21 nada
 2172: 		    return(1);
 2173: 		}
 2174: 	    }
 2175: 	}
 2176: 	taghi = ~taghi & TAGHI_MASK;
[2176] 0x900000001fc0b098:  df a4 00 38 ld	a0,56(sp)
[2176] 0x900000001fc0b09c:  02 80 60 27 nor	t0,s4,zero
 2177: 	taglo = ~taglo & TAGLO_MASK;
[2177] 0x900000001fc0b0a0:  02 a0 58 27 nor	a7,s5,zero
[2159] 0x900000001fc0b0a4:  df a8 00 30 ld	a4,48(sp)
[2159] 0x900000001fc0b0a8:  24 49 00 01 addiu	a5,v0,1
[2159] 0x900000001fc0b0ac:  00 40 50 2a slt	a6,v0,zero
[2159] 0x900000001fc0b0b0:  65 08 00 80 daddiu	a4,a4,128
[2159] 0x900000001fc0b0b4:  00 4a 48 0a movz	a5,v0,a6
[2159] 0x900000001fc0b0b8:  00 00 00 21 nada
[2159] 0x900000001fc0b0bc:  00 00 00 21 nada
[2159] 0x900000001fc0b0c0:  00 00 00 21 nada
[2159] 0x900000001fc0b0c4:  31 94 00 0f andi	s4,t0,0xf
[2159] 0x900000001fc0b0c8:  00 09 48 43 sra	a5,a5,1
[2159] 0x900000001fc0b0cc:  24 0c cd ff li	t0,-12801
[2159] 0x900000001fc0b0d0:  ff a8 00 30 sd	a4,48(sp)
[2159] 0x900000001fc0b0d4:  df a3 00 30 ld	v1,48(sp)
[2159] 0x900000001fc0b0d8:  01 09 40 2b sltu	a4,a4,a5
[2159] 0x900000001fc0b0dc:  00 14 08 3c dsll32	at,s4,0
[2159] 0x900000001fc0b0e0:  01 6c a8 24 and	s5,a7,t0
[2159] 0x900000001fc0b0e4:  55 00 ff bd bnel	a4,zero,0x900000001fc0afdc
[2159] 0x900000001fc0b0e8:  00 01 08 3e dsrl32	at,at,0
 2178:     }
 2179: 
 2180:     /* Now the data */
 2181: 
 2182:     taghi = (__uint32_t)(p >> 32);
[2182] 0x900000001fc0b0ec:  df b4 00 20 ld	s4,32(sp)
 2183:     taglo = (__uint32_t)p;
 2184:     ecc   = (__uint32_t)p;
 2185: 
 2186:     for (offset = 0; offset <= 8; offset += 8) {
[2186] 0x900000001fc0b0f0:  ff a0 00 50 sd	zero,80(sp)
[2183] 0x900000001fc0b0f4:  df b1 00 38 ld	s1,56(sp)
[2183] 0x900000001fc0b0f8:  df b5 00 28 ld	s5,40(sp)
[2183] 0x900000001fc0b0fc:  24 10 00 08 li	s0,8
[2183] 0x900000001fc0b100:  66 2f 1d b0 daddiu	t3,s1,7600
[2183] 0x900000001fc0b104:  ff b0 00 70 sd	s0,112(sp)
[2183] 0x900000001fc0b108:  66 2e 1d c0 daddiu	t2,s1,7616
[2183] 0x900000001fc0b10c:  ff af 00 58 sd	t3,88(sp)
[2183] 0x900000001fc0b110:  66 2d 1d e0 daddiu	t1,s1,7648
[2183] 0x900000001fc0b114:  ff ae 00 60 sd	t2,96(sp)
[2184] 0x900000001fc0b118:  02 a0 98 25 move	s3,s5
[2184] 0x900000001fc0b11c:  66 3e 1d 88 daddiu	s8,s1,7560
[2184] 0x900000001fc0b120:  ff ad 00 68 sd	t1,104(sp)
 2187: 
 2188: 	for (a = offset; a < sCacheSize() / 2; a += 16) {
[2188] 0x900000001fc0b124:  0f f0 05 80 jal		sCacheSize
[2188] 0x900000001fc0b128:  00 00 00 21 nada
[2188] 0x900000001fc0b12c:  24 52 00 01 addiu	s2,v0,1
[2188] 0x900000001fc0b130:  00 40 b0 2a slt	s6,v0,zero
[2188] 0x900000001fc0b134:  00 56 90 0a movz	s2,v0,s6
[2188] 0x900000001fc0b138:  00 00 00 21 nada
[2188] 0x900000001fc0b13c:  00 00 00 21 nada
[2188] 0x900000001fc0b140:  00 00 00 21 nada
[2188] 0x900000001fc0b144:  00 12 b0 43 sra	s6,s2,1
[2188] 0x900000001fc0b148:  df b2 00 50 ld	s2,80(sp)
[2188] 0x900000001fc0b14c:  02 56 b0 2b sltu	s6,s2,s6
[2188] 0x900000001fc0b150:  12 c0 00 26 beq	s6,zero,0x900000001fc0b1ec
[2188] 0x900000001fc0b154:  ff b2 00 30 sd	s2,48(sp)
[2188] 0x900000001fc0b158:  02 60 f8 25 move	ra,s3
 2189: 	    for (way = 0; way <= 1; way++) {
[2189] 0x900000001fc0b15c:  df b9 00 38 ld	t9,56(sp)
[2189] 0x900000001fc0b160:  df b8 00 30 ld	t8,48(sp)
[2189] 0x900000001fc0b164:  df 39 0e e8 ld	t9,3816(t9)
[2189] 0x900000001fc0b168:  03 19 88 2f dsubu	s1,t8,t9
[2189] 0x900000001fc0b16c:  66 30 00 02 daddiu	s0,s1,2
 2190: 		cop.cop_address 	= K0BASE + a + way;
 2191: 		cop.cop_operation	= C_ISD+CACH_S;
 2192: 		cop.cop_taghi	= taghi;
 2193: 		cop.cop_taglo	= taglo;
 2194: 		cop.cop_ecc		= ecc;
 2195: 		cacheOP(&cop);
[2195] 0x900000001fc0b170:  af b5 00 10 sw	s5,16(sp)
[2194] 0x900000001fc0b174:  ff b1 00 00 sd	s1,0(sp)
[2192] 0x900000001fc0b178:  02 e0 20 25 move	a0,s7
[2192] 0x900000001fc0b17c:  af bf 00 14 sw	ra,20(sp)
[2192] 0x900000001fc0b180:  02 80 f8 25 move	ra,s4
[2192] 0x900000001fc0b184:  af bf 00 0c sw	ra,12(sp)
[2192] 0x900000001fc0b188:  24 01 00 1f li	at,31
[2192] 0x900000001fc0b18c:  0f f0 0c 1c jal		cacheOP
[2192] 0x900000001fc0b190:  af a1 00 08 sw	at,8(sp)
[2189] 0x900000001fc0b194:  66 31 00 01 daddiu	s1,s1,1
[2189] 0x900000001fc0b198:  16 30 ff f5 bne	s1,s0,0x900000001fc0b170
[2189] 0x900000001fc0b19c:  02 60 f8 25 move	ra,s3
[2188] 0x900000001fc0b1a0:  0f f0 05 80 jal		sCacheSize
[2188] 0x900000001fc0b1a4:  00 00 00 21 nada
 2196: 	    }
 2197: 	    taghi = ~taghi;
 2198: 	    taglo = ~taglo;
 2199: 	    ecc   = ~ecc & CTS_ECC_MASK;
[2199] 0x900000001fc0b1a8:  02 60 28 27 nor	a1,s3,zero
[2199] 0x900000001fc0b1ac:  00 40 18 25 move	v1,v0
[2199] 0x900000001fc0b1b0:  24 62 00 01 addiu	v0,v1,1
[2199] 0x900000001fc0b1b4:  00 60 20 2a slt	a0,v1,zero
[2197] 0x900000001fc0b1b8:  02 80 a0 27 nor	s4,s4,zero
[2197] 0x900000001fc0b1bc:  df a1 00 30 ld	at,48(sp)
[2197] 0x900000001fc0b1c0:  00 64 10 0a movz	v0,v1,a0
[2197] 0x900000001fc0b1c4:  00 00 00 21 nada
[2197] 0x900000001fc0b1c8:  00 00 00 21 nada
[2197] 0x900000001fc0b1cc:  00 00 00 21 nada
[2197] 0x900000001fc0b1d0:  64 21 00 10 daddiu	at,at,16
[2197] 0x900000001fc0b1d4:  00 02 10 43 sra	v0,v0,1
[2198] 0x900000001fc0b1d8:  ff a1 00 30 sd	at,48(sp)
[2198] 0x900000001fc0b1dc:  00 22 08 2b sltu	at,at,v0
[2198] 0x900000001fc0b1e0:  30 b3 00 7f andi	s3,a1,0x7f
[2198] 0x900000001fc0b1e4:  14 20 ff dc bne	at,zero,0x900000001fc0b158
[2198] 0x900000001fc0b1e8:  02 a0 a8 27 nor	s5,s5,zero
 2200: 	}
 2201: 
 2202: 	for (a = offset; a < sCacheSize() / 2; a += 16) {
[2202] 0x900000001fc0b1ec:  0f f0 05 80 jal		sCacheSize
[2202] 0x900000001fc0b1f0:  00 00 00 21 nada
[2202] 0x900000001fc0b1f4:  24 46 00 01 addiu	a2,v0,1
[2202] 0x900000001fc0b1f8:  00 40 38 2a slt	a3,v0,zero
[2202] 0x900000001fc0b1fc:  00 47 30 0a movz	a2,v0,a3
[2202] 0x900000001fc0b200:  00 00 00 21 nada
[2202] 0x900000001fc0b204:  00 00 00 21 nada
[2202] 0x900000001fc0b208:  00 00 00 21 nada
[2202] 0x900000001fc0b20c:  00 06 30 43 sra	a2,a2,1
[2202] 0x900000001fc0b210:  02 46 30 2b sltu	a2,s2,a2
[2202] 0x900000001fc0b214:  ff b2 00 30 sd	s2,48(sp)
[2202] 0x900000001fc0b218:  50 c0 00 46 beql	a2,zero,0x900000001fc0b334
[2202] 0x900000001fc0b21c:  df b6 00 50 ld	s6,80(sp)
 2203: 	    for (way = 0; way <= 1; way++) {
[2203] 0x900000001fc0b220:  00 14 40 3c dsll32	a4,s4,0
[2203] 0x900000001fc0b224:  00 08 40 3e dsrl32	a4,a4,0
[2203] 0x900000001fc0b228:  df ab 00 38 ld	a7,56(sp)
[2203] 0x900000001fc0b22c:  00 15 48 3c dsll32	a5,s5,0
[2203] 0x900000001fc0b230:  00 00 80 25 move	s0,zero
[2203] 0x900000001fc0b234:  00 09 48 3e dsrl32	a5,a5,0
[2203] 0x900000001fc0b238:  df aa 00 30 ld	a6,48(sp)
[2203] 0x900000001fc0b23c:  dd 6b 0e e8 ld	a7,3816(a7)
[2203] 0x900000001fc0b240:  00 08 40 3c dsll32	a4,a4,0
[2203] 0x900000001fc0b244:  01 4b 88 2f dsubu	s1,a6,a7
[2203] 0x900000001fc0b248:  01 09 b0 2d daddu	s6,a4,a5
[2203] 0x900000001fc0b24c:  66 32 00 02 daddiu	s2,s1,2
[2203] 0x900000001fc0b250:  02 e0 20 25 move	a0,s7
 2204: 		cop.cop_address = K0BASE + a + way;
 2205: 		cop.cop_operation= C_ILD+CACH_S;
 2206: 		cacheOP(&cop);
[2206] 0x900000001fc0b254:  ff b1 00 00 sd	s1,0(sp)
[2206] 0x900000001fc0b258:  24 0c 00 1b li	t0,27
[2206] 0x900000001fc0b25c:  0f f0 0c 1c jal		cacheOP
[2206] 0x900000001fc0b260:  af ac 00 08 sw	t0,8(sp)
[2206] 0x900000001fc0b264:  8f b9 00 10 lw	t9,16(sp)
[2206] 0x900000001fc0b268:  8f ac 00 0c lw	t0,12(sp)
 2207: 		if ((cop.cop_taghi != taghi) || (cop.cop_taglo != taglo)) {
[2207] 0x900000001fc0b26c:  56 8c 00 04 bnel	s4,t0,0x900000001fc0b280
[2207] 0x900000001fc0b270:  02 00 28 25 move	a1,s0
[2205] 0x900000001fc0b274:  52 b9 00 1a beql	s5,t9,0x900000001fc0b2e0
[2205] 0x900000001fc0b278:  26 10 00 01 addiu	s0,s0,1
 2208: 		    loprintf(" 2ndry data compare error: Way %d:", way);
[2208] 0x900000001fc0b27c:  02 00 28 25 move	a1,s0
[2208] 0x900000001fc0b280:  0f f0 2c e3 jal		loprintf
[2208] 0x900000001fc0b284:  03 c0 20 25 move	a0,s8
 2209: 		    loprintf(" address: 0x%x\n", a);
[2209] 0x900000001fc0b288:  df a5 00 30 ld	a1,48(sp)
[2209] 0x900000001fc0b28c:  0f f0 2c e3 jal		loprintf
[2209] 0x900000001fc0b290:  df a4 00 58 ld	a0,88(sp)
 2210: 		    loprintf("\twrote(data/ecc): 0x%x/0x%x\n", 
[2210] 0x900000001fc0b294:  02 60 30 25 move	a2,s3
[2210] 0x900000001fc0b298:  02 c0 28 25 move	a1,s6
[2210] 0x900000001fc0b29c:  0f f0 2c e3 jal		loprintf
[2210] 0x900000001fc0b2a0:  df a4 00 60 ld	a0,96(sp)
[2210] 0x900000001fc0b2a4:  8f ad 00 0c lw	t1,12(sp)
 2211: 			     ((__uint64_t)taghi << 32) + taglo, ecc);
 2212: 		    loprintf("\tread (data/ecc): 0x%x/0x%x\n", 
[2212] 0x900000001fc0b2a8:  00 0d 68 3c dsll32	t1,t1,0
[2212] 0x900000001fc0b2ac:  8f ae 00 10 lw	t2,16(sp)
[2212] 0x900000001fc0b2b0:  00 0e 70 3c dsll32	t2,t2,0
[2212] 0x900000001fc0b2b4:  00 0d 68 3e dsrl32	t1,t1,0
[2212] 0x900000001fc0b2b8:  00 0e 70 3e dsrl32	t2,t2,0
[2212] 0x900000001fc0b2bc:  8f a6 00 14 lw	a2,20(sp)
[2212] 0x900000001fc0b2c0:  df a4 00 68 ld	a0,104(sp)
[2212] 0x900000001fc0b2c4:  00 0d 68 3c dsll32	t1,t1,0
[2212] 0x900000001fc0b2c8:  0f f0 2c e3 jal		loprintf
[2212] 0x900000001fc0b2cc:  01 ae 28 2d daddu	a1,t1,t2
 2213: 			     ((__uint64_t)cop.cop_taghi << 32) + cop.cop_taglo, 
 2214: 			     cop.cop_ecc);
 2215: 		    if (stopOnError) {
[2215] 0x900000001fc0b2d0:  df ad 00 18 ld	t1,24(sp)
[2215] 0x900000001fc0b2d4:  15 a0 00 1e bne	t1,zero,0x900000001fc0b350
[2215] 0x900000001fc0b2d8:  00 00 00 21 nada
[2215] 0x900000001fc0b2dc:  26 10 00 01 addiu	s0,s0,1
[2203] 0x900000001fc0b2e0:  66 31 00 01 daddiu	s1,s1,1
[2203] 0x900000001fc0b2e4:  56 32 ff db bnel	s1,s2,0x900000001fc0b254
[2203] 0x900000001fc0b2e8:  02 e0 20 25 move	a0,s7
 2216: 			return(1);
 2217: 		    }
 2218: 		}
 2219: 	    }
 2220: 	    ecc   = ~ecc & CTS_ECC_MASK;
[2220] 0x900000001fc0b2ec:  0f f0 05 80 jal		sCacheSize
[2220] 0x900000001fc0b2f0:  02 60 90 27 nor	s2,s3,zero
[2220] 0x900000001fc0b2f4:  24 50 00 01 addiu	s0,v0,1
[2220] 0x900000001fc0b2f8:  00 40 88 2a slt	s1,v0,zero
 2221: 	    taghi = ~taghi;
[2221] 0x900000001fc0b2fc:  02 80 a0 27 nor	s4,s4,zero
[2221] 0x900000001fc0b300:  df af 00 30 ld	t3,48(sp)
[2221] 0x900000001fc0b304:  00 51 80 0a movz	s0,v0,s1
[2221] 0x900000001fc0b308:  00 00 00 21 nada
[2221] 0x900000001fc0b30c:  00 00 00 21 nada
[2221] 0x900000001fc0b310:  00 00 00 21 nada
[2221] 0x900000001fc0b314:  65 ef 00 10 daddiu	t3,t3,16
[2221] 0x900000001fc0b318:  00 10 80 43 sra	s0,s0,1
 2222: 	    taglo = ~taglo;
[2222] 0x900000001fc0b31c:  ff af 00 30 sd	t3,48(sp)
[2222] 0x900000001fc0b320:  01 f0 78 2b sltu	t3,t3,s0
[2222] 0x900000001fc0b324:  32 53 00 7f andi	s3,s2,0x7f
[2222] 0x900000001fc0b328:  15 e0 ff bd bne	t3,zero,0x900000001fc0b220
[2222] 0x900000001fc0b32c:  02 a0 a8 27 nor	s5,s5,zero
[2186] 0x900000001fc0b330:  df b6 00 50 ld	s6,80(sp)
[2186] 0x900000001fc0b334:  26 d8 00 08 addiu	t8,s6,8
[2186] 0x900000001fc0b338:  df b6 00 70 ld	s6,112(sp)
[2186] 0x900000001fc0b33c:  02 d8 b0 2a slt	s6,s6,t8
[2186] 0x900000001fc0b340:  12 c0 ff 78 beq	s6,zero,0x900000001fc0b124
[2186] 0x900000001fc0b344:  ff b8 00 50 sd	t8,80(sp)
 2223: 	}
 2224:     }
 2225:     return(0);
[2225] 0x900000001fc0b348:  10 00 00 04 b		0x900000001fc0b35c
[2225] 0x900000001fc0b34c:  00 00 10 25 move	v0,zero
[2216] 0x900000001fc0b350:  10 00 00 02 b		0x900000001fc0b35c
[2216] 0x900000001fc0b354:  24 02 00 01 li	v0,1
[2172] 0x900000001fc0b358:  24 02 00 01 li	v0,1
[2172] 0x900000001fc0b35c:  df b1 00 b0 ld	s1,176(sp)
[2172] 0x900000001fc0b360:  df b3 00 a0 ld	s3,160(sp)
[2172] 0x900000001fc0b364:  df b5 00 90 ld	s5,144(sp)
[2172] 0x900000001fc0b368:  df be 00 78 ld	s8,120(sp)
[2172] 0x900000001fc0b36c:  df bf 00 c0 ld	ra,192(sp)
[2172] 0x900000001fc0b370:  df b6 00 88 ld	s6,136(sp)
[2172] 0x900000001fc0b374:  df b4 00 98 ld	s4,152(sp)
[2172] 0x900000001fc0b378:  df b2 00 a8 ld	s2,168(sp)
[2172] 0x900000001fc0b37c:  df b0 00 b8 ld	s0,184(sp)
[2172] 0x900000001fc0b380:  df b7 00 80 ld	s7,128(sp)
[2172] 0x900000001fc0b384:  03 e0 00 08 jr	ra
[2172] 0x900000001fc0b388:  67 bd 00 d0 daddiu	sp,sp,208
Skipping source listing to line 35 of /cores/banyan/stand/arcs/IP25prom/pod_io.c...
   36: void loprf(void (*putc)(char), char *, va_list);
   37: void lo_sprintn(char *, __scunsigned_t, int, int);
   38: int *logets(int *, int);
   39: void loprintf(char *, ...);
   40: void loputs(void (*putc)(char), char *, int);
   41: void loputchar(char);
   42: 
   43: /*VARARGS1*/
   44: void loprintf(char *fmt, ...)
   45: {
loprintf:
[  45] 0x900000001fc0b38c:  67 bd ff b0 daddiu	sp,sp,-80
[  45] 0x900000001fc0b390:  ff a4 00 10 sd	a0,16(sp)
[  45] 0x900000001fc0b394:  ff a5 00 18 sd	a1,24(sp)
[  45] 0x900000001fc0b398:  ff a6 00 20 sd	a2,32(sp)
   46: 	va_list ap;
   47: 
   48: 	va_start(ap, fmt);
   49: 	loprf(loputchar, fmt, ap);
[  49] 0x900000001fc0b39c:  3c 01 90 00 lui	at,0x9000
[  49] 0x900000001fc0b3a0:  ff a7 00 28 sd	a3,40(sp)
[  49] 0x900000001fc0b3a4:  60 21 00 00 daddi	at,at,0
[  49] 0x900000001fc0b3a8:  3c 02 1f c2 lui	v0,0x1fc2
[  49] 0x900000001fc0b3ac:  ff a8 00 30 sd	a4,48(sp)
[  49] 0x900000001fc0b3b0:  60 42 b9 50 daddi	v0,v0,-18096
[  49] 0x900000001fc0b3b4:  00 01 08 3c dsll32	at,at,0
[  49] 0x900000001fc0b3b8:  ff a9 00 38 sd	a5,56(sp)
[  48] 0x900000001fc0b3bc:  ff aa 00 40 sd	a6,64(sp)
[  48] 0x900000001fc0b3c0:  67 a6 00 18 daddiu	a2,sp,24
[  48] 0x900000001fc0b3c4:  00 22 08 2c dadd	at,at,v0
[  48] 0x900000001fc0b3c8:  ff ab 00 48 sd	a7,72(sp)
[  48] 0x900000001fc0b3cc:  00 80 28 25 move	a1,a0
[  48] 0x900000001fc0b3d0:  ff bf 00 00 sd	ra,0(sp)
[  48] 0x900000001fc0b3d4:  0f f0 2d 38 jal		loprf
[  48] 0x900000001fc0b3d8:  dc 24 00 00 ld	a0,0(at)
   50: 	va_end(ap);
   51: }
[  51] 0x900000001fc0b3dc:  df bf 00 00 ld	ra,0(sp)
[  51] 0x900000001fc0b3e0:  03 e0 00 08 jr	ra
[  51] 0x900000001fc0b3e4:  67 bd 00 50 daddiu	sp,sp,80
   52: 
   53: /*VARARGS1*/
   54: void ccloprintf(char *fmt, ...)
   55: {
ccloprintf:
[  55] 0x900000001fc0b3e8:  67 bd ff b0 daddiu	sp,sp,-80
[  55] 0x900000001fc0b3ec:  ff a4 00 10 sd	a0,16(sp)
[  55] 0x900000001fc0b3f0:  ff a5 00 18 sd	a1,24(sp)
[  55] 0x900000001fc0b3f4:  ff a6 00 20 sd	a2,32(sp)
[  55] 0x900000001fc0b3f8:  ff a7 00 28 sd	a3,40(sp)
[  55] 0x900000001fc0b3fc:  ff a8 00 30 sd	a4,48(sp)
[  55] 0x900000001fc0b400:  ff a9 00 38 sd	a5,56(sp)
   56: 	va_list ap;
   57: 
   58: 	if (!(get_BSR() & BSR_MANUMODE))
[  58] 0x900000001fc0b404:  ff aa 00 40 sd	a6,64(sp)
[  58] 0x900000001fc0b408:  ff bf 00 00 sd	ra,0(sp)
[  58] 0x900000001fc0b40c:  0f f0 0d 97 jal		get_BSR
[  58] 0x900000001fc0b410:  ff ab 00 48 sd	a7,72(sp)
[  58] 0x900000001fc0b414:  df a5 00 10 ld	a1,16(sp)
[  58] 0x900000001fc0b418:  3c 04 1f c2 lui	a0,0x1fc2
[  58] 0x900000001fc0b41c:  30 41 00 40 andi	at,v0,0x40
[  58] 0x900000001fc0b420:  50 20 00 0a beql	at,zero,0x900000001fc0b44c
[  58] 0x900000001fc0b424:  df bf 00 00 ld	ra,0(sp)
   59: 		return;
   60: 
   61: 	va_start(ap, fmt);
   62: 	loprf(loputchar, fmt, ap);
[  62] 0x900000001fc0b428:  3c 03 90 00 lui	v1,0x9000
[  62] 0x900000001fc0b42c:  60 63 00 00 daddi	v1,v1,0
[  62] 0x900000001fc0b430:  60 84 b9 50 daddi	a0,a0,-18096
[  62] 0x900000001fc0b434:  00 03 18 3c dsll32	v1,v1,0
[  62] 0x900000001fc0b438:  00 64 18 2c dadd	v1,v1,a0
[  62] 0x900000001fc0b43c:  67 a6 00 18 daddiu	a2,sp,24
[  62] 0x900000001fc0b440:  0f f0 2d 38 jal		loprf
[  62] 0x900000001fc0b444:  dc 64 00 00 ld	a0,0(v1)
   63: 	va_end(ap);
   64: }
[  64] 0x900000001fc0b448:  df bf 00 00 ld	ra,0(sp)
[  64] 0x900000001fc0b44c:  03 e0 00 08 jr	ra
[  64] 0x900000001fc0b450:  67 bd 00 50 daddiu	sp,sp,80
   65: 
   66: void lostrncpy(unsigned char *dst, unsigned char *src, int n)
   67: {
lostrncpy:
[  67] 0x900000001fc0b454:  67 bd ff d0 daddiu	sp,sp,-48
[  67] 0x900000001fc0b458:  ff b3 00 00 sd	s3,0(sp)
[  67] 0x900000001fc0b45c:  00 c0 98 25 move	s3,a2
[  67] 0x900000001fc0b460:  ff b2 00 08 sd	s2,8(sp)
[  67] 0x900000001fc0b464:  00 80 90 25 move	s2,a0
[  67] 0x900000001fc0b468:  ff b0 00 18 sd	s0,24(sp)
[  67] 0x900000001fc0b46c:  00 a0 80 25 move	s0,a1
   68: 	int i;
   69: 
   70: 	for (i = 0; (i < n) && (*src != '\0'); i++)
[  70] 0x900000001fc0b470:  ff b1 00 10 sd	s1,16(sp)
[  70] 0x900000001fc0b474:  00 00 88 25 move	s1,zero
[  70] 0x900000001fc0b478:  ff bf 00 20 sd	ra,32(sp)
[  70] 0x900000001fc0b47c:  5a 60 00 11 blezl	s3,0x900000001fc0b4c4
[  70] 0x900000001fc0b480:  df b1 00 10 ld	s1,16(sp)
[  70] 0x900000001fc0b484:  92 01 00 00 lbu	at,0(s0)
[  70] 0x900000001fc0b488:  50 20 00 0e beql	at,zero,0x900000001fc0b4c4
[  70] 0x900000001fc0b48c:  df b1 00 10 ld	s1,16(sp)
   71: 		*dst++ = get_char(src++);
[  71] 0x900000001fc0b490:  0f f0 0d 88 jal		get_char
[  71] 0x900000001fc0b494:  02 00 20 25 move	a0,s0
[  71] 0x900000001fc0b498:  66 10 00 01 daddiu	s0,s0,1
[  70] 0x900000001fc0b49c:  26 31 00 01 addiu	s1,s1,1
[  70] 0x900000001fc0b4a0:  00 40 18 25 move	v1,v0
[  70] 0x900000001fc0b4a4:  02 33 10 2a slt	v0,s1,s3
[  70] 0x900000001fc0b4a8:  a2 43 00 00 sb	v1,0(s2)
[  70] 0x900000001fc0b4ac:  10 40 00 04 beq	v0,zero,0x900000001fc0b4c0
[  70] 0x900000001fc0b4b0:  66 52 00 01 daddiu	s2,s2,1
[  70] 0x900000001fc0b4b4:  92 05 00 00 lbu	a1,0(s0)
[  70] 0x900000001fc0b4b8:  14 a0 ff f5 bne	a1,zero,0x900000001fc0b490
[  70] 0x900000001fc0b4bc:  00 00 00 21 nada
[  70] 0x900000001fc0b4c0:  df b1 00 10 ld	s1,16(sp)
[  70] 0x900000001fc0b4c4:  df bf 00 20 ld	ra,32(sp)
   72: 	*dst = '\0';
[  72] 0x900000001fc0b4c8:  a2 40 00 00 sb	zero,0(s2)
[  72] 0x900000001fc0b4cc:  df b2 00 08 ld	s2,8(sp)
[  72] 0x900000001fc0b4d0:  df b0 00 18 ld	s0,24(sp)
[  72] 0x900000001fc0b4d4:  df b3 00 00 ld	s3,0(sp)
[  72] 0x900000001fc0b4d8:  03 e0 00 08 jr	ra
[  72] 0x900000001fc0b4dc:  67 bd 00 30 daddiu	sp,sp,48
   73: }
   74: 
   75: void loprf(void (*putc)(char), char *fmt, va_list adx)
   76: {
loprf:
[  76] 0x900000001fc0b4e0:  67 bd ff 50 daddiu	sp,sp,-176
[  76] 0x900000001fc0b4e4:  ff b6 00 68 sd	s6,104(sp)
[  76] 0x900000001fc0b4e8:  00 80 b0 25 move	s6,a0
[  76] 0x900000001fc0b4ec:  ff b3 00 80 sd	s3,128(sp)
[  76] 0x900000001fc0b4f0:  00 a0 98 25 move	s3,a1
   77: 	char c;
   78: 	char *s;
   79: 	int *p;
   80: 	__scint_t i;
   81: 	char prbuf[32];
   82: 	FLIPINIT(dosw, fmt);
[  82] 0x900000001fc0b4f4:  ff be 00 58 sd	s8,88(sp)
[  82] 0x900000001fc0b4f8:  00 c0 f0 25 move	s8,a2
[  82] 0x900000001fc0b4fc:  ff b4 00 78 sd	s4,120(sp)
[  82] 0x900000001fc0b500:  ff bf 00 a0 sd	ra,160(sp)
[  82] 0x900000001fc0b504:  0f f0 0d d0 jal		getendian
[  82] 0x900000001fc0b508:  00 00 a0 25 move	s4,zero
[  82] 0x900000001fc0b50c:  ff b5 00 70 sd	s5,112(sp)
[  82] 0x900000001fc0b510:  3c 01 90 00 lui	at,0x9000
[  82] 0x900000001fc0b514:  60 21 00 00 daddi	at,at,0
[  82] 0x900000001fc0b518:  3c 03 1f c2 lui	v1,0x1fc2
[  82] 0x900000001fc0b51c:  ff b2 00 88 sd	s2,136(sp)
[  82] 0x900000001fc0b520:  60 63 b9 50 daddi	v1,v1,-18096
[  82] 0x900000001fc0b524:  ff b0 00 98 sd	s0,152(sp)
[  82] 0x900000001fc0b528:  00 13 85 3a dsrl	s0,s3,20
[  82] 0x900000001fc0b52c:  24 04 00 61 li	a0,97
[  82] 0x900000001fc0b530:  ff b1 00 90 sd	s1,144(sp)
[  82] 0x900000001fc0b534:  00 01 08 3c dsll32	at,at,0
[  82] 0x900000001fc0b538:  ff a4 00 38 sd	a0,56(sp)
[  82] 0x900000001fc0b53c:  24 04 00 79 li	a0,121
[  82] 0x900000001fc0b540:  00 23 08 2c dadd	at,at,v1
[  82] 0x900000001fc0b544:  ff a1 00 30 sd	at,48(sp)
[  82] 0x900000001fc0b548:  50 40 00 0b beql	v0,zero,0x900000001fc0b578
[  82] 0x900000001fc0b54c:  df a7 00 30 ld	a3,48(sp)
[  82] 0x900000001fc0b550:  df a6 00 30 ld	a2,48(sp)
[  82] 0x900000001fc0b554:  df a5 00 30 ld	a1,48(sp)
[  82] 0x900000001fc0b558:  dc a5 00 d8 ld	a1,216(a1)
[  82] 0x900000001fc0b55c:  52 05 00 05 beql	s0,a1,0x900000001fc0b574
[  82] 0x900000001fc0b560:  24 14 00 01 li	s4,1
[  82] 0x900000001fc0b564:  dc c6 00 e0 ld	a2,224(a2)
[  82] 0x900000001fc0b568:  56 06 00 03 bnel	s0,a2,0x900000001fc0b578
[  82] 0x900000001fc0b56c:  df a7 00 30 ld	a3,48(sp)
[  82] 0x900000001fc0b570:  24 14 00 01 li	s4,1
[  82] 0x900000001fc0b574:  df a7 00 30 ld	a3,48(sp)
[  82] 0x900000001fc0b578:  ff a4 00 40 sd	a0,64(sp)
[  82] 0x900000001fc0b57c:  64 e7 fd 00 daddiu	a3,a3,-768
[  82] 0x900000001fc0b580:  ff b7 00 60 sd	s7,96(sp)
[  82] 0x900000001fc0b584:  24 15 00 39 li	s5,57
[  82] 0x900000001fc0b588:  ff a7 00 48 sd	a3,72(sp)
[  82] 0x900000001fc0b58c:  24 17 00 25 li	s7,37
[  82] 0x900000001fc0b590:  66 72 00 01 daddiu	s2,s3,1
   83: 
   84: 	for (;;) {
   85: 		while ((c = EVCFLIP(dosw, fmt++)) != '%') {
[  85] 0x900000001fc0b594:  52 80 00 06 beql	s4,zero,0x900000001fc0b5b0
[  85] 0x900000001fc0b598:  02 60 20 25 move	a0,s3
[  85] 0x900000001fc0b59c:  02 60 40 25 move	a4,s3
[  85] 0x900000001fc0b5a0:  02 40 98 25 move	s3,s2
[  85] 0x900000001fc0b5a4:  10 00 00 03 b		0x900000001fc0b5b4
[  85] 0x900000001fc0b5a8:  39 04 00 03 xori	a0,a4,0x3
[  85] 0x900000001fc0b5ac:  02 60 20 25 move	a0,s3
[  85] 0x900000001fc0b5b0:  02 40 98 25 move	s3,s2
[  85] 0x900000001fc0b5b4:  0f f0 0d 88 jal		get_char
[  85] 0x900000001fc0b5b8:  00 00 00 21 nada
[  85] 0x900000001fc0b5bc:  30 4b 00 ff andi	a7,v0,0xff
[  85] 0x900000001fc0b5c0:  51 77 00 14 beql	a7,s7,0x900000001fc0b614
[  85] 0x900000001fc0b5c4:  66 52 00 01 daddiu	s2,s2,1
   86: 		        if(c == '\0') {
[  86] 0x900000001fc0b5c8:  51 60 00 e5 beql	a7,zero,0x900000001fc0b960
[  86] 0x900000001fc0b5cc:  df b1 00 90 ld	s1,144(sp)
   87: 				return;
   88: 			}
   89: 			(*putc)(c);
[  89] 0x900000001fc0b5d0:  02 c0 f8 09 jalr	ra,s6
[  89] 0x900000001fc0b5d4:  00 40 20 25 move	a0,v0
[  85] 0x900000001fc0b5d8:  66 52 00 01 daddiu	s2,s2,1
[  85] 0x900000001fc0b5dc:  52 80 00 06 beql	s4,zero,0x900000001fc0b5f8
[  85] 0x900000001fc0b5e0:  02 60 20 25 move	a0,s3
[  85] 0x900000001fc0b5e4:  02 60 48 25 move	a5,s3
[  85] 0x900000001fc0b5e8:  02 40 98 25 move	s3,s2
[  85] 0x900000001fc0b5ec:  10 00 00 03 b		0x900000001fc0b5fc
[  85] 0x900000001fc0b5f0:  39 24 00 03 xori	a0,a5,0x3
[  85] 0x900000001fc0b5f4:  02 60 20 25 move	a0,s3
[  85] 0x900000001fc0b5f8:  02 40 98 25 move	s3,s2
[  85] 0x900000001fc0b5fc:  0f f0 0d 88 jal		get_char
[  85] 0x900000001fc0b600:  00 00 00 21 nada
[  85] 0x900000001fc0b604:  30 4b 00 ff andi	a7,v0,0xff
[  85] 0x900000001fc0b608:  15 77 ff ef bne	a7,s7,0x900000001fc0b5c8
[  85] 0x900000001fc0b60c:  00 00 00 21 nada
[  85] 0x900000001fc0b610:  66 52 00 01 daddiu	s2,s2,1
   90: 		}
   91: 
   92: 		/*
   93: 		 * Ignore 'precision' for compatibility with 'dk'.
   94: 		 */
   95: 		do {
   96: 			c = EVCFLIP(dosw, fmt++);
[  96] 0x900000001fc0b614:  52 80 00 07 beql	s4,zero,0x900000001fc0b634
[  96] 0x900000001fc0b618:  02 60 20 25 move	a0,s3
[  96] 0x900000001fc0b61c:  02 60 50 25 move	a6,s3
[  96] 0x900000001fc0b620:  02 40 98 25 move	s3,s2
[  96] 0x900000001fc0b624:  66 52 00 01 daddiu	s2,s2,1
[  96] 0x900000001fc0b628:  10 00 00 04 b		0x900000001fc0b63c
[  96] 0x900000001fc0b62c:  39 44 00 03 xori	a0,a6,0x3
[  96] 0x900000001fc0b630:  02 60 20 25 move	a0,s3
[  96] 0x900000001fc0b634:  02 40 98 25 move	s3,s2
[  96] 0x900000001fc0b638:  66 52 00 01 daddiu	s2,s2,1
[  96] 0x900000001fc0b63c:  0f f0 0d 88 jal		get_char
[  96] 0x900000001fc0b640:  00 00 00 21 nada
[  95] 0x900000001fc0b644:  30 4b 00 ff andi	a7,v0,0xff
[  95] 0x900000001fc0b648:  02 ab c8 2a slt	t9,s5,a7
[  95] 0x900000001fc0b64c:  29 6c 00 30 slti	t0,a7,48
[  95] 0x900000001fc0b650:  55 80 00 04 bnel	t0,zero,0x900000001fc0b664
[  95] 0x900000001fc0b654:  df ad 00 38 ld	t1,56(sp)
[  95] 0x900000001fc0b658:  13 20 ff ee beq	t9,zero,0x900000001fc0b614
[  95] 0x900000001fc0b65c:  00 00 00 21 nada
   97: 		} while (isdigit(c));
   98: 
   99: 		switch (c) {
[  99] 0x900000001fc0b660:  df ad 00 38 ld	t1,56(sp)
[  99] 0x900000001fc0b664:  01 6d 68 2a slt	t1,a7,t1
[  99] 0x900000001fc0b668:  15 a0 ff ca bne	t1,zero,0x900000001fc0b594
[  99] 0x900000001fc0b66c:  00 00 00 21 nada
[  99] 0x900000001fc0b670:  df ae 00 40 ld	t2,64(sp)
[  99] 0x900000001fc0b674:  01 cb 70 2a slt	t2,t2,a7
[  99] 0x900000001fc0b678:  15 c0 ff c6 bne	t2,zero,0x900000001fc0b594
[  99] 0x900000001fc0b67c:  00 00 00 21 nada
[  99] 0x900000001fc0b680:  00 0b 78 f8 dsll	t3,a7,3
[  99] 0x900000001fc0b684:  df b0 00 48 ld	s0,72(sp)
[  99] 0x900000001fc0b688:  01 f0 78 2d daddu	t3,t3,s0
[  99] 0x900000001fc0b68c:  dd ef 00 00 ld	t3,0(t3)
[  99] 0x900000001fc0b690:  01 e0 00 08 jr	t3
[  99] 0x900000001fc0b694:  00 00 00 21 nada
  100: 		case 'd':	/* Print a variable-length decimal number */
  101: 			lo_sprintn(prbuf, va_arg(adx, __scunsigned_t), 10, 0);
  102: 			loputs(putc, prbuf, 0);
  103: 			break;
  104: 		case 'a':	/* Print a two digit decimal number */
  105: 			lo_sprintn(prbuf, va_arg(adx, __scunsigned_t), 10, 2);
  106: 			loputs(putc, prbuf, 0);
  107: 			break;
  108: 		case 'h':	/* Print a hex halfword */
  109: 			lo_sprintn(prbuf, va_arg(adx, __scunsigned_t), 16, 4);
  110: 			loputs(putc, prbuf, 0);
  111: 			break;
  112: 		case 'b':	/* Print a hex byte. */
  113: 			lo_sprintn(prbuf, va_arg(adx, __scunsigned_t), 16, 2);
  114: 			loputs(putc, prbuf, 0);
  115: 			break;
  116: 		case 'l':	/* Print a variable-length hex number */
  117: 			/* Note: this supports %llx. */
  118: 			c = EVCFLIP(dosw, fmt++);
  119: 			c = EVCFLIP(dosw, fmt++);
  120: 			lo_sprintn(prbuf, va_arg(adx, __scunsigned_t), 16, 8);
  121: 			loputs(putc, prbuf, 0);
  122: 			break;
  123: 		case 'x':	/* Print a variable-length hex number */
  124: 			lo_sprintn(prbuf, va_arg(adx, __scunsigned_t), 16, 8);
  125: 			loputs(putc, prbuf, 0);
  126: 			break;
  127: 		case 'y':	/* Print a hex doubleword */
  128: 			lo_sprintn(prbuf, va_arg(adx, __scunsigned_t), 16, 16);
[ 128] 0x900000001fc0b698:  67 d1 00 07 daddiu	s1,s8,7
[ 128] 0x900000001fc0b69c:  24 07 00 10 li	a3,16
[ 128] 0x900000001fc0b6a0:  24 18 ff f8 li	t8,-8
[ 128] 0x900000001fc0b6a4:  24 06 00 10 li	a2,16
[ 128] 0x900000001fc0b6a8:  02 38 88 24 and	s1,s1,t8
[ 128] 0x900000001fc0b6ac:  67 a4 00 00 daddiu	a0,sp,0
[ 128] 0x900000001fc0b6b0:  0f f0 2e 9d jal		lo_sprintn
[ 128] 0x900000001fc0b6b4:  de 25 00 00 ld	a1,0(s1)
  129: 			loputs(putc, prbuf, 0);
[ 129] 0x900000001fc0b6b8:  00 00 30 25 move	a2,zero
[ 129] 0x900000001fc0b6bc:  67 a5 00 00 daddiu	a1,sp,0
[ 129] 0x900000001fc0b6c0:  0f f0 2e 63 jal		loputs
[ 129] 0x900000001fc0b6c4:  02 c0 20 25 move	a0,s6
  130: 			break;
[ 130] 0x900000001fc0b6c8:  10 00 ff b2 b		0x900000001fc0b594
[ 130] 0x900000001fc0b6cc:  66 3e 00 08 daddiu	s8,s1,8
[ 124] 0x900000001fc0b6d0:  67 d9 00 07 daddiu	t9,s8,7
[ 124] 0x900000001fc0b6d4:  24 07 00 08 li	a3,8
[ 124] 0x900000001fc0b6d8:  24 06 00 10 li	a2,16
[ 124] 0x900000001fc0b6dc:  24 1e ff f8 li	s8,-8
[ 124] 0x900000001fc0b6e0:  67 a4 00 00 daddiu	a0,sp,0
[ 124] 0x900000001fc0b6e4:  03 3e c8 24 and	t9,t9,s8
[ 124] 0x900000001fc0b6e8:  67 3e 00 08 daddiu	s8,t9,8
[ 124] 0x900000001fc0b6ec:  0f f0 2e 9d jal		lo_sprintn
[ 124] 0x900000001fc0b6f0:  df 25 00 00 ld	a1,0(t9)
[ 125] 0x900000001fc0b6f4:  00 00 30 25 move	a2,zero
[ 125] 0x900000001fc0b6f8:  67 a5 00 00 daddiu	a1,sp,0
[ 125] 0x900000001fc0b6fc:  0f f0 2e 63 jal		loputs
[ 125] 0x900000001fc0b700:  02 c0 20 25 move	a0,s6
[ 126] 0x900000001fc0b704:  10 00 ff a3 b		0x900000001fc0b594
[ 126] 0x900000001fc0b708:  00 00 00 21 nada
  131: 		case 's':	/* Print a string */
  132: 			s = (char *)va_arg(adx, char *);
[ 132] 0x900000001fc0b70c:  67 df 00 07 daddiu	ra,s8,7
[ 132] 0x900000001fc0b710:  24 01 ff f8 li	at,-8
[ 132] 0x900000001fc0b714:  03 e1 f0 24 and	s8,ra,at
  133: 			loputs(putc, s, getendian() && INBOOTPROM(s));
[ 133] 0x900000001fc0b718:  00 00 88 25 move	s1,zero
[ 133] 0x900000001fc0b71c:  df d0 00 00 ld	s0,0(s8)
[ 133] 0x900000001fc0b720:  0f f0 0d d0 jal		getendian
[ 133] 0x900000001fc0b724:  ff b0 00 50 sd	s0,80(sp)
[ 133] 0x900000001fc0b728:  df a1 00 30 ld	at,48(sp)
[ 133] 0x900000001fc0b72c:  df a5 00 50 ld	a1,80(sp)
[ 133] 0x900000001fc0b730:  10 40 00 09 beq	v0,zero,0x900000001fc0b758
[ 133] 0x900000001fc0b734:  00 05 85 3a dsrl	s0,a1,20
[ 133] 0x900000001fc0b738:  df a2 00 30 ld	v0,48(sp)
[ 133] 0x900000001fc0b73c:  dc 21 00 d8 ld	at,216(at)
[ 133] 0x900000001fc0b740:  52 01 00 05 beql	s0,at,0x900000001fc0b758
[ 133] 0x900000001fc0b744:  24 11 00 01 li	s1,1
[ 133] 0x900000001fc0b748:  dc 42 00 e0 ld	v0,224(v0)
[ 133] 0x900000001fc0b74c:  56 02 00 03 bnel	s0,v0,0x900000001fc0b75c
[ 133] 0x900000001fc0b750:  02 20 30 25 move	a2,s1
[ 133] 0x900000001fc0b754:  24 11 00 01 li	s1,1
[ 133] 0x900000001fc0b758:  02 20 30 25 move	a2,s1
[ 133] 0x900000001fc0b75c:  0f f0 2e 63 jal		loputs
[ 133] 0x900000001fc0b760:  02 c0 20 25 move	a0,s6
  134: 			break;
[ 134] 0x900000001fc0b764:  67 de 00 08 daddiu	s8,s8,8
[ 134] 0x900000001fc0b768:  10 00 ff 8a b		0x900000001fc0b594
[ 134] 0x900000001fc0b76c:  00 00 00 21 nada
  135: 		case 'c':	/* print a character */
  136: 			i = va_arg(adx, __scint_t);
  137: 				(*putc)((char)i);
  138: 			break;	
  139: 		case 'p':	/* print a "prom string" (in an int array) */
  140: 			p = (int *)va_arg(adx, int *);
[ 140] 0x900000001fc0b770:  67 c7 00 07 daddiu	a3,s8,7
[ 140] 0x900000001fc0b774:  24 08 ff f8 li	a4,-8
[ 140] 0x900000001fc0b778:  00 e8 38 24 and	a3,a3,a4
[ 140] 0x900000001fc0b77c:  dc f0 00 00 ld	s0,0(a3)
  141: 			while (*p != 0)
[ 141] 0x900000001fc0b780:  8e 11 00 00 lw	s1,0(s0)
[ 141] 0x900000001fc0b784:  12 20 ff 83 beq	s1,zero,0x900000001fc0b594
[ 141] 0x900000001fc0b788:  64 fe 00 08 daddiu	s8,a3,8
  142: 				(*putc)(*p++);
[ 142] 0x900000001fc0b78c:  32 24 00 ff andi	a0,s1,0xff
[ 142] 0x900000001fc0b790:  02 c0 f8 09 jalr	ra,s6
[ 142] 0x900000001fc0b794:  66 10 00 04 daddiu	s0,s0,4
[ 141] 0x900000001fc0b798:  8e 11 00 00 lw	s1,0(s0)
[ 141] 0x900000001fc0b79c:  12 20 ff 7d beq	s1,zero,0x900000001fc0b594
[ 141] 0x900000001fc0b7a0:  00 00 00 21 nada
[ 141] 0x900000001fc0b7a4:  10 00 ff f9 b		0x900000001fc0b78c
[ 141] 0x900000001fc0b7a8:  00 00 00 21 nada
[ 118] 0x900000001fc0b7ac:  52 80 00 07 beql	s4,zero,0x900000001fc0b7cc
[ 118] 0x900000001fc0b7b0:  02 60 20 25 move	a0,s3
[ 118] 0x900000001fc0b7b4:  02 60 48 25 move	a5,s3
[ 118] 0x900000001fc0b7b8:  02 40 98 25 move	s3,s2
[ 118] 0x900000001fc0b7bc:  66 52 00 01 daddiu	s2,s2,1
[ 118] 0x900000001fc0b7c0:  10 00 00 04 b		0x900000001fc0b7d4
[ 118] 0x900000001fc0b7c4:  39 24 00 03 xori	a0,a5,0x3
[ 118] 0x900000001fc0b7c8:  02 60 20 25 move	a0,s3
[ 118] 0x900000001fc0b7cc:  02 40 98 25 move	s3,s2
[ 118] 0x900000001fc0b7d0:  66 52 00 01 daddiu	s2,s2,1
[ 118] 0x900000001fc0b7d4:  0f f0 0d 88 jal		get_char
[ 118] 0x900000001fc0b7d8:  00 00 00 21 nada
[ 119] 0x900000001fc0b7dc:  02 60 20 25 move	a0,s3
[ 119] 0x900000001fc0b7e0:  02 60 50 25 move	a6,s3
[ 119] 0x900000001fc0b7e4:  52 80 00 06 beql	s4,zero,0x900000001fc0b800
[ 119] 0x900000001fc0b7e8:  02 40 98 25 move	s3,s2
[ 119] 0x900000001fc0b7ec:  02 40 98 25 move	s3,s2
[ 119] 0x900000001fc0b7f0:  66 52 00 01 daddiu	s2,s2,1
[ 119] 0x900000001fc0b7f4:  10 00 00 03 b		0x900000001fc0b804
[ 119] 0x900000001fc0b7f8:  39 44 00 03 xori	a0,a6,0x3
[ 119] 0x900000001fc0b7fc:  02 40 98 25 move	s3,s2
[ 119] 0x900000001fc0b800:  66 52 00 01 daddiu	s2,s2,1
[ 119] 0x900000001fc0b804:  0f f0 0d 88 jal		get_char
[ 119] 0x900000001fc0b808:  00 00 00 21 nada
[ 120] 0x900000001fc0b80c:  67 cb 00 07 daddiu	a7,s8,7
[ 120] 0x900000001fc0b810:  24 07 00 08 li	a3,8
[ 120] 0x900000001fc0b814:  24 06 00 10 li	a2,16
[ 120] 0x900000001fc0b818:  24 0c ff f8 li	t0,-8
[ 120] 0x900000001fc0b81c:  67 a4 00 00 daddiu	a0,sp,0
[ 120] 0x900000001fc0b820:  01 6c 88 24 and	s1,a7,t0
[ 120] 0x900000001fc0b824:  67 b0 00 00 daddiu	s0,sp,0
[ 120] 0x900000001fc0b828:  0f f0 2e 9d jal		lo_sprintn
[ 120] 0x900000001fc0b82c:  de 25 00 00 ld	a1,0(s1)
[ 121] 0x900000001fc0b830:  00 00 30 25 move	a2,zero
[ 121] 0x900000001fc0b834:  02 00 28 25 move	a1,s0
[ 121] 0x900000001fc0b838:  0f f0 2e 63 jal		loputs
[ 121] 0x900000001fc0b83c:  02 c0 20 25 move	a0,s6
[ 122] 0x900000001fc0b840:  10 00 ff 54 b		0x900000001fc0b594
[ 122] 0x900000001fc0b844:  66 3e 00 08 daddiu	s8,s1,8
[ 109] 0x900000001fc0b848:  67 d8 00 07 daddiu	t8,s8,7
[ 109] 0x900000001fc0b84c:  24 07 00 04 li	a3,4
[ 109] 0x900000001fc0b850:  24 06 00 10 li	a2,16
[ 109] 0x900000001fc0b854:  24 19 ff f8 li	t9,-8
[ 109] 0x900000001fc0b858:  67 a4 00 00 daddiu	a0,sp,0
[ 109] 0x900000001fc0b85c:  03 19 c0 24 and	t8,t8,t9
[ 109] 0x900000001fc0b860:  67 1e 00 08 daddiu	s8,t8,8
[ 109] 0x900000001fc0b864:  0f f0 2e 9d jal		lo_sprintn
[ 109] 0x900000001fc0b868:  df 05 00 00 ld	a1,0(t8)
[ 110] 0x900000001fc0b86c:  00 00 30 25 move	a2,zero
[ 110] 0x900000001fc0b870:  67 a5 00 00 daddiu	a1,sp,0
[ 110] 0x900000001fc0b874:  0f f0 2e 63 jal		loputs
[ 110] 0x900000001fc0b878:  02 c0 20 25 move	a0,s6
[ 111] 0x900000001fc0b87c:  10 00 ff 45 b		0x900000001fc0b594
[ 111] 0x900000001fc0b880:  00 00 00 21 nada
[ 101] 0x900000001fc0b884:  67 de 00 07 daddiu	s8,s8,7
[ 101] 0x900000001fc0b888:  00 00 38 25 move	a3,zero
[ 101] 0x900000001fc0b88c:  24 06 00 0a li	a2,10
[ 101] 0x900000001fc0b890:  24 1f ff f8 li	ra,-8
[ 101] 0x900000001fc0b894:  67 a4 00 00 daddiu	a0,sp,0
[ 101] 0x900000001fc0b898:  03 df 08 24 and	at,s8,ra
[ 101] 0x900000001fc0b89c:  64 3e 00 08 daddiu	s8,at,8
[ 101] 0x900000001fc0b8a0:  0f f0 2e 9d jal		lo_sprintn
[ 101] 0x900000001fc0b8a4:  dc 25 00 00 ld	a1,0(at)
[ 102] 0x900000001fc0b8a8:  00 00 30 25 move	a2,zero
[ 102] 0x900000001fc0b8ac:  67 a5 00 00 daddiu	a1,sp,0
[ 102] 0x900000001fc0b8b0:  0f f0 2e 63 jal		loputs
[ 102] 0x900000001fc0b8b4:  02 c0 20 25 move	a0,s6
[ 103] 0x900000001fc0b8b8:  10 00 ff 36 b		0x900000001fc0b594
[ 103] 0x900000001fc0b8bc:  00 00 00 21 nada
[ 136] 0x900000001fc0b8c0:  67 c1 00 07 daddiu	at,s8,7
[ 136] 0x900000001fc0b8c4:  24 02 ff f8 li	v0,-8
[ 136] 0x900000001fc0b8c8:  00 22 08 24 and	at,at,v0
[ 137] 0x900000001fc0b8cc:  64 3e 00 08 daddiu	s8,at,8
[ 137] 0x900000001fc0b8d0:  dc 21 00 00 ld	at,0(at)
[ 137] 0x900000001fc0b8d4:  02 c0 f8 09 jalr	ra,s6
[ 137] 0x900000001fc0b8d8:  30 24 00 ff andi	a0,at,0xff
[ 138] 0x900000001fc0b8dc:  10 00 ff 2d b		0x900000001fc0b594
[ 138] 0x900000001fc0b8e0:  00 00 00 21 nada
[ 113] 0x900000001fc0b8e4:  67 c5 00 07 daddiu	a1,s8,7
[ 113] 0x900000001fc0b8e8:  24 07 00 02 li	a3,2
[ 113] 0x900000001fc0b8ec:  24 06 00 10 li	a2,16
[ 113] 0x900000001fc0b8f0:  24 08 ff f8 li	a4,-8
[ 113] 0x900000001fc0b8f4:  67 a4 00 00 daddiu	a0,sp,0
[ 113] 0x900000001fc0b8f8:  00 a8 28 24 and	a1,a1,a4
[ 113] 0x900000001fc0b8fc:  64 be 00 08 daddiu	s8,a1,8
[ 113] 0x900000001fc0b900:  0f f0 2e 9d jal		lo_sprintn
[ 113] 0x900000001fc0b904:  dc a5 00 00 ld	a1,0(a1)
[ 114] 0x900000001fc0b908:  00 00 30 25 move	a2,zero
[ 114] 0x900000001fc0b90c:  67 a5 00 00 daddiu	a1,sp,0
[ 114] 0x900000001fc0b910:  0f f0 2e 63 jal		loputs
[ 114] 0x900000001fc0b914:  02 c0 20 25 move	a0,s6
[ 115] 0x900000001fc0b918:  10 00 ff 1e b		0x900000001fc0b594
[ 115] 0x900000001fc0b91c:  00 00 00 21 nada
[ 105] 0x900000001fc0b920:  67 c9 00 07 daddiu	a5,s8,7
[ 105] 0x900000001fc0b924:  24 07 00 02 li	a3,2
[ 105] 0x900000001fc0b928:  24 06 00 0a li	a2,10
[ 105] 0x900000001fc0b92c:  24 0a ff f8 li	a6,-8
[ 105] 0x900000001fc0b930:  67 a4 00 00 daddiu	a0,sp,0
[ 105] 0x900000001fc0b934:  01 2a 48 24 and	a5,a5,a6
[ 105] 0x900000001fc0b938:  65 3e 00 08 daddiu	s8,a5,8
[ 105] 0x900000001fc0b93c:  0f f0 2e 9d jal		lo_sprintn
[ 105] 0x900000001fc0b940:  dd 25 00 00 ld	a1,0(a5)
[ 106] 0x900000001fc0b944:  00 00 30 25 move	a2,zero
[ 106] 0x900000001fc0b948:  67 a5 00 00 daddiu	a1,sp,0
[ 106] 0x900000001fc0b94c:  0f f0 2e 63 jal		loputs
[ 106] 0x900000001fc0b950:  02 c0 20 25 move	a0,s6
[ 107] 0x900000001fc0b954:  10 00 ff 0f b		0x900000001fc0b594
[ 107] 0x900000001fc0b958:  00 00 00 21 nada
[ 107] 0x900000001fc0b95c:  df b1 00 90 ld	s1,144(sp)
[ 107] 0x900000001fc0b960:  df b3 00 80 ld	s3,128(sp)
[ 107] 0x900000001fc0b964:  df b5 00 70 ld	s5,112(sp)
[ 107] 0x900000001fc0b968:  df be 00 58 ld	s8,88(sp)
[ 107] 0x900000001fc0b96c:  df bf 00 a0 ld	ra,160(sp)
[ 107] 0x900000001fc0b970:  df b6 00 68 ld	s6,104(sp)
[ 107] 0x900000001fc0b974:  df b4 00 78 ld	s4,120(sp)
[ 107] 0x900000001fc0b978:  df b2 00 88 ld	s2,136(sp)
[ 107] 0x900000001fc0b97c:  df b0 00 98 ld	s0,152(sp)
[ 107] 0x900000001fc0b980:  df b7 00 60 ld	s7,96(sp)
[ 107] 0x900000001fc0b984:  03 e0 00 08 jr	ra
[ 107] 0x900000001fc0b988:  67 bd 00 b0 daddiu	sp,sp,176
  143: 			break;	
  144: 		default:
  145: 			break;
  146: 	
  147: 		}
  148: 	}
  149: }
  150: 
  151: void
  152: loputs(void (*putc)(char), char *sp, int dosw)
  153: {
loputs:
[ 153] 0x900000001fc0b98c:  67 bd ff d0 daddiu	sp,sp,-48
[ 153] 0x900000001fc0b990:  ff b1 00 10 sd	s1,16(sp)
[ 153] 0x900000001fc0b994:  00 a0 88 25 move	s1,a1
[ 153] 0x900000001fc0b998:  ff b3 00 00 sd	s3,0(sp)
[ 153] 0x900000001fc0b99c:  00 80 98 25 move	s3,a0
[ 153] 0x900000001fc0b9a0:  ff b2 00 08 sd	s2,8(sp)
[ 153] 0x900000001fc0b9a4:  00 c0 90 25 move	s2,a2
  154: 	if (sp == 0) {
[ 154] 0x900000001fc0b9a8:  ff b0 00 18 sd	s0,24(sp)
[ 154] 0x900000001fc0b9ac:  ff bf 00 20 sd	ra,32(sp)
[ 154] 0x900000001fc0b9b0:  12 20 00 1e beq	s1,zero,0x900000001fc0ba2c
[ 154] 0x900000001fc0b9b4:  02 20 80 25 move	s0,s1
  155: 		loputs(putc, "<NULL>", getendian());
  156: 		return;
  157: 	}
  158: 	while (EVCFLIP(dosw, sp))
[ 158] 0x900000001fc0b9b8:  12 40 00 02 beq	s2,zero,0x900000001fc0b9c4
[ 158] 0x900000001fc0b9bc:  00 00 00 21 nada
[ 158] 0x900000001fc0b9c0:  3a 30 00 03 xori	s0,s1,0x3
[ 158] 0x900000001fc0b9c4:  0f f0 0d 88 jal		get_char
[ 158] 0x900000001fc0b9c8:  02 00 20 25 move	a0,s0
[ 158] 0x900000001fc0b9cc:  50 40 00 23 beql	v0,zero,0x900000001fc0ba5c
[ 158] 0x900000001fc0b9d0:  df b0 00 18 ld	s0,24(sp)
  159: 		(*putc)(EVCFLIP(dosw, sp++));
[ 159] 0x900000001fc0b9d4:  12 40 00 05 beq	s2,zero,0x900000001fc0b9ec
[ 159] 0x900000001fc0b9d8:  66 30 00 01 daddiu	s0,s1,1
[ 159] 0x900000001fc0b9dc:  02 20 28 25 move	a1,s1
[ 159] 0x900000001fc0b9e0:  02 00 88 25 move	s1,s0
[ 159] 0x900000001fc0b9e4:  10 00 00 03 b		0x900000001fc0b9f4
[ 159] 0x900000001fc0b9e8:  38 a4 00 03 xori	a0,a1,0x3
[ 159] 0x900000001fc0b9ec:  02 20 20 25 move	a0,s1
[ 159] 0x900000001fc0b9f0:  02 00 88 25 move	s1,s0
[ 159] 0x900000001fc0b9f4:  0f f0 0d 88 jal		get_char
[ 159] 0x900000001fc0b9f8:  00 00 00 21 nada
[ 159] 0x900000001fc0b9fc:  02 60 f8 09 jalr	ra,s3
[ 159] 0x900000001fc0ba00:  00 40 20 25 move	a0,v0
[ 158] 0x900000001fc0ba04:  02 00 c8 25 move	t9,s0
[ 158] 0x900000001fc0ba08:  12 40 00 02 beq	s2,zero,0x900000001fc0ba14
[ 158] 0x900000001fc0ba0c:  00 00 00 21 nada
[ 158] 0x900000001fc0ba10:  3a 19 00 03 xori	t9,s0,0x3
[ 158] 0x900000001fc0ba14:  0f f0 0d 88 jal		get_char
[ 158] 0x900000001fc0ba18:  03 20 20 25 move	a0,t9
[ 158] 0x900000001fc0ba1c:  14 40 ff ed bne	v0,zero,0x900000001fc0b9d4
[ 158] 0x900000001fc0ba20:  00 00 00 21 nada
[ 158] 0x900000001fc0ba24:  10 00 00 0c b		0x900000001fc0ba58
[ 158] 0x900000001fc0ba28:  00 00 00 21 nada
[ 155] 0x900000001fc0ba2c:  0f f0 0d d0 jal		getendian
[ 155] 0x900000001fc0ba30:  00 00 00 21 nada
[ 155] 0x900000001fc0ba34:  3c 06 90 00 lui	a2,0x9000
[ 155] 0x900000001fc0ba38:  3c 07 1f c2 lui	a3,0x1fc2
[ 155] 0x900000001fc0ba3c:  60 c6 00 00 daddi	a2,a2,0
[ 155] 0x900000001fc0ba40:  60 e8 ba 38 daddi	a4,a3,-17864
[ 155] 0x900000001fc0ba44:  00 06 38 3c dsll32	a3,a2,0
[ 155] 0x900000001fc0ba48:  00 40 30 25 move	a2,v0
[ 155] 0x900000001fc0ba4c:  02 60 20 25 move	a0,s3
[ 155] 0x900000001fc0ba50:  0f f0 2e 63 jal		loputs
[ 155] 0x900000001fc0ba54:  00 e8 28 2c dadd	a1,a3,a4
[ 156] 0x900000001fc0ba58:  df b0 00 18 ld	s0,24(sp)
[ 156] 0x900000001fc0ba5c:  df b3 00 00 ld	s3,0(sp)
[ 156] 0x900000001fc0ba60:  df bf 00 20 ld	ra,32(sp)
[ 156] 0x900000001fc0ba64:  df b1 00 10 ld	s1,16(sp)
[ 156] 0x900000001fc0ba68:  df b2 00 08 ld	s2,8(sp)
[ 156] 0x900000001fc0ba6c:  03 e0 00 08 jr	ra
[ 156] 0x900000001fc0ba70:  67 bd 00 30 daddiu	sp,sp,48
  160: }
  161: 
  162: /*
  163:  * lo_sprintn -- output a number n in base b.
  164:  */
  165: 
  166: void lo_sprintn(char *tgt, __scunsigned_t n, int b, int digits)
  167: {
lo_sprintn:
[ 167] 0x900000001fc0ba74:  67 bd ff 40 daddiu	sp,sp,-192
[ 167] 0x900000001fc0ba78:  ff b7 00 20 sd	s7,32(sp)
[ 167] 0x900000001fc0ba7c:  00 80 b8 25 move	s7,a0
[ 167] 0x900000001fc0ba80:  ff b1 00 50 sd	s1,80(sp)
[ 167] 0x900000001fc0ba84:  00 a0 88 25 move	s1,a1
[ 167] 0x900000001fc0ba88:  ff b4 00 38 sd	s4,56(sp)
[ 167] 0x900000001fc0ba8c:  00 c0 a0 25 move	s4,a2
[ 167] 0x900000001fc0ba90:  ff b3 00 40 sd	s3,64(sp)
[ 167] 0x900000001fc0ba94:  00 e0 98 25 move	s3,a3
  168: 	int prbuf[18];
  169: 	register int *cp;
  170: 
  171: 	cp = prbuf;
[ 171] 0x900000001fc0ba98:  3c 02 90 00 lui	v0,0x9000
[ 171] 0x900000001fc0ba9c:  3c 01 90 00 lui	at,0x9000
[ 171] 0x900000001fc0baa0:  60 43 00 00 daddi	v1,v0,0
[ 171] 0x900000001fc0baa4:  60 21 00 00 daddi	at,at,0
[ 171] 0x900000001fc0baa8:  3c 04 1f c2 lui	a0,0x1fc2
[ 171] 0x900000001fc0baac:  ff bf 00 60 sd	ra,96(sp)
[ 171] 0x900000001fc0bab0:  3c 02 1f c2 lui	v0,0x1fc2
[ 171] 0x900000001fc0bab4:  60 84 ba 58 daddi	a0,a0,-17832
[ 171] 0x900000001fc0bab8:  ff be 00 18 sd	s8,24(sp)
[ 171] 0x900000001fc0babc:  60 42 ba 40 daddi	v0,v0,-17856
[ 171] 0x900000001fc0bac0:  67 be 00 70 daddiu	s8,sp,112
[ 171] 0x900000001fc0bac4:  ff b6 00 28 sd	s6,40(sp)
[ 171] 0x900000001fc0bac8:  00 03 18 3c dsll32	v1,v1,0
[ 171] 0x900000001fc0bacc:  ff b2 00 48 sd	s2,72(sp)
[ 171] 0x900000001fc0bad0:  67 b2 00 70 daddiu	s2,sp,112
[ 171] 0x900000001fc0bad4:  00 01 08 3c dsll32	at,at,0
[ 171] 0x900000001fc0bad8:  ff b5 00 30 sd	s5,48(sp)
[ 171] 0x900000001fc0badc:  00 64 a8 2c dadd	s5,v1,a0
[ 171] 0x900000001fc0bae0:  00 22 b0 2c dadd	s6,at,v0
[ 171] 0x900000001fc0bae4:  ff b0 00 58 sd	s0,88(sp)
  172: 	do {
  173: 		if (getendian())	/* 1 = little */
[ 173] 0x900000001fc0bae8:  0f f0 0d d0 jal		getendian
[ 173] 0x900000001fc0baec:  00 00 00 21 nada
[ 173] 0x900000001fc0baf0:  02 34 00 1f ddivu	s1,s4
[ 173] 0x900000001fc0baf4:  66 50 00 04 daddiu	s0,s2,4
[ 173] 0x900000001fc0baf8:  14 40 00 08 bne	v0,zero,0x900000001fc0bb1c
[ 173] 0x900000001fc0bafc:  00 00 08 10 mfhi	at
  174: 			*cp++ = get_char((u_char *)"32107654ba98fedc" + n%b);
  175: 		else
  176: 			*cp++ = get_char((u_char *)"0123456789abcdef" + n%b);
[ 176] 0x900000001fc0bb00:  0f f0 0d 88 jal		get_char
[ 176] 0x900000001fc0bb04:  02 a1 20 2d daddu	a0,s5,at
[ 176] 0x900000001fc0bb08:  02 34 00 1f ddivu	s1,s4
[ 176] 0x900000001fc0bb0c:  ae 42 00 00 sw	v0,0(s2)
[ 176] 0x900000001fc0bb10:  02 00 90 25 move	s2,s0
[ 176] 0x900000001fc0bb14:  10 00 00 07 b		0x900000001fc0bb34
[ 176] 0x900000001fc0bb18:  00 00 88 12 mflo	s1
[ 174] 0x900000001fc0bb1c:  0f f0 0d 88 jal		get_char
[ 174] 0x900000001fc0bb20:  02 c1 20 2d daddu	a0,s6,at
[ 174] 0x900000001fc0bb24:  02 34 00 1f ddivu	s1,s4
[ 174] 0x900000001fc0bb28:  ae 42 00 00 sw	v0,0(s2)
[ 174] 0x900000001fc0bb2c:  02 00 90 25 move	s2,s0
[ 174] 0x900000001fc0bb30:  00 00 88 12 mflo	s1
  177: 		n /= b;
  178: 		if (digits)
[ 178] 0x900000001fc0bb34:  12 60 00 02 beq	s3,zero,0x900000001fc0bb40
[ 178] 0x900000001fc0bb38:  00 00 00 21 nada
  179: 			digits--;
[ 179] 0x900000001fc0bb3c:  26 73 ff ff addiu	s3,s3,-1
[ 172] 0x900000001fc0bb40:  16 20 ff e9 bne	s1,zero,0x900000001fc0bae8
[ 172] 0x900000001fc0bb44:  00 00 00 21 nada
[ 172] 0x900000001fc0bb48:  16 60 ff e7 bne	s3,zero,0x900000001fc0bae8
[ 172] 0x900000001fc0bb4c:  00 00 00 21 nada
[ 172] 0x900000001fc0bb50:  02 e0 20 25 move	a0,s7
[ 172] 0x900000001fc0bb54:  24 05 ff fc li	a1,-4
[ 172] 0x900000001fc0bb58:  24 06 ff fc li	a2,-4
[ 172] 0x900000001fc0bb5c:  02 45 28 2d daddu	a1,s2,a1
[ 172] 0x900000001fc0bb60:  03 c6 08 2f dsubu	at,s8,a2
[ 172] 0x900000001fc0bb64:  03 c5 28 2b sltu	a1,s8,a1
[ 172] 0x900000001fc0bb68:  50 a0 00 17 beql	a1,zero,0x900000001fc0bbc8
[ 172] 0x900000001fc0bb6c:  66 52 ff fc daddiu	s2,s2,-4
[ 172] 0x900000001fc0bb70:  66 42 ff fc daddiu	v0,s2,-4
[ 172] 0x900000001fc0bb74:  8e 43 ff fc lw	v1,-4(s2)
  180: 	} while (n || digits);
  181: 	do {
  182: 		*tgt++ = (*--cp);
[ 182] 0x900000001fc0bb78:  64 46 ff fc daddiu	a2,v0,-4
[ 181] 0x900000001fc0bb7c:  a0 83 00 00 sb	v1,0(a0)
[ 181] 0x900000001fc0bb80:  64 84 00 01 daddiu	a0,a0,1
[ 181] 0x900000001fc0bb84:  00 22 28 2b sltu	a1,at,v0
[ 181] 0x900000001fc0bb88:  8c c3 00 00 lw	v1,0(a2)
[ 181] 0x900000001fc0bb8c:  10 a0 00 0a beq	a1,zero,0x900000001fc0bbb8
[ 181] 0x900000001fc0bb90:  64 c2 ff fc daddiu	v0,a2,-4
[ 181] 0x900000001fc0bb94:  a0 83 00 00 sb	v1,0(a0)
[ 181] 0x900000001fc0bb98:  64 84 00 01 daddiu	a0,a0,1
[ 181] 0x900000001fc0bb9c:  00 26 28 2b sltu	a1,at,a2
[ 181] 0x900000001fc0bba0:  8c 43 00 00 lw	v1,0(v0)
[ 181] 0x900000001fc0bba4:  14 a0 ff f5 bne	a1,zero,0x900000001fc0bb7c
[ 181] 0x900000001fc0bba8:  64 46 ff fc daddiu	a2,v0,-4
[ 181] 0x900000001fc0bbac:  a0 83 00 00 sb	v1,0(a0)
[ 181] 0x900000001fc0bbb0:  10 00 00 0a b		0x900000001fc0bbdc
[ 181] 0x900000001fc0bbb4:  64 97 00 01 daddiu	s7,a0,1
[ 181] 0x900000001fc0bbb8:  a0 83 00 00 sb	v1,0(a0)
[ 181] 0x900000001fc0bbbc:  10 00 00 07 b		0x900000001fc0bbdc
[ 181] 0x900000001fc0bbc0:  64 97 00 01 daddiu	s7,a0,1
[ 181] 0x900000001fc0bbc4:  66 52 ff fc daddiu	s2,s2,-4
[ 181] 0x900000001fc0bbc8:  8e 48 00 00 lw	a4,0(s2)
[ 181] 0x900000001fc0bbcc:  03 d2 38 2b sltu	a3,s8,s2
[ 181] 0x900000001fc0bbd0:  a2 e8 00 00 sb	a4,0(s7)
[ 181] 0x900000001fc0bbd4:  14 e0 ff fb bne	a3,zero,0x900000001fc0bbc4
[ 181] 0x900000001fc0bbd8:  66 f7 00 01 daddiu	s7,s7,1
[ 181] 0x900000001fc0bbdc:  df b0 00 58 ld	s0,88(sp)
[ 181] 0x900000001fc0bbe0:  df b2 00 48 ld	s2,72(sp)
[ 181] 0x900000001fc0bbe4:  df b4 00 38 ld	s4,56(sp)
[ 181] 0x900000001fc0bbe8:  df b6 00 28 ld	s6,40(sp)
[ 181] 0x900000001fc0bbec:  df bf 00 60 ld	ra,96(sp)
  183: 	} while (cp > prbuf);
  184: 	*tgt++ = '\0';
[ 184] 0x900000001fc0bbf0:  a2 e0 00 00 sb	zero,0(s7)
[ 184] 0x900000001fc0bbf4:  df b7 00 20 ld	s7,32(sp)
[ 184] 0x900000001fc0bbf8:  df b5 00 30 ld	s5,48(sp)
[ 184] 0x900000001fc0bbfc:  df b3 00 40 ld	s3,64(sp)
[ 184] 0x900000001fc0bc00:  df b1 00 50 ld	s1,80(sp)
[ 184] 0x900000001fc0bc04:  df be 00 18 ld	s8,24(sp)
[ 184] 0x900000001fc0bc08:  03 e0 00 08 jr	ra
[ 184] 0x900000001fc0bc0c:  67 bd 00 c0 daddiu	sp,sp,192
  185: }
  186: 
  187: 
  188: void
  189: loputchar(char c)
  190: {
loputchar:
[ 190] 0x900000001fc0bc10:  67 bd ff e0 daddiu	sp,sp,-32
[ 190] 0x900000001fc0bc14:  00 80 c8 25 move	t9,a0
  191: 	int column = 0;
  192: 	switch (c) {
[ 192] 0x900000001fc0bc18:  2b 2a 00 20 slti	a6,t9,32
[ 192] 0x900000001fc0bc1c:  24 01 00 0a li	at,10
[ 192] 0x900000001fc0bc20:  ff bf 00 10 sd	ra,16(sp)
[ 192] 0x900000001fc0bc24:  17 21 00 07 bne	t9,at,0x900000001fc0bc44
[ 192] 0x900000001fc0bc28:  2b 2b 00 7f slti	a7,t9,127
  193: 	case '\n':
  194: 		loputchar('\r');
[ 194] 0x900000001fc0bc2c:  ff b9 00 08 sd	t9,8(sp)
[ 194] 0x900000001fc0bc30:  0f f0 2f 04 jal		loputchar
[ 194] 0x900000001fc0bc34:  24 04 00 0d li	a0,13
  195: 		break;
[ 195] 0x900000001fc0bc38:  df b9 00 08 ld	t9,8(sp)
[ 195] 0x900000001fc0bc3c:  10 00 00 08 b		0x900000001fc0bc60
[ 195] 0x900000001fc0bc40:  00 00 00 21 nada
  196: 
  197: 	default:
  198: 		if (isprint(c))
[ 198] 0x900000001fc0bc44:  55 40 00 04 bnel	a6,zero,0x900000001fc0bc58
[ 198] 0x900000001fc0bc48:  24 05 00 09 li	a1,9
[ 198] 0x900000001fc0bc4c:  15 60 00 04 bne	a7,zero,0x900000001fc0bc60
[ 198] 0x900000001fc0bc50:  00 00 00 21 nada
[ 198] 0x900000001fc0bc54:  24 05 00 09 li	a1,9
[ 198] 0x900000001fc0bc58:  13 25 00 01 beq	t9,a1,0x900000001fc0bc60
[ 198] 0x900000001fc0bc5c:  00 00 00 21 nada
  199: 			column++;
  200: 		break;
  201: 	}
  202: 	pod_putc(c);		/* attempt to print something */
[ 202] 0x900000001fc0bc60:  0f f0 15 13 jal		pod_putc
[ 202] 0x900000001fc0bc64:  03 20 20 25 move	a0,t9
  203: }
[ 203] 0x900000001fc0bc68:  df bf 00 10 ld	ra,16(sp)
[ 203] 0x900000001fc0bc6c:  03 e0 00 08 jr	ra
[ 203] 0x900000001fc0bc70:  67 bd 00 20 daddiu	sp,sp,32
  204: 
  205: 
  206: /*
  207:  * gets -- get an input line from user
  208:  * handles basic line editing
  209:  * buf assumed to be LINESIZE char, read into internal array of int
  210:  * then convert them into char. Since using cache for stack.
  211:  */
  212: 
  213: int *
  214: logets(int *buf, int max_length)
  215: {
logets:
[ 215] 0x900000001fc0bc74:  67 bd ff 90 daddiu	sp,sp,-112
[ 215] 0x900000001fc0bc78:  00 a0 40 25 move	a4,a1
  216: 	char c;
  217: 	int *bufp;
  218: 
  219: 	bufp = buf;
[ 219] 0x900000001fc0bc7c:  ff b1 00 50 sd	s1,80(sp)
[ 219] 0x900000001fc0bc80:  00 80 88 25 move	s1,a0
[ 219] 0x900000001fc0bc84:  ff b2 00 48 sd	s2,72(sp)
[ 219] 0x900000001fc0bc88:  24 12 00 7f li	s2,127
[ 219] 0x900000001fc0bc8c:  ff b7 00 20 sd	s7,32(sp)
[ 219] 0x900000001fc0bc90:  24 17 00 08 li	s7,8
[ 219] 0x900000001fc0bc94:  3c 01 90 00 lui	at,0x9000
[ 219] 0x900000001fc0bc98:  ff b4 00 38 sd	s4,56(sp)
[ 219] 0x900000001fc0bc9c:  24 14 00 20 li	s4,32
[ 219] 0x900000001fc0bca0:  60 21 00 00 daddi	at,at,0
[ 219] 0x900000001fc0bca4:  3c 03 1f c2 lui	v1,0x1fc2
[ 219] 0x900000001fc0bca8:  3c 02 90 00 lui	v0,0x9000
[ 219] 0x900000001fc0bcac:  60 67 b9 50 daddi	a3,v1,-18096
[ 219] 0x900000001fc0bcb0:  60 44 00 00 daddi	a0,v0,0
[ 219] 0x900000001fc0bcb4:  3c 02 90 00 lui	v0,0x9000
[ 219] 0x900000001fc0bcb8:  3c 03 1f c2 lui	v1,0x1fc2
[ 219] 0x900000001fc0bcbc:  60 42 00 00 daddi	v0,v0,0
[ 219] 0x900000001fc0bcc0:  60 66 ba 30 daddi	a2,v1,-17872
[ 219] 0x900000001fc0bcc4:  3c 03 1f c2 lui	v1,0x1fc2
[ 219] 0x900000001fc0bcc8:  00 01 08 3c dsll32	at,at,0
[ 219] 0x900000001fc0bccc:  ff bf 00 60 sd	ra,96(sp)
[ 219] 0x900000001fc0bcd0:  60 63 ba e8 daddi	v1,v1,-17688
[ 219] 0x900000001fc0bcd4:  ff b6 00 28 sd	s6,40(sp)
[ 219] 0x900000001fc0bcd8:  00 04 28 3c dsll32	a1,a0,0
[ 219] 0x900000001fc0bcdc:  ff b5 00 30 sd	s5,48(sp)
[ 219] 0x900000001fc0bce0:  00 08 20 b8 dsll	a0,a4,2
[ 219] 0x900000001fc0bce4:  ff b0 00 58 sd	s0,88(sp)
[ 219] 0x900000001fc0bce8:  02 20 80 25 move	s0,s1
[ 219] 0x900000001fc0bcec:  02 24 20 2d daddu	a0,s1,a0
[ 219] 0x900000001fc0bcf0:  00 02 10 3c dsll32	v0,v0,0
[ 219] 0x900000001fc0bcf4:  ff a8 00 10 sd	a4,16(sp)
[ 219] 0x900000001fc0bcf8:  00 27 08 2c dadd	at,at,a3
[ 219] 0x900000001fc0bcfc:  00 a6 a8 2c dadd	s5,a1,a2
[ 219] 0x900000001fc0bd00:  ff b3 00 40 sd	s3,64(sp)
[ 219] 0x900000001fc0bd04:  64 93 ff fc daddiu	s3,a0,-4
[ 219] 0x900000001fc0bd08:  00 43 b0 2c dadd	s6,v0,v1
[ 219] 0x900000001fc0bd0c:  ff a1 00 18 sd	at,24(sp)
  220: 	for (;;) {
  221: 		c = pod_getc();
[ 221] 0x900000001fc0bd10:  0f f0 15 0b jal		pod_getc
[ 221] 0x900000001fc0bd14:  00 00 00 21 nada
[ 221] 0x900000001fc0bd18:  00 40 20 25 move	a0,v0
  222: 
  223: 		switch (c) {
[ 223] 0x900000001fc0bd1c:  30 8b 00 ff andi	a7,a0,0xff
[ 223] 0x900000001fc0bd20:  29 69 00 08 slti	a5,a7,8
[ 223] 0x900000001fc0bd24:  15 20 00 03 bne	a5,zero,0x900000001fc0bd34
[ 223] 0x900000001fc0bd28:  29 79 00 16 slti	t9,a7,22
[ 223] 0x900000001fc0bd2c:  57 20 00 06 bnel	t9,zero,0x900000001fc0bd48
[ 223] 0x900000001fc0bd30:  00 0b 50 f8 dsll	a6,a7,3
[ 223] 0x900000001fc0bd34:  11 72 00 33 beq	a7,s2,0x900000001fc0be04
[ 223] 0x900000001fc0bd38:  00 00 00 21 nada
[ 223] 0x900000001fc0bd3c:  10 00 00 17 b		0x900000001fc0bd9c
[ 223] 0x900000001fc0bd40:  00 00 00 21 nada
[ 223] 0x900000001fc0bd44:  00 0b 50 f8 dsll	a6,a7,3
[ 223] 0x900000001fc0bd48:  01 55 50 2d daddu	a6,a6,s5
[ 223] 0x900000001fc0bd4c:  dd 4a 00 00 ld	a6,0(a6)
[ 223] 0x900000001fc0bd50:  01 40 00 08 jr	a6
[ 223] 0x900000001fc0bd54:  00 00 00 21 nada
[ 223] 0x900000001fc0bd58:  df b4 00 38 ld	s4,56(sp)
[ 223] 0x900000001fc0bd5c:  df b2 00 48 ld	s2,72(sp)
  224: 
  225: 		case '\n':
  226: 		case '\r':
  227: 			loputchar('\n');
[ 227] 0x900000001fc0bd60:  0f f0 2f 04 jal		loputchar
[ 227] 0x900000001fc0bd64:  24 04 00 0a li	a0,10
  228: 			*bufp = 0;
[ 228] 0x900000001fc0bd68:  ae 00 00 00 sw	zero,0(s0)
[ 228] 0x900000001fc0bd6c:  df b0 00 58 ld	s0,88(sp)
[ 228] 0x900000001fc0bd70:  10 00 00 1c b		0x900000001fc0bde4
[ 228] 0x900000001fc0bd74:  02 20 10 25 move	v0,s1
  229: 			return(buf);
  230: 
  231: 		case CTRL('H'):
  232: 		case DEL:
  233: 			/*
  234: 			 * Change this to a hardcopy erase????
  235: 			 */
  236: 			if (bufp > buf) {
  237: 				bufp--;
  238: 				loputchar(CTRL('H'));
  239: 				loputchar(' ');
  240: 				loputchar(CTRL('H'));
  241: 			}
  242: 			break;
  243: 
  244: 		case CTRL('U'):
  245: 			if (bufp > buf) {
[ 245] 0x900000001fc0bd78:  02 30 58 2b sltu	a7,s1,s0
[ 245] 0x900000001fc0bd7c:  11 60 ff e4 beq	a7,zero,0x900000001fc0bd10
[ 245] 0x900000001fc0bd80:  00 00 00 21 nada
  246: 				loprintf("^U\n? ");
[ 246] 0x900000001fc0bd84:  0f f0 2c e3 jal		loprintf
[ 246] 0x900000001fc0bd88:  02 c0 20 25 move	a0,s6
  247: 				bufp = buf;
[ 247] 0x900000001fc0bd8c:  02 20 80 25 move	s0,s1
[ 247] 0x900000001fc0bd90:  10 00 ff df b		0x900000001fc0bd10
[ 247] 0x900000001fc0bd94:  00 00 00 21 nada
  248: 			}
  249: 			break;
  250: 
  251: 		case '\t':
  252: 			c = ' ';	/* simplifies CTRL(H) dramatically */
[ 252] 0x900000001fc0bd98:  02 80 20 25 move	a0,s4
  253: 			/* fall through to default case */
  254: 
  255: 		default:
[ 255] 0x900000001fc0bd9c:  30 8d 00 ff andi	t1,a0,0xff
  256: 			/*
  257: 			 * Make sure there's room for this character
  258: 			 * plus a trailing \n and 0 byte
  259: 			 */
  260: 			if (bufp >= buf + max_length - 1) {
[ 260] 0x900000001fc0bda0:  02 13 60 2b sltu	t0,s0,s3
[ 260] 0x900000001fc0bda4:  51 80 00 07 beql	t0,zero,0x900000001fc0bdc4
[ 260] 0x900000001fc0bda8:  df a5 00 10 ld	a1,16(sp)
  261: 				loprintf("\n*** POD: Line > %d chars.\n", max_length);
  262: 				/* Don't return a partial line to the
  263: 					parser. */
  264: 				*buf = 0;
  265: 				return(buf);
  266: 			}
  267: 			*bufp++ = c;
  268: 			loputchar(c);
[ 268] 0x900000001fc0bdac:  0f f0 2f 04 jal		loputchar
[ 268] 0x900000001fc0bdb0:  ae 0d 00 00 sw	t1,0(s0)
  269: 			break;
[ 269] 0x900000001fc0bdb4:  66 10 00 04 daddiu	s0,s0,4
[ 269] 0x900000001fc0bdb8:  10 00 ff d5 b		0x900000001fc0bd10
[ 269] 0x900000001fc0bdbc:  00 00 00 21 nada
[ 261] 0x900000001fc0bdc0:  df a5 00 10 ld	a1,16(sp)
[ 261] 0x900000001fc0bdc4:  df ae 00 18 ld	t2,24(sp)
[ 261] 0x900000001fc0bdc8:  df b2 00 48 ld	s2,72(sp)
[ 261] 0x900000001fc0bdcc:  df b0 00 58 ld	s0,88(sp)
[ 261] 0x900000001fc0bdd0:  0f f0 2c e3 jal		loprintf
[ 261] 0x900000001fc0bdd4:  65 c4 01 a0 daddiu	a0,t2,416
[ 264] 0x900000001fc0bdd8:  df b4 00 38 ld	s4,56(sp)
[ 264] 0x900000001fc0bddc:  ae 20 00 00 sw	zero,0(s1)
[ 265] 0x900000001fc0bde0:  02 20 10 25 move	v0,s1
[ 265] 0x900000001fc0bde4:  df b7 00 20 ld	s7,32(sp)
[ 265] 0x900000001fc0bde8:  df bf 00 60 ld	ra,96(sp)
[ 265] 0x900000001fc0bdec:  df b5 00 30 ld	s5,48(sp)
[ 265] 0x900000001fc0bdf0:  df b3 00 40 ld	s3,64(sp)
[ 265] 0x900000001fc0bdf4:  df b1 00 50 ld	s1,80(sp)
[ 265] 0x900000001fc0bdf8:  df b6 00 28 ld	s6,40(sp)
[ 265] 0x900000001fc0bdfc:  03 e0 00 08 jr	ra
[ 265] 0x900000001fc0be00:  67 bd 00 70 daddiu	sp,sp,112
[ 236] 0x900000001fc0be04:  02 30 78 2b sltu	t3,s1,s0
[ 236] 0x900000001fc0be08:  11 e0 ff c1 beq	t3,zero,0x900000001fc0bd10
[ 236] 0x900000001fc0be0c:  00 00 00 21 nada
[ 238] 0x900000001fc0be10:  0f f0 2f 04 jal		loputchar
[ 238] 0x900000001fc0be14:  02 e0 20 25 move	a0,s7
[ 239] 0x900000001fc0be18:  0f f0 2f 04 jal		loputchar
[ 239] 0x900000001fc0be1c:  02 80 20 25 move	a0,s4
[ 240] 0x900000001fc0be20:  0f f0 2f 04 jal		loputchar
[ 240] 0x900000001fc0be24:  02 e0 20 25 move	a0,s7
[ 237] 0x900000001fc0be28:  10 00 ff b9 b		0x900000001fc0bd10
[ 237] 0x900000001fc0be2c:  66 10 ff fc daddiu	s0,s0,-4
  270: 		}
  271: 	}
  272: 	/*NOTREACHED*/
  273: 	return (int *)0;	/* to keep the compiler happy */
  274: }
  275: 
  276: /*
  277:  * gets -- get an input line from user
  278:  * handles basic line editing
  279:  * buf assumed to be LINESIZE char, read into internal array of int
  280:  * then convert them into char. Since using cache for stack.
  281:  */
  282: 
  283: char *
  284: logetstring(char *buf, int max_length)
  285: {
logetstring:
[ 285] 0x900000001fc0be30:  67 bd ff 90 daddiu	sp,sp,-112
[ 285] 0x900000001fc0be34:  ff b1 00 50 sd	s1,80(sp)
[ 285] 0x900000001fc0be38:  00 80 88 25 move	s1,a0
[ 285] 0x900000001fc0be3c:  00 a0 40 25 move	a4,a1
  286: 	char c;
  287: 	char *bufp;
  288: 
  289: 	bufp = buf;
[ 289] 0x900000001fc0be40:  ff b2 00 48 sd	s2,72(sp)
[ 289] 0x900000001fc0be44:  24 12 00 7f li	s2,127
[ 289] 0x900000001fc0be48:  ff b7 00 20 sd	s7,32(sp)
[ 289] 0x900000001fc0be4c:  24 17 00 08 li	s7,8
[ 289] 0x900000001fc0be50:  ff b4 00 38 sd	s4,56(sp)
[ 289] 0x900000001fc0be54:  24 14 00 20 li	s4,32
[ 289] 0x900000001fc0be58:  3c 01 90 00 lui	at,0x9000
[ 289] 0x900000001fc0be5c:  60 21 00 00 daddi	at,at,0
[ 289] 0x900000001fc0be60:  3c 02 1f c2 lui	v0,0x1fc2
[ 289] 0x900000001fc0be64:  60 46 b9 50 daddi	a2,v0,-18096
[ 289] 0x900000001fc0be68:  3c 02 90 00 lui	v0,0x9000
[ 289] 0x900000001fc0be6c:  60 44 00 00 daddi	a0,v0,0
[ 289] 0x900000001fc0be70:  3c 02 90 00 lui	v0,0x9000
[ 289] 0x900000001fc0be74:  60 42 00 00 daddi	v0,v0,0
[ 289] 0x900000001fc0be78:  3c 03 1f c2 lui	v1,0x1fc2
[ 289] 0x900000001fc0be7c:  ff bf 00 60 sd	ra,96(sp)
[ 289] 0x900000001fc0be80:  60 65 ba d0 daddi	a1,v1,-17712
[ 289] 0x900000001fc0be84:  02 28 38 2d daddu	a3,s1,a4
[ 289] 0x900000001fc0be88:  ff b6 00 28 sd	s6,40(sp)
[ 289] 0x900000001fc0be8c:  3c 03 1f c2 lui	v1,0x1fc2
[ 289] 0x900000001fc0be90:  00 01 08 3c dsll32	at,at,0
[ 289] 0x900000001fc0be94:  ff b5 00 30 sd	s5,48(sp)
[ 289] 0x900000001fc0be98:  60 63 bb 88 daddi	v1,v1,-17528
[ 289] 0x900000001fc0be9c:  00 04 20 3c dsll32	a0,a0,0
[ 289] 0x900000001fc0bea0:  ff b0 00 58 sd	s0,88(sp)
[ 289] 0x900000001fc0bea4:  02 20 80 25 move	s0,s1
[ 289] 0x900000001fc0bea8:  00 02 10 3c dsll32	v0,v0,0
[ 289] 0x900000001fc0beac:  ff a8 00 10 sd	a4,16(sp)
[ 289] 0x900000001fc0beb0:  ff b3 00 40 sd	s3,64(sp)
[ 289] 0x900000001fc0beb4:  64 f3 ff ff daddiu	s3,a3,-1
[ 289] 0x900000001fc0beb8:  00 26 08 2c dadd	at,at,a2
[ 289] 0x900000001fc0bebc:  00 85 a8 2c dadd	s5,a0,a1
[ 289] 0x900000001fc0bec0:  00 43 b0 2c dadd	s6,v0,v1
[ 289] 0x900000001fc0bec4:  ff a1 00 18 sd	at,24(sp)
  290: 	for (;;) {
  291: 		c = pod_getc();
[ 291] 0x900000001fc0bec8:  0f f0 15 0b jal		pod_getc
[ 291] 0x900000001fc0becc:  00 00 00 21 nada
[ 291] 0x900000001fc0bed0:  00 40 20 25 move	a0,v0
  292: 
  293: 		switch (c) {
[ 293] 0x900000001fc0bed4:  30 8b 00 ff andi	a7,a0,0xff
[ 293] 0x900000001fc0bed8:  29 69 00 08 slti	a5,a7,8
[ 293] 0x900000001fc0bedc:  15 20 00 03 bne	a5,zero,0x900000001fc0beec
[ 293] 0x900000001fc0bee0:  29 79 00 16 slti	t9,a7,22
[ 293] 0x900000001fc0bee4:  57 20 00 06 bnel	t9,zero,0x900000001fc0bf00
[ 293] 0x900000001fc0bee8:  00 0b 50 f8 dsll	a6,a7,3
[ 293] 0x900000001fc0beec:  11 72 00 33 beq	a7,s2,0x900000001fc0bfbc
[ 293] 0x900000001fc0bef0:  00 00 00 21 nada
[ 293] 0x900000001fc0bef4:  10 00 00 17 b		0x900000001fc0bf54
[ 293] 0x900000001fc0bef8:  00 00 00 21 nada
[ 293] 0x900000001fc0befc:  00 0b 50 f8 dsll	a6,a7,3
[ 293] 0x900000001fc0bf00:  01 55 50 2d daddu	a6,a6,s5
[ 293] 0x900000001fc0bf04:  dd 4a 00 00 ld	a6,0(a6)
[ 293] 0x900000001fc0bf08:  01 40 00 08 jr	a6
[ 293] 0x900000001fc0bf0c:  00 00 00 21 nada
[ 293] 0x900000001fc0bf10:  df b4 00 38 ld	s4,56(sp)
[ 293] 0x900000001fc0bf14:  df b2 00 48 ld	s2,72(sp)
  294: 
  295: 		case '\n':
  296: 		case '\r':
  297: 			loputchar('\n');
[ 297] 0x900000001fc0bf18:  0f f0 2f 04 jal		loputchar
[ 297] 0x900000001fc0bf1c:  24 04 00 0a li	a0,10
  298: 			*bufp = 0;
[ 298] 0x900000001fc0bf20:  a2 00 00 00 sb	zero,0(s0)
[ 298] 0x900000001fc0bf24:  df b0 00 58 ld	s0,88(sp)
[ 298] 0x900000001fc0bf28:  10 00 00 1c b		0x900000001fc0bf9c
[ 298] 0x900000001fc0bf2c:  02 20 10 25 move	v0,s1
  299: 			return(buf);
  300: 
  301: 		case CTRL('H'):
  302: 		case DEL:
  303: 			/*
  304: 			 * Change this to a hardcopy erase????
  305: 			 */
  306: 			if (bufp > buf) {
  307: 				bufp--;
  308: 				loputchar(CTRL('H'));
  309: 				loputchar(' ');
  310: 				loputchar(CTRL('H'));
  311: 			}
  312: 			break;
  313: 
  314: 		case CTRL('U'):
  315: 			if (bufp > buf) {
[ 315] 0x900000001fc0bf30:  02 30 58 2b sltu	a7,s1,s0
[ 315] 0x900000001fc0bf34:  11 60 ff e4 beq	a7,zero,0x900000001fc0bec8
[ 315] 0x900000001fc0bf38:  00 00 00 21 nada
  316: 				loprintf("^U\n? ");
[ 316] 0x900000001fc0bf3c:  0f f0 2c e3 jal		loprintf
[ 316] 0x900000001fc0bf40:  02 c0 20 25 move	a0,s6
  317: 				bufp = buf;
[ 317] 0x900000001fc0bf44:  02 20 80 25 move	s0,s1
[ 317] 0x900000001fc0bf48:  10 00 ff df b		0x900000001fc0bec8
[ 317] 0x900000001fc0bf4c:  00 00 00 21 nada
  318: 			}
  319: 			break;
  320: 
  321: 		case '\t':
  322: 			c = ' ';	/* simplifies CTRL(H) dramatically */
[ 322] 0x900000001fc0bf50:  02 80 20 25 move	a0,s4
  323: 			/* fall through to default case */
  324: 
  325: 		default:
  326: 			/*
  327: 			 * Make sure there's room for this character
  328: 			 * plus a trailing \n and 0 byte
  329: 			 */
  330: 			if (bufp >= buf + max_length - 1) {
[ 330] 0x900000001fc0bf54:  02 13 60 2b sltu	t0,s0,s3
[ 330] 0x900000001fc0bf58:  51 80 00 08 beql	t0,zero,0x900000001fc0bf7c
[ 330] 0x900000001fc0bf5c:  df a5 00 10 ld	a1,16(sp)
  331: 				loprintf("\n*** POD: Line > %d chars.\n", max_length);
  332: 				/* Don't return a partial line to the
  333: 					parser. */
  334: 				*buf = 0;
  335: 				return(buf);
  336: 			}
  337: 			*bufp++ = c;
[ 337] 0x900000001fc0bf60:  a2 04 00 00 sb	a0,0(s0)
[ 337] 0x900000001fc0bf64:  0f f0 2f 04 jal		loputchar
[ 337] 0x900000001fc0bf68:  00 00 00 21 nada
  338: 			loputchar(c);
  339: 			break;
[ 339] 0x900000001fc0bf6c:  66 10 00 01 daddiu	s0,s0,1
[ 339] 0x900000001fc0bf70:  10 00 ff d5 b		0x900000001fc0bec8
[ 339] 0x900000001fc0bf74:  00 00 00 21 nada
[ 331] 0x900000001fc0bf78:  df a5 00 10 ld	a1,16(sp)
[ 331] 0x900000001fc0bf7c:  df ad 00 18 ld	t1,24(sp)
[ 331] 0x900000001fc0bf80:  df b2 00 48 ld	s2,72(sp)
[ 331] 0x900000001fc0bf84:  df b0 00 58 ld	s0,88(sp)
[ 331] 0x900000001fc0bf88:  0f f0 2c e3 jal		loprintf
[ 331] 0x900000001fc0bf8c:  65 a4 02 40 daddiu	a0,t1,576
[ 334] 0x900000001fc0bf90:  df b4 00 38 ld	s4,56(sp)
[ 334] 0x900000001fc0bf94:  a2 20 00 00 sb	zero,0(s1)
[ 335] 0x900000001fc0bf98:  02 20 10 25 move	v0,s1
[ 335] 0x900000001fc0bf9c:  df b7 00 20 ld	s7,32(sp)
[ 335] 0x900000001fc0bfa0:  df bf 00 60 ld	ra,96(sp)
[ 335] 0x900000001fc0bfa4:  df b5 00 30 ld	s5,48(sp)
[ 335] 0x900000001fc0bfa8:  df b3 00 40 ld	s3,64(sp)
[ 335] 0x900000001fc0bfac:  df b1 00 50 ld	s1,80(sp)
[ 335] 0x900000001fc0bfb0:  df b6 00 28 ld	s6,40(sp)
[ 335] 0x900000001fc0bfb4:  03 e0 00 08 jr	ra
[ 335] 0x900000001fc0bfb8:  67 bd 00 70 daddiu	sp,sp,112
[ 306] 0x900000001fc0bfbc:  02 30 70 2b sltu	t2,s1,s0
[ 306] 0x900000001fc0bfc0:  11 c0 ff c1 beq	t2,zero,0x900000001fc0bec8
[ 306] 0x900000001fc0bfc4:  00 00 00 21 nada
[ 308] 0x900000001fc0bfc8:  0f f0 2f 04 jal		loputchar
[ 308] 0x900000001fc0bfcc:  02 e0 20 25 move	a0,s7
[ 309] 0x900000001fc0bfd0:  0f f0 2f 04 jal		loputchar
[ 309] 0x900000001fc0bfd4:  02 80 20 25 move	a0,s4
[ 310] 0x900000001fc0bfd8:  0f f0 2f 04 jal		loputchar
[ 310] 0x900000001fc0bfdc:  02 e0 20 25 move	a0,s7
[ 307] 0x900000001fc0bfe0:  10 00 ff b9 b		0x900000001fc0bec8
[ 307] 0x900000001fc0bfe4:  66 10 ff ff daddiu	s0,s0,-1
Skipping source listing to line 26 of /cores/banyan/stand/arcs/IP25prom/nvram.c...
   27: 	NVRAM_GET(_reg) = (_value);
   28: 
   29: /*
   30:  * get_nvreg()
   31:  *	Read a byte from the NVRAM.
   32:  */
   33: /*ARGSUSED*/
   34: uint
   35: get_nvreg(uint offset)
   36: {
get_nvreg:
[  36] 0x900000001fc0bfe8:  67 bd ff d0 daddiu	sp,sp,-48
   37: #ifdef SABLE
   38:     return 0;
   39: #else
   40:     uint value;
   41: 
   42:     /* First set up the XRAM Page register */
   43:     NVRAM_SET(NVR_XRAMPAGE, XRAM_PAGE(offset));
[  43] 0x900000001fc0bfec:  ff b2 00 10 sd	s2,16(sp)
[  43] 0x900000001fc0bff0:  00 80 90 25 move	s2,a0
[  43] 0x900000001fc0bff4:  ff b1 00 08 sd	s1,8(sp)
[  43] 0x900000001fc0bff8:  ff bf 00 18 sd	ra,24(sp)
[  43] 0x900000001fc0bffc:  0f f0 0d d0 jal		getendian
[  43] 0x900000001fc0c000:  30 91 0f e0 andi	s1,a0,0xfe0
[  43] 0x900000001fc0c004:  ff b3 00 20 sd	s3,32(sp)
[  43] 0x900000001fc0c008:  2c 53 00 01 sltiu	s3,v0,1
[  43] 0x900000001fc0c00c:  ff b0 00 00 sd	s0,0(sp)
[  43] 0x900000001fc0c010:  0f f0 3d 04 jal		master_epc_adap
[  43] 0x900000001fc0c014:  3c 10 90 00 lui	s0,0x9000
[  43] 0x900000001fc0c018:  62 10 00 00 daddi	s0,s0,0
[  43] 0x900000001fc0c01c:  3c 03 1f c2 lui	v1,0x1fc2
[  43] 0x900000001fc0c020:  00 10 08 3c dsll32	at,s0,0
[  43] 0x900000001fc0c024:  60 70 bb b0 daddi	s0,v1,-17488
[  43] 0x900000001fc0c028:  00 30 80 2c dadd	s0,at,s0
[  43] 0x900000001fc0c02c:  00 13 08 f8 dsll	at,s3,3
[  43] 0x900000001fc0c030:  00 33 08 2f dsubu	at,at,s3
[  43] 0x900000001fc0c034:  df b3 00 20 ld	s3,32(sp)
[  43] 0x900000001fc0c038:  00 02 14 38 dsll	v0,v0,16
[  43] 0x900000001fc0c03c:  00 11 89 42 srl	s1,s1,5
[  43] 0x900000001fc0c040:  00 22 08 2d daddu	at,at,v0
[  43] 0x900000001fc0c044:  de 02 00 00 ld	v0,0(s0)
   44:     value = (uint) NVRAM_GET(XRAM_REG(offset));	
[  44] 0x900000001fc0c048:  32 43 00 1f andi	v1,s2,0x1f
[  44] 0x900000001fc0c04c:  00 22 08 2d daddu	at,at,v0
[  44] 0x900000001fc0c050:  00 03 90 c0 sll	s2,v1,3
[  44] 0x900000001fc0c054:  0f f0 3d 04 jal		master_epc_adap
[  44] 0x900000001fc0c058:  a0 31 00 00 sb	s1,0(at)
[  44] 0x900000001fc0c05c:  00 02 8c 38 dsll	s1,v0,16
[  44] 0x900000001fc0c060:  0f f0 0d d0 jal		getendian
[  44] 0x900000001fc0c064:  00 12 90 3c dsll32	s2,s2,0
[  44] 0x900000001fc0c068:  df bf 00 18 ld	ra,24(sp)
[  44] 0x900000001fc0c06c:  00 12 90 3e dsrl32	s2,s2,0
[  44] 0x900000001fc0c070:  2c 43 00 01 sltiu	v1,v0,1
[  44] 0x900000001fc0c074:  00 03 10 f8 dsll	v0,v1,3
[  44] 0x900000001fc0c078:  02 32 08 2d daddu	at,s1,s2
[  44] 0x900000001fc0c07c:  df b1 00 08 ld	s1,8(sp)
[  44] 0x900000001fc0c080:  df b2 00 10 ld	s2,16(sp)
[  44] 0x900000001fc0c084:  00 43 10 2f dsubu	v0,v0,v1
[  44] 0x900000001fc0c088:  00 22 08 2d daddu	at,at,v0
[  44] 0x900000001fc0c08c:  de 02 00 08 ld	v0,8(s0)
[  44] 0x900000001fc0c090:  df b0 00 00 ld	s0,0(sp)
[  44] 0x900000001fc0c094:  00 22 08 2d daddu	at,at,v0
   45:     return value;
[  45] 0x900000001fc0c098:  90 22 00 00 lbu	v0,0(at)
[  45] 0x900000001fc0c09c:  03 e0 00 08 jr	ra
[  45] 0x900000001fc0c0a0:  67 bd 00 30 daddiu	sp,sp,48
   46: #endif
   47: }
   48: 
   49: 
   50: /*
   51:  * set_nvreg()
   52:  *	Writes a byte into the NVRAM
   53:  */
   54: /*ARGSUSED*/
   55: uint
   56: set_nvreg(uint offset, uint byte)
   57: {
set_nvreg:
[  57] 0x900000001fc0c0a4:  67 bd ff c0 daddiu	sp,sp,-64
[  57] 0x900000001fc0c0a8:  ff b2 00 10 sd	s2,16(sp)
[  57] 0x900000001fc0c0ac:  00 80 90 25 move	s2,a0
   58:     uint value; 
   59: 
   60: #ifdef SABLE
   61:     value = byte;
   62: #else
   63:     /* First set up the XRAM Page register */
   64:     NVRAM_SET(NVR_XRAMPAGE, XRAM_PAGE(offset));
[  64] 0x900000001fc0c0b0:  ff b4 00 28 sd	s4,40(sp)
[  64] 0x900000001fc0c0b4:  00 a0 a0 25 move	s4,a1
[  64] 0x900000001fc0c0b8:  ff b1 00 08 sd	s1,8(sp)
[  64] 0x900000001fc0c0bc:  ff bf 00 30 sd	ra,48(sp)
[  64] 0x900000001fc0c0c0:  0f f0 0d d0 jal		getendian
[  64] 0x900000001fc0c0c4:  30 91 0f e0 andi	s1,a0,0xfe0
[  64] 0x900000001fc0c0c8:  ff b3 00 20 sd	s3,32(sp)
[  64] 0x900000001fc0c0cc:  2c 53 00 01 sltiu	s3,v0,1
[  64] 0x900000001fc0c0d0:  ff b0 00 00 sd	s0,0(sp)
[  64] 0x900000001fc0c0d4:  0f f0 3d 04 jal		master_epc_adap
[  64] 0x900000001fc0c0d8:  3c 10 90 00 lui	s0,0x9000
[  64] 0x900000001fc0c0dc:  62 10 00 00 daddi	s0,s0,0
[  64] 0x900000001fc0c0e0:  3c 03 1f c2 lui	v1,0x1fc2
[  64] 0x900000001fc0c0e4:  00 10 08 3c dsll32	at,s0,0
[  64] 0x900000001fc0c0e8:  60 70 bb b0 daddi	s0,v1,-17488
[  64] 0x900000001fc0c0ec:  00 30 80 2c dadd	s0,at,s0
[  64] 0x900000001fc0c0f0:  00 13 08 f8 dsll	at,s3,3
[  64] 0x900000001fc0c0f4:  00 33 08 2f dsubu	at,at,s3
[  64] 0x900000001fc0c0f8:  df b3 00 20 ld	s3,32(sp)
[  64] 0x900000001fc0c0fc:  00 02 14 38 dsll	v0,v0,16
[  64] 0x900000001fc0c100:  00 11 89 42 srl	s1,s1,5
[  64] 0x900000001fc0c104:  00 22 08 2d daddu	at,at,v0
[  64] 0x900000001fc0c108:  de 02 00 00 ld	v0,0(s0)
   65:     NVRAM_SET(XRAM_REG(offset), byte);  
[  65] 0x900000001fc0c10c:  32 43 00 1f andi	v1,s2,0x1f
[  65] 0x900000001fc0c110:  00 22 08 2d daddu	at,at,v0
[  65] 0x900000001fc0c114:  00 03 90 c0 sll	s2,v1,3
[  65] 0x900000001fc0c118:  0f f0 3d 04 jal		master_epc_adap
[  65] 0x900000001fc0c11c:  a0 31 00 00 sb	s1,0(at)
[  65] 0x900000001fc0c120:  00 02 8c 38 dsll	s1,v0,16
[  65] 0x900000001fc0c124:  0f f0 0d d0 jal		getendian
[  65] 0x900000001fc0c128:  00 12 90 3c dsll32	s2,s2,0
[  65] 0x900000001fc0c12c:  00 12 90 3e dsrl32	s2,s2,0
[  65] 0x900000001fc0c130:  2c 44 00 01 sltiu	a0,v0,1
[  65] 0x900000001fc0c134:  00 04 18 f8 dsll	v1,a0,3
[  65] 0x900000001fc0c138:  02 32 10 2d daddu	v0,s1,s2
[  65] 0x900000001fc0c13c:  00 64 18 2f dsubu	v1,v1,a0
[  65] 0x900000001fc0c140:  00 43 10 2d daddu	v0,v0,v1
[  65] 0x900000001fc0c144:  de 10 00 08 ld	s0,8(s0)
[  65] 0x900000001fc0c148:  ff b4 00 18 sd	s4,24(sp)
[  65] 0x900000001fc0c14c:  df b4 00 28 ld	s4,40(sp)
[  65] 0x900000001fc0c150:  00 50 10 2d daddu	v0,v0,s0
[  65] 0x900000001fc0c154:  df a1 00 18 ld	at,24(sp)
   66:     value = NVRAM_GET(XRAM_REG(offset));
[  66] 0x900000001fc0c158:  0f f0 3d 04 jal		master_epc_adap
[  66] 0x900000001fc0c15c:  a0 41 00 00 sb	at,0(v0)
[  66] 0x900000001fc0c160:  00 02 8c 38 dsll	s1,v0,16
[  66] 0x900000001fc0c164:  0f f0 0d d0 jal		getendian
[  66] 0x900000001fc0c168:  00 00 00 21 nada
[  66] 0x900000001fc0c16c:  df bf 00 30 ld	ra,48(sp)
[  66] 0x900000001fc0c170:  00 00 c8 25 move	t9,zero
[  66] 0x900000001fc0c174:  2c 43 00 01 sltiu	v1,v0,1
[  66] 0x900000001fc0c178:  00 03 10 f8 dsll	v0,v1,3
[  66] 0x900000001fc0c17c:  02 32 08 2d daddu	at,s1,s2
[  66] 0x900000001fc0c180:  00 43 10 2f dsubu	v0,v0,v1
[  66] 0x900000001fc0c184:  00 22 08 2d daddu	at,at,v0
[  66] 0x900000001fc0c188:  00 30 08 2d daddu	at,at,s0
[  66] 0x900000001fc0c18c:  df a5 00 18 ld	a1,24(sp)
[  66] 0x900000001fc0c190:  90 21 00 00 lbu	at,0(at)
   67: #endif
   68: 
   69:     if (value == byte)
[  69] 0x900000001fc0c194:  50 a1 00 04 beql	a1,at,0x900000001fc0c1a8
[  69] 0x900000001fc0c198:  03 20 10 25 move	v0,t9
   70: 	return 0;
   71:     else
   72: 	return 1;	
[  72] 0x900000001fc0c19c:  10 00 00 01 b		0x900000001fc0c1a4
[  72] 0x900000001fc0c1a0:  24 19 00 01 li	t9,1
[  70] 0x900000001fc0c1a4:  03 20 10 25 move	v0,t9
[  70] 0x900000001fc0c1a8:  df b0 00 00 ld	s0,0(sp)
[  70] 0x900000001fc0c1ac:  df b1 00 08 ld	s1,8(sp)
[  70] 0x900000001fc0c1b0:  df b2 00 10 ld	s2,16(sp)
[  70] 0x900000001fc0c1b4:  03 e0 00 08 jr	ra
[  70] 0x900000001fc0c1b8:  67 bd 00 40 daddiu	sp,sp,64
   73: }
   74: 
   75: 
   76: /*
   77:  * nvchecksum()
   78:  *	Calculates the checksum for the NVRAM attached to the master
   79:  *	IO4 EPC.
   80:  */
   81: 
   82: uint 
   83: nvchecksum(void)
   84: {
nvchecksum:
[  84] 0x900000001fc0c1bc:  67 bd ff d0 daddiu	sp,sp,-48
   85:     register uint nv_reg;
   86:     unchar nv_val;
   87:     signed char checksum = 0xa5;
[  87] 0x900000001fc0c1c0:  ff b1 00 18 sd	s1,24(sp)
[  87] 0x900000001fc0c1c4:  24 11 ff a5 li	s1,-91
   88: 
   89:     /*
   90:      * do the checksum on all of the nvram, skip the checksum byte !!
   91:      */
   92:     for (nv_reg = 0; nv_reg < NVOFF_HIGHFREE; nv_reg++) {
[  92] 0x900000001fc0c1c8:  ff b0 00 20 sd	s0,32(sp)
[  92] 0x900000001fc0c1cc:  00 00 80 25 move	s0,zero
[  92] 0x900000001fc0c1d0:  ff b3 00 08 sd	s3,8(sp)
[  92] 0x900000001fc0c1d4:  24 13 03 68 li	s3,872
[  92] 0x900000001fc0c1d8:  ff b4 00 00 sd	s4,0(sp)
[  92] 0x900000001fc0c1dc:  24 14 03 1b li	s4,795
[  92] 0x900000001fc0c1e0:  ff b2 00 10 sd	s2,16(sp)
[  92] 0x900000001fc0c1e4:  24 12 0f da li	s2,4058
[  92] 0x900000001fc0c1e8:  ff bf 00 28 sd	ra,40(sp)
   93:         nv_val = get_nvreg(nv_reg);
[  93] 0x900000001fc0c1ec:  0f f0 2f fa jal		get_nvreg
[  93] 0x900000001fc0c1f0:  02 00 20 25 move	a0,s0
   94: 	if (nv_reg != NVOFF_NEW_CHECKSUM &&
[  94] 0x900000001fc0c1f4:  30 59 00 ff andi	t9,v0,0xff
[  94] 0x900000001fc0c1f8:  52 13 00 08 beql	s0,s3,0x900000001fc0c21c
[  94] 0x900000001fc0c1fc:  00 11 30 40 sll	a2,s1,1
[  94] 0x900000001fc0c200:  52 14 00 06 beql	s0,s4,0x900000001fc0c21c
[  94] 0x900000001fc0c204:  00 11 30 40 sll	a2,s1,1
   95: 	    nv_reg != NVOFF_RESTART)
   96:            checksum ^= nv_val;
[  96] 0x900000001fc0c208:  33 25 00 ff andi	a1,t9,0xff
[  96] 0x900000001fc0c20c:  02 25 28 26 xor	a1,s1,a1
[  96] 0x900000001fc0c210:  00 05 2e 3c dsll32	a1,a1,24
[  96] 0x900000001fc0c214:  00 05 8e 3f dsra32	s1,a1,24
[  96] 0x900000001fc0c218:  00 11 30 40 sll	a2,s1,1
   97: 
   98:         /* following is a tricky way to rotate */
   99:         checksum = (checksum << 1) | (checksum < 0);
[  99] 0x900000001fc0c21c:  2a 27 00 00 slti	a3,s1,0
[  99] 0x900000001fc0c220:  00 c7 30 25 or	a2,a2,a3
[  92] 0x900000001fc0c224:  00 06 36 3c dsll32	a2,a2,24
[  92] 0x900000001fc0c228:  26 10 00 01 addiu	s0,s0,1
[  92] 0x900000001fc0c22c:  16 12 ff ef bne	s0,s2,0x900000001fc0c1ec
[  92] 0x900000001fc0c230:  00 06 8e 3f dsra32	s1,a2,24
[  92] 0x900000001fc0c234:  df bf 00 28 ld	ra,40(sp)
[  92] 0x900000001fc0c238:  df b4 00 00 ld	s4,0(sp)
  100:     }
  101: 
  102:     return ((uint)checksum & 0xff);
[ 102] 0x900000001fc0c23c:  32 22 00 ff andi	v0,s1,0xff
[ 102] 0x900000001fc0c240:  df b1 00 18 ld	s1,24(sp)
[ 102] 0x900000001fc0c244:  df b2 00 10 ld	s2,16(sp)
[ 102] 0x900000001fc0c248:  df b0 00 20 ld	s0,32(sp)
[ 102] 0x900000001fc0c24c:  df b3 00 08 ld	s3,8(sp)
[ 102] 0x900000001fc0c250:  03 e0 00 08 jr	ra
[ 102] 0x900000001fc0c254:  67 bd 00 30 daddiu	sp,sp,48
  103: }
  104: 
  105: /*
  106:  * set_nvram
  107:  *	Write the given string to nvram at an offset.  If operation
  108:  *	fails, return -1, otherwise return 0.
  109:  */
  110: 
  111: int
  112: set_nvram(uint nv_off, uint nv_len, char *string)
  113: {
set_nvram:
[ 113] 0x900000001fc0c258:  67 bd ff d0 daddiu	sp,sp,-48
[ 113] 0x900000001fc0c25c:  ff b4 00 00 sd	s4,0(sp)
[ 113] 0x900000001fc0c260:  00 80 a0 25 move	s4,a0
[ 113] 0x900000001fc0c264:  ff b2 00 10 sd	s2,16(sp)
[ 113] 0x900000001fc0c268:  00 a0 90 25 move	s2,a1
  114:     uint i;
  115:     unchar new_cksum;
  116: 
  117:     if ((nv_off + nv_len) >= NVLEN_MAX)
[ 117] 0x900000001fc0c26c:  ff b3 00 08 sd	s3,8(sp)
[ 117] 0x900000001fc0c270:  00 c0 98 25 move	s3,a2
[ 117] 0x900000001fc0c274:  02 54 08 21 addu	at,s2,s4
[ 117] 0x900000001fc0c278:  ff b0 00 20 sd	s0,32(sp)
[ 117] 0x900000001fc0c27c:  24 10 ff ff li	s0,-1
[ 117] 0x900000001fc0c280:  2c 21 10 00 sltiu	at,at,4096
[ 117] 0x900000001fc0c284:  ff b1 00 18 sd	s1,24(sp)
[ 117] 0x900000001fc0c288:  00 00 88 25 move	s1,zero
[ 117] 0x900000001fc0c28c:  ff bf 00 28 sd	ra,40(sp)
[ 117] 0x900000001fc0c290:  50 20 00 1e beql	at,zero,0x900000001fc0c30c
[ 117] 0x900000001fc0c294:  df b1 00 18 ld	s1,24(sp)
  118: 	return -1;
  119: 
  120:     for (i = 0; i < nv_len; i++) {
[ 120] 0x900000001fc0c298:  12 40 00 0e beq	s2,zero,0x900000001fc0c2d4
[ 120] 0x900000001fc0c29c:  00 00 00 21 nada
[ 120] 0x900000001fc0c2a0:  00 11 10 3c dsll32	v0,s1,0
[ 120] 0x900000001fc0c2a4:  00 02 10 3e dsrl32	v0,v0,0
[ 120] 0x900000001fc0c2a8:  02 34 20 21 addu	a0,s1,s4
[ 120] 0x900000001fc0c2ac:  02 62 80 2d daddu	s0,s3,v0
  121: 	if (set_nvreg(i+nv_off, string[i]))
[ 121] 0x900000001fc0c2b0:  92 05 00 00 lbu	a1,0(s0)
[ 121] 0x900000001fc0c2b4:  0f f0 30 29 jal		set_nvreg
[ 121] 0x900000001fc0c2b8:  26 31 00 01 addiu	s1,s1,1
[ 121] 0x900000001fc0c2bc:  00 11 18 3c dsll32	v1,s1,0
[ 121] 0x900000001fc0c2c0:  00 03 18 3e dsrl32	v1,v1,0
[ 121] 0x900000001fc0c2c4:  14 40 00 0e bne	v0,zero,0x900000001fc0c300
[ 121] 0x900000001fc0c2c8:  02 63 80 2d daddu	s0,s3,v1
[ 120] 0x900000001fc0c2cc:  16 32 ff f8 bne	s1,s2,0x900000001fc0c2b0
[ 120] 0x900000001fc0c2d0:  02 34 20 21 addu	a0,s1,s4
  122: 	    return -1;
  123:     }
  124: 
  125:     /* Update the checksum */
  126:     new_cksum = nvchecksum();
[ 126] 0x900000001fc0c2d4:  0f f0 30 6f jal		nvchecksum
[ 126] 0x900000001fc0c2d8:  00 00 00 21 nada
[ 126] 0x900000001fc0c2dc:  30 46 00 ff andi	a2,v0,0xff
  127:     if (set_nvreg(NVOFF_NEW_CHECKSUM, new_cksum))
[ 127] 0x900000001fc0c2e0:  24 04 03 68 li	a0,872
[ 127] 0x900000001fc0c2e4:  0f f0 30 29 jal		set_nvreg
[ 127] 0x900000001fc0c2e8:  30 c5 00 ff andi	a1,a2,0xff
[ 127] 0x900000001fc0c2ec:  24 10 ff ff li	s0,-1
[ 127] 0x900000001fc0c2f0:  54 40 00 06 bnel	v0,zero,0x900000001fc0c30c
[ 127] 0x900000001fc0c2f4:  df b1 00 18 ld	s1,24(sp)
  128: 	return -1;
  129: 
  130:     return 0;
[ 130] 0x900000001fc0c2f8:  10 00 00 03 b		0x900000001fc0c308
[ 130] 0x900000001fc0c2fc:  00 00 80 25 move	s0,zero
[ 122] 0x900000001fc0c300:  10 00 00 01 b		0x900000001fc0c308
[ 122] 0x900000001fc0c304:  24 10 ff ff li	s0,-1
[ 118] 0x900000001fc0c308:  df b1 00 18 ld	s1,24(sp)
[ 118] 0x900000001fc0c30c:  df b4 00 00 ld	s4,0(sp)
[ 118] 0x900000001fc0c310:  df bf 00 28 ld	ra,40(sp)
[ 118] 0x900000001fc0c314:  02 00 10 25 move	v0,s0
[ 118] 0x900000001fc0c318:  df b2 00 10 ld	s2,16(sp)
[ 118] 0x900000001fc0c31c:  df b0 00 20 ld	s0,32(sp)
[ 118] 0x900000001fc0c320:  df b3 00 08 ld	s3,8(sp)
[ 118] 0x900000001fc0c324:  03 e0 00 08 jr	ra
[ 118] 0x900000001fc0c328:  67 bd 00 30 daddiu	sp,sp,48
  131: } 
  132: 
  133: /*
  134:  * get_nvram
  135:  *	Just reads a sequence of bytes out of the NVRAM.
  136:  */
  137: 
  138: void
  139: get_nvram(uint nv_off, uint nv_len, char buf[])
  140: {
get_nvram:
[ 140] 0x900000001fc0c32c:  67 bd ff d0 daddiu	sp,sp,-48
[ 140] 0x900000001fc0c330:  ff b3 00 00 sd	s3,0(sp)
[ 140] 0x900000001fc0c334:  00 80 98 25 move	s3,a0
[ 140] 0x900000001fc0c338:  ff b2 00 08 sd	s2,8(sp)
[ 140] 0x900000001fc0c33c:  00 a0 90 25 move	s2,a1
  141:     uint i;
  142: 
  143:     /* Avoid overruns */
  144:     if ((nv_off + nv_len) >= NVLEN_MAX) {
[ 144] 0x900000001fc0c340:  02 53 08 21 addu	at,s2,s3
[ 144] 0x900000001fc0c344:  ff b1 00 10 sd	s1,16(sp)
[ 144] 0x900000001fc0c348:  00 c0 88 25 move	s1,a2
[ 144] 0x900000001fc0c34c:  2c 21 10 00 sltiu	at,at,4096
[ 144] 0x900000001fc0c350:  ff b0 00 18 sd	s0,24(sp)
[ 144] 0x900000001fc0c354:  00 00 80 25 move	s0,zero
[ 144] 0x900000001fc0c358:  ff bf 00 20 sd	ra,32(sp)
[ 144] 0x900000001fc0c35c:  50 20 00 0e beql	at,zero,0x900000001fc0c398
[ 144] 0x900000001fc0c360:  df b0 00 18 ld	s0,24(sp)
  145: 	*buf = '\0';
  146: 	return;
  147:     }
  148:   
  149:     /* Transfer the bytes into the array */ 
  150:     for (i = 0; i < nv_len; i++)
[ 150] 0x900000001fc0c364:  52 40 00 09 beql	s2,zero,0x900000001fc0c38c
[ 150] 0x900000001fc0c368:  df b0 00 18 ld	s0,24(sp)
  151:        	*buf++ = get_nvreg(i+nv_off);
[ 151] 0x900000001fc0c36c:  0f f0 2f fa jal		get_nvreg
[ 151] 0x900000001fc0c370:  02 13 20 21 addu	a0,s0,s3
[ 150] 0x900000001fc0c374:  26 10 00 01 addiu	s0,s0,1
[ 150] 0x900000001fc0c378:  a2 22 00 00 sb	v0,0(s1)
[ 150] 0x900000001fc0c37c:  66 31 00 01 daddiu	s1,s1,1
[ 150] 0x900000001fc0c380:  16 12 ff fa bne	s0,s2,0x900000001fc0c36c
[ 150] 0x900000001fc0c384:  00 00 00 21 nada
[ 150] 0x900000001fc0c388:  df b0 00 18 ld	s0,24(sp)
  152: 
  153:     *buf = '\0';
[ 153] 0x900000001fc0c38c:  10 00 00 03 b		0x900000001fc0c39c
[ 153] 0x900000001fc0c390:  a2 20 00 00 sb	zero,0(s1)
[ 153] 0x900000001fc0c394:  df b0 00 18 ld	s0,24(sp)
[ 145] 0x900000001fc0c398:  a2 20 00 00 sb	zero,0(s1)
[ 146] 0x900000001fc0c39c:  df b3 00 00 ld	s3,0(sp)
[ 146] 0x900000001fc0c3a0:  df bf 00 20 ld	ra,32(sp)
[ 146] 0x900000001fc0c3a4:  df b1 00 10 ld	s1,16(sp)
[ 146] 0x900000001fc0c3a8:  df b2 00 08 ld	s2,8(sp)
[ 146] 0x900000001fc0c3ac:  03 e0 00 08 jr	ra
[ 146] 0x900000001fc0c3b0:  67 bd 00 30 daddiu	sp,sp,48
  154: }
  155: 
  156: 
  157: /*
  158:  * nvram_okay
  159:  *	Examines the NVRAM checksum and returns a value indicating 
  160:  *	whether the NVRAM is valid (1 == NVRAM valid, 0 == bogus).
  161:  */
  162: 
  163: uint
  164: nvram_okay(void)
  165: {
nvram_okay:
[ 165] 0x900000001fc0c3b4:  67 bd ff 70 daddiu	sp,sp,-144
  166:     uint	cksum;
  167:     uint	old_cksum;
  168:     jmp_buf	fault_buf;
  169:     unsigned	*old_buf;
  170: 
  171: #ifdef	SABLE
  172:     return 1;
  173: #else
  174:     /* Deal gracefully with broken IO4s's */
  175:     if (setfault(fault_buf, &old_buf))  {
[ 175] 0x900000001fc0c3b8:  67 a5 00 00 daddiu	a1,sp,0
[ 175] 0x900000001fc0c3bc:  ff bf 00 18 sd	ra,24(sp)
[ 175] 0x900000001fc0c3c0:  0f f0 18 7f jal		setfault
[ 175] 0x900000001fc0c3c4:  67 a4 00 20 daddiu	a0,sp,32
[ 175] 0x900000001fc0c3c8:  14 40 00 10 bne	v0,zero,0x900000001fc0c40c
[ 175] 0x900000001fc0c3cc:  00 00 00 21 nada
  176: 	restorefault(old_buf);
  177: 	return 0;
  178:     }
  179: 
  180:     cksum = nvchecksum();
[ 180] 0x900000001fc0c3d0:  0f f0 30 6f jal		nvchecksum
[ 180] 0x900000001fc0c3d4:  00 00 00 21 nada
[ 180] 0x900000001fc0c3d8:  ff b0 00 08 sd	s0,8(sp)
[ 180] 0x900000001fc0c3dc:  00 40 80 25 move	s0,v0
  181:     old_cksum = get_nvreg(NVOFF_NEW_CHECKSUM);
[ 181] 0x900000001fc0c3e0:  0f f0 2f fa jal		get_nvreg
[ 181] 0x900000001fc0c3e4:  24 04 03 68 li	a0,872
[ 181] 0x900000001fc0c3e8:  ff a2 00 10 sd	v0,16(sp)
  182: 
  183:     restorefault(old_buf);
[ 183] 0x900000001fc0c3ec:  0f f0 18 86 jal		restorefault
[ 183] 0x900000001fc0c3f0:  df a4 00 00 ld	a0,0(sp)
[ 183] 0x900000001fc0c3f4:  df bf 00 18 ld	ra,24(sp)
[ 183] 0x900000001fc0c3f8:  df a2 00 10 ld	v0,16(sp)
  184:     return (cksum == old_cksum);
[ 184] 0x900000001fc0c3fc:  02 02 30 26 xor	a2,s0,v0
[ 184] 0x900000001fc0c400:  df b0 00 08 ld	s0,8(sp)
[ 184] 0x900000001fc0c404:  10 00 00 05 b		0x900000001fc0c41c
[ 184] 0x900000001fc0c408:  2c d9 00 01 sltiu	t9,a2,1
[ 176] 0x900000001fc0c40c:  0f f0 18 86 jal		restorefault
[ 176] 0x900000001fc0c410:  df a4 00 00 ld	a0,0(sp)
[ 177] 0x900000001fc0c414:  df bf 00 18 ld	ra,24(sp)
[ 177] 0x900000001fc0c418:  00 00 c8 25 move	t9,zero
[ 177] 0x900000001fc0c41c:  03 20 10 25 move	v0,t9
[ 177] 0x900000001fc0c420:  03 e0 00 08 jr	ra
[ 177] 0x900000001fc0c424:  67 bd 00 90 daddiu	sp,sp,144
Skipping source listing to line 166 of /cores/banyan/stand/arcs/IP25prom/pod_parse.c...
  167: };
  168: 
  169: /*
  170:  * pod_parse is the commands driver for Power on menu.
  171:  * Basic utilities for bring up, available functions are:
  172:  *	- loprintf: can handle string, %s and %x.
  173:  *	- pon_sload: down loading program from RS232 into cache/mem and run it.
  174:  */
  175: 
  176: int find_token(int *cmd, int *cmd_token, int *num_args) {
find_token:
[ 176] 0x900000001fc0c428:  67 bd ff c0 daddiu	sp,sp,-64
  177: 	int i = 0;
  178: 
  179: 	for (i = 0; (commands[i].token != NULL) &&
[ 179] 0x900000001fc0c42c:  3c 01 90 00 lui	at,0x9000
[ 179] 0x900000001fc0c430:  60 21 00 00 daddi	at,at,0
[ 179] 0x900000001fc0c434:  3c 02 1f c2 lui	v0,0x1fc2
[ 179] 0x900000001fc0c438:  60 42 bb c0 daddi	v0,v0,-17472
[ 179] 0x900000001fc0c43c:  00 01 08 3c dsll32	at,at,0
[ 179] 0x900000001fc0c440:  ff b4 00 10 sd	s4,16(sp)
[ 179] 0x900000001fc0c444:  00 22 a0 2c dadd	s4,at,v0
[ 179] 0x900000001fc0c448:  ff b5 00 08 sd	s5,8(sp)
[ 179] 0x900000001fc0c44c:  ff b6 00 00 sd	s6,0(sp)
[ 179] 0x900000001fc0c450:  de 81 0c 48 ld	at,3144(s4)
[ 179] 0x900000001fc0c454:  ff b3 00 18 sd	s3,24(sp)
[ 179] 0x900000001fc0c458:  00 80 98 25 move	s3,a0
[ 179] 0x900000001fc0c45c:  00 a0 a8 25 move	s5,a1
[ 179] 0x900000001fc0c460:  de 83 0c 48 ld	v1,3144(s4)
[ 179] 0x900000001fc0c464:  00 c0 b0 25 move	s6,a2
[ 179] 0x900000001fc0c468:  ff b2 00 20 sd	s2,32(sp)
[ 179] 0x900000001fc0c46c:  00 00 90 25 move	s2,zero
[ 179] 0x900000001fc0c470:  02 60 20 25 move	a0,s3
[ 179] 0x900000001fc0c474:  8c 21 00 00 lw	at,0(at)
[ 179] 0x900000001fc0c478:  ff b0 00 30 sd	s0,48(sp)
[ 179] 0x900000001fc0c47c:  64 70 00 08 daddiu	s0,v1,8
[ 179] 0x900000001fc0c480:  ff b1 00 28 sd	s1,40(sp)
[ 179] 0x900000001fc0c484:  00 60 88 25 move	s1,v1
[ 179] 0x900000001fc0c488:  ff bf 00 38 sd	ra,56(sp)
[ 179] 0x900000001fc0c48c:  50 20 00 11 beql	at,zero,0x900000001fc0c4d4
[ 179] 0x900000001fc0c490:  df b1 00 28 ld	s1,40(sp)
[ 179] 0x900000001fc0c494:  0f f0 35 f5 jal		lo_strcmp
[ 179] 0x900000001fc0c498:  dc 65 00 08 ld	a1,8(v1)
[ 179] 0x900000001fc0c49c:  00 00 90 25 move	s2,zero
[ 179] 0x900000001fc0c4a0:  50 40 00 0c beql	v0,zero,0x900000001fc0c4d4
[ 179] 0x900000001fc0c4a4:  df b1 00 28 ld	s1,40(sp)
[ 179] 0x900000001fc0c4a8:  8e 26 00 18 lw	a2,24(s1)
  180: 			(lo_strcmp(cmd, commands[i].name)); i++);
[ 180] 0x900000001fc0c4ac:  66 52 00 18 daddiu	s2,s2,24
[ 180] 0x900000001fc0c4b0:  66 10 00 18 daddiu	s0,s0,24
[ 180] 0x900000001fc0c4b4:  10 c0 00 06 beq	a2,zero,0x900000001fc0c4d0
[ 180] 0x900000001fc0c4b8:  66 31 00 18 daddiu	s1,s1,24
[ 180] 0x900000001fc0c4bc:  de 05 00 00 ld	a1,0(s0)
[ 180] 0x900000001fc0c4c0:  0f f0 35 f5 jal		lo_strcmp
[ 180] 0x900000001fc0c4c4:  02 60 20 25 move	a0,s3
[ 180] 0x900000001fc0c4c8:  54 40 ff f8 bnel	v0,zero,0x900000001fc0c4ac
[ 180] 0x900000001fc0c4cc:  8e 26 00 18 lw	a2,24(s1)
[ 180] 0x900000001fc0c4d0:  df b1 00 28 ld	s1,40(sp)
  181: 	if (*cmd == 0) {
[ 181] 0x900000001fc0c4d4:  8e 67 00 00 lw	a3,0(s3)
[ 181] 0x900000001fc0c4d8:  50 e0 00 10 beql	a3,zero,0x900000001fc0c51c
[ 181] 0x900000001fc0c4dc:  df b2 00 20 ld	s2,32(sp)
  182: 		*cmd_token = NO_COMMAND;
  183: 		*num_args = 0;
  184: 	} else {
  185: 		*cmd_token = commands[i].token;
[ 185] 0x900000001fc0c4e0:  de 88 0c 48 ld	a4,3144(s4)
[ 185] 0x900000001fc0c4e4:  df b4 00 10 ld	s4,16(sp)
[ 185] 0x900000001fc0c4e8:  02 48 48 2d daddu	a5,s2,a4
  186: 		*num_args = commands[i].args;
[ 186] 0x900000001fc0c4ec:  65 08 00 04 daddiu	a4,a4,4
[ 186] 0x900000001fc0c4f0:  02 48 40 2d daddu	a4,s2,a4
[ 186] 0x900000001fc0c4f4:  df b2 00 20 ld	s2,32(sp)
[ 186] 0x900000001fc0c4f8:  8d 29 00 00 lw	a5,0(a5)
[ 186] 0x900000001fc0c4fc:  df bf 00 38 ld	ra,56(sp)
[ 186] 0x900000001fc0c500:  ae a9 00 00 sw	a5,0(s5)
[ 186] 0x900000001fc0c504:  8d 08 00 00 lw	a4,0(a4)
[ 186] 0x900000001fc0c508:  ae c8 00 00 sw	a4,0(s6)
[ 186] 0x900000001fc0c50c:  8e b0 00 00 lw	s0,0(s5)
[ 186] 0x900000001fc0c510:  10 00 00 09 b		0x900000001fc0c538
[ 186] 0x900000001fc0c514:  24 02 00 01 li	v0,1
[ 186] 0x900000001fc0c518:  df b2 00 20 ld	s2,32(sp)
[ 186] 0x900000001fc0c51c:  df b4 00 10 ld	s4,16(sp)
[ 182] 0x900000001fc0c520:  24 0a 00 16 li	a6,22
[ 182] 0x900000001fc0c524:  ae aa 00 00 sw	a6,0(s5)
[ 183] 0x900000001fc0c528:  df bf 00 38 ld	ra,56(sp)
[ 183] 0x900000001fc0c52c:  ae c0 00 00 sw	zero,0(s6)
[ 183] 0x900000001fc0c530:  8e b0 00 00 lw	s0,0(s5)
[ 183] 0x900000001fc0c534:  24 02 00 01 li	v0,1
[ 183] 0x900000001fc0c538:  df b6 00 00 ld	s6,0(sp)
  187: 	}
  188: 	if (*cmd_token)
  189: 		return 1;
[ 189] 0x900000001fc0c53c:  00 10 10 0a movz	v0,zero,s0
[ 189] 0x900000001fc0c540:  00 00 00 21 nada
[ 189] 0x900000001fc0c544:  00 00 00 21 nada
[ 189] 0x900000001fc0c548:  00 00 00 21 nada
  190: 	else
  191: 		return 0;
[ 191] 0x900000001fc0c54c:  df b0 00 30 ld	s0,48(sp)
[ 191] 0x900000001fc0c550:  df b5 00 08 ld	s5,8(sp)
[ 191] 0x900000001fc0c554:  df b3 00 18 ld	s3,24(sp)
[ 191] 0x900000001fc0c558:  03 e0 00 08 jr	ra
[ 191] 0x900000001fc0c55c:  67 bd 00 40 daddiu	sp,sp,64
  192: }
  193: 
  194: static void skipwhite(int **src)
  195: {
skipwhite:
[ 195] 0x900000001fc0c560:  24 0b 00 09 li	a7,9
  196: 	while (**src == ' ' || **src == '\t')
[ 196] 0x900000001fc0c564:  dc 8a 00 00 ld	a6,0(a0)
[ 196] 0x900000001fc0c568:  24 09 00 20 li	a5,32
[ 196] 0x900000001fc0c56c:  8d 59 00 00 lw	t9,0(a6)
[ 196] 0x900000001fc0c570:  53 29 00 04 beql	t9,a5,0x900000001fc0c584
[ 196] 0x900000001fc0c574:  65 4a 00 04 daddiu	a6,a6,4
[ 196] 0x900000001fc0c578:  17 2b 00 08 bne	t9,a7,0x900000001fc0c59c
[ 196] 0x900000001fc0c57c:  00 00 00 21 nada
  197: 		(*src)++;
[ 197] 0x900000001fc0c580:  65 4a 00 04 daddiu	a6,a6,4
[ 197] 0x900000001fc0c584:  fc 8a 00 00 sd	a6,0(a0)
[ 196] 0x900000001fc0c588:  8d 59 00 00 lw	t9,0(a6)
[ 196] 0x900000001fc0c58c:  53 29 ff fd beql	t9,a5,0x900000001fc0c584
[ 196] 0x900000001fc0c590:  65 4a 00 04 daddiu	a6,a6,4
[ 196] 0x900000001fc0c594:  53 2b ff fb beql	t9,a7,0x900000001fc0c584
[ 196] 0x900000001fc0c598:  65 4a 00 04 daddiu	a6,a6,4
[ 196] 0x900000001fc0c59c:  03 e0 00 08 jr	ra
[ 196] 0x900000001fc0c5a0:  00 00 00 21 nada
  198: }
  199: 
  200: static void parse_error(void)
  201: {
parse_error:
[ 201] 0x900000001fc0c5a4:  67 bd ff f0 daddiu	sp,sp,-16
  202: 	loprintf("*** POD syntax error.\n");
[ 202] 0x900000001fc0c5a8:  3c 01 90 00 lui	at,0x9000
[ 202] 0x900000001fc0c5ac:  3c 02 1f c2 lui	v0,0x1fc2
[ 202] 0x900000001fc0c5b0:  60 21 00 00 daddi	at,at,0
[ 202] 0x900000001fc0c5b4:  60 42 c8 10 daddi	v0,v0,-14320
[ 202] 0x900000001fc0c5b8:  00 01 08 3c dsll32	at,at,0
[ 202] 0x900000001fc0c5bc:  ff bf 00 00 sd	ra,0(sp)
[ 202] 0x900000001fc0c5c0:  0f f0 2c e3 jal		loprintf
[ 202] 0x900000001fc0c5c4:  00 22 20 2c dadd	a0,at,v0
  203: }
[ 203] 0x900000001fc0c5c8:  df bf 00 00 ld	ra,0(sp)
[ 203] 0x900000001fc0c5cc:  03 e0 00 08 jr	ra
[ 203] 0x900000001fc0c5d0:  67 bd 00 10 daddiu	sp,sp,16
  204: 
  205: static void copystr(int **target, int **src)
  206: {
  207: 	while (**src != ' ' && **src != '\t' && **src != 0 && **src != ';' 
copystr:
[ 207] 0x900000001fc0c5d4:  dc ab 00 00 ld	a7,0(a1)
[ 207] 0x900000001fc0c5d8:  24 0a 00 09 li	a6,9
[ 207] 0x900000001fc0c5dc:  24 09 00 3b li	a5,59
[ 207] 0x900000001fc0c5e0:  24 07 00 20 li	a3,32
[ 207] 0x900000001fc0c5e4:  8d 79 00 00 lw	t9,0(a7)
[ 207] 0x900000001fc0c5e8:  13 27 00 1b beq	t9,a3,0x900000001fc0c658
[ 207] 0x900000001fc0c5ec:  24 08 00 29 li	a4,41
[ 207] 0x900000001fc0c5f0:  13 2a 00 19 beq	t9,a6,0x900000001fc0c658
[ 207] 0x900000001fc0c5f4:  00 00 00 21 nada
[ 207] 0x900000001fc0c5f8:  13 20 00 17 beq	t9,zero,0x900000001fc0c658
[ 207] 0x900000001fc0c5fc:  00 00 00 21 nada
[ 207] 0x900000001fc0c600:  13 29 00 15 beq	t9,a5,0x900000001fc0c658
[ 207] 0x900000001fc0c604:  00 00 00 21 nada
[ 207] 0x900000001fc0c608:  13 28 00 13 beq	t9,a4,0x900000001fc0c658
[ 207] 0x900000001fc0c60c:  65 66 00 04 daddiu	a2,a7,4
  208: 								&& **src != ')')
  209: 		*((*target)++) = *((*src)++);
[ 209] 0x900000001fc0c610:  fc a6 00 00 sd	a2,0(a1)
[ 209] 0x900000001fc0c614:  dc 81 00 00 ld	at,0(a0)
[ 209] 0x900000001fc0c618:  ac 39 00 00 sw	t9,0(at)
[ 209] 0x900000001fc0c61c:  dc 81 00 00 ld	at,0(a0)
[ 209] 0x900000001fc0c620:  64 21 00 04 daddiu	at,at,4
[ 209] 0x900000001fc0c624:  fc 81 00 00 sd	at,0(a0)
[ 207] 0x900000001fc0c628:  dc ab 00 00 ld	a7,0(a1)
[ 207] 0x900000001fc0c62c:  8d 79 00 00 lw	t9,0(a7)
[ 207] 0x900000001fc0c630:  13 27 00 09 beq	t9,a3,0x900000001fc0c658
[ 207] 0x900000001fc0c634:  00 00 00 21 nada
[ 207] 0x900000001fc0c638:  13 2a 00 07 beq	t9,a6,0x900000001fc0c658
[ 207] 0x900000001fc0c63c:  00 00 00 21 nada
[ 207] 0x900000001fc0c640:  13 20 00 05 beq	t9,zero,0x900000001fc0c658
[ 207] 0x900000001fc0c644:  00 00 00 21 nada
[ 207] 0x900000001fc0c648:  13 29 00 03 beq	t9,a5,0x900000001fc0c658
[ 207] 0x900000001fc0c64c:  00 00 00 21 nada
[ 207] 0x900000001fc0c650:  17 28 ff ef bne	t9,a4,0x900000001fc0c610
[ 207] 0x900000001fc0c654:  65 66 00 04 daddiu	a2,a7,4
[ 207] 0x900000001fc0c658:  03 e0 00 08 jr	ra
[ 207] 0x900000001fc0c65c:  00 00 00 21 nada
  210: }
  211: 
  212: 
  213: int get_arg(int *string, __scunsigned_t *value, int **bufp)
  214: {
get_arg:
[ 214] 0x900000001fc0c660:  67 bd ff d0 daddiu	sp,sp,-48
[ 214] 0x900000001fc0c664:  ff b0 00 18 sd	s0,24(sp)
[ 214] 0x900000001fc0c668:  00 c0 80 25 move	s0,a2
[ 214] 0x900000001fc0c66c:  ff b1 00 10 sd	s1,16(sp)
[ 214] 0x900000001fc0c670:  00 80 88 25 move	s1,a0
  215: 	int *ip;
  216: 
  217: 	skipwhite(bufp);
[ 217] 0x900000001fc0c674:  00 c0 20 25 move	a0,a2
[ 217] 0x900000001fc0c678:  ff bf 00 20 sd	ra,32(sp)
[ 217] 0x900000001fc0c67c:  0f f0 31 58 jal		skipwhite
[ 217] 0x900000001fc0c680:  ff a5 00 08 sd	a1,8(sp)
  218: 
  219: 	if (!(**bufp)) {
[ 219] 0x900000001fc0c684:  02 20 28 25 move	a1,s1
[ 219] 0x900000001fc0c688:  de 01 00 00 ld	at,0(s0)
[ 219] 0x900000001fc0c68c:  3c 0a 1f c2 lui	a6,0x1fc2
[ 219] 0x900000001fc0c690:  3c 09 90 00 lui	a5,0x9000
[ 219] 0x900000001fc0c694:  8c 21 00 00 lw	at,0(at)
[ 219] 0x900000001fc0c698:  50 20 00 23 beql	at,zero,0x900000001fc0c728
[ 219] 0x900000001fc0c69c:  df b1 00 10 ld	s1,16(sp)
  220: 		loprintf("*** Insufficient arguments\n");;
  221: 		return 0;
  222: 	}
  223: 	/* get argv1 */
  224: 	ip = string;
  225: 	if (**bufp == '(') {
[ 225] 0x900000001fc0c6a0:  ff a5 00 00 sd	a1,0(sp)
[ 225] 0x900000001fc0c6a4:  de 06 00 00 ld	a2,0(s0)
[ 225] 0x900000001fc0c6a8:  24 05 00 28 li	a1,40
[ 225] 0x900000001fc0c6ac:  8c cb 00 00 lw	a7,0(a2)
[ 225] 0x900000001fc0c6b0:  11 65 00 0e beq	a7,a1,0x900000001fc0c6ec
[ 225] 0x900000001fc0c6b4:  df a8 00 00 ld	a4,0(sp)
  226: 		*ip++ = **bufp;
  227: 		(*bufp)++;
  228: 		*ip = 0;
  229: 	} else {
  230: 		copystr(&ip, bufp);
[ 230] 0x900000001fc0c6b8:  02 00 28 25 move	a1,s0
[ 230] 0x900000001fc0c6bc:  0f f0 31 75 jal		copystr
[ 230] 0x900000001fc0c6c0:  67 a4 00 00 daddiu	a0,sp,0
[ 230] 0x900000001fc0c6c4:  df a7 00 00 ld	a3,0(sp)
  231: 		*ip = 0;
  232: 		*value = lo_atoh(string);
[ 232] 0x900000001fc0c6c8:  02 20 20 25 move	a0,s1
[ 232] 0x900000001fc0c6cc:  df b1 00 10 ld	s1,16(sp)
[ 231] 0x900000001fc0c6d0:  0f f0 36 85 jal		lo_atoh
[ 231] 0x900000001fc0c6d4:  ac e0 00 00 sw	zero,0(a3)
[ 231] 0x900000001fc0c6d8:  df bf 00 20 ld	ra,32(sp)
[ 231] 0x900000001fc0c6dc:  df a7 00 08 ld	a3,8(sp)
[ 231] 0x900000001fc0c6e0:  24 19 00 01 li	t9,1
[ 231] 0x900000001fc0c6e4:  10 00 00 17 b		0x900000001fc0c744
[ 231] 0x900000001fc0c6e8:  fc e2 00 00 sd	v0,0(a3)
[ 226] 0x900000001fc0c6ec:  ad 0b 00 00 sw	a7,0(a4)
[ 226] 0x900000001fc0c6f0:  df a8 00 00 ld	a4,0(sp)
[ 226] 0x900000001fc0c6f4:  65 08 00 04 daddiu	a4,a4,4
[ 227] 0x900000001fc0c6f8:  ff a8 00 00 sd	a4,0(sp)
[ 227] 0x900000001fc0c6fc:  de 08 00 00 ld	a4,0(s0)
[ 227] 0x900000001fc0c700:  65 08 00 04 daddiu	a4,a4,4
[ 227] 0x900000001fc0c704:  fe 08 00 00 sd	a4,0(s0)
[ 227] 0x900000001fc0c708:  df a8 00 00 ld	a4,0(sp)
[ 228] 0x900000001fc0c70c:  ad 00 00 00 sw	zero,0(a4)
[ 228] 0x900000001fc0c710:  df bf 00 20 ld	ra,32(sp)
[ 228] 0x900000001fc0c714:  24 19 00 01 li	t9,1
  233: 	}
  234: 	return 1;
[ 234] 0x900000001fc0c718:  df b1 00 10 ld	s1,16(sp)
[ 234] 0x900000001fc0c71c:  10 00 00 0a b		0x900000001fc0c748
[ 234] 0x900000001fc0c720:  03 20 10 25 move	v0,t9
[ 234] 0x900000001fc0c724:  df b1 00 10 ld	s1,16(sp)
[ 220] 0x900000001fc0c728:  61 29 00 00 daddi	a5,a5,0
[ 220] 0x900000001fc0c72c:  61 4a c8 28 daddi	a6,a6,-14296
[ 220] 0x900000001fc0c730:  00 09 48 3c dsll32	a5,a5,0
[ 220] 0x900000001fc0c734:  0f f0 2c e3 jal		loprintf
[ 220] 0x900000001fc0c738:  01 2a 20 2c dadd	a0,a5,a6
[ 221] 0x900000001fc0c73c:  df bf 00 20 ld	ra,32(sp)
[ 221] 0x900000001fc0c740:  00 00 c8 25 move	t9,zero
[ 221] 0x900000001fc0c744:  03 20 10 25 move	v0,t9
[ 221] 0x900000001fc0c748:  df b0 00 18 ld	s0,24(sp)
[ 221] 0x900000001fc0c74c:  03 e0 00 08 jr	ra
[ 221] 0x900000001fc0c750:  67 bd 00 30 daddiu	sp,sp,48
  235: }
  236: 
  237: 
  238: int check_eol(int **bufp) {
check_eol:
[ 238] 0x900000001fc0c754:  24 01 00 29 li	at,41
  239: 
  240: 	if (*bufp == (int *)NULL) {
[ 240] 0x900000001fc0c758:  dc 99 00 00 ld	t9,0(a0)
[ 240] 0x900000001fc0c75c:  13 20 00 12 beq	t9,zero,0x900000001fc0c7a8
[ 240] 0x900000001fc0c760:  24 02 00 01 li	v0,1
[ 240] 0x900000001fc0c764:  24 0a 00 3b li	a6,59
  241: 		return 1;
  242: 	}
  243: 
  244: 	if (**bufp == ')') {
[ 244] 0x900000001fc0c768:  24 02 00 01 li	v0,1
[ 244] 0x900000001fc0c76c:  8f 2b 00 00 lw	a7,0(t9)
[ 244] 0x900000001fc0c770:  51 61 00 0a beql	a7,at,0x900000001fc0c79c
[ 244] 0x900000001fc0c774:  67 23 00 04 daddiu	v1,t9,4
  245: 		(*bufp)++;
  246: 		return 1;
  247: 	}
  248: 
  249: 	if (!(**bufp)) {
[ 249] 0x900000001fc0c778:  11 60 00 0b beq	a7,zero,0x900000001fc0c7a8
[ 249] 0x900000001fc0c77c:  00 00 00 21 nada
  250: 		return 1;
  251: 	}
  252: 
  253: 	if (**bufp == ';') {
[ 253] 0x900000001fc0c780:  15 6a 00 03 bne	a7,a6,0x900000001fc0c790
[ 253] 0x900000001fc0c784:  00 00 00 21 nada
  254: 		(*bufp)++;
[ 254] 0x900000001fc0c788:  67 22 00 04 daddiu	v0,t9,4
[ 254] 0x900000001fc0c78c:  fc 82 00 00 sd	v0,0(a0)
  255: 	}
  256: 
  257: 	return 0;
[ 257] 0x900000001fc0c790:  10 00 00 05 b		0x900000001fc0c7a8
[ 257] 0x900000001fc0c794:  00 00 10 25 move	v0,zero
[ 245] 0x900000001fc0c798:  67 23 00 04 daddiu	v1,t9,4
[ 246] 0x900000001fc0c79c:  fc 83 00 00 sd	v1,0(a0)
[ 246] 0x900000001fc0c7a0:  10 00 00 01 b		0x900000001fc0c7a8
[ 246] 0x900000001fc0c7a4:  24 02 00 01 li	v0,1
[ 241] 0x900000001fc0c7a8:  03 e0 00 08 jr	ra
[ 241] 0x900000001fc0c7ac:  00 00 00 21 nada
  258: }
  259: 
  260: 
  261: int *pod_parse(int *buf, struct reg_struct *gprs, int parse_level, int sloop,
  262: 				struct flag_struct *flags)
  263: {
pod_parse:
[ 263] 0x900000001fc0c7b0:  67 bd fc e0 daddiu	sp,sp,-800
[ 263] 0x900000001fc0c7b4:  ff b5 00 e8 sd	s5,232(sp)
[ 263] 0x900000001fc0c7b8:  00 c0 a8 25 move	s5,a2
[ 263] 0x900000001fc0c7bc:  ff b4 00 f0 sd	s4,240(sp)
[ 263] 0x900000001fc0c7c0:  ff b3 00 f8 sd	s3,248(sp)
  264:     int *bufp = buf;
  265:     int cmd[32];
  266:     int argv1[32];
  267:     int argv2[32];
  268:     int argv3[32];
  269:     int *ip;
  270:     __scunsigned_t arg1_val;
  271:     __scunsigned_t arg2_val;
  272:     __scunsigned_t arg3_val;
  273:     int line_end;
  274:     int cmd_token;
  275:     int num_args;
  276:     int i;
  277:     __uint64_t addr;
  278: 
  279:     if (parse_level >= MAX_NEST) {
[ 279] 0x900000001fc0c7c4:  3c 01 90 00 lui	at,0x9000
[ 279] 0x900000001fc0c7c8:  3c 02 1f c2 lui	v0,0x1fc2
[ 279] 0x900000001fc0c7cc:  60 21 00 00 daddi	at,at,0
[ 279] 0x900000001fc0c7d0:  ff bf 01 18 sd	ra,280(sp)
[ 279] 0x900000001fc0c7d4:  60 43 bb c0 daddi	v1,v0,-17472
[ 279] 0x900000001fc0c7d8:  ff b0 01 10 sd	s0,272(sp)
[ 279] 0x900000001fc0c7dc:  00 01 10 3c dsll32	v0,at,0
[ 279] 0x900000001fc0c7e0:  00 43 80 2c dadd	s0,v0,v1
[ 279] 0x900000001fc0c7e4:  2a a1 00 06 slti	at,s5,6
[ 279] 0x900000001fc0c7e8:  ff a4 00 00 sd	a0,0(sp)
[ 279] 0x900000001fc0c7ec:  10 20 03 ef beq	at,zero,0x900000001fc0d7ac
[ 279] 0x900000001fc0c7f0:  ff a7 00 40 sd	a3,64(sp)
[ 264] 0x900000001fc0c7f4:  ff b0 00 48 sd	s0,72(sp)
  280: 	loprintf("*** Too many levels of loops/parentheses.\n");
  281: 	return (int *)NULL;
  282:     }
  283: 
  284:     line_end = 0;
  285:     /* command format: cmd [argv1] [argv2] */
  286:     /* get command */
  287: 
  288:     while (!line_end) {
[ 288] 0x900000001fc0c7f8:  01 00 98 25 move	s3,a4
[ 288] 0x900000001fc0c7fc:  df a8 00 48 ld	a4,72(sp)
[ 288] 0x900000001fc0c800:  65 09 11 d8 daddiu	a5,a4,4568
[ 288] 0x900000001fc0c804:  ff b1 01 08 sd	s1,264(sp)
[ 288] 0x900000001fc0c808:  ff a9 00 58 sd	a5,88(sp)
[ 288] 0x900000001fc0c80c:  65 09 0c e8 daddiu	a5,a4,3304
[ 288] 0x900000001fc0c810:  ff a9 00 60 sd	a5,96(sp)
[ 288] 0x900000001fc0c814:  65 09 12 e0 daddiu	a5,a4,4832
[ 288] 0x900000001fc0c818:  ff a9 00 68 sd	a5,104(sp)
[ 288] 0x900000001fc0c81c:  65 09 12 28 daddiu	a5,a4,4648
[ 288] 0x900000001fc0c820:  ff a9 00 70 sd	a5,112(sp)
[ 288] 0x900000001fc0c824:  65 09 12 48 daddiu	a5,a4,4680
[ 288] 0x900000001fc0c828:  ff a9 00 78 sd	a5,120(sp)
[ 288] 0x900000001fc0c82c:  65 09 12 68 daddiu	a5,a4,4712
[ 288] 0x900000001fc0c830:  ff a9 00 80 sd	a5,128(sp)
[ 288] 0x900000001fc0c834:  65 09 12 88 daddiu	a5,a4,4744
[ 288] 0x900000001fc0c838:  ff a9 00 88 sd	a5,136(sp)
[ 288] 0x900000001fc0c83c:  65 09 12 08 daddiu	a5,a4,4616
[ 288] 0x900000001fc0c840:  ff a9 00 90 sd	a5,144(sp)
[ 288] 0x900000001fc0c844:  65 09 10 88 daddiu	a5,a4,4232
[ 288] 0x900000001fc0c848:  ff a9 00 98 sd	a5,152(sp)
[ 288] 0x900000001fc0c84c:  65 09 10 a0 daddiu	a5,a4,4256
[ 288] 0x900000001fc0c850:  ff a9 00 a0 sd	a5,160(sp)
[ 288] 0x900000001fc0c854:  65 09 10 f0 daddiu	a5,a4,4336
[ 288] 0x900000001fc0c858:  ff a9 00 a8 sd	a5,168(sp)
[ 288] 0x900000001fc0c85c:  65 09 12 d0 daddiu	a5,a4,4816
[ 288] 0x900000001fc0c860:  ff be 00 d0 sd	s8,208(sp)
[ 288] 0x900000001fc0c864:  65 1e 11 e8 daddiu	s8,a4,4584
[ 288] 0x900000001fc0c868:  ff a9 00 b0 sd	a5,176(sp)
[ 288] 0x900000001fc0c86c:  65 09 11 40 daddiu	a5,a4,4416
[ 288] 0x900000001fc0c870:  ff b7 00 d8 sd	s7,216(sp)
[ 288] 0x900000001fc0c874:  65 17 11 f8 daddiu	s7,a4,4600
[ 288] 0x900000001fc0c878:  ff a9 00 b8 sd	a5,184(sp)
[ 288] 0x900000001fc0c87c:  65 09 11 90 daddiu	a5,a4,4496
[ 288] 0x900000001fc0c880:  dd 08 0c 48 ld	a4,3144(a4)
[ 288] 0x900000001fc0c884:  ff a9 00 c0 sd	a5,192(sp)
[ 288] 0x900000001fc0c888:  65 08 00 10 daddiu	a4,a4,16
[ 284] 0x900000001fc0c88c:  ff b6 00 e0 sd	s6,224(sp)
[ 284] 0x900000001fc0c890:  26 b6 00 01 addiu	s6,s5,1
[ 284] 0x900000001fc0c894:  ff b2 01 00 sd	s2,256(sp)
[ 284] 0x900000001fc0c898:  24 12 00 01 li	s2,1
[ 284] 0x900000001fc0c89c:  ff a8 00 50 sd	a4,80(sp)
[ 284] 0x900000001fc0c8a0:  00 a0 a0 25 move	s4,a1
  289: 	skipwhite(&bufp);
[ 289] 0x900000001fc0c8a4:  0f f0 31 58 jal		skipwhite
[ 289] 0x900000001fc0c8a8:  67 a4 00 00 daddiu	a0,sp,0
  290: 	ip = cmd;
  291: 	if (*bufp == '(') {
[ 291] 0x900000001fc0c8ac:  df ad 00 00 ld	t1,0(sp)
[ 291] 0x900000001fc0c8b0:  67 a5 00 00 daddiu	a1,sp,0
[ 291] 0x900000001fc0c8b4:  67 ab 01 20 daddiu	a7,sp,288
[ 291] 0x900000001fc0c8b8:  df aa 00 00 ld	a6,0(sp)
[ 291] 0x900000001fc0c8bc:  ff ab 00 08 sd	a7,8(sp)
[ 291] 0x900000001fc0c8c0:  24 0b 00 28 li	a7,40
[ 291] 0x900000001fc0c8c4:  8d 4a 00 00 lw	a6,0(a6)
[ 291] 0x900000001fc0c8c8:  51 4b 00 08 beql	a6,a7,0x900000001fc0c8ec
[ 291] 0x900000001fc0c8cc:  67 a5 00 28 daddiu	a1,sp,40
  292: 	    *ip++ = *bufp++;
  293: 	} else {
  294: 	    copystr(&ip, &bufp);
[ 294] 0x900000001fc0c8d0:  0f f0 31 75 jal		copystr
[ 294] 0x900000001fc0c8d4:  67 a4 00 08 daddiu	a0,sp,8
[ 294] 0x900000001fc0c8d8:  67 a5 00 28 daddiu	a1,sp,40
[ 294] 0x900000001fc0c8dc:  df b9 00 08 ld	t9,8(sp)
[ 294] 0x900000001fc0c8e0:  10 00 00 0a b		0x900000001fc0c90c
[ 294] 0x900000001fc0c8e4:  67 a6 00 2c daddiu	a2,sp,44
[ 294] 0x900000001fc0c8e8:  67 a5 00 28 daddiu	a1,sp,40
[ 292] 0x900000001fc0c8ec:  8d ac 00 00 lw	t0,0(t1)
[ 292] 0x900000001fc0c8f0:  65 ae 00 04 daddiu	t2,t1,4
[ 292] 0x900000001fc0c8f4:  df ad 00 08 ld	t1,8(sp)
[ 292] 0x900000001fc0c8f8:  ff ae 00 00 sd	t2,0(sp)
[ 292] 0x900000001fc0c8fc:  ad ac 00 00 sw	t0,0(t1)
[ 292] 0x900000001fc0c900:  df ac 00 08 ld	t0,8(sp)
[ 292] 0x900000001fc0c904:  65 99 00 04 daddiu	t9,t0,4
[ 292] 0x900000001fc0c908:  67 a6 00 2c daddiu	a2,sp,44
  295: 	}
  296: 
  297: 	*ip = 0;
[ 297] 0x900000001fc0c90c:  ff b9 00 08 sd	t9,8(sp)
[ 297] 0x900000001fc0c910:  67 a4 01 20 daddiu	a0,sp,288
[ 297] 0x900000001fc0c914:  0f f0 31 0a jal		find_token
[ 297] 0x900000001fc0c918:  af 20 00 00 sw	zero,0(t9)
[ 297] 0x900000001fc0c91c:  8f b0 00 2c lw	s0,44(sp)
[ 297] 0x900000001fc0c920:  50 40 03 98 beql	v0,zero,0x900000001fc0d784
[ 297] 0x900000001fc0c924:  df be 00 d0 ld	s8,208(sp)
  298: 	if (!find_token(cmd, &cmd_token, &num_args)) {
  299: 	    loprintf("*** Invalid POD command: '%p'\n", cmd);
  300: 	    return (int *)NULL;
  301: 	}
  302: 	if (num_args > 0) {
[ 302] 0x900000001fc0c928:  5a 00 00 08 blezl	s0,0x900000001fc0c94c
[ 302] 0x900000001fc0c92c:  67 a5 00 18 daddiu	a1,sp,24
  303: 	    if (!get_arg(argv1, &arg1_val, &bufp))
[ 303] 0x900000001fc0c930:  67 a6 00 00 daddiu	a2,sp,0
[ 303] 0x900000001fc0c934:  67 a5 00 10 daddiu	a1,sp,16
[ 303] 0x900000001fc0c938:  0f f0 31 98 jal		get_arg
[ 303] 0x900000001fc0c93c:  67 a4 01 a0 daddiu	a0,sp,416
[ 303] 0x900000001fc0c940:  50 40 03 88 beql	v0,zero,0x900000001fc0d764
[ 303] 0x900000001fc0c944:  00 00 10 25 move	v0,zero
[ 303] 0x900000001fc0c948:  67 a5 00 18 daddiu	a1,sp,24
[ 303] 0x900000001fc0c94c:  67 a6 00 00 daddiu	a2,sp,0
[ 303] 0x900000001fc0c950:  8f af 00 2c lw	t3,44(sp)
  304: 		return (int *)NULL;
  305: 	}
  306: 
  307: 	if (num_args > 1) {
[ 307] 0x900000001fc0c954:  29 ef 00 02 slti	t3,t3,2
[ 307] 0x900000001fc0c958:  55 e0 00 06 bnel	t3,zero,0x900000001fc0c974
[ 307] 0x900000001fc0c95c:  67 a5 00 20 daddiu	a1,sp,32
  308: 	    if (!get_arg(argv2, &arg2_val, &bufp))
[ 308] 0x900000001fc0c960:  0f f0 31 98 jal		get_arg
[ 308] 0x900000001fc0c964:  67 a4 02 20 daddiu	a0,sp,544
[ 308] 0x900000001fc0c968:  50 40 03 76 beql	v0,zero,0x900000001fc0d744
[ 308] 0x900000001fc0c96c:  00 00 10 25 move	v0,zero
[ 308] 0x900000001fc0c970:  67 a5 00 20 daddiu	a1,sp,32
[ 308] 0x900000001fc0c974:  8f b0 00 2c lw	s0,44(sp)
  309: 		return (int *)NULL;
  310: 	}
  311: 
  312: 	if (num_args > 2) {
[ 312] 0x900000001fc0c978:  2a 10 00 03 slti	s0,s0,3
[ 312] 0x900000001fc0c97c:  16 00 00 05 bne	s0,zero,0x900000001fc0c994
[ 312] 0x900000001fc0c980:  67 a6 00 00 daddiu	a2,sp,0
  313: 	    if (!get_arg(argv3, &arg3_val, &bufp))
[ 313] 0x900000001fc0c984:  0f f0 31 98 jal		get_arg
[ 313] 0x900000001fc0c988:  67 a4 02 a0 daddiu	a0,sp,672
[ 313] 0x900000001fc0c98c:  50 40 03 65 beql	v0,zero,0x900000001fc0d724
[ 313] 0x900000001fc0c990:  00 00 10 25 move	v0,zero
  314: 		return (int *)NULL;
  315: 	}
  316: 	line_end = check_eol(&bufp);
[ 316] 0x900000001fc0c994:  0f f0 31 d5 jal		check_eol
[ 316] 0x900000001fc0c998:  67 a4 00 00 daddiu	a0,sp,0
  317: 
  318: 	if ((flags->selected != 0xff) &&
[ 318] 0x900000001fc0c99c:  24 1f 00 3e li	ra,62
[ 318] 0x900000001fc0c9a0:  ff a2 00 c8 sd	v0,200(sp)
[ 318] 0x900000001fc0c9a4:  92 70 00 16 lbu	s0,22(s3)
[ 318] 0x900000001fc0c9a8:  24 11 00 ff li	s1,255
[ 318] 0x900000001fc0c9ac:  8f b9 00 28 lw	t9,40(sp)
[ 318] 0x900000001fc0c9b0:  52 11 00 07 beql	s0,s1,0x900000001fc0c9d0
[ 318] 0x900000001fc0c9b4:  df a2 00 60 ld	v0,96(sp)
[ 318] 0x900000001fc0c9b8:  92 78 00 15 lbu	t8,21(s3)
[ 318] 0x900000001fc0c9bc:  53 10 00 04 beql	t8,s0,0x900000001fc0c9d0
[ 318] 0x900000001fc0c9c0:  df a2 00 60 ld	v0,96(sp)
[ 318] 0x900000001fc0c9c4:  57 3f 03 4d bnel	t9,ra,0x900000001fc0d6fc
[ 318] 0x900000001fc0c9c8:  df be 00 d0 ld	s8,208(sp)
[ 318] 0x900000001fc0c9cc:  df a2 00 60 ld	v0,96(sp)
[ 318] 0x900000001fc0c9d0:  8f b9 00 28 lw	t9,40(sp)
  319: 	    (flags->slice != flags->selected) &&
  320: 	    (cmd_token != POD_SELECT)) {
  321: 	    loprintf("*** Not selected\n");
  322: 	    return (int *)NULL;
  323: 	}
  324: 
  325: 	do {
  326: 	    switch (cmd_token) {
[ 326] 0x900000001fc0c9d4:  1b 20 00 61 blez	t9,0x900000001fc0cb5c
[ 326] 0x900000001fc0c9d8:  2b 30 00 73 slti	s0,t9,115
[ 326] 0x900000001fc0c9dc:  52 00 00 60 beql	s0,zero,0x900000001fc0cb60
[ 326] 0x900000001fc0c9e0:  67 a5 01 20 daddiu	a1,sp,288
[ 326] 0x900000001fc0c9e4:  00 19 08 f8 dsll	at,t9,3
[ 326] 0x900000001fc0c9e8:  00 22 08 2d daddu	at,at,v0
[ 326] 0x900000001fc0c9ec:  dc 21 00 00 ld	at,0(at)
[ 326] 0x900000001fc0c9f0:  df b0 00 10 ld	s0,16(sp)
[ 326] 0x900000001fc0c9f4:  00 20 00 08 jr	at
[ 326] 0x900000001fc0c9f8:  00 00 88 25 move	s1,zero
  327: 	    case POD_SELECT:
  328: 		flags->selected = (char)(arg1_val & 0xff);
  329: 		loprintf("Selected slice %b\n",flags->selected);
  330: 		break;
  331: 	    case WALK_MEM:
  332: 		pod_walk(arg1_val, arg2_val, (int)arg3_val, 1);
  333: 		break;
  334: 	    case DO_BIST:
  335: 		if (flags->mem) {
  336: 		    loprintf(
  337: 			     "Your stack must be in cache to reconfigure memory.  Use the 'gc' command.\n");
  338: 		} else {
  339: 		    pod_bist();
  340: 		}
  341: 		break;
  342: 	    case RECONF_MEM:
  343: 		if (flags->mem) {
  344: 		    loprintf(
  345: 			     "Your stack must be in cache to reconfigure memory.  Use the 'gc' command.\n");
  346: 		} else {
  347: 		    pod_reconf_mem();
  348: 		}
  349: 		break;
  350: 	    case TLB_DUMP:
  351: 		tlb_dump(argv1, (int)arg1_val);
  352: 		break;
  353: 	    case DISP_EVCONFIG:
  354: 		dump_evcfg(argv1, (int)arg1_val);
  355: 		break;
  356: 	    case DISP_MPCONF:
  357: 		dump_mpconf((uint)arg1_val);
  358: 		break;
  359: 
  360: 	    case DTAG_DUMP:		/* Dump data tags  */
  361: 		dumpPrimaryDataLine((int)arg1_val, 0, 0);
  362: 		dumpPrimaryDataLine((int)arg1_val, 1, 0);
  363: 		break;
  364: 
  365: 	    case DTAG_FDUMP:		/* Dump data tags with data */
  366: 		dumpPrimaryDataLine((int)arg1_val, 0, 1);
  367: 		dumpPrimaryDataLine((int)arg1_val, 1, 1);
  368: 		break;
  369: 
  370: 	    case ITAG_DUMP:		/* Dump intruction tags */
  371: 		dumpPrimaryInstructionLine((int)arg1_val, 0, 0);
  372: 		dumpPrimaryInstructionLine((int)arg1_val, 1, 0);
  373: 		break;
  374: 
  375: 	    case ITAG_FDUMP:		/* Dump intruction tags + data */
  376: 		dumpPrimaryInstructionLine((int)arg1_val, 0, 1);
  377: 		dumpPrimaryInstructionLine((int)arg1_val, 1, 1);
  378: 		break;
  379: 
  380: 	    case STAG_DUMP:
  381: 		dumpSecondaryLine((int)arg1_val, 0, 0);
  382: 		dumpSecondaryLine((int)arg1_val, 1, 0);
  383: 		break;
  384: 
  385: 	    case STAG_FDUMP:
  386: 		dumpSecondaryLine((int)arg1_val, 0, 1);
  387: 		dumpSecondaryLine((int)arg1_val, 1, 1);
  388: 		break;
  389: 	    case DTAG_ADUMP:		/* Dump data tags  */
  390: 		dumpPrimaryDataLineAddr((int)arg1_val, 0, 0);
  391: 		dumpPrimaryDataLineAddr((int)arg1_val, 1, 0);
  392: 		break;
  393: 
  394: 	    case DTAG_AFDUMP:		/* Dump data tags with data */
  395: 		dumpPrimaryDataLineAddr((int)arg1_val, 0, 1);
  396: 		dumpPrimaryDataLineAddr((int)arg1_val, 1, 1);
  397: 		break;
  398: 
  399: 	    case ITAG_ADUMP:		/* Dump intruction tags */
  400: 		dumpPrimaryInstructionLineAddr((int)arg1_val, 0, 0);
  401: 		dumpPrimaryInstructionLineAddr((int)arg1_val, 1, 0);
  402: 		break;
  403: 
  404: 	    case ITAG_AFDUMP:		/* Dump intruction tags + data */
  405: 		dumpPrimaryInstructionLineAddr((int)arg1_val, 0, 1);
  406: 		dumpPrimaryInstructionLineAddr((int)arg1_val, 1, 1);
  407: 		break;
  408: 
  409: 	    case STAG_ADUMP:
  410: 		dumpSecondaryLineAddr((int)arg1_val, 0, 0);
  411: 		dumpSecondaryLineAddr((int)arg1_val, 1, 0);
  412: 		break;
  413: 
  414: 	    case STAG_AFDUMP:
  415: 		dumpSecondaryLineAddr((int)arg1_val, 0, 1);
  416: 		dumpSecondaryLineAddr((int)arg1_val, 1, 1);
  417: 		break;
  418: 
  419: 	    case STAG_DUMP_ALL:
  420: 		dumpSecondaryCache(1);
  421: 		break;
  422: 
  423: 	    case DTAG_DUMP_ALL:
  424: 		dumpPrimaryCache(1);
  425: 		break;
  426: 
  427: 	    case ECC_SLINE:
  428: 		setSecondaryECC((__uint64_t)arg1_val | K0BASE);
  429: 		break;
  430: 
  431: 	    case SCACHE_TEST:
  432: 		testScacheFlipBits((__uint64_t)arg1_val, 1);
  433: 		break;
  434: 
  435: 	    case SCACHE_TEST_ALL:
  436: 		testScacheFlipBits((__uint64_t)arg1_val, 0);
  437: 		break;
  438: 
  439: 	    case DISP_MC3:
  440: 		dump_mc3((uint)arg1_val);
  441: 		break;
  442: 	    case DISP_IO4:
  443: 		dump_io4((uint)arg1_val);
  444: 		break;
  445: 	    case DISP_CONF:
  446: 		conf_register(READ, (uint)arg1_val, (uint)arg2_val, 0,
  447: 			      parse_level);
  448: 		break;
  449: 	    case WRITE_CONF:
  450: 		conf_register(WRITE, (uint)arg1_val, (uint)arg2_val,
  451: 			      arg3_val, parse_level);
  452: 		break;
  453: 	    case DISP_HELP:
  454: 		loprintf("\
  455: All numerical inputs should be in hex with or without 0x preceding them.\n");
  456: 		loprintf("\
  457: Commands may be separated by semicolons, and loops may be nested.\n");
  458: 		for (i = 0; (commands[i].token != NULL); i++)
  459: 		    if (get_char(commands[i].help))
  460: 			loprintf("     %s\n",
  461: 				 commands[i].help);
  462: 		break;
  463: 	    case UWRITE_BYTE:
  464: 		memory(WRITE, BYTE, K1BASE | arg1_val, arg2_val,
  465: 		       parse_level);
  466: 		break;
  467: 	    case UWRITE_HALF:
  468: 		memory(WRITE, HALF, K1BASE | arg1_val, arg2_val,
  469: 		       parse_level);
  470: 		break;
  471: 	    case UWRITE_WORD:
  472: 		memory(WRITE, WORD, K1BASE | arg1_val, arg2_val,
  473: 		       parse_level);
  474: 		break;
  475: 	    case UWRITE_DOUBLE:
  476: 		memory(WRITE, DOUBLE, K1BASE | arg1_val, arg2_val,
  477: 		       parse_level);
  478: 		break;
  479: 	    case UDISP_BYTE:
  480: 		memory(READ, BYTE, K1BASE | arg1_val, 0, parse_level);
  481: 		break;
  482: 	    case UDISP_HALF:
  483: 		memory(READ, HALF, K1BASE | arg1_val, 0, parse_level);
  484: 		break;
  485: 	    case UDISP_WORD:
  486: 		memory(READ, WORD, K1BASE | arg1_val, 0, parse_level);
  487: 		break;
  488: 	    case UDISP_DOUBLE:
  489: 		memory(READ, DOUBLE, K1BASE | arg1_val, 0, parse_level);
  490: 		break;
  491: 	    case WRITE_BYTE:
  492: 		memory(WRITE, BYTE, K0BASE | arg1_val, arg2_val,
[ 492] 0x900000001fc0c9fc:  df a6 00 48 ld	a2,72(sp)
[ 492] 0x900000001fc0ca00:  df a7 00 18 ld	a3,24(sp)
[ 492] 0x900000001fc0ca04:  02 a0 40 25 move	a4,s5
[ 492] 0x900000001fc0ca08:  00 00 28 25 move	a1,zero
[ 492] 0x900000001fc0ca0c:  02 40 20 25 move	a0,s2
[ 492] 0x900000001fc0ca10:  df a3 00 10 ld	v1,16(sp)
[ 492] 0x900000001fc0ca14:  dc c6 13 08 ld	a2,4872(a2)
[ 492] 0x900000001fc0ca18:  0f f0 25 0d jal		memory
[ 492] 0x900000001fc0ca1c:  00 66 30 25 or	a2,v1,a2
  493: 		       parse_level);
  494: 		break;
[ 494] 0x900000001fc0ca20:  10 00 03 0d b		0x900000001fc0d658
[ 494] 0x900000001fc0ca24:  df bf 00 40 ld	ra,64(sp)
  495: 	    case WRITE_HALF:
  496: 		memory(WRITE, HALF, K0BASE | arg1_val, arg2_val,
[ 496] 0x900000001fc0ca28:  df aa 00 48 ld	a6,72(sp)
[ 496] 0x900000001fc0ca2c:  df a7 00 18 ld	a3,24(sp)
[ 496] 0x900000001fc0ca30:  02 a0 40 25 move	a4,s5
[ 496] 0x900000001fc0ca34:  02 40 28 25 move	a1,s2
[ 496] 0x900000001fc0ca38:  02 40 20 25 move	a0,s2
[ 496] 0x900000001fc0ca3c:  df a9 00 10 ld	a5,16(sp)
[ 496] 0x900000001fc0ca40:  dd 4a 13 08 ld	a6,4872(a6)
[ 496] 0x900000001fc0ca44:  0f f0 25 0d jal		memory
[ 496] 0x900000001fc0ca48:  01 2a 30 25 or	a2,a5,a6
  497: 		       parse_level);
  498: 		break;
[ 498] 0x900000001fc0ca4c:  10 00 03 02 b		0x900000001fc0d658
[ 498] 0x900000001fc0ca50:  df bf 00 40 ld	ra,64(sp)
  499: 	    case WRITE_WORD:
  500: 		memory(WRITE, WORD, K0BASE | arg1_val, arg2_val,
[ 500] 0x900000001fc0ca54:  df ac 00 48 ld	t0,72(sp)
[ 500] 0x900000001fc0ca58:  df a7 00 18 ld	a3,24(sp)
[ 500] 0x900000001fc0ca5c:  02 a0 40 25 move	a4,s5
[ 500] 0x900000001fc0ca60:  24 05 00 02 li	a1,2
[ 500] 0x900000001fc0ca64:  02 40 20 25 move	a0,s2
[ 500] 0x900000001fc0ca68:  df ab 00 10 ld	a7,16(sp)
[ 500] 0x900000001fc0ca6c:  dd 8c 13 08 ld	t0,4872(t0)
[ 500] 0x900000001fc0ca70:  0f f0 25 0d jal		memory
[ 500] 0x900000001fc0ca74:  01 6c 30 25 or	a2,a7,t0
  501: 		       parse_level);
  502: 		break;
[ 502] 0x900000001fc0ca78:  10 00 02 f7 b		0x900000001fc0d658
[ 502] 0x900000001fc0ca7c:  df bf 00 40 ld	ra,64(sp)
  503: 	    case WRITE_DOUBLE:
  504: 		memory(WRITE, DOUBLE, K0BASE | arg1_val, arg2_val,
[ 504] 0x900000001fc0ca80:  df ae 00 48 ld	t2,72(sp)
[ 504] 0x900000001fc0ca84:  df a7 00 18 ld	a3,24(sp)
[ 504] 0x900000001fc0ca88:  02 a0 40 25 move	a4,s5
[ 504] 0x900000001fc0ca8c:  24 05 00 03 li	a1,3
[ 504] 0x900000001fc0ca90:  02 40 20 25 move	a0,s2
[ 504] 0x900000001fc0ca94:  df ad 00 10 ld	t1,16(sp)
[ 504] 0x900000001fc0ca98:  dd ce 13 08 ld	t2,4872(t2)
[ 504] 0x900000001fc0ca9c:  0f f0 25 0d jal		memory
[ 504] 0x900000001fc0caa0:  01 ae 30 25 or	a2,t1,t2
  505: 		       parse_level);
  506: 		break;
[ 506] 0x900000001fc0caa4:  10 00 02 ec b		0x900000001fc0d658
[ 506] 0x900000001fc0caa8:  df bf 00 40 ld	ra,64(sp)
  507: 	    case DISP_BYTE:
  508: 		memory(READ, BYTE, K0BASE | arg1_val, 0, parse_level);
[ 508] 0x900000001fc0caac:  02 a0 40 25 move	a4,s5
[ 508] 0x900000001fc0cab0:  df b0 00 48 ld	s0,72(sp)
[ 508] 0x900000001fc0cab4:  00 00 38 25 move	a3,zero
[ 508] 0x900000001fc0cab8:  00 00 28 25 move	a1,zero
[ 508] 0x900000001fc0cabc:  00 00 20 25 move	a0,zero
[ 508] 0x900000001fc0cac0:  df af 00 10 ld	t3,16(sp)
[ 508] 0x900000001fc0cac4:  de 10 13 08 ld	s0,4872(s0)
[ 508] 0x900000001fc0cac8:  0f f0 25 0d jal		memory
[ 508] 0x900000001fc0cacc:  01 f0 30 25 or	a2,t3,s0
  509: 		break;
[ 509] 0x900000001fc0cad0:  10 00 02 e1 b		0x900000001fc0d658
[ 509] 0x900000001fc0cad4:  df bf 00 40 ld	ra,64(sp)
  510: 	    case DISP_HALF:
  511: 		memory(READ, HALF, K0BASE | arg1_val, 0, parse_level);
[ 511] 0x900000001fc0cad8:  02 a0 40 25 move	a4,s5
[ 511] 0x900000001fc0cadc:  df b8 00 48 ld	t8,72(sp)
[ 511] 0x900000001fc0cae0:  00 00 38 25 move	a3,zero
[ 511] 0x900000001fc0cae4:  02 40 28 25 move	a1,s2
[ 511] 0x900000001fc0cae8:  00 00 20 25 move	a0,zero
[ 511] 0x900000001fc0caec:  df b1 00 10 ld	s1,16(sp)
[ 511] 0x900000001fc0caf0:  df 18 13 08 ld	t8,4872(t8)
[ 511] 0x900000001fc0caf4:  0f f0 25 0d jal		memory
[ 511] 0x900000001fc0caf8:  02 38 30 25 or	a2,s1,t8
  512: 		break;
[ 512] 0x900000001fc0cafc:  10 00 02 d6 b		0x900000001fc0d658
[ 512] 0x900000001fc0cb00:  df bf 00 40 ld	ra,64(sp)
  513: 	    case DISP_WORD:
  514: 		memory(READ, WORD, K0BASE | arg1_val, 0, parse_level);
[ 514] 0x900000001fc0cb04:  02 a0 40 25 move	a4,s5
[ 514] 0x900000001fc0cb08:  df bf 00 48 ld	ra,72(sp)
[ 514] 0x900000001fc0cb0c:  00 00 38 25 move	a3,zero
[ 514] 0x900000001fc0cb10:  24 05 00 02 li	a1,2
[ 514] 0x900000001fc0cb14:  00 00 20 25 move	a0,zero
[ 514] 0x900000001fc0cb18:  df b9 00 10 ld	t9,16(sp)
[ 514] 0x900000001fc0cb1c:  df e1 13 08 ld	at,4872(ra)
[ 514] 0x900000001fc0cb20:  0f f0 25 0d jal		memory
[ 514] 0x900000001fc0cb24:  03 21 30 25 or	a2,t9,at
  515: 		break;
[ 515] 0x900000001fc0cb28:  10 00 02 cb b		0x900000001fc0d658
[ 515] 0x900000001fc0cb2c:  df bf 00 40 ld	ra,64(sp)
  516: 	    case DISP_DOUBLE:
  517: 		memory(READ, DOUBLE, K0BASE | arg1_val, 0, parse_level);
[ 517] 0x900000001fc0cb30:  02 a0 40 25 move	a4,s5
[ 517] 0x900000001fc0cb34:  df a2 00 48 ld	v0,72(sp)
[ 517] 0x900000001fc0cb38:  00 00 38 25 move	a3,zero
[ 517] 0x900000001fc0cb3c:  24 05 00 03 li	a1,3
[ 517] 0x900000001fc0cb40:  00 00 20 25 move	a0,zero
[ 517] 0x900000001fc0cb44:  df a1 00 10 ld	at,16(sp)
[ 517] 0x900000001fc0cb48:  dc 42 13 08 ld	v0,4872(v0)
[ 517] 0x900000001fc0cb4c:  0f f0 25 0d jal		memory
[ 517] 0x900000001fc0cb50:  00 22 30 25 or	a2,at,v0
  518: 		break;
[ 518] 0x900000001fc0cb54:  10 00 02 c0 b		0x900000001fc0d658
[ 518] 0x900000001fc0cb58:  df bf 00 40 ld	ra,64(sp)
  519:             case NIB_DISP_MASTER:
  520: 		for (i = 0; i < arg1_val; i++) {
  521: 		    addr = MASTER_DEBUG_ADDR + (i * 8);
  522: 		    loprintf("%x: %y \n", (__uint64_t *) addr, *(__uint64_t *)addr);
  523: 		}
  524: 		break;
  525: 
  526:             case NIB_DISP_SLAVE:
  527: 		for (i = 0; i < arg1_val; i++) {
  528: 		    addr = SLAVE_DEBUG_ADDR + (i * 8);
  529: 		    loprintf("%x: %y \n", addr, *(__uint64_t *)addr);
  530: 		}
  531: 		break;
  532: 
  533: 	    case GOTO_MEM:
  534: 		run_cached(pod_loop);
  535: 		/* Never returns */
  536: 		break;
  537: 	    case GOTO_CACHE:
  538: 		podMode(EVDIAG_DEBUG,
  539: 			"Putting stack in dcache\r\n");
  540: 		/* Never returns */
  541: 		break;
  542: 	    case RESET_SYSTEM:
  543: 		reset_system();
  544: 		break;
  545: 	    case DISP_REG:
  546: 		_register(READ, argv1, 0, gprs);
  547: 		break;
  548: 	    case POD_RESUME:
  549: 		podResume();
  550: 		break;
  551: 	    case CLEAR_STATE:
  552: 		clearIP25State();
  553: 		loprintf("Cleared CPU error state.\n");
  554: 		clear_mc3_state();
  555: 		loprintf("Cleared memory error state.\n");
  556: 		clear_io4_state();
  557: 		loprintf("Cleared IO error state.\n");
  558: 		break;
  559: 	    case SEND_INT:
  560: 		send_int((int)arg1_val, (int)arg2_val, (int)arg3_val);
  561: 		break;
  562: 	    case WRITE_REG:
  563: 		_register(WRITE,argv1,arg2_val,gprs);
  564: 		break;
  565: 	    case WHY:
  566: 		flags->scroll_msg = 1;
  567: 		loprintf("Reason for entering POD mode: %s\n",
  568: 			 flags->diag_string);
  569: 		break;
  570: 	    case SCOPE_LOOP:
  571: 		if (*argv1 != '(') {
  572: 		    parse_error();	
  573: 		    return (int *)NULL;
  574: 		}	
  575: 		ip = pod_parse(bufp, gprs, parse_level+1, 1, 
  576: 			       flags);
  577: 		if (ip == (int *)NULL)
  578: 		    return ip;
  579: 		bufp = ip;
  580: 		line_end = check_eol(&bufp);
  581: 		/* Recheck the end of line because we made
  582: 		   recursive parser calls in the switch */
  583: 		break;
  584: 	    case ZAP_INVENTORY:
  585: 		zap_inventory();
  586: 		break;
  587: 
  588: 	    case FINITE_LOOP:
  589: 		if (*argv2 != '(') {
  590: 		    parse_error();	
  591: 		    return (int *)NULL;
  592: 		}
  593: 		if (!arg1_val) {
  594: 		    loprintf("*** Loop count must be > 0.\n");
  595: 		    return (int *)NULL;
  596: 		}
  597: 				
  598: 		for (i = 0; i < arg1_val; i++) {
  599: 		    ip = pod_parse(bufp, gprs,
  600: 				   parse_level+1, 0, flags);
  601: 		    if (ip == (int *)NULL)
  602: 			return ip;
  603: 		}
  604: 		bufp = ip;
  605: 		line_end = check_eol(&bufp);
  606: 		/* Recheck the end of line because we made
  607: 		   recursive parser calls in the switch */
  608: 		break;
  609: 	    case LEFT_PAREN:
  610: 		bufp = pod_parse(bufp, gprs, parse_level+1, 0,
  611: 				 flags);
  612: 		line_end = check_eol(&bufp);
  613: 		/* Recheck the end of line because we made
  614: 		   recursive parser calls in the switch */
  615: 		break;
  616: 	    case DISP_INFO:
  617: 		info();
  618: 		break;
  619: 	    case DECODE_ADDR:
  620: 		decode_address(arg1_val);
  621: 		break;
  622: 	    case FLUSHT:
  623: 		flushTlb();
  624: 		break;
  625: 	    case FLUSHI:
  626: 		invalidateIDcache();
  627: 		break;
  628: 	    case TEST_MEM:
  629: 		mem_test(arg1_val, arg2_val);
  630: 		break;
  631: 	    case SLAVE_MODE:
  632: 		jump_addr((__psunsigned_t)prom_slave, 0, 0, flags);
  633: 		break;
  634: 	    case JUMP_ADDR:
  635: 		arg2_val = 0;
  636: 		break;
  637: 		/* Fall through */
  638: 	    case JUMP_ADDR1:
  639: 		arg3_val = 0;
  640: 		/* Fall through */
  641: 	    case JUMP_ADDR2:
  642: 		loprintf("Returned %x\n", 
  643: 			 jump_addr(arg1_val,
  644: 				   (uint)arg2_val, (uint)arg3_val, flags));
  645: 		break;
  646: 
  647: 	    case DOWNLOAD_IO4:
  648: 		load_io4prom();
  649: 		break;
  650: 	    case DISABLE_UNIT:
  651: 		(void)set_unit_enable((uint)arg1_val, (uint)arg2_val, 0, 0);
  652: 		break;
  653: 	    case FDISABLE_UNIT:
  654: 		(void)set_unit_enable((uint)arg1_val, (uint)arg2_val, 0, 1);
  655: 		break;
  656: 	    case ENABLE_UNIT:
  657: 		(void)set_unit_enable((uint)arg1_val, (uint)arg2_val, 1, 0);
  658: 		break;
  659: 	    case FENABLE_UNIT:
  660: 		(void)set_unit_enable((uint)arg1_val, (uint)arg2_val, 1, 1);
  661: 		break;
  662: 	    case SLOT:
  663: 		dumpSlot((int)arg1_val);
  664: 		break;
  665: 	    case SLICE:
  666: 		dumpSlice((int)arg1_val, (int)arg2_val);
  667: 		break;
  668: 	    case ALL:
  669: 		dumpAll();
  670: 		break;
  671: 	    case WAIT:
  672: 		wait();
  673: 		break;
  674: 	    case CT_TEST:
  675: 		compareSecondaryTags(0, 0);
  676: 		break;
  677: 	    case CT_TEST_ALL:
  678: 		compareSecondaryTags(1, 0);
  679: 		break;
  680: 	    case CT_TEST_STRICT:
  681: 		compareSecondaryTags(0, 1);
  682: 		break;
  683: 	    case CT_TEST_STRICT_ALL:
  684: 		compareSecondaryTags(1, 1);
  685: 		break;
  686: 	    case MARGIN:
  687: 		margin(arg1_val, argv2, argv3);
  688: 		break;
  689: 	    case NO_COMMAND:
  690: 		break;
  691: 	    default:
  692: 		loprintf("*** Unimplemented POD command: '%p'\n", cmd);
[ 692] 0x900000001fc0cb5c:  67 a5 01 20 daddiu	a1,sp,288
[ 692] 0x900000001fc0cb60:  0f f0 2c e3 jal		loprintf
[ 692] 0x900000001fc0cb64:  df a4 00 68 ld	a0,104(sp)
  693: 		break;
[ 693] 0x900000001fc0cb68:  10 00 02 bb b		0x900000001fc0d658
[ 693] 0x900000001fc0cb6c:  df bf 00 40 ld	ra,64(sp)
[ 543] 0x900000001fc0cb70:  0f f0 2b 71 jal		reset_system
[ 543] 0x900000001fc0cb74:  00 00 00 21 nada
[ 544] 0x900000001fc0cb78:  10 00 02 b7 b		0x900000001fc0d658
[ 544] 0x900000001fc0cb7c:  df bf 00 40 ld	ra,64(sp)
[ 546] 0x900000001fc0cb80:  02 80 38 25 move	a3,s4
[ 546] 0x900000001fc0cb84:  00 00 30 25 move	a2,zero
[ 546] 0x900000001fc0cb88:  67 a5 01 a0 daddiu	a1,sp,416
[ 546] 0x900000001fc0cb8c:  0f f0 22 4d jal		_register
[ 546] 0x900000001fc0cb90:  00 00 20 25 move	a0,zero
[ 547] 0x900000001fc0cb94:  10 00 02 b0 b		0x900000001fc0d658
[ 547] 0x900000001fc0cb98:  df bf 00 40 ld	ra,64(sp)
[ 563] 0x900000001fc0cb9c:  02 80 38 25 move	a3,s4
[ 563] 0x900000001fc0cba0:  df a6 00 18 ld	a2,24(sp)
[ 563] 0x900000001fc0cba4:  67 a5 01 a0 daddiu	a1,sp,416
[ 563] 0x900000001fc0cba8:  0f f0 22 4d jal		_register
[ 563] 0x900000001fc0cbac:  02 40 20 25 move	a0,s2
[ 564] 0x900000001fc0cbb0:  10 00 02 a9 b		0x900000001fc0d658
[ 564] 0x900000001fc0cbb4:  df bf 00 40 ld	ra,64(sp)
[ 617] 0x900000001fc0cbb8:  0f f0 26 0d jal		info
[ 617] 0x900000001fc0cbbc:  00 00 00 21 nada
[ 618] 0x900000001fc0cbc0:  10 00 02 a5 b		0x900000001fc0d658
[ 618] 0x900000001fc0cbc4:  df bf 00 40 ld	ra,64(sp)
[ 618] 0x900000001fc0cbc8:  df a5 00 18 ld	a1,24(sp)
[ 629] 0x900000001fc0cbcc:  0f f0 28 a7 jal		mem_test
[ 629] 0x900000001fc0cbd0:  df a4 00 10 ld	a0,16(sp)
[ 630] 0x900000001fc0cbd4:  10 00 02 a0 b		0x900000001fc0d658
[ 630] 0x900000001fc0cbd8:  df bf 00 40 ld	ra,64(sp)
[ 630] 0x900000001fc0cbdc:  ff a0 00 18 sd	zero,24(sp)
[ 636] 0x900000001fc0cbe0:  10 00 02 9d b		0x900000001fc0d658
[ 636] 0x900000001fc0cbe4:  df bf 00 40 ld	ra,64(sp)
[ 610] 0x900000001fc0cbe8:  02 60 40 25 move	a4,s3
[ 610] 0x900000001fc0cbec:  00 00 38 25 move	a3,zero
[ 610] 0x900000001fc0cbf0:  df a4 00 00 ld	a0,0(sp)
[ 610] 0x900000001fc0cbf4:  02 c0 30 25 move	a2,s6
[ 610] 0x900000001fc0cbf8:  0f f0 31 ec jal		pod_parse
[ 610] 0x900000001fc0cbfc:  02 80 28 25 move	a1,s4
[ 612] 0x900000001fc0cc00:  67 a4 00 00 daddiu	a0,sp,0
[ 612] 0x900000001fc0cc04:  0f f0 31 d5 jal		check_eol
[ 612] 0x900000001fc0cc08:  ff a2 00 00 sd	v0,0(sp)
[ 615] 0x900000001fc0cc0c:  ff a2 00 c8 sd	v0,200(sp)
[ 615] 0x900000001fc0cc10:  10 00 02 91 b		0x900000001fc0d658
[ 615] 0x900000001fc0cc14:  df bf 00 40 ld	ra,64(sp)
[ 446] 0x900000001fc0cc18:  02 a0 40 25 move	a4,s5
[ 446] 0x900000001fc0cc1c:  00 00 38 25 move	a3,zero
[ 446] 0x900000001fc0cc20:  00 00 20 25 move	a0,zero
[ 446] 0x900000001fc0cc24:  df a9 00 10 ld	a5,16(sp)
[ 446] 0x900000001fc0cc28:  00 09 28 00 sll	a1,a5,0
[ 446] 0x900000001fc0cc2c:  df a9 00 18 ld	a5,24(sp)
[ 446] 0x900000001fc0cc30:  0f f0 23 1c jal		conf_register
[ 446] 0x900000001fc0cc34:  00 09 30 00 sll	a2,a5,0
[ 448] 0x900000001fc0cc38:  10 00 02 87 b		0x900000001fc0d658
[ 448] 0x900000001fc0cc3c:  df bf 00 40 ld	ra,64(sp)
[ 440] 0x900000001fc0cc40:  df aa 00 10 ld	a6,16(sp)
[ 440] 0x900000001fc0cc44:  0f f0 23 b4 jal		dump_mc3
[ 440] 0x900000001fc0cc48:  00 0a 20 00 sll	a0,a6,0
[ 441] 0x900000001fc0cc4c:  10 00 02 82 b		0x900000001fc0d658
[ 441] 0x900000001fc0cc50:  df bf 00 40 ld	ra,64(sp)
[ 549] 0x900000001fc0cc54:  0f f0 15 e1 jal		podResume
[ 549] 0x900000001fc0cc58:  00 00 00 21 nada
[ 550] 0x900000001fc0cc5c:  10 00 02 7e b		0x900000001fc0d658
[ 550] 0x900000001fc0cc60:  df bf 00 40 ld	ra,64(sp)
[ 626] 0x900000001fc0cc64:  0f f0 07 f8 jal		invalidateIDcache
[ 626] 0x900000001fc0cc68:  00 00 00 21 nada
[ 627] 0x900000001fc0cc6c:  10 00 02 7a b		0x900000001fc0d658
[ 627] 0x900000001fc0cc70:  df bf 00 40 ld	ra,64(sp)
[ 623] 0x900000001fc0cc74:  0f f0 17 47 jal		flushTlb
[ 623] 0x900000001fc0cc78:  00 00 00 21 nada
[ 624] 0x900000001fc0cc7c:  10 00 02 76 b		0x900000001fc0d658
[ 624] 0x900000001fc0cc80:  df bf 00 40 ld	ra,64(sp)
[ 351] 0x900000001fc0cc84:  67 a4 01 a0 daddiu	a0,sp,416
[ 351] 0x900000001fc0cc88:  df ab 00 10 ld	a7,16(sp)
[ 351] 0x900000001fc0cc8c:  0f f0 1d 8e jal		tlb_dump
[ 351] 0x900000001fc0cc90:  00 0b 28 00 sll	a1,a7,0
[ 352] 0x900000001fc0cc94:  10 00 02 70 b		0x900000001fc0d658
[ 352] 0x900000001fc0cc98:  df bf 00 40 ld	ra,64(sp)
[ 450] 0x900000001fc0cc9c:  02 a0 40 25 move	a4,s5
[ 450] 0x900000001fc0cca0:  02 40 20 25 move	a0,s2
[ 450] 0x900000001fc0cca4:  df ac 00 10 ld	t0,16(sp)
[ 450] 0x900000001fc0cca8:  df a7 00 20 ld	a3,32(sp)
[ 450] 0x900000001fc0ccac:  00 0c 28 00 sll	a1,t0,0
[ 450] 0x900000001fc0ccb0:  df ac 00 18 ld	t0,24(sp)
[ 450] 0x900000001fc0ccb4:  0f f0 23 1c jal		conf_register
[ 450] 0x900000001fc0ccb8:  00 0c 30 00 sll	a2,t0,0
[ 452] 0x900000001fc0ccbc:  10 00 02 66 b		0x900000001fc0d658
[ 452] 0x900000001fc0ccc0:  df bf 00 40 ld	ra,64(sp)
[ 452] 0x900000001fc0ccc4:  df ad 00 10 ld	t1,16(sp)
[ 560] 0x900000001fc0ccc8:  00 0d 20 00 sll	a0,t1,0
[ 560] 0x900000001fc0cccc:  df ad 00 18 ld	t1,24(sp)
[ 560] 0x900000001fc0ccd0:  00 0d 28 00 sll	a1,t1,0
[ 560] 0x900000001fc0ccd4:  df ad 00 20 ld	t1,32(sp)
[ 560] 0x900000001fc0ccd8:  0f f0 23 09 jal		send_int
[ 560] 0x900000001fc0ccdc:  00 0d 30 00 sll	a2,t1,0
[ 561] 0x900000001fc0cce0:  10 00 02 5d b		0x900000001fc0d658
[ 561] 0x900000001fc0cce4:  df bf 00 40 ld	ra,64(sp)
[ 443] 0x900000001fc0cce8:  df ae 00 10 ld	t2,16(sp)
[ 443] 0x900000001fc0ccec:  0f f0 23 45 jal		dump_io4
[ 443] 0x900000001fc0ccf0:  00 0e 20 00 sll	a0,t2,0
[ 444] 0x900000001fc0ccf4:  10 00 02 58 b		0x900000001fc0d658
[ 444] 0x900000001fc0ccf8:  df bf 00 40 ld	ra,64(sp)
[ 552] 0x900000001fc0ccfc:  0f f0 16 dc jal		clearIP25State
[ 552] 0x900000001fc0cd00:  00 00 00 21 nada
[ 553] 0x900000001fc0cd04:  0f f0 2c e3 jal		loprintf
[ 553] 0x900000001fc0cd08:  df a4 00 70 ld	a0,112(sp)
[ 554] 0x900000001fc0cd0c:  0f f0 24 a1 jal		clear_mc3_state
[ 554] 0x900000001fc0cd10:  00 00 00 21 nada
[ 555] 0x900000001fc0cd14:  0f f0 2c e3 jal		loprintf
[ 555] 0x900000001fc0cd18:  df a4 00 78 ld	a0,120(sp)
[ 556] 0x900000001fc0cd1c:  0f f0 24 d5 jal		clear_io4_state
[ 556] 0x900000001fc0cd20:  00 00 00 21 nada
[ 557] 0x900000001fc0cd24:  0f f0 2c e3 jal		loprintf
[ 557] 0x900000001fc0cd28:  df a4 00 80 ld	a0,128(sp)
[ 558] 0x900000001fc0cd2c:  10 00 02 4a b		0x900000001fc0d658
[ 558] 0x900000001fc0cd30:  df bf 00 40 ld	ra,64(sp)
[ 620] 0x900000001fc0cd34:  0f f0 42 2c jal		decode_address
[ 620] 0x900000001fc0cd38:  df a4 00 10 ld	a0,16(sp)
[ 621] 0x900000001fc0cd3c:  10 00 02 46 b		0x900000001fc0d658
[ 621] 0x900000001fc0cd40:  df bf 00 40 ld	ra,64(sp)
[ 621] 0x900000001fc0cd44:  df a5 00 18 ld	a1,24(sp)
[ 621] 0x900000001fc0cd48:  df a4 00 10 ld	a0,16(sp)
[ 332] 0x900000001fc0cd4c:  02 40 38 25 move	a3,s2
[ 332] 0x900000001fc0cd50:  df af 00 20 ld	t3,32(sp)
[ 332] 0x900000001fc0cd54:  0f f0 40 29 jal		pod_walk
[ 332] 0x900000001fc0cd58:  00 0f 30 00 sll	a2,t3,0
[ 333] 0x900000001fc0cd5c:  10 00 02 3e b		0x900000001fc0d658
[ 333] 0x900000001fc0cd60:  df bf 00 40 ld	ra,64(sp)
[ 632] 0x900000001fc0cd64:  02 60 38 25 move	a3,s3
[ 632] 0x900000001fc0cd68:  00 00 30 25 move	a2,zero
[ 632] 0x900000001fc0cd6c:  df b0 00 48 ld	s0,72(sp)
[ 632] 0x900000001fc0cd70:  00 00 28 25 move	a1,zero
[ 632] 0x900000001fc0cd74:  0f f0 2b 49 jal		jump_addr
[ 632] 0x900000001fc0cd78:  de 04 13 30 ld	a0,4912(s0)
[ 633] 0x900000001fc0cd7c:  10 00 02 36 b		0x900000001fc0d658
[ 633] 0x900000001fc0cd80:  df bf 00 40 ld	ra,64(sp)
[ 648] 0x900000001fc0cd84:  0f f0 5b 40 jal		load_io4prom
[ 648] 0x900000001fc0cd88:  00 00 00 21 nada
[ 649] 0x900000001fc0cd8c:  10 00 02 32 b		0x900000001fc0d658
[ 649] 0x900000001fc0cd90:  df bf 00 40 ld	ra,64(sp)
[ 567] 0x900000001fc0cd94:  de 65 00 08 ld	a1,8(s3)
[ 566] 0x900000001fc0cd98:  ae 72 00 10 sw	s2,16(s3)
[ 566] 0x900000001fc0cd9c:  0f f0 2c e3 jal		loprintf
[ 566] 0x900000001fc0cda0:  df a4 00 88 ld	a0,136(sp)
[ 569] 0x900000001fc0cda4:  10 00 02 2c b		0x900000001fc0d658
[ 569] 0x900000001fc0cda8:  df bf 00 40 ld	ra,64(sp)
[ 534] 0x900000001fc0cdac:  df b1 00 48 ld	s1,72(sp)
[ 534] 0x900000001fc0cdb0:  0f f0 15 94 jal		run_cached
[ 534] 0x900000001fc0cdb4:  de 24 13 28 ld	a0,4904(s1)
[ 536] 0x900000001fc0cdb8:  10 00 02 27 b		0x900000001fc0d658
[ 536] 0x900000001fc0cdbc:  df bf 00 40 ld	ra,64(sp)
[ 651] 0x900000001fc0cdc0:  00 00 38 25 move	a3,zero
[ 651] 0x900000001fc0cdc4:  00 00 30 25 move	a2,zero
[ 651] 0x900000001fc0cdc8:  df b8 00 10 ld	t8,16(sp)
[ 651] 0x900000001fc0cdcc:  00 18 20 00 sll	a0,t8,0
[ 651] 0x900000001fc0cdd0:  df b8 00 18 ld	t8,24(sp)
[ 651] 0x900000001fc0cdd4:  0f f0 19 ce jal		set_unit_enable
[ 651] 0x900000001fc0cdd8:  00 18 28 00 sll	a1,t8,0
[ 652] 0x900000001fc0cddc:  10 00 02 1e b		0x900000001fc0d658
[ 652] 0x900000001fc0cde0:  df bf 00 40 ld	ra,64(sp)
[ 657] 0x900000001fc0cde4:  00 00 38 25 move	a3,zero
[ 657] 0x900000001fc0cde8:  24 06 00 01 li	a2,1
[ 657] 0x900000001fc0cdec:  df b9 00 10 ld	t9,16(sp)
[ 657] 0x900000001fc0cdf0:  00 19 20 00 sll	a0,t9,0
[ 657] 0x900000001fc0cdf4:  df b9 00 18 ld	t9,24(sp)
[ 657] 0x900000001fc0cdf8:  0f f0 19 ce jal		set_unit_enable
[ 657] 0x900000001fc0cdfc:  00 19 28 00 sll	a1,t9,0
[ 658] 0x900000001fc0ce00:  10 00 02 15 b		0x900000001fc0d658
[ 658] 0x900000001fc0ce04:  df bf 00 40 ld	ra,64(sp)
[ 538] 0x900000001fc0ce08:  24 04 00 fd li	a0,253
[ 538] 0x900000001fc0ce0c:  0f f0 15 fd jal		podMode
[ 538] 0x900000001fc0ce10:  df a5 00 90 ld	a1,144(sp)
[ 541] 0x900000001fc0ce14:  10 00 02 10 b		0x900000001fc0d658
[ 541] 0x900000001fc0ce18:  df bf 00 40 ld	ra,64(sp)
[ 354] 0x900000001fc0ce1c:  67 a4 01 a0 daddiu	a0,sp,416
[ 354] 0x900000001fc0ce20:  df a1 00 10 ld	at,16(sp)
[ 354] 0x900000001fc0ce24:  0f f0 1d c0 jal		dump_evcfg
[ 354] 0x900000001fc0ce28:  00 01 28 00 sll	a1,at,0
[ 355] 0x900000001fc0ce2c:  10 00 02 0a b		0x900000001fc0d658
[ 355] 0x900000001fc0ce30:  df bf 00 40 ld	ra,64(sp)
[ 355] 0x900000001fc0ce34:  df bf 00 10 ld	ra,16(sp)
[ 329] 0x900000001fc0ce38:  33 ff 00 ff andi	ra,ra,0xff
[ 329] 0x900000001fc0ce3c:  df a4 00 98 ld	a0,152(sp)
[ 329] 0x900000001fc0ce40:  a2 7f 00 16 sb	ra,22(s3)
[ 329] 0x900000001fc0ce44:  0f f0 2c e3 jal		loprintf
[ 329] 0x900000001fc0ce48:  92 65 00 16 lbu	a1,22(s3)
[ 330] 0x900000001fc0ce4c:  10 00 02 02 b		0x900000001fc0d658
[ 330] 0x900000001fc0ce50:  df bf 00 40 ld	ra,64(sp)
[ 654] 0x900000001fc0ce54:  24 07 00 01 li	a3,1
[ 654] 0x900000001fc0ce58:  00 00 30 25 move	a2,zero
[ 654] 0x900000001fc0ce5c:  df a1 00 10 ld	at,16(sp)
[ 654] 0x900000001fc0ce60:  00 01 20 00 sll	a0,at,0
[ 654] 0x900000001fc0ce64:  df a1 00 18 ld	at,24(sp)
[ 654] 0x900000001fc0ce68:  0f f0 19 ce jal		set_unit_enable
[ 654] 0x900000001fc0ce6c:  00 01 28 00 sll	a1,at,0
[ 655] 0x900000001fc0ce70:  10 00 01 f9 b		0x900000001fc0d658
[ 655] 0x900000001fc0ce74:  df bf 00 40 ld	ra,64(sp)
[ 660] 0x900000001fc0ce78:  24 07 00 01 li	a3,1
[ 660] 0x900000001fc0ce7c:  24 06 00 01 li	a2,1
[ 660] 0x900000001fc0ce80:  df a8 00 10 ld	a4,16(sp)
[ 660] 0x900000001fc0ce84:  00 08 20 00 sll	a0,a4,0
[ 660] 0x900000001fc0ce88:  df a8 00 18 ld	a4,24(sp)
[ 660] 0x900000001fc0ce8c:  0f f0 19 ce jal		set_unit_enable
[ 660] 0x900000001fc0ce90:  00 08 28 00 sll	a1,a4,0
[ 661] 0x900000001fc0ce94:  10 00 01 f0 b		0x900000001fc0d658
[ 661] 0x900000001fc0ce98:  df bf 00 40 ld	ra,64(sp)
[ 585] 0x900000001fc0ce9c:  0f f0 2b 7a jal		zap_inventory
[ 585] 0x900000001fc0cea0:  00 00 00 21 nada
[ 586] 0x900000001fc0cea4:  10 00 01 ec b		0x900000001fc0d658
[ 586] 0x900000001fc0cea8:  df bf 00 40 ld	ra,64(sp)
[ 357] 0x900000001fc0ceac:  df a9 00 10 ld	a5,16(sp)
[ 357] 0x900000001fc0ceb0:  0f f0 1e 0a jal		dump_mpconf
[ 357] 0x900000001fc0ceb4:  00 09 20 00 sll	a0,a5,0
[ 358] 0x900000001fc0ceb8:  10 00 01 e7 b		0x900000001fc0d658
[ 358] 0x900000001fc0cebc:  df bf 00 40 ld	ra,64(sp)
[ 361] 0x900000001fc0cec0:  00 00 30 25 move	a2,zero
[ 361] 0x900000001fc0cec4:  00 00 28 25 move	a1,zero
[ 361] 0x900000001fc0cec8:  df aa 00 10 ld	a6,16(sp)
[ 361] 0x900000001fc0cecc:  0f f0 20 b7 jal		dumpPrimaryDataLine
[ 361] 0x900000001fc0ced0:  00 0a 20 00 sll	a0,a6,0
[ 362] 0x900000001fc0ced4:  00 00 30 25 move	a2,zero
[ 362] 0x900000001fc0ced8:  02 40 28 25 move	a1,s2
[ 362] 0x900000001fc0cedc:  df aa 00 10 ld	a6,16(sp)
[ 362] 0x900000001fc0cee0:  0f f0 20 b7 jal		dumpPrimaryDataLine
[ 362] 0x900000001fc0cee4:  00 0a 20 00 sll	a0,a6,0
[ 363] 0x900000001fc0cee8:  10 00 01 db b		0x900000001fc0d658
[ 363] 0x900000001fc0ceec:  df bf 00 40 ld	ra,64(sp)
[ 366] 0x900000001fc0cef0:  02 40 30 25 move	a2,s2
[ 366] 0x900000001fc0cef4:  00 00 28 25 move	a1,zero
[ 366] 0x900000001fc0cef8:  df ab 00 10 ld	a7,16(sp)
[ 366] 0x900000001fc0cefc:  0f f0 20 b7 jal		dumpPrimaryDataLine
[ 366] 0x900000001fc0cf00:  00 0b 20 00 sll	a0,a7,0
[ 367] 0x900000001fc0cf04:  02 40 30 25 move	a2,s2
[ 367] 0x900000001fc0cf08:  02 40 28 25 move	a1,s2
[ 367] 0x900000001fc0cf0c:  df ab 00 10 ld	a7,16(sp)
[ 367] 0x900000001fc0cf10:  0f f0 20 b7 jal		dumpPrimaryDataLine
[ 367] 0x900000001fc0cf14:  00 0b 20 00 sll	a0,a7,0
[ 368] 0x900000001fc0cf18:  10 00 01 cf b		0x900000001fc0d658
[ 368] 0x900000001fc0cf1c:  df bf 00 40 ld	ra,64(sp)
[ 371] 0x900000001fc0cf20:  00 00 30 25 move	a2,zero
[ 371] 0x900000001fc0cf24:  00 00 28 25 move	a1,zero
[ 371] 0x900000001fc0cf28:  df ac 00 10 ld	t0,16(sp)
[ 371] 0x900000001fc0cf2c:  0f f0 20 6d jal		dumpPrimaryInstructionLine
[ 371] 0x900000001fc0cf30:  00 0c 20 00 sll	a0,t0,0
[ 372] 0x900000001fc0cf34:  00 00 30 25 move	a2,zero
[ 372] 0x900000001fc0cf38:  02 40 28 25 move	a1,s2
[ 372] 0x900000001fc0cf3c:  df ac 00 10 ld	t0,16(sp)
[ 372] 0x900000001fc0cf40:  0f f0 20 6d jal		dumpPrimaryInstructionLine
[ 372] 0x900000001fc0cf44:  00 0c 20 00 sll	a0,t0,0
[ 373] 0x900000001fc0cf48:  10 00 01 c3 b		0x900000001fc0d658
[ 373] 0x900000001fc0cf4c:  df bf 00 40 ld	ra,64(sp)
[ 376] 0x900000001fc0cf50:  02 40 30 25 move	a2,s2
[ 376] 0x900000001fc0cf54:  00 00 28 25 move	a1,zero
[ 376] 0x900000001fc0cf58:  df ad 00 10 ld	t1,16(sp)
[ 376] 0x900000001fc0cf5c:  0f f0 20 6d jal		dumpPrimaryInstructionLine
[ 376] 0x900000001fc0cf60:  00 0d 20 00 sll	a0,t1,0
[ 377] 0x900000001fc0cf64:  02 40 30 25 move	a2,s2
[ 377] 0x900000001fc0cf68:  02 40 28 25 move	a1,s2
[ 377] 0x900000001fc0cf6c:  df ad 00 10 ld	t1,16(sp)
[ 377] 0x900000001fc0cf70:  0f f0 20 6d jal		dumpPrimaryInstructionLine
[ 377] 0x900000001fc0cf74:  00 0d 20 00 sll	a0,t1,0
[ 378] 0x900000001fc0cf78:  10 00 01 b7 b		0x900000001fc0d658
[ 378] 0x900000001fc0cf7c:  df bf 00 40 ld	ra,64(sp)
[ 381] 0x900000001fc0cf80:  00 00 30 25 move	a2,zero
[ 381] 0x900000001fc0cf84:  00 00 28 25 move	a1,zero
[ 381] 0x900000001fc0cf88:  df ae 00 10 ld	t2,16(sp)
[ 381] 0x900000001fc0cf8c:  0f f0 20 36 jal		dumpSecondaryLine
[ 381] 0x900000001fc0cf90:  00 0e 20 00 sll	a0,t2,0
[ 382] 0x900000001fc0cf94:  00 00 30 25 move	a2,zero
[ 382] 0x900000001fc0cf98:  02 40 28 25 move	a1,s2
[ 382] 0x900000001fc0cf9c:  df ae 00 10 ld	t2,16(sp)
[ 382] 0x900000001fc0cfa0:  0f f0 20 36 jal		dumpSecondaryLine
[ 382] 0x900000001fc0cfa4:  00 0e 20 00 sll	a0,t2,0
[ 383] 0x900000001fc0cfa8:  10 00 01 ab b		0x900000001fc0d658
[ 383] 0x900000001fc0cfac:  df bf 00 40 ld	ra,64(sp)
[ 386] 0x900000001fc0cfb0:  02 40 30 25 move	a2,s2
[ 386] 0x900000001fc0cfb4:  00 00 28 25 move	a1,zero
[ 386] 0x900000001fc0cfb8:  df af 00 10 ld	t3,16(sp)
[ 386] 0x900000001fc0cfbc:  0f f0 20 36 jal		dumpSecondaryLine
[ 386] 0x900000001fc0cfc0:  00 0f 20 00 sll	a0,t3,0
[ 387] 0x900000001fc0cfc4:  02 40 30 25 move	a2,s2
[ 387] 0x900000001fc0cfc8:  02 40 28 25 move	a1,s2
[ 387] 0x900000001fc0cfcc:  df af 00 10 ld	t3,16(sp)
[ 387] 0x900000001fc0cfd0:  0f f0 20 36 jal		dumpSecondaryLine
[ 387] 0x900000001fc0cfd4:  00 0f 20 00 sll	a0,t3,0
[ 388] 0x900000001fc0cfd8:  10 00 01 9f b		0x900000001fc0d658
[ 388] 0x900000001fc0cfdc:  df bf 00 40 ld	ra,64(sp)
[ 420] 0x900000001fc0cfe0:  0f f0 21 2e jal		dumpSecondaryCache
[ 420] 0x900000001fc0cfe4:  02 40 20 25 move	a0,s2
[ 421] 0x900000001fc0cfe8:  10 00 01 9b b		0x900000001fc0d658
[ 421] 0x900000001fc0cfec:  df bf 00 40 ld	ra,64(sp)
[ 424] 0x900000001fc0cff0:  0f f0 21 02 jal		dumpPrimaryCache
[ 424] 0x900000001fc0cff4:  02 40 20 25 move	a0,s2
[ 425] 0x900000001fc0cff8:  10 00 01 97 b		0x900000001fc0d658
[ 425] 0x900000001fc0cffc:  df bf 00 40 ld	ra,64(sp)
[ 425] 0x900000001fc0d000:  df b0 00 10 ld	s0,16(sp)
[ 666] 0x900000001fc0d004:  00 10 20 00 sll	a0,s0,0
[ 666] 0x900000001fc0d008:  df b0 00 18 ld	s0,24(sp)
[ 666] 0x900000001fc0d00c:  0f f0 27 23 jal		dumpSlice
[ 666] 0x900000001fc0d010:  00 10 28 00 sll	a1,s0,0
[ 667] 0x900000001fc0d014:  10 00 01 90 b		0x900000001fc0d658
[ 667] 0x900000001fc0d018:  df bf 00 40 ld	ra,64(sp)
[ 672] 0x900000001fc0d01c:  0f f0 59 d9 jal		wait
[ 672] 0x900000001fc0d020:  00 00 00 21 nada
[ 673] 0x900000001fc0d024:  10 00 01 8c b		0x900000001fc0d658
[ 673] 0x900000001fc0d028:  df bf 00 40 ld	ra,64(sp)
[ 464] 0x900000001fc0d02c:  df b8 00 48 ld	t8,72(sp)
[ 464] 0x900000001fc0d030:  df a7 00 18 ld	a3,24(sp)
[ 464] 0x900000001fc0d034:  02 a0 40 25 move	a4,s5
[ 464] 0x900000001fc0d038:  00 00 28 25 move	a1,zero
[ 464] 0x900000001fc0d03c:  02 40 20 25 move	a0,s2
[ 464] 0x900000001fc0d040:  df b1 00 10 ld	s1,16(sp)
[ 464] 0x900000001fc0d044:  df 18 13 10 ld	t8,4880(t8)
[ 464] 0x900000001fc0d048:  0f f0 25 0d jal		memory
[ 464] 0x900000001fc0d04c:  02 38 30 25 or	a2,s1,t8
[ 466] 0x900000001fc0d050:  10 00 01 81 b		0x900000001fc0d658
[ 466] 0x900000001fc0d054:  df bf 00 40 ld	ra,64(sp)
[ 468] 0x900000001fc0d058:  df bf 00 48 ld	ra,72(sp)
[ 468] 0x900000001fc0d05c:  df a7 00 18 ld	a3,24(sp)
[ 468] 0x900000001fc0d060:  02 a0 40 25 move	a4,s5
[ 468] 0x900000001fc0d064:  02 40 28 25 move	a1,s2
[ 468] 0x900000001fc0d068:  02 40 20 25 move	a0,s2
[ 468] 0x900000001fc0d06c:  df b9 00 10 ld	t9,16(sp)
[ 468] 0x900000001fc0d070:  df e1 13 10 ld	at,4880(ra)
[ 468] 0x900000001fc0d074:  0f f0 25 0d jal		memory
[ 468] 0x900000001fc0d078:  03 21 30 25 or	a2,t9,at
[ 470] 0x900000001fc0d07c:  10 00 01 76 b		0x900000001fc0d658
[ 470] 0x900000001fc0d080:  df bf 00 40 ld	ra,64(sp)
[ 472] 0x900000001fc0d084:  df a2 00 48 ld	v0,72(sp)
[ 472] 0x900000001fc0d088:  df a7 00 18 ld	a3,24(sp)
[ 472] 0x900000001fc0d08c:  02 a0 40 25 move	a4,s5
[ 472] 0x900000001fc0d090:  24 05 00 02 li	a1,2
[ 472] 0x900000001fc0d094:  02 40 20 25 move	a0,s2
[ 472] 0x900000001fc0d098:  df a1 00 10 ld	at,16(sp)
[ 472] 0x900000001fc0d09c:  dc 42 13 10 ld	v0,4880(v0)
[ 472] 0x900000001fc0d0a0:  0f f0 25 0d jal		memory
[ 472] 0x900000001fc0d0a4:  00 22 30 25 or	a2,at,v0
[ 474] 0x900000001fc0d0a8:  10 00 01 6b b		0x900000001fc0d658
[ 474] 0x900000001fc0d0ac:  df bf 00 40 ld	ra,64(sp)
[ 476] 0x900000001fc0d0b0:  df aa 00 48 ld	a6,72(sp)
[ 476] 0x900000001fc0d0b4:  df a7 00 18 ld	a3,24(sp)
[ 476] 0x900000001fc0d0b8:  02 a0 40 25 move	a4,s5
[ 476] 0x900000001fc0d0bc:  24 05 00 03 li	a1,3
[ 476] 0x900000001fc0d0c0:  02 40 20 25 move	a0,s2
[ 476] 0x900000001fc0d0c4:  df a9 00 10 ld	a5,16(sp)
[ 476] 0x900000001fc0d0c8:  dd 4a 13 10 ld	a6,4880(a6)
[ 476] 0x900000001fc0d0cc:  0f f0 25 0d jal		memory
[ 476] 0x900000001fc0d0d0:  01 2a 30 25 or	a2,a5,a6
[ 478] 0x900000001fc0d0d4:  10 00 01 60 b		0x900000001fc0d658
[ 478] 0x900000001fc0d0d8:  df bf 00 40 ld	ra,64(sp)
[ 480] 0x900000001fc0d0dc:  02 a0 40 25 move	a4,s5
[ 480] 0x900000001fc0d0e0:  df ac 00 48 ld	t0,72(sp)
[ 480] 0x900000001fc0d0e4:  00 00 38 25 move	a3,zero
[ 480] 0x900000001fc0d0e8:  00 00 28 25 move	a1,zero
[ 480] 0x900000001fc0d0ec:  00 00 20 25 move	a0,zero
[ 480] 0x900000001fc0d0f0:  df ab 00 10 ld	a7,16(sp)
[ 480] 0x900000001fc0d0f4:  dd 8c 13 10 ld	t0,4880(t0)
[ 480] 0x900000001fc0d0f8:  0f f0 25 0d jal		memory
[ 480] 0x900000001fc0d0fc:  01 6c 30 25 or	a2,a7,t0
[ 481] 0x900000001fc0d100:  10 00 01 55 b		0x900000001fc0d658
[ 481] 0x900000001fc0d104:  df bf 00 40 ld	ra,64(sp)
[ 483] 0x900000001fc0d108:  02 a0 40 25 move	a4,s5
[ 483] 0x900000001fc0d10c:  df ae 00 48 ld	t2,72(sp)
[ 483] 0x900000001fc0d110:  00 00 38 25 move	a3,zero
[ 483] 0x900000001fc0d114:  02 40 28 25 move	a1,s2
[ 483] 0x900000001fc0d118:  00 00 20 25 move	a0,zero
[ 483] 0x900000001fc0d11c:  df ad 00 10 ld	t1,16(sp)
[ 483] 0x900000001fc0d120:  dd ce 13 10 ld	t2,4880(t2)
[ 483] 0x900000001fc0d124:  0f f0 25 0d jal		memory
[ 483] 0x900000001fc0d128:  01 ae 30 25 or	a2,t1,t2
[ 484] 0x900000001fc0d12c:  10 00 01 4a b		0x900000001fc0d658
[ 484] 0x900000001fc0d130:  df bf 00 40 ld	ra,64(sp)
[ 486] 0x900000001fc0d134:  02 a0 40 25 move	a4,s5
[ 486] 0x900000001fc0d138:  df b0 00 48 ld	s0,72(sp)
[ 486] 0x900000001fc0d13c:  00 00 38 25 move	a3,zero
[ 486] 0x900000001fc0d140:  24 05 00 02 li	a1,2
[ 486] 0x900000001fc0d144:  00 00 20 25 move	a0,zero
[ 486] 0x900000001fc0d148:  df af 00 10 ld	t3,16(sp)
[ 486] 0x900000001fc0d14c:  de 10 13 10 ld	s0,4880(s0)
[ 486] 0x900000001fc0d150:  0f f0 25 0d jal		memory
[ 486] 0x900000001fc0d154:  01 f0 30 25 or	a2,t3,s0
[ 487] 0x900000001fc0d158:  10 00 01 3f b		0x900000001fc0d658
[ 487] 0x900000001fc0d15c:  df bf 00 40 ld	ra,64(sp)
[ 489] 0x900000001fc0d160:  02 a0 40 25 move	a4,s5
[ 489] 0x900000001fc0d164:  df b8 00 48 ld	t8,72(sp)
[ 489] 0x900000001fc0d168:  00 00 38 25 move	a3,zero
[ 489] 0x900000001fc0d16c:  24 05 00 03 li	a1,3
[ 489] 0x900000001fc0d170:  00 00 20 25 move	a0,zero
[ 489] 0x900000001fc0d174:  df b1 00 10 ld	s1,16(sp)
[ 489] 0x900000001fc0d178:  df 18 13 10 ld	t8,4880(t8)
[ 489] 0x900000001fc0d17c:  0f f0 25 0d jal		memory
[ 489] 0x900000001fc0d180:  02 38 30 25 or	a2,s1,t8
[ 490] 0x900000001fc0d184:  10 00 01 34 b		0x900000001fc0d658
[ 490] 0x900000001fc0d188:  df bf 00 40 ld	ra,64(sp)
[ 390] 0x900000001fc0d18c:  00 00 30 25 move	a2,zero
[ 390] 0x900000001fc0d190:  00 00 28 25 move	a1,zero
[ 390] 0x900000001fc0d194:  df b9 00 10 ld	t9,16(sp)
[ 390] 0x900000001fc0d198:  0f f0 20 e5 jal		dumpPrimaryDataLineAddr
[ 390] 0x900000001fc0d19c:  00 19 20 00 sll	a0,t9,0
[ 391] 0x900000001fc0d1a0:  00 00 30 25 move	a2,zero
[ 391] 0x900000001fc0d1a4:  02 40 28 25 move	a1,s2
[ 391] 0x900000001fc0d1a8:  df b9 00 10 ld	t9,16(sp)
[ 391] 0x900000001fc0d1ac:  0f f0 20 e5 jal		dumpPrimaryDataLineAddr
[ 391] 0x900000001fc0d1b0:  00 19 20 00 sll	a0,t9,0
[ 392] 0x900000001fc0d1b4:  10 00 01 28 b		0x900000001fc0d658
[ 392] 0x900000001fc0d1b8:  df bf 00 40 ld	ra,64(sp)
[ 395] 0x900000001fc0d1bc:  02 40 30 25 move	a2,s2
[ 395] 0x900000001fc0d1c0:  00 00 28 25 move	a1,zero
[ 395] 0x900000001fc0d1c4:  df a1 00 10 ld	at,16(sp)
[ 395] 0x900000001fc0d1c8:  0f f0 20 e5 jal		dumpPrimaryDataLineAddr
[ 395] 0x900000001fc0d1cc:  00 01 20 00 sll	a0,at,0
[ 396] 0x900000001fc0d1d0:  02 40 30 25 move	a2,s2
[ 396] 0x900000001fc0d1d4:  02 40 28 25 move	a1,s2
[ 396] 0x900000001fc0d1d8:  df a1 00 10 ld	at,16(sp)
[ 396] 0x900000001fc0d1dc:  0f f0 20 e5 jal		dumpPrimaryDataLineAddr
[ 396] 0x900000001fc0d1e0:  00 01 20 00 sll	a0,at,0
[ 397] 0x900000001fc0d1e4:  10 00 01 1c b		0x900000001fc0d658
[ 397] 0x900000001fc0d1e8:  df bf 00 40 ld	ra,64(sp)
[ 400] 0x900000001fc0d1ec:  00 00 30 25 move	a2,zero
[ 400] 0x900000001fc0d1f0:  00 00 28 25 move	a1,zero
[ 400] 0x900000001fc0d1f4:  df a1 00 10 ld	at,16(sp)
[ 400] 0x900000001fc0d1f8:  0f f0 20 9a jal		dumpPrimaryInstructionLineAddr
[ 400] 0x900000001fc0d1fc:  00 01 20 00 sll	a0,at,0
[ 401] 0x900000001fc0d200:  00 00 30 25 move	a2,zero
[ 401] 0x900000001fc0d204:  02 40 28 25 move	a1,s2
[ 401] 0x900000001fc0d208:  df a1 00 10 ld	at,16(sp)
[ 401] 0x900000001fc0d20c:  0f f0 20 9a jal		dumpPrimaryInstructionLineAddr
[ 401] 0x900000001fc0d210:  00 01 20 00 sll	a0,at,0
[ 402] 0x900000001fc0d214:  10 00 01 10 b		0x900000001fc0d658
[ 402] 0x900000001fc0d218:  df bf 00 40 ld	ra,64(sp)
[ 405] 0x900000001fc0d21c:  02 40 30 25 move	a2,s2
[ 405] 0x900000001fc0d220:  00 00 28 25 move	a1,zero
[ 405] 0x900000001fc0d224:  df a1 00 10 ld	at,16(sp)
[ 405] 0x900000001fc0d228:  0f f0 20 9a jal		dumpPrimaryInstructionLineAddr
[ 405] 0x900000001fc0d22c:  00 01 20 00 sll	a0,at,0
[ 406] 0x900000001fc0d230:  02 40 30 25 move	a2,s2
[ 406] 0x900000001fc0d234:  02 40 28 25 move	a1,s2
[ 406] 0x900000001fc0d238:  df a1 00 10 ld	at,16(sp)
[ 406] 0x900000001fc0d23c:  0f f0 20 9a jal		dumpPrimaryInstructionLineAddr
[ 406] 0x900000001fc0d240:  00 01 20 00 sll	a0,at,0
[ 407] 0x900000001fc0d244:  10 00 01 04 b		0x900000001fc0d658
[ 407] 0x900000001fc0d248:  df bf 00 40 ld	ra,64(sp)
[ 410] 0x900000001fc0d24c:  00 00 30 25 move	a2,zero
[ 410] 0x900000001fc0d250:  00 00 28 25 move	a1,zero
[ 410] 0x900000001fc0d254:  df a1 00 10 ld	at,16(sp)
[ 410] 0x900000001fc0d258:  0f f0 20 51 jal		dumpSecondaryLineAddr
[ 410] 0x900000001fc0d25c:  00 01 20 00 sll	a0,at,0
[ 411] 0x900000001fc0d260:  00 00 30 25 move	a2,zero
[ 411] 0x900000001fc0d264:  02 40 28 25 move	a1,s2
[ 411] 0x900000001fc0d268:  df a1 00 10 ld	at,16(sp)
[ 411] 0x900000001fc0d26c:  0f f0 20 51 jal		dumpSecondaryLineAddr
[ 411] 0x900000001fc0d270:  00 01 20 00 sll	a0,at,0
[ 412] 0x900000001fc0d274:  10 00 00 f8 b		0x900000001fc0d658
[ 412] 0x900000001fc0d278:  df bf 00 40 ld	ra,64(sp)
[ 415] 0x900000001fc0d27c:  02 40 30 25 move	a2,s2
[ 415] 0x900000001fc0d280:  00 00 28 25 move	a1,zero
[ 415] 0x900000001fc0d284:  df a1 00 10 ld	at,16(sp)
[ 415] 0x900000001fc0d288:  0f f0 20 51 jal		dumpSecondaryLineAddr
[ 415] 0x900000001fc0d28c:  00 01 20 00 sll	a0,at,0
[ 416] 0x900000001fc0d290:  02 40 30 25 move	a2,s2
[ 416] 0x900000001fc0d294:  02 40 28 25 move	a1,s2
[ 416] 0x900000001fc0d298:  df a1 00 10 ld	at,16(sp)
[ 416] 0x900000001fc0d29c:  0f f0 20 51 jal		dumpSecondaryLineAddr
[ 416] 0x900000001fc0d2a0:  00 01 20 00 sll	a0,at,0
[ 417] 0x900000001fc0d2a4:  10 00 00 ec b		0x900000001fc0d658
[ 417] 0x900000001fc0d2a8:  df bf 00 40 ld	ra,64(sp)
[ 417] 0x900000001fc0d2ac:  df a4 00 10 ld	a0,16(sp)
[ 432] 0x900000001fc0d2b0:  0f f0 2b 94 jal		testScacheFlipBits
[ 432] 0x900000001fc0d2b4:  02 40 28 25 move	a1,s2
[ 433] 0x900000001fc0d2b8:  10 00 00 e7 b		0x900000001fc0d658
[ 433] 0x900000001fc0d2bc:  df bf 00 40 ld	ra,64(sp)
[ 433] 0x900000001fc0d2c0:  df a4 00 10 ld	a0,16(sp)
[ 436] 0x900000001fc0d2c4:  0f f0 2b 94 jal		testScacheFlipBits
[ 436] 0x900000001fc0d2c8:  00 00 28 25 move	a1,zero
[ 437] 0x900000001fc0d2cc:  10 00 00 e2 b		0x900000001fc0d658
[ 437] 0x900000001fc0d2d0:  df bf 00 40 ld	ra,64(sp)
[ 675] 0x900000001fc0d2d4:  00 00 28 25 move	a1,zero
[ 675] 0x900000001fc0d2d8:  0f f0 21 ea jal		compareSecondaryTags
[ 675] 0x900000001fc0d2dc:  00 00 20 25 move	a0,zero
[ 676] 0x900000001fc0d2e0:  10 00 00 dd b		0x900000001fc0d658
[ 676] 0x900000001fc0d2e4:  df bf 00 40 ld	ra,64(sp)
[ 678] 0x900000001fc0d2e8:  00 00 28 25 move	a1,zero
[ 678] 0x900000001fc0d2ec:  0f f0 21 ea jal		compareSecondaryTags
[ 678] 0x900000001fc0d2f0:  02 40 20 25 move	a0,s2
[ 679] 0x900000001fc0d2f4:  10 00 00 d8 b		0x900000001fc0d658
[ 679] 0x900000001fc0d2f8:  df bf 00 40 ld	ra,64(sp)
[ 681] 0x900000001fc0d2fc:  02 40 28 25 move	a1,s2
[ 681] 0x900000001fc0d300:  0f f0 21 ea jal		compareSecondaryTags
[ 681] 0x900000001fc0d304:  00 00 20 25 move	a0,zero
[ 682] 0x900000001fc0d308:  10 00 00 d3 b		0x900000001fc0d658
[ 682] 0x900000001fc0d30c:  df bf 00 40 ld	ra,64(sp)
[ 684] 0x900000001fc0d310:  02 40 28 25 move	a1,s2
[ 684] 0x900000001fc0d314:  0f f0 21 ea jal		compareSecondaryTags
[ 684] 0x900000001fc0d318:  02 40 20 25 move	a0,s2
[ 685] 0x900000001fc0d31c:  10 00 00 ce b		0x900000001fc0d658
[ 685] 0x900000001fc0d320:  df bf 00 40 ld	ra,64(sp)
[ 428] 0x900000001fc0d324:  df bf 00 48 ld	ra,72(sp)
[ 428] 0x900000001fc0d328:  df a1 00 10 ld	at,16(sp)
[ 428] 0x900000001fc0d32c:  df e2 13 08 ld	v0,4872(ra)
[ 428] 0x900000001fc0d330:  0f f0 22 2e jal		setSecondaryECC
[ 428] 0x900000001fc0d334:  00 22 20 25 or	a0,at,v0
[ 429] 0x900000001fc0d338:  10 00 00 c7 b		0x900000001fc0d658
[ 429] 0x900000001fc0d33c:  df bf 00 40 ld	ra,64(sp)
[ 663] 0x900000001fc0d340:  df a1 00 10 ld	at,16(sp)
[ 663] 0x900000001fc0d344:  0f f0 27 69 jal		dumpSlot
[ 663] 0x900000001fc0d348:  00 01 20 00 sll	a0,at,0
[ 664] 0x900000001fc0d34c:  10 00 00 c2 b		0x900000001fc0d658
[ 664] 0x900000001fc0d350:  df bf 00 40 ld	ra,64(sp)
[ 669] 0x900000001fc0d354:  0f f0 27 f4 jal		dumpAll
[ 669] 0x900000001fc0d358:  00 00 00 21 nada
[ 670] 0x900000001fc0d35c:  10 00 00 be b		0x900000001fc0d658
[ 670] 0x900000001fc0d360:  df bf 00 40 ld	ra,64(sp)
[ 670] 0x900000001fc0d364:  df a4 00 10 ld	a0,16(sp)
[ 687] 0x900000001fc0d368:  67 a6 02 a0 daddiu	a2,sp,672
[ 687] 0x900000001fc0d36c:  0f f0 28 12 jal		margin
[ 687] 0x900000001fc0d370:  67 a5 02 20 daddiu	a1,sp,544
[ 688] 0x900000001fc0d374:  10 00 00 b8 b		0x900000001fc0d658
[ 688] 0x900000001fc0d378:  df bf 00 40 ld	ra,64(sp)
[ 688] 0x900000001fc0d37c:  3c 08 90 00 lui	a4,0x9000
[ 688] 0x900000001fc0d380:  00 00 88 25 move	s1,zero
[ 688] 0x900000001fc0d384:  df a7 00 10 ld	a3,16(sp)
[ 527] 0x900000001fc0d388:  50 e0 00 b3 beql	a3,zero,0x900000001fc0d658
[ 527] 0x900000001fc0d38c:  df bf 00 40 ld	ra,64(sp)
[ 527] 0x900000001fc0d390:  61 08 00 00 daddi	a4,a4,0
[ 527] 0x900000001fc0d394:  3c 09 1f c2 lui	a5,0x1fc2
[ 527] 0x900000001fc0d398:  61 29 bb c0 daddi	a5,a5,-17472
[ 527] 0x900000001fc0d39c:  00 08 40 3c dsll32	a4,a4,0
[ 527] 0x900000001fc0d3a0:  01 09 40 2c dadd	a4,a4,a5
[ 527] 0x900000001fc0d3a4:  ff a8 00 48 sd	a4,72(sp)
[ 527] 0x900000001fc0d3a8:  dd 10 13 48 ld	s0,4936(a4)
[ 527] 0x900000001fc0d3ac:  02 00 28 25 move	a1,s0
[ 529] 0x900000001fc0d3b0:  de 06 00 00 ld	a2,0(s0)
[ 529] 0x900000001fc0d3b4:  66 10 00 08 daddiu	s0,s0,8
[ 529] 0x900000001fc0d3b8:  0f f0 2c e3 jal		loprintf
[ 529] 0x900000001fc0d3bc:  02 e0 20 25 move	a0,s7
[ 527] 0x900000001fc0d3c0:  df aa 00 10 ld	a6,16(sp)
[ 527] 0x900000001fc0d3c4:  26 31 00 01 addiu	s1,s1,1
[ 527] 0x900000001fc0d3c8:  02 2a 50 2b sltu	a6,s1,a6
[ 527] 0x900000001fc0d3cc:  15 40 ff f8 bne	a6,zero,0x900000001fc0d3b0
[ 527] 0x900000001fc0d3d0:  02 00 28 25 move	a1,s0
[ 528] 0x900000001fc0d3d4:  10 00 00 9f b		0x900000001fc0d654
[ 528] 0x900000001fc0d3d8:  00 00 00 21 nada
[ 520] 0x900000001fc0d3dc:  52 00 00 9e beql	s0,zero,0x900000001fc0d658
[ 520] 0x900000001fc0d3e0:  df bf 00 40 ld	ra,64(sp)
[ 520] 0x900000001fc0d3e4:  3c 0b 90 00 lui	a7,0x9000
[ 520] 0x900000001fc0d3e8:  61 6b 00 00 daddi	a7,a7,0
[ 520] 0x900000001fc0d3ec:  3c 0c 1f c2 lui	t0,0x1fc2
[ 520] 0x900000001fc0d3f0:  61 8c bb c0 daddi	t0,t0,-17472
[ 520] 0x900000001fc0d3f4:  00 0b 58 3c dsll32	a7,a7,0
[ 520] 0x900000001fc0d3f8:  01 6c 58 2c dadd	a7,a7,t0
[ 520] 0x900000001fc0d3fc:  ff ab 00 48 sd	a7,72(sp)
[ 520] 0x900000001fc0d400:  dd 70 13 50 ld	s0,4944(a7)
[ 520] 0x900000001fc0d404:  02 00 28 25 move	a1,s0
[ 522] 0x900000001fc0d408:  de 06 00 00 ld	a2,0(s0)
[ 522] 0x900000001fc0d40c:  66 10 00 08 daddiu	s0,s0,8
[ 522] 0x900000001fc0d410:  0f f0 2c e3 jal		loprintf
[ 522] 0x900000001fc0d414:  03 c0 20 25 move	a0,s8
[ 520] 0x900000001fc0d418:  df ad 00 10 ld	t1,16(sp)
[ 520] 0x900000001fc0d41c:  26 31 00 01 addiu	s1,s1,1
[ 520] 0x900000001fc0d420:  02 2d 68 2b sltu	t1,s1,t1
[ 520] 0x900000001fc0d424:  15 a0 ff f8 bne	t1,zero,0x900000001fc0d408
[ 520] 0x900000001fc0d428:  02 00 28 25 move	a1,s0
[ 521] 0x900000001fc0d42c:  10 00 00 89 b		0x900000001fc0d654
[ 521] 0x900000001fc0d430:  00 00 00 21 nada
[ 335] 0x900000001fc0d434:  8e 6e 00 00 lw	t2,0(s3)
[ 335] 0x900000001fc0d438:  15 c0 00 05 bne	t2,zero,0x900000001fc0d450
[ 335] 0x900000001fc0d43c:  00 00 00 21 nada
[ 339] 0x900000001fc0d440:  0f f0 1b ee jal		pod_bist
[ 339] 0x900000001fc0d444:  00 00 00 21 nada
[ 339] 0x900000001fc0d448:  10 00 00 83 b		0x900000001fc0d658
[ 339] 0x900000001fc0d44c:  df bf 00 40 ld	ra,64(sp)
[ 336] 0x900000001fc0d450:  0f f0 2c e3 jal		loprintf
[ 336] 0x900000001fc0d454:  df a4 00 a0 ld	a0,160(sp)
[ 336] 0x900000001fc0d458:  10 00 00 7f b		0x900000001fc0d658
[ 336] 0x900000001fc0d45c:  df bf 00 40 ld	ra,64(sp)
[ 343] 0x900000001fc0d460:  8e 6f 00 00 lw	t3,0(s3)
[ 343] 0x900000001fc0d464:  15 e0 00 05 bne	t3,zero,0x900000001fc0d47c
[ 343] 0x900000001fc0d468:  00 00 00 21 nada
[ 347] 0x900000001fc0d46c:  0f f0 1a e3 jal		pod_reconf_mem
[ 347] 0x900000001fc0d470:  00 00 00 21 nada
[ 347] 0x900000001fc0d474:  10 00 00 78 b		0x900000001fc0d658
[ 347] 0x900000001fc0d478:  df bf 00 40 ld	ra,64(sp)
[ 344] 0x900000001fc0d47c:  0f f0 2c e3 jal		loprintf
[ 344] 0x900000001fc0d480:  df a4 00 a8 ld	a0,168(sp)
[ 344] 0x900000001fc0d484:  10 00 00 74 b		0x900000001fc0d658
[ 344] 0x900000001fc0d488:  df bf 00 40 ld	ra,64(sp)
[ 641] 0x900000001fc0d48c:  ff a0 00 20 sd	zero,32(sp)
[ 642] 0x900000001fc0d490:  02 60 38 25 move	a3,s3
[ 642] 0x900000001fc0d494:  df b0 00 18 ld	s0,24(sp)
[ 642] 0x900000001fc0d498:  df a4 00 10 ld	a0,16(sp)
[ 642] 0x900000001fc0d49c:  00 10 28 00 sll	a1,s0,0
[ 642] 0x900000001fc0d4a0:  df b0 00 20 ld	s0,32(sp)
[ 642] 0x900000001fc0d4a4:  0f f0 2b 49 jal		jump_addr
[ 642] 0x900000001fc0d4a8:  00 10 30 00 sll	a2,s0,0
[ 642] 0x900000001fc0d4ac:  00 40 28 25 move	a1,v0
[ 642] 0x900000001fc0d4b0:  0f f0 2c e3 jal		loprintf
[ 642] 0x900000001fc0d4b4:  df a4 00 b0 ld	a0,176(sp)
[ 645] 0x900000001fc0d4b8:  10 00 00 67 b		0x900000001fc0d658
[ 645] 0x900000001fc0d4bc:  df bf 00 40 ld	ra,64(sp)
[ 454] 0x900000001fc0d4c0:  0f f0 2c e3 jal		loprintf
[ 454] 0x900000001fc0d4c4:  df a4 00 b8 ld	a0,184(sp)
[ 456] 0x900000001fc0d4c8:  0f f0 2c e3 jal		loprintf
[ 456] 0x900000001fc0d4cc:  df a4 00 c0 ld	a0,192(sp)
[ 458] 0x900000001fc0d4d0:  df b0 00 50 ld	s0,80(sp)
[ 458] 0x900000001fc0d4d4:  df b1 00 48 ld	s1,72(sp)
[ 458] 0x900000001fc0d4d8:  de 38 0c 48 ld	t8,3144(s1)
[ 458] 0x900000001fc0d4dc:  03 00 88 25 move	s1,t8
[ 458] 0x900000001fc0d4e0:  8f 18 00 00 lw	t8,0(t8)
[ 458] 0x900000001fc0d4e4:  53 00 00 5c beql	t8,zero,0x900000001fc0d658
[ 458] 0x900000001fc0d4e8:  df bf 00 40 ld	ra,64(sp)
[ 459] 0x900000001fc0d4ec:  0f f0 0d 88 jal		get_char
[ 459] 0x900000001fc0d4f0:  de 04 00 00 ld	a0,0(s0)
[ 459] 0x900000001fc0d4f4:  50 40 00 05 beql	v0,zero,0x900000001fc0d50c
[ 459] 0x900000001fc0d4f8:  8e 39 00 18 lw	t9,24(s1)
[ 460] 0x900000001fc0d4fc:  de 05 00 00 ld	a1,0(s0)
[ 460] 0x900000001fc0d500:  0f f0 2c e3 jal		loprintf
[ 460] 0x900000001fc0d504:  df a4 00 58 ld	a0,88(sp)
[ 460] 0x900000001fc0d508:  8e 39 00 18 lw	t9,24(s1)
[ 458] 0x900000001fc0d50c:  66 10 00 18 daddiu	s0,s0,24
[ 458] 0x900000001fc0d510:  17 20 ff f6 bne	t9,zero,0x900000001fc0d4ec
[ 458] 0x900000001fc0d514:  66 31 00 18 daddiu	s1,s1,24
[ 458] 0x900000001fc0d518:  10 00 00 4e b		0x900000001fc0d654
[ 458] 0x900000001fc0d51c:  00 00 00 21 nada
[ 458] 0x900000001fc0d520:  00 00 88 25 move	s1,zero
[ 589] 0x900000001fc0d524:  8f bf 02 20 lw	ra,544(sp)
[ 589] 0x900000001fc0d528:  24 01 00 28 li	at,40
[ 589] 0x900000001fc0d52c:  df b0 00 10 ld	s0,16(sp)
[ 589] 0x900000001fc0d530:  57 e1 00 2d bnel	ra,at,0x900000001fc0d5e8
[ 589] 0x900000001fc0d534:  df b7 00 d8 ld	s7,216(sp)
[ 593] 0x900000001fc0d538:  52 00 00 21 beql	s0,zero,0x900000001fc0d5c0
[ 593] 0x900000001fc0d53c:  df be 00 d0 ld	s8,208(sp)
[ 598] 0x900000001fc0d540:  52 00 00 10 beql	s0,zero,0x900000001fc0d584
[ 598] 0x900000001fc0d544:  67 a4 00 00 daddiu	a0,sp,0
[ 599] 0x900000001fc0d548:  02 60 40 25 move	a4,s3
[ 599] 0x900000001fc0d54c:  00 00 38 25 move	a3,zero
[ 599] 0x900000001fc0d550:  df a4 00 00 ld	a0,0(sp)
[ 599] 0x900000001fc0d554:  02 c0 30 25 move	a2,s6
[ 599] 0x900000001fc0d558:  0f f0 31 ec jal		pod_parse
[ 599] 0x900000001fc0d55c:  02 80 28 25 move	a1,s4
[ 599] 0x900000001fc0d560:  00 40 c8 25 move	t9,v0
[ 601] 0x900000001fc0d564:  df a1 00 10 ld	at,16(sp)
[ 601] 0x900000001fc0d568:  26 31 00 01 addiu	s1,s1,1
[ 601] 0x900000001fc0d56c:  02 21 80 2b sltu	s0,s1,at
[ 601] 0x900000001fc0d570:  13 20 00 0a beq	t9,zero,0x900000001fc0d59c
[ 601] 0x900000001fc0d574:  ff b9 00 08 sd	t9,8(sp)
[ 598] 0x900000001fc0d578:  56 00 ff f4 bnel	s0,zero,0x900000001fc0d54c
[ 598] 0x900000001fc0d57c:  02 60 40 25 move	a4,s3
[ 605] 0x900000001fc0d580:  67 a4 00 00 daddiu	a0,sp,0
[ 605] 0x900000001fc0d584:  df a9 00 08 ld	a5,8(sp)
[ 604] 0x900000001fc0d588:  0f f0 31 d5 jal		check_eol
[ 604] 0x900000001fc0d58c:  ff a9 00 00 sd	a5,0(sp)
[ 608] 0x900000001fc0d590:  ff a2 00 c8 sd	v0,200(sp)
[ 608] 0x900000001fc0d594:  10 00 00 30 b		0x900000001fc0d658
[ 608] 0x900000001fc0d598:  df bf 00 40 ld	ra,64(sp)
[ 608] 0x900000001fc0d59c:  03 20 10 25 move	v0,t9
[ 608] 0x900000001fc0d5a0:  df b1 01 08 ld	s1,264(sp)
[ 608] 0x900000001fc0d5a4:  df b6 00 e0 ld	s6,224(sp)
[ 608] 0x900000001fc0d5a8:  df b7 00 d8 ld	s7,216(sp)
[ 608] 0x900000001fc0d5ac:  df b2 01 00 ld	s2,256(sp)
[ 608] 0x900000001fc0d5b0:  df be 00 d0 ld	s8,208(sp)
[ 602] 0x900000001fc0d5b4:  10 00 00 81 b		0x900000001fc0d7bc
[ 602] 0x900000001fc0d5b8:  df b0 01 10 ld	s0,272(sp)
[ 602] 0x900000001fc0d5bc:  df be 00 d0 ld	s8,208(sp)
[ 594] 0x900000001fc0d5c0:  df aa 00 48 ld	a6,72(sp)
[ 594] 0x900000001fc0d5c4:  df b6 00 e0 ld	s6,224(sp)
[ 594] 0x900000001fc0d5c8:  df b7 00 d8 ld	s7,216(sp)
[ 594] 0x900000001fc0d5cc:  0f f0 2c e3 jal		loprintf
[ 594] 0x900000001fc0d5d0:  65 44 12 b0 daddiu	a0,a6,4784
[ 595] 0x900000001fc0d5d4:  00 00 10 25 move	v0,zero
[ 595] 0x900000001fc0d5d8:  df b2 01 00 ld	s2,256(sp)
[ 595] 0x900000001fc0d5dc:  10 00 00 76 b		0x900000001fc0d7b8
[ 595] 0x900000001fc0d5e0:  df b1 01 08 ld	s1,264(sp)
[ 595] 0x900000001fc0d5e4:  df b7 00 d8 ld	s7,216(sp)
[ 595] 0x900000001fc0d5e8:  df be 00 d0 ld	s8,208(sp)
[ 590] 0x900000001fc0d5ec:  0f f0 31 69 jal		parse_error
[ 590] 0x900000001fc0d5f0:  00 00 00 21 nada
[ 591] 0x900000001fc0d5f4:  00 00 10 25 move	v0,zero
[ 591] 0x900000001fc0d5f8:  df b2 01 00 ld	s2,256(sp)
[ 591] 0x900000001fc0d5fc:  df b6 00 e0 ld	s6,224(sp)
[ 591] 0x900000001fc0d600:  df b1 01 08 ld	s1,264(sp)
[ 591] 0x900000001fc0d604:  10 00 00 6d b		0x900000001fc0d7bc
[ 591] 0x900000001fc0d608:  df b0 01 10 ld	s0,272(sp)
[ 591] 0x900000001fc0d60c:  df a4 00 00 ld	a0,0(sp)
[ 591] 0x900000001fc0d610:  02 60 40 25 move	a4,s3
[ 571] 0x900000001fc0d614:  8f ab 01 a0 lw	a7,416(sp)
[ 571] 0x900000001fc0d618:  24 0c 00 28 li	t0,40
[ 571] 0x900000001fc0d61c:  55 6c 00 2d bnel	a7,t0,0x900000001fc0d6d4
[ 571] 0x900000001fc0d620:  df b7 00 d8 ld	s7,216(sp)
[ 575] 0x900000001fc0d624:  02 40 38 25 move	a3,s2
[ 575] 0x900000001fc0d628:  02 c0 30 25 move	a2,s6
[ 575] 0x900000001fc0d62c:  0f f0 31 ec jal		pod_parse
[ 575] 0x900000001fc0d630:  02 80 28 25 move	a1,s4
[ 575] 0x900000001fc0d634:  67 a4 00 00 daddiu	a0,sp,0
[ 575] 0x900000001fc0d638:  00 40 c8 25 move	t9,v0
[ 577] 0x900000001fc0d63c:  ff b9 00 08 sd	t9,8(sp)
[ 577] 0x900000001fc0d640:  53 20 00 1c beql	t9,zero,0x900000001fc0d6b4
[ 577] 0x900000001fc0d644:  03 20 10 25 move	v0,t9
[ 579] 0x900000001fc0d648:  0f f0 31 d5 jal		check_eol
[ 579] 0x900000001fc0d64c:  ff b9 00 00 sd	t9,0(sp)
[ 579] 0x900000001fc0d650:  ff a2 00 c8 sd	v0,200(sp)
  694: 	    } /* Switch */
  695: 	    if (sloop)
[ 695] 0x900000001fc0d654:  df bf 00 40 ld	ra,64(sp)
[ 695] 0x900000001fc0d658:  53 e0 00 0c beql	ra,zero,0x900000001fc0d68c
[ 695] 0x900000001fc0d65c:  df a4 00 c8 ld	a0,200(sp)
  696: 		if (pod_poll()) {
[ 696] 0x900000001fc0d660:  0f f0 15 23 jal		pod_poll
[ 696] 0x900000001fc0d664:  00 00 00 21 nada
[ 696] 0x900000001fc0d668:  50 40 00 05 beql	v0,zero,0x900000001fc0d680
[ 696] 0x900000001fc0d66c:  df a3 00 40 ld	v1,64(sp)
  697: 		    pod_getc();
[ 697] 0x900000001fc0d670:  0f f0 15 0b jal		pod_getc
[ 697] 0x900000001fc0d674:  00 00 00 21 nada
  698: 		    sloop = 0;
[ 698] 0x900000001fc0d678:  ff a0 00 40 sd	zero,64(sp)
[ 698] 0x900000001fc0d67c:  df a3 00 40 ld	v1,64(sp)
[ 325] 0x900000001fc0d680:  54 60 fc d3 bnel	v1,zero,0x900000001fc0c9d0
[ 325] 0x900000001fc0d684:  df a2 00 60 ld	v0,96(sp)
[ 288] 0x900000001fc0d688:  df a4 00 c8 ld	a0,200(sp)
[ 288] 0x900000001fc0d68c:  10 80 fc 85 beq	a0,zero,0x900000001fc0c8a4
[ 288] 0x900000001fc0d690:  00 00 00 21 nada
[ 288] 0x900000001fc0d694:  df b2 01 00 ld	s2,256(sp)
[ 288] 0x900000001fc0d698:  df b7 00 d8 ld	s7,216(sp)
[ 288] 0x900000001fc0d69c:  df be 00 d0 ld	s8,208(sp)
  699: 		}
  700: 	} while (sloop);
  701:     } /* While line end */
  702:     return bufp;
[ 702] 0x900000001fc0d6a0:  df b6 00 e0 ld	s6,224(sp)
[ 702] 0x900000001fc0d6a4:  df b1 01 08 ld	s1,264(sp)
[ 702] 0x900000001fc0d6a8:  10 00 00 43 b		0x900000001fc0d7b8
[ 702] 0x900000001fc0d6ac:  df a2 00 00 ld	v0,0(sp)
[ 702] 0x900000001fc0d6b0:  03 20 10 25 move	v0,t9
[ 702] 0x900000001fc0d6b4:  df b1 01 08 ld	s1,264(sp)
[ 702] 0x900000001fc0d6b8:  df b6 00 e0 ld	s6,224(sp)
[ 702] 0x900000001fc0d6bc:  df b7 00 d8 ld	s7,216(sp)
[ 702] 0x900000001fc0d6c0:  df b2 01 00 ld	s2,256(sp)
[ 702] 0x900000001fc0d6c4:  df be 00 d0 ld	s8,208(sp)
[ 578] 0x900000001fc0d6c8:  10 00 00 3c b		0x900000001fc0d7bc
[ 578] 0x900000001fc0d6cc:  df b0 01 10 ld	s0,272(sp)
[ 578] 0x900000001fc0d6d0:  df b7 00 d8 ld	s7,216(sp)
[ 578] 0x900000001fc0d6d4:  df be 00 d0 ld	s8,208(sp)
[ 572] 0x900000001fc0d6d8:  0f f0 31 69 jal		parse_error
[ 572] 0x900000001fc0d6dc:  00 00 00 21 nada
[ 573] 0x900000001fc0d6e0:  00 00 10 25 move	v0,zero
[ 573] 0x900000001fc0d6e4:  df b2 01 00 ld	s2,256(sp)
[ 573] 0x900000001fc0d6e8:  df b6 00 e0 ld	s6,224(sp)
[ 573] 0x900000001fc0d6ec:  df b1 01 08 ld	s1,264(sp)
[ 573] 0x900000001fc0d6f0:  10 00 00 32 b		0x900000001fc0d7bc
[ 573] 0x900000001fc0d6f4:  df b0 01 10 ld	s0,272(sp)
[ 573] 0x900000001fc0d6f8:  df be 00 d0 ld	s8,208(sp)
[ 321] 0x900000001fc0d6fc:  df a5 00 48 ld	a1,72(sp)
[ 321] 0x900000001fc0d700:  df b6 00 e0 ld	s6,224(sp)
[ 321] 0x900000001fc0d704:  df b7 00 d8 ld	s7,216(sp)
[ 321] 0x900000001fc0d708:  0f f0 2c e3 jal		loprintf
[ 321] 0x900000001fc0d70c:  64 a4 0c d8 daddiu	a0,a1,3288
[ 322] 0x900000001fc0d710:  00 00 10 25 move	v0,zero
[ 322] 0x900000001fc0d714:  df b2 01 00 ld	s2,256(sp)
[ 322] 0x900000001fc0d718:  10 00 00 27 b		0x900000001fc0d7b8
[ 322] 0x900000001fc0d71c:  df b1 01 08 ld	s1,264(sp)
[ 322] 0x900000001fc0d720:  00 00 10 25 move	v0,zero
[ 322] 0x900000001fc0d724:  df b1 01 08 ld	s1,264(sp)
[ 322] 0x900000001fc0d728:  df b6 00 e0 ld	s6,224(sp)
[ 322] 0x900000001fc0d72c:  df b7 00 d8 ld	s7,216(sp)
[ 322] 0x900000001fc0d730:  df b2 01 00 ld	s2,256(sp)
[ 322] 0x900000001fc0d734:  df be 00 d0 ld	s8,208(sp)
[ 314] 0x900000001fc0d738:  10 00 00 20 b		0x900000001fc0d7bc
[ 314] 0x900000001fc0d73c:  df b0 01 10 ld	s0,272(sp)
[ 314] 0x900000001fc0d740:  00 00 10 25 move	v0,zero
[ 314] 0x900000001fc0d744:  df b1 01 08 ld	s1,264(sp)
[ 314] 0x900000001fc0d748:  df b6 00 e0 ld	s6,224(sp)
[ 314] 0x900000001fc0d74c:  df b7 00 d8 ld	s7,216(sp)
[ 314] 0x900000001fc0d750:  df b2 01 00 ld	s2,256(sp)
[ 314] 0x900000001fc0d754:  df be 00 d0 ld	s8,208(sp)
[ 309] 0x900000001fc0d758:  10 00 00 18 b		0x900000001fc0d7bc
[ 309] 0x900000001fc0d75c:  df b0 01 10 ld	s0,272(sp)
[ 309] 0x900000001fc0d760:  00 00 10 25 move	v0,zero
[ 309] 0x900000001fc0d764:  df b1 01 08 ld	s1,264(sp)
[ 309] 0x900000001fc0d768:  df b6 00 e0 ld	s6,224(sp)
[ 309] 0x900000001fc0d76c:  df b7 00 d8 ld	s7,216(sp)
[ 309] 0x900000001fc0d770:  df b2 01 00 ld	s2,256(sp)
[ 309] 0x900000001fc0d774:  df be 00 d0 ld	s8,208(sp)
[ 304] 0x900000001fc0d778:  10 00 00 10 b		0x900000001fc0d7bc
[ 304] 0x900000001fc0d77c:  df b0 01 10 ld	s0,272(sp)
[ 304] 0x900000001fc0d780:  df be 00 d0 ld	s8,208(sp)
[ 299] 0x900000001fc0d784:  67 a5 01 20 daddiu	a1,sp,288
[ 299] 0x900000001fc0d788:  df a6 00 48 ld	a2,72(sp)
[ 299] 0x900000001fc0d78c:  df b6 00 e0 ld	s6,224(sp)
[ 299] 0x900000001fc0d790:  df b7 00 d8 ld	s7,216(sp)
[ 299] 0x900000001fc0d794:  0f f0 2c e3 jal		loprintf
[ 299] 0x900000001fc0d798:  64 c4 0c b8 daddiu	a0,a2,3256
[ 300] 0x900000001fc0d79c:  00 00 10 25 move	v0,zero
[ 300] 0x900000001fc0d7a0:  df b2 01 00 ld	s2,256(sp)
[ 300] 0x900000001fc0d7a4:  10 00 00 04 b		0x900000001fc0d7b8
[ 300] 0x900000001fc0d7a8:  df b1 01 08 ld	s1,264(sp)
[ 280] 0x900000001fc0d7ac:  0f f0 2c e3 jal		loprintf
[ 280] 0x900000001fc0d7b0:  66 04 0c 88 daddiu	a0,s0,3208
[ 281] 0x900000001fc0d7b4:  00 00 10 25 move	v0,zero
[ 281] 0x900000001fc0d7b8:  df b0 01 10 ld	s0,272(sp)
[ 281] 0x900000001fc0d7bc:  df b5 00 e8 ld	s5,232(sp)
[ 281] 0x900000001fc0d7c0:  df bf 01 18 ld	ra,280(sp)
[ 281] 0x900000001fc0d7c4:  df b3 00 f8 ld	s3,248(sp)
[ 281] 0x900000001fc0d7c8:  df b4 00 f0 ld	s4,240(sp)
[ 281] 0x900000001fc0d7cc:  03 e0 00 08 jr	ra
[ 281] 0x900000001fc0d7d0:  67 bd 03 20 daddiu	sp,sp,800
  703: }
  704: 
  705: int lo_strcmp(int *ip, char *cp)			/* biendian */
  706: {
lo_strcmp:
[ 706] 0x900000001fc0d7d4:  67 bd ff d0 daddiu	sp,sp,-48
[ 706] 0x900000001fc0d7d8:  ff b2 00 10 sd	s2,16(sp)
[ 706] 0x900000001fc0d7dc:  00 80 90 25 move	s2,a0
  707: 	FLIPINIT(dosw, cp);
[ 707] 0x900000001fc0d7e0:  ff b3 00 08 sd	s3,8(sp)
[ 707] 0x900000001fc0d7e4:  00 a0 98 25 move	s3,a1
[ 707] 0x900000001fc0d7e8:  ff b4 00 00 sd	s4,0(sp)
[ 707] 0x900000001fc0d7ec:  ff bf 00 28 sd	ra,40(sp)
[ 707] 0x900000001fc0d7f0:  0f f0 0d d0 jal		getendian
[ 707] 0x900000001fc0d7f4:  00 00 a0 25 move	s4,zero
[ 707] 0x900000001fc0d7f8:  3c 03 90 00 lui	v1,0x9000
[ 707] 0x900000001fc0d7fc:  8e 4b 00 00 lw	a7,0(s2)
[ 707] 0x900000001fc0d800:  ff b0 00 20 sd	s0,32(sp)
[ 707] 0x900000001fc0d804:  ff b1 00 18 sd	s1,24(sp)
[ 707] 0x900000001fc0d808:  10 40 00 0e beq	v0,zero,0x900000001fc0d844
[ 707] 0x900000001fc0d80c:  24 10 00 20 li	s0,32
[ 707] 0x900000001fc0d810:  60 63 00 00 daddi	v1,v1,0
[ 707] 0x900000001fc0d814:  3c 04 1f c2 lui	a0,0x1fc2
[ 707] 0x900000001fc0d818:  60 84 bb c0 daddi	a0,a0,-17472
[ 707] 0x900000001fc0d81c:  00 03 18 3c dsll32	v1,v1,0
[ 707] 0x900000001fc0d820:  00 64 c8 2c dadd	t9,v1,a0
[ 707] 0x900000001fc0d824:  00 13 8d 3a dsrl	s1,s3,20
[ 707] 0x900000001fc0d828:  df 23 13 38 ld	v1,4920(t9)
[ 707] 0x900000001fc0d82c:  52 23 00 05 beql	s1,v1,0x900000001fc0d844
[ 707] 0x900000001fc0d830:  24 14 00 01 li	s4,1
[ 707] 0x900000001fc0d834:  df 25 13 40 ld	a1,4928(t9)
[ 707] 0x900000001fc0d838:  16 25 00 02 bne	s1,a1,0x900000001fc0d844
[ 707] 0x900000001fc0d83c:  00 00 00 21 nada
[ 707] 0x900000001fc0d840:  24 14 00 01 li	s4,1
  708: 
  709: 	while (*ip == ' ' && *ip != 0)
[ 709] 0x900000001fc0d844:  15 70 00 09 bne	a7,s0,0x900000001fc0d86c
[ 709] 0x900000001fc0d848:  00 00 00 21 nada
[ 709] 0x900000001fc0d84c:  11 60 00 07 beq	a7,zero,0x900000001fc0d86c
[ 709] 0x900000001fc0d850:  00 00 00 21 nada
  710: 		ip++;
[ 710] 0x900000001fc0d854:  66 52 00 04 daddiu	s2,s2,4
[ 709] 0x900000001fc0d858:  8e 4b 00 00 lw	a7,0(s2)
[ 709] 0x900000001fc0d85c:  15 70 00 03 bne	a7,s0,0x900000001fc0d86c
[ 709] 0x900000001fc0d860:  00 00 00 21 nada
[ 709] 0x900000001fc0d864:  55 60 ff fc bnel	a7,zero,0x900000001fc0d858
[ 709] 0x900000001fc0d868:  66 52 00 04 daddiu	s2,s2,4
  711: 	while ((EVCFLIP(dosw, cp) != 0) || (*ip != 0)) {
[ 711] 0x900000001fc0d86c:  12 80 00 02 beq	s4,zero,0x900000001fc0d878
[ 711] 0x900000001fc0d870:  02 60 20 25 move	a0,s3
[ 711] 0x900000001fc0d874:  3a 64 00 03 xori	a0,s3,0x3
[ 711] 0x900000001fc0d878:  0f f0 0d 88 jal		get_char
[ 711] 0x900000001fc0d87c:  00 00 00 21 nada
[ 711] 0x900000001fc0d880:  8e 4b 00 00 lw	a7,0(s2)
[ 711] 0x900000001fc0d884:  54 40 00 04 bnel	v0,zero,0x900000001fc0d898
[ 711] 0x900000001fc0d888:  66 70 00 01 daddiu	s0,s3,1
[ 711] 0x900000001fc0d88c:  51 60 00 1f beql	a7,zero,0x900000001fc0d90c
[ 711] 0x900000001fc0d890:  df b4 00 00 ld	s4,0(sp)
[ 711] 0x900000001fc0d894:  66 70 00 01 daddiu	s0,s3,1
  712: 		if (*ip++ == EVCFLIP(dosw,cp++))
[ 712] 0x900000001fc0d898:  01 60 88 25 move	s1,a7
[ 712] 0x900000001fc0d89c:  52 80 00 06 beql	s4,zero,0x900000001fc0d8b8
[ 712] 0x900000001fc0d8a0:  02 60 20 25 move	a0,s3
[ 712] 0x900000001fc0d8a4:  02 60 30 25 move	a2,s3
[ 712] 0x900000001fc0d8a8:  02 00 98 25 move	s3,s0
[ 712] 0x900000001fc0d8ac:  10 00 00 03 b		0x900000001fc0d8bc
[ 712] 0x900000001fc0d8b0:  38 c4 00 03 xori	a0,a2,0x3
[ 712] 0x900000001fc0d8b4:  02 60 20 25 move	a0,s3
[ 712] 0x900000001fc0d8b8:  02 00 98 25 move	s3,s0
[ 712] 0x900000001fc0d8bc:  0f f0 0d 88 jal		get_char
[ 712] 0x900000001fc0d8c0:  00 00 00 21 nada
[ 712] 0x900000001fc0d8c4:  66 52 00 04 daddiu	s2,s2,4
[ 712] 0x900000001fc0d8c8:  12 22 00 05 beq	s1,v0,0x900000001fc0d8e0
[ 712] 0x900000001fc0d8cc:  02 00 c8 25 move	t9,s0
[ 712] 0x900000001fc0d8d0:  df b4 00 00 ld	s4,0(sp)
[ 712] 0x900000001fc0d8d4:  df b1 00 18 ld	s1,24(sp)
  713: 			continue;
  714: 		else
  715: 			return(-1);
[ 715] 0x900000001fc0d8d8:  10 00 00 0e b		0x900000001fc0d914
[ 715] 0x900000001fc0d8dc:  24 02 ff ff li	v0,-1
[ 711] 0x900000001fc0d8e0:  12 80 00 02 beq	s4,zero,0x900000001fc0d8ec
[ 711] 0x900000001fc0d8e4:  00 00 00 21 nada
[ 711] 0x900000001fc0d8e8:  3a 19 00 03 xori	t9,s0,0x3
[ 711] 0x900000001fc0d8ec:  0f f0 0d 88 jal		get_char
[ 711] 0x900000001fc0d8f0:  03 20 20 25 move	a0,t9
[ 711] 0x900000001fc0d8f4:  8e 4b 00 00 lw	a7,0(s2)
[ 711] 0x900000001fc0d8f8:  54 40 ff e7 bnel	v0,zero,0x900000001fc0d898
[ 711] 0x900000001fc0d8fc:  66 70 00 01 daddiu	s0,s3,1
[ 711] 0x900000001fc0d900:  55 60 ff e5 bnel	a7,zero,0x900000001fc0d898
[ 711] 0x900000001fc0d904:  66 70 00 01 daddiu	s0,s3,1
[ 711] 0x900000001fc0d908:  df b4 00 00 ld	s4,0(sp)
[ 711] 0x900000001fc0d90c:  df b1 00 18 ld	s1,24(sp)
  716: 	}
  717: 	return(0);
[ 717] 0x900000001fc0d910:  00 00 10 25 move	v0,zero
[ 717] 0x900000001fc0d914:  df bf 00 28 ld	ra,40(sp)
[ 717] 0x900000001fc0d918:  df b2 00 10 ld	s2,16(sp)
[ 717] 0x900000001fc0d91c:  df b0 00 20 ld	s0,32(sp)
[ 717] 0x900000001fc0d920:  df b3 00 08 ld	s3,8(sp)
[ 717] 0x900000001fc0d924:  03 e0 00 08 jr	ra
[ 717] 0x900000001fc0d928:  67 bd 00 30 daddiu	sp,sp,48
  718: }
  719: 
  720: 
  721: void lo_strcpy(char *dest, char *src)			/* biendian */
  722: {
lo_strcpy:
[ 722] 0x900000001fc0d92c:  67 bd ff d0 daddiu	sp,sp,-48
  723: 	FLIPINIT(dosw, src);
[ 723] 0x900000001fc0d930:  ff b3 00 00 sd	s3,0(sp)
[ 723] 0x900000001fc0d934:  00 80 98 25 move	s3,a0
[ 723] 0x900000001fc0d938:  ff b1 00 10 sd	s1,16(sp)
[ 723] 0x900000001fc0d93c:  ff bf 00 20 sd	ra,32(sp)
[ 723] 0x900000001fc0d940:  0f f0 0d d0 jal		getendian
[ 723] 0x900000001fc0d944:  00 a0 88 25 move	s1,a1
[ 723] 0x900000001fc0d948:  3c 03 90 00 lui	v1,0x9000
[ 723] 0x900000001fc0d94c:  ff b2 00 08 sd	s2,8(sp)
[ 723] 0x900000001fc0d950:  ff b0 00 18 sd	s0,24(sp)
[ 723] 0x900000001fc0d954:  10 40 00 0e beq	v0,zero,0x900000001fc0d990
[ 723] 0x900000001fc0d958:  00 00 90 25 move	s2,zero
[ 723] 0x900000001fc0d95c:  60 63 00 00 daddi	v1,v1,0
[ 723] 0x900000001fc0d960:  3c 04 1f c2 lui	a0,0x1fc2
[ 723] 0x900000001fc0d964:  60 84 bb c0 daddi	a0,a0,-17472
[ 723] 0x900000001fc0d968:  00 03 18 3c dsll32	v1,v1,0
[ 723] 0x900000001fc0d96c:  00 64 c8 2c dadd	t9,v1,a0
[ 723] 0x900000001fc0d970:  00 11 85 3a dsrl	s0,s1,20
[ 723] 0x900000001fc0d974:  df 23 13 38 ld	v1,4920(t9)
[ 723] 0x900000001fc0d978:  52 03 00 05 beql	s0,v1,0x900000001fc0d990
[ 723] 0x900000001fc0d97c:  24 12 00 01 li	s2,1
[ 723] 0x900000001fc0d980:  df 25 13 40 ld	a1,4928(t9)
[ 723] 0x900000001fc0d984:  16 05 00 02 bne	s0,a1,0x900000001fc0d990
[ 723] 0x900000001fc0d988:  00 00 00 21 nada
[ 723] 0x900000001fc0d98c:  24 12 00 01 li	s2,1
  724: 
  725: 	while (EVCFLIP(dosw, src) != 0)
[ 725] 0x900000001fc0d990:  12 40 00 02 beq	s2,zero,0x900000001fc0d99c
[ 725] 0x900000001fc0d994:  02 20 20 25 move	a0,s1
[ 725] 0x900000001fc0d998:  3a 24 00 03 xori	a0,s1,0x3
[ 725] 0x900000001fc0d99c:  0f f0 0d 88 jal		get_char
[ 725] 0x900000001fc0d9a0:  00 00 00 21 nada
[ 725] 0x900000001fc0d9a4:  50 40 00 15 beql	v0,zero,0x900000001fc0d9fc
[ 725] 0x900000001fc0d9a8:  df b0 00 18 ld	s0,24(sp)
  726: 		*dest++ = EVCFLIP(dosw, src++);
[ 726] 0x900000001fc0d9ac:  12 40 00 05 beq	s2,zero,0x900000001fc0d9c4
[ 726] 0x900000001fc0d9b0:  66 30 00 01 daddiu	s0,s1,1
[ 726] 0x900000001fc0d9b4:  02 20 30 25 move	a2,s1
[ 726] 0x900000001fc0d9b8:  02 00 88 25 move	s1,s0
[ 726] 0x900000001fc0d9bc:  10 00 00 03 b		0x900000001fc0d9cc
[ 726] 0x900000001fc0d9c0:  38 c4 00 03 xori	a0,a2,0x3
[ 726] 0x900000001fc0d9c4:  02 20 20 25 move	a0,s1
[ 726] 0x900000001fc0d9c8:  02 00 88 25 move	s1,s0
[ 726] 0x900000001fc0d9cc:  0f f0 0d 88 jal		get_char
[ 726] 0x900000001fc0d9d0:  00 00 00 21 nada
[ 725] 0x900000001fc0d9d4:  02 00 c8 25 move	t9,s0
[ 725] 0x900000001fc0d9d8:  a2 62 00 00 sb	v0,0(s3)
[ 725] 0x900000001fc0d9dc:  12 40 00 02 beq	s2,zero,0x900000001fc0d9e8
[ 725] 0x900000001fc0d9e0:  66 73 00 01 daddiu	s3,s3,1
[ 725] 0x900000001fc0d9e4:  3a 19 00 03 xori	t9,s0,0x3
[ 725] 0x900000001fc0d9e8:  0f f0 0d 88 jal		get_char
[ 725] 0x900000001fc0d9ec:  03 20 20 25 move	a0,t9
[ 725] 0x900000001fc0d9f0:  14 40 ff ee bne	v0,zero,0x900000001fc0d9ac
[ 725] 0x900000001fc0d9f4:  00 00 00 21 nada
[ 725] 0x900000001fc0d9f8:  df b0 00 18 ld	s0,24(sp)
[ 725] 0x900000001fc0d9fc:  df b3 00 00 ld	s3,0(sp)
[ 725] 0x900000001fc0da00:  df bf 00 20 ld	ra,32(sp)
[ 725] 0x900000001fc0da04:  df b1 00 10 ld	s1,16(sp)
[ 725] 0x900000001fc0da08:  df b2 00 08 ld	s2,8(sp)
[ 725] 0x900000001fc0da0c:  03 e0 00 08 jr	ra
[ 725] 0x900000001fc0da10:  67 bd 00 30 daddiu	sp,sp,48
  727: }
  728: 
  729: __scunsigned_t lo_atoh(int *cp)
  730: {
lo_atoh:
[ 730] 0x900000001fc0da14:  24 19 00 58 li	t9,88
[ 730] 0x900000001fc0da18:  67 bd ff e0 daddiu	sp,sp,-32
[ 730] 0x900000001fc0da1c:  ff b1 00 00 sd	s1,0(sp)
[ 730] 0x900000001fc0da20:  00 80 88 25 move	s1,a0
  731: 	register __scunsigned_t i;
  732: 
  733: 	/* Ignore leading 0x or 0X */
  734: 	if (*cp == '0' && (*(cp+1) == 'x' || *(cp+1) == 'X'))
[ 734] 0x900000001fc0da24:  24 02 00 30 li	v0,48
[ 734] 0x900000001fc0da28:  8e 21 00 00 lw	at,0(s1)
[ 734] 0x900000001fc0da2c:  ff b0 00 08 sd	s0,8(sp)
[ 734] 0x900000001fc0da30:  14 22 00 07 bne	at,v0,0x900000001fc0da50
[ 734] 0x900000001fc0da34:  24 03 00 78 li	v1,120
[ 734] 0x900000001fc0da38:  8e 30 00 04 lw	s0,4(s1)
[ 734] 0x900000001fc0da3c:  52 03 00 04 beql	s0,v1,0x900000001fc0da50
[ 734] 0x900000001fc0da40:  66 31 00 08 daddiu	s1,s1,8
[ 734] 0x900000001fc0da44:  16 19 00 02 bne	s0,t9,0x900000001fc0da50
[ 734] 0x900000001fc0da48:  00 00 00 21 nada
  735: 		cp += 2;
[ 735] 0x900000001fc0da4c:  66 31 00 08 daddiu	s1,s1,8
  736: 
  737: 	for (i = 0 ; lo_ishex(*cp) ;)
[ 737] 0x900000001fc0da50:  ff bf 00 10 sd	ra,16(sp)
[ 737] 0x900000001fc0da54:  0f f0 36 d4 jal		lo_ishex
[ 737] 0x900000001fc0da58:  8e 24 00 00 lw	a0,0(s1)
[ 737] 0x900000001fc0da5c:  66 2b 00 04 daddiu	a7,s1,4
[ 737] 0x900000001fc0da60:  00 00 80 25 move	s0,zero
[ 737] 0x900000001fc0da64:  00 10 c9 38 dsll	t9,s0,4
[ 737] 0x900000001fc0da68:  50 40 00 1d beql	v0,zero,0x900000001fc0dae0
[ 737] 0x900000001fc0da6c:  df b1 00 00 ld	s1,0(sp)
  738: 		if (*cp <= '9')
[ 738] 0x900000001fc0da70:  8e 24 00 00 lw	a0,0(s1)
[ 738] 0x900000001fc0da74:  01 60 88 25 move	s1,a7
[ 738] 0x900000001fc0da78:  28 8a 00 61 slti	a6,a0,97
[ 738] 0x900000001fc0da7c:  28 85 00 3a slti	a1,a0,58
[ 738] 0x900000001fc0da80:  54 a0 00 0e bnel	a1,zero,0x900000001fc0dabc
[ 738] 0x900000001fc0da84:  03 24 40 2d daddu	a4,t9,a0
  739: 			i = i*16 + *cp++ - '0';
  740: 		else {
  741: 			if (*cp >= 'a')
[ 741] 0x900000001fc0da88:  51 40 00 07 beql	a6,zero,0x900000001fc0daa8
[ 741] 0x900000001fc0da8c:  03 24 38 2d daddu	a3,t9,a0
  742: 				i = i * 16 + *cp++ - 'a' + 10;
  743: 			else
  744: 				i = i * 16 + *cp++ - 'A' + 10;
[ 744] 0x900000001fc0da90:  03 24 30 2d daddu	a2,t9,a0
[ 744] 0x900000001fc0da94:  01 60 88 25 move	s1,a7
[ 744] 0x900000001fc0da98:  8d 64 00 00 lw	a0,0(a7)
[ 744] 0x900000001fc0da9c:  10 00 00 09 b		0x900000001fc0dac4
[ 744] 0x900000001fc0daa0:  64 d0 ff c9 daddiu	s0,a2,-55
[ 742] 0x900000001fc0daa4:  03 24 38 2d daddu	a3,t9,a0
[ 742] 0x900000001fc0daa8:  01 60 88 25 move	s1,a7
[ 742] 0x900000001fc0daac:  8d 64 00 00 lw	a0,0(a7)
[ 742] 0x900000001fc0dab0:  10 00 00 04 b		0x900000001fc0dac4
[ 742] 0x900000001fc0dab4:  64 f0 ff a9 daddiu	s0,a3,-87
[ 739] 0x900000001fc0dab8:  03 24 40 2d daddu	a4,t9,a0
[ 739] 0x900000001fc0dabc:  8d 64 00 00 lw	a0,0(a7)
[ 739] 0x900000001fc0dac0:  65 10 ff d0 daddiu	s0,a4,-48
[ 737] 0x900000001fc0dac4:  0f f0 36 d4 jal		lo_ishex
[ 737] 0x900000001fc0dac8:  00 00 00 21 nada
[ 737] 0x900000001fc0dacc:  66 2b 00 04 daddiu	a7,s1,4
[ 737] 0x900000001fc0dad0:  00 10 c9 38 dsll	t9,s0,4
[ 737] 0x900000001fc0dad4:  54 40 ff e7 bnel	v0,zero,0x900000001fc0da74
[ 737] 0x900000001fc0dad8:  8e 24 00 00 lw	a0,0(s1)
[ 737] 0x900000001fc0dadc:  df b1 00 00 ld	s1,0(sp)
[ 737] 0x900000001fc0dae0:  df bf 00 10 ld	ra,16(sp)
  745: 		}
  746: 	return i;
[ 746] 0x900000001fc0dae4:  02 00 10 25 move	v0,s0
[ 746] 0x900000001fc0dae8:  df b0 00 08 ld	s0,8(sp)
[ 746] 0x900000001fc0daec:  03 e0 00 08 jr	ra
[ 746] 0x900000001fc0daf0:  67 bd 00 20 daddiu	sp,sp,32
  747: }
  748: 
  749: uint lo_atoi(int *cp)
  750: {
  751: 	register unsigned i;
  752: 
  753: 	for (i = 0 ; isdigit(*cp) ;)
lo_atoi:
[ 753] 0x900000001fc0daf4:  00 00 10 25 move	v0,zero
[ 753] 0x900000001fc0daf8:  8c 99 00 00 lw	t9,0(a0)
[ 753] 0x900000001fc0dafc:  24 0b 00 39 li	a7,57
[ 753] 0x900000001fc0db00:  2b 21 00 30 slti	at,t9,48
[ 753] 0x900000001fc0db04:  14 20 00 10 bne	at,zero,0x900000001fc0db48
[ 753] 0x900000001fc0db08:  2b 2a 00 3a slti	a6,t9,58
[ 753] 0x900000001fc0db0c:  00 02 40 c0 sll	a4,v0,3
[ 753] 0x900000001fc0db10:  11 40 00 0d beq	a6,zero,0x900000001fc0db48
[ 753] 0x900000001fc0db14:  00 42 48 21 addu	a5,v0,v0
  754: 		i = i*10 + *cp++ - '0';
[ 754] 0x900000001fc0db18:  64 84 00 04 daddiu	a0,a0,4
[ 754] 0x900000001fc0db1c:  01 09 10 21 addu	v0,a4,a5
[ 753] 0x900000001fc0db20:  00 59 10 21 addu	v0,v0,t9
[ 753] 0x900000001fc0db24:  8c 99 00 00 lw	t9,0(a0)
[ 753] 0x900000001fc0db28:  24 42 ff d0 addiu	v0,v0,-48
[ 753] 0x900000001fc0db2c:  2b 23 00 30 slti	v1,t9,48
[ 753] 0x900000001fc0db30:  14 60 00 05 bne	v1,zero,0x900000001fc0db48
[ 753] 0x900000001fc0db34:  01 79 50 2a slt	a6,a7,t9
[ 753] 0x900000001fc0db38:  00 02 40 c0 sll	a4,v0,3
[ 753] 0x900000001fc0db3c:  00 42 48 21 addu	a5,v0,v0
[ 753] 0x900000001fc0db40:  51 40 ff f6 beql	a6,zero,0x900000001fc0db1c
[ 753] 0x900000001fc0db44:  64 84 00 04 daddiu	a0,a0,4
  755: 	return i;
[ 755] 0x900000001fc0db48:  03 e0 00 08 jr	ra
[ 755] 0x900000001fc0db4c:  00 00 00 21 nada
  756: }
  757: 
  758: int lo_ishex(int c)
  759: {
lo_ishex:
[ 759] 0x900000001fc0db50:  28 99 00 3a slti	t9,a0,58
  760: 	if ((c >= '0' && c <= '9') ||
[ 760] 0x900000001fc0db54:  28 81 00 30 slti	at,a0,48
[ 760] 0x900000001fc0db58:  54 20 00 04 bnel	at,zero,0x900000001fc0db6c
[ 760] 0x900000001fc0db5c:  28 99 00 47 slti	t9,a0,71
[ 760] 0x900000001fc0db60:  57 20 00 10 bnel	t9,zero,0x900000001fc0dba4
[ 760] 0x900000001fc0db64:  24 02 00 01 li	v0,1
[ 760] 0x900000001fc0db68:  28 99 00 47 slti	t9,a0,71
[ 760] 0x900000001fc0db6c:  28 82 00 41 slti	v0,a0,65
[ 760] 0x900000001fc0db70:  54 40 00 04 bnel	v0,zero,0x900000001fc0db84
[ 760] 0x900000001fc0db74:  28 99 00 67 slti	t9,a0,103
[ 760] 0x900000001fc0db78:  57 20 00 0a bnel	t9,zero,0x900000001fc0dba4
[ 760] 0x900000001fc0db7c:  24 02 00 01 li	v0,1
[ 760] 0x900000001fc0db80:  28 99 00 67 slti	t9,a0,103
[ 760] 0x900000001fc0db84:  28 83 00 61 slti	v1,a0,97
[ 760] 0x900000001fc0db88:  14 60 00 03 bne	v1,zero,0x900000001fc0db98
[ 760] 0x900000001fc0db8c:  00 00 00 21 nada
[ 760] 0x900000001fc0db90:  57 20 00 04 bnel	t9,zero,0x900000001fc0dba4
[ 760] 0x900000001fc0db94:  24 02 00 01 li	v0,1
  761: 	    (c >= 'A' && c <= 'F') ||
  762: 	    (c >= 'a' && c <= 'f')) {
  763: 		return 1;
  764: 	}
  765: 	else
  766: 		return 0;
[ 766] 0x900000001fc0db98:  10 00 00 02 b		0x900000001fc0dba4
[ 766] 0x900000001fc0db9c:  00 00 10 25 move	v0,zero
[ 763] 0x900000001fc0dba0:  24 02 00 01 li	v0,1
[ 763] 0x900000001fc0dba4:  03 e0 00 08 jr	ra
[ 763] 0x900000001fc0dba8:  00 00 00 21 nada
Skipping source listing to line 29 of /cores/banyan/stand/arcs/IP25prom/pod_master.c...
   30:               INV_UNITOFF + ((_u) * INV_UNITSIZE) + (_f))
   31: #define ABS_VAL(_x)		(((_x) < 0) ? -(_x) : (_x))
   32: 
   33: int	load_io4prom(void);
   34: void	xlate_ertoip(__uint64_t);
   35: void	set_ertoip_at_reset(void);
   36: 
   37: extern unsigned long MemSizes[];
   38: 
   39: void update_boot_stat(int io4_err, int slot, int slice) {
update_boot_stat:
[  39] 0x900000001fc0dbac:  67 bd ff 30 daddiu	sp,sp,-208
[  39] 0x900000001fc0dbb0:  ff b0 00 c8 sd	s0,200(sp)
[  39] 0x900000001fc0dbb4:  00 80 80 25 move	s0,a0
   40:     uint nv_valid;
   41:     evbrdinfo_t *brd;
   42:     uint i, c;
   43:     char cpuinfo[EV_MAX_CPUS+1];
   44:     char *currcpu = cpuinfo;
   45: 
   46:     nv_valid = (nvram_okay() && !io4_err);
[  46] 0x900000001fc0dbb8:  ff b1 00 c0 sd	s1,192(sp)
[  46] 0x900000001fc0dbbc:  00 00 88 25 move	s1,zero
[  46] 0x900000001fc0dbc0:  ff a5 00 50 sd	a1,80(sp)
[  46] 0x900000001fc0dbc4:  ff bf 00 80 sd	ra,128(sp)
[  46] 0x900000001fc0dbc8:  0f f0 30 ed jal		nvram_okay
[  46] 0x900000001fc0dbcc:  ff a6 00 58 sd	a2,88(sp)
[  44] 0x900000001fc0dbd0:  ff b4 00 a8 sd	s4,168(sp)
[  44] 0x900000001fc0dbd4:  67 b4 00 00 daddiu	s4,sp,0
[  44] 0x900000001fc0dbd8:  ff b2 00 b8 sd	s2,184(sp)
[  44] 0x900000001fc0dbdc:  ff b3 00 b0 sd	s3,176(sp)
[  44] 0x900000001fc0dbe0:  ff b5 00 a0 sd	s5,160(sp)
[  44] 0x900000001fc0dbe4:  ff b6 00 98 sd	s6,152(sp)
[  44] 0x900000001fc0dbe8:  10 40 00 04 beq	v0,zero,0x900000001fc0dbfc
[  44] 0x900000001fc0dbec:  ff b7 00 90 sd	s7,144(sp)
[  44] 0x900000001fc0dbf0:  16 00 00 02 bne	s0,zero,0x900000001fc0dbfc
[  44] 0x900000001fc0dbf4:  00 00 00 21 nada
[  44] 0x900000001fc0dbf8:  24 11 00 01 li	s1,1
   47: 
   48:     /* Switch off nv_valid if it the valid inventory flag isn't set */
   49:     if (nv_valid)
[  49] 0x900000001fc0dbfc:  ff be 00 88 sd	s8,136(sp)
[  49] 0x900000001fc0dc00:  12 20 00 09 beq	s1,zero,0x900000001fc0dc28
[  49] 0x900000001fc0dc04:  02 20 a8 25 move	s5,s1
   50:         if (get_nvreg(NVOFF_INVENT_VALID) != INVENT_VALID)
[  50] 0x900000001fc0dc08:  0f f0 2f fa jal		get_nvreg
[  50] 0x900000001fc0dc0c:  24 04 01 14 li	a0,276
   51:             nv_valid = 0;
[  51] 0x900000001fc0dc10:  02 20 a8 25 move	s5,s1
[  51] 0x900000001fc0dc14:  38 43 00 4a xori	v1,v0,0x4a
[  51] 0x900000001fc0dc18:  00 03 a8 0b movn	s5,zero,v1
[  51] 0x900000001fc0dc1c:  00 00 00 21 nada
[  51] 0x900000001fc0dc20:  00 00 00 21 nada
[  51] 0x900000001fc0dc24:  00 00 00 21 nada
[  51] 0x900000001fc0dc28:  03 a0 80 25 move	s0,sp
   52: 
   53:     /* Clear out the cpuinfo character array */
   54:     for (i = 0; i < EV_MAX_CPUS; i++)
[  54] 0x900000001fc0dc2c:  24 05 00 04 li	a1,4
[  54] 0x900000001fc0dc30:  00 05 28 2d daddu	a1,zero,a1
[  54] 0x900000001fc0dc34:  24 11 00 31 li	s1,49
[  54] 0x900000001fc0dc38:  00 00 b0 25 move	s6,zero
[  54] 0x900000001fc0dc3c:  00 b1 28 2b sltu	a1,a1,s1
[  54] 0x900000001fc0dc40:  50 a0 00 69 beql	a1,zero,0x900000001fc0dde8
[  54] 0x900000001fc0dc44:  26 cf 00 03 addiu	t3,s6,3
[  54] 0x900000001fc0dc48:  26 c9 00 04 addiu	a5,s6,4
[  54] 0x900000001fc0dc4c:  02 c0 38 25 move	a3,s6
[  54] 0x900000001fc0dc50:  26 c3 00 01 addiu	v1,s6,1
[  54] 0x900000001fc0dc54:  24 01 00 20 li	at,32
[  54] 0x900000001fc0dc58:  24 0a 00 04 li	a6,4
[  54] 0x900000001fc0dc5c:  24 08 00 20 li	a4,32
[  54] 0x900000001fc0dc60:  00 09 30 3c dsll32	a2,a5,0
[  54] 0x900000001fc0dc64:  02 2a 10 2f dsubu	v0,s1,a6
[  54] 0x900000001fc0dc68:  a2 08 00 00 sb	a4,0(s0)
[  54] 0x900000001fc0dc6c:  00 06 30 3e dsrl32	a2,a2,0
[  54] 0x900000001fc0dc70:  00 03 20 3c dsll32	a0,v1,0
[  54] 0x900000001fc0dc74:  25 28 00 04 addiu	a4,a5,4
[  54] 0x900000001fc0dc78:  00 04 20 3e dsrl32	a0,a0,0
[  54] 0x900000001fc0dc7c:  24 e5 00 02 addiu	a1,a3,2
[  54] 0x900000001fc0dc80:  00 05 28 3c dsll32	a1,a1,0
[  54] 0x900000001fc0dc84:  03 a6 50 2d daddu	a6,sp,a2
[  54] 0x900000001fc0dc88:  00 05 28 3e dsrl32	a1,a1,0
[  54] 0x900000001fc0dc8c:  24 e6 00 03 addiu	a2,a3,3
[  54] 0x900000001fc0dc90:  03 a4 20 2d daddu	a0,sp,a0
[  54] 0x900000001fc0dc94:  00 06 30 3c dsll32	a2,a2,0
[  54] 0x900000001fc0dc98:  a1 41 00 00 sb	at,0(a6)
[  54] 0x900000001fc0dc9c:  03 a5 28 2d daddu	a1,sp,a1
[  54] 0x900000001fc0dca0:  00 06 30 3e dsrl32	a2,a2,0
[  54] 0x900000001fc0dca4:  a0 81 00 00 sb	at,0(a0)
[  54] 0x900000001fc0dca8:  03 a6 20 2d daddu	a0,sp,a2
[  54] 0x900000001fc0dcac:  00 08 30 3c dsll32	a2,a4,0
[  54] 0x900000001fc0dcb0:  a0 a1 00 00 sb	at,0(a1)
[  54] 0x900000001fc0dcb4:  00 06 30 3e dsrl32	a2,a2,0
[  54] 0x900000001fc0dcb8:  01 22 28 2b sltu	a1,a5,v0
[  54] 0x900000001fc0dcbc:  a0 81 00 00 sb	at,0(a0)
[  54] 0x900000001fc0dcc0:  10 a0 00 44 beq	a1,zero,0x900000001fc0ddd4
[  54] 0x900000001fc0dcc4:  25 23 00 01 addiu	v1,a5,1
[  54] 0x900000001fc0dcc8:  00 03 20 3c dsll32	a0,v1,0
[  54] 0x900000001fc0dccc:  25 07 00 04 addiu	a3,a4,4
[  54] 0x900000001fc0dcd0:  00 04 20 3e dsrl32	a0,a0,0
[  54] 0x900000001fc0dcd4:  25 25 00 02 addiu	a1,a5,2
[  54] 0x900000001fc0dcd8:  00 05 28 3c dsll32	a1,a1,0
[  54] 0x900000001fc0dcdc:  03 a6 50 2d daddu	a6,sp,a2
[  54] 0x900000001fc0dce0:  00 05 28 3e dsrl32	a1,a1,0
[  54] 0x900000001fc0dce4:  25 26 00 03 addiu	a2,a5,3
[  54] 0x900000001fc0dce8:  03 a4 20 2d daddu	a0,sp,a0
[  54] 0x900000001fc0dcec:  00 06 30 3c dsll32	a2,a2,0
[  54] 0x900000001fc0dcf0:  a1 41 00 00 sb	at,0(a6)
[  54] 0x900000001fc0dcf4:  03 a5 28 2d daddu	a1,sp,a1
[  54] 0x900000001fc0dcf8:  00 06 30 3e dsrl32	a2,a2,0
[  54] 0x900000001fc0dcfc:  a0 81 00 00 sb	at,0(a0)
[  54] 0x900000001fc0dd00:  03 a6 20 2d daddu	a0,sp,a2
[  54] 0x900000001fc0dd04:  00 07 30 3c dsll32	a2,a3,0
[  54] 0x900000001fc0dd08:  a0 a1 00 00 sb	at,0(a1)
[  54] 0x900000001fc0dd0c:  00 06 30 3e dsrl32	a2,a2,0
[  54] 0x900000001fc0dd10:  01 02 28 2b sltu	a1,a4,v0
[  54] 0x900000001fc0dd14:  a0 81 00 00 sb	at,0(a0)
[  54] 0x900000001fc0dd18:  10 a0 00 2a beq	a1,zero,0x900000001fc0ddc4
[  54] 0x900000001fc0dd1c:  25 03 00 01 addiu	v1,a4,1
[  54] 0x900000001fc0dd20:  00 03 20 3c dsll32	a0,v1,0
[  54] 0x900000001fc0dd24:  24 e9 00 04 addiu	a5,a3,4
[  54] 0x900000001fc0dd28:  00 04 20 3e dsrl32	a0,a0,0
[  54] 0x900000001fc0dd2c:  25 05 00 02 addiu	a1,a4,2
[  54] 0x900000001fc0dd30:  00 05 28 3c dsll32	a1,a1,0
[  54] 0x900000001fc0dd34:  03 a6 50 2d daddu	a6,sp,a2
[  54] 0x900000001fc0dd38:  00 05 28 3e dsrl32	a1,a1,0
[  54] 0x900000001fc0dd3c:  25 06 00 03 addiu	a2,a4,3
[  54] 0x900000001fc0dd40:  03 a4 20 2d daddu	a0,sp,a0
[  54] 0x900000001fc0dd44:  00 06 30 3c dsll32	a2,a2,0
[  54] 0x900000001fc0dd48:  a1 41 00 00 sb	at,0(a6)
[  54] 0x900000001fc0dd4c:  03 a5 28 2d daddu	a1,sp,a1
[  54] 0x900000001fc0dd50:  00 06 30 3e dsrl32	a2,a2,0
[  54] 0x900000001fc0dd54:  a0 81 00 00 sb	at,0(a0)
[  54] 0x900000001fc0dd58:  03 a6 20 2d daddu	a0,sp,a2
[  54] 0x900000001fc0dd5c:  00 09 30 3c dsll32	a2,a5,0
[  54] 0x900000001fc0dd60:  a0 a1 00 00 sb	at,0(a1)
[  54] 0x900000001fc0dd64:  00 06 30 3e dsrl32	a2,a2,0
[  54] 0x900000001fc0dd68:  00 e2 28 2b sltu	a1,a3,v0
[  54] 0x900000001fc0dd6c:  a0 81 00 00 sb	at,0(a0)
[  54] 0x900000001fc0dd70:  14 a0 ff bf bne	a1,zero,0x900000001fc0dc70
[  54] 0x900000001fc0dd74:  24 e3 00 01 addiu	v1,a3,1
[  54] 0x900000001fc0dd78:  00 c0 88 25 move	s1,a2
[  54] 0x900000001fc0dd7c:  00 e0 90 25 move	s2,a3
[  54] 0x900000001fc0dd80:  00 60 98 25 move	s3,v1
[  54] 0x900000001fc0dd84:  00 13 68 3c dsll32	t1,s3,0
[  54] 0x900000001fc0dd88:  26 4c 00 02 addiu	t0,s2,2
[  54] 0x900000001fc0dd8c:  00 0d 68 3e dsrl32	t1,t1,0
[  54] 0x900000001fc0dd90:  26 4b 00 03 addiu	a7,s2,3
[  54] 0x900000001fc0dd94:  00 0c 60 3c dsll32	t0,t0,0
[  54] 0x900000001fc0dd98:  00 0b 58 3c dsll32	a7,a7,0
[  54] 0x900000001fc0dd9c:  00 0c 60 3e dsrl32	t0,t0,0
[  54] 0x900000001fc0dda0:  03 ad 68 2d daddu	t1,sp,t1
[  54] 0x900000001fc0dda4:  00 0b 58 3e dsrl32	a7,a7,0
[  54] 0x900000001fc0dda8:  03 ac 60 2d daddu	t0,sp,t0
[  54] 0x900000001fc0ddac:  03 ab 58 2d daddu	a7,sp,a7
[  54] 0x900000001fc0ddb0:  a1 a1 00 00 sb	at,0(t1)
[  54] 0x900000001fc0ddb4:  03 b1 80 2d daddu	s0,sp,s1
[  54] 0x900000001fc0ddb8:  a1 81 00 00 sb	at,0(t0)
[  54] 0x900000001fc0ddbc:  10 00 00 23 b		0x900000001fc0de4c
[  54] 0x900000001fc0ddc0:  a1 61 00 00 sb	at,0(a7)
[  54] 0x900000001fc0ddc4:  00 c0 88 25 move	s1,a2
[  54] 0x900000001fc0ddc8:  01 00 90 25 move	s2,a4
[  54] 0x900000001fc0ddcc:  10 00 ff ed b		0x900000001fc0dd84
[  54] 0x900000001fc0ddd0:  00 60 98 25 move	s3,v1
[  54] 0x900000001fc0ddd4:  00 c0 88 25 move	s1,a2
[  54] 0x900000001fc0ddd8:  01 20 90 25 move	s2,a5
[  54] 0x900000001fc0dddc:  10 00 ff e9 b		0x900000001fc0dd84
[  54] 0x900000001fc0dde0:  00 60 98 25 move	s3,v1
[  54] 0x900000001fc0dde4:  26 cf 00 03 addiu	t3,s6,3
[  54] 0x900000001fc0dde8:  00 0f 90 3c dsll32	s2,t3,0
[  54] 0x900000001fc0ddec:  00 12 90 3e dsrl32	s2,s2,0
[  54] 0x900000001fc0ddf0:  26 ce 00 01 addiu	t2,s6,1
[  54] 0x900000001fc0ddf4:  00 0e 98 3c dsll32	s3,t2,0
[  54] 0x900000001fc0ddf8:  26 ce 00 02 addiu	t2,s6,2
[  54] 0x900000001fc0ddfc:  00 0e 70 3c dsll32	t2,t2,0
[  54] 0x900000001fc0de00:  00 13 98 3e dsrl32	s3,s3,0
[  54] 0x900000001fc0de04:  24 0f 00 20 li	t3,32
[  54] 0x900000001fc0de08:  00 0e 70 3e dsrl32	t2,t2,0
[  54] 0x900000001fc0de0c:  03 b3 98 2d daddu	s3,sp,s3
[  54] 0x900000001fc0de10:  a2 0f 00 00 sb	t3,0(s0)
[  54] 0x900000001fc0de14:  26 d6 00 04 addiu	s6,s6,4
[  54] 0x900000001fc0de18:  03 ae 70 2d daddu	t2,sp,t2
[  54] 0x900000001fc0de1c:  00 16 80 3c dsll32	s0,s6,0
[  54] 0x900000001fc0de20:  03 b2 90 2d daddu	s2,sp,s2
[  54] 0x900000001fc0de24:  a2 6f 00 00 sb	t3,0(s3)
[  54] 0x900000001fc0de28:  00 10 80 3e dsrl32	s0,s0,0
[  54] 0x900000001fc0de2c:  a1 cf 00 00 sb	t3,0(t2)
[  54] 0x900000001fc0de30:  02 d1 70 2b sltu	t2,s6,s1
[  54] 0x900000001fc0de34:  a2 4f 00 00 sb	t3,0(s2)
[  54] 0x900000001fc0de38:  26 cf 00 03 addiu	t3,s6,3
[  54] 0x900000001fc0de3c:  00 0f 90 3c dsll32	s2,t3,0
[  54] 0x900000001fc0de40:  03 b0 80 2d daddu	s0,sp,s0
[  54] 0x900000001fc0de44:  15 c0 ff ea bne	t2,zero,0x900000001fc0ddf0
[  54] 0x900000001fc0de48:  00 12 90 3e dsrl32	s2,s2,0
[  54] 0x900000001fc0de4c:  00 00 88 25 move	s1,zero
   55:         cpuinfo[i] = ' ';
   56: 
   57:     cpuinfo[i] = '\0';   /* Null terminate */
   58: 
   59:     for (i = 1; i < EV_MAX_SLOTS; i++) {
[  59] 0x900000001fc0de50:  ff b5 00 60 sd	s5,96(sp)
[  59] 0x900000001fc0de54:  3c 15 90 00 lui	s5,0x9000
[  59] 0x900000001fc0de58:  62 b7 00 00 daddi	s7,s5,0
[  59] 0x900000001fc0de5c:  24 16 00 01 li	s6,1
[  59] 0x900000001fc0de60:  3c 18 1f c2 lui	t8,0x1fc2
[  59] 0x900000001fc0de64:  00 16 a8 3c dsll32	s5,s6,0
[  59] 0x900000001fc0de68:  63 1f cf 18 daddi	ra,t8,-12520
[  59] 0x900000001fc0de6c:  00 15 a8 3e dsrl32	s5,s5,0
[  59] 0x900000001fc0de70:  24 02 00 1c li	v0,28
[  59] 0x900000001fc0de74:  00 17 c0 3c dsll32	t8,s7,0
[  57] 0x900000001fc0de78:  a2 00 00 00 sb	zero,0(s0)
[  57] 0x900000001fc0de7c:  24 01 01 c0 li	at,448
[  57] 0x900000001fc0de80:  00 15 c8 b8 dsll	t9,s5,2
[  57] 0x900000001fc0de84:  ff a2 00 70 sd	v0,112(sp)
[  57] 0x900000001fc0de88:  df a3 00 70 ld	v1,112(sp)
[  57] 0x900000001fc0de8c:  00 15 b9 38 dsll	s7,s5,4
[  57] 0x900000001fc0de90:  03 1f c0 2c dadd	t8,t8,ra
[  57] 0x900000001fc0de94:  ff a1 00 78 sd	at,120(sp)
[  57] 0x900000001fc0de98:  00 15 a9 f8 dsll	s5,s5,7
[  57] 0x900000001fc0de9c:  02 f9 b8 2d daddu	s7,s7,t9
[  57] 0x900000001fc0dea0:  24 1e 00 ff li	s8,255
[  57] 0x900000001fc0dea4:  ff b8 00 68 sd	t8,104(sp)
[  57] 0x900000001fc0dea8:  df a2 00 68 ld	v0,104(sp)
[  57] 0x900000001fc0deac:  02 b7 08 2f dsubu	at,s5,s7
[  57] 0x900000001fc0deb0:  24 75 01 27 addiu	s5,v1,295
[  57] 0x900000001fc0deb4:  df a8 00 50 ld	a4,80(sp)
   60:         brd = &(EVCFGINFO->ecfg_board[i]);
[  60] 0x900000001fc0deb8:  dc 42 00 00 ld	v0,0(v0)
[  60] 0x900000001fc0debc:  00 22 b8 2f dsubu	s7,at,v0
   61: 
   62:         /* Skip non-CPU boards */
   63:         if ((brd->eb_type & EVCLASS_MASK) != EVCLASS_CPU)
[  63] 0x900000001fc0dec0:  24 70 01 1b addiu	s0,v1,283
[  63] 0x900000001fc0dec4:  92 e1 00 64 lbu	at,100(s7)
[  63] 0x900000001fc0dec8:  30 21 00 f0 andi	at,at,0xf0
[  63] 0x900000001fc0decc:  24 02 00 10 li	v0,16
[  63] 0x900000001fc0ded0:  54 22 00 05 bnel	at,v0,0x900000001fc0dee8
[  63] 0x900000001fc0ded4:  00 00 88 25 move	s1,zero
   64:             continue;
   65: 
   66: 	for (c = 0; c < EV_CPU_PER_BOARD; c++) {
[  66] 0x900000001fc0ded8:  24 01 00 20 li	at,32
[  66] 0x900000001fc0dedc:  10 00 00 22 b		0x900000001fc0df68
[  66] 0x900000001fc0dee0:  df a9 00 58 ld	a5,88(sp)
[  66] 0x900000001fc0dee4:  00 00 88 25 move	s1,zero
[  66] 0x900000001fc0dee8:  df a2 00 68 ld	v0,104(sp)
[  59] 0x900000001fc0deec:  26 d6 00 01 addiu	s6,s6,1
[  59] 0x900000001fc0def0:  00 16 28 3c dsll32	a1,s6,0
[  59] 0x900000001fc0def4:  00 05 30 3e dsrl32	a2,a1,0
[  59] 0x900000001fc0def8:  df a4 00 70 ld	a0,112(sp)
[  59] 0x900000001fc0defc:  00 06 38 b8 dsll	a3,a2,2
[  59] 0x900000001fc0df00:  24 84 00 1c addiu	a0,a0,28
[  59] 0x900000001fc0df04:  ff a4 00 70 sd	a0,112(sp)
[  59] 0x900000001fc0df08:  df a3 00 70 ld	v1,112(sp)
[  59] 0x900000001fc0df0c:  00 06 29 38 dsll	a1,a2,4
[  59] 0x900000001fc0df10:  00 06 31 f8 dsll	a2,a2,7
[  59] 0x900000001fc0df14:  00 a7 38 2d daddu	a3,a1,a3
[  59] 0x900000001fc0df18:  df a5 00 78 ld	a1,120(sp)
[  59] 0x900000001fc0df1c:  24 75 01 27 addiu	s5,v1,295
[  59] 0x900000001fc0df20:  00 c7 08 2f dsubu	at,a2,a3
[  59] 0x900000001fc0df24:  54 85 ff e4 bnel	a0,a1,0x900000001fc0deb8
[  59] 0x900000001fc0df28:  df a8 00 50 ld	a4,80(sp)
[  59] 0x900000001fc0df2c:  df b7 00 90 ld	s7,144(sp)
[  59] 0x900000001fc0df30:  df b1 00 c0 ld	s1,192(sp)
[  59] 0x900000001fc0df34:  df be 00 88 ld	s8,136(sp)
   67: 
   68: 	    /* Special case the behaviour for the boot master */
   69: 	    if ((i == slot) && (c == slice)) {
   70: 		*currcpu++ = SCSTAT_BOOTMASTER;
   71: 		continue;
   72: 	    }
   73: 
   74: 	    /* Check to see whether processor is alive */
   75: 	    if ( brd->eb_cpuarr[c].cpu_vpid != CPUST_NORESP ) {
   76: 		/* See if processor is enabled */
   77: 		if (nv_valid && !INV_READU(i, c, INVU_ENABLE)) {
   78: 		    *currcpu++ = SCSTAT_DISABLED;
   79:                 } else if ( brd->eb_cpuarr[c].cpu_diagval ) {
   80: 		    *currcpu++ = SCSTAT_BROKEN;
   81: 		} else {
   82:                     *currcpu++ = SCSTAT_WORKING;
   83: 		}
   84:             } else {
   85:                 /* Processor didn't respond - either it isn't there
   86:                    or it is seriously hosed */
   87: 		if (nv_valid && !INV_READU(i, c, INVU_ENABLE))
   88: 		    *currcpu++ = SCSTAT_DISABLED;
   89: 		else
   90:                     *currcpu++ = SCSTAT_UNKNOWN;
   91:             }
   92:    	}
   93:     } 
   94: 
   95:     /* Fire the CPU status string off to the system controller */
   96:     sysctlr_bootstat(cpuinfo, 0);
[  96] 0x900000001fc0df38:  df b5 00 a0 ld	s5,160(sp)
[  96] 0x900000001fc0df3c:  00 00 28 25 move	a1,zero
[  96] 0x900000001fc0df40:  df b0 00 c8 ld	s0,200(sp)
[  96] 0x900000001fc0df44:  df b6 00 98 ld	s6,152(sp)
[  96] 0x900000001fc0df48:  0f f0 3e 16 jal		sysctlr_bootstat
[  96] 0x900000001fc0df4c:  67 a4 00 00 daddiu	a0,sp,0
   97: }
[  97] 0x900000001fc0df50:  df b4 00 a8 ld	s4,168(sp)
[  97] 0x900000001fc0df54:  df bf 00 80 ld	ra,128(sp)
[  97] 0x900000001fc0df58:  df b2 00 b8 ld	s2,184(sp)
[  97] 0x900000001fc0df5c:  df b3 00 b0 ld	s3,176(sp)
[  97] 0x900000001fc0df60:  03 e0 00 08 jr	ra
[  97] 0x900000001fc0df64:  67 bd 00 d0 daddiu	sp,sp,208
[  97] 0x900000001fc0df68:  24 19 00 42 li	t9,66
[  97] 0x900000001fc0df6c:  66 93 00 01 daddiu	s3,s4,1
[  69] 0x900000001fc0df70:  56 c8 00 05 bnel	s6,a4,0x900000001fc0df88
[  69] 0x900000001fc0df74:  df ad 00 60 ld	t1,96(sp)
[  69] 0x900000001fc0df78:  df a8 00 50 ld	a4,80(sp)
[  69] 0x900000001fc0df7c:  52 29 00 3c beql	s1,a5,0x900000001fc0e070
[  69] 0x900000001fc0df80:  26 10 00 03 addiu	s0,s0,3
[  69] 0x900000001fc0df84:  df ad 00 60 ld	t1,96(sp)
[  75] 0x900000001fc0df88:  00 11 50 3c dsll32	a6,s1,0
[  75] 0x900000001fc0df8c:  00 0a 57 3a dsrl	a6,a6,28
[  75] 0x900000001fc0df90:  02 ea 90 2d daddu	s2,s7,a6
[  75] 0x900000001fc0df94:  92 4a 00 0c lbu	a6,12(s2)
[  75] 0x900000001fc0df98:  15 5e 00 15 bne	a6,s8,0x900000001fc0dff0
[  75] 0x900000001fc0df9c:  df ab 00 60 ld	a7,96(sp)
[  87] 0x900000001fc0dfa0:  51 60 00 09 beql	a7,zero,0x900000001fc0dfc8
[  87] 0x900000001fc0dfa4:  df a8 00 50 ld	a4,80(sp)
[  87] 0x900000001fc0dfa8:  0f f0 2f fa jal		get_nvreg
[  87] 0x900000001fc0dfac:  02 00 20 25 move	a0,s0
[  87] 0x900000001fc0dfb0:  24 0c 00 44 li	t0,68
[  87] 0x900000001fc0dfb4:  df a8 00 50 ld	a4,80(sp)
[  87] 0x900000001fc0dfb8:  24 01 00 20 li	at,32
[  87] 0x900000001fc0dfbc:  50 40 00 08 beql	v0,zero,0x900000001fc0dfe0
[  87] 0x900000001fc0dfc0:  26 10 00 03 addiu	s0,s0,3
[  87] 0x900000001fc0dfc4:  df a8 00 50 ld	a4,80(sp)
[  90] 0x900000001fc0dfc8:  a2 81 00 00 sb	at,0(s4)
[  90] 0x900000001fc0dfcc:  02 60 a0 25 move	s4,s3
[  90] 0x900000001fc0dfd0:  26 10 00 03 addiu	s0,s0,3
[  90] 0x900000001fc0dfd4:  10 00 00 29 b		0x900000001fc0e07c
[  90] 0x900000001fc0dfd8:  26 31 00 01 addiu	s1,s1,1
[  88] 0x900000001fc0dfdc:  26 10 00 03 addiu	s0,s0,3
[  88] 0x900000001fc0dfe0:  a2 8c 00 00 sb	t0,0(s4)
[  88] 0x900000001fc0dfe4:  02 60 a0 25 move	s4,s3
[  88] 0x900000001fc0dfe8:  10 00 00 24 b		0x900000001fc0e07c
[  88] 0x900000001fc0dfec:  26 31 00 01 addiu	s1,s1,1
[  77] 0x900000001fc0dff0:  51 a0 00 09 beql	t1,zero,0x900000001fc0e018
[  77] 0x900000001fc0dff4:  24 0f 00 2b li	t3,43
[  77] 0x900000001fc0dff8:  0f f0 2f fa jal		get_nvreg
[  77] 0x900000001fc0dffc:  02 00 20 25 move	a0,s0
[  77] 0x900000001fc0e000:  24 18 00 44 li	t8,68
[  77] 0x900000001fc0e004:  df a8 00 50 ld	a4,80(sp)
[  77] 0x900000001fc0e008:  24 01 00 20 li	at,32
[  77] 0x900000001fc0e00c:  50 40 00 13 beql	v0,zero,0x900000001fc0e05c
[  77] 0x900000001fc0e010:  26 10 00 03 addiu	s0,s0,3
[  77] 0x900000001fc0e014:  24 0f 00 2b li	t3,43
[  79] 0x900000001fc0e018:  92 4e 00 0b lbu	t2,11(s2)
[  79] 0x900000001fc0e01c:  24 12 00 58 li	s2,88
[  79] 0x900000001fc0e020:  55 c0 00 08 bnel	t2,zero,0x900000001fc0e044
[  79] 0x900000001fc0e024:  df a8 00 50 ld	a4,80(sp)
[  82] 0x900000001fc0e028:  26 10 00 03 addiu	s0,s0,3
[  82] 0x900000001fc0e02c:  a2 8f 00 00 sb	t3,0(s4)
[  82] 0x900000001fc0e030:  02 60 a0 25 move	s4,s3
[  82] 0x900000001fc0e034:  df a8 00 50 ld	a4,80(sp)
[  82] 0x900000001fc0e038:  10 00 00 10 b		0x900000001fc0e07c
[  82] 0x900000001fc0e03c:  26 31 00 01 addiu	s1,s1,1
[  82] 0x900000001fc0e040:  df a8 00 50 ld	a4,80(sp)
[  80] 0x900000001fc0e044:  26 10 00 03 addiu	s0,s0,3
[  80] 0x900000001fc0e048:  a2 92 00 00 sb	s2,0(s4)
[  80] 0x900000001fc0e04c:  02 60 a0 25 move	s4,s3
[  80] 0x900000001fc0e050:  10 00 00 0a b		0x900000001fc0e07c
[  80] 0x900000001fc0e054:  26 31 00 01 addiu	s1,s1,1
[  78] 0x900000001fc0e058:  26 10 00 03 addiu	s0,s0,3
[  78] 0x900000001fc0e05c:  a2 98 00 00 sb	t8,0(s4)
[  78] 0x900000001fc0e060:  02 60 a0 25 move	s4,s3
[  78] 0x900000001fc0e064:  10 00 00 05 b		0x900000001fc0e07c
[  78] 0x900000001fc0e068:  26 31 00 01 addiu	s1,s1,1
[  71] 0x900000001fc0e06c:  26 10 00 03 addiu	s0,s0,3
[  71] 0x900000001fc0e070:  26 31 00 01 addiu	s1,s1,1
[  71] 0x900000001fc0e074:  a2 99 00 00 sb	t9,0(s4)
[  71] 0x900000001fc0e078:  02 60 a0 25 move	s4,s3
[  66] 0x900000001fc0e07c:  56 15 ff ba bnel	s0,s5,0x900000001fc0df68
[  66] 0x900000001fc0e080:  df a9 00 58 ld	a5,88(sp)
[  66] 0x900000001fc0e084:  10 00 ff 98 b		0x900000001fc0dee8
[  66] 0x900000001fc0e088:  00 00 88 25 move	s1,zero
   98: 
   99: 
  100: void check_slaves(int slot, int slice) {
check_slaves:
[ 100] 0x900000001fc0e08c:  67 bd ff 10 daddiu	sp,sp,-240
[ 100] 0x900000001fc0e090:  00 80 60 25 move	t0,a0
[ 100] 0x900000001fc0e094:  00 a0 58 25 move	a7,a1
  101:     int i, j;
  102:     int done;
  103:     int slave_errs = 0;
  104:     unsigned int time, timeout, last_print, tout;
  105:     unsigned int cur_time;
  106:     int max_promrev = 0;	/* Highest PROM rev on the system */
  107:     evbrdinfo_t *brdinfo;
  108:     volatile unsigned char *stat;
  109: 
  110:     time = LD_RTC();
  111:     timeout = time + SLAVE_TOUT;
  112:     last_print = 0;
[ 112] 0x900000001fc0e098:  ff b2 00 d0 sd	s2,208(sp)
[ 112] 0x900000001fc0e09c:  00 00 90 25 move	s2,zero
  113:     tout = 0;
[ 113] 0x900000001fc0e0a0:  ff b1 00 d8 sd	s1,216(sp)
[ 113] 0x900000001fc0e0a4:  00 00 88 25 move	s1,zero
[ 113] 0x900000001fc0e0a8:  ff b3 00 c8 sd	s3,200(sp)
[ 113] 0x900000001fc0e0ac:  3c 13 00 04 lui	s3,0x4
[ 110] 0x900000001fc0e0b0:  3c 02 90 00 lui	v0,0x9000
[ 110] 0x900000001fc0e0b4:  3c 01 1f c2 lui	at,0x1fc2
[ 110] 0x900000001fc0e0b8:  60 46 00 00 daddi	a2,v0,0
[ 110] 0x900000001fc0e0bc:  60 2a cf 18 daddi	a6,at,-12520
[ 110] 0x900000001fc0e0c0:  3c 02 90 00 lui	v0,0x9000
[ 110] 0x900000001fc0e0c4:  3c 01 1f c2 lui	at,0x1fc2
[ 110] 0x900000001fc0e0c8:  60 42 00 00 daddi	v0,v0,0
[ 110] 0x900000001fc0e0cc:  60 24 cf 18 daddi	a0,at,-12520
[ 110] 0x900000001fc0e0d0:  3c 01 90 00 lui	at,0x9000
[ 110] 0x900000001fc0e0d4:  ff bf 00 e8 sd	ra,232(sp)
[ 110] 0x900000001fc0e0d8:  3c 03 1f c2 lui	v1,0x1fc2
[ 110] 0x900000001fc0e0dc:  60 21 00 00 daddi	at,at,0
[ 110] 0x900000001fc0e0e0:  ff be 00 a0 sd	s8,160(sp)
[ 110] 0x900000001fc0e0e4:  60 63 cf 18 daddi	v1,v1,-12520
[ 110] 0x900000001fc0e0e8:  3c 05 90 00 lui	a1,0x9000
[ 110] 0x900000001fc0e0ec:  ff b7 00 a8 sd	s7,168(sp)
[ 110] 0x900000001fc0e0f0:  00 06 30 3c dsll32	a2,a2,0
[ 110] 0x900000001fc0e0f4:  3c 07 90 00 lui	a3,0x9000
[ 110] 0x900000001fc0e0f8:  ff b6 00 b0 sd	s6,176(sp)
[ 110] 0x900000001fc0e0fc:  00 ca 30 2c dadd	a2,a2,a6
[ 110] 0x900000001fc0e100:  60 a5 00 00 daddi	a1,a1,0
[ 110] 0x900000001fc0e104:  ff b4 00 c0 sd	s4,192(sp)
[ 110] 0x900000001fc0e108:  60 e7 00 00 daddi	a3,a3,0
[ 110] 0x900000001fc0e10c:  ff ac 00 20 sd	t0,32(sp)
[ 110] 0x900000001fc0e110:  3c 08 1f c2 lui	a4,0x1fc2
[ 110] 0x900000001fc0e114:  00 02 10 3c dsll32	v0,v0,0
[ 110] 0x900000001fc0e118:  ff ab 00 28 sd	a7,40(sp)
[ 110] 0x900000001fc0e11c:  dc d4 01 c0 ld	s4,448(a2)
[ 106] 0x900000001fc0e120:  61 09 cf 78 daddi	a5,a4,-12424
[ 106] 0x900000001fc0e124:  ff a0 00 30 sd	zero,48(sp)
[ 106] 0x900000001fc0e128:  00 44 10 2c dadd	v0,v0,a0
[ 106] 0x900000001fc0e12c:  3c 08 1f c2 lui	a4,0x1fc2
[ 106] 0x900000001fc0e130:  00 05 28 3c dsll32	a1,a1,0
[ 106] 0x900000001fc0e134:  de 84 00 00 ld	a0,0(s4)
[ 106] 0x900000001fc0e138:  ff b5 00 b8 sd	s5,184(sp)
[ 106] 0x900000001fc0e13c:  00 01 08 3c dsll32	at,at,0
[ 106] 0x900000001fc0e140:  00 a9 28 2c dadd	a1,a1,a5
[ 106] 0x900000001fc0e144:  dc 42 04 d0 ld	v0,1232(v0)
[ 106] 0x900000001fc0e148:  ff b0 00 e0 sd	s0,224(sp)
[ 106] 0x900000001fc0e14c:  00 07 38 3c dsll32	a3,a3,0
[ 106] 0x900000001fc0e150:  ff a5 00 38 sd	a1,56(sp)
[ 106] 0x900000001fc0e154:  00 23 08 2c dadd	at,at,v1
[ 106] 0x900000001fc0e158:  61 08 c7 a0 daddi	a4,a4,-14432
[ 106] 0x900000001fc0e15c:  00 04 22 3b dsra	a0,a0,8
[ 106] 0x900000001fc0e160:  ff a2 00 40 sd	v0,64(sp)
[ 106] 0x900000001fc0e164:  df ad 00 40 ld	t1,64(sp)
[ 111] 0x900000001fc0e168:  00 04 a8 00 sll	s5,a0,0
[ 111] 0x900000001fc0e16c:  3c 02 00 c0 lui	v0,0xc0
[ 111] 0x900000001fc0e170:  ff a1 00 48 sd	at,72(sp)
[ 111] 0x900000001fc0e174:  dc 21 04 d8 ld	at,1240(at)
  114: 
  115:     for (i = 0; i < EV_MAX_SLOTS; i ++) {
[ 115] 0x900000001fc0e178:  00 e8 f0 2c dadd	s8,a3,a4
[ 115] 0x900000001fc0e17c:  02 a2 b0 21 addu	s6,s5,v0
[ 115] 0x900000001fc0e180:  ff a1 00 50 sd	at,80(sp)
[ 115] 0x900000001fc0e184:  df b9 00 30 ld	t9,48(sp)
[ 115] 0x900000001fc0e188:  24 18 00 ff li	t8,255
  116: 	brdinfo = &(EVCFGINFO->ecfg_board[i]);
  117: 	if ((brdinfo->eb_type & EVCLASS_MASK) == EVCLASS_CPU) {
[ 117] 0x900000001fc0e18c:  ff ad 00 58 sd	t1,88(sp)
[ 117] 0x900000001fc0e190:  65 ae 00 0b daddiu	t2,t1,11
[ 117] 0x900000001fc0e194:  ff ae 00 60 sd	t2,96(sp)
[ 117] 0x900000001fc0e198:  65 ae 00 40 daddiu	t2,t1,64
[ 117] 0x900000001fc0e19c:  65 af 00 6c daddiu	t3,t1,108
[ 117] 0x900000001fc0e1a0:  91 ad 00 64 lbu	t1,100(t1)
[ 117] 0x900000001fc0e1a4:  df b7 00 58 ld	s7,88(sp)
[ 117] 0x900000001fc0e1a8:  ff ae 00 68 sd	t2,104(sp)
[ 117] 0x900000001fc0e1ac:  31 ad 00 f0 andi	t1,t1,0xf0
[ 117] 0x900000001fc0e1b0:  24 0e 00 10 li	t2,16
[ 117] 0x900000001fc0e1b4:  ff af 00 40 sd	t3,64(sp)
[ 117] 0x900000001fc0e1b8:  55 ae 00 45 bnel	t1,t2,0x900000001fc0e2d0
[ 117] 0x900000001fc0e1bc:  df a9 00 40 ld	a5,64(sp)
[ 116] 0x900000001fc0e1c0:  24 10 00 01 li	s0,1
  118: 	    /* Print the slot we're looking at */
  119: 	    DPRINTF((" %a", i));
  120:  	    for (j = 0; j < EV_CPU_PER_BOARD; j++) {
  121: 		if ((brdinfo->eb_cpuarr[j].cpu_vpid == CPUST_NORESP) ||
[ 121] 0x900000001fc0e1c4:  92 ff 00 0f lbu	ra,15(s7)
[ 121] 0x900000001fc0e1c8:  92 f7 00 0c lbu	s7,12(s7)
[ 121] 0x900000001fc0e1cc:  df a1 00 58 ld	at,88(sp)
[ 121] 0x900000001fc0e1d0:  12 f8 00 0a beq	s7,t8,0x900000001fc0e1fc
[ 121] 0x900000001fc0e1d4:  03 3f c8 2a slt	t9,t9,ra
  122: 			    (brdinfo->eb_cpuarr[j].cpu_vpid == 0))
  123: 		    done = 1;
[ 123] 0x900000001fc0e1d8:  24 10 00 01 li	s0,1
[ 123] 0x900000001fc0e1dc:  df b7 00 60 ld	s7,96(sp)
[ 123] 0x900000001fc0e1e0:  90 21 00 0c lbu	at,12(at)
  124: 		else
  125: 		    done = 0;
[ 125] 0x900000001fc0e1e4:  00 01 80 0b movn	s0,zero,at
[ 125] 0x900000001fc0e1e8:  00 00 00 21 nada
[ 125] 0x900000001fc0e1ec:  00 00 00 21 nada
[ 125] 0x900000001fc0e1f0:  00 00 00 21 nada
[ 125] 0x900000001fc0e1f4:  10 00 00 02 b		0x900000001fc0e200
[ 125] 0x900000001fc0e1f8:  00 00 00 21 nada
[ 123] 0x900000001fc0e1fc:  df b7 00 60 ld	s7,96(sp)
[ 123] 0x900000001fc0e200:  df a2 00 58 ld	v0,88(sp)
  126: 		stat = &(brdinfo->eb_cpuarr[j].cpu_diagval);
  127: 
  128: 		/* Keep track of the highest prom revisions on the
  129: 		 * machine.
  130: 		 */
  131: 		if ((brdinfo->eb_cpuarr[j].cpu_promrev > max_promrev) &&
[ 131] 0x900000001fc0e204:  13 20 00 06 beq	t9,zero,0x900000001fc0e220
[ 131] 0x900000001fc0e208:  df a3 00 58 ld	v1,88(sp)
[ 126] 0x900000001fc0e20c:  90 42 00 0f lbu	v0,15(v0)
[ 126] 0x900000001fc0e210:  50 40 00 04 beql	v0,zero,0x900000001fc0e224
[ 126] 0x900000001fc0e214:  92 eb 00 00 lbu	a7,0(s7)
  132: 				brdinfo->eb_cpuarr[j].cpu_promrev)
  133: 		    max_promrev = brdinfo->eb_cpuarr[j].cpu_promrev;
[ 133] 0x900000001fc0e218:  90 63 00 0f lbu	v1,15(v1)
[ 133] 0x900000001fc0e21c:  ff a3 00 30 sd	v1,48(sp)
  134: 		do {
  135: 		    switch (*stat) {
[ 135] 0x900000001fc0e220:  92 eb 00 00 lbu	a7,0(s7)
[ 135] 0x900000001fc0e224:  29 79 00 fa slti	t9,a7,250
[ 135] 0x900000001fc0e228:  29 64 00 f0 slti	a0,a7,240
[ 135] 0x900000001fc0e22c:  54 80 00 09 bnel	a0,zero,0x900000001fc0e254
[ 135] 0x900000001fc0e230:  24 10 00 01 li	s0,1
[ 135] 0x900000001fc0e234:  53 20 00 07 beql	t9,zero,0x900000001fc0e254
[ 135] 0x900000001fc0e238:  24 10 00 01 li	s0,1
[ 135] 0x900000001fc0e23c:  00 0b 28 f8 dsll	a1,a7,3
[ 135] 0x900000001fc0e240:  00 be 28 2d daddu	a1,a1,s8
[ 135] 0x900000001fc0e244:  dc a5 00 00 ld	a1,0(a1)
[ 135] 0x900000001fc0e248:  00 a0 00 08 jr	a1
[ 135] 0x900000001fc0e24c:  00 00 00 21 nada
  136: 		    case EVDIAG_TESTING_DCACHE:
  137: 		    case EVDIAG_TESTING_ICACHE:
  138: 		    case EVDIAG_TESTING_SCACHE:
  139: 		    case EVDIAG_INITING_CACHES:
  140: 		    case EVDIAG_INITING_SCACHE:
  141: 		    case EVDIAG_WRCPUINFO:
  142: 		    case EVDIAG_TESTING_CCJOIN:
  143: 		    case EVDIAG_TESTING_CCWG:
  144: 			break;
  145: 		    default:
  146: 			done = 1;
[ 146] 0x900000001fc0e250:  24 10 00 01 li	s0,1
  147: 		    } /* switch */
  148: 		    cur_time = LD_RTC();
[ 148] 0x900000001fc0e254:  de 86 00 00 ld	a2,0(s4)
[ 148] 0x900000001fc0e258:  00 06 32 3b dsra	a2,a2,8
[ 148] 0x900000001fc0e25c:  00 06 c8 00 sll	t9,a2,0
  149: 		    if (cur_time - last_print > 0x40000) {
[ 149] 0x900000001fc0e260:  03 32 30 23 subu	a2,t9,s2
[ 149] 0x900000001fc0e264:  02 66 30 2b sltu	a2,s3,a2
[ 149] 0x900000001fc0e268:  10 c0 00 04 beq	a2,zero,0x900000001fc0e27c
[ 149] 0x900000001fc0e26c:  00 00 00 21 nada
  150: 			last_print = cur_time;
[ 150] 0x900000001fc0e270:  03 20 90 25 move	s2,t9
[ 150] 0x900000001fc0e274:  0f f0 2c e3 jal		loprintf
[ 150] 0x900000001fc0e278:  df a4 00 38 ld	a0,56(sp)
[ 134] 0x900000001fc0e27c:  56 00 00 08 bnel	s0,zero,0x900000001fc0e2a0
[ 134] 0x900000001fc0e280:  24 18 00 ff li	t8,255
[ 134] 0x900000001fc0e284:  02 c0 28 25 move	a1,s6
[ 134] 0x900000001fc0e288:  0f f0 40 b6 jal		timed_out
[ 134] 0x900000001fc0e28c:  02 a0 20 25 move	a0,s5
[ 134] 0x900000001fc0e290:  02 22 88 21 addu	s1,s1,v0
[ 134] 0x900000001fc0e294:  52 20 ff e3 beql	s1,zero,0x900000001fc0e224
[ 134] 0x900000001fc0e298:  92 eb 00 00 lbu	a7,0(s7)
[ 134] 0x900000001fc0e29c:  24 18 00 ff li	t8,255
[ 134] 0x900000001fc0e2a0:  24 10 00 01 li	s0,1
[ 120] 0x900000001fc0e2a4:  df a8 00 60 ld	a4,96(sp)
[ 120] 0x900000001fc0e2a8:  df a7 00 58 ld	a3,88(sp)
[ 120] 0x900000001fc0e2ac:  df b9 00 30 ld	t9,48(sp)
[ 120] 0x900000001fc0e2b0:  65 08 00 10 daddiu	a4,a4,16
[ 120] 0x900000001fc0e2b4:  64 e7 00 10 daddiu	a3,a3,16
[ 120] 0x900000001fc0e2b8:  ff a8 00 60 sd	a4,96(sp)
[ 120] 0x900000001fc0e2bc:  df a8 00 68 ld	a4,104(sp)
[ 120] 0x900000001fc0e2c0:  ff a7 00 58 sd	a3,88(sp)
[ 120] 0x900000001fc0e2c4:  14 e8 ff bf bne	a3,a4,0x900000001fc0e1c4
[ 120] 0x900000001fc0e2c8:  df b7 00 58 ld	s7,88(sp)
[ 115] 0x900000001fc0e2cc:  df a9 00 40 ld	a5,64(sp)
[ 115] 0x900000001fc0e2d0:  df aa 00 50 ld	a6,80(sp)
[ 115] 0x900000001fc0e2d4:  df ad 00 40 ld	t1,64(sp)
[ 115] 0x900000001fc0e2d8:  55 2a ff ab bnel	a5,a6,0x900000001fc0e188
[ 115] 0x900000001fc0e2dc:  df b9 00 30 ld	t9,48(sp)
[ 115] 0x900000001fc0e2e0:  df ab 00 48 ld	a7,72(sp)
[ 115] 0x900000001fc0e2e4:  00 00 98 25 move	s3,zero
[ 115] 0x900000001fc0e2e8:  00 00 a8 25 move	s5,zero
  151: 			loprintf(".");
  152: 		    }
  153: 		} while (!done && !(tout += timed_out(time, timeout)));
  154: 	    } /* for j */
  155: 	} /* if CPU class */
  156:     } /* for i */
  157: 
  158:     loprintf("\n");
[ 158] 0x900000001fc0e2ec:  0f f0 2c e3 jal		loprintf
[ 158] 0x900000001fc0e2f0:  65 64 00 62 daddiu	a0,a7,98
  159: 
  160:     if (tout)
[ 160] 0x900000001fc0e2f4:  df ac 00 48 ld	t0,72(sp)
[ 160] 0x900000001fc0e2f8:  3c 12 1f c2 lui	s2,0x1fc2
[ 160] 0x900000001fc0e2fc:  3c 0b 90 00 lui	a7,0x9000
[ 160] 0x900000001fc0e300:  12 20 00 03 beq	s1,zero,0x900000001fc0e310
[ 160] 0x900000001fc0e304:  61 70 00 00 daddi	s0,a7,0
  161: 	loprintf("*** Timed out waiting for slaves\n");
[ 161] 0x900000001fc0e308:  0f f0 2c e3 jal		loprintf
[ 161] 0x900000001fc0e30c:  65 84 00 68 daddiu	a0,t0,104
  162: 
  163:     for (i = 0; i < EV_MAX_SLOTS; i ++) {
[ 163] 0x900000001fc0e310:  00 10 68 3c dsll32	t1,s0,0
[ 163] 0x900000001fc0e314:  df af 00 48 ld	t3,72(sp)
[ 163] 0x900000001fc0e318:  62 4e cf 18 daddi	t2,s2,-12520
[ 163] 0x900000001fc0e31c:  65 f2 01 08 daddiu	s2,t3,264
[ 163] 0x900000001fc0e320:  65 f1 00 d0 daddiu	s1,t3,208
[ 163] 0x900000001fc0e324:  65 f0 f9 10 daddiu	s0,t3,-1776
[ 163] 0x900000001fc0e328:  01 ae 70 2c dadd	t2,t1,t2
[ 163] 0x900000001fc0e32c:  3c 0d 90 00 lui	t1,0x9000
[ 163] 0x900000001fc0e330:  61 ad 00 00 daddi	t1,t1,0
[ 163] 0x900000001fc0e334:  3c 0f 1f c2 lui	t3,0x1fc2
[ 163] 0x900000001fc0e338:  ff b2 00 70 sd	s2,112(sp)
[ 163] 0x900000001fc0e33c:  61 ef cf 18 daddi	t3,t3,-12520
[ 163] 0x900000001fc0e340:  00 0d 68 3c dsll32	t1,t1,0
[ 163] 0x900000001fc0e344:  ff b1 00 78 sd	s1,120(sp)
[ 163] 0x900000001fc0e348:  24 18 00 10 li	t8,16
[ 163] 0x900000001fc0e34c:  ff b0 00 80 sd	s0,128(sp)
[ 163] 0x900000001fc0e350:  dd ce 04 d0 ld	t2,1232(t2)
[ 163] 0x900000001fc0e354:  01 af 68 2c dadd	t1,t1,t3
[ 163] 0x900000001fc0e358:  ff ae 00 40 sd	t2,64(sp)
[ 163] 0x900000001fc0e35c:  df b2 00 40 ld	s2,64(sp)
[ 163] 0x900000001fc0e360:  ff ad 00 48 sd	t1,72(sp)
[ 163] 0x900000001fc0e364:  dd ad 04 d8 ld	t1,1240(t1)
[ 163] 0x900000001fc0e368:  24 1e 00 81 li	s8,129
[ 163] 0x900000001fc0e36c:  ff ad 00 88 sd	t1,136(sp)
  164: 	brdinfo = &(EVCFGINFO->ecfg_board[i]);
  165: 	if ((brdinfo->eb_type & EVCLASS_MASK) == EVCLASS_CPU) {
[ 165] 0x900000001fc0e370:  66 56 00 40 daddiu	s6,s2,64
[ 165] 0x900000001fc0e374:  66 54 00 0b daddiu	s4,s2,11
[ 165] 0x900000001fc0e378:  92 57 00 64 lbu	s7,100(s2)
[ 165] 0x900000001fc0e37c:  32 f7 00 f0 andi	s7,s7,0xf0
[ 165] 0x900000001fc0e380:  56 f8 00 45 bnel	s7,t8,0x900000001fc0e498
[ 165] 0x900000001fc0e384:  24 18 00 10 li	t8,16
  166: 	    for (j = 0; j < EV_CPU_PER_BOARD; j++) {
[ 166] 0x900000001fc0e388:  02 60 30 25 move	a2,s3
  167: 		stat = &(brdinfo->eb_cpuarr[j].cpu_diagval);
  168: 		switch (*stat) {
[ 168] 0x900000001fc0e38c:  92 8b 00 00 lbu	a7,0(s4)
[ 167] 0x900000001fc0e390:  02 80 b8 25 move	s7,s4
[ 167] 0x900000001fc0e394:  15 7e 00 0e bne	a7,s8,0x900000001fc0e3d0
[ 167] 0x900000001fc0e398:  29 71 00 f7 slti	s1,a7,247
  169: 		case EVDIAG_ERTOIP_COR:
  170: 		    loprintf("*** CPU %a/%a: recoverable errors, "
  171: 			     "reporting disabled\n", i, j);
  172: 		    xlate_ertoip(MPCONF[brdinfo->eb_cpuarr[j].cpu_vpid].ertoip);
  173: 		    *stat = EVDIAG_PASSED;
  174: 		    break;
  175: 		case EVDIAG_ERTOIP:
  176: 		    loprintf("*** CPU %a/%a: unrecoverable errors\n", i, j);
[ 176] 0x900000001fc0e39c:  02 a0 28 25 move	a1,s5
[ 176] 0x900000001fc0e3a0:  0f f0 2c e3 jal		loprintf
[ 176] 0x900000001fc0e3a4:  df a4 00 70 ld	a0,112(sp)
  177: 		    xlate_ertoip(MPCONF[brdinfo->eb_cpuarr[j].cpu_vpid].ertoip);
[ 177] 0x900000001fc0e3a8:  92 59 00 0c lbu	t9,12(s2)
[ 177] 0x900000001fc0e3ac:  df bf 00 48 ld	ra,72(sp)
[ 177] 0x900000001fc0e3b0:  33 39 00 ff andi	t9,t9,0xff
[ 177] 0x900000001fc0e3b4:  00 19 c9 b8 dsll	t9,t9,6
[ 177] 0x900000001fc0e3b8:  df ff 01 c8 ld	ra,456(ra)
[ 177] 0x900000001fc0e3bc:  03 3f c8 2d daddu	t9,t9,ra
[ 177] 0x900000001fc0e3c0:  0f f0 18 dd jal		xlate_ertoip
[ 177] 0x900000001fc0e3c4:  8f 24 00 00 lw	a0,0(t9)
  178: 		    break;
[ 178] 0x900000001fc0e3c8:  10 00 00 2f b		0x900000001fc0e488
[ 178] 0x900000001fc0e3cc:  26 73 00 01 addiu	s3,s3,1
[ 178] 0x900000001fc0e3d0:  02 60 30 25 move	a2,s3
[ 178] 0x900000001fc0e3d4:  24 01 00 82 li	at,130
[ 178] 0x900000001fc0e3d8:  df a8 00 80 ld	a4,128(sp)
[ 178] 0x900000001fc0e3dc:  15 61 00 0f bne	a7,at,0x900000001fc0e41c
[ 178] 0x900000001fc0e3e0:  29 70 00 f0 slti	s0,a7,240
[ 170] 0x900000001fc0e3e4:  02 a0 28 25 move	a1,s5
[ 170] 0x900000001fc0e3e8:  0f f0 2c e3 jal		loprintf
[ 170] 0x900000001fc0e3ec:  df a4 00 78 ld	a0,120(sp)
[ 172] 0x900000001fc0e3f0:  92 42 00 0c lbu	v0,12(s2)
[ 172] 0x900000001fc0e3f4:  df a3 00 48 ld	v1,72(sp)
[ 172] 0x900000001fc0e3f8:  30 42 00 ff andi	v0,v0,0xff
[ 172] 0x900000001fc0e3fc:  00 02 11 b8 dsll	v0,v0,6
[ 172] 0x900000001fc0e400:  dc 63 01 c8 ld	v1,456(v1)
[ 172] 0x900000001fc0e404:  00 43 10 2d daddu	v0,v0,v1
[ 172] 0x900000001fc0e408:  0f f0 18 dd jal		xlate_ertoip
[ 172] 0x900000001fc0e40c:  8c 44 00 00 lw	a0,0(v0)
[ 173] 0x900000001fc0e410:  a2 e0 00 00 sb	zero,0(s7)
[ 173] 0x900000001fc0e414:  10 00 00 1c b		0x900000001fc0e488
[ 173] 0x900000001fc0e418:  26 73 00 01 addiu	s3,s3,1
[ 173] 0x900000001fc0e41c:  56 00 00 1a bnel	s0,zero,0x900000001fc0e488
[ 173] 0x900000001fc0e420:  26 73 00 01 addiu	s3,s3,1
[ 173] 0x900000001fc0e424:  52 20 00 18 beql	s1,zero,0x900000001fc0e488
[ 173] 0x900000001fc0e428:  26 73 00 01 addiu	s3,s3,1
[ 173] 0x900000001fc0e42c:  24 09 00 2d li	a5,45
[ 173] 0x900000001fc0e430:  00 0b 38 f8 dsll	a3,a7,3
[ 173] 0x900000001fc0e434:  24 0a 00 07 li	a6,7
[ 173] 0x900000001fc0e438:  00 e8 38 2d daddu	a3,a3,a4
[ 173] 0x900000001fc0e43c:  24 0c 00 08 li	t0,8
[ 173] 0x900000001fc0e440:  24 0b 00 09 li	a7,9
[ 173] 0x900000001fc0e444:  dc e7 00 00 ld	a3,0(a3)
[ 173] 0x900000001fc0e448:  00 e0 00 08 jr	a3
[ 173] 0x900000001fc0e44c:  24 0d 00 0a li	t1,10
  179: 		case EVDIAG_TESTING_DCACHE:
  180: 		    *stat = EVDIAG_DCACHE_HANG;
  181: 		    break;
  182: 		case EVDIAG_TESTING_SCACHE:
  183: 		    *stat = EVDIAG_SCACHE_HANG;
  184: 		    break;
  185: 		case EVDIAG_TESTING_ICACHE:
  186: 		    *stat = EVDIAG_ICACHE_HANG;
  187: 		    break;
  188: 		case EVDIAG_INITING_CACHES:
  189: 		    *stat = EVDIAG_CACHE_INIT_HANG;
  190: 		    break;
  191: 		case EVDIAG_WRCPUINFO:
  192: 		    *stat = EVDIAG_WRCFG_HANG;
  193: 		    break;
[ 193] 0x900000001fc0e450:  a2 e9 00 00 sb	a5,0(s7)
[ 193] 0x900000001fc0e454:  10 00 00 0c b		0x900000001fc0e488
[ 193] 0x900000001fc0e458:  26 73 00 01 addiu	s3,s3,1
[ 181] 0x900000001fc0e45c:  a2 ea 00 00 sb	a6,0(s7)
[ 181] 0x900000001fc0e460:  10 00 00 09 b		0x900000001fc0e488
[ 181] 0x900000001fc0e464:  26 73 00 01 addiu	s3,s3,1
[ 187] 0x900000001fc0e468:  a2 eb 00 00 sb	a7,0(s7)
[ 187] 0x900000001fc0e46c:  10 00 00 06 b		0x900000001fc0e488
[ 187] 0x900000001fc0e470:  26 73 00 01 addiu	s3,s3,1
[ 184] 0x900000001fc0e474:  a2 ec 00 00 sb	t0,0(s7)
[ 184] 0x900000001fc0e478:  10 00 00 03 b		0x900000001fc0e488
[ 184] 0x900000001fc0e47c:  26 73 00 01 addiu	s3,s3,1
[ 189] 0x900000001fc0e480:  a2 ed 00 00 sb	t1,0(s7)
[ 166] 0x900000001fc0e484:  26 73 00 01 addiu	s3,s3,1
[ 166] 0x900000001fc0e488:  66 52 00 10 daddiu	s2,s2,16
[ 166] 0x900000001fc0e48c:  16 56 ff be bne	s2,s6,0x900000001fc0e388
[ 166] 0x900000001fc0e490:  66 94 00 10 daddiu	s4,s4,16
[ 166] 0x900000001fc0e494:  24 18 00 10 li	t8,16
[ 166] 0x900000001fc0e498:  00 00 98 25 move	s3,zero
[ 163] 0x900000001fc0e49c:  df ae 00 40 ld	t2,64(sp)
[ 163] 0x900000001fc0e4a0:  65 ce 00 6c daddiu	t2,t2,108
[ 163] 0x900000001fc0e4a4:  df af 00 88 ld	t3,136(sp)
[ 163] 0x900000001fc0e4a8:  26 b5 00 01 addiu	s5,s5,1
[ 163] 0x900000001fc0e4ac:  ff ae 00 40 sd	t2,64(sp)
[ 163] 0x900000001fc0e4b0:  15 cf ff af bne	t2,t3,0x900000001fc0e370
[ 163] 0x900000001fc0e4b4:  df b2 00 40 ld	s2,64(sp)
[ 163] 0x900000001fc0e4b8:  3c 10 1f c2 lui	s0,0x1fc2
[ 163] 0x900000001fc0e4bc:  3c 11 90 00 lui	s1,0x9000
  194: 		}
  195: 	    }
  196: 	} /* if EVCLASS_CPU */
  197:     } /* for i */
  198: 
  199:     for (i = 0; i < EV_MAX_SLOTS; i ++) {
[ 199] 0x900000001fc0e4c0:  62 32 00 00 daddi	s2,s1,0
[ 199] 0x900000001fc0e4c4:  62 14 cf 18 daddi	s4,s0,-12520
[ 199] 0x900000001fc0e4c8:  df b0 00 48 ld	s0,72(sp)
[ 199] 0x900000001fc0e4cc:  66 16 01 30 daddiu	s6,s0,304
[ 199] 0x900000001fc0e4d0:  66 1e 01 98 daddiu	s8,s0,408
[ 199] 0x900000001fc0e4d4:  66 11 01 58 daddiu	s1,s0,344
[ 199] 0x900000001fc0e4d8:  3c 10 90 00 lui	s0,0x9000
[ 199] 0x900000001fc0e4dc:  62 10 00 00 daddi	s0,s0,0
[ 199] 0x900000001fc0e4e0:  00 12 90 3c dsll32	s2,s2,0
[ 199] 0x900000001fc0e4e4:  3c 13 1f c2 lui	s3,0x1fc2
[ 199] 0x900000001fc0e4e8:  02 54 90 2c dadd	s2,s2,s4
[ 199] 0x900000001fc0e4ec:  62 73 cf 18 daddi	s3,s3,-12520
[ 199] 0x900000001fc0e4f0:  00 10 80 3c dsll32	s0,s0,0
[ 199] 0x900000001fc0e4f4:  de 52 04 d0 ld	s2,1232(s2)
[ 199] 0x900000001fc0e4f8:  02 13 80 2c dadd	s0,s0,s3
[ 199] 0x900000001fc0e4fc:  00 00 98 25 move	s3,zero
[ 199] 0x900000001fc0e500:  24 18 00 10 li	t8,16
[ 199] 0x900000001fc0e504:  ff b2 00 40 sd	s2,64(sp)
[ 199] 0x900000001fc0e508:  df b2 00 40 ld	s2,64(sp)
[ 199] 0x900000001fc0e50c:  ff b0 00 48 sd	s0,72(sp)
[ 199] 0x900000001fc0e510:  de 10 04 d8 ld	s0,1240(s0)
[ 199] 0x900000001fc0e514:  00 00 a8 25 move	s5,zero
[ 199] 0x900000001fc0e518:  ff b0 00 90 sd	s0,144(sp)
  200: 	brdinfo = &(EVCFGINFO->ecfg_board[i]);
  201: 	if ((brdinfo->eb_type & EVCLASS_MASK) == EVCLASS_CPU) {
[ 201] 0x900000001fc0e51c:  66 50 00 40 daddiu	s0,s2,64
[ 201] 0x900000001fc0e520:  66 54 00 0b daddiu	s4,s2,11
[ 201] 0x900000001fc0e524:  92 57 00 64 lbu	s7,100(s2)
[ 201] 0x900000001fc0e528:  32 f7 00 f0 andi	s7,s7,0xf0
[ 201] 0x900000001fc0e52c:  56 f8 00 37 bnel	s7,t8,0x900000001fc0e60c
[ 201] 0x900000001fc0e530:  24 18 00 10 li	t8,16
  202: 	    for (j = 0; j < EV_CPU_PER_BOARD; j++) {
[ 202] 0x900000001fc0e534:  02 80 b8 25 move	s7,s4
  203: 		stat = &(brdinfo->eb_cpuarr[j].cpu_diagval);
  204: 		if (brdinfo->eb_cpuarr[j].cpu_vpid != CPUST_NORESP) {
[ 204] 0x900000001fc0e538:  92 59 00 0c lbu	t9,12(s2)
[ 204] 0x900000001fc0e53c:  24 1f 00 ff li	ra,255
[ 203] 0x900000001fc0e540:  53 3f 00 2e beql	t9,ra,0x900000001fc0e5fc
[ 203] 0x900000001fc0e544:  26 73 00 01 addiu	s3,s3,1
[ 203] 0x900000001fc0e548:  02 60 30 25 move	a2,s3
[ 203] 0x900000001fc0e54c:  02 a0 28 25 move	a1,s5
  205: 		    /* Can't tell the difference between a rev. 0 prom and
  206: 		     * a CPU that can't see memory.
  207: 		     * Bummer.
  208: 		     */
  209: 		    if((brdinfo->eb_cpuarr[j].cpu_promrev < max_promrev)
[ 209] 0x900000001fc0e550:  92 41 00 0f lbu	at,15(s2)
[ 209] 0x900000001fc0e554:  df a2 00 30 ld	v0,48(sp)
[ 209] 0x900000001fc0e558:  00 22 08 2a slt	at,at,v0
[ 209] 0x900000001fc0e55c:  50 20 00 07 beql	at,zero,0x900000001fc0e57c
[ 209] 0x900000001fc0e560:  df a8 00 28 ld	a4,40(sp)
[ 209] 0x900000001fc0e564:  92 43 00 0f lbu	v1,15(s2)
[ 209] 0x900000001fc0e568:  50 60 00 04 beql	v1,zero,0x900000001fc0e57c
[ 209] 0x900000001fc0e56c:  df a8 00 28 ld	a4,40(sp)
  210: 					&& brdinfo->eb_cpuarr[j].cpu_promrev)
  211: 			loprintf("*** CPU %a/%a has a downrev PROM!\n", i, j);
[ 211] 0x900000001fc0e570:  0f f0 2c e3 jal		loprintf
[ 211] 0x900000001fc0e574:  02 c0 20 25 move	a0,s6
[ 211] 0x900000001fc0e578:  df a8 00 28 ld	a4,40(sp)
  212: 		    if ((i != slot) || (j != slice)) {
[ 212] 0x900000001fc0e57c:  df a7 00 20 ld	a3,32(sp)
[ 212] 0x900000001fc0e580:  56 a7 00 10 bnel	s5,a3,0x900000001fc0e5c4
[ 212] 0x900000001fc0e584:  92 ea 00 00 lbu	a6,0(s7)
[ 212] 0x900000001fc0e588:  56 68 00 0e bnel	s3,a4,0x900000001fc0e5c4
[ 212] 0x900000001fc0e58c:  92 ea 00 00 lbu	a6,0(s7)
  213: 			/* Not the CPU we're running on */
  214: 			if(*stat != EVDIAG_PASSED) {
  215: 			    loprintf("*** Disabling slave CPU %d/%d,"
  216: 				     " First diag Error(%d): %s\n", 
  217: 				     i, j, *stat, get_diag_string(*stat));
  218: 			    brdinfo->eb_cpuarr[j].cpu_enable = 0;
  219: 			    slave_errs++;
  220: 			}
  221: 		    } else {
  222: 			/* Master CPU */
  223: 			if(*stat != EVDIAG_PASSED) {
[ 223] 0x900000001fc0e590:  92 e9 00 00 lbu	a5,0(s7)
[ 223] 0x900000001fc0e594:  51 20 00 19 beql	a5,zero,0x900000001fc0e5fc
[ 223] 0x900000001fc0e598:  26 73 00 01 addiu	s3,s3,1
  224: 			    loprintf("*** Master CPU %a/%a    Error: %s\n", 
[ 224] 0x900000001fc0e59c:  0f f0 3f 6c jal		get_diag_string
[ 224] 0x900000001fc0e5a0:  92 e4 00 00 lbu	a0,0(s7)
[ 224] 0x900000001fc0e5a4:  00 40 38 25 move	a3,v0
[ 224] 0x900000001fc0e5a8:  02 60 30 25 move	a2,s3
[ 224] 0x900000001fc0e5ac:  02 a0 28 25 move	a1,s5
[ 224] 0x900000001fc0e5b0:  0f f0 2c e3 jal		loprintf
[ 224] 0x900000001fc0e5b4:  03 c0 20 25 move	a0,s8
[ 224] 0x900000001fc0e5b8:  10 00 00 10 b		0x900000001fc0e5fc
[ 224] 0x900000001fc0e5bc:  26 73 00 01 addiu	s3,s3,1
[ 214] 0x900000001fc0e5c0:  92 ea 00 00 lbu	a6,0(s7)
[ 214] 0x900000001fc0e5c4:  51 40 00 0d beql	a6,zero,0x900000001fc0e5fc
[ 214] 0x900000001fc0e5c8:  26 73 00 01 addiu	s3,s3,1
[ 215] 0x900000001fc0e5cc:  92 eb 00 00 lbu	a7,0(s7)
[ 215] 0x900000001fc0e5d0:  ff ab 00 98 sd	a7,152(sp)
[ 215] 0x900000001fc0e5d4:  0f f0 3f 6c jal		get_diag_string
[ 215] 0x900000001fc0e5d8:  92 e4 00 00 lbu	a0,0(s7)
[ 215] 0x900000001fc0e5dc:  00 40 40 25 move	a4,v0
[ 215] 0x900000001fc0e5e0:  02 60 30 25 move	a2,s3
[ 215] 0x900000001fc0e5e4:  df a7 00 98 ld	a3,152(sp)
[ 215] 0x900000001fc0e5e8:  02 a0 28 25 move	a1,s5
[ 215] 0x900000001fc0e5ec:  0f f0 2c e3 jal		loprintf
[ 215] 0x900000001fc0e5f0:  02 20 20 25 move	a0,s1
[ 218] 0x900000001fc0e5f4:  a2 40 00 09 sb	zero,9(s2)
[ 219] 0x900000001fc0e5f8:  26 73 00 01 addiu	s3,s3,1
[ 202] 0x900000001fc0e5fc:  66 52 00 10 daddiu	s2,s2,16
[ 202] 0x900000001fc0e600:  16 50 ff cc bne	s2,s0,0x900000001fc0e534
[ 202] 0x900000001fc0e604:  66 94 00 10 daddiu	s4,s4,16
[ 202] 0x900000001fc0e608:  24 18 00 10 li	t8,16
[ 202] 0x900000001fc0e60c:  00 00 98 25 move	s3,zero
[ 199] 0x900000001fc0e610:  df ac 00 40 ld	t0,64(sp)
[ 199] 0x900000001fc0e614:  65 8c 00 6c daddiu	t0,t0,108
[ 199] 0x900000001fc0e618:  df ad 00 90 ld	t1,144(sp)
[ 199] 0x900000001fc0e61c:  26 b5 00 01 addiu	s5,s5,1
[ 199] 0x900000001fc0e620:  ff ac 00 40 sd	t0,64(sp)
[ 199] 0x900000001fc0e624:  15 8d ff bd bne	t0,t1,0x900000001fc0e51c
[ 199] 0x900000001fc0e628:  df b2 00 40 ld	s2,64(sp)
[ 199] 0x900000001fc0e62c:  df b3 00 c8 ld	s3,200(sp)
[ 199] 0x900000001fc0e630:  df b1 00 d8 ld	s1,216(sp)
[ 199] 0x900000001fc0e634:  df b5 00 b8 ld	s5,184(sp)
[ 199] 0x900000001fc0e638:  df be 00 a0 ld	s8,160(sp)
[ 199] 0x900000001fc0e63c:  df bf 00 e8 ld	ra,232(sp)
[ 199] 0x900000001fc0e640:  df b6 00 b0 ld	s6,176(sp)
[ 199] 0x900000001fc0e644:  df b4 00 c0 ld	s4,192(sp)
[ 199] 0x900000001fc0e648:  df b2 00 d0 ld	s2,208(sp)
[ 199] 0x900000001fc0e64c:  df b0 00 e0 ld	s0,224(sp)
[ 199] 0x900000001fc0e650:  df b7 00 a8 ld	s7,168(sp)
[ 199] 0x900000001fc0e654:  03 e0 00 08 jr	ra
[ 199] 0x900000001fc0e658:  67 bd 00 f0 daddiu	sp,sp,240
  225: 				     i, j, get_diag_string(*stat));
  226: 			}
  227: 		    }
  228: 		}
  229: 	    }
  230: 	} /* if EVCLASS_CPU */
  231:     } /* for i */
  232: }
  233: 
  234: 
  235: void 
  236: query_evcfg(uint *enabled_mem, uint *disabled_mem, 
  237: 	    int *enabled_cpus, int *disabled_cpus) 
  238: {
query_evcfg:
[ 238] 0x900000001fc0e65c:  67 bd ff c0 daddiu	sp,sp,-64
  239:     evbrdinfo_t *brdinfo;
  240:     int i;
  241:     int j;
  242: 
  243:     *enabled_mem = *disabled_mem = *enabled_cpus = *disabled_cpus = 0;
  244: 
  245:     for (i = 0; i < EV_MAX_SLOTS; i++) {
[ 245] 0x900000001fc0e660:  3c 01 90 00 lui	at,0x9000
[ 245] 0x900000001fc0e664:  60 23 00 00 daddi	v1,at,0
[ 245] 0x900000001fc0e668:  3c 01 1f c2 lui	at,0x1fc2
[ 245] 0x900000001fc0e66c:  60 2b cf 18 daddi	a7,at,-12520
[ 245] 0x900000001fc0e670:  3c 01 90 00 lui	at,0x9000
[ 245] 0x900000001fc0e674:  60 22 00 00 daddi	v0,at,0
[ 245] 0x900000001fc0e678:  3c 01 1f c2 lui	at,0x1fc2
[ 245] 0x900000001fc0e67c:  ff b3 00 18 sd	s3,24(sp)
[ 245] 0x900000001fc0e680:  60 2a cf 18 daddi	a6,at,-12520
[ 245] 0x900000001fc0e684:  00 03 18 3c dsll32	v1,v1,0
[ 245] 0x900000001fc0e688:  ff b2 00 20 sd	s2,32(sp)
[ 245] 0x900000001fc0e68c:  3c 01 90 00 lui	at,0x9000
[ 245] 0x900000001fc0e690:  00 6b 18 2c dadd	v1,v1,a7
[ 245] 0x900000001fc0e694:  ff b1 00 28 sd	s1,40(sp)
[ 245] 0x900000001fc0e698:  60 21 00 00 daddi	at,at,0
[ 245] 0x900000001fc0e69c:  00 02 10 3c dsll32	v0,v0,0
[ 243] 0x900000001fc0e6a0:  ff b0 00 30 sd	s0,48(sp)
[ 243] 0x900000001fc0e6a4:  3c 09 1f c2 lui	a5,0x1fc2
[ 243] 0x900000001fc0e6a8:  ac e0 00 00 sw	zero,0(a3)
[ 243] 0x900000001fc0e6ac:  dc 63 01 d0 ld	v1,464(v1)
[ 243] 0x900000001fc0e6b0:  00 4a 10 2c dadd	v0,v0,a6
[ 243] 0x900000001fc0e6b4:  61 29 cf 18 daddi	a5,a5,-12520
[ 243] 0x900000001fc0e6b8:  00 01 08 3c dsll32	at,at,0
[ 243] 0x900000001fc0e6bc:  ac c0 00 00 sw	zero,0(a2)
[ 243] 0x900000001fc0e6c0:  ac a0 00 00 sw	zero,0(a1)
[ 243] 0x900000001fc0e6c4:  dc 42 04 d0 ld	v0,1232(v0)
[ 243] 0x900000001fc0e6c8:  00 29 08 2c dadd	at,at,a5
[ 243] 0x900000001fc0e6cc:  24 08 00 07 li	a4,7
[ 243] 0x900000001fc0e6d0:  24 12 00 10 li	s2,16
[ 243] 0x900000001fc0e6d4:  ac 80 00 00 sw	zero,0(a0)
[ 245] 0x900000001fc0e6d8:  24 13 00 30 li	s3,48
[ 245] 0x900000001fc0e6dc:  24 10 00 ff li	s0,255
[ 245] 0x900000001fc0e6e0:  ff a1 00 10 sd	at,16(sp)
[ 245] 0x900000001fc0e6e4:  dc 31 04 d8 ld	s1,1240(at)
[ 245] 0x900000001fc0e6e8:  90 4c 00 64 lbu	t0,100(v0)
  246: 	brdinfo = &(EVCFGINFO->ecfg_board[i]);
[ 246] 0x900000001fc0e6ec:  00 40 58 25 move	a7,v0
[ 246] 0x900000001fc0e6f0:  00 40 50 25 move	a6,v0
[ 246] 0x900000001fc0e6f4:  64 49 00 60 daddiu	a5,v0,96
[ 246] 0x900000001fc0e6f8:  31 99 00 f0 andi	t9,t0,0xf0
[ 246] 0x900000001fc0e6fc:  13 32 00 36 beq	t9,s2,0x900000001fc0e7d8
[ 246] 0x900000001fc0e700:  64 42 00 6c daddiu	v0,v0,108
  247: 	if ((brdinfo->eb_type & EVCLASS_MASK) == EVCLASS_CPU) {
  248: 	    for (j = 0; j < EV_CPU_PER_BOARD; j++) {
  249: 		DPRINTF(("CPU %a/%a: diagval %x, enable %x\n", i, j,
  250: 			brdinfo->eb_cpuarr[j].cpu_diagval,
  251: 			brdinfo->eb_cpuarr[j].cpu_enable));
  252: 		if (brdinfo->eb_cpuarr[j].cpu_diagval != CPUST_NORESP) {
  253: 		    if (brdinfo->eb_cpuarr[j].cpu_enable)
  254: 			(*enabled_cpus)++;
  255: 		    else
  256: 			(*disabled_cpus)++;
  257: 		}
  258: 	    } /* for j */
  259: 	} else if ((brdinfo->eb_type & EVCLASS_MASK) == EVCLASS_MEM) {
[ 259] 0x900000001fc0e704:  17 33 00 6c bne	t9,s3,0x900000001fc0e8b8
[ 259] 0x900000001fc0e708:  00 00 00 21 nada
  260: #ifdef SABLE
  261: 	    *(enabled_mem) = 8 << 12;	/* 8 mb */
  262: #else
  263: 	    for (j = 0; j < MC3_NUM_BANKS; j++) {
[ 263] 0x900000001fc0e70c:  91 59 00 0a lbu	t9,10(a6)
[ 263] 0x900000001fc0e710:  53 28 00 16 beql	t9,a4,0x900000001fc0e76c
[ 263] 0x900000001fc0e714:  91 59 00 16 lbu	t9,22(a6)
[ 263] 0x900000001fc0e718:  33 2d 00 ff andi	t1,t9,0xff
[ 263] 0x900000001fc0e71c:  00 0d 68 f8 dsll	t1,t1,3
[ 263] 0x900000001fc0e720:  01 a3 70 2d daddu	t2,t1,v1
[ 263] 0x900000001fc0e724:  91 4d 00 05 lbu	t1,5(a6)
[ 263] 0x900000001fc0e728:  15 a0 00 09 bne	t1,zero,0x900000001fc0e750
[ 263] 0x900000001fc0e72c:  dd cb 00 00 ld	a7,0(t2)
[ 263] 0x900000001fc0e730:  8c af 00 00 lw	t3,0(a1)
[ 263] 0x900000001fc0e734:  00 0f 78 3c dsll32	t3,t3,0
[ 263] 0x900000001fc0e738:  00 0f 78 3e dsrl32	t3,t3,0
[ 263] 0x900000001fc0e73c:  01 6f 78 2d daddu	t3,a7,t3
[ 263] 0x900000001fc0e740:  00 0f 78 00 sll	t3,t3,0
[ 263] 0x900000001fc0e744:  ac af 00 00 sw	t3,0(a1)
[ 263] 0x900000001fc0e748:  10 00 00 08 b		0x900000001fc0e76c
[ 263] 0x900000001fc0e74c:  91 59 00 16 lbu	t9,22(a6)
[ 263] 0x900000001fc0e750:  8c 98 00 00 lw	t8,0(a0)
[ 263] 0x900000001fc0e754:  00 18 c0 3c dsll32	t8,t8,0
[ 263] 0x900000001fc0e758:  00 18 c0 3e dsrl32	t8,t8,0
[ 263] 0x900000001fc0e75c:  01 78 c0 2d daddu	t8,a7,t8
[ 263] 0x900000001fc0e760:  00 18 c0 00 sll	t8,t8,0
[ 263] 0x900000001fc0e764:  ac 98 00 00 sw	t8,0(a0)
[ 263] 0x900000001fc0e768:  91 59 00 16 lbu	t9,22(a6)
[ 263] 0x900000001fc0e76c:  53 28 00 16 beql	t9,a4,0x900000001fc0e7c8
[ 263] 0x900000001fc0e770:  65 4a 00 18 daddiu	a6,a6,24
[ 263] 0x900000001fc0e774:  33 39 00 ff andi	t9,t9,0xff
[ 263] 0x900000001fc0e778:  00 19 c8 f8 dsll	t9,t9,3
[ 263] 0x900000001fc0e77c:  03 23 08 2d daddu	at,t9,v1
[ 263] 0x900000001fc0e780:  91 59 00 11 lbu	t9,17(a6)
[ 263] 0x900000001fc0e784:  17 20 00 09 bne	t9,zero,0x900000001fc0e7ac
[ 263] 0x900000001fc0e788:  dc 2b 00 00 ld	a7,0(at)
[ 263] 0x900000001fc0e78c:  8c a1 00 00 lw	at,0(a1)
[ 263] 0x900000001fc0e790:  00 01 08 3c dsll32	at,at,0
[ 263] 0x900000001fc0e794:  00 01 08 3e dsrl32	at,at,0
[ 263] 0x900000001fc0e798:  01 61 08 2d daddu	at,a7,at
[ 263] 0x900000001fc0e79c:  00 01 08 00 sll	at,at,0
[ 263] 0x900000001fc0e7a0:  ac a1 00 00 sw	at,0(a1)
[ 263] 0x900000001fc0e7a4:  10 00 00 08 b		0x900000001fc0e7c8
[ 263] 0x900000001fc0e7a8:  65 4a 00 18 daddiu	a6,a6,24
[ 263] 0x900000001fc0e7ac:  8c 81 00 00 lw	at,0(a0)
[ 263] 0x900000001fc0e7b0:  00 01 08 3c dsll32	at,at,0
[ 263] 0x900000001fc0e7b4:  00 01 08 3e dsrl32	at,at,0
[ 263] 0x900000001fc0e7b8:  01 61 08 2d daddu	at,a7,at
[ 263] 0x900000001fc0e7bc:  00 01 08 00 sll	at,at,0
[ 263] 0x900000001fc0e7c0:  ac 81 00 00 sw	at,0(a0)
[ 263] 0x900000001fc0e7c4:  65 4a 00 18 daddiu	a6,a6,24
[ 263] 0x900000001fc0e7c8:  15 49 ff d0 bne	a6,a5,0x900000001fc0e70c
[ 263] 0x900000001fc0e7cc:  00 00 00 21 nada
[ 263] 0x900000001fc0e7d0:  10 00 00 39 b		0x900000001fc0e8b8
[ 263] 0x900000001fc0e7d4:  00 00 00 21 nada
[ 248] 0x900000001fc0e7d8:  91 61 00 0b lbu	at,11(a7)
[ 248] 0x900000001fc0e7dc:  50 30 00 0d beql	at,s0,0x900000001fc0e814
[ 248] 0x900000001fc0e7e0:  91 61 00 1b lbu	at,27(a7)
[ 248] 0x900000001fc0e7e4:  91 61 00 09 lbu	at,9(a7)
[ 248] 0x900000001fc0e7e8:  54 20 00 07 bnel	at,zero,0x900000001fc0e808
[ 248] 0x900000001fc0e7ec:  8c c1 00 00 lw	at,0(a2)
[ 248] 0x900000001fc0e7f0:  8c e1 00 00 lw	at,0(a3)
[ 248] 0x900000001fc0e7f4:  24 21 00 01 addiu	at,at,1
[ 248] 0x900000001fc0e7f8:  ac e1 00 00 sw	at,0(a3)
[ 248] 0x900000001fc0e7fc:  10 00 00 05 b		0x900000001fc0e814
[ 248] 0x900000001fc0e800:  91 61 00 1b lbu	at,27(a7)
[ 248] 0x900000001fc0e804:  8c c1 00 00 lw	at,0(a2)
[ 248] 0x900000001fc0e808:  24 21 00 01 addiu	at,at,1
[ 248] 0x900000001fc0e80c:  ac c1 00 00 sw	at,0(a2)
[ 248] 0x900000001fc0e810:  91 61 00 1b lbu	at,27(a7)
[ 248] 0x900000001fc0e814:  50 30 00 0d beql	at,s0,0x900000001fc0e84c
[ 248] 0x900000001fc0e818:  91 61 00 2b lbu	at,43(a7)
[ 248] 0x900000001fc0e81c:  91 61 00 19 lbu	at,25(a7)
[ 248] 0x900000001fc0e820:  54 20 00 07 bnel	at,zero,0x900000001fc0e840
[ 248] 0x900000001fc0e824:  8c c1 00 00 lw	at,0(a2)
[ 248] 0x900000001fc0e828:  8c e1 00 00 lw	at,0(a3)
[ 248] 0x900000001fc0e82c:  24 21 00 01 addiu	at,at,1
[ 248] 0x900000001fc0e830:  ac e1 00 00 sw	at,0(a3)
[ 248] 0x900000001fc0e834:  10 00 00 05 b		0x900000001fc0e84c
[ 248] 0x900000001fc0e838:  91 61 00 2b lbu	at,43(a7)
[ 248] 0x900000001fc0e83c:  8c c1 00 00 lw	at,0(a2)
[ 248] 0x900000001fc0e840:  24 21 00 01 addiu	at,at,1
[ 248] 0x900000001fc0e844:  ac c1 00 00 sw	at,0(a2)
[ 248] 0x900000001fc0e848:  91 61 00 2b lbu	at,43(a7)
[ 248] 0x900000001fc0e84c:  50 30 00 0d beql	at,s0,0x900000001fc0e884
[ 248] 0x900000001fc0e850:  91 61 00 3b lbu	at,59(a7)
[ 248] 0x900000001fc0e854:  91 61 00 29 lbu	at,41(a7)
[ 248] 0x900000001fc0e858:  54 20 00 07 bnel	at,zero,0x900000001fc0e878
[ 248] 0x900000001fc0e85c:  8c c1 00 00 lw	at,0(a2)
[ 248] 0x900000001fc0e860:  8c e1 00 00 lw	at,0(a3)
[ 248] 0x900000001fc0e864:  24 21 00 01 addiu	at,at,1
[ 248] 0x900000001fc0e868:  ac e1 00 00 sw	at,0(a3)
[ 248] 0x900000001fc0e86c:  10 00 00 05 b		0x900000001fc0e884
[ 248] 0x900000001fc0e870:  91 61 00 3b lbu	at,59(a7)
[ 248] 0x900000001fc0e874:  8c c1 00 00 lw	at,0(a2)
[ 248] 0x900000001fc0e878:  24 21 00 01 addiu	at,at,1
[ 248] 0x900000001fc0e87c:  ac c1 00 00 sw	at,0(a2)
[ 248] 0x900000001fc0e880:  91 61 00 3b lbu	at,59(a7)
[ 248] 0x900000001fc0e884:  10 30 00 0c beq	at,s0,0x900000001fc0e8b8
[ 248] 0x900000001fc0e888:  00 00 00 21 nada
[ 248] 0x900000001fc0e88c:  91 61 00 39 lbu	at,57(a7)
[ 248] 0x900000001fc0e890:  54 20 00 07 bnel	at,zero,0x900000001fc0e8b0
[ 248] 0x900000001fc0e894:  8c c1 00 00 lw	at,0(a2)
[ 248] 0x900000001fc0e898:  8c e1 00 00 lw	at,0(a3)
[ 248] 0x900000001fc0e89c:  24 21 00 01 addiu	at,at,1
[ 248] 0x900000001fc0e8a0:  ac e1 00 00 sw	at,0(a3)
[ 248] 0x900000001fc0e8a4:  10 00 00 04 b		0x900000001fc0e8b8
[ 248] 0x900000001fc0e8a8:  00 00 00 21 nada
[ 248] 0x900000001fc0e8ac:  8c c1 00 00 lw	at,0(a2)
[ 248] 0x900000001fc0e8b0:  24 21 00 01 addiu	at,at,1
[ 248] 0x900000001fc0e8b4:  ac c1 00 00 sw	at,0(a2)
[ 245] 0x900000001fc0e8b8:  54 51 ff 8c bnel	v0,s1,0x900000001fc0e6ec
[ 245] 0x900000001fc0e8bc:  90 4c 00 64 lbu	t0,100(v0)
[ 245] 0x900000001fc0e8c0:  df b2 00 20 ld	s2,32(sp)
[ 245] 0x900000001fc0e8c4:  df b1 00 28 ld	s1,40(sp)
[ 245] 0x900000001fc0e8c8:  df b0 00 30 ld	s0,48(sp)
[ 245] 0x900000001fc0e8cc:  df b3 00 18 ld	s3,24(sp)
[ 245] 0x900000001fc0e8d0:  03 e0 00 08 jr	ra
[ 245] 0x900000001fc0e8d4:  67 bd 00 40 daddiu	sp,sp,64
  264: 		if (brdinfo->eb_banks[j].bnk_size != MC3_NOBANK)
  265: 		    if (brdinfo->eb_banks[j].bnk_enable)
  266: 			(*enabled_mem) += MemSizes[brdinfo->eb_banks[j].bnk_size];
  267: 		    else
  268: 			(*disabled_mem) += MemSizes[brdinfo->eb_banks[j].bnk_size];
  269: 	    } /* for j */
  270: #endif
  271: 	}
  272:     } /* for i */
  273: }
  274: 
  275: void hard_disable_cpus(int slot, int slice)
  276: {
hard_disable_cpus:
[ 276] 0x900000001fc0e8d8:  24 06 00 10 li	a2,16
[ 276] 0x900000001fc0e8dc:  67 bd ff 90 daddiu	sp,sp,-112
  277:     evbrdinfo_t *brdinfo;
  278:     int i, j;
  279:     int mask;
  280:     unsigned timeout, time;
  281: 
  282:     for (i = 0; i < EV_MAX_SLOTS; i++) {
[ 282] 0x900000001fc0e8e0:  ff b6 00 30 sd	s6,48(sp)
[ 282] 0x900000001fc0e8e4:  00 80 b0 25 move	s6,a0
[ 282] 0x900000001fc0e8e8:  3c 01 90 00 lui	at,0x9000
[ 282] 0x900000001fc0e8ec:  60 22 00 00 daddi	v0,at,0
[ 282] 0x900000001fc0e8f0:  3c 01 1f c2 lui	at,0x1fc2
[ 282] 0x900000001fc0e8f4:  ff b5 00 38 sd	s5,56(sp)
[ 282] 0x900000001fc0e8f8:  60 24 cf 18 daddi	a0,at,-12520
[ 282] 0x900000001fc0e8fc:  3c 01 90 00 lui	at,0x9000
[ 282] 0x900000001fc0e900:  ff b4 00 40 sd	s4,64(sp)
[ 282] 0x900000001fc0e904:  60 21 00 00 daddi	at,at,0
[ 282] 0x900000001fc0e908:  00 02 10 3c dsll32	v0,v0,0
[ 282] 0x900000001fc0e90c:  ff b3 00 48 sd	s3,72(sp)
[ 282] 0x900000001fc0e910:  3c 03 1f c2 lui	v1,0x1fc2
[ 282] 0x900000001fc0e914:  00 44 10 2c dadd	v0,v0,a0
[ 282] 0x900000001fc0e918:  ff b2 00 50 sd	s2,80(sp)
[ 282] 0x900000001fc0e91c:  60 63 cf 18 daddi	v1,v1,-12520
[ 282] 0x900000001fc0e920:  00 01 08 3c dsll32	at,at,0
[ 282] 0x900000001fc0e924:  ff b1 00 58 sd	s1,88(sp)
[ 282] 0x900000001fc0e928:  dc 42 04 d0 ld	v0,1232(v0)
[ 282] 0x900000001fc0e92c:  00 23 08 2c dadd	at,at,v1
[ 282] 0x900000001fc0e930:  ff b0 00 60 sd	s0,96(sp)
[ 282] 0x900000001fc0e934:  ff a2 00 00 sd	v0,0(sp)
[ 282] 0x900000001fc0e938:  ff be 00 20 sd	s8,32(sp)
[ 282] 0x900000001fc0e93c:  00 a0 f0 25 move	s8,a1
[ 282] 0x900000001fc0e940:  df a5 00 00 ld	a1,0(sp)
[ 282] 0x900000001fc0e944:  00 00 a0 25 move	s4,zero
[ 282] 0x900000001fc0e948:  ff a1 00 08 sd	at,8(sp)
[ 282] 0x900000001fc0e94c:  dc 21 04 d8 ld	at,1240(at)
[ 282] 0x900000001fc0e950:  ff b7 00 28 sd	s7,40(sp)
[ 282] 0x900000001fc0e954:  24 17 00 ff li	s7,255
[ 282] 0x900000001fc0e958:  24 15 00 01 li	s5,1
[ 282] 0x900000001fc0e95c:  ff a1 00 10 sd	at,16(sp)
[ 282] 0x900000001fc0e960:  ff bf 00 68 sd	ra,104(sp)
[ 282] 0x900000001fc0e964:  00 00 90 25 move	s2,zero
[ 282] 0x900000001fc0e968:  00 14 3a c0 sll	a3,s4,11
[ 282] 0x900000001fc0e96c:  df a8 00 08 ld	a4,8(sp)
  283: 	brdinfo = &(EVCFGINFO->ecfg_board[i]);
  284: 	if ((brdinfo->eb_type & EVCLASS_MASK) == EVCLASS_CPU) {
[ 284] 0x900000001fc0e970:  90 a5 00 64 lbu	a1,100(a1)
[ 284] 0x900000001fc0e974:  00 00 88 25 move	s1,zero
[ 284] 0x900000001fc0e978:  df b0 00 00 ld	s0,0(sp)
[ 284] 0x900000001fc0e97c:  30 a5 00 f0 andi	a1,a1,0xf0
[ 284] 0x900000001fc0e980:  54 a6 00 3d bnel	a1,a2,0x900000001fc0ea78
[ 284] 0x900000001fc0e984:  24 06 00 10 li	a2,16
  285: 	    mask = 0;
  286: 	    for (j = 0; j < EV_CPU_PER_BOARD; j++) {
[ 286] 0x900000001fc0e988:  dd 08 01 d8 ld	a4,472(a4)
[ 285] 0x900000001fc0e98c:  00 e8 38 2d daddu	a3,a3,a4
[ 286] 0x900000001fc0e990:  66 13 00 40 daddiu	s3,s0,64
[ 286] 0x900000001fc0e994:  ff a7 00 18 sd	a3,24(sp)
  287: 		if ((i == slot) && (j == slice)) {
[ 287] 0x900000001fc0e998:  56 96 00 04 bnel	s4,s6,0x900000001fc0e9ac
[ 287] 0x900000001fc0e99c:  02 35 60 04 sllv	t0,s5,s1
[ 287] 0x900000001fc0e9a0:  52 3e 00 17 beql	s1,s8,0x900000001fc0ea00
[ 287] 0x900000001fc0e9a4:  02 35 68 04 sllv	t1,s5,s1
[ 287] 0x900000001fc0e9a8:  02 35 60 04 sllv	t0,s5,s1
  288: 		    mask |= 1 << j;
  289: 		    continue;
  290: 		}
  291: 		if (brdinfo->eb_cpuarr[j].cpu_diagval != CPUST_NORESP) {
[ 291] 0x900000001fc0e9ac:  92 09 00 0b lbu	a5,11(s0)
[ 291] 0x900000001fc0e9b0:  51 37 00 05 beql	a5,s7,0x900000001fc0e9c8
[ 291] 0x900000001fc0e9b4:  24 06 00 03 li	a2,3
  292: 		    if (brdinfo->eb_cpuarr[j].cpu_enable) {
[ 292] 0x900000001fc0e9b8:  92 0a 00 09 lbu	a6,9(s0)
[ 292] 0x900000001fc0e9bc:  55 40 00 0c bnel	a6,zero,0x900000001fc0e9f0
[ 292] 0x900000001fc0e9c0:  66 10 00 10 daddiu	s0,s0,16
  293: 			mask |= 1 << j;
  294: 			continue;
  295: 		    }
  296: 		}
  297: 		/* If we get here, we're disabled */
  298: 
  299: 		/* Go flash our LEDs -
  300: 		 * 	Since the PROM's in "uncached" space, use the K1
  301: 		 *	macro.
  302: 		 */
  303: 		brdinfo->eb_cpuarr[j].cpu_launch =
  304: 					KPHYSTO32K1(IP25PROM_FLASHLEDS);
  305: 
  306: 		/* Actually launch the slave */
  307: 		send_int(i, j, LAUNCH_LEVEL);
[ 307] 0x900000001fc0e9c4:  24 06 00 03 li	a2,3
[ 307] 0x900000001fc0e9c8:  02 20 28 25 move	a1,s1
[ 307] 0x900000001fc0e9cc:  02 80 20 25 move	a0,s4
[ 303] 0x900000001fc0e9d0:  3c 0b bf c0 lui	a7,0xbfc0
[ 303] 0x900000001fc0e9d4:  35 6b 00 28 ori	a7,a7,0x28
[ 303] 0x900000001fc0e9d8:  0f f0 23 09 jal		send_int
[ 303] 0x900000001fc0e9dc:  ae 0b 00 00 sw	a7,0(s0)
[ 303] 0x900000001fc0e9e0:  66 10 00 10 daddiu	s0,s0,16
[ 303] 0x900000001fc0e9e4:  10 00 00 09 b		0x900000001fc0ea0c
[ 303] 0x900000001fc0e9e8:  26 31 00 01 addiu	s1,s1,1
[ 294] 0x900000001fc0e9ec:  66 10 00 10 daddiu	s0,s0,16
[ 294] 0x900000001fc0e9f0:  26 31 00 01 addiu	s1,s1,1
[ 294] 0x900000001fc0e9f4:  10 00 00 05 b		0x900000001fc0ea0c
[ 294] 0x900000001fc0e9f8:  02 4c 90 25 or	s2,s2,t0
[ 288] 0x900000001fc0e9fc:  02 35 68 04 sllv	t1,s5,s1
[ 289] 0x900000001fc0ea00:  66 10 00 10 daddiu	s0,s0,16
[ 289] 0x900000001fc0ea04:  26 31 00 01 addiu	s1,s1,1
[ 289] 0x900000001fc0ea08:  02 4d 90 25 or	s2,s2,t1
[ 286] 0x900000001fc0ea0c:  16 13 ff e2 bne	s0,s3,0x900000001fc0e998
[ 286] 0x900000001fc0ea10:  00 00 00 21 nada
[ 286] 0x900000001fc0ea14:  df ae 00 18 ld	t2,24(sp)
  308: 
  309: 	    } /* for j */
  310: 
  311: 	    /* Give CPUs a chance to jump. */
  312: 	    if (mask != EV_GET_CONFIG(i, EV_A_ENABLE)) {
[ 312] 0x900000001fc0ea18:  dd ce 00 00 ld	t2,0(t2)
[ 312] 0x900000001fc0ea1c:  df af 00 08 ld	t3,8(sp)
[ 312] 0x900000001fc0ea20:  02 40 98 25 move	s3,s2
[ 312] 0x900000001fc0ea24:  51 d2 00 14 beql	t2,s2,0x900000001fc0ea78
[ 312] 0x900000001fc0ea28:  24 06 00 10 li	a2,16
  313: 	        time = LD_RTC();
[ 313] 0x900000001fc0ea2c:  dd ef 01 c0 ld	t3,448(t3)
[ 313] 0x900000001fc0ea30:  dd ef 00 00 ld	t3,0(t3)
[ 313] 0x900000001fc0ea34:  00 0f 7a 3b dsra	t3,t3,8
  314: 	        timeout = time + DISABLE_TOUT;
[ 314] 0x900000001fc0ea38:  00 0f 80 00 sll	s0,t3,0
[ 314] 0x900000001fc0ea3c:  3c 0f 00 08 lui	t3,0x8
[ 314] 0x900000001fc0ea40:  02 0f 88 21 addu	s1,s0,t3
  315: 		while (!timed_out(time, timeout));
[ 315] 0x900000001fc0ea44:  02 00 20 25 move	a0,s0
[ 315] 0x900000001fc0ea48:  0f f0 40 b6 jal		timed_out
[ 315] 0x900000001fc0ea4c:  02 20 28 25 move	a1,s1
[ 315] 0x900000001fc0ea50:  54 40 00 07 bnel	v0,zero,0x900000001fc0ea70
[ 315] 0x900000001fc0ea54:  df b0 00 18 ld	s0,24(sp)
[ 315] 0x900000001fc0ea58:  02 20 28 25 move	a1,s1
[ 315] 0x900000001fc0ea5c:  0f f0 40 b6 jal		timed_out
[ 315] 0x900000001fc0ea60:  02 00 20 25 move	a0,s0
[ 315] 0x900000001fc0ea64:  50 40 ff fd beql	v0,zero,0x900000001fc0ea5c
[ 315] 0x900000001fc0ea68:  02 20 28 25 move	a1,s1
  316: 		    /* Actually disable CPUs */
  317: 		    EV_SET_CONFIG(i, EV_A_ENABLE, mask);
[ 317] 0x900000001fc0ea6c:  df b0 00 18 ld	s0,24(sp)
[ 317] 0x900000001fc0ea70:  fe 13 00 00 sd	s3,0(s0)
[ 317] 0x900000001fc0ea74:  24 06 00 10 li	a2,16
[ 282] 0x900000001fc0ea78:  df b1 00 00 ld	s1,0(sp)
[ 282] 0x900000001fc0ea7c:  66 31 00 6c daddiu	s1,s1,108
[ 282] 0x900000001fc0ea80:  df b2 00 10 ld	s2,16(sp)
[ 282] 0x900000001fc0ea84:  26 94 00 01 addiu	s4,s4,1
[ 282] 0x900000001fc0ea88:  ff b1 00 00 sd	s1,0(sp)
[ 282] 0x900000001fc0ea8c:  df a5 00 00 ld	a1,0(sp)
[ 282] 0x900000001fc0ea90:  56 32 ff b5 bnel	s1,s2,0x900000001fc0e968
[ 282] 0x900000001fc0ea94:  00 00 90 25 move	s2,zero
[ 282] 0x900000001fc0ea98:  df b3 00 48 ld	s3,72(sp)
[ 282] 0x900000001fc0ea9c:  df b1 00 58 ld	s1,88(sp)
[ 282] 0x900000001fc0eaa0:  df b5 00 38 ld	s5,56(sp)
[ 282] 0x900000001fc0eaa4:  df be 00 20 ld	s8,32(sp)
[ 282] 0x900000001fc0eaa8:  df bf 00 68 ld	ra,104(sp)
[ 282] 0x900000001fc0eaac:  df b6 00 30 ld	s6,48(sp)
[ 282] 0x900000001fc0eab0:  df b4 00 40 ld	s4,64(sp)
[ 282] 0x900000001fc0eab4:  df b2 00 50 ld	s2,80(sp)
[ 282] 0x900000001fc0eab8:  df b0 00 60 ld	s0,96(sp)
[ 282] 0x900000001fc0eabc:  df b7 00 28 ld	s7,40(sp)
[ 282] 0x900000001fc0eac0:  03 e0 00 08 jr	ra
[ 282] 0x900000001fc0eac4:  67 bd 00 70 daddiu	sp,sp,112
  318: 	    }
  319: 	}
  320:     } /* for i */
  321: }
  322: 
  323: 
  324: char plural(int number)
  325: {
  326:     if (number != 1)
plural:
[ 326] 0x900000001fc0eac8:  24 01 00 01 li	at,1
[ 326] 0x900000001fc0eacc:  14 81 00 03 bne	a0,at,0x900000001fc0eadc
[ 326] 0x900000001fc0ead0:  24 02 00 73 li	v0,115
  327: 	return 's';
  328:     else
  329: 	return ' ';
[ 329] 0x900000001fc0ead4:  10 00 00 01 b		0x900000001fc0eadc
[ 329] 0x900000001fc0ead8:  24 02 00 20 li	v0,32
[ 327] 0x900000001fc0eadc:  03 e0 00 08 jr	ra
[ 327] 0x900000001fc0eae0:  00 00 00 21 nada
  330: }
  331: 
  332: 
  333: void test_master(int io4_err)
  334: {
test_master:
[ 334] 0x900000001fc0eae4:  67 bd ff b0 daddiu	sp,sp,-80
  335:     int 	failure_code = 0;
  336:     int 	slot, slice;		/* Our position on the midplane */
  337:     uint 	enabled_mem, disabled_mem;
  338:     int 	enabled_cpus, disabled_cpus;
  339:     evreg_t	ertoip;
  340: 
  341:     slot  = (int)((LD(EV_SPNUM) & EV_SLOTNUM_MASK) >> EV_SLOTNUM_SHFT);
[ 341] 0x900000001fc0eae8:  3c 01 90 00 lui	at,0x9000
[ 341] 0x900000001fc0eaec:  60 21 00 00 daddi	at,at,0
[ 341] 0x900000001fc0eaf0:  3c 02 1f c2 lui	v0,0x1fc2
[ 341] 0x900000001fc0eaf4:  60 42 cf 18 daddi	v0,v0,-12520
[ 341] 0x900000001fc0eaf8:  00 01 08 3c dsll32	at,at,0
[ 341] 0x900000001fc0eafc:  ff b0 00 38 sd	s0,56(sp)
[ 341] 0x900000001fc0eb00:  00 22 80 2c dadd	s0,at,v0
[ 341] 0x900000001fc0eb04:  de 01 04 a8 ld	at,1192(s0)
[ 341] 0x900000001fc0eb08:  ff b4 00 18 sd	s4,24(sp)
[ 341] 0x900000001fc0eb0c:  dc 22 00 00 ld	v0,0(at)
[ 341] 0x900000001fc0eb10:  ff b3 00 20 sd	s3,32(sp)
[ 341] 0x900000001fc0eb14:  30 42 00 3c andi	v0,v0,0x3c
  342:     slice = (int)((LD(EV_SPNUM) & EV_PROCNUM_MASK) >> EV_PROCNUM_SHFT);
[ 342] 0x900000001fc0eb18:  ff b2 00 28 sd	s2,40(sp)
[ 342] 0x900000001fc0eb1c:  00 02 18 bb dsra	v1,v0,2
[ 342] 0x900000001fc0eb20:  dc 22 00 00 ld	v0,0(at)
[ 342] 0x900000001fc0eb24:  de 01 04 b0 ld	at,1200(s0)
[ 342] 0x900000001fc0eb28:  30 42 00 03 andi	v0,v0,0x3
[ 342] 0x900000001fc0eb2c:  00 03 98 00 sll	s3,v1,0
[ 342] 0x900000001fc0eb30:  ff b1 00 30 sd	s1,48(sp)
[ 342] 0x900000001fc0eb34:  00 80 90 25 move	s2,a0
[ 342] 0x900000001fc0eb38:  00 02 a0 00 sll	s4,v0,0
[ 342] 0x900000001fc0eb3c:  dc 21 00 00 ld	at,0(at)
  343: 
  344:     /*
  345:      * Check if there are any recoverable errors set in the 
  346:      * ertoip register at this point, if so, print out the
  347:      * error as a warning and continue.
  348:      */
  349: 
  350:     ertoip = LD(EV_ERTOIP);
  351:     if (0 != ertoip) {
[ 351] 0x900000001fc0eb40:  de 11 04 b8 ld	s1,1208(s0)
[ 351] 0x900000001fc0eb44:  ff bf 00 40 sd	ra,64(sp)
[ 351] 0x900000001fc0eb48:  10 20 00 11 beq	at,zero,0x900000001fc0eb90
[ 351] 0x900000001fc0eb4c:  00 20 c8 25 move	t9,at
  352: 	xlate_ertoip(ertoip);
[ 352] 0x900000001fc0eb50:  0f f0 18 dd jal		xlate_ertoip
[ 352] 0x900000001fc0eb54:  03 20 20 25 move	a0,t9
  353: 	SD(EV_ERTOIP, 0xffffffff);
[ 353] 0x900000001fc0eb58:  34 04 ff ff ori	a0,zero,0xffff
[ 353] 0x900000001fc0eb5c:  00 04 2c 38 dsll	a1,a0,16
[ 353] 0x900000001fc0eb60:  de 04 04 b0 ld	a0,1200(s0)
[ 353] 0x900000001fc0eb64:  34 a5 ff ff ori	a1,a1,0xffff
[ 353] 0x900000001fc0eb68:  fc 85 00 00 sd	a1,0(a0)
  354: 	ertoip = LD(EV_ERTOIP);
[ 354] 0x900000001fc0eb6c:  dc 84 00 00 ld	a0,0(a0)
  355: 	if (ertoip) {
[ 355] 0x900000001fc0eb70:  14 80 00 05 bne	a0,zero,0x900000001fc0eb88
[ 355] 0x900000001fc0eb74:  00 00 00 21 nada
  356: 	    loprintf(" *** Warning: unexpected errors - unable to clear\n");
  357: 	} else {
  358: 	    loprintf(" *** Warning: unexpected errors"
[ 358] 0x900000001fc0eb78:  0f f0 2c e3 jal		loprintf
[ 358] 0x900000001fc0eb7c:  66 04 02 18 daddiu	a0,s0,536
[ 358] 0x900000001fc0eb80:  10 00 00 04 b		0x900000001fc0eb94
[ 358] 0x900000001fc0eb84:  8e 26 06 d8 lw	a2,1752(s1)
[ 356] 0x900000001fc0eb88:  0f f0 2c e3 jal		loprintf
[ 356] 0x900000001fc0eb8c:  66 04 01 e0 daddiu	a0,s0,480
  359: 		     " - cleared and continuing\n");
  360: 	}
  361:     }
  362: 
  363:     /* Check on the slaves. */
  364: 
  365:     if (!(EVCFGINFO->ecfg_debugsw & VDS_NO_DIAGS))
[ 365] 0x900000001fc0eb90:  8e 26 06 d8 lw	a2,1752(s1)
[ 365] 0x900000001fc0eb94:  30 c6 00 10 andi	a2,a2,0x10
[ 365] 0x900000001fc0eb98:  10 c0 00 05 beq	a2,zero,0x900000001fc0ebb0
[ 365] 0x900000001fc0eb9c:  00 00 00 21 nada
  366: 	loprintf("Checking slave processor diag results..");
  367:     else
  368: 	loprintf("Checking slave processor status..");
[ 368] 0x900000001fc0eba0:  0f f0 2c e3 jal		loprintf
[ 368] 0x900000001fc0eba4:  66 04 02 80 daddiu	a0,s0,640
[ 368] 0x900000001fc0eba8:  10 00 00 03 b		0x900000001fc0ebb8
[ 368] 0x900000001fc0ebac:  00 00 00 21 nada
[ 366] 0x900000001fc0ebb0:  0f f0 2c e3 jal		loprintf
[ 366] 0x900000001fc0ebb4:  66 04 02 58 daddiu	a0,s0,600
  369: 
  370:     sysctlr_message("Checking slaves...");
[ 370] 0x900000001fc0ebb8:  0f f0 11 7c jal		sysctlr_message
[ 370] 0x900000001fc0ebbc:  66 04 02 a8 daddiu	a0,s0,680
  371:     check_slaves(slot, slice);
[ 371] 0x900000001fc0ebc0:  02 80 28 25 move	a1,s4
[ 371] 0x900000001fc0ebc4:  0f f0 38 23 jal		check_slaves
[ 371] 0x900000001fc0ebc8:  02 60 20 25 move	a0,s3
  372:     update_boot_stat(io4_err, slot, slice);
[ 372] 0x900000001fc0ebcc:  02 80 30 25 move	a2,s4
[ 372] 0x900000001fc0ebd0:  02 60 28 25 move	a1,s3
[ 372] 0x900000001fc0ebd4:  0f f0 36 eb jal		update_boot_stat
[ 372] 0x900000001fc0ebd8:  02 40 20 25 move	a0,s2
  373: 
  374:     query_evcfg(&enabled_mem, &disabled_mem, &enabled_cpus, &disabled_cpus);
[ 374] 0x900000001fc0ebdc:  67 a7 00 0c daddiu	a3,sp,12
[ 374] 0x900000001fc0ebe0:  67 a6 00 08 daddiu	a2,sp,8
[ 374] 0x900000001fc0ebe4:  67 a5 00 04 daddiu	a1,sp,4
[ 374] 0x900000001fc0ebe8:  0f f0 39 97 jal		query_evcfg
[ 374] 0x900000001fc0ebec:  67 a4 00 00 daddiu	a0,sp,0
  375:     loprintf("    Enabled %d Megabytes of main memory\n",
[ 375] 0x900000001fc0ebf0:  66 04 02 c0 daddiu	a0,s0,704
[ 375] 0x900000001fc0ebf4:  8f a7 00 00 lw	a3,0(sp)
[ 375] 0x900000001fc0ebf8:  0f f0 2c e3 jal		loprintf
[ 375] 0x900000001fc0ebfc:  00 07 2b 02 srl	a1,a3,12
  376:                 enabled_mem >> 12);
  377:     if (disabled_mem)
[ 377] 0x900000001fc0ec00:  8f a8 00 04 lw	a4,4(sp)
[ 377] 0x900000001fc0ec04:  8f a7 00 04 lw	a3,4(sp)
[ 377] 0x900000001fc0ec08:  10 e0 00 03 beq	a3,zero,0x900000001fc0ec18
[ 377] 0x900000001fc0ec0c:  66 04 02 f0 daddiu	a0,s0,752
  378: 	    loprintf("    (Disabled %d Megabytes of main memory)\n",
[ 378] 0x900000001fc0ec10:  0f f0 2c e3 jal		loprintf
[ 378] 0x900000001fc0ec14:  00 08 2b 02 srl	a1,a4,12
  379:                 disabled_mem >> 12);
  380:     loprintf("    Enabled %d processor%c\n", enabled_cpus,
[ 380] 0x900000001fc0ec18:  0f f0 3a b2 jal		plural
[ 380] 0x900000001fc0ec1c:  8f a4 00 08 lw	a0,8(sp)
[ 380] 0x900000001fc0ec20:  8f a5 00 08 lw	a1,8(sp)
[ 380] 0x900000001fc0ec24:  30 46 00 ff andi	a2,v0,0xff
[ 380] 0x900000001fc0ec28:  0f f0 2c e3 jal		loprintf
[ 380] 0x900000001fc0ec2c:  66 04 03 20 daddiu	a0,s0,800
[ 380] 0x900000001fc0ec30:  8f b9 00 0c lw	t9,12(sp)
  381: 						plural(enabled_cpus));
  382:     if (disabled_cpus)
[ 382] 0x900000001fc0ec34:  53 20 00 08 beql	t9,zero,0x900000001fc0ec58
[ 382] 0x900000001fc0ec38:  8f a9 00 00 lw	a5,0(sp)
  383: 	    loprintf("    (Disabled %d processor%c)\n", disabled_cpus,
[ 383] 0x900000001fc0ec3c:  0f f0 3a b2 jal		plural
[ 383] 0x900000001fc0ec40:  03 20 20 25 move	a0,t9
[ 383] 0x900000001fc0ec44:  30 46 00 ff andi	a2,v0,0xff
[ 383] 0x900000001fc0ec48:  8f a5 00 0c lw	a1,12(sp)
[ 383] 0x900000001fc0ec4c:  0f f0 2c e3 jal		loprintf
[ 383] 0x900000001fc0ec50:  66 04 03 40 daddiu	a0,s0,832
[ 383] 0x900000001fc0ec54:  8f a9 00 00 lw	a5,0(sp)
  384: 						plural(disabled_cpus));
  385: 
  386: #if SABLE
  387:     io4_err = 0;				/* error? what error? */
  388:     EVCFGINFO->ecfg_debugsw |= VDS_PODMODE;	/* drop into pod mode */
  389:     EVCFGINFO->ecfg_memsize = enabled_mem;	/* kludge memory size */
  390: #endif
  391: 
  392:     if (enabled_mem != (EVCFGINFO->ecfg_memsize)) {
[ 392] 0x900000001fc0ec58:  8e 2a 06 d0 lw	a6,1744(s1)
[ 392] 0x900000001fc0ec5c:  11 2a 00 05 beq	a5,a6,0x900000001fc0ec74
[ 392] 0x900000001fc0ec60:  00 00 00 21 nada
  393: 	loprintf("*** Memory size in evconfig structure was corrupted.  Updating.\n");
[ 393] 0x900000001fc0ec64:  0f f0 2c e3 jal		loprintf
[ 393] 0x900000001fc0ec68:  66 04 03 60 daddiu	a0,s0,864
[ 393] 0x900000001fc0ec6c:  8f ab 00 00 lw	a7,0(sp)
  394: 	EVCFGINFO->ecfg_memsize = enabled_mem;
[ 394] 0x900000001fc0ec70:  ae 2b 06 d0 sw	a7,1744(s1)
  395:     }
  396: 
  397:     if (io4_err) {
[ 397] 0x900000001fc0ec74:  12 40 00 08 beq	s2,zero,0x900000001fc0ec98
[ 397] 0x900000001fc0ec78:  ff b5 00 10 sd	s5,16(sp)
  398: 	sc_disp(io4_err);
[ 398] 0x900000001fc0ec7c:  32 55 00 ff andi	s5,s2,0xff
[ 398] 0x900000001fc0ec80:  0f f0 3f 12 jal		sc_disp
[ 398] 0x900000001fc0ec84:  02 a0 20 25 move	a0,s5
  399: 	podMode(io4_err, "\r\nIO4 board failed.\r\n");
[ 399] 0x900000001fc0ec88:  66 05 03 a8 daddiu	a1,s0,936
[ 399] 0x900000001fc0ec8c:  0f f0 15 fd jal		podMode
[ 399] 0x900000001fc0ec90:  02 a0 20 25 move	a0,s5
[ 399] 0x900000001fc0ec94:  df b5 00 10 ld	s5,16(sp)
  400:     }
  401: 
  402: 
  403:     /* Clean stuff up. */
  404:     pod_clear_ints();
[ 404] 0x900000001fc0ec98:  0f f0 14 d8 jal		pod_clear_ints
[ 404] 0x900000001fc0ec9c:  00 00 00 21 nada
  405:     SD_LO(EV_CIPL124, 0x6);
[ 405] 0x900000001fc0eca0:  de 1f 04 c0 ld	ra,1216(s0)
[ 405] 0x900000001fc0eca4:  24 19 00 06 li	t9,6
  406:     SD_LO(EV_CERTOIP, 0xffffffff);
[ 406] 0x900000001fc0eca8:  34 18 ff ff ori	t8,zero,0xffff
[ 406] 0x900000001fc0ecac:  ff f9 00 00 sd	t9,0(ra)
[ 406] 0x900000001fc0ecb0:  00 18 c4 38 dsll	t8,t8,16
[ 406] 0x900000001fc0ecb4:  de 19 04 c8 ld	t9,1224(s0)
[ 406] 0x900000001fc0ecb8:  37 18 ff ff ori	t8,t8,0xffff
[ 406] 0x900000001fc0ecbc:  ff 38 00 00 sd	t8,0(t9)
  407: 
  408:     if (EVCFGINFO->ecfg_debugsw & VDS_PODMODE) {
[ 408] 0x900000001fc0ecc0:  8e 38 06 d8 lw	t8,1752(s1)
[ 408] 0x900000001fc0ecc4:  33 18 00 20 andi	t8,t8,0x20
[ 408] 0x900000001fc0ecc8:  53 00 00 07 beql	t8,zero,0x900000001fc0ece8
[ 408] 0x900000001fc0eccc:  02 80 28 25 move	a1,s4
  409: 	sysctlr_message("Entering POD mode.");
[ 409] 0x900000001fc0ecd0:  0f f0 11 7c jal		sysctlr_message
[ 409] 0x900000001fc0ecd4:  66 04 03 c0 daddiu	a0,s0,960
  410: 	podMode(EVDIAG_DEBUG, "\r\nEntering POD mode.\r\n");
[ 410] 0x900000001fc0ecd8:  66 05 03 d8 daddiu	a1,s0,984
[ 410] 0x900000001fc0ecdc:  0f f0 15 fd jal		podMode
[ 410] 0x900000001fc0ece0:  24 04 00 fd li	a0,253
[ 410] 0x900000001fc0ece4:  02 80 28 25 move	a1,s4
  411:     }
  412: 
  413:     /* If NO_DIAGS isn't set and PODMODE isn't set, hard disable CPUs */
  414:     if (!(EVCFGINFO->ecfg_debugsw & VDS_NO_DIAGS)) {
[ 414] 0x900000001fc0ece8:  8e 26 06 d8 lw	a2,1752(s1)
[ 414] 0x900000001fc0ecec:  30 c6 00 10 andi	a2,a2,0x10
[ 414] 0x900000001fc0ecf0:  10 c0 00 07 beq	a2,zero,0x900000001fc0ed10
[ 414] 0x900000001fc0ecf4:  8f b9 00 0c lw	t9,12(sp)
  415: 	hard_disable_cpus(slot, slice);
  416:     } else if (disabled_cpus) {
[ 416] 0x900000001fc0ecf8:  53 20 00 08 beql	t9,zero,0x900000001fc0ed1c
[ 416] 0x900000001fc0ecfc:  8e 27 06 d0 lw	a3,1744(s1)
  417: 	loprintf("NOTE: Soft-disabling CPUs.\n");
[ 417] 0x900000001fc0ed00:  0f f0 2c e3 jal		loprintf
[ 417] 0x900000001fc0ed04:  66 04 03 f0 daddiu	a0,s0,1008
[ 417] 0x900000001fc0ed08:  10 00 00 04 b		0x900000001fc0ed1c
[ 417] 0x900000001fc0ed0c:  8e 27 06 d0 lw	a3,1744(s1)
[ 415] 0x900000001fc0ed10:  0f f0 3a 36 jal		hard_disable_cpus
[ 415] 0x900000001fc0ed14:  02 60 20 25 move	a0,s3
[ 415] 0x900000001fc0ed18:  8e 27 06 d0 lw	a3,1744(s1)
  418:     }
  419: 
  420:     if ((EVCFGINFO->ecfg_memsize >> 12) < 32) {
[ 420] 0x900000001fc0ed1c:  00 07 3b 02 srl	a3,a3,12
[ 420] 0x900000001fc0ed20:  2c e7 00 20 sltiu	a3,a3,32
[ 420] 0x900000001fc0ed24:  50 e0 00 09 beql	a3,zero,0x900000001fc0ed4c
[ 420] 0x900000001fc0ed28:  df b3 00 20 ld	s3,32(sp)
  421: 	loprintf("*** Can't load IO prom with < 32 Megabytes of working memory.\n");
[ 421] 0x900000001fc0ed2c:  0f f0 2c e3 jal		loprintf
[ 421] 0x900000001fc0ed30:  66 04 04 10 daddiu	a0,s0,1040
  422: 	sc_disp(EVDIAG_MC3NOTENOUGH);
[ 422] 0x900000001fc0ed34:  0f f0 3f 12 jal		sc_disp
[ 422] 0x900000001fc0ed38:  24 04 00 32 li	a0,50
  423: 	podMode(EVDIAG_MC3NOTENOUGH, "Insufficient memory.\r\n");
[ 423] 0x900000001fc0ed3c:  66 05 04 50 daddiu	a1,s0,1104
[ 423] 0x900000001fc0ed40:  0f f0 15 fd jal		podMode
[ 423] 0x900000001fc0ed44:  24 04 00 32 li	a0,50
[ 423] 0x900000001fc0ed48:  df b3 00 20 ld	s3,32(sp)
  424:     }
  425: 
  426:     /*
  427:      * Download the IO4 PROM
  428:      */
  429: 
  430:     if (!io4_err) {
[ 430] 0x900000001fc0ed4c:  52 40 00 0d beql	s2,zero,0x900000001fc0ed84
[ 430] 0x900000001fc0ed50:  df b1 00 30 ld	s1,48(sp)
  431:         failure_code = load_io4prom();
  432: 	sc_disp(failure_code);
  433: 	podMode(failure_code, "IO4 prom failed.\r\n");
  434:     } else {
  435: 	sc_disp(io4_err);
[ 435] 0x900000001fc0ed54:  32 51 00 ff andi	s1,s2,0xff
[ 435] 0x900000001fc0ed58:  df b4 00 18 ld	s4,24(sp)
[ 435] 0x900000001fc0ed5c:  0f f0 3f 12 jal		sc_disp
[ 435] 0x900000001fc0ed60:  02 20 20 25 move	a0,s1
  436: 	podMode(io4_err, "Cannot run without working IO4\r\n");
[ 436] 0x900000001fc0ed64:  66 05 04 80 daddiu	a1,s0,1152
[ 436] 0x900000001fc0ed68:  df b0 00 38 ld	s0,56(sp)
[ 436] 0x900000001fc0ed6c:  0f f0 15 fd jal		podMode
[ 436] 0x900000001fc0ed70:  02 20 20 25 move	a0,s1
[ 436] 0x900000001fc0ed74:  df b1 00 30 ld	s1,48(sp)
[ 436] 0x900000001fc0ed78:  10 00 00 0d b		0x900000001fc0edb0
[ 436] 0x900000001fc0ed7c:  df bf 00 40 ld	ra,64(sp)
[ 436] 0x900000001fc0ed80:  df b1 00 30 ld	s1,48(sp)
[ 431] 0x900000001fc0ed84:  df b4 00 18 ld	s4,24(sp)
[ 431] 0x900000001fc0ed88:  0f f0 5b 40 jal		load_io4prom
[ 431] 0x900000001fc0ed8c:  00 00 00 21 nada
[ 432] 0x900000001fc0ed90:  30 44 00 ff andi	a0,v0,0xff
[ 432] 0x900000001fc0ed94:  0f f0 3f 12 jal		sc_disp
[ 432] 0x900000001fc0ed98:  00 80 90 25 move	s2,a0
[ 433] 0x900000001fc0ed9c:  66 05 04 68 daddiu	a1,s0,1128
[ 433] 0x900000001fc0eda0:  df b0 00 38 ld	s0,56(sp)
[ 433] 0x900000001fc0eda4:  0f f0 15 fd jal		podMode
[ 433] 0x900000001fc0eda8:  02 40 20 25 move	a0,s2
[ 433] 0x900000001fc0edac:  df bf 00 40 ld	ra,64(sp)
[ 433] 0x900000001fc0edb0:  df b2 00 28 ld	s2,40(sp)
[ 433] 0x900000001fc0edb4:  03 e0 00 08 jr	ra
[ 433] 0x900000001fc0edb8:  67 bd 00 50 daddiu	sp,sp,80
Skipping source listing to line 39 of /cores/banyan/stand/arcs/IP25prom/epc_config.c...
   40:  *	   On return, this data structure will be updated with the
   41:  *	   configuration information for the master IO4.
   42:  * Returns:
   43:  *	0 if the master IO4 was found and configured correctly,
   44:  *	EVDIAG_NOEPC1 if an error occurred.
   45:  */
   46: 
   47: int
   48: io4_initmaster(evcfginfo_t *evcfg)
   49: {
io4_initmaster:
[  49] 0x900000001fc0edbc:  3c 03 90 00 lui	v1,0x9000
[  49] 0x900000001fc0edc0:  67 bd ff 90 daddiu	sp,sp,-112
[  49] 0x900000001fc0edc4:  60 63 00 00 daddi	v1,v1,0
[  49] 0x900000001fc0edc8:  ff b7 00 20 sd	s7,32(sp)
[  49] 0x900000001fc0edcc:  00 80 b8 25 move	s7,a0
   50:     int slot;			/* Start with the largest legal slot */
   51:     int winnum;			/* Window numbers */
   52:     int diagval = 0;		/* Diagval for board */
   53:     int master_slot = -1;	/* Master IO board's slot number (or -1) */
[  53] 0x900000001fc0edd0:  24 02 ff ff li	v0,-1
[  53] 0x900000001fc0edd4:  00 03 18 3c dsll32	v1,v1,0
[  53] 0x900000001fc0edd8:  3c 04 1f c2 lui	a0,0x1fc2
[  53] 0x900000001fc0eddc:  ff be 00 18 sd	s8,24(sp)
[  53] 0x900000001fc0ede0:  60 84 d3 f8 daddi	a0,a0,-11272
[  53] 0x900000001fc0ede4:  8e e1 06 d8 lw	at,1752(s7)
[  53] 0x900000001fc0ede8:  ff b5 00 30 sd	s5,48(sp)
[  53] 0x900000001fc0edec:  24 15 00 01 li	s5,1
[  53] 0x900000001fc0edf0:  00 64 18 2c dadd	v1,v1,a0
[  53] 0x900000001fc0edf4:  ff a2 00 00 sd	v0,0(sp)
[  53] 0x900000001fc0edf8:  30 21 00 02 andi	at,at,0x2
   54:     int epcioa = 0;		/* Master EPC ioa (or 0) */
[  54] 0x900000001fc0edfc:  ff b3 00 40 sd	s3,64(sp)
[  54] 0x900000001fc0ee00:  24 13 00 07 li	s3,7
[  54] 0x900000001fc0ee04:  ff b0 00 58 sd	s0,88(sp)
[  54] 0x900000001fc0ee08:  ff b1 00 50 sd	s1,80(sp)
[  54] 0x900000001fc0ee0c:  ff b2 00 48 sd	s2,72(sp)
[  54] 0x900000001fc0ee10:  ff b4 00 38 sd	s4,56(sp)
[  54] 0x900000001fc0ee14:  ff b6 00 28 sd	s6,40(sp)
[  54] 0x900000001fc0ee18:  ff bf 00 60 sd	ra,96(sp)
[  54] 0x900000001fc0ee1c:  14 20 00 03 bne	at,zero,0x900000001fc0ee2c
[  54] 0x900000001fc0ee20:  ff a0 00 08 sd	zero,8(sp)
   55: 
   56:     /* If we're booting off of the second IO4, we need to numer
   57:      * it with 1, but it's antisocial to leave the first one
   58:      * unmapped so we number it 7.
   59:      */
   60:     if (evcfg->ecfg_debugsw & VDS_2ND_IO4)
   61: 	winnum = 7;
   62:     else
   63: 	winnum = 1;
[  63] 0x900000001fc0ee24:  10 00 00 01 b		0x900000001fc0ee2c
[  63] 0x900000001fc0ee28:  02 a0 98 25 move	s3,s5
   64: 
   65:     /*
   66:      * Find the master IO4 by searching until we find the IO4 board
   67:      * in the highest numbered slot (unless VDS_2ND_IO4 is set).
   68:      */ 
   69:     evcfg->ecfg_epcioa = 0;
[  69] 0x900000001fc0ee2c:  ae e0 06 d4 sw	zero,1748(s7)
   70:     for (slot = EV_MAX_SLOTS - 1; slot >= 0; slot--) {
[  70] 0x900000001fc0ee30:  24 11 00 0f li	s1,15
[  70] 0x900000001fc0ee34:  66 f0 06 54 daddiu	s0,s7,1620
[  70] 0x900000001fc0ee38:  ff a3 00 10 sd	v1,16(sp)
[  70] 0x900000001fc0ee3c:  24 16 00 21 li	s6,33
[  70] 0x900000001fc0ee40:  66 f4 ff 94 daddiu	s4,s7,-108
[  70] 0x900000001fc0ee44:  dc 7e 00 00 ld	s8,0(v1)
[  70] 0x900000001fc0ee48:  00 00 10 25 move	v0,zero
[  70] 0x900000001fc0ee4c:  00 11 32 c0 sll	a2,s1,11
   71: 	if (evcfg->ecfg_board[slot].eb_type == EVTYPE_IO4) {
[  71] 0x900000001fc0ee50:  92 05 00 64 lbu	a1,100(s0)
[  71] 0x900000001fc0ee54:  54 b6 00 47 bnel	a1,s6,0x900000001fc0ef74
[  71] 0x900000001fc0ee58:  26 31 ff ff addiu	s1,s1,-1
[  71] 0x900000001fc0ee5c:  02 20 28 25 move	a1,s1
   72: 	    evcfg->ecfg_board[slot].eb_slot = slot;
   73: 
   74: 	    /* Set IO4 board rev to IA chip type and rev */
   75: 	    evcfg->ecfg_board[slot].eb_rev = 
[  75] 0x900000001fc0ee60:  00 de 30 2d daddu	a2,a2,s8
[  72] 0x900000001fc0ee64:  a2 11 00 69 sb	s1,105(s0)
   76: 		(u_char)(EV_GET_CONFIG(slot, IO4_CONF_REVTYPE) &
   77: 			(IO4_TYPE_MASK | IO4_REV_MASK));
   78: 
   79: 	    if (winnum == 1) {
[  79] 0x900000001fc0ee68:  dc c6 00 00 ld	a2,0(a2)
[  79] 0x900000001fc0ee6c:  30 c6 00 ff andi	a2,a2,0xff
[  79] 0x900000001fc0ee70:  a2 06 00 65 sb	a2,101(s0)
[  79] 0x900000001fc0ee74:  52 75 00 04 beql	s3,s5,0x900000001fc0ee88
[  79] 0x900000001fc0ee78:  00 00 10 25 move	v0,zero
   80: 		master_slot = slot;
   81: 		if (!(evcfg->ecfg_debugsw & VDS_NO_DIAGS))
   82: 			diagval = check_io4(winnum, slot);
   83: 		else
   84: 			diagval = 0;
   85: 	    } else {
   86: 		diagval = 0;
[  86] 0x900000001fc0ee7c:  10 00 00 0b b		0x900000001fc0eeac
[  86] 0x900000001fc0ee80:  00 00 00 21 nada
[  86] 0x900000001fc0ee84:  00 00 10 25 move	v0,zero
[  81] 0x900000001fc0ee88:  8e e7 06 d8 lw	a3,1752(s7)
[  81] 0x900000001fc0ee8c:  30 e7 00 10 andi	a3,a3,0x10
[  80] 0x900000001fc0ee90:  ff b1 00 00 sd	s1,0(sp)
[  80] 0x900000001fc0ee94:  10 e0 00 03 beq	a3,zero,0x900000001fc0eea4
[  80] 0x900000001fc0ee98:  00 00 00 21 nada
[  84] 0x900000001fc0ee9c:  10 00 00 03 b		0x900000001fc0eeac
[  84] 0x900000001fc0eea0:  00 00 00 21 nada
[  82] 0x900000001fc0eea4:  0f f0 3d 0f jal		check_io4
[  82] 0x900000001fc0eea8:  02 60 20 25 move	a0,s3
   87: 	    }
   88: 
   89: 	    if (diagval == 0) {
[  89] 0x900000001fc0eeac:  14 40 00 10 bne	v0,zero,0x900000001fc0eef0
[  89] 0x900000001fc0eeb0:  00 00 00 21 nada
   90: 		diagval = initialize_io4(&(evcfg->ecfg_board[slot]), winnum);
[  90] 0x900000001fc0eeb4:  02 60 28 25 move	a1,s3
[  90] 0x900000001fc0eeb8:  0f f0 3c 0b jal		initialize_io4
[  90] 0x900000001fc0eebc:  02 00 20 25 move	a0,s0
   91: 		if (!diagval && (winnum == 1) &&
[  91] 0x900000001fc0eec0:  14 40 00 0b bne	v0,zero,0x900000001fc0eef0
[  91] 0x900000001fc0eec4:  00 00 00 21 nada
[  91] 0x900000001fc0eec8:  16 75 00 07 bne	s3,s5,0x900000001fc0eee8
[  91] 0x900000001fc0eecc:  00 00 00 21 nada
[  91] 0x900000001fc0eed0:  8e e8 06 d8 lw	a4,1752(s7)
[  91] 0x900000001fc0eed4:  31 08 00 10 andi	a4,a4,0x10
[  91] 0x900000001fc0eed8:  15 00 00 03 bne	a4,zero,0x900000001fc0eee8
[  91] 0x900000001fc0eedc:  02 20 28 25 move	a1,s1
   92: 				(!(evcfg->ecfg_debugsw & VDS_NO_DIAGS)))
   93: 		    diagval = check_iaram(winnum, slot);
[  93] 0x900000001fc0eee0:  0f f0 56 20 jal		check_iaram
[  93] 0x900000001fc0eee4:  02 60 20 25 move	a0,s3
   94: 	    }
   95: 
   96: 	    if (diagval == 0) {
[  96] 0x900000001fc0eee8:  10 40 00 04 beq	v0,zero,0x900000001fc0eefc
[  96] 0x900000001fc0eeec:  00 00 00 21 nada
[  96] 0x900000001fc0eef0:  a2 02 00 68 sb	v0,104(s0)
   97: 		/* Try and find the master EPC */
   98: 		if (winnum == 1) {
   99: 		    epcioa = find_epc(&(evcfg->ecfg_board[slot]));
  100: 		    if (epcioa && !(evcfg->ecfg_debugsw & VDS_NO_DIAGS))
  101: 		        evcfg->ecfg_board[slot].eb_ioarr[epcioa].ioa_diagval =
  102: 					pod_check_epc(slot, epcioa, winnum);
  103: 		}
  104: 		winnum++;
  105: 
  106: 		/* If we're booting off of the second IO4, we need to numer
  107: 		 * it with 1, but it's antisocial to leave the first one
  108: 		 * unmapped so we number it 7.
  109: 		 */
  110: 		if (evcfg->ecfg_debugsw & VDS_2ND_IO4)
  111: 		    if (winnum >= 8)
  112: 			winnum = 1;
  113: 	    } else {
  114: 		evcfg->ecfg_board[slot].eb_diagval = diagval;
[ 114] 0x900000001fc0eef4:  10 00 00 1f b		0x900000001fc0ef74
[ 114] 0x900000001fc0eef8:  26 31 ff ff addiu	s1,s1,-1
[  98] 0x900000001fc0eefc:  56 75 00 15 bnel	s3,s5,0x900000001fc0ef54
[  98] 0x900000001fc0ef00:  8e f8 06 d8 lw	t8,1752(s7)
[  99] 0x900000001fc0ef04:  0f f0 3c 94 jal		find_epc
[  99] 0x900000001fc0ef08:  02 00 20 25 move	a0,s0
[  99] 0x900000001fc0ef0c:  02 20 20 25 move	a0,s1
[  99] 0x900000001fc0ef10:  00 40 90 25 move	s2,v0
[ 100] 0x900000001fc0ef14:  ff b2 00 08 sd	s2,8(sp)
[ 100] 0x900000001fc0ef18:  52 40 00 0e beql	s2,zero,0x900000001fc0ef54
[ 100] 0x900000001fc0ef1c:  8e f8 06 d8 lw	t8,1752(s7)
[ 100] 0x900000001fc0ef20:  02 60 30 25 move	a2,s3
[ 100] 0x900000001fc0ef24:  8e e9 06 d8 lw	a5,1752(s7)
[ 100] 0x900000001fc0ef28:  31 29 00 10 andi	a5,a5,0x10
[ 100] 0x900000001fc0ef2c:  55 20 00 09 bnel	a5,zero,0x900000001fc0ef54
[ 100] 0x900000001fc0ef30:  8e f8 06 d8 lw	t8,1752(s7)
[ 101] 0x900000001fc0ef34:  0f f0 55 36 jal		pod_check_epc
[ 101] 0x900000001fc0ef38:  df a5 00 08 ld	a1,8(sp)
[ 101] 0x900000001fc0ef3c:  00 12 50 b8 dsll	a6,s2,2
[ 101] 0x900000001fc0ef40:  00 12 90 f8 dsll	s2,s2,3
[ 101] 0x900000001fc0ef44:  02 4a 50 2d daddu	a6,s2,a6
[ 101] 0x900000001fc0ef48:  02 0a 50 2d daddu	a6,s0,a6
[ 101] 0x900000001fc0ef4c:  a1 42 00 06 sb	v0,6(a6)
[ 101] 0x900000001fc0ef50:  8e f8 06 d8 lw	t8,1752(s7)
[ 104] 0x900000001fc0ef54:  33 18 00 02 andi	t8,t8,0x2
[ 104] 0x900000001fc0ef58:  26 73 00 01 addiu	s3,s3,1
[ 104] 0x900000001fc0ef5c:  13 00 00 04 beq	t8,zero,0x900000001fc0ef70
[ 104] 0x900000001fc0ef60:  2a 79 00 08 slti	t9,s3,8
[ 111] 0x900000001fc0ef64:  57 20 00 03 bnel	t9,zero,0x900000001fc0ef74
[ 111] 0x900000001fc0ef68:  26 31 ff ff addiu	s1,s1,-1
[ 112] 0x900000001fc0ef6c:  02 a0 98 25 move	s3,s5
[ 112] 0x900000001fc0ef70:  26 31 ff ff addiu	s1,s1,-1
[  70] 0x900000001fc0ef74:  66 10 ff 94 daddiu	s0,s0,-108
[  70] 0x900000001fc0ef78:  56 14 ff b4 bnel	s0,s4,0x900000001fc0ee4c
[  70] 0x900000001fc0ef7c:  00 00 10 25 move	v0,zero
[  70] 0x900000001fc0ef80:  24 1e ff ff li	s8,-1
[  70] 0x900000001fc0ef84:  df b9 00 00 ld	t9,0(sp)
[  70] 0x900000001fc0ef88:  df bf 00 08 ld	ra,8(sp)
  115: 	    } 
  116: 	} 
  117:     }
  118: 
  119:     evcfg->ecfg_epcioa = epcioa;
[ 119] 0x900000001fc0ef8c:  df b5 00 30 ld	s5,48(sp)
[ 119] 0x900000001fc0ef90:  ae ff 06 d4 sw	ra,1748(s7)
[ 119] 0x900000001fc0ef94:  13 3e 00 1a beq	t9,s8,0x900000001fc0f000
[ 119] 0x900000001fc0ef98:  24 02 00 46 li	v0,70
  120: 
  121:     if (master_slot == -1)
  122: 	return EVDIAG_NOIO4;
  123: 
  124:     if (evcfg->ecfg_board[master_slot].eb_diagval)
[ 124] 0x900000001fc0ef9c:  df a1 00 00 ld	at,0(sp)
[ 124] 0x900000001fc0efa0:  df a4 00 08 ld	a0,8(sp)
[ 124] 0x900000001fc0efa4:  00 01 18 b8 dsll	v1,at,2
[ 124] 0x900000001fc0efa8:  00 01 11 38 dsll	v0,at,4
[ 124] 0x900000001fc0efac:  00 01 09 f8 dsll	at,at,7
[ 124] 0x900000001fc0efb0:  00 43 10 2d daddu	v0,v0,v1
[ 124] 0x900000001fc0efb4:  00 22 08 2f dsubu	at,at,v0
[ 124] 0x900000001fc0efb8:  02 e1 80 2d daddu	s0,s7,at
[ 124] 0x900000001fc0efbc:  92 01 00 68 lbu	at,104(s0)
[ 124] 0x900000001fc0efc0:  54 20 00 0d bnel	at,zero,0x900000001fc0eff8
[ 124] 0x900000001fc0efc4:  df b3 00 40 ld	s3,64(sp)
  125: 	return evcfg->ecfg_board[master_slot].eb_diagval;
  126: 
  127:     return (epcioa ? evcfg->ecfg_board[master_slot].eb_ioarr[epcioa].ioa_diagval
[ 127] 0x900000001fc0efc8:  df a5 00 08 ld	a1,8(sp)
[ 127] 0x900000001fc0efcc:  df b3 00 40 ld	s3,64(sp)
[ 127] 0x900000001fc0efd0:  10 80 00 06 beq	a0,zero,0x900000001fc0efec
[ 127] 0x900000001fc0efd4:  24 11 00 4f li	s1,79
[ 127] 0x900000001fc0efd8:  00 05 30 b8 dsll	a2,a1,2
[ 127] 0x900000001fc0efdc:  00 05 28 f8 dsll	a1,a1,3
[ 127] 0x900000001fc0efe0:  00 a6 28 2d daddu	a1,a1,a2
[ 127] 0x900000001fc0efe4:  02 05 28 2d daddu	a1,s0,a1
[ 127] 0x900000001fc0efe8:  90 b1 00 06 lbu	s1,6(a1)
[ 127] 0x900000001fc0efec:  10 00 00 05 b		0x900000001fc0f004
[ 127] 0x900000001fc0eff0:  02 20 10 25 move	v0,s1
[ 127] 0x900000001fc0eff4:  df b3 00 40 ld	s3,64(sp)
[ 125] 0x900000001fc0eff8:  10 00 00 02 b		0x900000001fc0f004
[ 125] 0x900000001fc0effc:  92 02 00 68 lbu	v0,104(s0)
[ 125] 0x900000001fc0f000:  df b3 00 40 ld	s3,64(sp)
[ 122] 0x900000001fc0f004:  df b1 00 50 ld	s1,80(sp)
[ 122] 0x900000001fc0f008:  df be 00 18 ld	s8,24(sp)
[ 122] 0x900000001fc0f00c:  df bf 00 60 ld	ra,96(sp)
[ 122] 0x900000001fc0f010:  df b6 00 28 ld	s6,40(sp)
[ 122] 0x900000001fc0f014:  df b4 00 38 ld	s4,56(sp)
[ 122] 0x900000001fc0f018:  df b2 00 48 ld	s2,72(sp)
[ 122] 0x900000001fc0f01c:  df b0 00 58 ld	s0,88(sp)
[ 122] 0x900000001fc0f020:  df b7 00 20 ld	s7,32(sp)
[ 122] 0x900000001fc0f024:  03 e0 00 08 jr	ra
[ 122] 0x900000001fc0f028:  67 bd 00 70 daddiu	sp,sp,112
  128: 		   : EVDIAG_NOEPC);
  129: }
  130: 
  131: 
  132: /*
  133:  * initialize_io4()
  134:  * 	Examines the IO adaptors of the IO4 in the given slot
  135:  * 	and initializes the IO4 configuration registers appropriately.
  136:  */
  137: 
  138: static int
  139: initialize_io4(evbrdinfo_t *io4info, uint window)
  140: {
initialize_io4:
[ 140] 0x900000001fc0f02c:  67 bd ff 30 daddiu	sp,sp,-208
  141:     uint iodev[2];		/* The I/O device configuration registers */ 
  142:     int i;			/* IOA index */
  143:     int value;			/* IO adapter value */
  144:     int slot;			/* Slot containing this window */
  145:     unsigned int adaps = 0;	/* Adapter activation mask */
  146:     jmp_buf fault_buf;		/* Jump buffer for returning from exceptions */
  147:     unsigned *old_buf;		/* Previous fault handler buffer */
  148: 
  149:     /* Setup the slot and window information fields */
  150:     slot = io4info->eb_slot;
[ 150] 0x900000001fc0f030:  ff b2 00 30 sd	s2,48(sp)
[ 150] 0x900000001fc0f034:  90 92 00 69 lbu	s2,105(a0)
[ 150] 0x900000001fc0f038:  ff b1 00 40 sd	s1,64(sp)
[ 150] 0x900000001fc0f03c:  00 80 88 25 move	s1,a0
  151:     io4info->eb_io.eb_winnum = window;
[ 151] 0x900000001fc0f040:  a0 85 00 60 sb	a1,96(a0)
[ 145] 0x900000001fc0f044:  ff b0 00 48 sd	s0,72(sp)
[ 145] 0x900000001fc0f048:  00 00 80 25 move	s0,zero
  152: 
  153:     if (setfault(fault_buf, &old_buf)) {
[ 153] 0x900000001fc0f04c:  67 a4 00 60 daddiu	a0,sp,96
[ 153] 0x900000001fc0f050:  ff a5 00 10 sd	a1,16(sp)
[ 153] 0x900000001fc0f054:  ff bf 00 50 sd	ra,80(sp)
[ 153] 0x900000001fc0f058:  0f f0 18 7f jal		setfault
[ 153] 0x900000001fc0f05c:  67 a5 00 08 daddiu	a1,sp,8
[ 153] 0x900000001fc0f060:  3c 18 1f c2 lui	t8,0x1fc2
[ 153] 0x900000001fc0f064:  24 19 00 50 li	t9,80
[ 153] 0x900000001fc0f068:  ff b2 00 18 sd	s2,24(sp)
[ 153] 0x900000001fc0f06c:  ff b3 00 38 sd	s3,56(sp)
[ 153] 0x900000001fc0f070:  54 40 00 71 bnel	v0,zero,0x900000001fc0f238
[ 153] 0x900000001fc0f074:  df b2 00 30 ld	s2,48(sp)
  154:         return EVDIAG_CFGBUSERR;
  155:     }
  156: 
  157:     /* Set the window bases, the endianess, and some interrupt info */
  158:     EV_SET_CONFIG(slot, IO4_CONF_LW,  window);
[ 158] 0x900000001fc0f078:  3c 13 90 00 lui	s3,0x9000
[ 158] 0x900000001fc0f07c:  62 73 00 00 daddi	s3,s3,0
[ 158] 0x900000001fc0f080:  63 19 d3 f8 daddi	t9,t8,-11272
[ 158] 0x900000001fc0f084:  00 13 98 3c dsll32	s3,s3,0
[ 158] 0x900000001fc0f088:  02 79 98 2c dadd	s3,s3,t9
[ 158] 0x900000001fc0f08c:  df b8 00 18 ld	t8,24(sp)
[ 158] 0x900000001fc0f090:  00 18 92 c0 sll	s2,t8,11
[ 158] 0x900000001fc0f094:  df b8 00 10 ld	t8,16(sp)
[ 158] 0x900000001fc0f098:  de 79 00 08 ld	t9,8(s3)
[ 158] 0x900000001fc0f09c:  00 18 c0 3c dsll32	t8,t8,0
[ 158] 0x900000001fc0f0a0:  02 59 c8 2d daddu	t9,s2,t9
[ 158] 0x900000001fc0f0a4:  00 18 c0 3e dsrl32	t8,t8,0
[ 158] 0x900000001fc0f0a8:  ff b2 00 20 sd	s2,32(sp)
[ 158] 0x900000001fc0f0ac:  ff 38 00 00 sd	t8,0(t9)
  159:     EV_SET_CONFIG(slot, IO4_CONF_SW, window);
[ 159] 0x900000001fc0f0b0:  de 79 00 00 ld	t9,0(s3)
[ 159] 0x900000001fc0f0b4:  02 59 c8 2d daddu	t9,s2,t9
  160:     EV_SET_CONFIG(slot, IO4_CONF_ENDIAN, !getendian());
[ 160] 0x900000001fc0f0b8:  ff 38 00 00 sd	t8,0(t9)
[ 160] 0x900000001fc0f0bc:  0f f0 0d d0 jal		getendian
[ 160] 0x900000001fc0f0c0:  ff b3 00 28 sd	s3,40(sp)
[ 160] 0x900000001fc0f0c4:  df aa 00 28 ld	a6,40(sp)
[ 160] 0x900000001fc0f0c8:  dd 59 00 10 ld	t9,16(a6)
[ 160] 0x900000001fc0f0cc:  02 59 c8 2d daddu	t9,s2,t9
[ 160] 0x900000001fc0f0d0:  2c 58 00 01 sltiu	t8,v0,1
[ 160] 0x900000001fc0f0d4:  ff 38 00 00 sd	t8,0(t9)
  161:     EV_GET_CONFIG(slot, IO4_CONF_IBUSERRORCLR);
[ 161] 0x900000001fc0f0d8:  dd 58 00 18 ld	t8,24(a6)
  162:     EV_GET_CONFIG(slot, IO4_CONF_EBUSERRORCLR);
[ 162] 0x900000001fc0f0dc:  02 58 f8 2d daddu	ra,s2,t8
[ 162] 0x900000001fc0f0e0:  dd 58 00 20 ld	t8,32(a6)
  163:     EV_SET_CONFIG(slot, IO4_CONF_INTRMASK, 0x2);
[ 163] 0x900000001fc0f0e4:  02 58 c0 2d daddu	t8,s2,t8
[ 163] 0x900000001fc0f0e8:  dd 59 00 28 ld	t9,40(a6)
[ 163] 0x900000001fc0f0ec:  02 59 c8 2d daddu	t9,s2,t9
[ 163] 0x900000001fc0f0f0:  df e0 00 00 ld	zero,0(ra)
[ 163] 0x900000001fc0f0f4:  df 00 00 00 ld	zero,0(t8)
[ 163] 0x900000001fc0f0f8:  24 18 00 02 li	t8,2
[ 163] 0x900000001fc0f0fc:  ff 38 00 00 sd	t8,0(t9)
  164:     EV_SET_CONFIG(slot, IO4_CONF_INTRVECTOR, IO4ERR_VECTOR);
[ 164] 0x900000001fc0f100:  dd 58 00 30 ld	t8,48(a6)
[ 164] 0x900000001fc0f104:  02 58 c8 2d daddu	t9,s2,t8
[ 164] 0x900000001fc0f108:  24 18 03 40 li	t8,832
[ 164] 0x900000001fc0f10c:  ff 38 00 00 sd	t8,0(t9)
  165:     
  166:     /*
  167:      * Get information about the IO adapaters and buiild
  168:      * up the configuration mask appropriately.
  169:      */
  170: 
  171:     iodev[0] = (uint)EV_GET_CONFIG(slot, IO4_CONF_IODEV0);
[ 171] 0x900000001fc0f110:  dd 58 00 38 ld	t8,56(a6)
[ 171] 0x900000001fc0f114:  02 58 c0 2d daddu	t8,s2,t8
[ 171] 0x900000001fc0f118:  df 19 00 00 ld	t9,0(t8)
  172:     iodev[1] = (uint)EV_GET_CONFIG(slot, IO4_CONF_IODEV1);
[ 172] 0x900000001fc0f11c:  dd 58 00 40 ld	t8,64(a6)
[ 172] 0x900000001fc0f120:  02 58 c0 2d daddu	t8,s2,t8
[ 172] 0x900000001fc0f124:  00 19 c8 00 sll	t9,t9,0
[ 172] 0x900000001fc0f128:  af b9 00 00 sw	t9,0(sp)
[ 172] 0x900000001fc0f12c:  df 18 00 00 ld	t8,0(t8)
  173:    
  174:     for (i = 1; i < IO4_MAX_PADAPS; i++) {
[ 174] 0x900000001fc0f130:  00 18 f8 00 sll	ra,t8,0
[ 174] 0x900000001fc0f134:  8f b8 00 00 lw	t8,0(sp)
[ 174] 0x900000001fc0f138:  af bf 00 04 sw	ra,4(sp)
[ 174] 0x900000001fc0f13c:  00 18 c2 02 srl	t8,t8,8
[ 174] 0x900000001fc0f140:  33 19 00 ff andi	t9,t8,0xff
[ 174] 0x900000001fc0f144:  24 0b 00 0e li	a7,14
[ 174] 0x900000001fc0f148:  17 2b 00 02 bne	t9,a7,0x900000001fc0f154
[ 174] 0x900000001fc0f14c:  a2 39 00 13 sb	t9,19(s1)
[ 174] 0x900000001fc0f150:  24 10 00 02 li	s0,2
[ 174] 0x900000001fc0f154:  a2 20 00 14 sb	zero,20(s1)
[ 174] 0x900000001fc0f158:  8f a1 00 00 lw	at,0(sp)
[ 174] 0x900000001fc0f15c:  00 01 0c 02 srl	at,at,16
[ 174] 0x900000001fc0f160:  a2 20 00 20 sb	zero,32(s1)
[ 174] 0x900000001fc0f164:  30 21 00 ff andi	at,at,0xff
[ 174] 0x900000001fc0f168:  a2 21 00 1f sb	at,31(s1)
[ 174] 0x900000001fc0f16c:  8f a2 00 00 lw	v0,0(sp)
[ 174] 0x900000001fc0f170:  00 02 4e 02 srl	a5,v0,24
[ 174] 0x900000001fc0f174:  dd 4f 00 48 ld	t3,72(a6)
[ 174] 0x900000001fc0f178:  14 2b 00 02 bne	at,a7,0x900000001fc0f184
[ 174] 0x900000001fc0f17c:  df ae 00 20 ld	t2,32(sp)
[ 174] 0x900000001fc0f180:  36 10 00 04 ori	s0,s0,0x4
[ 174] 0x900000001fc0f184:  31 23 00 ff andi	v1,a5,0xff
[ 174] 0x900000001fc0f188:  a2 20 00 2c sb	zero,44(s1)
[ 174] 0x900000001fc0f18c:  a2 23 00 2b sb	v1,43(s1)
[ 174] 0x900000001fc0f190:  8f b9 00 04 lw	t9,4(sp)
[ 174] 0x900000001fc0f194:  14 6b 00 02 bne	v1,a7,0x900000001fc0f1a0
[ 174] 0x900000001fc0f198:  00 00 00 21 nada
[ 174] 0x900000001fc0f19c:  36 10 00 08 ori	s0,s0,0x8
[ 174] 0x900000001fc0f1a0:  33 24 00 ff andi	a0,t9,0xff
[ 174] 0x900000001fc0f1a4:  a2 20 00 38 sb	zero,56(s1)
[ 174] 0x900000001fc0f1a8:  a2 24 00 37 sb	a0,55(s1)
[ 174] 0x900000001fc0f1ac:  8f a5 00 04 lw	a1,4(sp)
[ 174] 0x900000001fc0f1b0:  14 8b 00 02 bne	a0,a7,0x900000001fc0f1bc
[ 174] 0x900000001fc0f1b4:  00 05 4a 02 srl	a5,a1,8
[ 174] 0x900000001fc0f1b8:  36 10 00 10 ori	s0,s0,0x10
[ 174] 0x900000001fc0f1bc:  31 26 00 ff andi	a2,a5,0xff
[ 174] 0x900000001fc0f1c0:  a2 20 00 44 sb	zero,68(s1)
[ 174] 0x900000001fc0f1c4:  a2 26 00 43 sb	a2,67(s1)
[ 174] 0x900000001fc0f1c8:  8f a7 00 04 lw	a3,4(sp)
[ 174] 0x900000001fc0f1cc:  df b3 00 38 ld	s3,56(sp)
[ 174] 0x900000001fc0f1d0:  14 cb 00 02 bne	a2,a7,0x900000001fc0f1dc
[ 174] 0x900000001fc0f1d4:  00 07 cc 02 srl	t9,a3,16
[ 174] 0x900000001fc0f1d8:  36 10 00 20 ori	s0,s0,0x20
[ 174] 0x900000001fc0f1dc:  33 28 00 ff andi	a4,t9,0xff
[ 174] 0x900000001fc0f1e0:  a2 20 00 50 sb	zero,80(s1)
[ 174] 0x900000001fc0f1e4:  a2 28 00 4f sb	a4,79(s1)
[ 174] 0x900000001fc0f1e8:  8f a9 00 04 lw	a5,4(sp)
[ 174] 0x900000001fc0f1ec:  15 0b 00 02 bne	a4,a7,0x900000001fc0f1f8
[ 174] 0x900000001fc0f1f0:  00 09 4e 02 srl	a5,a5,24
[ 174] 0x900000001fc0f1f4:  36 10 00 40 ori	s0,s0,0x40
[ 174] 0x900000001fc0f1f8:  31 2c 00 ff andi	t0,a5,0xff
[ 174] 0x900000001fc0f1fc:  a2 20 00 5c sb	zero,92(s1)
[ 174] 0x900000001fc0f200:  55 8b 00 03 bnel	t0,a7,0x900000001fc0f210
[ 174] 0x900000001fc0f204:  00 10 68 3c dsll32	t1,s0,0
[ 174] 0x900000001fc0f208:  36 10 00 80 ori	s0,s0,0x80
[ 174] 0x900000001fc0f20c:  00 10 68 3c dsll32	t1,s0,0
  175: 	value = (iodev[i>>2]  >> (8 * (i & 0x3))) & 0xff;
  176: 
  177: 	/* Switch on iff it's an EPC */
  178: 	if (value == IO4_ADAP_EPC)
  179: 	    adaps |= (1 << i); 
  180: 
  181: 	io4info->eb_ioarr[i].ioa_type = value;
  182: 	io4info->eb_ioarr[i].ioa_virtid = 0;		
  183:     } 
  184: 
  185:     EV_SET_CONFIG(slot, IO4_CONF_ADAP, adaps);
[ 185] 0x900000001fc0f210:  01 cf 70 2d daddu	t2,t2,t3
[ 185] 0x900000001fc0f214:  00 0d 68 3e dsrl32	t1,t1,0
  186: 
  187:     restorefault(old_buf); 
[ 187] 0x900000001fc0f218:  a2 2c 00 5b sb	t0,91(s1)
[ 187] 0x900000001fc0f21c:  fd cd 00 00 sd	t1,0(t2)
[ 187] 0x900000001fc0f220:  0f f0 18 86 jal		restorefault
[ 187] 0x900000001fc0f224:  df a4 00 08 ld	a0,8(sp)
  188:     return 0;
[ 188] 0x900000001fc0f228:  00 00 c8 25 move	t9,zero
[ 188] 0x900000001fc0f22c:  10 00 00 02 b		0x900000001fc0f238
[ 188] 0x900000001fc0f230:  df b2 00 30 ld	s2,48(sp)
[ 154] 0x900000001fc0f234:  df b2 00 30 ld	s2,48(sp)
[ 154] 0x900000001fc0f238:  df bf 00 50 ld	ra,80(sp)
[ 154] 0x900000001fc0f23c:  03 20 10 25 move	v0,t9
[ 154] 0x900000001fc0f240:  df b0 00 48 ld	s0,72(sp)
[ 154] 0x900000001fc0f244:  df b1 00 40 ld	s1,64(sp)
[ 154] 0x900000001fc0f248:  03 e0 00 08 jr	ra
[ 154] 0x900000001fc0f24c:  67 bd 00 d0 daddiu	sp,sp,208
  189: }
  190: 
  191: 
  192: /*
  193:  * find_epc()
  194:  *	Examines the given IO4 board and tries to initialize
  195:  *	the EPC on it.  If it fails, it prints a message and
  196:  *	returns 0.  Otherwise, it returns the padap number.
  197:  */
  198: 
  199: static int
  200: find_epc(evbrdinfo_t *io4info)
  201: {
find_epc:
[ 201] 0x900000001fc0f250:  67 bd ff 60 daddiu	sp,sp,-160
  202:     uint i;			/* Index variable for iterating thru padaps */
  203:     uint window;		/* Window of this IO4 */
  204:     jmp_buf fault_buf; 		/* Jump buffer for returning from exceptions */
  205:     unsigned *old_buf;		/* Previous jump buffer */
  206: 
  207:     sysctlr_message("Initing EPC...");
[ 207] 0x900000001fc0f254:  ff b0 00 20 sd	s0,32(sp)
[ 207] 0x900000001fc0f258:  00 80 80 25 move	s0,a0
[ 207] 0x900000001fc0f25c:  3c 01 90 00 lui	at,0x9000
[ 207] 0x900000001fc0f260:  60 21 00 00 daddi	at,at,0
[ 207] 0x900000001fc0f264:  3c 02 1f c2 lui	v0,0x1fc2
[ 207] 0x900000001fc0f268:  60 42 d4 48 daddi	v0,v0,-11192
[ 207] 0x900000001fc0f26c:  3c 03 90 00 lui	v1,0x9000
[ 207] 0x900000001fc0f270:  ff b2 00 10 sd	s2,16(sp)
[ 207] 0x900000001fc0f274:  60 72 00 00 daddi	s2,v1,0
[ 207] 0x900000001fc0f278:  ff b1 00 18 sd	s1,24(sp)
[ 207] 0x900000001fc0f27c:  3c 11 1f c2 lui	s1,0x1fc2
[ 207] 0x900000001fc0f280:  00 01 08 3c dsll32	at,at,0
[ 207] 0x900000001fc0f284:  ff bf 00 28 sd	ra,40(sp)
[ 207] 0x900000001fc0f288:  0f f0 11 7c jal		sysctlr_message
[ 207] 0x900000001fc0f28c:  00 22 20 2c dadd	a0,at,v0
[ 207] 0x900000001fc0f290:  62 31 d3 f8 daddi	s1,s1,-11272
[ 207] 0x900000001fc0f294:  00 12 08 3c dsll32	at,s2,0
[ 207] 0x900000001fc0f298:  00 31 90 2c dadd	s2,at,s1
  208:     window = io4info->eb_io.eb_winnum;
  209:     for (i = 1; i < IO4_MAX_PADAPS; i++) {
[ 209] 0x900000001fc0f29c:  24 11 00 01 li	s1,1
[ 208] 0x900000001fc0f2a0:  67 ab 00 30 daddiu	a7,sp,48
[ 208] 0x900000001fc0f2a4:  92 02 00 60 lbu	v0,96(s0)
[ 208] 0x900000001fc0f2a8:  92 01 00 13 lbu	at,19(s0)
[ 208] 0x900000001fc0f2ac:  24 19 00 0e li	t9,14
[ 208] 0x900000001fc0f2b0:  ff a2 00 08 sd	v0,8(sp)
[ 208] 0x900000001fc0f2b4:  10 39 00 28 beq	at,t9,0x900000001fc0f358
[ 208] 0x900000001fc0f2b8:  67 a5 00 00 daddiu	a1,sp,0
[ 209] 0x900000001fc0f2bc:  24 11 00 02 li	s1,2
[ 209] 0x900000001fc0f2c0:  67 ab 00 30 daddiu	a7,sp,48
[ 209] 0x900000001fc0f2c4:  92 18 00 1f lbu	t8,31(s0)
[ 209] 0x900000001fc0f2c8:  13 19 00 23 beq	t8,t9,0x900000001fc0f358
[ 209] 0x900000001fc0f2cc:  67 a5 00 00 daddiu	a1,sp,0
[ 209] 0x900000001fc0f2d0:  24 11 00 03 li	s1,3
[ 209] 0x900000001fc0f2d4:  67 ab 00 30 daddiu	a7,sp,48
[ 209] 0x900000001fc0f2d8:  92 1f 00 2b lbu	ra,43(s0)
[ 209] 0x900000001fc0f2dc:  13 f9 00 1e beq	ra,t9,0x900000001fc0f358
[ 209] 0x900000001fc0f2e0:  67 a5 00 00 daddiu	a1,sp,0
[ 209] 0x900000001fc0f2e4:  24 11 00 04 li	s1,4
[ 209] 0x900000001fc0f2e8:  67 ab 00 30 daddiu	a7,sp,48
[ 209] 0x900000001fc0f2ec:  92 01 00 37 lbu	at,55(s0)
[ 209] 0x900000001fc0f2f0:  10 39 00 19 beq	at,t9,0x900000001fc0f358
[ 209] 0x900000001fc0f2f4:  67 a5 00 00 daddiu	a1,sp,0
[ 209] 0x900000001fc0f2f8:  24 11 00 05 li	s1,5
[ 209] 0x900000001fc0f2fc:  67 ab 00 30 daddiu	a7,sp,48
[ 209] 0x900000001fc0f300:  92 02 00 43 lbu	v0,67(s0)
[ 209] 0x900000001fc0f304:  10 59 00 14 beq	v0,t9,0x900000001fc0f358
[ 209] 0x900000001fc0f308:  67 a5 00 00 daddiu	a1,sp,0
[ 209] 0x900000001fc0f30c:  24 11 00 06 li	s1,6
[ 209] 0x900000001fc0f310:  67 ab 00 30 daddiu	a7,sp,48
[ 209] 0x900000001fc0f314:  92 03 00 4f lbu	v1,79(s0)
[ 209] 0x900000001fc0f318:  10 79 00 0f beq	v1,t9,0x900000001fc0f358
[ 209] 0x900000001fc0f31c:  67 a5 00 00 daddiu	a1,sp,0
[ 209] 0x900000001fc0f320:  24 11 00 07 li	s1,7
[ 209] 0x900000001fc0f324:  67 ab 00 30 daddiu	a7,sp,48
[ 209] 0x900000001fc0f328:  92 04 00 5b lbu	a0,91(s0)
[ 209] 0x900000001fc0f32c:  10 99 00 0a beq	a0,t9,0x900000001fc0f358
[ 209] 0x900000001fc0f330:  67 a5 00 00 daddiu	a1,sp,0
[ 209] 0x900000001fc0f334:  df b2 00 10 ld	s2,16(sp)
  210: 	if (io4info->eb_ioarr[i].ioa_type == IO4_ADAP_EPC) {
  211: 
  212: 	    if (setfault(fault_buf, &old_buf)) {
  213: 		sysctlr_message("EPC init failed");
  214: 		restorefault(old_buf);
  215: 		return 0;
  216: 	    }
  217: 
  218: 	    EPC_PROMSET(window,i, EPC_IERR, 0x1000000);
  219: 	    EPC_PROMGET(window,i, EPC_IERRC);
  220: 	    EPC_PROMSET(window,i, EPC_PRSTCLR, 0x3ff);
  221: 
  222: 	    /* Set the EPC IOA value in the BSR */
  223: 	    set_BSR((i << BSR_EPCIOA_SHFT) | get_BSR());
  224: 
  225: 	    restorefault(old_buf);
  226: 	    return i;
  227: 	}
  228:     }
  229: 
  230:     restorefault(old_buf);
[ 230] 0x900000001fc0f338:  0f f0 18 86 jal		restorefault
[ 230] 0x900000001fc0f33c:  df a4 00 00 ld	a0,0(sp)
  231:     return 0;
[ 231] 0x900000001fc0f340:  df b0 00 20 ld	s0,32(sp)
[ 231] 0x900000001fc0f344:  df bf 00 28 ld	ra,40(sp)
[ 231] 0x900000001fc0f348:  00 00 c8 25 move	t9,zero
[ 231] 0x900000001fc0f34c:  df b1 00 18 ld	s1,24(sp)
[ 231] 0x900000001fc0f350:  10 00 00 2d b		0x900000001fc0f408
[ 231] 0x900000001fc0f354:  03 20 10 25 move	v0,t9
[ 212] 0x900000001fc0f358:  0f f0 18 7f jal		setfault
[ 212] 0x900000001fc0f35c:  01 60 20 25 move	a0,a7
[ 212] 0x900000001fc0f360:  df a6 00 08 ld	a2,8(sp)
[ 212] 0x900000001fc0f364:  14 40 00 1e bne	v0,zero,0x900000001fc0f3e0
[ 212] 0x900000001fc0f368:  00 11 3c 00 sll	a3,s1,16
[ 218] 0x900000001fc0f36c:  00 06 34 c0 sll	a2,a2,19
[ 218] 0x900000001fc0f370:  00 07 38 3c dsll32	a3,a3,0
[ 218] 0x900000001fc0f374:  00 06 30 3c dsll32	a2,a2,0
[ 218] 0x900000001fc0f378:  00 07 38 3e dsrl32	a3,a3,0
[ 218] 0x900000001fc0f37c:  00 06 30 3e dsrl32	a2,a2,0
[ 218] 0x900000001fc0f380:  00 c7 38 2d daddu	a3,a2,a3
[ 218] 0x900000001fc0f384:  de 46 00 70 ld	a2,112(s2)
[ 218] 0x900000001fc0f388:  00 e6 40 2d daddu	a4,a3,a2
[ 218] 0x900000001fc0f38c:  3c 06 01 00 lui	a2,0x100
[ 218] 0x900000001fc0f390:  df b0 00 20 ld	s0,32(sp)
[ 218] 0x900000001fc0f394:  fd 06 00 00 sd	a2,0(a4)
[ 219] 0x900000001fc0f398:  de 46 00 78 ld	a2,120(s2)
[ 220] 0x900000001fc0f39c:  00 e6 30 2d daddu	a2,a3,a2
[ 220] 0x900000001fc0f3a0:  de 48 00 80 ld	a4,128(s2)
[ 220] 0x900000001fc0f3a4:  df b2 00 10 ld	s2,16(sp)
[ 220] 0x900000001fc0f3a8:  00 e8 38 2d daddu	a3,a3,a4
[ 223] 0x900000001fc0f3ac:  dc c0 00 00 ld	zero,0(a2)
[ 223] 0x900000001fc0f3b0:  24 06 03 ff li	a2,1023
[ 223] 0x900000001fc0f3b4:  0f f0 0d 97 jal		get_BSR
[ 223] 0x900000001fc0f3b8:  fc e6 00 00 sd	a2,0(a3)
[ 223] 0x900000001fc0f3bc:  00 11 32 40 sll	a2,s1,9
[ 223] 0x900000001fc0f3c0:  0f f0 0d 94 jal		set_BSR
[ 223] 0x900000001fc0f3c4:  00 46 20 25 or	a0,v0,a2
[ 225] 0x900000001fc0f3c8:  0f f0 18 86 jal		restorefault
[ 225] 0x900000001fc0f3cc:  df a4 00 00 ld	a0,0(sp)
[ 226] 0x900000001fc0f3d0:  02 20 c8 25 move	t9,s1
[ 226] 0x900000001fc0f3d4:  df b1 00 18 ld	s1,24(sp)
[ 226] 0x900000001fc0f3d8:  10 00 00 0a b		0x900000001fc0f404
[ 226] 0x900000001fc0f3dc:  df bf 00 28 ld	ra,40(sp)
[ 226] 0x900000001fc0f3e0:  df b1 00 18 ld	s1,24(sp)
[ 226] 0x900000001fc0f3e4:  df b0 00 20 ld	s0,32(sp)
[ 213] 0x900000001fc0f3e8:  0f f0 11 7c jal		sysctlr_message
[ 213] 0x900000001fc0f3ec:  66 44 00 60 daddiu	a0,s2,96
[ 214] 0x900000001fc0f3f0:  df b2 00 10 ld	s2,16(sp)
[ 214] 0x900000001fc0f3f4:  0f f0 18 86 jal		restorefault
[ 214] 0x900000001fc0f3f8:  df a4 00 00 ld	a0,0(sp)
[ 215] 0x900000001fc0f3fc:  df bf 00 28 ld	ra,40(sp)
[ 215] 0x900000001fc0f400:  00 00 c8 25 move	t9,zero
[ 215] 0x900000001fc0f404:  03 20 10 25 move	v0,t9
[ 215] 0x900000001fc0f408:  03 e0 00 08 jr	ra
[ 215] 0x900000001fc0f40c:  67 bd 00 a0 daddiu	sp,sp,160
  232: }
  233: 
  234:  
  235: /*
  236:  * master_epc_adap()
  237:  * 	Looks up the PADAP of the EPC on the master IO4 and 
  238:  * 	returns it.  The padap is stashed in the BSR.
  239:  */
  240: 
  241: __scunsigned_t
  242: master_epc_adap(void)
  243: {
master_epc_adap:
[ 243] 0x900000001fc0f410:  67 bd ff f0 daddiu	sp,sp,-16
  244:     return ((get_BSR() & BSR_EPCIOA_MASK) >> BSR_EPCIOA_SHFT);
[ 244] 0x900000001fc0f414:  ff bf 00 00 sd	ra,0(sp)
[ 244] 0x900000001fc0f418:  0f f0 0d 97 jal		get_BSR
[ 244] 0x900000001fc0f41c:  00 00 00 21 nada
[ 244] 0x900000001fc0f420:  df bf 00 00 ld	ra,0(sp)
[ 244] 0x900000001fc0f424:  30 41 1e 00 andi	at,v0,0x1e00
[ 244] 0x900000001fc0f428:  00 01 12 42 srl	v0,at,9
[ 244] 0x900000001fc0f42c:  03 e0 00 08 jr	ra
[ 244] 0x900000001fc0f430:  67 bd 00 10 daddiu	sp,sp,16
Skipping source listing to line 22 of /cores/banyan/stand/arcs/IP25prom/pod_iaid.c...
   23: {IO4_CONF_ETIMEOUT,      0xfffff},
   24: {IO4_CONF_RTIMEOUT,      0xfffff},
   25: {IO4_CONF_INTRMASK,      0x3},
   26: { (-1), 0}
   27: };
   28: 
   29: extern char *ertoip_names[16];
   30: void
   31: dump_errors()
   32: {
dump_errors:
[  32] 0x900000001fc0f434:  03 e0 00 08 jr	ra
[  32] 0x900000001fc0f438:  00 00 00 21 nada
   33: #if DEBUG
   34:         int 	i;
   35:         evreg_t ertoip=0;
   36: 
   37:         ertoip = LD(EV_ERTOIP);
   38:         if (ertoip)
   39: 	{
   40: 		ccloprintf("\n");
   41:                 ccloprintf("*** Error/TimeOut Interrupt(s) Pending: %x ==\n", ertoip);
   42:         	for (i = 0; i < 16; i++)
   43:                 	if (ertoip & (1 << i))
   44:                         	ccloprintf("\t %s\n", ertoip_names[i]);
   45:             	ccloprintf("    EPC %x CAUSE %x BADVADDR %x\n", _epc(0, 0), _cause(0, 0), _badvaddr(0, 0));
   46: 
   47: 	}
   48: #endif
   49: }
   50: 
   51: /*
   52:  * Function : check_io4
   53:  * Description :
   54:  *	Look at the various configuration registers of the IO4, and 
   55:  *	see if they are in good shape.
   56:  * Parameters:
   57:  *	slot   --  Slot containing the IO4 board.
   58:  *	window --  The small and large window number Where it is located.
   59:  */
   60: 
   61: uint check_io4(unsigned window, unsigned slot)
   62: {
check_io4:
[  62] 0x900000001fc0f43c:  67 bd ff 50 daddiu	sp,sp,-176
[  62] 0x900000001fc0f440:  ff b2 00 18 sd	s2,24(sp)
[  62] 0x900000001fc0f444:  00 80 90 25 move	s2,a0
   63:     int result = 0;
   64:     jmp_buf iaid_buf;
   65:     uint *prev_fault;
   66: 
   67:     ccloprintf("Testing master IA chip registers (slot %b)...\n", slot);
[  67] 0x900000001fc0f448:  ff b0 00 30 sd	s0,48(sp)
[  67] 0x900000001fc0f44c:  00 a0 80 25 move	s0,a1
[  67] 0x900000001fc0f450:  3c 01 90 00 lui	at,0x9000
[  67] 0x900000001fc0f454:  60 21 00 00 daddi	at,at,0
[  67] 0x900000001fc0f458:  3c 02 1f c2 lui	v0,0x1fc2
[  67] 0x900000001fc0f45c:  60 42 d4 80 daddi	v0,v0,-11136
[  67] 0x900000001fc0f460:  00 01 08 3c dsll32	at,at,0
[  67] 0x900000001fc0f464:  ff a4 00 08 sd	a0,8(sp)
[  67] 0x900000001fc0f468:  ff b1 00 28 sd	s1,40(sp)
[  67] 0x900000001fc0f46c:  00 22 88 2c dadd	s1,at,v0
[  67] 0x900000001fc0f470:  ff bf 00 38 sd	ra,56(sp)
[  67] 0x900000001fc0f474:  0f f0 2c fa jal		ccloprintf
[  67] 0x900000001fc0f478:  02 20 20 25 move	a0,s1
   68: 
   69:     min_io4config(slot, window);
[  69] 0x900000001fc0f47c:  02 40 28 25 move	a1,s2
[  69] 0x900000001fc0f480:  0f f0 3d f1 jal		min_io4config
[  69] 0x900000001fc0f484:  02 00 20 25 move	a0,s0
   70: 
   71:     if (setfault(iaid_buf, &prev_fault)) {
[  71] 0x900000001fc0f488:  67 a5 00 00 daddiu	a1,sp,0
[  71] 0x900000001fc0f48c:  0f f0 18 7f jal		setfault
[  71] 0x900000001fc0f490:  67 a4 00 40 daddiu	a0,sp,64
[  71] 0x900000001fc0f494:  14 40 00 1f bne	v0,zero,0x900000001fc0f514
[  71] 0x900000001fc0f498:  00 00 00 21 nada
   72: 	/* Returned here due to an error */
   73:         restorefault(prev_fault);
   74: 	ccloprintf("*** Exception while testing IA/ID regs on IO4 in slot %d\n",
   75: 								slot);
   76: 	return EVDIAG_IAREG_BUSERR;
   77:     } else {
   78:         result = io4_check_regs(slot);
[  78] 0x900000001fc0f49c:  0f f0 3d 52 jal		io4_check_regs
[  78] 0x900000001fc0f4a0:  02 00 20 25 move	a0,s0
[  78] 0x900000001fc0f4a4:  ff a2 00 20 sd	v0,32(sp)
   79:     }
   80: 
   81:     restorefault(prev_fault);
[  81] 0x900000001fc0f4a8:  0f f0 18 86 jal		restorefault
[  81] 0x900000001fc0f4ac:  df a4 00 00 ld	a0,0(sp)
[  81] 0x900000001fc0f4b0:  67 a5 00 00 daddiu	a1,sp,0
[  81] 0x900000001fc0f4b4:  df a2 00 20 ld	v0,32(sp)
   82: 
   83:     if (result)
[  83] 0x900000001fc0f4b8:  14 40 00 1c bne	v0,zero,0x900000001fc0f52c
[  83] 0x900000001fc0f4bc:  00 40 c8 25 move	t9,v0
   84: 	return result;
   85:     if (setfault(iaid_buf, &prev_fault)) {
[  85] 0x900000001fc0f4c0:  0f f0 18 7f jal		setfault
[  85] 0x900000001fc0f4c4:  67 a4 00 40 daddiu	a0,sp,64
[  85] 0x900000001fc0f4c8:  14 40 00 06 bne	v0,zero,0x900000001fc0f4e4
[  85] 0x900000001fc0f4cc:  00 00 00 21 nada
   86:         restorefault(prev_fault);
   87: 	/* Returned here due to an error */
   88: 	ccloprintf("*** Exception while testing PIO timeout on IO4 in slot %d\n",
   89: 									slot);
   90: 	result = EVDIAG_IAPIO_BUSERR;
   91:     } else {
   92: 	result = io4_check_errpio(slot, window); 
[  92] 0x900000001fc0f4d0:  02 00 20 25 move	a0,s0
[  92] 0x900000001fc0f4d4:  0f f0 3d 98 jal		io4_check_errpio
[  92] 0x900000001fc0f4d8:  df a5 00 08 ld	a1,8(sp)
[  92] 0x900000001fc0f4dc:  10 00 00 07 b		0x900000001fc0f4fc
[  92] 0x900000001fc0f4e0:  00 00 00 21 nada
[  86] 0x900000001fc0f4e4:  0f f0 18 86 jal		restorefault
[  86] 0x900000001fc0f4e8:  df a4 00 00 ld	a0,0(sp)
[  88] 0x900000001fc0f4ec:  02 00 28 25 move	a1,s0
[  88] 0x900000001fc0f4f0:  0f f0 2c fa jal		ccloprintf
[  88] 0x900000001fc0f4f4:  66 24 00 70 daddiu	a0,s1,112
[  90] 0x900000001fc0f4f8:  24 02 00 52 li	v0,82
   93:     }
   94: 
   95:     restorefault(prev_fault);
[  95] 0x900000001fc0f4fc:  ff a2 00 10 sd	v0,16(sp)
[  95] 0x900000001fc0f500:  0f f0 18 86 jal		restorefault
[  95] 0x900000001fc0f504:  df a4 00 00 ld	a0,0(sp)
   96:     return result;
[  96] 0x900000001fc0f508:  df b9 00 10 ld	t9,16(sp)
[  96] 0x900000001fc0f50c:  10 00 00 08 b		0x900000001fc0f530
[  96] 0x900000001fc0f510:  df b2 00 18 ld	s2,24(sp)
[  73] 0x900000001fc0f514:  0f f0 18 86 jal		restorefault
[  73] 0x900000001fc0f518:  df a4 00 00 ld	a0,0(sp)
[  74] 0x900000001fc0f51c:  02 00 28 25 move	a1,s0
[  74] 0x900000001fc0f520:  0f f0 2c fa jal		ccloprintf
[  74] 0x900000001fc0f524:  66 24 00 30 daddiu	a0,s1,48
[  76] 0x900000001fc0f528:  24 19 00 51 li	t9,81
[  76] 0x900000001fc0f52c:  df b2 00 18 ld	s2,24(sp)
[  76] 0x900000001fc0f530:  df bf 00 38 ld	ra,56(sp)
[  76] 0x900000001fc0f534:  03 20 10 25 move	v0,t9
[  76] 0x900000001fc0f538:  df b0 00 30 ld	s0,48(sp)
[  76] 0x900000001fc0f53c:  df b1 00 28 ld	s1,40(sp)
[  76] 0x900000001fc0f540:  03 e0 00 08 jr	ra
[  76] 0x900000001fc0f544:  67 bd 00 b0 daddiu	sp,sp,176
   97: }
   98: 
   99: 
  100: uint io4_check_regs(int slot)
  101: {
io4_check_regs:
[ 101] 0x900000001fc0f548:  67 bd ff f0 daddiu	sp,sp,-16
  102:     IO4cf_regs	*ioregs;
  103:     int		i,j;
  104:     evreg_t	value, readv, old_value;
  105: 
  106:     for (ioregs = io4_regs,i=0; ioregs->reg_no != (-1); ioregs++,i++){
[ 106] 0x900000001fc0f54c:  3c 01 90 00 lui	at,0x9000
[ 106] 0x900000001fc0f550:  60 21 00 00 daddi	at,at,0
[ 106] 0x900000001fc0f554:  3c 02 1f c2 lui	v0,0x1fc2
[ 106] 0x900000001fc0f558:  60 42 d4 80 daddi	v0,v0,-11136
[ 106] 0x900000001fc0f55c:  00 01 08 3c dsll32	at,at,0
[ 106] 0x900000001fc0f560:  24 0b 00 04 li	a7,4
[ 106] 0x900000001fc0f564:  00 22 18 2c dadd	v1,at,v0
[ 106] 0x900000001fc0f568:  00 04 52 c0 sll	a6,a0,11
[ 106] 0x900000001fc0f56c:  dc 61 00 e8 ld	at,232(v1)
[ 106] 0x900000001fc0f570:  24 08 ff ff li	a4,-1
[ 106] 0x900000001fc0f574:  00 20 c8 25 move	t9,at
[ 106] 0x900000001fc0f578:  8c 21 00 00 lw	at,0(at)
[ 106] 0x900000001fc0f57c:  ff bf 00 00 sd	ra,0(sp)
[ 106] 0x900000001fc0f580:  50 28 00 34 beql	at,a4,0x900000001fc0f654
[ 106] 0x900000001fc0f584:  df bf 00 00 ld	ra,0(sp)
[ 106] 0x900000001fc0f588:  dc 69 00 f0 ld	a5,240(v1)
[ 106] 0x900000001fc0f58c:  24 06 00 01 li	a2,1
[ 106] 0x900000001fc0f590:  00 00 28 25 move	a1,zero
  107:         if (ioregs->bitmask0 == 0)
[ 107] 0x900000001fc0f594:  8f 24 00 04 lw	a0,4(t9)
[ 107] 0x900000001fc0f598:  50 80 00 2a beql	a0,zero,0x900000001fc0f644
[ 107] 0x900000001fc0f59c:  67 39 00 08 daddiu	t9,t9,8
  108:                 continue;
  109: 	old_value = EV_GET_CONFIG(slot, ioregs->reg_no);
[ 109] 0x900000001fc0f5a0:  8f 27 00 00 lw	a3,0(t9)
[ 109] 0x900000001fc0f5a4:  00 07 38 c0 sll	a3,a3,3
[ 109] 0x900000001fc0f5a8:  01 47 38 2d daddu	a3,a6,a3
[ 109] 0x900000001fc0f5ac:  00 e9 38 2d daddu	a3,a3,a5
  110: 	for (j=0, value=1; j < sizeof(unsigned); j++, value <<=1){
[ 110] 0x900000001fc0f5b0:  dc e4 00 00 ld	a0,0(a3)
[ 110] 0x900000001fc0f5b4:  8f 2c 00 04 lw	t0,4(t9)
  111: 	    if (!(ioregs->bitmask0 & value))
[ 111] 0x900000001fc0f5b8:  00 0c 60 3c dsll32	t0,t0,0
[ 111] 0x900000001fc0f5bc:  00 0c 60 3e dsrl32	t0,t0,0
[ 111] 0x900000001fc0f5c0:  00 cc 60 24 and	t0,a2,t0
[ 111] 0x900000001fc0f5c4:  51 80 00 0e beql	t0,zero,0x900000001fc0f600
[ 111] 0x900000001fc0f5c8:  00 06 30 78 dsll	a2,a2,1
  112: 		continue;
  113: 	    EV_SET_CONFIG(slot, ioregs->reg_no, value);
[ 113] 0x900000001fc0f5cc:  8f 2d 00 00 lw	t1,0(t9)
[ 113] 0x900000001fc0f5d0:  00 0d 68 c0 sll	t1,t1,3
[ 113] 0x900000001fc0f5d4:  01 4d 68 2d daddu	t1,a6,t1
[ 113] 0x900000001fc0f5d8:  01 a9 68 2d daddu	t1,t1,a5
[ 113] 0x900000001fc0f5dc:  fd a6 00 00 sd	a2,0(t1)
  114: 	    readv = EV_GET_CONFIG(slot, ioregs->reg_no);
[ 114] 0x900000001fc0f5e0:  8f 2d 00 00 lw	t1,0(t9)
[ 114] 0x900000001fc0f5e4:  00 0d 68 c0 sll	t1,t1,3
[ 114] 0x900000001fc0f5e8:  01 4d 68 2d daddu	t1,a6,t1
[ 114] 0x900000001fc0f5ec:  01 a9 68 2d daddu	t1,t1,a5
[ 114] 0x900000001fc0f5f0:  dd ad 00 00 ld	t1,0(t1)
  115: 
  116: 	    if (readv != value){
[ 116] 0x900000001fc0f5f4:  15 a6 00 0c bne	t1,a2,0x900000001fc0f628
[ 116] 0x900000001fc0f5f8:  01 a0 38 25 move	a3,t1
[ 116] 0x900000001fc0f5fc:  00 06 30 78 dsll	a2,a2,1
[ 110] 0x900000001fc0f600:  24 a5 00 01 addiu	a1,a1,1
[ 110] 0x900000001fc0f604:  00 ab 70 2b sltu	t2,a1,a7
[ 110] 0x900000001fc0f608:  55 c0 ff eb bnel	t2,zero,0x900000001fc0f5b8
[ 110] 0x900000001fc0f60c:  8f 2c 00 04 lw	t0,4(t9)
  117: 		ccloprintf("*** ERROR in IA config reg %d: Expected=0x%x Got: 0x%x\n", 
  118: 					ioregs->reg_no, value, readv);
  119: 		return EVDIAG_IAREG_FAILED;
  120: 	    }
  121:         }
  122: 	EV_SET_CONFIG(slot, ioregs->reg_no, old_value);
[ 122] 0x900000001fc0f610:  8f 2f 00 00 lw	t3,0(t9)
[ 122] 0x900000001fc0f614:  00 0f 78 c0 sll	t3,t3,3
[ 122] 0x900000001fc0f618:  01 4f 78 2d daddu	t3,a6,t3
[ 122] 0x900000001fc0f61c:  01 e9 78 2d daddu	t3,t3,a5
[ 122] 0x900000001fc0f620:  10 00 00 07 b		0x900000001fc0f640
[ 122] 0x900000001fc0f624:  fd e4 00 00 sd	a0,0(t3)
[ 117] 0x900000001fc0f628:  8f 25 00 00 lw	a1,0(t9)
[ 117] 0x900000001fc0f62c:  0f f0 2c fa jal		ccloprintf
[ 117] 0x900000001fc0f630:  64 64 00 b0 daddiu	a0,v1,176
[ 119] 0x900000001fc0f634:  24 02 00 53 li	v0,83
[ 119] 0x900000001fc0f638:  10 00 00 07 b		0x900000001fc0f658
[ 119] 0x900000001fc0f63c:  df bf 00 00 ld	ra,0(sp)
[ 106] 0x900000001fc0f640:  67 39 00 08 daddiu	t9,t9,8
[ 106] 0x900000001fc0f644:  8f 38 00 00 lw	t8,0(t9)
[ 106] 0x900000001fc0f648:  57 08 ff d1 bnel	t8,a4,0x900000001fc0f590
[ 106] 0x900000001fc0f64c:  24 06 00 01 li	a2,1
[ 106] 0x900000001fc0f650:  df bf 00 00 ld	ra,0(sp)
  123:     }
  124: 
  125:     return 0;
[ 125] 0x900000001fc0f654:  00 00 10 25 move	v0,zero
[ 125] 0x900000001fc0f658:  03 e0 00 08 jr	ra
[ 125] 0x900000001fc0f65c:  67 bd 00 10 daddiu	sp,sp,16
  126: }
  127: 
  128: 
  129: /*
  130:  * Function : io4_check_timeout
  131:  * Description :
  132:  *	Do some invalid PIO operation, and check the error bits which
  133:  *	get set. Do the invalid PIO again, and see if the sticky bit 
  134:  *	gets set.
  135:  */
  136: uint io4_check_errpio(int slot, int window)
  137: {
io4_check_errpio:
[ 137] 0x900000001fc0f660:  67 bd ff b0 daddiu	sp,sp,-80
  138:     evreg_t	ebus_error, olvl;
  139:     int		result;
  140: 
  141: #define	exp_error 	(IO4_EBUSERROR_BADIOA | IO4_EBUSERROR_STICKY)
  142: 
  143:     result = 0;
  144:     min_io4config(slot, window);
[ 144] 0x900000001fc0f664:  ff b2 00 30 sd	s2,48(sp)
[ 144] 0x900000001fc0f668:  00 80 90 25 move	s2,a0
[ 144] 0x900000001fc0f66c:  ff b1 00 28 sd	s1,40(sp)
[ 144] 0x900000001fc0f670:  ff bf 00 40 sd	ra,64(sp)
[ 144] 0x900000001fc0f674:  0f f0 3d f1 jal		min_io4config
[ 144] 0x900000001fc0f678:  00 a0 88 25 move	s1,a1
  145: 
  146:     EV_GET_CONFIG(slot, IO4_CONF_EBUSERRORCLR);
[ 146] 0x900000001fc0f67c:  3c 02 90 00 lui	v0,0x9000
[ 146] 0x900000001fc0f680:  60 42 00 00 daddi	v0,v0,0
[ 146] 0x900000001fc0f684:  3c 03 1f c2 lui	v1,0x1fc2
[ 146] 0x900000001fc0f688:  60 63 d4 80 daddi	v1,v1,-11136
[ 146] 0x900000001fc0f68c:  00 02 10 3c dsll32	v0,v0,0
[ 146] 0x900000001fc0f690:  00 43 c8 2c dadd	t9,v0,v1
[ 146] 0x900000001fc0f694:  00 12 5a c0 sll	a7,s2,11
[ 146] 0x900000001fc0f698:  df 22 01 70 ld	v0,368(t9)
  147: 
  148:     olvl = EV_GET_CONFIG(slot, IO4_CONF_INTRVECTOR);
[ 148] 0x900000001fc0f69c:  01 62 50 2d daddu	a6,a7,v0
[ 148] 0x900000001fc0f6a0:  df 22 01 78 ld	v0,376(t9)
[ 148] 0x900000001fc0f6a4:  01 62 48 2d daddu	a5,a7,v0
[ 148] 0x900000001fc0f6a8:  dd 40 00 00 ld	zero,0(a6)
  149: 
  150:     EV_SET_CONFIG(slot, IO4_CONF_INTRVECTOR, IO4ERR_VECTOR);
[ 150] 0x900000001fc0f6ac:  24 05 00 09 li	a1,9
[ 150] 0x900000001fc0f6b0:  dd 28 00 00 ld	a4,0(a5)
[ 150] 0x900000001fc0f6b4:  24 02 03 40 li	v0,832
[ 150] 0x900000001fc0f6b8:  fd 22 00 00 sd	v0,0(a5)
  151:     SD_LO(SWIN_BASE(window, 0), 0);	/* NON_EXISTENT_IOA */
[ 151] 0x900000001fc0f6bc:  00 11 0c c0 sll	at,s1,19
[ 151] 0x900000001fc0f6c0:  df 22 01 80 ld	v0,384(t9)
[ 151] 0x900000001fc0f6c4:  00 22 08 2d daddu	at,at,v0
[ 151] 0x900000001fc0f6c8:  ff b0 00 38 sd	s0,56(sp)
[ 151] 0x900000001fc0f6cc:  fc 20 00 00 sd	zero,0(at)
  152: 
  153:     /* This should set the sticky bit 	*/
  154:     SD_LO(SWIN_BASE(window, 0), 0);	
[ 154] 0x900000001fc0f6d0:  fc 20 00 00 sd	zero,0(at)
[ 143] 0x900000001fc0f6d4:  00 00 80 25 move	s0,zero
  155: 
  156:     ebus_error = EV_GET_CONFIG(slot, IO4_CONF_EBUSERRORCLR);
  157: 
  158:     if (ebus_error != exp_error){
[ 158] 0x900000001fc0f6d8:  24 02 00 09 li	v0,9
[ 158] 0x900000001fc0f6dc:  dd 41 00 00 ld	at,0(a6)
[ 158] 0x900000001fc0f6e0:  10 22 00 0e beq	at,v0,0x900000001fc0f71c
[ 158] 0x900000001fc0f6e4:  00 20 30 25 move	a2,at
  159: 	ccloprintf("*** ERROR: Wrong Error Reg bits set: Exp 0x%x, Act 0x%x\n",
[ 159] 0x900000001fc0f6e8:  ff a8 00 00 sd	a4,0(sp)
[ 159] 0x900000001fc0f6ec:  ff a9 00 08 sd	a5,8(sp)
[ 159] 0x900000001fc0f6f0:  ff aa 00 10 sd	a6,16(sp)
[ 159] 0x900000001fc0f6f4:  ff ab 00 18 sd	a7,24(sp)
[ 159] 0x900000001fc0f6f8:  ff b9 00 20 sd	t9,32(sp)
[ 159] 0x900000001fc0f6fc:  0f f0 2c fa jal		ccloprintf
[ 159] 0x900000001fc0f700:  67 24 00 f8 daddiu	a0,t9,248
  160: 							exp_error, ebus_error);
  161: 	result = EVDIAG_IAPIO_BADERR;
[ 161] 0x900000001fc0f704:  df a8 00 00 ld	a4,0(sp)
[ 161] 0x900000001fc0f708:  df a9 00 08 ld	a5,8(sp)
[ 161] 0x900000001fc0f70c:  df aa 00 10 ld	a6,16(sp)
[ 161] 0x900000001fc0f710:  24 10 00 54 li	s0,84
[ 161] 0x900000001fc0f714:  df ab 00 18 ld	a7,24(sp)
[ 161] 0x900000001fc0f718:  df b9 00 20 ld	t9,32(sp)
[ 161] 0x900000001fc0f71c:  24 05 00 03 li	a1,3
[ 161] 0x900000001fc0f720:  df b1 00 28 ld	s1,40(sp)
  162:     }
  163: 
  164:     if (!(LD(EV_IP0) & (1 << IO4ERR_LEVEL))) {
[ 164] 0x900000001fc0f724:  df 38 01 88 ld	t8,392(t9)
[ 164] 0x900000001fc0f728:  df b2 00 30 ld	s2,48(sp)
[ 164] 0x900000001fc0f72c:  df 18 00 00 ld	t8,0(t8)
[ 164] 0x900000001fc0f730:  33 18 00 08 andi	t8,t8,0x8
[ 164] 0x900000001fc0f734:  57 00 00 0f bnel	t8,zero,0x900000001fc0f774
[ 164] 0x900000001fc0f738:  df bf 00 40 ld	ra,64(sp)
  165: 	ccloprintf("*** ERROR: IA did not send an interrupt on level 0x%b\n",
[ 165] 0x900000001fc0f73c:  ff a8 00 00 sd	a4,0(sp)
[ 165] 0x900000001fc0f740:  ff a9 00 08 sd	a5,8(sp)
[ 165] 0x900000001fc0f744:  ff aa 00 10 sd	a6,16(sp)
[ 165] 0x900000001fc0f748:  ff ab 00 18 sd	a7,24(sp)
[ 165] 0x900000001fc0f74c:  ff b9 00 20 sd	t9,32(sp)
[ 165] 0x900000001fc0f750:  0f f0 2c fa jal		ccloprintf
[ 165] 0x900000001fc0f754:  67 24 01 38 daddiu	a0,t9,312
  166: 							IO4ERR_LEVEL);
  167: 	result =  EVDIAG_IAPIO_NOINT;
[ 167] 0x900000001fc0f758:  df a8 00 00 ld	a4,0(sp)
[ 167] 0x900000001fc0f75c:  df a9 00 08 ld	a5,8(sp)
[ 167] 0x900000001fc0f760:  df aa 00 10 ld	a6,16(sp)
[ 167] 0x900000001fc0f764:  24 10 00 55 li	s0,85
[ 167] 0x900000001fc0f768:  df ab 00 18 ld	a7,24(sp)
[ 167] 0x900000001fc0f76c:  df b9 00 20 ld	t9,32(sp)
[ 167] 0x900000001fc0f770:  df bf 00 40 ld	ra,64(sp)
  168:     }
  169: 
  170:     /* clean up after ourselves. */
  171:     SD(EV_CIPL0, 0);
[ 171] 0x900000001fc0f774:  df 23 01 90 ld	v1,400(t9)
[ 171] 0x900000001fc0f778:  fc 60 00 00 sd	zero,0(v1)
  172: 
  173:     /* Restore interrupt vector */
  174:     EV_SET_CONFIG(slot, IO4_CONF_INTRVECTOR, olvl);
  175: 
  176:     /* Clean out interrupt */
  177:     SD(EV_CIPL0, IO4ERR_LEVEL);
[ 177] 0x900000001fc0f77c:  fd 28 00 00 sd	a4,0(a5)
[ 177] 0x900000001fc0f780:  24 01 00 03 li	at,3
[ 177] 0x900000001fc0f784:  fc 61 00 00 sd	at,0(v1)
  178: 
  179:     /* Clear IO4 error state */
  180:     EV_GET_CONFIG(slot, IO4_CONF_IBUSERRORCLR);
[ 180] 0x900000001fc0f788:  df 21 01 98 ld	at,408(t9)
[ 180] 0x900000001fc0f78c:  01 61 08 2d daddu	at,a7,at
  181:     EV_GET_CONFIG(slot, IO4_CONF_EBUSERRORCLR);
  182: 
  183:     SD_LO(EV_ILE, EV_ERTOINT_MASK | EV_CMPINT_MASK);
[ 183] 0x900000001fc0f790:  dc 20 00 00 ld	zero,0(at)
[ 183] 0x900000001fc0f794:  df 23 01 a0 ld	v1,416(t9)
[ 181] 0x900000001fc0f798:  dd 40 00 00 ld	zero,0(a6)
[ 181] 0x900000001fc0f79c:  24 01 00 0a li	at,10
[ 181] 0x900000001fc0f7a0:  fc 61 00 00 sd	at,0(v1)
  184:     SD_LO(EV_CIPL124, 0);
[ 184] 0x900000001fc0f7a4:  df 21 01 a8 ld	at,424(t9)
[ 184] 0x900000001fc0f7a8:  fc 20 00 00 sd	zero,0(at)
  185:     SD_LO(EV_ERTOIP, 0);
[ 185] 0x900000001fc0f7ac:  df 39 01 b0 ld	t9,432(t9)
  186: 
  187:     return result;
[ 187] 0x900000001fc0f7b0:  02 00 10 25 move	v0,s0
[ 187] 0x900000001fc0f7b4:  df b0 00 38 ld	s0,56(sp)
[ 187] 0x900000001fc0f7b8:  ff 20 00 00 sd	zero,0(t9)
[ 187] 0x900000001fc0f7bc:  03 e0 00 08 jr	ra
[ 187] 0x900000001fc0f7c0:  67 bd 00 50 daddiu	sp,sp,80
  188: 
  189: #undef 	exp_error
  190: }
  191: 
  192: 
  193: /*
  194:  * Function : min_io4config
  195:  * Description : Do minimal IO4 configuration
  196:  */
  197: void min_io4config(int slot, int window)
  198: {
min_io4config:
[ 198] 0x900000001fc0f7c4:  67 bd ff e0 daddiu	sp,sp,-32
  199: 
  200:     /* First do minimal IO4 configuration	*/
  201:     EV_SET_CONFIG(slot, IO4_CONF_LW, window);
[ 201] 0x900000001fc0f7c8:  3c 01 90 00 lui	at,0x9000
[ 201] 0x900000001fc0f7cc:  60 21 00 00 daddi	at,at,0
[ 201] 0x900000001fc0f7d0:  3c 02 1f c2 lui	v0,0x1fc2
[ 201] 0x900000001fc0f7d4:  60 42 d4 80 daddi	v0,v0,-11136
[ 201] 0x900000001fc0f7d8:  00 01 08 3c dsll32	at,at,0
[ 201] 0x900000001fc0f7dc:  ff b1 00 08 sd	s1,8(sp)
[ 201] 0x900000001fc0f7e0:  00 22 88 2c dadd	s1,at,v0
[ 201] 0x900000001fc0f7e4:  ff b0 00 00 sd	s0,0(sp)
[ 201] 0x900000001fc0f7e8:  00 04 82 c0 sll	s0,a0,11
[ 201] 0x900000001fc0f7ec:  de 21 00 f0 ld	at,240(s1)
[ 201] 0x900000001fc0f7f0:  02 01 08 2d daddu	at,s0,at
[ 201] 0x900000001fc0f7f4:  fc 25 00 00 sd	a1,0(at)
  202:     EV_SET_CONFIG(slot, IO4_CONF_SW, window);
[ 202] 0x900000001fc0f7f8:  de 21 01 b8 ld	at,440(s1)
[ 202] 0x900000001fc0f7fc:  02 01 08 2d daddu	at,s0,at
  203: 
  204:     EV_SET_CONFIG(slot, IO4_CONF_ENDIAN, !getendian());
[ 204] 0x900000001fc0f800:  ff bf 00 10 sd	ra,16(sp)
[ 204] 0x900000001fc0f804:  0f f0 0d d0 jal		getendian
[ 204] 0x900000001fc0f808:  fc 25 00 00 sd	a1,0(at)
[ 204] 0x900000001fc0f80c:  df bf 00 10 ld	ra,16(sp)
[ 204] 0x900000001fc0f810:  2c 41 00 01 sltiu	at,v0,1
[ 204] 0x900000001fc0f814:  de 22 01 c0 ld	v0,448(s1)
[ 204] 0x900000001fc0f818:  02 02 10 2d daddu	v0,s0,v0
[ 204] 0x900000001fc0f81c:  fc 41 00 00 sd	at,0(v0)
  205: /* Polarity on getendian? */
  206: 
  207:     EV_GET_CONFIG(slot, IO4_CONF_IBUSERRORCLR);
[ 207] 0x900000001fc0f820:  de 23 01 98 ld	v1,408(s1)
  208:     EV_GET_CONFIG(slot, IO4_CONF_EBUSERRORCLR);
[ 208] 0x900000001fc0f824:  de 21 01 70 ld	at,368(s1)
[ 208] 0x900000001fc0f828:  02 03 18 2d daddu	v1,s0,v1
  209:     EV_SET_CONFIG(slot, IO4_CONF_INTRMASK, 0x2);
[ 209] 0x900000001fc0f82c:  02 01 08 2d daddu	at,s0,at
[ 209] 0x900000001fc0f830:  de 22 01 c8 ld	v0,456(s1)
[ 209] 0x900000001fc0f834:  df b1 00 08 ld	s1,8(sp)
[ 209] 0x900000001fc0f838:  02 02 10 2d daddu	v0,s0,v0
[ 209] 0x900000001fc0f83c:  df b0 00 00 ld	s0,0(sp)
[ 209] 0x900000001fc0f840:  dc 60 00 00 ld	zero,0(v1)
[ 209] 0x900000001fc0f844:  dc 20 00 00 ld	zero,0(at)
[ 209] 0x900000001fc0f848:  24 01 00 02 li	at,2
  210: }
[ 210] 0x900000001fc0f84c:  fc 41 00 00 sd	at,0(v0)
[ 210] 0x900000001fc0f850:  03 e0 00 08 jr	ra
[ 210] 0x900000001fc0f854:  67 bd 00 20 daddiu	sp,sp,32
Skipping source listing to line 133 of /cores/banyan/stand/arcs/IP25prom/diagval.c...
  134:     /*                           12345678901234567890		*/
  135:     {EVDIAG_RETURNING,		"Reentering POD mode",	(char *)NULL},
  136:     {EVDIAG_PANIC,		"PROM EXCEPTION!",	promexc_long},
  137:     {EVDIAG_NMI,		"PROM NMI HANDLER",	promnmi_long},
  138:     {EVDIAG_DEBUG,		"CPU in POD mode.",	(char *)NULL}
  139: };
  140: 
  141: #ifdef PROM
  142: void sysctlr_bootstat(char *message, int leading)
  143: {
sysctlr_bootstat:
[ 143] 0x900000001fc0f858:  67 bd ff d0 daddiu	sp,sp,-48
  144:     int i;
  145: 
  146:     ccuart_putc(SC_ESCAPE);
[ 146] 0x900000001fc0f85c:  ff b1 00 18 sd	s1,24(sp)
[ 146] 0x900000001fc0f860:  00 a0 88 25 move	s1,a1
[ 146] 0x900000001fc0f864:  ff a4 00 00 sd	a0,0(sp)
[ 146] 0x900000001fc0f868:  ff bf 00 08 sd	ra,8(sp)
[ 146] 0x900000001fc0f86c:  0f f0 0c d6 jal		ccuart_putc
[ 146] 0x900000001fc0f870:  24 04 00 18 li	a0,24
  147:     ccuart_putc(SC_SET);
[ 147] 0x900000001fc0f874:  0f f0 0c d6 jal		ccuart_putc
[ 147] 0x900000001fc0f878:  24 04 00 53 li	a0,83
  148:     ccuart_putc(SC_PROCSTAT);
[ 148] 0x900000001fc0f87c:  0f f0 0c d6 jal		ccuart_putc
[ 148] 0x900000001fc0f880:  24 04 00 50 li	a0,80
  149:     for (i = 0; i < leading; i++)
[ 149] 0x900000001fc0f884:  ff b0 00 20 sd	s0,32(sp)
[ 149] 0x900000001fc0f888:  00 00 80 25 move	s0,zero
[ 149] 0x900000001fc0f88c:  ff b2 00 10 sd	s2,16(sp)
[ 149] 0x900000001fc0f890:  1a 20 00 06 blez	s1,0x900000001fc0f8ac
[ 149] 0x900000001fc0f894:  24 12 00 20 li	s2,32
  150: 	    ccuart_putc(' ');
[ 150] 0x900000001fc0f898:  0f f0 0c d6 jal		ccuart_putc
[ 150] 0x900000001fc0f89c:  02 40 20 25 move	a0,s2
[ 149] 0x900000001fc0f8a0:  26 10 00 01 addiu	s0,s0,1
[ 149] 0x900000001fc0f8a4:  16 11 ff fc bne	s0,s1,0x900000001fc0f898
[ 149] 0x900000001fc0f8a8:  00 00 00 21 nada
[ 149] 0x900000001fc0f8ac:  df b2 00 10 ld	s2,16(sp)
  151:     ccuart_puts(message);
[ 151] 0x900000001fc0f8b0:  0f f0 0d 14 jal		ccuart_puts
[ 151] 0x900000001fc0f8b4:  df a4 00 00 ld	a0,0(sp)
  152:     ccuart_putc(SC_TERM);
[ 152] 0x900000001fc0f8b8:  df b0 00 20 ld	s0,32(sp)
[ 152] 0x900000001fc0f8bc:  df b1 00 18 ld	s1,24(sp)
[ 152] 0x900000001fc0f8c0:  0f f0 0c d6 jal		ccuart_putc
[ 152] 0x900000001fc0f8c4:  24 04 00 0a li	a0,10
  153: }
[ 153] 0x900000001fc0f8c8:  df bf 00 08 ld	ra,8(sp)
[ 153] 0x900000001fc0f8cc:  03 e0 00 08 jr	ra
[ 153] 0x900000001fc0f8d0:  67 bd 00 30 daddiu	sp,sp,48
  154: 
  155: 
  156: void scroll_message(unsigned char *message, int reps)
  157: {
scroll_message:
[ 157] 0x900000001fc0f8d4:  67 bd ff 50 daddiu	sp,sp,-176
[ 157] 0x900000001fc0f8d8:  ff be 00 08 sd	s8,8(sp)
[ 157] 0x900000001fc0f8dc:  00 80 f0 25 move	s8,a0
[ 157] 0x900000001fc0f8e0:  ff b4 00 28 sd	s4,40(sp)
[ 157] 0x900000001fc0f8e4:  00 a0 a0 25 move	s4,a1
  158: 	int display_size;
  159: 	int length;
  160: 	int i;
  161: 	unsigned char buffer[80];
  162: 	char c;
  163: 
  164: 	display_size = 20;
[ 164] 0x900000001fc0f8e8:  ff b5 00 20 sd	s5,32(sp)
[ 164] 0x900000001fc0f8ec:  24 15 00 14 li	s5,20
  165: 	for (i = 0; i < 3; i++) {
[ 165] 0x900000001fc0f8f0:  ff b1 00 40 sd	s1,64(sp)
[ 165] 0x900000001fc0f8f4:  00 00 88 25 move	s1,zero
[ 165] 0x900000001fc0f8f8:  3c 01 90 00 lui	at,0x9000
[ 165] 0x900000001fc0f8fc:  60 21 00 00 daddi	at,at,0
[ 165] 0x900000001fc0f900:  3c 02 1f c2 lui	v0,0x1fc2
[ 165] 0x900000001fc0f904:  ff b3 00 30 sd	s3,48(sp)
[ 165] 0x900000001fc0f908:  60 42 d6 50 daddi	v0,v0,-10672
[ 165] 0x900000001fc0f90c:  00 01 08 3c dsll32	at,at,0
[ 165] 0x900000001fc0f910:  ff b2 00 38 sd	s2,56(sp)
[ 165] 0x900000001fc0f914:  24 12 00 54 li	s2,84
[ 165] 0x900000001fc0f918:  00 22 08 2c dadd	at,at,v0
[ 165] 0x900000001fc0f91c:  ff b0 00 48 sd	s0,72(sp)
[ 165] 0x900000001fc0f920:  24 13 00 45 li	s3,69
[ 165] 0x900000001fc0f924:  24 10 00 03 li	s0,3
[ 165] 0x900000001fc0f928:  ff a1 00 00 sd	at,0(sp)
[ 165] 0x900000001fc0f92c:  ff bf 00 50 sd	ra,80(sp)
  166: 		c = sysctlr_getpanel();
[ 166] 0x900000001fc0f930:  0f f0 11 c0 jal		sysctlr_getpanel
[ 166] 0x900000001fc0f934:  00 00 00 21 nada
  167: 		if (c == 'T') {
[ 167] 0x900000001fc0f938:  26 31 00 01 addiu	s1,s1,1
[ 167] 0x900000001fc0f93c:  30 59 00 ff andi	t9,v0,0xff
[ 167] 0x900000001fc0f940:  53 32 00 0a beql	t9,s2,0x900000001fc0f96c
[ 167] 0x900000001fc0f944:  24 15 00 28 li	s5,40
  168: 			display_size = 40;
  169: 			break;
  170: 		} else if (c == 'E') {
[ 170] 0x900000001fc0f948:  13 33 00 05 beq	t9,s3,0x900000001fc0f960
[ 170] 0x900000001fc0f94c:  00 00 00 21 nada
[ 165] 0x900000001fc0f950:  16 30 ff f7 bne	s1,s0,0x900000001fc0f930
[ 165] 0x900000001fc0f954:  00 00 00 21 nada
[ 165] 0x900000001fc0f958:  10 00 00 04 b		0x900000001fc0f96c
[ 165] 0x900000001fc0f95c:  00 00 00 21 nada
  171: 			display_size = 20;
[ 171] 0x900000001fc0f960:  10 00 00 02 b		0x900000001fc0f96c
[ 171] 0x900000001fc0f964:  24 15 00 14 li	s5,20
[ 168] 0x900000001fc0f968:  24 15 00 28 li	s5,40
  172: 			break;
  173: 		}
  174: 	}
  175: 
  176: 	ccuart_flush();
[ 176] 0x900000001fc0f96c:  0f f0 0c ea jal		ccuart_flush
[ 176] 0x900000001fc0f970:  00 00 00 21 nada
  177: 
  178: 	i = 0;
  179: 	while(get_char(message + i) != '\0')
[ 179] 0x900000001fc0f974:  03 c0 20 25 move	a0,s8
[ 178] 0x900000001fc0f978:  0f f0 0d 88 jal		get_char
[ 178] 0x900000001fc0f97c:  00 00 88 25 move	s1,zero
[ 178] 0x900000001fc0f980:  03 c0 80 25 move	s0,s8
[ 178] 0x900000001fc0f984:  50 40 00 08 beql	v0,zero,0x900000001fc0f9a8
[ 178] 0x900000001fc0f988:  26 30 ff ff addiu	s0,s1,-1
  180: 		i++;
[ 180] 0x900000001fc0f98c:  66 10 00 01 daddiu	s0,s0,1
[ 179] 0x900000001fc0f990:  0f f0 0d 88 jal		get_char
[ 179] 0x900000001fc0f994:  02 00 20 25 move	a0,s0
[ 179] 0x900000001fc0f998:  26 31 00 01 addiu	s1,s1,1
[ 179] 0x900000001fc0f99c:  54 40 ff fc bnel	v0,zero,0x900000001fc0f990
[ 179] 0x900000001fc0f9a0:  66 10 00 01 daddiu	s0,s0,1
  181: 	length = i - 1;
[ 181] 0x900000001fc0f9a4:  26 30 ff ff addiu	s0,s1,-1
  182: 	if (length < display_size) {
[ 182] 0x900000001fc0f9a8:  02 15 28 2a slt	a1,s0,s5
[ 182] 0x900000001fc0f9ac:  54 a0 00 3b bnel	a1,zero,0x900000001fc0fa9c
[ 182] 0x900000001fc0f9b0:  00 00 28 25 move	a1,zero
  183: 		i = 0;
  184: 		sysctlr_bootstat((char *)message, 0);
  185: 		while(!pod_poll() && ((reps == -1) || (i < reps * length))) {
  186: 			i++;
  187: 			delay(500000);
  188: 		}
  189: 		sysctlr_bootstat("", 1);
  190: 		return;
  191: 	}
  192: 
  193: 	i = 0;
[ 193] 0x900000001fc0f9b4:  0f f0 15 23 jal		pod_poll
[ 193] 0x900000001fc0f9b8:  00 00 88 25 move	s1,zero
[ 193] 0x900000001fc0f9bc:  67 b3 00 60 daddiu	s3,sp,96
[ 193] 0x900000001fc0f9c0:  ff b6 00 18 sd	s6,24(sp)
[ 193] 0x900000001fc0f9c4:  3c 06 00 06 lui	a2,0x6
[ 193] 0x900000001fc0f9c8:  02 b0 b0 21 addu	s6,s5,s0
[ 193] 0x900000001fc0f9cc:  ff b7 00 10 sd	s7,16(sp)
[ 193] 0x900000001fc0f9d0:  34 d7 1a 80 ori	s7,a2,0x1a80
[ 193] 0x900000001fc0f9d4:  54 40 00 26 bnel	v0,zero,0x900000001fc0fa70
[ 193] 0x900000001fc0f9d8:  df b7 00 10 ld	s7,16(sp)
[ 193] 0x900000001fc0f9dc:  52 80 00 24 beql	s4,zero,0x900000001fc0fa70
[ 193] 0x900000001fc0f9e0:  df b7 00 10 ld	s7,16(sp)
[ 193] 0x900000001fc0f9e4:  02 35 80 2a slt	s0,s1,s5
  194: 	while (!pod_poll() && (reps != 0)) {
  195: 		if (i < display_size) {
[ 195] 0x900000001fc0f9e8:  16 00 00 0b bne	s0,zero,0x900000001fc0fa18
[ 195] 0x900000001fc0f9ec:  02 d1 90 2a slt	s2,s6,s1
  196: 			lostrncpy(buffer, message, i);
  197: 			sysctlr_bootstat((char *)buffer, display_size - i);
  198: 		} else {
  199: 			lostrncpy(buffer, message + (i - display_size),
[ 199] 0x900000001fc0f9f0:  02 a0 30 25 move	a2,s5
[ 199] 0x900000001fc0f9f4:  02 60 20 25 move	a0,s3
[ 199] 0x900000001fc0f9f8:  02 35 38 23 subu	a3,s1,s5
[ 199] 0x900000001fc0f9fc:  0f f0 2d 15 jal		lostrncpy
[ 199] 0x900000001fc0fa00:  03 c7 28 2d daddu	a1,s8,a3
  200: 								display_size);
  201: 			sysctlr_bootstat((char *)buffer, 0);
[ 201] 0x900000001fc0fa04:  00 00 28 25 move	a1,zero
[ 201] 0x900000001fc0fa08:  0f f0 3e 16 jal		sysctlr_bootstat
[ 201] 0x900000001fc0fa0c:  02 60 20 25 move	a0,s3
[ 201] 0x900000001fc0fa10:  10 00 00 08 b		0x900000001fc0fa34
[ 201] 0x900000001fc0fa14:  00 00 00 21 nada
[ 196] 0x900000001fc0fa18:  02 20 30 25 move	a2,s1
[ 196] 0x900000001fc0fa1c:  03 c0 28 25 move	a1,s8
[ 196] 0x900000001fc0fa20:  0f f0 2d 15 jal		lostrncpy
[ 196] 0x900000001fc0fa24:  02 60 20 25 move	a0,s3
[ 197] 0x900000001fc0fa28:  02 b1 28 23 subu	a1,s5,s1
[ 197] 0x900000001fc0fa2c:  0f f0 3e 16 jal		sysctlr_bootstat
[ 197] 0x900000001fc0fa30:  02 60 20 25 move	a0,s3
  202: 		}
  203: 		if (i > (length + display_size)) {
[ 203] 0x900000001fc0fa34:  12 40 00 04 beq	s2,zero,0x900000001fc0fa48
[ 203] 0x900000001fc0fa38:  00 00 00 21 nada
  204: 			i = 0;
[ 204] 0x900000001fc0fa3c:  1a 80 00 02 blez	s4,0x900000001fc0fa48
[ 204] 0x900000001fc0fa40:  00 00 88 25 move	s1,zero
  205: 			if (reps > 0)
  206: 				reps--;
[ 206] 0x900000001fc0fa44:  26 94 ff ff addiu	s4,s4,-1
  207: 		}
  208: 		i++;
  209: 		delay(400000);
[ 209] 0x900000001fc0fa48:  0f f0 0d a4 jal		delay
[ 209] 0x900000001fc0fa4c:  02 e0 20 25 move	a0,s7
[ 194] 0x900000001fc0fa50:  0f f0 15 23 jal		pod_poll
[ 194] 0x900000001fc0fa54:  00 00 00 21 nada
[ 208] 0x900000001fc0fa58:  26 31 00 01 addiu	s1,s1,1
[ 208] 0x900000001fc0fa5c:  54 40 00 04 bnel	v0,zero,0x900000001fc0fa70
[ 208] 0x900000001fc0fa60:  df b7 00 10 ld	s7,16(sp)
[ 208] 0x900000001fc0fa64:  16 80 ff e0 bne	s4,zero,0x900000001fc0f9e8
[ 208] 0x900000001fc0fa68:  02 35 80 2a slt	s0,s1,s5
[ 208] 0x900000001fc0fa6c:  df b7 00 10 ld	s7,16(sp)
  210: 	}
  211: 	sysctlr_bootstat("", 1);
[ 211] 0x900000001fc0fa70:  24 05 00 01 li	a1,1
[ 211] 0x900000001fc0fa74:  df a8 00 00 ld	a4,0(sp)
[ 211] 0x900000001fc0fa78:  df b1 00 40 ld	s1,64(sp)
[ 211] 0x900000001fc0fa7c:  df b6 00 18 ld	s6,24(sp)
[ 211] 0x900000001fc0fa80:  0f f0 3e 16 jal		sysctlr_bootstat
[ 211] 0x900000001fc0fa84:  65 04 0c 0a daddiu	a0,a4,3082
  212: }
[ 212] 0x900000001fc0fa88:  df be 00 08 ld	s8,8(sp)
[ 212] 0x900000001fc0fa8c:  df b3 00 30 ld	s3,48(sp)
[ 212] 0x900000001fc0fa90:  10 00 00 25 b		0x900000001fc0fb28
[ 212] 0x900000001fc0fa94:  df bf 00 50 ld	ra,80(sp)
[ 184] 0x900000001fc0fa98:  00 00 28 25 move	a1,zero
[ 184] 0x900000001fc0fa9c:  0f f0 3e 16 jal		sysctlr_bootstat
[ 184] 0x900000001fc0faa0:  03 c0 20 25 move	a0,s8
[ 185] 0x900000001fc0faa4:  0f f0 15 23 jal		pod_poll
[ 185] 0x900000001fc0faa8:  00 00 00 21 nada
[ 185] 0x900000001fc0faac:  02 14 00 18 mult	s0,s4
[ 183] 0x900000001fc0fab0:  00 00 88 25 move	s1,zero
[ 183] 0x900000001fc0fab4:  24 12 ff ff li	s2,-1
[ 183] 0x900000001fc0fab8:  14 40 00 13 bne	v0,zero,0x900000001fc0fb08
[ 183] 0x900000001fc0fabc:  00 00 98 12 mflo	s3
[ 183] 0x900000001fc0fac0:  52 92 00 04 beql	s4,s2,0x900000001fc0fad4
[ 183] 0x900000001fc0fac4:  3c 09 00 07 lui	a5,0x7
[ 183] 0x900000001fc0fac8:  5a 60 00 10 blezl	s3,0x900000001fc0fb0c
[ 183] 0x900000001fc0facc:  df b1 00 40 ld	s1,64(sp)
[ 183] 0x900000001fc0fad0:  3c 09 00 07 lui	a5,0x7
[ 183] 0x900000001fc0fad4:  35 30 a1 20 ori	s0,a5,0xa120
[ 187] 0x900000001fc0fad8:  0f f0 0d a4 jal		delay
[ 187] 0x900000001fc0fadc:  02 00 20 25 move	a0,s0
[ 185] 0x900000001fc0fae0:  0f f0 15 23 jal		pod_poll
[ 185] 0x900000001fc0fae4:  00 00 00 21 nada
[ 186] 0x900000001fc0fae8:  26 31 00 01 addiu	s1,s1,1
[ 186] 0x900000001fc0faec:  54 40 00 07 bnel	v0,zero,0x900000001fc0fb0c
[ 186] 0x900000001fc0faf0:  df b1 00 40 ld	s1,64(sp)
[ 186] 0x900000001fc0faf4:  12 92 ff f8 beq	s4,s2,0x900000001fc0fad8
[ 186] 0x900000001fc0faf8:  00 00 00 21 nada
[ 186] 0x900000001fc0fafc:  02 33 50 2a slt	a6,s1,s3
[ 186] 0x900000001fc0fb00:  15 40 ff f5 bne	a6,zero,0x900000001fc0fad8
[ 186] 0x900000001fc0fb04:  00 00 00 21 nada
[ 186] 0x900000001fc0fb08:  df b1 00 40 ld	s1,64(sp)
[ 189] 0x900000001fc0fb0c:  24 05 00 01 li	a1,1
[ 189] 0x900000001fc0fb10:  df ab 00 00 ld	a7,0(sp)
[ 189] 0x900000001fc0fb14:  df be 00 08 ld	s8,8(sp)
[ 189] 0x900000001fc0fb18:  df b3 00 30 ld	s3,48(sp)
[ 189] 0x900000001fc0fb1c:  0f f0 3e 16 jal		sysctlr_bootstat
[ 189] 0x900000001fc0fb20:  65 64 0c 09 daddiu	a0,a7,3081
[ 190] 0x900000001fc0fb24:  df bf 00 50 ld	ra,80(sp)
[ 190] 0x900000001fc0fb28:  df b4 00 28 ld	s4,40(sp)
[ 190] 0x900000001fc0fb2c:  df b2 00 38 ld	s2,56(sp)
[ 190] 0x900000001fc0fb30:  df b0 00 48 ld	s0,72(sp)
[ 190] 0x900000001fc0fb34:  df b5 00 20 ld	s5,32(sp)
[ 190] 0x900000001fc0fb38:  03 e0 00 08 jr	ra
[ 190] 0x900000001fc0fb3c:  67 bd 00 b0 daddiu	sp,sp,176
  213: 
  214: 
  215: void code_msg(unsigned char diagcode, char *buffer)
  216: {
code_msg:
[ 216] 0x900000001fc0fb40:  67 bd ff d0 daddiu	sp,sp,-48
[ 216] 0x900000001fc0fb44:  ff b3 00 08 sd	s3,8(sp)
[ 216] 0x900000001fc0fb48:  00 80 98 25 move	s3,a0
  217:     unsigned char *cp;
  218:     int i;
  219: 
  220: 
  221:     if ((diagcode == EVDIAG_DEBUG) || (diagcode == EVDIAG_RETURNING)) {
[ 221] 0x900000001fc0fb4c:  ff b2 00 10 sd	s2,16(sp)
[ 221] 0x900000001fc0fb50:  00 a0 90 25 move	s2,a1
[ 221] 0x900000001fc0fb54:  24 01 00 fd li	at,253
[ 221] 0x900000001fc0fb58:  ff b0 00 20 sd	s0,32(sp)
[ 221] 0x900000001fc0fb5c:  24 10 00 fa li	s0,250
[ 221] 0x900000001fc0fb60:  ff bf 00 28 sd	ra,40(sp)
[ 221] 0x900000001fc0fb64:  52 61 00 32 beql	s3,at,0x900000001fc0fc30
[ 221] 0x900000001fc0fb68:  df b3 00 08 ld	s3,8(sp)
[ 221] 0x900000001fc0fb6c:  52 70 00 30 beql	s3,s0,0x900000001fc0fc30
[ 221] 0x900000001fc0fb70:  df b3 00 08 ld	s3,8(sp)
  222: 	buffer[0] = '\0';
  223: 	return;
  224:     }
  225: 
  226:     /*    012345678901234567890 */
  227:     cp = "Diagnostic code #";
[ 227] 0x900000001fc0fb74:  3c 02 90 00 lui	v0,0x9000
[ 227] 0x900000001fc0fb78:  60 42 00 00 daddi	v0,v0,0
[ 227] 0x900000001fc0fb7c:  3c 03 1f c2 lui	v1,0x1fc2
[ 227] 0x900000001fc0fb80:  60 63 e2 60 daddi	v1,v1,-7584
[ 227] 0x900000001fc0fb84:  00 02 10 3c dsll32	v0,v0,0
  228: 
  229:     for (i = 0; get_char(cp); i++)
[ 229] 0x900000001fc0fb88:  00 43 80 2c dadd	s0,v0,v1
[ 229] 0x900000001fc0fb8c:  0f f0 0d 88 jal		get_char
[ 229] 0x900000001fc0fb90:  02 00 20 25 move	a0,s0
[ 229] 0x900000001fc0fb94:  24 03 00 64 li	v1,100
[ 229] 0x900000001fc0fb98:  ff b1 00 18 sd	s1,24(sp)
[ 229] 0x900000001fc0fb9c:  02 40 88 25 move	s1,s2
[ 229] 0x900000001fc0fba0:  ff a3 00 00 sd	v1,0(sp)
[ 229] 0x900000001fc0fba4:  50 40 00 0b beql	v0,zero,0x900000001fc0fbd4
[ 229] 0x900000001fc0fba8:  df b1 00 18 ld	s1,24(sp)
  230: 	buffer[i] = get_char(cp++);
[ 230] 0x900000001fc0fbac:  0f f0 0d 88 jal		get_char
[ 230] 0x900000001fc0fbb0:  02 00 20 25 move	a0,s0
[ 230] 0x900000001fc0fbb4:  66 10 00 01 daddiu	s0,s0,1
[ 230] 0x900000001fc0fbb8:  a2 22 00 00 sb	v0,0(s1)
[ 229] 0x900000001fc0fbbc:  0f f0 0d 88 jal		get_char
[ 229] 0x900000001fc0fbc0:  02 00 20 25 move	a0,s0
[ 229] 0x900000001fc0fbc4:  66 31 00 01 daddiu	s1,s1,1
[ 229] 0x900000001fc0fbc8:  14 40 ff f8 bne	v0,zero,0x900000001fc0fbac
[ 229] 0x900000001fc0fbcc:  00 00 00 21 nada
[ 229] 0x900000001fc0fbd0:  df b1 00 18 ld	s1,24(sp)
  231:     buffer[17] = '0' + diagcode / 100;
[ 231] 0x900000001fc0fbd4:  df a5 00 00 ld	a1,0(sp)
[ 231] 0x900000001fc0fbd8:  02 65 00 1a div	s3,a1
  232:     buffer[18] = '0' + (diagcode / 10) % 10;
[ 232] 0x900000001fc0fbdc:  00 00 38 12 mflo	a3
[ 232] 0x900000001fc0fbe0:  24 05 00 0a li	a1,10
[ 232] 0x900000001fc0fbe4:  02 65 00 1a div	s3,a1
[ 232] 0x900000001fc0fbe8:  24 06 00 0a li	a2,10
[ 232] 0x900000001fc0fbec:  00 00 28 12 mflo	a1
[ 232] 0x900000001fc0fbf0:  00 a6 00 1a div	a1,a2
  233:     buffer[19] = '0' + (diagcode % 10);
[ 233] 0x900000001fc0fbf4:  00 00 28 10 mfhi	a1
[ 233] 0x900000001fc0fbf8:  24 06 00 0a li	a2,10
[ 233] 0x900000001fc0fbfc:  02 66 00 1a div	s3,a2
[ 233] 0x900000001fc0fc00:  df b3 00 08 ld	s3,8(sp)
  234: 
  235:     buffer[20] = '\0';
[ 235] 0x900000001fc0fc04:  a2 40 00 14 sb	zero,20(s2)
[ 235] 0x900000001fc0fc08:  24 e7 00 30 addiu	a3,a3,48
[ 235] 0x900000001fc0fc0c:  a2 47 00 11 sb	a3,17(s2)
[ 235] 0x900000001fc0fc10:  24 a6 00 30 addiu	a2,a1,48
[ 235] 0x900000001fc0fc14:  00 00 28 10 mfhi	a1
  236: }
[ 236] 0x900000001fc0fc18:  a2 46 00 12 sb	a2,18(s2)
[ 236] 0x900000001fc0fc1c:  24 a5 00 30 addiu	a1,a1,48
[ 236] 0x900000001fc0fc20:  a2 45 00 13 sb	a1,19(s2)
[ 236] 0x900000001fc0fc24:  10 00 00 04 b		0x900000001fc0fc38
[ 236] 0x900000001fc0fc28:  df bf 00 28 ld	ra,40(sp)
[ 236] 0x900000001fc0fc2c:  df b3 00 08 ld	s3,8(sp)
[ 222] 0x900000001fc0fc30:  a2 40 00 00 sb	zero,0(s2)
[ 223] 0x900000001fc0fc34:  df bf 00 28 ld	ra,40(sp)
[ 223] 0x900000001fc0fc38:  df b0 00 20 ld	s0,32(sp)
[ 223] 0x900000001fc0fc3c:  df b2 00 10 ld	s2,16(sp)
[ 223] 0x900000001fc0fc40:  03 e0 00 08 jr	ra
[ 223] 0x900000001fc0fc44:  67 bd 00 30 daddiu	sp,sp,48
  237: 
  238: int sc_disp(unsigned char diagcode)
  239: {
sc_disp:
[ 239] 0x900000001fc0fc48:  67 bd ff b0 daddiu	sp,sp,-80
  240:     int num_entries;
  241:     int i;
  242:     char buffer[21];
  243: 
  244: 
  245:     num_entries = sizeof(scmsg_map) / sizeof(pod_scmsg_t);
  246: 
  247:     for (i = 0; i < num_entries; i++) {
[ 247] 0x900000001fc0fc4c:  3c 01 90 00 lui	at,0x9000
[ 247] 0x900000001fc0fc50:  60 21 00 00 daddi	at,at,0
[ 247] 0x900000001fc0fc54:  3c 02 1f c2 lui	v0,0x1fc2
[ 247] 0x900000001fc0fc58:  60 42 d6 50 daddi	v0,v0,-10672
[ 247] 0x900000001fc0fc5c:  00 01 08 3c dsll32	at,at,0
[ 247] 0x900000001fc0fc60:  ff b3 00 20 sd	s3,32(sp)
[ 247] 0x900000001fc0fc64:  00 22 08 2c dadd	at,at,v0
[ 247] 0x900000001fc0fc68:  00 80 98 25 move	s3,a0
[ 247] 0x900000001fc0fc6c:  ff b1 00 30 sd	s1,48(sp)
[ 247] 0x900000001fc0fc70:  00 00 88 25 move	s1,zero
[ 247] 0x900000001fc0fc74:  ff a1 00 18 sd	at,24(sp)
[ 247] 0x900000001fc0fc78:  dc 21 0c 28 ld	at,3112(at)
[ 247] 0x900000001fc0fc7c:  ff b0 00 38 sd	s0,56(sp)
[ 247] 0x900000001fc0fc80:  64 30 09 c8 daddiu	s0,at,2504
[ 247] 0x900000001fc0fc84:  ff b2 00 28 sd	s2,40(sp)
[ 247] 0x900000001fc0fc88:  64 32 0f 80 daddiu	s2,at,3968
[ 247] 0x900000001fc0fc8c:  ff bf 00 40 sd	ra,64(sp)
  248: 	if (get_char(&scmsg_map[i].dv_code) == diagcode) {
[ 248] 0x900000001fc0fc90:  0f f0 0d 88 jal		get_char
[ 248] 0x900000001fc0fc94:  02 00 20 25 move	a0,s0
[ 248] 0x900000001fc0fc98:  66 10 00 18 daddiu	s0,s0,24
[ 248] 0x900000001fc0fc9c:  50 53 00 10 beql	v0,s3,0x900000001fc0fce0
[ 248] 0x900000001fc0fca0:  df b0 00 38 ld	s0,56(sp)
[ 247] 0x900000001fc0fca4:  16 12 ff fa bne	s0,s2,0x900000001fc0fc90
[ 247] 0x900000001fc0fca8:  66 31 00 18 daddiu	s1,s1,24
[ 247] 0x900000001fc0fcac:  67 a5 00 00 daddiu	a1,sp,0
[ 247] 0x900000001fc0fcb0:  df b0 00 38 ld	s0,56(sp)
  249: 	    sysctlr_message(scmsg_map[i].short_msg);
  250: 	    return 1;
  251: 	}
  252:     }
  253: 
  254:     code_msg(diagcode, buffer);
[ 254] 0x900000001fc0fcb4:  df b2 00 28 ld	s2,40(sp)
[ 254] 0x900000001fc0fcb8:  df b1 00 30 ld	s1,48(sp)
[ 254] 0x900000001fc0fcbc:  0f f0 3e d0 jal		code_msg
[ 254] 0x900000001fc0fcc0:  02 60 20 25 move	a0,s3
  255:     sysctlr_message(buffer);
[ 255] 0x900000001fc0fcc4:  df b3 00 20 ld	s3,32(sp)
[ 255] 0x900000001fc0fcc8:  0f f0 11 7c jal		sysctlr_message
[ 255] 0x900000001fc0fccc:  67 a4 00 00 daddiu	a0,sp,0
  256:     return 0;
[ 256] 0x900000001fc0fcd0:  00 00 10 25 move	v0,zero
[ 256] 0x900000001fc0fcd4:  10 00 00 0d b		0x900000001fc0fd0c
[ 256] 0x900000001fc0fcd8:  df bf 00 40 ld	ra,64(sp)
[ 256] 0x900000001fc0fcdc:  df b0 00 38 ld	s0,56(sp)
[ 256] 0x900000001fc0fce0:  df a6 00 18 ld	a2,24(sp)
[ 256] 0x900000001fc0fce4:  df b2 00 28 ld	s2,40(sp)
[ 256] 0x900000001fc0fce8:  df b3 00 20 ld	s3,32(sp)
[ 256] 0x900000001fc0fcec:  dc c6 0c 28 ld	a2,3112(a2)
[ 256] 0x900000001fc0fcf0:  64 c6 09 d0 daddiu	a2,a2,2512
[ 256] 0x900000001fc0fcf4:  02 26 30 2d daddu	a2,s1,a2
[ 256] 0x900000001fc0fcf8:  df b1 00 30 ld	s1,48(sp)
[ 249] 0x900000001fc0fcfc:  0f f0 11 7c jal		sysctlr_message
[ 249] 0x900000001fc0fd00:  dc c4 00 00 ld	a0,0(a2)
[ 250] 0x900000001fc0fd04:  df bf 00 40 ld	ra,64(sp)
[ 250] 0x900000001fc0fd08:  24 02 00 01 li	v0,1
[ 250] 0x900000001fc0fd0c:  03 e0 00 08 jr	ra
[ 250] 0x900000001fc0fd10:  67 bd 00 50 daddiu	sp,sp,80
  257: }
  258: 
  259: 
  260: unsigned char *get_long_scmsg(unsigned char diagcode)
  261: {
get_long_scmsg:
[ 261] 0x900000001fc0fd14:  67 bd ff d0 daddiu	sp,sp,-48
  262:     int num_entries;
  263:     int i;
  264: 
  265:     num_entries = sizeof(scmsg_map) / sizeof(pod_scmsg_t);
  266: 
  267:     for (i = 0; i < num_entries; i++) {
[ 267] 0x900000001fc0fd18:  3c 01 90 00 lui	at,0x9000
[ 267] 0x900000001fc0fd1c:  60 21 00 00 daddi	at,at,0
[ 267] 0x900000001fc0fd20:  3c 02 1f c2 lui	v0,0x1fc2
[ 267] 0x900000001fc0fd24:  60 42 d6 50 daddi	v0,v0,-10672
[ 267] 0x900000001fc0fd28:  00 01 08 3c dsll32	at,at,0
[ 267] 0x900000001fc0fd2c:  ff b2 00 10 sd	s2,16(sp)
[ 267] 0x900000001fc0fd30:  00 22 08 2c dadd	at,at,v0
[ 267] 0x900000001fc0fd34:  00 80 90 25 move	s2,a0
[ 267] 0x900000001fc0fd38:  ff b1 00 18 sd	s1,24(sp)
[ 267] 0x900000001fc0fd3c:  00 00 88 25 move	s1,zero
[ 267] 0x900000001fc0fd40:  ff a1 00 00 sd	at,0(sp)
[ 267] 0x900000001fc0fd44:  dc 21 0c 28 ld	at,3112(at)
[ 267] 0x900000001fc0fd48:  ff b0 00 20 sd	s0,32(sp)
[ 267] 0x900000001fc0fd4c:  64 30 09 c8 daddiu	s0,at,2504
[ 267] 0x900000001fc0fd50:  ff b3 00 08 sd	s3,8(sp)
[ 267] 0x900000001fc0fd54:  64 33 0f 80 daddiu	s3,at,3968
[ 267] 0x900000001fc0fd58:  ff bf 00 28 sd	ra,40(sp)
  268: 	if (get_char(&scmsg_map[i].dv_code) == diagcode) {
[ 268] 0x900000001fc0fd5c:  0f f0 0d 88 jal		get_char
[ 268] 0x900000001fc0fd60:  02 00 20 25 move	a0,s0
[ 268] 0x900000001fc0fd64:  66 10 00 18 daddiu	s0,s0,24
[ 268] 0x900000001fc0fd68:  50 52 00 06 beql	v0,s2,0x900000001fc0fd84
[ 268] 0x900000001fc0fd6c:  df a5 00 00 ld	a1,0(sp)
[ 267] 0x900000001fc0fd70:  16 13 ff fa bne	s0,s3,0x900000001fc0fd5c
[ 267] 0x900000001fc0fd74:  66 31 00 18 daddiu	s1,s1,24
  269: 	    return (unsigned char *)scmsg_map[i].long_msg;
  270: 	}
  271:     }
  272:     return (unsigned char *)NULL;
[ 272] 0x900000001fc0fd78:  10 00 00 06 b		0x900000001fc0fd94
[ 272] 0x900000001fc0fd7c:  00 00 10 25 move	v0,zero
[ 272] 0x900000001fc0fd80:  df a5 00 00 ld	a1,0(sp)
[ 272] 0x900000001fc0fd84:  dc a5 0c 28 ld	a1,3112(a1)
[ 272] 0x900000001fc0fd88:  64 a5 09 d8 daddiu	a1,a1,2520
[ 272] 0x900000001fc0fd8c:  02 25 28 2d daddu	a1,s1,a1
[ 272] 0x900000001fc0fd90:  dc a2 00 00 ld	v0,0(a1)
[ 269] 0x900000001fc0fd94:  df b0 00 20 ld	s0,32(sp)
[ 269] 0x900000001fc0fd98:  df b3 00 08 ld	s3,8(sp)
[ 269] 0x900000001fc0fd9c:  df bf 00 28 ld	ra,40(sp)
[ 269] 0x900000001fc0fda0:  df b1 00 18 ld	s1,24(sp)
[ 269] 0x900000001fc0fda4:  df b2 00 10 ld	s2,16(sp)
[ 269] 0x900000001fc0fda8:  03 e0 00 08 jr	ra
[ 269] 0x900000001fc0fdac:  67 bd 00 30 daddiu	sp,sp,48
  273: }
  274: 
  275: 
  276: char *get_diag_string(uint diagcode)
  277: {
get_diag_string:
[ 277] 0x900000001fc0fdb0:  67 bd ff d0 daddiu	sp,sp,-48
  278:     int num_entries;
  279:     int i;
  280: 
  281:     num_entries = sizeof(diagval_map) / sizeof(diagval_t);
  282: 
  283:     for (i = 0; i < num_entries; i++) {
[ 283] 0x900000001fc0fdb4:  3c 01 90 00 lui	at,0x9000
[ 283] 0x900000001fc0fdb8:  60 21 00 00 daddi	at,at,0
[ 283] 0x900000001fc0fdbc:  3c 02 1f c2 lui	v0,0x1fc2
[ 283] 0x900000001fc0fdc0:  60 42 d6 50 daddi	v0,v0,-10672
[ 283] 0x900000001fc0fdc4:  00 01 08 3c dsll32	at,at,0
[ 283] 0x900000001fc0fdc8:  ff b4 00 00 sd	s4,0(sp)
[ 283] 0x900000001fc0fdcc:  00 22 a0 2c dadd	s4,at,v0
[ 283] 0x900000001fc0fdd0:  30 83 00 ff andi	v1,a0,0xff
[ 283] 0x900000001fc0fdd4:  ff b1 00 18 sd	s1,24(sp)
[ 283] 0x900000001fc0fdd8:  00 00 88 25 move	s1,zero
[ 283] 0x900000001fc0fddc:  ff b2 00 10 sd	s2,16(sp)
[ 283] 0x900000001fc0fde0:  30 72 00 ff andi	s2,v1,0xff
[ 283] 0x900000001fc0fde4:  de 81 0c 28 ld	at,3112(s4)
[ 283] 0x900000001fc0fde8:  ff b0 00 20 sd	s0,32(sp)
[ 283] 0x900000001fc0fdec:  00 20 80 25 move	s0,at
[ 283] 0x900000001fc0fdf0:  ff b3 00 08 sd	s3,8(sp)
[ 283] 0x900000001fc0fdf4:  64 33 04 d0 daddiu	s3,at,1232
[ 283] 0x900000001fc0fdf8:  ff bf 00 28 sd	ra,40(sp)
  284: 	if (get_char(&diagval_map[i].dv_code) == EVDIAG_DIAGCODE(diagcode))
[ 284] 0x900000001fc0fdfc:  0f f0 0d 88 jal		get_char
[ 284] 0x900000001fc0fe00:  02 00 20 25 move	a0,s0
[ 284] 0x900000001fc0fe04:  66 10 00 10 daddiu	s0,s0,16
[ 284] 0x900000001fc0fe08:  52 42 00 06 beql	s2,v0,0x900000001fc0fe24
[ 284] 0x900000001fc0fe0c:  de 85 0c 28 ld	a1,3112(s4)
[ 283] 0x900000001fc0fe10:  16 13 ff fa bne	s0,s3,0x900000001fc0fdfc
[ 283] 0x900000001fc0fe14:  66 31 00 10 daddiu	s1,s1,16
  285: 	    return diagval_map[i].dv_msg;
  286:     }
  287: #ifdef DEBUG
  288:     loprintf("diagcode = %d\n", diagcode);
  289: #endif 
  290:     return "<check evdiag.h> ";
[ 290] 0x900000001fc0fe18:  10 00 00 05 b		0x900000001fc0fe30
[ 290] 0x900000001fc0fe1c:  66 82 0c 30 daddiu	v0,s4,3120
[ 290] 0x900000001fc0fe20:  de 85 0c 28 ld	a1,3112(s4)
[ 290] 0x900000001fc0fe24:  64 a5 00 08 daddiu	a1,a1,8
[ 290] 0x900000001fc0fe28:  02 25 28 2d daddu	a1,s1,a1
[ 290] 0x900000001fc0fe2c:  dc a2 00 00 ld	v0,0(a1)
[ 285] 0x900000001fc0fe30:  df b1 00 18 ld	s1,24(sp)
[ 285] 0x900000001fc0fe34:  df b4 00 00 ld	s4,0(sp)
[ 285] 0x900000001fc0fe38:  df bf 00 28 ld	ra,40(sp)
[ 285] 0x900000001fc0fe3c:  df b2 00 10 ld	s2,16(sp)
[ 285] 0x900000001fc0fe40:  df b0 00 20 ld	s0,32(sp)
[ 285] 0x900000001fc0fe44:  df b3 00 08 ld	s3,8(sp)
[ 285] 0x900000001fc0fe48:  03 e0 00 08 jr	ra
[ 285] 0x900000001fc0fe4c:  67 bd 00 30 daddiu	sp,sp,48
  291: }
  292: 
  293: 
  294: void scroll_n_print(unsigned char diagcode)
  295: {
scroll_n_print:
[ 295] 0x900000001fc0fe50:  67 bd ff c0 daddiu	sp,sp,-64
  296:     unsigned char *cp;
  297:     unsigned char buffer[21];
  298: 
  299:     if ((cp = get_long_scmsg(diagcode))) {
[ 299] 0x900000001fc0fe54:  ff b2 00 28 sd	s2,40(sp)
[ 299] 0x900000001fc0fe58:  ff bf 00 18 sd	ra,24(sp)
[ 299] 0x900000001fc0fe5c:  0f f0 3f 45 jal		get_long_scmsg
[ 299] 0x900000001fc0fe60:  00 80 90 25 move	s2,a0
[ 299] 0x900000001fc0fe64:  ff b1 00 30 sd	s1,48(sp)
[ 299] 0x900000001fc0fe68:  00 40 88 25 move	s1,v0
[ 299] 0x900000001fc0fe6c:  ff b3 00 20 sd	s3,32(sp)
[ 299] 0x900000001fc0fe70:  67 b3 00 00 daddiu	s3,sp,0
[ 299] 0x900000001fc0fe74:  ff b0 00 38 sd	s0,56(sp)
[ 299] 0x900000001fc0fe78:  52 20 00 19 beql	s1,zero,0x900000001fc0fee0
[ 299] 0x900000001fc0fe7c:  df b0 00 38 ld	s0,56(sp)
  300: 	while (!pod_poll()) {
[ 300] 0x900000001fc0fe80:  0f f0 15 23 jal		pod_poll
[ 300] 0x900000001fc0fe84:  00 00 00 21 nada
[ 300] 0x900000001fc0fe88:  24 10 00 01 li	s0,1
[ 300] 0x900000001fc0fe8c:  54 40 00 14 bnel	v0,zero,0x900000001fc0fee0
[ 300] 0x900000001fc0fe90:  df b0 00 38 ld	s0,56(sp)
[ 300] 0x900000001fc0fe94:  02 00 28 25 move	a1,s0
  301: 	    scroll_message(cp, 1);
[ 301] 0x900000001fc0fe98:  0f f0 3e 35 jal		scroll_message
[ 301] 0x900000001fc0fe9c:  02 20 20 25 move	a0,s1
  302: 	    if (!pod_poll()) {
[ 302] 0x900000001fc0fea0:  0f f0 15 23 jal		pod_poll
[ 302] 0x900000001fc0fea4:  00 00 00 21 nada
[ 302] 0x900000001fc0fea8:  02 60 28 25 move	a1,s3
[ 302] 0x900000001fc0feac:  14 40 00 06 bne	v0,zero,0x900000001fc0fec8
[ 302] 0x900000001fc0feb0:  00 00 00 21 nada
  303: 		    code_msg(diagcode, (char *)buffer);
[ 303] 0x900000001fc0feb4:  0f f0 3e d0 jal		code_msg
[ 303] 0x900000001fc0feb8:  02 40 20 25 move	a0,s2
  304: 		    scroll_message(buffer, 1);
[ 304] 0x900000001fc0febc:  02 00 28 25 move	a1,s0
[ 304] 0x900000001fc0fec0:  0f f0 3e 35 jal		scroll_message
[ 304] 0x900000001fc0fec4:  02 60 20 25 move	a0,s3
[ 300] 0x900000001fc0fec8:  0f f0 15 23 jal		pod_poll
[ 300] 0x900000001fc0fecc:  00 00 00 21 nada
[ 300] 0x900000001fc0fed0:  02 00 28 25 move	a1,s0
[ 300] 0x900000001fc0fed4:  10 40 ff f0 beq	v0,zero,0x900000001fc0fe98
[ 300] 0x900000001fc0fed8:  00 00 00 21 nada
[ 300] 0x900000001fc0fedc:  df b0 00 38 ld	s0,56(sp)
[ 300] 0x900000001fc0fee0:  df b1 00 30 ld	s1,48(sp)
  305: 	    }
  306: 	}
  307:     }
  308: 
  309:     code_msg(diagcode, (char *)buffer);
[ 309] 0x900000001fc0fee4:  02 60 28 25 move	a1,s3
[ 309] 0x900000001fc0fee8:  0f f0 3e d0 jal		code_msg
[ 309] 0x900000001fc0feec:  02 40 20 25 move	a0,s2
  310:     sysctlr_bootstat((char *)buffer, 0);
[ 310] 0x900000001fc0fef0:  df b2 00 28 ld	s2,40(sp)
[ 310] 0x900000001fc0fef4:  00 00 28 25 move	a1,zero
[ 310] 0x900000001fc0fef8:  0f f0 3e 16 jal		sysctlr_bootstat
[ 310] 0x900000001fc0fefc:  02 60 20 25 move	a0,s3
  311: }
[ 311] 0x900000001fc0ff00:  df b3 00 20 ld	s3,32(sp)
[ 311] 0x900000001fc0ff04:  df bf 00 18 ld	ra,24(sp)
[ 311] 0x900000001fc0ff08:  03 e0 00 08 jr	ra
[ 311] 0x900000001fc0ff0c:  67 bd 00 40 daddiu	sp,sp,64
Skipping source listing to line 28 of /cores/banyan/stand/arcs/IP25prom/pod_mem.c...
   29: 	num_banks:	number of banks in thr configuration array
   30: 	banks:	 	bank configuration information
   31: 	mem_size:	total configured memory size in blocs
   32:    Returns:
   33: 	0 on success
   34: 	nonzero on address line failure
   35: */
   36: 
   37: int pod_check_mem(uint mem_size)
   38: {
pod_check_mem:
[  38] 0x900000001fc0ff10:  67 bd ff f0 daddiu	sp,sp,-16
   39: 	int status;
   40: 
   41: 	if (status = pod_address_test(mem_size))
[  41] 0x900000001fc0ff14:  ff bf 00 00 sd	ra,0(sp)
[  41] 0x900000001fc0ff18:  0f f0 3f d1 jal		pod_address_test
[  41] 0x900000001fc0ff1c:  00 00 00 21 nada
   42: 		return status;
[  42] 0x900000001fc0ff20:  df bf 00 00 ld	ra,0(sp)
[  42] 0x900000001fc0ff24:  00 40 08 25 move	at,v0
[  42] 0x900000001fc0ff28:  00 02 08 0a movz	at,zero,v0
[  42] 0x900000001fc0ff2c:  00 00 00 21 nada
[  42] 0x900000001fc0ff30:  00 00 00 21 nada
[  42] 0x900000001fc0ff34:  00 00 00 21 nada
[  42] 0x900000001fc0ff38:  00 20 10 25 move	v0,at
   43: 	return 0;
[  43] 0x900000001fc0ff3c:  03 e0 00 08 jr	ra
[  43] 0x900000001fc0ff40:  67 bd 00 10 daddiu	sp,sp,16
   44: }
   45: 
   46: /* pod_address_test - Check all of the address bits up to mem_size.
   47:  *	mem_size = memory size in blocs.
   48:  *	returns the address line at which comparison failed or zero.
   49:  */ 
   50: static int pod_address_test(uint mem_size)
   51: {
pod_address_test:
[  51] 0x900000001fc0ff44:  67 bd ff c0 daddiu	sp,sp,-64
[  51] 0x900000001fc0ff48:  ff b6 00 00 sd	s6,0(sp)
[  51] 0x900000001fc0ff4c:  00 80 b0 25 move	s6,a0
   52: 	uint count, test;	/* Correspond to address lines */
   53: 	uint addr;		/* Bloc address */
   54: 
   55: 	for (count = 3; count < 8; count++)
[  55] 0x900000001fc0ff50:  ff b1 00 28 sd	s1,40(sp)
[  55] 0x900000001fc0ff54:  24 11 00 03 li	s1,3
[  55] 0x900000001fc0ff58:  ff b2 00 20 sd	s2,32(sp)
[  55] 0x900000001fc0ff5c:  24 12 00 40 li	s2,64
[  55] 0x900000001fc0ff60:  ff b4 00 10 sd	s4,16(sp)
[  55] 0x900000001fc0ff64:  24 14 00 01 li	s4,1
[  55] 0x900000001fc0ff68:  ff b0 00 30 sd	s0,48(sp)
[  55] 0x900000001fc0ff6c:  24 10 00 08 li	s0,8
[  55] 0x900000001fc0ff70:  ff bf 00 38 sd	ra,56(sp)
[  55] 0x900000001fc0ff74:  02 34 28 04 sllv	a1,s4,s1
   56: 		u64sw(POD_BASE_BLOC, (1 << count), count);
[  56] 0x900000001fc0ff78:  02 20 30 25 move	a2,s1
[  56] 0x900000001fc0ff7c:  0f f0 0d c2 jal		u64sw
[  56] 0x900000001fc0ff80:  02 40 20 25 move	a0,s2
[  55] 0x900000001fc0ff84:  26 31 00 01 addiu	s1,s1,1
[  55] 0x900000001fc0ff88:  56 30 ff fb bnel	s1,s0,0x900000001fc0ff78
[  55] 0x900000001fc0ff8c:  02 34 28 04 sllv	a1,s4,s1
[  55] 0x900000001fc0ff90:  02 20 30 25 move	a2,s1
[  55] 0x900000001fc0ff94:  00 00 28 25 move	a1,zero
[  55] 0x900000001fc0ff98:  02 96 80 2b sltu	s0,s4,s6
   57: 	for (addr = 0x1; addr < mem_size; count++) {
[  57] 0x900000001fc0ff9c:  ff b3 00 18 sd	s3,24(sp)
[  57] 0x900000001fc0ffa0:  02 80 98 25 move	s3,s4
[  57] 0x900000001fc0ffa4:  ff b5 00 08 sd	s5,8(sp)
[  57] 0x900000001fc0ffa8:  12 00 00 0a beq	s0,zero,0x900000001fc0ffd4
[  57] 0x900000001fc0ffac:  24 15 00 08 li	s5,8
   58: 		u64sw(addr + POD_BASE_BLOC, 0, count);
[  58] 0x900000001fc0ffb0:  0f f0 0d c2 jal		u64sw
[  58] 0x900000001fc0ffb4:  26 64 00 40 addiu	a0,s3,64
   59: 			/* POD_BASE_BLOC is the base memory address in blocs */
   60: 		addr = 1 << (count - 7);
[  60] 0x900000001fc0ffb8:  00 00 28 25 move	a1,zero
[  60] 0x900000001fc0ffbc:  26 27 ff f9 addiu	a3,s1,-7
[  60] 0x900000001fc0ffc0:  26 31 00 01 addiu	s1,s1,1
[  60] 0x900000001fc0ffc4:  00 f4 98 04 sllv	s3,s4,a3
[  57] 0x900000001fc0ffc8:  02 76 38 2b sltu	a3,s3,s6
[  57] 0x900000001fc0ffcc:  14 e0 ff f8 bne	a3,zero,0x900000001fc0ffb0
[  57] 0x900000001fc0ffd0:  02 20 30 25 move	a2,s1
[  57] 0x900000001fc0ffd4:  02 40 20 25 move	a0,s2
   61: 	}
   62: 
   63: 	for (count = 3; count < 8; count++) {
[  63] 0x900000001fc0ffd8:  24 11 00 03 li	s1,3
[  63] 0x900000001fc0ffdc:  02 34 80 04 sllv	s0,s4,s1
   64: 		test = u64lw(POD_BASE_BLOC, 1 << count);
[  64] 0x900000001fc0ffe0:  0f f0 0d b4 jal		u64lw
[  64] 0x900000001fc0ffe4:  02 00 28 25 move	a1,s0
   65: 		if (count != test) {
[  65] 0x900000001fc0ffe8:  02 00 28 25 move	a1,s0
[  65] 0x900000001fc0ffec:  00 00 30 25 move	a2,zero
[  65] 0x900000001fc0fff0:  56 22 00 22 bnel	s1,v0,0x900000001fc1007c
[  65] 0x900000001fc0fff4:  df b6 00 00 ld	s6,0(sp)
   66: 			return count;
   67: 		}
   68: 		u64sw(POD_BASE_BLOC, 1 << count, 0);
[  68] 0x900000001fc0fff8:  0f f0 0d c2 jal		u64sw
[  68] 0x900000001fc0fffc:  02 40 20 25 move	a0,s2
[  63] 0x900000001fc10000:  02 40 20 25 move	a0,s2
[  63] 0x900000001fc10004:  26 31 00 01 addiu	s1,s1,1
[  63] 0x900000001fc10008:  56 35 ff f5 bnel	s1,s5,0x900000001fc0ffe0
[  63] 0x900000001fc1000c:  02 34 80 04 sllv	s0,s4,s1
[  63] 0x900000001fc10010:  00 00 28 25 move	a1,zero
   69: 	}
   70: 	for (addr = 0x1; addr < mem_size; count++) {
[  70] 0x900000001fc10014:  02 96 80 2b sltu	s0,s4,s6
[  70] 0x900000001fc10018:  12 00 00 0f beq	s0,zero,0x900000001fc10058
[  70] 0x900000001fc1001c:  02 80 98 25 move	s3,s4
   71: 		test = u64lw(addr + POD_BASE_BLOC, 0);
[  71] 0x900000001fc10020:  0f f0 0d b4 jal		u64lw
[  71] 0x900000001fc10024:  26 64 00 40 addiu	a0,s3,64
   72: 		if (count != test) {
[  72] 0x900000001fc10028:  00 00 28 25 move	a1,zero
[  72] 0x900000001fc1002c:  00 00 30 25 move	a2,zero
[  72] 0x900000001fc10030:  16 22 00 0d bne	s1,v0,0x900000001fc10068
[  72] 0x900000001fc10034:  26 70 00 40 addiu	s0,s3,64
   73: 			return count;
   74: 		}
   75: 		u64sw(addr + POD_BASE_BLOC, 0, 0);
[  75] 0x900000001fc10038:  0f f0 0d c2 jal		u64sw
[  75] 0x900000001fc1003c:  02 00 20 25 move	a0,s0
   76: 		addr = 1 << (count - 7);
[  76] 0x900000001fc10040:  26 28 ff f9 addiu	a4,s1,-7
[  76] 0x900000001fc10044:  26 31 00 01 addiu	s1,s1,1
[  76] 0x900000001fc10048:  01 14 98 04 sllv	s3,s4,a4
[  70] 0x900000001fc1004c:  02 76 40 2b sltu	a4,s3,s6
[  70] 0x900000001fc10050:  15 00 ff f3 bne	a4,zero,0x900000001fc10020
[  70] 0x900000001fc10054:  00 00 28 25 move	a1,zero
[  70] 0x900000001fc10058:  df b6 00 00 ld	s6,0(sp)
[  70] 0x900000001fc1005c:  df b3 00 18 ld	s3,24(sp)
   77: 	}
   78: 
   79: 	return 0;
[  79] 0x900000001fc10060:  10 00 00 08 b		0x900000001fc10084
[  79] 0x900000001fc10064:  00 00 10 25 move	v0,zero
[  79] 0x900000001fc10068:  df b6 00 00 ld	s6,0(sp)
[  79] 0x900000001fc1006c:  df b3 00 18 ld	s3,24(sp)
[  73] 0x900000001fc10070:  10 00 00 04 b		0x900000001fc10084
[  73] 0x900000001fc10074:  02 20 10 25 move	v0,s1
[  73] 0x900000001fc10078:  df b6 00 00 ld	s6,0(sp)
[  73] 0x900000001fc1007c:  df b3 00 18 ld	s3,24(sp)
[  66] 0x900000001fc10080:  02 20 10 25 move	v0,s1
[  66] 0x900000001fc10084:  df b1 00 28 ld	s1,40(sp)
[  66] 0x900000001fc10088:  df bf 00 38 ld	ra,56(sp)
[  66] 0x900000001fc1008c:  df b4 00 10 ld	s4,16(sp)
[  66] 0x900000001fc10090:  df b2 00 20 ld	s2,32(sp)
[  66] 0x900000001fc10094:  df b0 00 30 ld	s0,48(sp)
[  66] 0x900000001fc10098:  df b5 00 08 ld	s5,8(sp)
[  66] 0x900000001fc1009c:  03 e0 00 08 jr	ra
[  66] 0x900000001fc100a0:  67 bd 00 40 daddiu	sp,sp,64
   80: }
   81: 
   82: 
   83: int pod_walk(__psunsigned_t lo, __psunsigned_t hi, int cont)
   84: {
pod_walk:
[  84] 0x900000001fc100a4:  67 bd ff 90 daddiu	sp,sp,-112
[  84] 0x900000001fc100a8:  ff b0 00 58 sd	s0,88(sp)
[  84] 0x900000001fc100ac:  00 80 80 25 move	s0,a0
[  84] 0x900000001fc100b0:  ff b2 00 48 sd	s2,72(sp)
[  84] 0x900000001fc100b4:  00 a0 90 25 move	s2,a1
[  84] 0x900000001fc100b8:  3c 05 1f ff lui	a1,0x1fff
[  84] 0x900000001fc100bc:  34 a5 ff ff ori	a1,a1,0xffff
[  84] 0x900000001fc100c0:  ff b5 00 30 sd	s5,48(sp)
   85:     __psunsigned_t addr;
   86:     uint data, read_val;
   87:     char key;
   88:     uint failures = 0;
   89: 
   90:     if (lo & 3) {
[  90] 0x900000001fc100c4:  3c 01 90 00 lui	at,0x9000
[  90] 0x900000001fc100c8:  ff b1 00 50 sd	s1,80(sp)
[  90] 0x900000001fc100cc:  3c 02 1f c2 lui	v0,0x1fc2
[  90] 0x900000001fc100d0:  60 21 00 00 daddi	at,at,0
[  90] 0x900000001fc100d4:  60 43 e2 98 daddi	v1,v0,-7528
[  90] 0x900000001fc100d8:  00 01 10 3c dsll32	v0,at,0
[  90] 0x900000001fc100dc:  32 01 00 03 andi	at,s0,0x3
[  90] 0x900000001fc100e0:  ff b4 00 38 sd	s4,56(sp)
[  90] 0x900000001fc100e4:  00 43 a0 2c dadd	s4,v0,v1
[  90] 0x900000001fc100e8:  14 20 00 6e bne	at,zero,0x900000001fc102a4
[  90] 0x900000001fc100ec:  ff be 00 18 sd	s8,24(sp)
[  90] 0x900000001fc100f0:  ff b6 00 28 sd	s6,40(sp)
   91: 	loprintf("*** The address must be word aligned! \n");
   92: 	return EVDIAG_TBD;
   93:     }
   94: 
   95:     lo &= 0x1fffffff;
   96:     hi &= 0x1fffffff;
   97:     lo = PHYS_TO_K1(lo);
   98:     hi = PHYS_TO_K1(hi);
   99:     loprintf("Converting to uncached, unmapped addresses (%x to %x)\n", lo, hi);
[  99] 0x900000001fc100f4:  66 84 00 28 daddiu	a0,s4,40
[  99] 0x900000001fc100f8:  00 c0 a8 25 move	s5,a2
[  99] 0x900000001fc100fc:  ff b7 00 20 sd	s7,32(sp)
[  97] 0x900000001fc10100:  02 05 38 24 and	a3,s0,a1
[  97] 0x900000001fc10104:  02 45 28 24 and	a1,s2,a1
[  97] 0x900000001fc10108:  de 86 01 28 ld	a2,296(s4)
[  98] 0x900000001fc1010c:  00 e6 88 25 or	s1,a3,a2
[  98] 0x900000001fc10110:  00 a6 f0 25 or	s8,a1,a2
[  98] 0x900000001fc10114:  32 30 0f ff andi	s0,s1,0xfff
[  98] 0x900000001fc10118:  03 c0 30 25 move	a2,s8
[  98] 0x900000001fc1011c:  ff bf 00 60 sd	ra,96(sp)
[  98] 0x900000001fc10120:  0f f0 2c e3 jal		loprintf
[  98] 0x900000001fc10124:  02 20 28 25 move	a1,s1
  100: 
  101:     for (addr = lo; addr < hi; addr += 4) {
[ 101] 0x900000001fc10128:  ff b3 00 40 sd	s3,64(sp)
[ 101] 0x900000001fc1012c:  ff b4 00 00 sd	s4,0(sp)
[ 101] 0x900000001fc10130:  df aa 00 00 ld	a6,0(sp)
[ 101] 0x900000001fc10134:  02 3e 20 2b sltu	a0,s1,s8
[ 101] 0x900000001fc10138:  00 00 98 25 move	s3,zero
[ 101] 0x900000001fc1013c:  50 80 00 3d beql	a0,zero,0x900000001fc10234
[ 101] 0x900000001fc10140:  df b0 00 00 ld	s0,0(sp)
[ 101] 0x900000001fc10144:  24 16 00 71 li	s6,113
[ 101] 0x900000001fc10148:  65 49 00 60 daddiu	a5,a6,96
[ 101] 0x900000001fc1014c:  65 48 00 70 daddiu	a4,a6,112
[ 101] 0x900000001fc10150:  ff a9 00 08 sd	a5,8(sp)
[ 101] 0x900000001fc10154:  65 54 00 98 daddiu	s4,a6,152
[ 101] 0x900000001fc10158:  65 57 00 c0 daddiu	s7,a6,192
[ 101] 0x900000001fc1015c:  ff a8 00 10 sd	a4,16(sp)
  102: 	if (!(addr & 0x0fff)) {
[ 102] 0x900000001fc10160:  56 00 00 12 bnel	s0,zero,0x900000001fc101ac
[ 102] 0x900000001fc10164:  3c 0c 1f ff lui	t0,0x1fff
  103: 		loprintf("Testing %x...\r", addr);
[ 103] 0x900000001fc10168:  02 20 28 25 move	a1,s1
[ 103] 0x900000001fc1016c:  0f f0 2c e3 jal		loprintf
[ 103] 0x900000001fc10170:  df a4 00 08 ld	a0,8(sp)
  104: 		if (pod_poll()) {
[ 104] 0x900000001fc10174:  0f f0 15 23 jal		pod_poll
[ 104] 0x900000001fc10178:  00 00 00 21 nada
[ 104] 0x900000001fc1017c:  50 40 00 0b beql	v0,zero,0x900000001fc101ac
[ 104] 0x900000001fc10180:  3c 0c 1f ff lui	t0,0x1fff
  105: 			pod_getc();
[ 105] 0x900000001fc10184:  0f f0 15 0b jal		pod_getc
[ 105] 0x900000001fc10188:  00 00 00 21 nada
  106: 			loprintf("Hit q to quit, other key to continue\n");
[ 106] 0x900000001fc1018c:  0f f0 2c e3 jal		loprintf
[ 106] 0x900000001fc10190:  df a4 00 10 ld	a0,16(sp)
  107: 			key = pod_getc();
[ 107] 0x900000001fc10194:  0f f0 15 0b jal		pod_getc
[ 107] 0x900000001fc10198:  00 00 00 21 nada
  108: 			if (key == 'q')
[ 108] 0x900000001fc1019c:  30 4b 00 ff andi	a7,v0,0xff
[ 108] 0x900000001fc101a0:  51 76 00 3b beql	a7,s6,0x900000001fc10290
[ 108] 0x900000001fc101a4:  00 00 10 25 move	v0,zero
  109: 				return 0;
  110: 		}
  111: 	}
  112: 	data = 0x80000000U;			/* Bit 31 == 1 */
  113: 	while (data != 0) {
[ 113] 0x900000001fc101a8:  3c 0c 1f ff lui	t0,0x1fff
[ 113] 0x900000001fc101ac:  35 8c ff ff ori	t0,t0,0xffff
[ 113] 0x900000001fc101b0:  02 2c 60 24 and	t0,s1,t0
[ 112] 0x900000001fc101b4:  3c 10 80 00 lui	s0,0x8000
[ 112] 0x900000001fc101b8:  00 0c 90 00 sll	s2,t0,0
[ 112] 0x900000001fc101bc:  02 20 28 25 move	a1,s1
[ 112] 0x900000001fc101c0:  02 00 30 25 move	a2,s0
  114: 	    SW(addr, data);
[ 114] 0x900000001fc101c4:  ae 30 00 00 sw	s0,0(s1)
  115: 	    read_val = LWU(addr);
[ 115] 0x900000001fc101c8:  8e 2d 00 00 lw	t1,0(s1)
  116: 
  117: 	    if (read_val != data) {
[ 117] 0x900000001fc101cc:  12 0d 00 0f beq	s0,t1,0x900000001fc1020c
[ 117] 0x900000001fc101d0:  01 a0 38 25 move	a3,t1
  118: 		loprintf("Addr 0x%x: wrote 0x%x, read 0x%x\n", addr, data,
[ 118] 0x900000001fc101d4:  0f f0 2c e3 jal		loprintf
[ 118] 0x900000001fc101d8:  02 80 20 25 move	a0,s4
  119: 								read_val);
  120: 		failures++;
  121: 		decode_address(addr & 0x1fffffff);
[ 121] 0x900000001fc101dc:  26 73 00 01 addiu	s3,s3,1
[ 121] 0x900000001fc101e0:  0f f0 42 2c jal		decode_address
[ 121] 0x900000001fc101e4:  02 40 20 25 move	a0,s2
  122: 		if (!cont) {
[ 122] 0x900000001fc101e8:  56 a0 00 09 bnel	s5,zero,0x900000001fc10210
[ 122] 0x900000001fc101ec:  00 10 80 42 srl	s0,s0,1
  123: 			loprintf("Hit y to continue, other key to quit\n");
[ 123] 0x900000001fc101f0:  0f f0 2c e3 jal		loprintf
[ 123] 0x900000001fc101f4:  02 e0 20 25 move	a0,s7
  124: 			key = pod_getc();
[ 124] 0x900000001fc101f8:  0f f0 15 0b jal		pod_getc
[ 124] 0x900000001fc101fc:  00 00 00 21 nada
  125: 			if (key == 'q')
[ 125] 0x900000001fc10200:  30 4e 00 ff andi	t2,v0,0xff
[ 125] 0x900000001fc10204:  51 d6 00 1c beql	t2,s6,0x900000001fc10278
[ 125] 0x900000001fc10208:  24 02 00 fd li	v0,253
  126: 			    return EVDIAG_TBD;
  127: 		}
  128: 	    } /* if read_val */
  129: 	    data >>= 1;
[ 129] 0x900000001fc1020c:  00 10 80 42 srl	s0,s0,1
[ 113] 0x900000001fc10210:  56 00 ff eb bnel	s0,zero,0x900000001fc101c0
[ 113] 0x900000001fc10214:  02 20 28 25 move	a1,s1
[ 101] 0x900000001fc10218:  66 31 00 04 daddiu	s1,s1,4
[ 101] 0x900000001fc1021c:  02 3e 78 2b sltu	t3,s1,s8
[ 101] 0x900000001fc10220:  15 e0 ff cf bne	t3,zero,0x900000001fc10160
[ 101] 0x900000001fc10224:  32 30 0f ff andi	s0,s1,0xfff
[ 101] 0x900000001fc10228:  df b6 00 28 ld	s6,40(sp)
[ 101] 0x900000001fc1022c:  df b7 00 20 ld	s7,32(sp)
[ 101] 0x900000001fc10230:  df b0 00 00 ld	s0,0(sp)
  130: 	} /* while data */
  131:     } /* for addr */
  132: 
  133:     if (failures) {
[ 133] 0x900000001fc10234:  56 60 00 08 bnel	s3,zero,0x900000001fc10258
[ 133] 0x900000001fc10238:  df be 00 18 ld	s8,24(sp)
  134: 	loprintf("\n*** Detected %d failures.\n", failures);
  135: 	return EVDIAG_TBD;
  136:     } else {
  137: 	loprintf("Test Passed.               \n");
[ 137] 0x900000001fc1023c:  df be 00 18 ld	s8,24(sp)
[ 137] 0x900000001fc10240:  0f f0 2c e3 jal		loprintf
[ 137] 0x900000001fc10244:  66 04 01 08 daddiu	a0,s0,264
  138: 	return 0;
[ 138] 0x900000001fc10248:  00 00 10 25 move	v0,zero
[ 138] 0x900000001fc1024c:  10 00 00 1a b		0x900000001fc102b8
[ 138] 0x900000001fc10250:  df b1 00 50 ld	s1,80(sp)
[ 138] 0x900000001fc10254:  df be 00 18 ld	s8,24(sp)
[ 134] 0x900000001fc10258:  02 60 28 25 move	a1,s3
[ 134] 0x900000001fc1025c:  df b1 00 00 ld	s1,0(sp)
[ 134] 0x900000001fc10260:  0f f0 2c e3 jal		loprintf
[ 134] 0x900000001fc10264:  66 24 00 e8 daddiu	a0,s1,232
[ 135] 0x900000001fc10268:  df b1 00 50 ld	s1,80(sp)
[ 135] 0x900000001fc1026c:  10 00 00 12 b		0x900000001fc102b8
[ 135] 0x900000001fc10270:  24 02 00 fd li	v0,253
[ 135] 0x900000001fc10274:  24 02 00 fd li	v0,253
[ 135] 0x900000001fc10278:  df b6 00 28 ld	s6,40(sp)
[ 135] 0x900000001fc1027c:  df b7 00 20 ld	s7,32(sp)
[ 135] 0x900000001fc10280:  df b1 00 50 ld	s1,80(sp)
[ 126] 0x900000001fc10284:  10 00 00 0c b		0x900000001fc102b8
[ 126] 0x900000001fc10288:  df be 00 18 ld	s8,24(sp)
[ 126] 0x900000001fc1028c:  00 00 10 25 move	v0,zero
[ 126] 0x900000001fc10290:  df b6 00 28 ld	s6,40(sp)
[ 126] 0x900000001fc10294:  df b7 00 20 ld	s7,32(sp)
[ 126] 0x900000001fc10298:  df b1 00 50 ld	s1,80(sp)
[ 109] 0x900000001fc1029c:  10 00 00 06 b		0x900000001fc102b8
[ 109] 0x900000001fc102a0:  df be 00 18 ld	s8,24(sp)
[  91] 0x900000001fc102a4:  ff bf 00 60 sd	ra,96(sp)
[  91] 0x900000001fc102a8:  0f f0 2c e3 jal		loprintf
[  91] 0x900000001fc102ac:  02 80 20 25 move	a0,s4
[  92] 0x900000001fc102b0:  24 02 00 fd li	v0,253
[  92] 0x900000001fc102b4:  ff b3 00 40 sd	s3,64(sp)
[  92] 0x900000001fc102b8:  df b2 00 48 ld	s2,72(sp)
[  92] 0x900000001fc102bc:  df b5 00 30 ld	s5,48(sp)
[  92] 0x900000001fc102c0:  df bf 00 60 ld	ra,96(sp)
[  92] 0x900000001fc102c4:  df b3 00 40 ld	s3,64(sp)
[  92] 0x900000001fc102c8:  df b0 00 58 ld	s0,88(sp)
[  92] 0x900000001fc102cc:  df b4 00 38 ld	s4,56(sp)
[  92] 0x900000001fc102d0:  03 e0 00 08 jr	ra
[  92] 0x900000001fc102d4:  67 bd 00 70 daddiu	sp,sp,112
  139:     }
  140: }
  141: 
  142: 
  143: /*
  144:  * timed_out returns zero before the timeout and nonzero after.
  145:  * t0 is the begin time.  t1 is the end time.  Handles wraps properly.
  146:  */
  147: int timed_out(unsigned int t0, unsigned int t1)
  148: {
  149: 	unsigned int cur_time;
  150: 
  151: 	cur_time = LD_RTC();
timed_out:
[ 151] 0x900000001fc102d8:  3c 01 90 00 lui	at,0x9000
[ 151] 0x900000001fc102dc:  60 22 00 00 daddi	v0,at,0
[ 151] 0x900000001fc102e0:  3c 01 1f c2 lui	at,0x1fc2
[ 151] 0x900000001fc102e4:  60 23 e2 98 daddi	v1,at,-7528
[ 151] 0x900000001fc102e8:  00 02 10 3c dsll32	v0,v0,0
[ 151] 0x900000001fc102ec:  00 43 10 2c dadd	v0,v0,v1
[ 151] 0x900000001fc102f0:  dc 42 01 30 ld	v0,304(v0)
  152: 	if (t0 < t1)
[ 152] 0x900000001fc102f4:  00 00 58 25 move	a7,zero
[ 152] 0x900000001fc102f8:  dc 42 00 00 ld	v0,0(v0)
[ 152] 0x900000001fc102fc:  00 00 c8 25 move	t9,zero
[ 152] 0x900000001fc10300:  00 02 12 3b dsra	v0,v0,8
[ 152] 0x900000001fc10304:  00 85 08 2b sltu	at,a0,a1
[ 152] 0x900000001fc10308:  00 02 10 00 sll	v0,v0,0
[ 152] 0x900000001fc1030c:  00 44 48 2b sltu	a5,v0,a0
[ 152] 0x900000001fc10310:  00 a2 50 2b sltu	a6,a1,v0
[ 152] 0x900000001fc10314:  00 a2 40 2b sltu	a4,a1,v0
[ 152] 0x900000001fc10318:  14 20 00 08 bne	at,zero,0x900000001fc1033c
[ 152] 0x900000001fc1031c:  00 44 38 2b sltu	a3,v0,a0
  153: 		return ((cur_time < t0) || (cur_time > t1));
  154: 	else
  155: 		return ((cur_time < t0) && (cur_time > t1));
[ 155] 0x900000001fc10320:  10 e0 00 04 beq	a3,zero,0x900000001fc10334
[ 155] 0x900000001fc10324:  00 00 00 21 nada
[ 155] 0x900000001fc10328:  11 00 00 02 beq	a4,zero,0x900000001fc10334
[ 155] 0x900000001fc1032c:  00 00 00 21 nada
[ 155] 0x900000001fc10330:  24 19 00 01 li	t9,1
[ 155] 0x900000001fc10334:  10 00 00 07 b		0x900000001fc10354
[ 155] 0x900000001fc10338:  03 20 10 25 move	v0,t9
[ 153] 0x900000001fc1033c:  55 20 00 04 bnel	a5,zero,0x900000001fc10350
[ 153] 0x900000001fc10340:  24 0b 00 01 li	a7,1
[ 153] 0x900000001fc10344:  51 40 00 03 beql	a6,zero,0x900000001fc10354
[ 153] 0x900000001fc10348:  01 60 10 25 move	v0,a7
[ 153] 0x900000001fc1034c:  24 0b 00 01 li	a7,1
[ 153] 0x900000001fc10350:  01 60 10 25 move	v0,a7
[ 153] 0x900000001fc10354:  03 e0 00 08 jr	ra
[ 153] 0x900000001fc10358:  00 00 00 21 nada
  156: }
  157: 
  158: 
  159: int pod_check_rawmem(int num_banks, evbnkcfg_t *bank_arr[])
  160: {
pod_check_rawmem:
[ 160] 0x900000001fc1035c:  67 bd ff 80 daddiu	sp,sp,-128
  161: 	int i;
  162: 	unsigned int time;
  163: 	unsigned int timeout;
  164: 	evreg_t status;
  165: 	int someone_failed = 0;
  166: 	int leaf;
  167: 	int bank;
  168: 	
  169: 	for (i = 0; i < num_banks; i += 8) {
[ 169] 0x900000001fc10360:  ff b4 00 50 sd	s4,80(sp)
[ 169] 0x900000001fc10364:  00 00 a0 25 move	s4,zero
[ 169] 0x900000001fc10368:  3c 01 90 00 lui	at,0x9000
[ 169] 0x900000001fc1036c:  3c 02 1f c2 lui	v0,0x1fc2
[ 169] 0x900000001fc10370:  60 21 00 00 daddi	at,at,0
[ 169] 0x900000001fc10374:  ff be 00 30 sd	s8,48(sp)
[ 169] 0x900000001fc10378:  60 42 e2 98 daddi	v0,v0,-7528
[ 169] 0x900000001fc1037c:  ff b1 00 68 sd	s1,104(sp)
[ 169] 0x900000001fc10380:  00 01 08 3c dsll32	at,at,0
[ 169] 0x900000001fc10384:  24 83 00 07 addiu	v1,a0,7
[ 169] 0x900000001fc10388:  ff b0 00 70 sd	s0,112(sp)
[ 169] 0x900000001fc1038c:  00 03 f0 c2 srl	s8,v1,3
[ 169] 0x900000001fc10390:  ff a4 00 10 sd	a0,16(sp)
[ 169] 0x900000001fc10394:  00 22 08 2c dadd	at,at,v0
[ 169] 0x900000001fc10398:  ff a5 00 18 sd	a1,24(sp)
[ 169] 0x900000001fc1039c:  33 d0 00 01 andi	s0,s8,0x1
[ 165] 0x900000001fc103a0:  ff b2 00 60 sd	s2,96(sp)
[ 165] 0x900000001fc103a4:  18 80 00 60 blez	a0,0x900000001fc10528
[ 165] 0x900000001fc103a8:  ff a1 00 20 sd	at,32(sp)
[ 165] 0x900000001fc103ac:  df a7 00 20 ld	a3,32(sp)
[ 165] 0x900000001fc103b0:  12 00 00 24 beq	s0,zero,0x900000001fc10444
[ 165] 0x900000001fc103b4:  ff b5 00 48 sd	s5,72(sp)
[ 165] 0x900000001fc103b8:  00 10 30 3c dsll32	a2,s0,0
[ 165] 0x900000001fc103bc:  24 11 00 ff li	s1,255
[ 165] 0x900000001fc103c0:  00 06 36 ba dsrl	a2,a2,26
[ 165] 0x900000001fc103c4:  ff b3 00 58 sd	s3,88(sp)
[ 165] 0x900000001fc103c8:  ff b7 00 38 sd	s7,56(sp)
[ 165] 0x900000001fc103cc:  dc f7 01 80 ld	s7,384(a3)
[ 165] 0x900000001fc103d0:  df b2 00 18 ld	s2,24(sp)
[ 165] 0x900000001fc103d4:  24 13 00 0f li	s3,15
[ 165] 0x900000001fc103d8:  ff b6 00 40 sd	s6,64(sp)
[ 165] 0x900000001fc103dc:  dc f6 01 88 ld	s6,392(a3)
[ 165] 0x900000001fc103e0:  dc f5 01 90 ld	s5,400(a3)
[ 165] 0x900000001fc103e4:  02 46 c8 2d daddu	t9,s2,a2
[ 165] 0x900000001fc103e8:  de 48 00 00 ld	a4,0(s2)
  170: 	    DPRINTF(("Starting BIST on slot %b\n", bank_arr[i]->bnk_slot));
  171: 		/* Enable all banks for BIST */
  172: 		EV_SET_CONFIG(bank_arr[i]->bnk_slot, MC3_BANKENB, 0xff);
[ 172] 0x900000001fc103ec:  91 08 00 04 lbu	a4,4(a4)
[ 172] 0x900000001fc103f0:  00 08 42 c0 sll	a4,a4,11
[ 172] 0x900000001fc103f4:  01 17 40 2d daddu	a4,a4,s7
[ 172] 0x900000001fc103f8:  fd 11 00 00 sd	s1,0(a4)
  173: 		EV_SET_CONFIG(bank_arr[i]->bnk_slot, MC3_LEAFCTLENB, 0xf);
[ 173] 0x900000001fc103fc:  de 48 00 00 ld	a4,0(s2)
[ 173] 0x900000001fc10400:  91 08 00 04 lbu	a4,4(a4)
[ 173] 0x900000001fc10404:  00 08 42 c0 sll	a4,a4,11
[ 173] 0x900000001fc10408:  01 16 40 2d daddu	a4,a4,s6
[ 173] 0x900000001fc1040c:  fd 13 00 00 sd	s3,0(a4)
  174: 		EV_SET_CONFIG(bank_arr[i]->bnk_slot, MC3_BISTRESULT, 0xf);
[ 174] 0x900000001fc10410:  de 48 00 00 ld	a4,0(s2)
[ 174] 0x900000001fc10414:  91 08 00 04 lbu	a4,4(a4)
[ 174] 0x900000001fc10418:  00 08 42 c0 sll	a4,a4,11
[ 174] 0x900000001fc1041c:  01 15 40 2d daddu	a4,a4,s5
[ 169] 0x900000001fc10420:  66 52 00 40 daddiu	s2,s2,64
[ 169] 0x900000001fc10424:  26 94 00 08 addiu	s4,s4,8
[ 169] 0x900000001fc10428:  fd 13 00 00 sd	s3,0(a4)
[ 169] 0x900000001fc1042c:  56 59 ff ef bnel	s2,t9,0x900000001fc103ec
[ 169] 0x900000001fc10430:  de 48 00 00 ld	a4,0(s2)
[ 169] 0x900000001fc10434:  df b5 00 48 ld	s5,72(sp)
[ 169] 0x900000001fc10438:  df b6 00 40 ld	s6,64(sp)
[ 169] 0x900000001fc1043c:  df b3 00 58 ld	s3,88(sp)
[ 169] 0x900000001fc10440:  df b7 00 38 ld	s7,56(sp)
[ 169] 0x900000001fc10444:  ff b7 00 38 sd	s7,56(sp)
[ 169] 0x900000001fc10448:  00 1e 58 42 srl	a7,s8,1
[ 169] 0x900000001fc1044c:  26 89 00 08 addiu	a5,s4,8
[ 169] 0x900000001fc10450:  df aa 00 10 ld	a6,16(sp)
[ 169] 0x900000001fc10454:  ff b6 00 40 sd	s6,64(sp)
[ 169] 0x900000001fc10458:  df ac 00 20 ld	t0,32(sp)
[ 169] 0x900000001fc1045c:  00 14 70 f8 dsll	t2,s4,3
[ 169] 0x900000001fc10460:  01 2a 48 2a slt	a5,a5,a6
[ 169] 0x900000001fc10464:  df ad 00 18 ld	t1,24(sp)
[ 169] 0x900000001fc10468:  11 20 00 2f beq	a5,zero,0x900000001fc10528
[ 169] 0x900000001fc1046c:  ff b5 00 48 sd	s5,72(sp)
[ 169] 0x900000001fc10470:  24 11 00 ff li	s1,255
[ 169] 0x900000001fc10474:  00 0b 58 3c dsll32	a7,a7,0
[ 169] 0x900000001fc10478:  01 ae 90 2d daddu	s2,t1,t2
[ 169] 0x900000001fc1047c:  00 0b 5e 7a dsrl	a7,a7,25
[ 169] 0x900000001fc10480:  dd 97 01 80 ld	s7,384(t0)
[ 169] 0x900000001fc10484:  ff b3 00 58 sd	s3,88(sp)
[ 169] 0x900000001fc10488:  24 13 00 0f li	s3,15
[ 169] 0x900000001fc1048c:  dd 96 01 88 ld	s6,392(t0)
[ 169] 0x900000001fc10490:  dd 95 01 90 ld	s5,400(t0)
[ 169] 0x900000001fc10494:  02 4b 80 2d daddu	s0,s2,a7
[ 169] 0x900000001fc10498:  de 4f 00 00 ld	t3,0(s2)
[ 169] 0x900000001fc1049c:  91 ef 00 04 lbu	t3,4(t3)
[ 169] 0x900000001fc104a0:  00 0f 7a c0 sll	t3,t3,11
[ 169] 0x900000001fc104a4:  01 f7 78 2d daddu	t3,t3,s7
[ 169] 0x900000001fc104a8:  fd f1 00 00 sd	s1,0(t3)
[ 169] 0x900000001fc104ac:  de 4f 00 00 ld	t3,0(s2)
[ 169] 0x900000001fc104b0:  91 ef 00 04 lbu	t3,4(t3)
[ 169] 0x900000001fc104b4:  00 0f 7a c0 sll	t3,t3,11
[ 169] 0x900000001fc104b8:  01 f6 78 2d daddu	t3,t3,s6
[ 169] 0x900000001fc104bc:  fd f3 00 00 sd	s3,0(t3)
[ 169] 0x900000001fc104c0:  de 4f 00 00 ld	t3,0(s2)
[ 169] 0x900000001fc104c4:  91 ef 00 04 lbu	t3,4(t3)
[ 169] 0x900000001fc104c8:  00 0f 7a c0 sll	t3,t3,11
[ 169] 0x900000001fc104cc:  01 f5 78 2d daddu	t3,t3,s5
[ 169] 0x900000001fc104d0:  fd f3 00 00 sd	s3,0(t3)
[ 169] 0x900000001fc104d4:  de 4f 00 40 ld	t3,64(s2)
[ 169] 0x900000001fc104d8:  91 ef 00 04 lbu	t3,4(t3)
[ 169] 0x900000001fc104dc:  00 0f 7a c0 sll	t3,t3,11
[ 169] 0x900000001fc104e0:  01 f7 78 2d daddu	t3,t3,s7
[ 169] 0x900000001fc104e4:  fd f1 00 00 sd	s1,0(t3)
[ 169] 0x900000001fc104e8:  de 4f 00 40 ld	t3,64(s2)
[ 169] 0x900000001fc104ec:  91 ef 00 04 lbu	t3,4(t3)
[ 169] 0x900000001fc104f0:  00 0f 7a c0 sll	t3,t3,11
[ 169] 0x900000001fc104f4:  01 f6 78 2d daddu	t3,t3,s6
[ 169] 0x900000001fc104f8:  fd f3 00 00 sd	s3,0(t3)
[ 169] 0x900000001fc104fc:  de 4f 00 40 ld	t3,64(s2)
[ 169] 0x900000001fc10500:  91 ef 00 04 lbu	t3,4(t3)
[ 169] 0x900000001fc10504:  00 0f 7a c0 sll	t3,t3,11
[ 169] 0x900000001fc10508:  01 f5 78 2d daddu	t3,t3,s5
[ 169] 0x900000001fc1050c:  66 52 00 80 daddiu	s2,s2,128
[ 169] 0x900000001fc10510:  16 50 ff e1 bne	s2,s0,0x900000001fc10498
[ 169] 0x900000001fc10514:  fd f3 00 00 sd	s3,0(t3)
[ 169] 0x900000001fc10518:  df b5 00 48 ld	s5,72(sp)
[ 169] 0x900000001fc1051c:  df b6 00 40 ld	s6,64(sp)
[ 169] 0x900000001fc10520:  df b3 00 58 ld	s3,88(sp)
[ 169] 0x900000001fc10524:  df b7 00 38 ld	s7,56(sp)
[ 169] 0x900000001fc10528:  ff b3 00 58 sd	s3,88(sp)
  175: 	}
  176: 
  177: 	time = LD_RTC();
[ 177] 0x900000001fc1052c:  df b0 00 20 ld	s0,32(sp)
[ 177] 0x900000001fc10530:  ff b5 00 48 sd	s5,72(sp)
[ 177] 0x900000001fc10534:  ff b7 00 38 sd	s7,56(sp)
[ 177] 0x900000001fc10538:  de 10 01 30 ld	s0,304(s0)
[ 177] 0x900000001fc1053c:  ff b6 00 40 sd	s6,64(sp)
[ 177] 0x900000001fc10540:  de 10 00 00 ld	s0,0(s0)
  178: 	timeout = time + MC3_BIST_TOUT;
[ 178] 0x900000001fc10544:  3c 11 00 b2 lui	s1,0xb2
[ 178] 0x900000001fc10548:  00 10 82 3b dsra	s0,s0,8
  179: 
  180: 	/* Wait for everyone to finish or a timeout */	
  181: 	for (i = 0; i < num_banks; i += 8) {
[ 181] 0x900000001fc1054c:  36 31 d0 50 ori	s1,s1,0xd050
[ 181] 0x900000001fc10550:  00 10 80 00 sll	s0,s0,0
[ 181] 0x900000001fc10554:  df b2 00 10 ld	s2,16(sp)
[ 181] 0x900000001fc10558:  ff bf 00 78 sd	ra,120(sp)
[ 181] 0x900000001fc1055c:  1a 40 00 31 blez	s2,0x900000001fc10624
[ 181] 0x900000001fc10560:  02 11 88 21 addu	s1,s0,s1
[ 181] 0x900000001fc10564:  df b3 00 10 ld	s3,16(sp)
[ 181] 0x900000001fc10568:  26 74 00 07 addiu	s4,s3,7
[ 181] 0x900000001fc1056c:  00 14 a0 c2 srl	s4,s4,3
[ 181] 0x900000001fc10570:  df b5 00 20 ld	s5,32(sp)
[ 181] 0x900000001fc10574:  00 14 a0 3c dsll32	s4,s4,0
[ 181] 0x900000001fc10578:  00 14 a6 ba dsrl	s4,s4,26
[ 181] 0x900000001fc1057c:  df b2 00 18 ld	s2,24(sp)
[ 181] 0x900000001fc10580:  66 b3 01 38 daddiu	s3,s5,312
[ 181] 0x900000001fc10584:  de b5 01 90 ld	s5,400(s5)
[ 181] 0x900000001fc10588:  02 60 20 25 move	a0,s3
[ 181] 0x900000001fc1058c:  02 54 a0 2d daddu	s4,s2,s4
  182: 		loprintf(" %a", bank_arr[i]->bnk_slot);
[ 182] 0x900000001fc10590:  de 56 00 00 ld	s6,0(s2)
[ 182] 0x900000001fc10594:  0f f0 2c e3 jal		loprintf
[ 182] 0x900000001fc10598:  92 c5 00 04 lbu	a1,4(s6)
  183: 		while ((EV_GET_CONFIG(bank_arr[i]->bnk_slot, MC3_BISTRESULT) & 3)
[ 183] 0x900000001fc1059c:  02 20 28 25 move	a1,s1
[ 183] 0x900000001fc105a0:  de 56 00 00 ld	s6,0(s2)
[ 183] 0x900000001fc105a4:  92 d6 00 04 lbu	s6,4(s6)
[ 183] 0x900000001fc105a8:  00 16 b2 c0 sll	s6,s6,11
[ 183] 0x900000001fc105ac:  02 d5 b0 2d daddu	s6,s6,s5
[ 183] 0x900000001fc105b0:  de d6 00 00 ld	s6,0(s6)
[ 183] 0x900000001fc105b4:  32 d6 00 03 andi	s6,s6,0x3
[ 183] 0x900000001fc105b8:  52 c0 00 13 beql	s6,zero,0x900000001fc10608
[ 183] 0x900000001fc105bc:  02 60 20 25 move	a0,s3
[ 183] 0x900000001fc105c0:  0f f0 40 b6 jal		timed_out
[ 183] 0x900000001fc105c4:  02 00 20 25 move	a0,s0
[ 183] 0x900000001fc105c8:  54 40 00 0f bnel	v0,zero,0x900000001fc10608
[ 183] 0x900000001fc105cc:  02 60 20 25 move	a0,s3
[ 183] 0x900000001fc105d0:  02 20 28 25 move	a1,s1
[ 183] 0x900000001fc105d4:  de 57 00 00 ld	s7,0(s2)
[ 183] 0x900000001fc105d8:  92 f7 00 04 lbu	s7,4(s7)
[ 183] 0x900000001fc105dc:  00 17 ba c0 sll	s7,s7,11
[ 183] 0x900000001fc105e0:  02 f5 b8 2d daddu	s7,s7,s5
[ 183] 0x900000001fc105e4:  de f7 00 00 ld	s7,0(s7)
[ 183] 0x900000001fc105e8:  32 f7 00 03 andi	s7,s7,0x3
[ 183] 0x900000001fc105ec:  52 e0 00 06 beql	s7,zero,0x900000001fc10608
[ 183] 0x900000001fc105f0:  02 60 20 25 move	a0,s3
[ 183] 0x900000001fc105f4:  0f f0 40 b6 jal		timed_out
[ 183] 0x900000001fc105f8:  02 00 20 25 move	a0,s0
[ 183] 0x900000001fc105fc:  50 40 ff f5 beql	v0,zero,0x900000001fc105d4
[ 183] 0x900000001fc10600:  02 20 28 25 move	a1,s1
[ 183] 0x900000001fc10604:  02 60 20 25 move	a0,s3
[ 181] 0x900000001fc10608:  66 52 00 40 daddiu	s2,s2,64
[ 181] 0x900000001fc1060c:  16 54 ff e0 bne	s2,s4,0x900000001fc10590
[ 181] 0x900000001fc10610:  00 00 00 21 nada
[ 181] 0x900000001fc10614:  df b5 00 48 ld	s5,72(sp)
[ 181] 0x900000001fc10618:  df b6 00 40 ld	s6,64(sp)
[ 181] 0x900000001fc1061c:  df b3 00 58 ld	s3,88(sp)
[ 181] 0x900000001fc10620:  df b7 00 38 ld	s7,56(sp)
[ 181] 0x900000001fc10624:  24 1f 00 01 li	ra,1
[ 181] 0x900000001fc10628:  df b9 00 10 ld	t9,16(sp)
[ 181] 0x900000001fc1062c:  00 00 a0 25 move	s4,zero
  184: 				&& !(timed_out(time, timeout)))
  185: 			;
  186: 	}
  187: 
  188: 	for (i = 0; i < num_banks; i++) {
[ 188] 0x900000001fc10630:  df b8 00 10 ld	t8,16(sp)
[ 188] 0x900000001fc10634:  df be 00 20 ld	s8,32(sp)
[ 188] 0x900000001fc10638:  1b 00 00 69 blez	t8,0x900000001fc107e0
[ 188] 0x900000001fc1063c:  ff b3 00 58 sd	s3,88(sp)
[ 188] 0x900000001fc10640:  00 19 c8 3c dsll32	t9,t9,0
[ 188] 0x900000001fc10644:  00 19 cf 7a dsrl	t9,t9,29
[ 188] 0x900000001fc10648:  ff b5 00 48 sd	s5,72(sp)
[ 188] 0x900000001fc1064c:  df d5 01 90 ld	s5,400(s8)
[ 188] 0x900000001fc10650:  67 c1 01 40 daddiu	at,s8,320
[ 188] 0x900000001fc10654:  df b2 00 18 ld	s2,24(sp)
[ 188] 0x900000001fc10658:  24 03 00 07 li	v1,7
[ 188] 0x900000001fc1065c:  ff a1 00 28 sd	at,40(sp)
[ 188] 0x900000001fc10660:  ff b7 00 38 sd	s7,56(sp)
[ 188] 0x900000001fc10664:  df d7 01 80 ld	s7,384(s8)
[ 188] 0x900000001fc10668:  02 59 f0 2d daddu	s8,s2,t9
[ 188] 0x900000001fc1066c:  ff b6 00 40 sd	s6,64(sp)
[ 188] 0x900000001fc10670:  de 41 00 00 ld	at,0(s2)
  189: 		/* Fetch the BIST result */
  190: 		status = EV_GET_CONFIG(bank_arr[i]->bnk_slot, MC3_BISTRESULT);
[ 190] 0x900000001fc10674:  90 21 00 04 lbu	at,4(at)
[ 190] 0x900000001fc10678:  00 01 0a c0 sll	at,at,11
[ 190] 0x900000001fc1067c:  00 35 08 2d daddu	at,at,s5
  191: 		status >>= 4;
  192: 		leaf = (i >> 2) % 2;
[ 192] 0x900000001fc10680:  00 14 c8 83 sra	t9,s4,2
[ 192] 0x900000001fc10684:  33 2b 00 01 andi	a7,t9,0x1
[ 192] 0x900000001fc10688:  01 6b 50 21 addu	a6,a7,a7
[ 192] 0x900000001fc1068c:  dc 21 00 00 ld	at,0(at)
[ 191] 0x900000001fc10690:  07 21 00 07 bgez	t9,0x900000001fc106b0
[ 191] 0x900000001fc10694:  00 01 49 3a dsrl	a5,at,4
[ 191] 0x900000001fc10698:  00 19 08 23 subu	at,zero,t9
[ 191] 0x900000001fc1069c:  30 21 00 01 andi	at,at,0x1
[ 191] 0x900000001fc106a0:  00 01 b0 23 subu	s6,zero,at
[ 191] 0x900000001fc106a4:  32 91 00 03 andi	s1,s4,0x3
[ 191] 0x900000001fc106a8:  10 00 00 03 b		0x900000001fc106b8
[ 191] 0x900000001fc106ac:  02 d6 50 21 addu	a6,s6,s6
[ 191] 0x900000001fc106b0:  32 91 00 03 andi	s1,s4,0x3
[ 191] 0x900000001fc106b4:  01 60 b0 25 move	s6,a7
  193: 		bank = i % 4;
[ 193] 0x900000001fc106b8:  06 83 00 06 bgezl	s4,0x900000001fc106d4
[ 193] 0x900000001fc106bc:  32 21 00 02 andi	at,s1,0x2
[ 193] 0x900000001fc106c0:  00 14 08 23 subu	at,zero,s4
[ 193] 0x900000001fc106c4:  30 21 00 03 andi	at,at,0x3
[ 193] 0x900000001fc106c8:  10 00 00 01 b		0x900000001fc106d0
[ 193] 0x900000001fc106cc:  00 01 88 23 subu	s1,zero,at
  194: 
  195: 		/* Check the BIST results for each bank. */
  196: 		if (status & (1 << (i & 7))) {
[ 196] 0x900000001fc106d0:  32 21 00 02 andi	at,s1,0x2
[ 196] 0x900000001fc106d4:  00 01 10 43 sra	v0,at,1
[ 196] 0x900000001fc106d8:  32 81 00 07 andi	at,s4,0x7
[ 196] 0x900000001fc106dc:  32 24 00 01 andi	a0,s1,0x1
[ 196] 0x900000001fc106e0:  00 3f 08 04 sllv	at,ra,at
[ 196] 0x900000001fc106e4:  02 20 80 25 move	s0,s1
[ 196] 0x900000001fc106e8:  00 02 10 80 sll	v0,v0,2
[ 196] 0x900000001fc106ec:  01 21 08 24 and	at,a5,at
[ 196] 0x900000001fc106f0:  00 4a 10 21 addu	v0,v0,a6
[ 196] 0x900000001fc106f4:  02 00 28 25 move	a1,s0
[ 196] 0x900000001fc106f8:  00 44 10 21 addu	v0,v0,a0
[ 196] 0x900000001fc106fc:  10 20 00 16 beq	at,zero,0x900000001fc10758
[ 196] 0x900000001fc10700:  00 5f 98 04 sllv	s3,ra,v0
  197: 			loprintf("\n*** Self-test FAILED on slot %a, leaf %d, bank %d (%c)\n",
[ 197] 0x900000001fc10704:  0f f0 42 58 jal		bank_letter
[ 197] 0x900000001fc10708:  02 c0 20 25 move	a0,s6
[ 197] 0x900000001fc1070c:  30 48 00 ff andi	a4,v0,0xff
[ 197] 0x900000001fc10710:  02 00 38 25 move	a3,s0
[ 197] 0x900000001fc10714:  de 41 00 00 ld	at,0(s2)
[ 197] 0x900000001fc10718:  02 c0 30 25 move	a2,s6
[ 197] 0x900000001fc1071c:  df a4 00 28 ld	a0,40(sp)
[ 197] 0x900000001fc10720:  0f f0 2c e3 jal		loprintf
[ 197] 0x900000001fc10724:  90 25 00 04 lbu	a1,4(at)
  198: 					bank_arr[i]->bnk_slot, leaf, bank,
  199: 					bank_letter(leaf, bank));
  200: 			bank_arr[i]->bnk_diagval = EVDIAG_BIST_FAILED;
[ 200] 0x900000001fc10728:  de 42 00 00 ld	v0,0(s2)
[ 200] 0x900000001fc1072c:  24 01 00 28 li	at,40
[ 200] 0x900000001fc10730:  a0 41 00 07 sb	at,7(v0)
  201: 			bank_arr[i]->bnk_enable = 0;
[ 201] 0x900000001fc10734:  de 41 00 00 ld	at,0(s2)
[ 201] 0x900000001fc10738:  a0 20 00 05 sb	zero,5(at)
  202: 			status = EV_GET_CONFIG(bank_arr[i]->bnk_slot, MC3_BANKENB);
[ 202] 0x900000001fc1073c:  de 41 00 00 ld	at,0(s2)
[ 202] 0x900000001fc10740:  90 21 00 04 lbu	at,4(at)
[ 202] 0x900000001fc10744:  00 01 0a c0 sll	at,at,11
[ 202] 0x900000001fc10748:  00 37 08 2d daddu	at,at,s7
[ 202] 0x900000001fc1074c:  24 03 00 07 li	v1,7
[ 202] 0x900000001fc10750:  24 1f 00 01 li	ra,1
[ 202] 0x900000001fc10754:  dc 20 00 00 ld	zero,0(at)
  203: 
  204: 		}
  205: 
  206: 		/* Set or clear the bank enable bit for each bank */
  207: 		if ((bank_arr[i]->bnk_size != MC3_NOBANK) &&
[ 207] 0x900000001fc10758:  de 41 00 00 ld	at,0(s2)
[ 207] 0x900000001fc1075c:  90 21 00 0a lbu	at,10(at)
[ 207] 0x900000001fc10760:  50 23 00 06 beql	at,v1,0x900000001fc1077c
[ 207] 0x900000001fc10764:  de 41 00 00 ld	at,0(s2)
[ 207] 0x900000001fc10768:  de 41 00 00 ld	at,0(s2)
[ 207] 0x900000001fc1076c:  90 21 00 05 lbu	at,5(at)
[ 207] 0x900000001fc10770:  54 20 00 0d bnel	at,zero,0x900000001fc107a8
[ 207] 0x900000001fc10774:  de 41 00 00 ld	at,0(s2)
  208: 						bank_arr[i]->bnk_enable) {
  209: 			status = EV_GET_CONFIG(bank_arr[i]->bnk_slot,
  210: 								MC3_BANKENB);
  211: 			status |= (MC3_BENB(leaf, bank));
  212: 			DPRINTF(("Turning on slot %d, leaf %d bank %d\n", 
  213: 				 bank_arr[i]->bnk_slot, leaf, bank));
  214: 			EV_SET_CONFIG(bank_arr[i]->bnk_slot, MC3_BANKENB,
  215: 								status);
  216: 		} else {
  217: 		    DPRINTF(("Turning OFF slot %d, leaf %d bank %d\n", 
  218: 			     bank_arr[i]->bnk_slot, leaf, bank));
  219: 			status = EV_GET_CONFIG(bank_arr[i]->bnk_slot,
[ 219] 0x900000001fc10778:  de 41 00 00 ld	at,0(s2)
[ 219] 0x900000001fc1077c:  90 21 00 04 lbu	at,4(at)
[ 219] 0x900000001fc10780:  00 01 0a c0 sll	at,at,11
[ 219] 0x900000001fc10784:  00 37 10 2d daddu	v0,at,s7
  220: 								MC3_BANKENB);
  221: 			status &= ~(MC3_BENB(leaf, bank));
[ 221] 0x900000001fc10788:  02 60 20 27 nor	a0,s3,zero
  222: 			EV_SET_CONFIG(bank_arr[i]->bnk_slot, MC3_BANKENB,
[ 222] 0x900000001fc1078c:  66 52 00 08 daddiu	s2,s2,8
[ 222] 0x900000001fc10790:  dc 41 00 00 ld	at,0(v0)
[ 222] 0x900000001fc10794:  00 24 08 24 and	at,at,a0
[ 222] 0x900000001fc10798:  fc 41 00 00 sd	at,0(v0)
[ 222] 0x900000001fc1079c:  10 00 00 0a b		0x900000001fc107c8
[ 222] 0x900000001fc107a0:  26 94 00 01 addiu	s4,s4,1
[ 209] 0x900000001fc107a4:  de 41 00 00 ld	at,0(s2)
[ 209] 0x900000001fc107a8:  90 21 00 04 lbu	at,4(at)
[ 209] 0x900000001fc107ac:  00 01 0a c0 sll	at,at,11
[ 209] 0x900000001fc107b0:  00 37 10 2d daddu	v0,at,s7
[ 209] 0x900000001fc107b4:  dc 41 00 00 ld	at,0(v0)
[ 211] 0x900000001fc107b8:  00 33 08 25 or	at,at,s3
[ 214] 0x900000001fc107bc:  66 52 00 08 daddiu	s2,s2,8
[ 214] 0x900000001fc107c0:  26 94 00 01 addiu	s4,s4,1
[ 214] 0x900000001fc107c4:  fc 41 00 00 sd	at,0(v0)
[ 188] 0x900000001fc107c8:  56 5e ff aa bnel	s2,s8,0x900000001fc10674
[ 188] 0x900000001fc107cc:  de 41 00 00 ld	at,0(s2)
[ 188] 0x900000001fc107d0:  df b5 00 48 ld	s5,72(sp)
[ 188] 0x900000001fc107d4:  df b6 00 40 ld	s6,64(sp)
[ 188] 0x900000001fc107d8:  df b3 00 58 ld	s3,88(sp)
[ 188] 0x900000001fc107dc:  df b7 00 38 ld	s7,56(sp)
[ 188] 0x900000001fc107e0:  df b1 00 68 ld	s1,104(sp)
[ 188] 0x900000001fc107e4:  df be 00 30 ld	s8,48(sp)
[ 188] 0x900000001fc107e8:  df bf 00 78 ld	ra,120(sp)
  223: 								status);
  224: 		}
  225: 	}
  226: 	return someone_failed;
[ 226] 0x900000001fc107ec:  00 00 10 25 move	v0,zero
[ 226] 0x900000001fc107f0:  df b2 00 60 ld	s2,96(sp)
[ 226] 0x900000001fc107f4:  df b0 00 70 ld	s0,112(sp)
[ 226] 0x900000001fc107f8:  df b4 00 50 ld	s4,80(sp)
[ 226] 0x900000001fc107fc:  03 e0 00 08 jr	ra
[ 226] 0x900000001fc10800:  67 bd 00 80 daddiu	sp,sp,128
  227: }
  228: 
  229: 
  230: /* in_bank returns 1 if the given address is in the same leaf position
  231:  * as the bank whose interleave factor and position are provided
  232:  * and the address is in the correct range.
  233:  */
  234: int in_bank(uint bloc, uint offset, uint base_bloc, uint i_factor,
  235: 					uint i_position, uint simm_type)
  236: {
in_bank:
[ 236] 0x900000001fc10804:  01 20 10 25 move	v0,a5
[ 236] 0x900000001fc10808:  00 e0 48 25 move	a5,a3
  237: 	uint end_bloc;
  238: 	uint cache_line_num;
  239: 
  240: 	end_bloc = base_bloc + MemSizes[simm_type] * MC3_INTERLEAV(i_factor);
[ 240] 0x900000001fc1080c:  00 c0 08 25 move	at,a2
[ 240] 0x900000001fc10810:  3c 03 90 00 lui	v1,0x9000
[ 240] 0x900000001fc10814:  60 66 00 00 daddi	a2,v1,0
[ 240] 0x900000001fc10818:  3c 03 1f c2 lui	v1,0x1fc2
[ 240] 0x900000001fc1081c:  60 67 e2 98 daddi	a3,v1,-7528
[ 240] 0x900000001fc10820:  00 06 30 3c dsll32	a2,a2,0
[ 240] 0x900000001fc10824:  00 c7 30 2c dadd	a2,a2,a3
[ 240] 0x900000001fc10828:  00 02 10 3c dsll32	v0,v0,0
[ 240] 0x900000001fc1082c:  00 02 17 7a dsrl	v0,v0,29
[ 240] 0x900000001fc10830:  dc c6 01 98 ld	a2,408(a2)
[ 240] 0x900000001fc10834:  00 46 10 2d daddu	v0,v0,a2
[ 240] 0x900000001fc10838:  24 03 00 01 li	v1,1
[ 240] 0x900000001fc1083c:  01 23 58 04 sllv	a7,v1,a5
[ 240] 0x900000001fc10840:  dc 42 00 00 ld	v0,0(v0)
[ 240] 0x900000001fc10844:  00 4b 00 1d dmultu	v0,a7
[ 240] 0x900000001fc10848:  00 01 18 3c dsll32	v1,at,0
[ 240] 0x900000001fc1084c:  00 03 18 3e dsrl32	v1,v1,0
[ 240] 0x900000001fc10850:  00 00 10 12 mflo	v0
  241: 
  242: 	DPRINTF(("base = %x, if = %d, ip = %d, type = %d",
  243: 		base_bloc, i_factor, i_position, simm_type));
  244: 
  245: 	/* If it's out of range, return 0 */
  246: 	if (bloc < base_bloc || bloc >= end_bloc) {
[ 246] 0x900000001fc10854:  00 81 08 2b sltu	at,a0,at
[ 246] 0x900000001fc10858:  00 43 10 2d daddu	v0,v0,v1
[ 246] 0x900000001fc1085c:  00 02 10 00 sll	v0,v0,0
[ 246] 0x900000001fc10860:  14 20 00 10 bne	at,zero,0x900000001fc108a4
[ 246] 0x900000001fc10864:  00 82 c8 2b sltu	t9,a0,v0
[ 246] 0x900000001fc10868:  53 20 00 0f beql	t9,zero,0x900000001fc108a8
[ 246] 0x900000001fc1086c:  00 00 10 25 move	v0,zero
  247: 		DPRINTF(("Not here.\n"));
  248: 		/* Nope. */
  249: 		return 0;
  250: 	}
  251: 
  252: 	DPRINTF(("End == %x\n", end_bloc));
  253: 	/* Is this bank the right position in the "interleave"?
  254: 	 * See if the "block" address falls in _our_ interleave position
  255: 	 */
  256: 	cache_line_num = (bloc << 1) + (offset >> 7);
[ 256] 0x900000001fc10870:  00 04 50 40 sll	a6,a0,1
[ 256] 0x900000001fc10874:  00 05 61 c2 srl	t0,a1,7
[ 256] 0x900000001fc10878:  01 4c 50 21 addu	a6,a6,t0
  257: 
  258: 	if ((cache_line_num % MC3_INTERLEAV(i_factor)) == i_position) {
[ 258] 0x900000001fc1087c:  01 4b 00 1b divu	a6,a7
  259: 	    DPRINTF(("This bank!\n"));
  260: 		/* We're the one */
  261: 		return 1;
[ 261] 0x900000001fc10880:  24 02 00 01 li	v0,1
[ 261] 0x900000001fc10884:  00 00 50 10 mfhi	a6
[ 261] 0x900000001fc10888:  01 0a 50 26 xor	a6,a4,a6
  262: 	}
  263: 
  264: 	DPRINTF(("In range, wrong IP.\n"));
  265: 	/* Nope. */
  266: 	return 0;
[ 266] 0x900000001fc1088c:  00 0a 10 0b movn	v0,zero,a6
[ 266] 0x900000001fc10890:  00 00 00 21 nada
[ 266] 0x900000001fc10894:  00 00 00 21 nada
[ 266] 0x900000001fc10898:  00 00 00 21 nada
[ 266] 0x900000001fc1089c:  10 00 00 02 b		0x900000001fc108a8
[ 266] 0x900000001fc108a0:  00 00 00 21 nada
[ 249] 0x900000001fc108a4:  00 00 10 25 move	v0,zero
[ 249] 0x900000001fc108a8:  03 e0 00 08 jr	ra
[ 249] 0x900000001fc108ac:  00 00 00 21 nada
  267: }
  268: 
  269: void
  270: decode_address(unsigned int paddr)
  271: {
decode_address:
[ 271] 0x900000001fc108b0:  67 bd ff d0 daddiu	sp,sp,-48
  272: 	uint slot, leaf, bank, simm;
  273: 	if (addr2sbs(paddr >> 8, paddr & 0xff, &slot, &bank, &simm)) {
[ 273] 0x900000001fc108b4:  00 04 0a 02 srl	at,a0,8
[ 273] 0x900000001fc108b8:  ff b0 00 20 sd	s0,32(sp)
[ 273] 0x900000001fc108bc:  00 80 80 25 move	s0,a0
[ 273] 0x900000001fc108c0:  30 85 00 ff andi	a1,a0,0xff
[ 273] 0x900000001fc108c4:  67 a8 00 08 daddiu	a4,sp,8
[ 273] 0x900000001fc108c8:  67 a7 00 04 daddiu	a3,sp,4
[ 273] 0x900000001fc108cc:  67 a6 00 00 daddiu	a2,sp,0
[ 273] 0x900000001fc108d0:  ff bf 00 28 sd	ra,40(sp)
[ 273] 0x900000001fc108d4:  0f f0 43 63 jal		addr2sbs
[ 273] 0x900000001fc108d8:  00 20 20 25 move	a0,at
[ 273] 0x900000001fc108dc:  02 00 28 25 move	a1,s0
[ 273] 0x900000001fc108e0:  8f aa 00 04 lw	a6,4(sp)
[ 273] 0x900000001fc108e4:  3c 01 90 00 lui	at,0x9000
[ 273] 0x900000001fc108e8:  60 21 00 00 daddi	at,at,0
[ 273] 0x900000001fc108ec:  3c 03 1f c2 lui	v1,0x1fc2
[ 273] 0x900000001fc108f0:  60 63 e2 98 daddi	v1,v1,-7528
[ 273] 0x900000001fc108f4:  00 01 08 3c dsll32	at,at,0
[ 273] 0x900000001fc108f8:  14 40 00 13 bne	v0,zero,0x900000001fc10948
[ 273] 0x900000001fc108fc:  00 23 c8 2c dadd	t9,at,v1
  274: 		loprintf("*** Unable to decode address %x!\n", paddr);
  275: 	} else {
  276: 		leaf = bank >> 2;
[ 276] 0x900000001fc10900:  ff b9 00 10 sd	t9,16(sp)
[ 276] 0x900000001fc10904:  00 0a 48 82 srl	a5,a6,2
  277: 		bank &= 3;
[ 277] 0x900000001fc10908:  ff a9 00 18 sd	a5,24(sp)
[ 277] 0x900000001fc1090c:  31 45 00 03 andi	a1,a6,0x3
  278: #ifdef SIMMDECODE
  279: 		loprintf("%x decodes to slot 0x%b, leaf %d bank %d (%c), simmm %d\n",
  280: 			paddr, slot, leaf, bank, bank_letter(leaf, bank), simm);
  281: #else
  282: 		loprintf("%x decodes to slot 0x%b, leaf %d, bank %d (%c)\n",
[ 282] 0x900000001fc10910:  af a5 00 04 sw	a1,4(sp)
[ 282] 0x900000001fc10914:  0f f0 42 58 jal		bank_letter
[ 282] 0x900000001fc10918:  01 20 20 25 move	a0,a5
[ 282] 0x900000001fc1091c:  df a7 00 18 ld	a3,24(sp)
[ 282] 0x900000001fc10920:  8f a6 00 00 lw	a2,0(sp)
[ 282] 0x900000001fc10924:  30 49 00 ff andi	a5,v0,0xff
[ 282] 0x900000001fc10928:  8f a8 00 04 lw	a4,4(sp)
[ 282] 0x900000001fc1092c:  02 00 28 25 move	a1,s0
[ 282] 0x900000001fc10930:  df aa 00 10 ld	a6,16(sp)
[ 282] 0x900000001fc10934:  df b0 00 20 ld	s0,32(sp)
[ 282] 0x900000001fc10938:  0f f0 2c e3 jal		loprintf
[ 282] 0x900000001fc1093c:  65 44 01 c8 daddiu	a0,a6,456
[ 282] 0x900000001fc10940:  10 00 00 05 b		0x900000001fc10958
[ 282] 0x900000001fc10944:  df bf 00 28 ld	ra,40(sp)
[ 274] 0x900000001fc10948:  df b0 00 20 ld	s0,32(sp)
[ 274] 0x900000001fc1094c:  0f f0 2c e3 jal		loprintf
[ 274] 0x900000001fc10950:  67 24 01 a0 daddiu	a0,t9,416
[ 274] 0x900000001fc10954:  df bf 00 28 ld	ra,40(sp)
[ 274] 0x900000001fc10958:  03 e0 00 08 jr	ra
[ 274] 0x900000001fc1095c:  67 bd 00 30 daddiu	sp,sp,48
  283: 			paddr, slot, leaf, bank, bank_letter(leaf, bank));
  284: #endif 
  285: 	}
  286: }
  287: 
  288: 
  289: static char bank_letter(uint leaf, uint bank)
  290: {
bank_letter:
[ 290] 0x900000001fc10960:  00 05 10 40 sll	v0,a1,1
  291: 	if ((leaf > 1) || (bank > 3))
[ 291] 0x900000001fc10964:  2c 81 00 02 sltiu	at,a0,2
[ 291] 0x900000001fc10968:  50 20 00 09 beql	at,zero,0x900000001fc10990
[ 291] 0x900000001fc1096c:  24 02 00 3f li	v0,63
[ 291] 0x900000001fc10970:  2c a3 00 04 sltiu	v1,a1,4
[ 291] 0x900000001fc10974:  00 82 10 21 addu	v0,a0,v0
[ 291] 0x900000001fc10978:  24 42 00 41 addiu	v0,v0,65
[ 291] 0x900000001fc1097c:  10 60 00 03 beq	v1,zero,0x900000001fc1098c
[ 291] 0x900000001fc10980:  30 42 00 ff andi	v0,v0,0xff
  292: 		return '?';
  293: 	
  294: 	return 'A' + leaf + (bank << 1);
[ 294] 0x900000001fc10984:  10 00 00 02 b		0x900000001fc10990
[ 294] 0x900000001fc10988:  00 00 00 21 nada
[ 292] 0x900000001fc1098c:  24 02 00 3f li	v0,63
[ 292] 0x900000001fc10990:  03 e0 00 08 jr	ra
[ 292] 0x900000001fc10994:  00 00 00 21 nada
  295: }
  296: 
  297: 
  298: int 
  299: disable_slot_bank(__uint64_t bloc, __uint64_t off, evbnkcfg_t *banks[], 
  300: 		  int num_banks, uint diagval)
  301: {
disable_slot_bank:
[ 301] 0x900000001fc10998:  67 bd ff d0 daddiu	sp,sp,-48
[ 301] 0x900000001fc1099c:  ff b0 00 20 sd	s0,32(sp)
[ 301] 0x900000001fc109a0:  00 c0 80 25 move	s0,a2
  302: 	uint slot;
  303: 	uint bank;
  304: 	uint simm;
  305: 	uint b;
  306: 
  307: 	if (addr2sbs(bloc, off, &slot, &bank, &simm))
[ 307] 0x900000001fc109a4:  ff b1 00 18 sd	s1,24(sp)
[ 307] 0x900000001fc109a8:  00 e0 88 25 move	s1,a3
[ 307] 0x900000001fc109ac:  00 04 20 00 sll	a0,a0,0
[ 307] 0x900000001fc109b0:  00 05 28 00 sll	a1,a1,0
[ 307] 0x900000001fc109b4:  67 a7 00 04 daddiu	a3,sp,4
[ 307] 0x900000001fc109b8:  67 a6 00 00 daddiu	a2,sp,0
[ 307] 0x900000001fc109bc:  ff a8 00 10 sd	a4,16(sp)
[ 307] 0x900000001fc109c0:  ff bf 00 28 sd	ra,40(sp)
[ 307] 0x900000001fc109c4:  0f f0 43 63 jal		addr2sbs
[ 307] 0x900000001fc109c8:  67 a8 00 08 daddiu	a4,sp,8
[ 307] 0x900000001fc109cc:  df bf 00 28 ld	ra,40(sp)
[ 307] 0x900000001fc109d0:  8f a5 00 00 lw	a1,0(sp)
[ 307] 0x900000001fc109d4:  00 00 48 25 move	a5,zero
[ 307] 0x900000001fc109d8:  24 19 ff ff li	t9,-1
[ 307] 0x900000001fc109dc:  54 40 00 c3 bnel	v0,zero,0x900000001fc10cec
[ 307] 0x900000001fc109e0:  df b1 00 18 ld	s1,24(sp)
  308: 		return -1;
  309: 
  310: 	for (b = 0; b < num_banks; b += 8) {
[ 310] 0x900000001fc109e4:  52 20 00 3e beql	s1,zero,0x900000001fc10ae0
[ 310] 0x900000001fc109e8:  df bf 00 28 ld	ra,40(sp)
[ 310] 0x900000001fc109ec:  26 2a 00 07 addiu	a6,s1,7
[ 310] 0x900000001fc109f0:  00 0a 50 c2 srl	a6,a6,3
[ 310] 0x900000001fc109f4:  31 4a 00 03 andi	a6,a6,0x3
[ 310] 0x900000001fc109f8:  11 40 00 0c beq	a6,zero,0x900000001fc10a2c
[ 310] 0x900000001fc109fc:  00 0a c8 c0 sll	t9,a6,3
  311: 		if (banks[b]->bnk_slot == slot) {
[ 311] 0x900000001fc10a00:  00 09 58 3c dsll32	a7,a5,0
[ 311] 0x900000001fc10a04:  00 0b 5f 7a dsrl	a7,a7,29
[ 311] 0x900000001fc10a08:  02 0b 58 2d daddu	a7,s0,a7
[ 311] 0x900000001fc10a0c:  dd 6b 00 00 ld	a7,0(a7)
[ 311] 0x900000001fc10a10:  91 6b 00 04 lbu	a7,4(a7)
[ 311] 0x900000001fc10a14:  50 ab 00 75 beql	a1,a7,0x900000001fc10bec
[ 311] 0x900000001fc10a18:  8f bf 00 04 lw	ra,4(sp)
[ 310] 0x900000001fc10a1c:  25 29 00 08 addiu	a5,a5,8
[ 310] 0x900000001fc10a20:  01 39 60 2b sltu	t0,a5,t9
[ 310] 0x900000001fc10a24:  55 80 ff f7 bnel	t0,zero,0x900000001fc10a04
[ 310] 0x900000001fc10a28:  00 09 58 3c dsll32	a7,a5,0
[ 310] 0x900000001fc10a2c:  00 09 70 3c dsll32	t2,a5,0
[ 310] 0x900000001fc10a30:  8f a5 00 00 lw	a1,0(sp)
[ 310] 0x900000001fc10a34:  25 2d 00 18 addiu	t1,a5,24
[ 310] 0x900000001fc10a38:  01 b1 68 2b sltu	t1,t1,s1
[ 310] 0x900000001fc10a3c:  26 28 ff e8 addiu	a4,s1,-24
[ 310] 0x900000001fc10a40:  51 a0 00 27 beql	t1,zero,0x900000001fc10ae0
[ 310] 0x900000001fc10a44:  df bf 00 28 ld	ra,40(sp)
[ 310] 0x900000001fc10a48:  00 0e 77 7a dsrl	t2,t2,29
[ 310] 0x900000001fc10a4c:  02 0e 88 2d daddu	s1,s0,t2
[ 310] 0x900000001fc10a50:  25 2a 00 10 addiu	a6,a5,16
[ 310] 0x900000001fc10a54:  de 2f 00 00 ld	t3,0(s1)
[ 310] 0x900000001fc10a58:  25 38 00 08 addiu	t8,a5,8
[ 310] 0x900000001fc10a5c:  25 2b 00 18 addiu	a7,a5,24
[ 310] 0x900000001fc10a60:  00 18 c0 3c dsll32	t8,t8,0
[ 310] 0x900000001fc10a64:  00 18 cf 7a dsrl	t9,t8,29
[ 310] 0x900000001fc10a68:  91 ef 00 04 lbu	t3,4(t3)
[ 310] 0x900000001fc10a6c:  50 af 00 50 beql	a1,t3,0x900000001fc10bb0
[ 310] 0x900000001fc10a70:  8f b1 00 04 lw	s1,4(sp)
[ 310] 0x900000001fc10a74:  02 19 c8 2d daddu	t9,s0,t9
[ 310] 0x900000001fc10a78:  df 39 00 00 ld	t9,0(t9)
[ 310] 0x900000001fc10a7c:  00 0a f8 3c dsll32	ra,a6,0
[ 310] 0x900000001fc10a80:  00 1f ff 7a dsrl	ra,ra,29
[ 310] 0x900000001fc10a84:  00 0b 10 3c dsll32	v0,a7,0
[ 310] 0x900000001fc10a88:  02 1f 88 2d daddu	s1,s0,ra
[ 310] 0x900000001fc10a8c:  93 39 00 04 lbu	t9,4(t9)
[ 310] 0x900000001fc10a90:  50 b9 00 37 beql	a1,t9,0x900000001fc10b70
[ 310] 0x900000001fc10a94:  25 29 00 08 addiu	a5,a5,8
[ 310] 0x900000001fc10a98:  de 21 00 00 ld	at,0(s1)
[ 310] 0x900000001fc10a9c:  25 29 00 20 addiu	a5,a5,32
[ 310] 0x900000001fc10aa0:  00 02 17 7a dsrl	v0,v0,29
[ 310] 0x900000001fc10aa4:  00 09 20 3c dsll32	a0,a5,0
[ 310] 0x900000001fc10aa8:  02 02 c8 2d daddu	t9,s0,v0
[ 310] 0x900000001fc10aac:  90 21 00 04 lbu	at,4(at)
[ 310] 0x900000001fc10ab0:  50 a1 00 1f beql	a1,at,0x900000001fc10b30
[ 310] 0x900000001fc10ab4:  8f ab 00 04 lw	a7,4(sp)
[ 310] 0x900000001fc10ab8:  df 23 00 00 ld	v1,0(t9)
[ 310] 0x900000001fc10abc:  01 28 50 2b sltu	a6,a5,a4
[ 310] 0x900000001fc10ac0:  00 04 27 7a dsrl	a0,a0,29
[ 310] 0x900000001fc10ac4:  02 04 88 2d daddu	s1,s0,a0
[ 310] 0x900000001fc10ac8:  90 63 00 04 lbu	v1,4(v1)
[ 310] 0x900000001fc10acc:  50 a3 00 08 beql	a1,v1,0x900000001fc10af0
[ 310] 0x900000001fc10ad0:  8f a6 00 04 lw	a2,4(sp)
[ 310] 0x900000001fc10ad4:  55 40 ff df bnel	a6,zero,0x900000001fc10a54
[ 310] 0x900000001fc10ad8:  25 2a 00 10 addiu	a6,a5,16
[ 310] 0x900000001fc10adc:  df bf 00 28 ld	ra,40(sp)
[ 310] 0x900000001fc10ae0:  df b1 00 18 ld	s1,24(sp)
  312: 			if (banks[b + bank]->bnk_slot != slot) {
  313: 				loprintf("*** IP25 prom logic error: "
  314: 					 "disable_slot_bank()!\n");
  315: 				return -1;
  316: 			}
  317: 
  318: 			if (banks[b + bank]->bnk_enable == 0) {
  319: 				loprintf("*** Slot %a, leaf %d, bank %d "
  320: 					 "ALREADY DISABLED!\n",
  321: 				slot, bank >> 2, bank & 3);
  322: 				return -1;
  323: 			}
  324: 			banks[b + bank]->bnk_enable = 0;
  325: 			banks[b + bank]->bnk_diagval = diagval;
  326: 			loprintf("    Disabling slot %a, leaf %d, bank %d\n",
  327: 				slot, bank >> 2, bank & 3);
  328: 			return 0;
  329: 		}
  330: 	}
  331: 	/* Never found it. */
  332: 	return -1;
[ 332] 0x900000001fc10ae4:  10 00 00 81 b		0x900000001fc10cec
[ 332] 0x900000001fc10ae8:  24 19 ff ff li	t9,-1
[ 332] 0x900000001fc10aec:  8f a6 00 04 lw	a2,4(sp)
[ 332] 0x900000001fc10af0:  01 66 30 21 addu	a2,a7,a2
[ 332] 0x900000001fc10af4:  00 06 30 3c dsll32	a2,a2,0
[ 332] 0x900000001fc10af8:  01 60 48 25 move	a5,a7
[ 332] 0x900000001fc10afc:  00 06 37 7a dsrl	a2,a2,29
[ 332] 0x900000001fc10b00:  3c 07 90 00 lui	a3,0x9000
[ 332] 0x900000001fc10b04:  02 06 30 2d daddu	a2,s0,a2
[ 332] 0x900000001fc10b08:  60 e7 00 00 daddi	a3,a3,0
[ 332] 0x900000001fc10b0c:  3c 08 1f c2 lui	a4,0x1fc2
[ 332] 0x900000001fc10b10:  61 08 e2 98 daddi	a4,a4,-7528
[ 332] 0x900000001fc10b14:  00 07 38 3c dsll32	a3,a3,0
[ 332] 0x900000001fc10b18:  dc c6 00 00 ld	a2,0(a2)
[ 332] 0x900000001fc10b1c:  00 e8 88 2c dadd	s1,a3,a4
[ 332] 0x900000001fc10b20:  90 d9 00 04 lbu	t9,4(a2)
[ 332] 0x900000001fc10b24:  10 00 00 3e b		0x900000001fc10c20
[ 332] 0x900000001fc10b28:  8f a2 00 04 lw	v0,4(sp)
[ 332] 0x900000001fc10b2c:  8f ab 00 04 lw	a7,4(sp)
[ 332] 0x900000001fc10b30:  01 40 48 25 move	a5,a6
[ 332] 0x900000001fc10b34:  01 4b 50 21 addu	a6,a6,a7
[ 332] 0x900000001fc10b38:  00 0a 50 3c dsll32	a6,a6,0
[ 332] 0x900000001fc10b3c:  00 0a 57 7a dsrl	a6,a6,29
[ 332] 0x900000001fc10b40:  3c 0b 90 00 lui	a7,0x9000
[ 332] 0x900000001fc10b44:  02 0a 50 2d daddu	a6,s0,a6
[ 332] 0x900000001fc10b48:  61 6b 00 00 daddi	a7,a7,0
[ 332] 0x900000001fc10b4c:  3c 0c 1f c2 lui	t0,0x1fc2
[ 332] 0x900000001fc10b50:  61 8c e2 98 daddi	t0,t0,-7528
[ 332] 0x900000001fc10b54:  00 0b 58 3c dsll32	a7,a7,0
[ 332] 0x900000001fc10b58:  dd 4a 00 00 ld	a6,0(a6)
[ 332] 0x900000001fc10b5c:  01 6c 88 2c dadd	s1,a7,t0
[ 332] 0x900000001fc10b60:  91 59 00 04 lbu	t9,4(a6)
[ 332] 0x900000001fc10b64:  10 00 00 2e b		0x900000001fc10c20
[ 332] 0x900000001fc10b68:  8f a2 00 04 lw	v0,4(sp)
[ 332] 0x900000001fc10b6c:  25 29 00 08 addiu	a5,a5,8
[ 332] 0x900000001fc10b70:  8f ad 00 04 lw	t1,4(sp)
[ 332] 0x900000001fc10b74:  01 2d 68 21 addu	t1,a5,t1
[ 332] 0x900000001fc10b78:  00 0d 68 3c dsll32	t1,t1,0
[ 332] 0x900000001fc10b7c:  00 0d 6f 7a dsrl	t1,t1,29
[ 332] 0x900000001fc10b80:  3c 0e 90 00 lui	t2,0x9000
[ 332] 0x900000001fc10b84:  02 0d 68 2d daddu	t1,s0,t1
[ 332] 0x900000001fc10b88:  61 ce 00 00 daddi	t2,t2,0
[ 332] 0x900000001fc10b8c:  3c 0f 1f c2 lui	t3,0x1fc2
[ 332] 0x900000001fc10b90:  61 ef e2 98 daddi	t3,t3,-7528
[ 332] 0x900000001fc10b94:  00 0e 70 3c dsll32	t2,t2,0
[ 332] 0x900000001fc10b98:  dd ad 00 00 ld	t1,0(t1)
[ 332] 0x900000001fc10b9c:  01 cf 88 2c dadd	s1,t2,t3
[ 332] 0x900000001fc10ba0:  91 b9 00 04 lbu	t9,4(t1)
[ 332] 0x900000001fc10ba4:  10 00 00 1e b		0x900000001fc10c20
[ 332] 0x900000001fc10ba8:  8f a2 00 04 lw	v0,4(sp)
[ 332] 0x900000001fc10bac:  8f b1 00 04 lw	s1,4(sp)
[ 332] 0x900000001fc10bb0:  01 31 c0 21 addu	t8,a5,s1
[ 332] 0x900000001fc10bb4:  00 18 c0 3c dsll32	t8,t8,0
[ 332] 0x900000001fc10bb8:  00 18 c7 7a dsrl	t8,t8,29
[ 332] 0x900000001fc10bbc:  3c 11 90 00 lui	s1,0x9000
[ 332] 0x900000001fc10bc0:  02 18 c0 2d daddu	t8,s0,t8
[ 332] 0x900000001fc10bc4:  62 31 00 00 daddi	s1,s1,0
[ 332] 0x900000001fc10bc8:  3c 19 1f c2 lui	t9,0x1fc2
[ 332] 0x900000001fc10bcc:  63 39 e2 98 daddi	t9,t9,-7528
[ 332] 0x900000001fc10bd0:  00 11 88 3c dsll32	s1,s1,0
[ 332] 0x900000001fc10bd4:  df 18 00 00 ld	t8,0(t8)
[ 332] 0x900000001fc10bd8:  02 39 88 2c dadd	s1,s1,t9
[ 332] 0x900000001fc10bdc:  93 19 00 04 lbu	t9,4(t8)
[ 332] 0x900000001fc10be0:  10 00 00 0f b		0x900000001fc10c20
[ 332] 0x900000001fc10be4:  8f a2 00 04 lw	v0,4(sp)
[ 332] 0x900000001fc10be8:  8f bf 00 04 lw	ra,4(sp)
[ 332] 0x900000001fc10bec:  01 3f f8 21 addu	ra,a5,ra
[ 332] 0x900000001fc10bf0:  00 1f f8 3c dsll32	ra,ra,0
[ 332] 0x900000001fc10bf4:  00 1f ff 7a dsrl	ra,ra,29
[ 332] 0x900000001fc10bf8:  02 1f f8 2d daddu	ra,s0,ra
[ 332] 0x900000001fc10bfc:  3c 01 90 00 lui	at,0x9000
[ 332] 0x900000001fc10c00:  60 21 00 00 daddi	at,at,0
[ 332] 0x900000001fc10c04:  3c 02 1f c2 lui	v0,0x1fc2
[ 332] 0x900000001fc10c08:  df ff 00 00 ld	ra,0(ra)
[ 332] 0x900000001fc10c0c:  60 42 e2 98 daddi	v0,v0,-7528
[ 332] 0x900000001fc10c10:  00 01 08 3c dsll32	at,at,0
[ 332] 0x900000001fc10c14:  00 22 88 2c dadd	s1,at,v0
[ 332] 0x900000001fc10c18:  93 f9 00 04 lbu	t9,4(ra)
[ 332] 0x900000001fc10c1c:  8f a2 00 04 lw	v0,4(sp)
[ 312] 0x900000001fc10c20:  14 b9 00 2b bne	a1,t9,0x900000001fc10cd0
[ 312] 0x900000001fc10c24:  00 00 00 21 nada
[ 318] 0x900000001fc10c28:  8f a8 00 04 lw	a4,4(sp)
[ 318] 0x900000001fc10c2c:  01 22 10 21 addu	v0,a5,v0
[ 318] 0x900000001fc10c30:  8f a1 00 04 lw	at,4(sp)
[ 318] 0x900000001fc10c34:  01 21 08 21 addu	at,a5,at
[ 318] 0x900000001fc10c38:  00 01 08 3c dsll32	at,at,0
[ 318] 0x900000001fc10c3c:  00 01 0f 7a dsrl	at,at,29
[ 318] 0x900000001fc10c40:  00 02 10 3c dsll32	v0,v0,0
[ 318] 0x900000001fc10c44:  02 01 08 2d daddu	at,s0,at
[ 318] 0x900000001fc10c48:  00 02 17 7a dsrl	v0,v0,29
[ 318] 0x900000001fc10c4c:  02 02 10 2d daddu	v0,s0,v0
[ 318] 0x900000001fc10c50:  dc 21 00 00 ld	at,0(at)
[ 318] 0x900000001fc10c54:  90 21 00 05 lbu	at,5(at)
[ 318] 0x900000001fc10c58:  50 20 00 16 beql	at,zero,0x900000001fc10cb4
[ 318] 0x900000001fc10c5c:  66 24 02 30 daddiu	a0,s1,560
[ 324] 0x900000001fc10c60:  dc 42 00 00 ld	v0,0(v0)
[ 324] 0x900000001fc10c64:  a0 40 00 05 sb	zero,5(v0)
[ 324] 0x900000001fc10c68:  8f a2 00 04 lw	v0,4(sp)
[ 325] 0x900000001fc10c6c:  01 22 10 21 addu	v0,a5,v0
[ 325] 0x900000001fc10c70:  00 02 10 3c dsll32	v0,v0,0
[ 325] 0x900000001fc10c74:  00 02 17 7a dsrl	v0,v0,29
[ 325] 0x900000001fc10c78:  02 02 18 2d daddu	v1,s0,v0
[ 325] 0x900000001fc10c7c:  dc 63 00 00 ld	v1,0(v1)
[ 325] 0x900000001fc10c80:  df a2 00 10 ld	v0,16(sp)
[ 325] 0x900000001fc10c84:  a0 62 00 07 sb	v0,7(v1)
[ 326] 0x900000001fc10c88:  8f a2 00 04 lw	v0,4(sp)
[ 326] 0x900000001fc10c8c:  66 24 02 68 daddiu	a0,s1,616
[ 326] 0x900000001fc10c90:  df b1 00 18 ld	s1,24(sp)
[ 326] 0x900000001fc10c94:  8f a5 00 00 lw	a1,0(sp)
[ 326] 0x900000001fc10c98:  00 02 30 82 srl	a2,v0,2
[ 326] 0x900000001fc10c9c:  0f f0 2c e3 jal		loprintf
[ 326] 0x900000001fc10ca0:  30 47 00 03 andi	a3,v0,0x3
[ 328] 0x900000001fc10ca4:  00 00 c8 25 move	t9,zero
[ 328] 0x900000001fc10ca8:  10 00 00 10 b		0x900000001fc10cec
[ 328] 0x900000001fc10cac:  df bf 00 28 ld	ra,40(sp)
[ 319] 0x900000001fc10cb0:  66 24 02 30 daddiu	a0,s1,560
[ 319] 0x900000001fc10cb4:  df b1 00 18 ld	s1,24(sp)
[ 319] 0x900000001fc10cb8:  00 08 30 82 srl	a2,a4,2
[ 319] 0x900000001fc10cbc:  0f f0 2c e3 jal		loprintf
[ 319] 0x900000001fc10cc0:  31 07 00 03 andi	a3,a4,0x3
[ 322] 0x900000001fc10cc4:  24 19 ff ff li	t9,-1
[ 322] 0x900000001fc10cc8:  10 00 00 08 b		0x900000001fc10cec
[ 322] 0x900000001fc10ccc:  df bf 00 28 ld	ra,40(sp)
[ 313] 0x900000001fc10cd0:  0f f0 2c e3 jal		loprintf
[ 313] 0x900000001fc10cd4:  66 24 01 f8 daddiu	a0,s1,504
[ 315] 0x900000001fc10cd8:  df bf 00 28 ld	ra,40(sp)
[ 315] 0x900000001fc10cdc:  24 19 ff ff li	t9,-1
[ 315] 0x900000001fc10ce0:  10 00 00 02 b		0x900000001fc10cec
[ 315] 0x900000001fc10ce4:  df b1 00 18 ld	s1,24(sp)
[ 315] 0x900000001fc10ce8:  df b1 00 18 ld	s1,24(sp)
[ 308] 0x900000001fc10cec:  03 20 10 25 move	v0,t9
[ 308] 0x900000001fc10cf0:  df b0 00 20 ld	s0,32(sp)
[ 308] 0x900000001fc10cf4:  03 e0 00 08 jr	ra
[ 308] 0x900000001fc10cf8:  67 bd 00 30 daddiu	sp,sp,48
  333: }
  334: 
  335: 
  336: void print_slot_bank(uint bloc, uint off) {
print_slot_bank:
[ 336] 0x900000001fc10cfc:  67 bd ff d0 daddiu	sp,sp,-48
  337: 	uint slot;
  338: 	uint leaf;
  339: 	uint bank;
  340: 	uint simm;
  341: 
  342: 	if (addr2sbs(bloc, off, &slot, &bank, &simm))
[ 342] 0x900000001fc10d00:  67 a8 00 08 daddiu	a4,sp,8
[ 342] 0x900000001fc10d04:  67 a7 00 04 daddiu	a3,sp,4
[ 342] 0x900000001fc10d08:  ff bf 00 18 sd	ra,24(sp)
[ 342] 0x900000001fc10d0c:  0f f0 43 63 jal		addr2sbs
[ 342] 0x900000001fc10d10:  67 a6 00 00 daddiu	a2,sp,0
[ 342] 0x900000001fc10d14:  3c 01 90 00 lui	at,0x9000
[ 342] 0x900000001fc10d18:  60 21 00 00 daddi	at,at,0
[ 342] 0x900000001fc10d1c:  3c 03 1f c2 lui	v1,0x1fc2
[ 342] 0x900000001fc10d20:  60 63 e2 98 daddi	v1,v1,-7528
[ 342] 0x900000001fc10d24:  00 01 08 3c dsll32	at,at,0
[ 342] 0x900000001fc10d28:  00 23 08 2c dadd	at,at,v1
[ 342] 0x900000001fc10d2c:  ff a1 00 10 sd	at,16(sp)
[ 342] 0x900000001fc10d30:  df a9 00 10 ld	a5,16(sp)
[ 342] 0x900000001fc10d34:  10 40 00 03 beq	v0,zero,0x900000001fc10d44
[ 342] 0x900000001fc10d38:  00 00 00 21 nada
  343: 		loprintf("UNKNOWN BANK!\n");
[ 343] 0x900000001fc10d3c:  0f f0 2c e3 jal		loprintf
[ 343] 0x900000001fc10d40:  65 24 02 98 daddiu	a0,a5,664
  344: 
  345: 	leaf = (bank > 3) ? 1 : 0;
[ 345] 0x900000001fc10d44:  8f ab 00 04 lw	a7,4(sp)
[ 345] 0x900000001fc10d48:  24 0a 00 03 li	a6,3
[ 345] 0x900000001fc10d4c:  01 4b 50 2b sltu	a6,a6,a7
  346: 	bank &= 3;
[ 346] 0x900000001fc10d50:  ff aa 00 20 sd	a6,32(sp)
[ 346] 0x900000001fc10d54:  31 65 00 03 andi	a1,a7,0x3
  347: 
  348: 	loprintf("slot %a, leaf %d, bank %d (%c)\n",
[ 348] 0x900000001fc10d58:  af a5 00 04 sw	a1,4(sp)
[ 348] 0x900000001fc10d5c:  0f f0 42 58 jal		bank_letter
[ 348] 0x900000001fc10d60:  01 40 20 25 move	a0,a6
[ 348] 0x900000001fc10d64:  df a6 00 20 ld	a2,32(sp)
[ 348] 0x900000001fc10d68:  8f a5 00 00 lw	a1,0(sp)
[ 348] 0x900000001fc10d6c:  8f a7 00 04 lw	a3,4(sp)
[ 348] 0x900000001fc10d70:  30 48 00 ff andi	a4,v0,0xff
[ 348] 0x900000001fc10d74:  df aa 00 10 ld	a6,16(sp)
[ 348] 0x900000001fc10d78:  0f f0 2c e3 jal		loprintf
[ 348] 0x900000001fc10d7c:  65 44 02 a8 daddiu	a0,a6,680
  349: 		slot, leaf, bank, bank_letter(leaf, bank));
  350: }
[ 350] 0x900000001fc10d80:  df bf 00 18 ld	ra,24(sp)
[ 350] 0x900000001fc10d84:  03 e0 00 08 jr	ra
[ 350] 0x900000001fc10d88:  67 bd 00 30 daddiu	sp,sp,48
  351: 
  352: 
  353: static int addr2sbs(uint bloc, uint offset, uint *slot, uint *bank, uint *simm)
  354: {
addr2sbs:
[ 354] 0x900000001fc10d8c:  67 bd ff 40 daddiu	sp,sp,-192
[ 354] 0x900000001fc10d90:  ff a4 00 00 sd	a0,0(sp)
[ 354] 0x900000001fc10d94:  ff a5 00 08 sd	a1,8(sp)
[ 354] 0x900000001fc10d98:  ff a6 00 10 sd	a2,16(sp)
  355:     unsigned int mem_slots;
  356:     int s, l, b;
  357:     short enable, simm_type, i_factor, i_position;
  358:     uint base_bloc;
  359: 
  360:     mem_slots = memory_slots();
[ 360] 0x900000001fc10d9c:  ff a7 00 18 sd	a3,24(sp)
[ 360] 0x900000001fc10da0:  ff bf 00 b0 sd	ra,176(sp)
[ 360] 0x900000001fc10da4:  0f f0 17 2e jal		memory_slots
[ 360] 0x900000001fc10da8:  ff a8 00 20 sd	a4,32(sp)
  361: 
  362:     for (s = 0; s < EV_MAX_SLOTS; s++) {
[ 362] 0x900000001fc10dac:  ff a0 00 30 sd	zero,48(sp)
[ 362] 0x900000001fc10db0:  24 01 00 01 li	at,1
[ 362] 0x900000001fc10db4:  24 03 00 10 li	v1,16
[ 362] 0x900000001fc10db8:  00 01 08 04 sllv	at,at,zero
[ 362] 0x900000001fc10dbc:  ff a3 00 38 sd	v1,56(sp)
[ 362] 0x900000001fc10dc0:  ff a2 00 28 sd	v0,40(sp)
[ 362] 0x900000001fc10dc4:  ff b0 00 a8 sd	s0,168(sp)
[ 362] 0x900000001fc10dc8:  00 41 80 24 and	s0,v0,at
[ 362] 0x900000001fc10dcc:  ff b1 00 a0 sd	s1,160(sp)
[ 362] 0x900000001fc10dd0:  ff b2 00 98 sd	s2,152(sp)
[ 362] 0x900000001fc10dd4:  ff b3 00 90 sd	s3,144(sp)
[ 362] 0x900000001fc10dd8:  ff b4 00 88 sd	s4,136(sp)
[ 362] 0x900000001fc10ddc:  ff b5 00 80 sd	s5,128(sp)
[ 362] 0x900000001fc10de0:  ff b6 00 78 sd	s6,120(sp)
[ 362] 0x900000001fc10de4:  ff b7 00 70 sd	s7,112(sp)
[ 362] 0x900000001fc10de8:  ff be 00 68 sd	s8,104(sp)
[ 362] 0x900000001fc10dec:  df b6 00 30 ld	s6,48(sp)
[ 362] 0x900000001fc10df0:  00 00 b8 25 move	s7,zero
  363: 	if (mem_slots & (1 << s)) {
[ 363] 0x900000001fc10df4:  ff a0 00 40 sd	zero,64(sp)
[ 363] 0x900000001fc10df8:  ff a0 00 48 sd	zero,72(sp)
[ 363] 0x900000001fc10dfc:  ff a0 00 50 sd	zero,80(sp)
[ 363] 0x900000001fc10e00:  df a5 00 50 ld	a1,80(sp)
[ 363] 0x900000001fc10e04:  24 04 00 80 li	a0,128
[ 363] 0x900000001fc10e08:  ff a4 00 58 sd	a0,88(sp)
[ 363] 0x900000001fc10e0c:  52 00 00 4b beql	s0,zero,0x900000001fc10f3c
[ 363] 0x900000001fc10e10:  df a1 00 30 ld	at,48(sp)
  364: 	    DPRINTF(("Board %b is memory\n", s));
  365: 	    /* It's a memory board, do leaf loop */
  366: 	    for (l = 0; l < MC3_NUM_LEAVES; l++) {
  367: 		DPRINTF(("leaf %b\n", l));
  368: 	        for (b = 0; b < MC3_BANKS_PER_LEAF; b++) {
[ 368] 0x900000001fc10e14:  24 b0 00 10 addiu	s0,a1,16
[ 368] 0x900000001fc10e18:  24 b1 00 12 addiu	s1,a1,18
[ 368] 0x900000001fc10e1c:  24 b2 00 13 addiu	s2,a1,19
[ 368] 0x900000001fc10e20:  24 b3 00 11 addiu	s3,a1,17
[ 368] 0x900000001fc10e24:  24 be 00 21 addiu	s8,a1,33
  369: 		    DPRINTF(("bank %b\n", l));
  370: 		/* Nonzero means enabled */
  371: 		    /* nonzero == enabled */
  372: 		    enable = (read_reg(s, MC3_BANKENB) & MC3_BENB(l, b));
[ 372] 0x900000001fc10e28:  00 00 28 25 move	a1,zero
[ 372] 0x900000001fc10e2c:  0f f0 24 8f jal		read_reg
[ 372] 0x900000001fc10e30:  02 c0 20 25 move	a0,s6
[ 372] 0x900000001fc10e34:  32 e6 00 02 andi	a2,s7,0x2
[ 372] 0x900000001fc10e38:  00 06 30 43 sra	a2,a2,1
[ 372] 0x900000001fc10e3c:  00 06 30 80 sll	a2,a2,2
[ 372] 0x900000001fc10e40:  df a7 00 48 ld	a3,72(sp)
[ 372] 0x900000001fc10e44:  00 c7 30 21 addu	a2,a2,a3
[ 372] 0x900000001fc10e48:  32 e7 00 01 andi	a3,s7,0x1
[ 372] 0x900000001fc10e4c:  00 c7 38 21 addu	a3,a2,a3
[ 372] 0x900000001fc10e50:  24 06 00 01 li	a2,1
  373: 		    DPRINTF(("Enable = %x\n", enable));
  374: 		    simm_type = read_reg(s, MC3_BANK(l, b, BANK_SIZE));
[ 374] 0x900000001fc10e54:  02 00 28 25 move	a1,s0
[ 374] 0x900000001fc10e58:  00 e6 30 04 sllv	a2,a2,a3
[ 374] 0x900000001fc10e5c:  00 46 a8 24 and	s5,v0,a2
[ 374] 0x900000001fc10e60:  0f f0 24 8f jal		read_reg
[ 374] 0x900000001fc10e64:  02 c0 20 25 move	a0,s6
[ 374] 0x900000001fc10e68:  00 02 a4 3c dsll32	s4,v0,16
  375: 		    DPRINTF(("Type = %x\n", simm_type));
  376: 		    i_factor = read_reg(s, MC3_BANK(l, b, BANK_IF));
[ 376] 0x900000001fc10e6c:  02 20 28 25 move	a1,s1
[ 376] 0x900000001fc10e70:  02 c0 20 25 move	a0,s6
[ 376] 0x900000001fc10e74:  0f f0 24 8f jal		read_reg
[ 376] 0x900000001fc10e78:  00 14 a4 3f dsra32	s4,s4,16
[ 376] 0x900000001fc10e7c:  ff b5 00 60 sd	s5,96(sp)
[ 376] 0x900000001fc10e80:  00 02 ac 3c dsll32	s5,v0,16
  377: 		    i_position = read_reg(s, MC3_BANK(l, b, BANK_IP));
[ 377] 0x900000001fc10e84:  02 40 28 25 move	a1,s2
[ 377] 0x900000001fc10e88:  0f f0 24 8f jal		read_reg
[ 377] 0x900000001fc10e8c:  02 c0 20 25 move	a0,s6
[ 377] 0x900000001fc10e90:  00 02 b4 3c dsll32	s6,v0,16
[ 377] 0x900000001fc10e94:  df a6 00 30 ld	a2,48(sp)
  378: 		    base_bloc = read_reg(s, MC3_BANK(l, b, BANK_BASE));
[ 378] 0x900000001fc10e98:  02 60 28 25 move	a1,s3
[ 378] 0x900000001fc10e9c:  0f f0 24 8f jal		read_reg
[ 378] 0x900000001fc10ea0:  00 c0 20 25 move	a0,a2
[ 378] 0x900000001fc10ea4:  df a5 00 08 ld	a1,8(sp)
[ 378] 0x900000001fc10ea8:  02 80 48 25 move	a5,s4
[ 378] 0x900000001fc10eac:  00 15 ac 3f dsra32	s5,s5,16
[ 378] 0x900000001fc10eb0:  df a6 00 60 ld	a2,96(sp)
[ 378] 0x900000001fc10eb4:  00 06 34 3c dsll32	a2,a2,16
[ 378] 0x900000001fc10eb8:  00 06 3c 3f dsra32	a3,a2,16
  379: 		    DPRINTF(("Base bloc = %x\n", base_bloc));
  380: 		    if (enable && in_bank(bloc, offset, base_bloc, i_factor,
[ 380] 0x900000001fc10ebc:  00 40 30 25 move	a2,v0
[ 380] 0x900000001fc10ec0:  10 e0 00 07 beq	a3,zero,0x900000001fc10ee0
[ 380] 0x900000001fc10ec4:  00 16 b4 3f dsra32	s6,s6,16
[ 380] 0x900000001fc10ec8:  02 c0 40 25 move	a4,s6
[ 380] 0x900000001fc10ecc:  02 a0 38 25 move	a3,s5
[ 380] 0x900000001fc10ed0:  0f f0 42 01 jal		in_bank
[ 380] 0x900000001fc10ed4:  df a4 00 00 ld	a0,0(sp)
[ 380] 0x900000001fc10ed8:  54 40 00 23 bnel	v0,zero,0x900000001fc10f68
[ 380] 0x900000001fc10edc:  df a6 00 40 ld	a2,64(sp)
[ 380] 0x900000001fc10ee0:  df b6 00 30 ld	s6,48(sp)
[ 368] 0x900000001fc10ee4:  26 f7 00 01 addiu	s7,s7,1
[ 368] 0x900000001fc10ee8:  26 10 00 04 addiu	s0,s0,4
[ 368] 0x900000001fc10eec:  26 31 00 04 addiu	s1,s1,4
[ 368] 0x900000001fc10ef0:  26 73 00 04 addiu	s3,s3,4
[ 368] 0x900000001fc10ef4:  16 7e ff cc bne	s3,s8,0x900000001fc10e28
[ 368] 0x900000001fc10ef8:  26 52 00 04 addiu	s2,s2,4
[ 368] 0x900000001fc10efc:  df b7 00 40 ld	s7,64(sp)
[ 368] 0x900000001fc10f00:  26 f9 00 01 addiu	t9,s7,1
[ 368] 0x900000001fc10f04:  df b8 00 48 ld	t8,72(sp)
[ 368] 0x900000001fc10f08:  df b7 00 50 ld	s7,80(sp)
[ 368] 0x900000001fc10f0c:  27 18 00 02 addiu	t8,t8,2
[ 368] 0x900000001fc10f10:  ff b9 00 40 sd	t9,64(sp)
[ 368] 0x900000001fc10f14:  26 f7 00 40 addiu	s7,s7,64
[ 368] 0x900000001fc10f18:  ff b8 00 48 sd	t8,72(sp)
[ 368] 0x900000001fc10f1c:  ff b7 00 50 sd	s7,80(sp)
[ 368] 0x900000001fc10f20:  00 00 b8 25 move	s7,zero
[ 366] 0x900000001fc10f24:  df be 00 50 ld	s8,80(sp)
[ 366] 0x900000001fc10f28:  df bf 00 58 ld	ra,88(sp)
[ 366] 0x900000001fc10f2c:  df a5 00 50 ld	a1,80(sp)
[ 366] 0x900000001fc10f30:  17 df ff b8 bne	s8,ra,0x900000001fc10e14
[ 366] 0x900000001fc10f34:  df b6 00 30 ld	s6,48(sp)
[ 362] 0x900000001fc10f38:  df a1 00 30 ld	at,48(sp)
[ 362] 0x900000001fc10f3c:  24 21 00 01 addiu	at,at,1
[ 362] 0x900000001fc10f40:  24 02 00 01 li	v0,1
[ 362] 0x900000001fc10f44:  00 22 20 04 sllv	a0,v0,at
[ 362] 0x900000001fc10f48:  df a3 00 28 ld	v1,40(sp)
[ 362] 0x900000001fc10f4c:  df a2 00 38 ld	v0,56(sp)
[ 362] 0x900000001fc10f50:  ff a1 00 30 sd	at,48(sp)
[ 362] 0x900000001fc10f54:  14 22 ff a5 bne	at,v0,0x900000001fc10dec
[ 362] 0x900000001fc10f58:  00 64 80 24 and	s0,v1,a0
  381: 					i_position, simm_type)) {
  382: 			/* We have a winner! */
  383: 			*slot = s;
  384: 			/* Banks are in order within the slots */
  385: 			DPRINTF(("Winner is slot %a, leaf %d, bank %d\n",
  386: 						s, l, b));
  387: 			*bank = b + (l * MC3_BANKS_PER_LEAF);
  388: 			/* Check which simm it's in:
  389: 			 * 	Each SIMM holds an eighth of cache line
  390: 			 *  so divide by 128/8 bytes (2^(7-3))
  391: 			 */
  392: 			*simm = (offset >> 4) & 0x3;
  393: 			return 0;
  394: 		    } else {
  395: 			DPRINTF(("Disabled!\n"));
  396: 		    } /* if enable... */
  397: 		}
  398: 	    }
  399: 	} /* If mem_slots... */
  400:     } /* for s */
  401: 
  402:     return -1;
[ 402] 0x900000001fc10f5c:  10 00 00 0f b		0x900000001fc10f9c
[ 402] 0x900000001fc10f60:  24 02 ff ff li	v0,-1
[ 387] 0x900000001fc10f64:  df a6 00 40 ld	a2,64(sp)
[ 392] 0x900000001fc10f68:  df a5 00 08 ld	a1,8(sp)
[ 392] 0x900000001fc10f6c:  df a9 00 10 ld	a5,16(sp)
[ 392] 0x900000001fc10f70:  00 06 30 80 sll	a2,a2,2
[ 392] 0x900000001fc10f74:  df a7 00 30 ld	a3,48(sp)
[ 392] 0x900000001fc10f78:  df a8 00 18 ld	a4,24(sp)
[ 392] 0x900000001fc10f7c:  00 05 29 02 srl	a1,a1,4
[ 392] 0x900000001fc10f80:  ad 27 00 00 sw	a3,0(a5)
[ 392] 0x900000001fc10f84:  02 e6 38 21 addu	a3,s7,a2
[ 392] 0x900000001fc10f88:  df a6 00 20 ld	a2,32(sp)
[ 392] 0x900000001fc10f8c:  30 a5 00 03 andi	a1,a1,0x3
[ 392] 0x900000001fc10f90:  ad 07 00 00 sw	a3,0(a4)
[ 393] 0x900000001fc10f94:  00 00 10 25 move	v0,zero
[ 393] 0x900000001fc10f98:  ac c5 00 00 sw	a1,0(a2)
[ 393] 0x900000001fc10f9c:  df b1 00 a0 ld	s1,160(sp)
[ 393] 0x900000001fc10fa0:  df b3 00 90 ld	s3,144(sp)
[ 393] 0x900000001fc10fa4:  df b5 00 80 ld	s5,128(sp)
[ 393] 0x900000001fc10fa8:  df be 00 68 ld	s8,104(sp)
[ 393] 0x900000001fc10fac:  df bf 00 b0 ld	ra,176(sp)
[ 393] 0x900000001fc10fb0:  df b6 00 78 ld	s6,120(sp)
[ 393] 0x900000001fc10fb4:  df b4 00 88 ld	s4,136(sp)
[ 393] 0x900000001fc10fb8:  df b2 00 98 ld	s2,152(sp)
[ 393] 0x900000001fc10fbc:  df b0 00 a8 ld	s0,168(sp)
[ 393] 0x900000001fc10fc0:  df b7 00 70 ld	s7,112(sp)
[ 393] 0x900000001fc10fc4:  03 e0 00 08 jr	ra
[ 393] 0x900000001fc10fc8:  67 bd 00 c0 daddiu	sp,sp,192
Skipping source listing to line 16 of /cores/banyan/stand/arcs/IP25prom/disp_evcfg.c...
   17: #include "prom_externs.h"
   18: 
   19: /*
   20:  * dump_evconfig
   21:  *	Prints out the contents of the everest configuration table.
   22:  */
   23: 
   24: static void 
   25: dump_general(evbrdinfo_t *brd)
   26: {
dump_general:
[  26] 0x900000001fc10fcc:  67 bd ff e0 daddiu	sp,sp,-32
[  26] 0x900000001fc10fd0:  ff b1 00 08 sd	s1,8(sp)
[  26] 0x900000001fc10fd4:  00 80 88 25 move	s1,a0
   27: 	int rev;
   28: 
   29: 	if (brd->eb_type != EVTYPE_IO4)
[  29] 0x900000001fc10fd8:  3c 01 90 00 lui	at,0x9000
[  29] 0x900000001fc10fdc:  60 21 00 00 daddi	at,at,0
[  29] 0x900000001fc10fe0:  3c 02 1f c2 lui	v0,0x1fc2
[  29] 0x900000001fc10fe4:  60 42 e5 60 daddi	v0,v0,-6816
[  29] 0x900000001fc10fe8:  00 01 08 3c dsll32	at,at,0
[  29] 0x900000001fc10fec:  ff b0 00 10 sd	s0,16(sp)
[  29] 0x900000001fc10ff0:  00 22 80 2c dadd	s0,at,v0
[  29] 0x900000001fc10ff4:  92 39 00 65 lbu	t9,101(s1)
[  29] 0x900000001fc10ff8:  24 02 00 21 li	v0,33
[  29] 0x900000001fc10ffc:  92 21 00 64 lbu	at,100(s1)
[  29] 0x900000001fc11000:  92 27 00 68 lbu	a3,104(s1)
[  29] 0x900000001fc11004:  14 22 00 07 bne	at,v0,0x900000001fc11024
[  29] 0x900000001fc11008:  03 20 28 25 move	a1,t9
[  29] 0x900000001fc1100c:  ff a7 00 00 sd	a3,0(sp)
   30: 		rev = brd->eb_rev;
   31: 	else
   32: 		rev = (brd->eb_rev & IO4_REV_MASK) >> IO4_REV_SHFT;
[  32] 0x900000001fc11010:  33 23 00 f0 andi	v1,t9,0xf0
[  32] 0x900000001fc11014:  66 08 00 40 daddiu	a4,s0,64
[  32] 0x900000001fc11018:  92 2b 00 66 lbu	a7,102(s1)
[  32] 0x900000001fc1101c:  10 00 00 04 b		0x900000001fc11030
[  32] 0x900000001fc11020:  00 03 29 03 sra	a1,v1,4
[  32] 0x900000001fc11024:  ff a7 00 00 sd	a3,0(sp)
[  30] 0x900000001fc11028:  66 08 00 40 daddiu	a4,s0,64
[  30] 0x900000001fc1102c:  92 2b 00 66 lbu	a7,102(s1)
   33: 	loprintf("   Rev: %d\tInventory: 0x%x    Diag Value: 0x%x, %s\n",
[  33] 0x900000001fc11030:  ff bf 00 18 sd	ra,24(sp)
[  33] 0x900000001fc11034:  11 60 00 03 beq	a7,zero,0x900000001fc11044
[  33] 0x900000001fc11038:  92 26 00 67 lbu	a2,103(s1)
[  33] 0x900000001fc1103c:  10 00 00 01 b		0x900000001fc11044
[  33] 0x900000001fc11040:  66 08 00 38 daddiu	a4,s0,56
[  33] 0x900000001fc11044:  0f f0 2c e3 jal		loprintf
[  33] 0x900000001fc11048:  02 00 20 25 move	a0,s0
   34: 		rev, brd->eb_inventory, brd->eb_diagval,
   35: 		(brd->eb_enabled ? "Enabled" : "Disabled"));
   36: 	if ((brd->eb_diagval != EVDIAG_PASSED) &&
[  36] 0x900000001fc1104c:  24 19 00 ff li	t9,255
[  36] 0x900000001fc11050:  92 27 00 68 lbu	a3,104(s1)
[  36] 0x900000001fc11054:  df b1 00 08 ld	s1,8(sp)
[  36] 0x900000001fc11058:  50 e0 00 09 beql	a3,zero,0x900000001fc11080
[  36] 0x900000001fc1105c:  df bf 00 18 ld	ra,24(sp)
[  36] 0x900000001fc11060:  50 f9 00 07 beql	a3,t9,0x900000001fc11080
[  36] 0x900000001fc11064:  df bf 00 18 ld	ra,24(sp)
   37: 					(brd->eb_diagval != EVDIAG_NOT_PRESENT))
   38: 		loprintf("  *** %s\n", get_diag_string(brd->eb_diagval));
[  38] 0x900000001fc11068:  0f f0 3f 6c jal		get_diag_string
[  38] 0x900000001fc1106c:  00 e0 20 25 move	a0,a3
[  38] 0x900000001fc11070:  00 40 28 25 move	a1,v0
[  38] 0x900000001fc11074:  0f f0 2c e3 jal		loprintf
[  38] 0x900000001fc11078:  66 04 00 50 daddiu	a0,s0,80
[  38] 0x900000001fc1107c:  df bf 00 18 ld	ra,24(sp)
[  38] 0x900000001fc11080:  df b0 00 10 ld	s0,16(sp)
[  38] 0x900000001fc11084:  03 e0 00 08 jr	ra
[  38] 0x900000001fc11088:  67 bd 00 20 daddiu	sp,sp,32
   39: }
   40: 
   41:  
   42: static void 
   43: dump_ip(evbrdinfo_t *brd)
   44: {
dump_ip:
[  44] 0x900000001fc1108c:  67 bd ff 90 daddiu	sp,sp,-112
   45: 	int i;
   46: 	evcpucfg_t *cpu;
   47: 
   48: 	dump_general(brd);
[  48] 0x900000001fc11090:  ff b1 00 50 sd	s1,80(sp)
[  48] 0x900000001fc11094:  ff bf 00 60 sd	ra,96(sp)
[  48] 0x900000001fc11098:  0f f0 43 f3 jal		dump_general
[  48] 0x900000001fc1109c:  00 80 88 25 move	s1,a0
   49: 
   50: 	for (i = 0; i < EV_CPU_PER_BOARD; i++) {
[  50] 0x900000001fc110a0:  ff b3 00 40 sd	s3,64(sp)
[  50] 0x900000001fc110a4:  00 00 98 25 move	s3,zero
[  50] 0x900000001fc110a8:  ff b5 00 30 sd	s5,48(sp)
[  50] 0x900000001fc110ac:  24 15 00 ff li	s5,255
[  50] 0x900000001fc110b0:  ff b4 00 38 sd	s4,56(sp)
[  50] 0x900000001fc110b4:  66 34 00 40 daddiu	s4,s1,64
[  50] 0x900000001fc110b8:  3c 02 90 00 lui	v0,0x9000
[  50] 0x900000001fc110bc:  3c 01 90 00 lui	at,0x9000
[  50] 0x900000001fc110c0:  60 43 00 00 daddi	v1,v0,0
[  50] 0x900000001fc110c4:  60 22 00 00 daddi	v0,at,0
[  50] 0x900000001fc110c8:  3c 01 90 00 lui	at,0x9000
[  50] 0x900000001fc110cc:  3c 04 90 00 lui	a0,0x9000
[  50] 0x900000001fc110d0:  60 21 00 00 daddi	at,at,0
[  50] 0x900000001fc110d4:  60 88 00 00 daddi	a4,a0,0
[  50] 0x900000001fc110d8:  3c 05 90 00 lui	a1,0x9000
[  50] 0x900000001fc110dc:  3c 04 1f c2 lui	a0,0x1fc2
[  50] 0x900000001fc110e0:  60 a6 00 00 daddi	a2,a1,0
[  50] 0x900000001fc110e4:  60 8c e6 00 daddi	t0,a0,-6656
[  50] 0x900000001fc110e8:  3c 04 90 00 lui	a0,0x9000
[  50] 0x900000001fc110ec:  3c 05 1f c2 lui	a1,0x1fc2
[  50] 0x900000001fc110f0:  60 84 00 00 daddi	a0,a0,0
[  50] 0x900000001fc110f4:  60 ab e6 68 daddi	a7,a1,-6552
[  50] 0x900000001fc110f8:  3c 07 1f c2 lui	a3,0x1fc2
[  50] 0x900000001fc110fc:  3c 05 1f c2 lui	a1,0x1fc2
[  50] 0x900000001fc11100:  60 ea e6 10 daddi	a6,a3,-6640
[  50] 0x900000001fc11104:  60 a9 e6 78 daddi	a5,a1,-6536
[  50] 0x900000001fc11108:  3c 05 1f c2 lui	a1,0x1fc2
[  50] 0x900000001fc1110c:  00 03 18 3c dsll32	v1,v1,0
[  50] 0x900000001fc11110:  60 a7 e5 c0 daddi	a3,a1,-6720
[  50] 0x900000001fc11114:  ff be 00 18 sd	s8,24(sp)
[  50] 0x900000001fc11118:  00 02 10 3c dsll32	v0,v0,0
[  50] 0x900000001fc1111c:  3c 05 1f c2 lui	a1,0x1fc2
[  50] 0x900000001fc11120:  ff b7 00 20 sd	s7,32(sp)
[  50] 0x900000001fc11124:  00 01 08 3c dsll32	at,at,0
[  50] 0x900000001fc11128:  60 a5 e6 60 daddi	a1,a1,-6560
[  50] 0x900000001fc1112c:  ff b6 00 28 sd	s6,40(sp)
[  50] 0x900000001fc11130:  00 08 40 3c dsll32	a4,a4,0
[  50] 0x900000001fc11134:  ff b2 00 48 sd	s2,72(sp)
[  50] 0x900000001fc11138:  00 06 30 3c dsll32	a2,a2,0
[  50] 0x900000001fc1113c:  00 6c 18 2c dadd	v1,v1,t0
[  50] 0x900000001fc11140:  ff b0 00 58 sd	s0,88(sp)
[  50] 0x900000001fc11144:  00 04 20 3c dsll32	a0,a0,0
[  50] 0x900000001fc11148:  00 4b 10 2c dadd	v0,v0,a7
[  50] 0x900000001fc1114c:  ff a3 00 00 sd	v1,0(sp)
[  50] 0x900000001fc11150:  00 2a 08 2c dadd	at,at,a6
[  50] 0x900000001fc11154:  01 09 b0 2c dadd	s6,a4,a5
[  50] 0x900000001fc11158:  ff a2 00 08 sd	v0,8(sp)
[  50] 0x900000001fc1115c:  00 c7 b8 2c dadd	s7,a2,a3
[  50] 0x900000001fc11160:  00 85 f0 2c dadd	s8,a0,a1
[  50] 0x900000001fc11164:  ff a1 00 10 sd	at,16(sp)
[  50] 0x900000001fc11168:  02 20 90 25 move	s2,s1
   51: 		cpu = &(brd->eb_cpuarr[i]);
   52: 		if (cpu->cpu_diagval != EVDIAG_NOTFOUND) {
[  52] 0x900000001fc1116c:  92 30 00 0b lbu	s0,11(s1)
[  51] 0x900000001fc11170:  56 15 00 09 bnel	s0,s5,0x900000001fc11198
[  51] 0x900000001fc11174:  02 00 38 25 move	a3,s0
   53: 			loprintf("        CPU %d: Inventory 0x%b, "
   54: 				 "DiagVal 0x%b, Info 0x%b\n",
   55: 		      		i, cpu->cpu_inventory, cpu->cpu_diagval, 
   56: 				cpu->cpu_info);
   57: 			if (cpu->cpu_diagval != EVDIAG_PASSED)
   58: 				loprintf("        *** %s\n",
   59: 					get_diag_string(cpu->cpu_diagval));
   60: 			loprintf("               Virt. #%d, Speed %d MHz, "
   61: 				 "Cache Size %d kB, Prom rev %d, %s\n",
   62: 				cpu->cpu_vpid, cpu->cpu_speed * 2, 
   63: 				1 << (cpu->cpu_cachesz - 10),
   64: 				(cpu->cpu_promrev),
   65: 				(cpu->cpu_enable ? "Enabled" : "Disabled"));
   66: 		} else {
   67: 			loprintf("        CPU %d: Not populated\n", i);
[  67] 0x900000001fc11178:  02 c0 20 25 move	a0,s6
[  67] 0x900000001fc1117c:  02 60 28 25 move	a1,s3
[  67] 0x900000001fc11180:  0f f0 2c e3 jal		loprintf
[  67] 0x900000001fc11184:  66 31 00 10 daddiu	s1,s1,16
[  67] 0x900000001fc11188:  26 73 00 01 addiu	s3,s3,1
[  67] 0x900000001fc1118c:  10 00 00 22 b		0x900000001fc11218
[  67] 0x900000001fc11190:  00 00 00 21 nada
[  53] 0x900000001fc11194:  02 00 38 25 move	a3,s0
[  53] 0x900000001fc11198:  92 46 00 0a lbu	a2,10(s2)
[  53] 0x900000001fc1119c:  92 48 00 08 lbu	a4,8(s2)
[  53] 0x900000001fc111a0:  02 60 28 25 move	a1,s3
[  53] 0x900000001fc111a4:  0f f0 2c e3 jal		loprintf
[  53] 0x900000001fc111a8:  02 e0 20 25 move	a0,s7
[  57] 0x900000001fc111ac:  92 50 00 0b lbu	s0,11(s2)
[  57] 0x900000001fc111b0:  52 00 00 07 beql	s0,zero,0x900000001fc111d0
[  57] 0x900000001fc111b4:  df ae 00 08 ld	t2,8(sp)
[  58] 0x900000001fc111b8:  0f f0 3f 6c jal		get_diag_string
[  58] 0x900000001fc111bc:  02 00 20 25 move	a0,s0
[  58] 0x900000001fc111c0:  00 40 28 25 move	a1,v0
[  58] 0x900000001fc111c4:  0f f0 2c e3 jal		loprintf
[  58] 0x900000001fc111c8:  df a4 00 00 ld	a0,0(sp)
[  58] 0x900000001fc111cc:  df ae 00 08 ld	t2,8(sp)
[  60] 0x900000001fc111d0:  92 4d 00 0e lbu	t1,14(s2)
[  60] 0x900000001fc111d4:  01 c0 48 25 move	a5,t2
[  60] 0x900000001fc111d8:  25 ae ff f6 addiu	t2,t1,-10
[  60] 0x900000001fc111dc:  92 4f 00 0d lbu	t3,13(s2)
[  60] 0x900000001fc111e0:  92 4d 00 09 lbu	t1,9(s2)
[  60] 0x900000001fc111e4:  92 45 00 0c lbu	a1,12(s2)
[  60] 0x900000001fc111e8:  01 ef 30 21 addu	a2,t3,t3
[  60] 0x900000001fc111ec:  03 cd 48 0b movn	a5,s8,t1
[  60] 0x900000001fc111f0:  00 00 00 21 nada
[  60] 0x900000001fc111f4:  00 00 00 21 nada
[  60] 0x900000001fc111f8:  00 00 00 21 nada
[  60] 0x900000001fc111fc:  92 48 00 0f lbu	a4,15(s2)
[  60] 0x900000001fc11200:  df a4 00 10 ld	a0,16(sp)
[  60] 0x900000001fc11204:  24 0d 00 01 li	t1,1
[  60] 0x900000001fc11208:  0f f0 2c e3 jal		loprintf
[  60] 0x900000001fc1120c:  01 cd 38 04 sllv	a3,t1,t2
[  60] 0x900000001fc11210:  66 31 00 10 daddiu	s1,s1,16
[  60] 0x900000001fc11214:  26 73 00 01 addiu	s3,s3,1
[  50] 0x900000001fc11218:  56 34 ff d4 bnel	s1,s4,0x900000001fc1116c
[  50] 0x900000001fc1121c:  02 20 90 25 move	s2,s1
[  50] 0x900000001fc11220:  df b3 00 40 ld	s3,64(sp)
[  50] 0x900000001fc11224:  df b1 00 50 ld	s1,80(sp)
[  50] 0x900000001fc11228:  df b5 00 30 ld	s5,48(sp)
[  50] 0x900000001fc1122c:  df be 00 18 ld	s8,24(sp)
[  50] 0x900000001fc11230:  df bf 00 60 ld	ra,96(sp)
[  50] 0x900000001fc11234:  df b6 00 28 ld	s6,40(sp)
[  50] 0x900000001fc11238:  df b4 00 38 ld	s4,56(sp)
[  50] 0x900000001fc1123c:  df b2 00 48 ld	s2,72(sp)
[  50] 0x900000001fc11240:  df b0 00 58 ld	s0,88(sp)
[  50] 0x900000001fc11244:  df b7 00 20 ld	s7,32(sp)
[  50] 0x900000001fc11248:  03 e0 00 08 jr	ra
[  50] 0x900000001fc1124c:  67 bd 00 70 daddiu	sp,sp,112
   68: 		}
   69: 	} 
   70: }
   71: 
   72: static void 
   73: dump_io4(evbrdinfo_t *brd)
   74: {
dump_io4:
[  74] 0x900000001fc11250:  67 bd ff 70 daddiu	sp,sp,-144
   75: 	int i;
   76: 	evioacfg_t *ioa;
   77: 
   78: 	dump_general(brd);
[  78] 0x900000001fc11254:  ff b0 00 78 sd	s0,120(sp)
[  78] 0x900000001fc11258:  ff bf 00 80 sd	ra,128(sp)
[  78] 0x900000001fc1125c:  0f f0 43 f3 jal		dump_general
[  78] 0x900000001fc11260:  00 80 80 25 move	s0,a0
   79: 	loprintf("  Window Number: %d\n", brd->eb_io.eb_winnum);
[  79] 0x900000001fc11264:  3c 01 90 00 lui	at,0x9000
[  79] 0x900000001fc11268:  3c 02 1f c2 lui	v0,0x1fc2
[  79] 0x900000001fc1126c:  60 21 00 00 daddi	at,at,0
[  79] 0x900000001fc11270:  60 42 e6 98 daddi	v0,v0,-6504
[  79] 0x900000001fc11274:  92 05 00 60 lbu	a1,96(s0)
[  79] 0x900000001fc11278:  00 01 08 3c dsll32	at,at,0
[  79] 0x900000001fc1127c:  0f f0 2c e3 jal		loprintf
[  79] 0x900000001fc11280:  00 22 20 2c dadd	a0,at,v0
   80: 
   81: 	for (i = 1; i < IO4_MAX_PADAPS; i++) {
[  81] 0x900000001fc11284:  ff b3 00 60 sd	s3,96(sp)
[  81] 0x900000001fc11288:  24 13 00 01 li	s3,1
[  81] 0x900000001fc1128c:  ff b2 00 68 sd	s2,104(sp)
[  81] 0x900000001fc11290:  66 12 00 0c daddiu	s2,s0,12
[  81] 0x900000001fc11294:  3c 01 90 00 lui	at,0x9000
[  81] 0x900000001fc11298:  ff be 00 38 sd	s8,56(sp)
[  81] 0x900000001fc1129c:  66 1e 00 60 daddiu	s8,s0,96
[  81] 0x900000001fc112a0:  60 26 00 00 daddi	a2,at,0
[  81] 0x900000001fc112a4:  3c 02 90 00 lui	v0,0x9000
[  81] 0x900000001fc112a8:  3c 01 90 00 lui	at,0x9000
[  81] 0x900000001fc112ac:  60 45 00 00 daddi	a1,v0,0
[  81] 0x900000001fc112b0:  60 24 00 00 daddi	a0,at,0
[  81] 0x900000001fc112b4:  3c 02 90 00 lui	v0,0x9000
[  81] 0x900000001fc112b8:  3c 01 90 00 lui	at,0x9000
[  81] 0x900000001fc112bc:  60 43 00 00 daddi	v1,v0,0
[  81] 0x900000001fc112c0:  60 22 00 00 daddi	v0,at,0
[  81] 0x900000001fc112c4:  3c 01 90 00 lui	at,0x9000
[  81] 0x900000001fc112c8:  3c 07 90 00 lui	a3,0x9000
[  81] 0x900000001fc112cc:  60 21 00 00 daddi	at,at,0
[  81] 0x900000001fc112d0:  60 ed 00 00 daddi	t1,a3,0
[  81] 0x900000001fc112d4:  3c 08 1f c2 lui	a4,0x1fc2
[  81] 0x900000001fc112d8:  3c 07 1f c2 lui	a3,0x1fc2
[  81] 0x900000001fc112dc:  ff b6 00 48 sd	s6,72(sp)
[  81] 0x900000001fc112e0:  61 16 e6 d0 daddi	s6,a4,-6448
[  81] 0x900000001fc112e4:  ff b5 00 50 sd	s5,80(sp)
[  81] 0x900000001fc112e8:  60 f5 e6 c7 daddi	s5,a3,-6457
[  81] 0x900000001fc112ec:  3c 08 1f c2 lui	a4,0x1fc2
[  81] 0x900000001fc112f0:  3c 07 1f c2 lui	a3,0x1fc2
[  81] 0x900000001fc112f4:  ff b4 00 58 sd	s4,88(sp)
[  81] 0x900000001fc112f8:  61 14 e6 c3 daddi	s4,a4,-6461
[  81] 0x900000001fc112fc:  ff b1 00 70 sd	s1,112(sp)
[  81] 0x900000001fc11300:  60 f1 e6 cb daddi	s1,a3,-6453
[  81] 0x900000001fc11304:  3c 08 1f c2 lui	a4,0x1fc2
[  81] 0x900000001fc11308:  3c 07 90 00 lui	a3,0x9000
[  81] 0x900000001fc1130c:  61 10 e6 e0 daddi	s0,a4,-6432
[  81] 0x900000001fc11310:  60 eb 00 00 daddi	a7,a3,0
[  81] 0x900000001fc11314:  3c 08 90 00 lui	a4,0x9000
[  81] 0x900000001fc11318:  3c 07 90 00 lui	a3,0x9000
[  81] 0x900000001fc1131c:  61 09 00 00 daddi	a5,a4,0
[  81] 0x900000001fc11320:  60 e7 00 00 daddi	a3,a3,0
[  81] 0x900000001fc11324:  3c 0a 1f c2 lui	a6,0x1fc2
[  81] 0x900000001fc11328:  3c 08 1f c2 lui	a4,0x1fc2
[  81] 0x900000001fc1132c:  61 4f e7 38 daddi	t3,a6,-6344
[  81] 0x900000001fc11330:  61 0e e6 b0 daddi	t2,a4,-6480
[  81] 0x900000001fc11334:  3c 08 1f c2 lui	a4,0x1fc2
[  81] 0x900000001fc11338:  00 06 30 3c dsll32	a2,a2,0
[  81] 0x900000001fc1133c:  61 0c e7 20 daddi	t0,a4,-6368
[  81] 0x900000001fc11340:  00 05 28 3c dsll32	a1,a1,0
[  81] 0x900000001fc11344:  3c 08 1f c2 lui	a4,0x1fc2
[  81] 0x900000001fc11348:  00 04 20 3c dsll32	a0,a0,0
[  81] 0x900000001fc1134c:  61 0a e7 28 daddi	a6,a4,-6360
[  81] 0x900000001fc11350:  00 03 18 3c dsll32	v1,v1,0
[  81] 0x900000001fc11354:  3c 08 1f c2 lui	a4,0x1fc2
[  81] 0x900000001fc11358:  00 02 10 3c dsll32	v0,v0,0
[  81] 0x900000001fc1135c:  61 08 e6 e8 daddi	a4,a4,-6424
[  81] 0x900000001fc11360:  00 01 08 3c dsll32	at,at,0
[  81] 0x900000001fc11364:  00 0d 68 3c dsll32	t1,t1,0
[  81] 0x900000001fc11368:  00 d6 30 2c dadd	a2,a2,s6
[  81] 0x900000001fc1136c:  ff b7 00 40 sd	s7,64(sp)
[  81] 0x900000001fc11370:  00 0b 58 3c dsll32	a7,a7,0
[  81] 0x900000001fc11374:  00 b5 28 2c dadd	a1,a1,s5
[  81] 0x900000001fc11378:  ff a6 00 08 sd	a2,8(sp)
[  81] 0x900000001fc1137c:  00 09 48 3c dsll32	a5,a5,0
[  81] 0x900000001fc11380:  00 94 20 2c dadd	a0,a0,s4
[  81] 0x900000001fc11384:  ff a5 00 10 sd	a1,16(sp)
[  81] 0x900000001fc11388:  00 07 38 3c dsll32	a3,a3,0
[  81] 0x900000001fc1138c:  00 71 18 2c dadd	v1,v1,s1
[  81] 0x900000001fc11390:  ff a4 00 18 sd	a0,24(sp)
[  81] 0x900000001fc11394:  00 50 10 2c dadd	v0,v0,s0
[  81] 0x900000001fc11398:  00 2f 08 2c dadd	at,at,t3
[  81] 0x900000001fc1139c:  ff a3 00 20 sd	v1,32(sp)
[  81] 0x900000001fc113a0:  01 ae a0 2c dadd	s4,t1,t2
[  81] 0x900000001fc113a4:  01 6c a8 2c dadd	s5,a7,t0
[  81] 0x900000001fc113a8:  ff a2 00 28 sd	v0,40(sp)
[  81] 0x900000001fc113ac:  01 2a b0 2c dadd	s6,a5,a6
[  81] 0x900000001fc113b0:  00 e8 b8 2c dadd	s7,a3,a4
[  81] 0x900000001fc113b4:  ff a1 00 30 sd	at,48(sp)
   82: 	
   83: 		ioa = &(brd->eb_ioarr[i]);
   84: 
   85: 		loprintf("        PADAP %d: ", i);
[  85] 0x900000001fc113b8:  02 60 28 25 move	a1,s3
[  85] 0x900000001fc113bc:  0f f0 2c e3 jal		loprintf
[  85] 0x900000001fc113c0:  02 80 20 25 move	a0,s4
   86: 		switch(ioa->ioa_type) {
[  86] 0x900000001fc113c4:  92 59 00 07 lbu	t9,7(s2)
[  83] 0x900000001fc113c8:  02 40 88 25 move	s1,s2
[  83] 0x900000001fc113cc:  57 20 00 0a bnel	t9,zero,0x900000001fc113f8
[  83] 0x900000001fc113d0:  24 18 00 0d li	t8,13
   87: 		  case IO4_ADAP_EPC:
   88: 			loprintf("EPC");
   89: 			break;
   90: 		  case IO4_ADAP_SCSI:
   91: 			loprintf("S1 ");
   92: 			break;
   93: 		  case IO4_ADAP_FCHIP:
   94: 			loprintf("F  ");
   95: 			break;
   96: 		  case 0:
   97: 			loprintf("Not populated.\n");
[  97] 0x900000001fc113d4:  0f f0 2c e3 jal		loprintf
[  97] 0x900000001fc113d8:  df a4 00 08 ld	a0,8(sp)
   98: 			break;
[  98] 0x900000001fc113dc:  92 39 00 07 lbu	t9,7(s1)
[  98] 0x900000001fc113e0:  92 2b 00 04 lbu	a7,4(s1)
[  98] 0x900000001fc113e4:  92 26 00 05 lbu	a2,5(s1)
[  98] 0x900000001fc113e8:  92 30 00 06 lbu	s0,6(s1)
[  98] 0x900000001fc113ec:  10 00 00 28 b		0x900000001fc11490
[  98] 0x900000001fc113f0:  92 28 00 08 lbu	a4,8(s1)
[  98] 0x900000001fc113f4:  24 18 00 0d li	t8,13
[  98] 0x900000001fc113f8:  57 38 00 0a bnel	t9,t8,0x900000001fc11424
[  98] 0x900000001fc113fc:  24 1f 00 0e li	ra,14
[  91] 0x900000001fc11400:  0f f0 2c e3 jal		loprintf
[  91] 0x900000001fc11404:  df a4 00 10 ld	a0,16(sp)
[  92] 0x900000001fc11408:  92 39 00 07 lbu	t9,7(s1)
[  92] 0x900000001fc1140c:  92 2b 00 04 lbu	a7,4(s1)
[  92] 0x900000001fc11410:  92 26 00 05 lbu	a2,5(s1)
[  92] 0x900000001fc11414:  92 30 00 06 lbu	s0,6(s1)
[  92] 0x900000001fc11418:  10 00 00 1d b		0x900000001fc11490
[  92] 0x900000001fc1141c:  92 28 00 08 lbu	a4,8(s1)
[  92] 0x900000001fc11420:  24 1f 00 0e li	ra,14
[  92] 0x900000001fc11424:  17 3f 00 09 bne	t9,ra,0x900000001fc1144c
[  92] 0x900000001fc11428:  24 05 00 0f li	a1,15
[  88] 0x900000001fc1142c:  0f f0 2c e3 jal		loprintf
[  88] 0x900000001fc11430:  df a4 00 18 ld	a0,24(sp)
[  89] 0x900000001fc11434:  92 39 00 07 lbu	t9,7(s1)
[  89] 0x900000001fc11438:  92 2b 00 04 lbu	a7,4(s1)
[  89] 0x900000001fc1143c:  92 26 00 05 lbu	a2,5(s1)
[  89] 0x900000001fc11440:  92 30 00 06 lbu	s0,6(s1)
[  89] 0x900000001fc11444:  10 00 00 12 b		0x900000001fc11490
[  89] 0x900000001fc11448:  92 28 00 08 lbu	a4,8(s1)
[  89] 0x900000001fc1144c:  17 25 00 09 bne	t9,a1,0x900000001fc11474
[  89] 0x900000001fc11450:  00 00 00 21 nada
[  94] 0x900000001fc11454:  0f f0 2c e3 jal		loprintf
[  94] 0x900000001fc11458:  df a4 00 20 ld	a0,32(sp)
[  95] 0x900000001fc1145c:  92 39 00 07 lbu	t9,7(s1)
[  95] 0x900000001fc11460:  92 2b 00 04 lbu	a7,4(s1)
[  95] 0x900000001fc11464:  92 26 00 05 lbu	a2,5(s1)
[  95] 0x900000001fc11468:  92 30 00 06 lbu	s0,6(s1)
[  95] 0x900000001fc1146c:  10 00 00 08 b		0x900000001fc11490
[  95] 0x900000001fc11470:  92 28 00 08 lbu	a4,8(s1)
   99: 		  default:
  100: 			loprintf("???");
[ 100] 0x900000001fc11474:  0f f0 2c e3 jal		loprintf
[ 100] 0x900000001fc11478:  df a4 00 28 ld	a0,40(sp)
  101: 			break;
[ 101] 0x900000001fc1147c:  92 39 00 07 lbu	t9,7(s1)
[ 101] 0x900000001fc11480:  92 2b 00 04 lbu	a7,4(s1)
[ 101] 0x900000001fc11484:  92 26 00 05 lbu	a2,5(s1)
[ 101] 0x900000001fc11488:  92 30 00 06 lbu	s0,6(s1)
[ 101] 0x900000001fc1148c:  92 28 00 08 lbu	a4,8(s1)
  102: 		}
  103: 
  104: 		loprintf(" (0x%b), Inventory 0x%b, DiagVal 0x%b, VirtID %d, %s\n",
[ 104] 0x900000001fc11490:  02 c0 48 25 move	a5,s6
[ 104] 0x900000001fc11494:  02 00 38 25 move	a3,s0
[ 104] 0x900000001fc11498:  03 20 28 25 move	a1,t9
[ 104] 0x900000001fc1149c:  02 e0 20 25 move	a0,s7
[ 104] 0x900000001fc114a0:  0f f0 2c e3 jal		loprintf
[ 104] 0x900000001fc114a4:  02 ab 48 0b movn	a5,s5,a7
[ 104] 0x900000001fc114a8:  00 00 00 21 nada
[ 104] 0x900000001fc114ac:  00 00 00 21 nada
[ 104] 0x900000001fc114b0:  00 00 00 21 nada
  105: 			ioa->ioa_type, ioa->ioa_inventory, 
  106: 			ioa->ioa_diagval, ioa->ioa_virtid, 
  107: 			(ioa->ioa_enable ? "Enabled" : "Disabled"));
  108: 			if (ioa->ioa_diagval != EVDIAG_PASSED)
[ 108] 0x900000001fc114b4:  92 30 00 06 lbu	s0,6(s1)
[ 108] 0x900000001fc114b8:  12 00 00 06 beq	s0,zero,0x900000001fc114d4
[ 108] 0x900000001fc114bc:  66 52 00 0c daddiu	s2,s2,12
  109: 				loprintf("        *** %s\n",
[ 109] 0x900000001fc114c0:  0f f0 3f 6c jal		get_diag_string
[ 109] 0x900000001fc114c4:  02 00 20 25 move	a0,s0
[ 109] 0x900000001fc114c8:  00 40 28 25 move	a1,v0
[ 109] 0x900000001fc114cc:  0f f0 2c e3 jal		loprintf
[ 109] 0x900000001fc114d0:  df a4 00 30 ld	a0,48(sp)
[  81] 0x900000001fc114d4:  16 5e ff b8 bne	s2,s8,0x900000001fc113b8
[  81] 0x900000001fc114d8:  26 73 00 01 addiu	s3,s3,1
[  81] 0x900000001fc114dc:  df b3 00 60 ld	s3,96(sp)
[  81] 0x900000001fc114e0:  df b1 00 70 ld	s1,112(sp)
[  81] 0x900000001fc114e4:  df b5 00 50 ld	s5,80(sp)
[  81] 0x900000001fc114e8:  df be 00 38 ld	s8,56(sp)
[  81] 0x900000001fc114ec:  df bf 00 80 ld	ra,128(sp)
[  81] 0x900000001fc114f0:  df b6 00 48 ld	s6,72(sp)
[  81] 0x900000001fc114f4:  df b4 00 58 ld	s4,88(sp)
[  81] 0x900000001fc114f8:  df b2 00 68 ld	s2,104(sp)
[  81] 0x900000001fc114fc:  df b0 00 78 ld	s0,120(sp)
[  81] 0x900000001fc11500:  df b7 00 40 ld	s7,64(sp)
[  81] 0x900000001fc11504:  03 e0 00 08 jr	ra
[  81] 0x900000001fc11508:  67 bd 00 90 daddiu	sp,sp,144
  110: 					get_diag_string(ioa->ioa_diagval));
  111: 	}
  112: }
  113: 
  114: 
  115: static void 
  116: dump_mc3(evbrdinfo_t *brd)
  117: {
dump_mc3:
[ 117] 0x900000001fc1150c:  67 bd ff a0 daddiu	sp,sp,-96
  118: 	int i;
  119: 	evbnkcfg_t *mem;
  120: 
  121: 	dump_general(brd);
[ 121] 0x900000001fc11510:  ff b2 00 40 sd	s2,64(sp)
[ 121] 0x900000001fc11514:  ff bf 00 58 sd	ra,88(sp)
[ 121] 0x900000001fc11518:  0f f0 43 f3 jal		dump_general
[ 121] 0x900000001fc1151c:  00 80 90 25 move	s2,a0
  122: 
  123: 	for (i = 0; i < MC3_NUM_BANKS; i++) {
[ 123] 0x900000001fc11520:  ff b1 00 48 sd	s1,72(sp)
[ 123] 0x900000001fc11524:  00 00 88 25 move	s1,zero
[ 123] 0x900000001fc11528:  ff b4 00 30 sd	s4,48(sp)
[ 123] 0x900000001fc1152c:  24 14 00 07 li	s4,7
[ 123] 0x900000001fc11530:  3c 01 90 00 lui	at,0x9000
[ 123] 0x900000001fc11534:  ff b3 00 38 sd	s3,56(sp)
[ 123] 0x900000001fc11538:  66 53 00 60 daddiu	s3,s2,96
[ 123] 0x900000001fc1153c:  60 22 00 00 daddi	v0,at,0
[ 123] 0x900000001fc11540:  3c 01 90 00 lui	at,0x9000
[ 123] 0x900000001fc11544:  3c 03 90 00 lui	v1,0x9000
[ 123] 0x900000001fc11548:  60 21 00 00 daddi	at,at,0
[ 123] 0x900000001fc1154c:  60 69 00 00 daddi	a5,v1,0
[ 123] 0x900000001fc11550:  3c 04 90 00 lui	a0,0x9000
[ 123] 0x900000001fc11554:  3c 03 90 00 lui	v1,0x9000
[ 123] 0x900000001fc11558:  60 87 00 00 daddi	a3,a0,0
[ 123] 0x900000001fc1155c:  60 65 00 00 daddi	a1,v1,0
[ 123] 0x900000001fc11560:  3c 03 90 00 lui	v1,0x9000
[ 123] 0x900000001fc11564:  3c 04 1f c2 lui	a0,0x1fc2
[ 123] 0x900000001fc11568:  60 63 00 00 daddi	v1,v1,0
[ 123] 0x900000001fc1156c:  60 8c e7 80 daddi	t0,a0,-6272
[ 123] 0x900000001fc11570:  3c 06 1f c2 lui	a2,0x1fc2
[ 123] 0x900000001fc11574:  3c 04 1f c2 lui	a0,0x1fc2
[ 123] 0x900000001fc11578:  60 cb e7 d0 daddi	a7,a2,-6192
[ 123] 0x900000001fc1157c:  60 8a e7 e0 daddi	a6,a0,-6176
[ 123] 0x900000001fc11580:  3c 04 1f c2 lui	a0,0x1fc2
[ 123] 0x900000001fc11584:  00 02 10 3c dsll32	v0,v0,0
[ 123] 0x900000001fc11588:  60 88 e7 48 daddi	a4,a0,-6328
[ 123] 0x900000001fc1158c:  00 01 08 3c dsll32	at,at,0
[ 123] 0x900000001fc11590:  3c 04 1f c2 lui	a0,0x1fc2
[ 123] 0x900000001fc11594:  00 09 48 3c dsll32	a5,a5,0
[ 123] 0x900000001fc11598:  60 86 e7 b8 daddi	a2,a0,-6216
[ 123] 0x900000001fc1159c:  00 07 38 3c dsll32	a3,a3,0
[ 123] 0x900000001fc115a0:  ff be 00 10 sd	s8,16(sp)
[ 123] 0x900000001fc115a4:  3c 04 1f c2 lui	a0,0x1fc2
[ 123] 0x900000001fc115a8:  00 05 28 3c dsll32	a1,a1,0
[ 123] 0x900000001fc115ac:  ff b7 00 18 sd	s7,24(sp)
[ 123] 0x900000001fc115b0:  60 84 e7 c0 daddi	a0,a0,-6208
[ 123] 0x900000001fc115b4:  00 03 18 3c dsll32	v1,v1,0
[ 123] 0x900000001fc115b8:  ff b6 00 20 sd	s6,32(sp)
[ 123] 0x900000001fc115bc:  00 4c 10 2c dadd	v0,v0,t0
[ 123] 0x900000001fc115c0:  00 2b 08 2c dadd	at,at,a7
[ 123] 0x900000001fc115c4:  ff b5 00 28 sd	s5,40(sp)
[ 123] 0x900000001fc115c8:  01 2a a8 2c dadd	s5,a5,a6
[ 123] 0x900000001fc115cc:  ff b0 00 50 sd	s0,80(sp)
[ 123] 0x900000001fc115d0:  00 e8 b0 2c dadd	s6,a3,a4
[ 123] 0x900000001fc115d4:  ff a2 00 00 sd	v0,0(sp)
[ 123] 0x900000001fc115d8:  00 a6 b8 2c dadd	s7,a1,a2
[ 123] 0x900000001fc115dc:  00 64 f0 2c dadd	s8,v1,a0
[ 123] 0x900000001fc115e0:  ff a1 00 08 sd	at,8(sp)
  124: 		mem = &(brd->eb_banks[i]);
  125: 		if (mem->bnk_size != MC3_NOBANK) {
[ 125] 0x900000001fc115e4:  92 48 00 0a lbu	a4,10(s2)
[ 124] 0x900000001fc115e8:  15 14 00 07 bne	a4,s4,0x900000001fc11608
[ 124] 0x900000001fc115ec:  02 40 80 25 move	s0,s2
  126: 			loprintf("        Bank %d: IP %d, IF %d, SIMM type %d, Bloc 0x%x\n",
  127: 				i, mem->bnk_ip, mem->bnk_if, mem->bnk_size, 
  128: 				mem->bnk_bloc);
  129: 			loprintf("                Inventory 0x%b, DiagVal 0x%b, %s\n",
  130: 				mem->bnk_inventory, mem->bnk_diagval,
  131: 				(mem->bnk_enable ? "Enabled" : "Disabled"));
  132: 			if (mem->bnk_diagval != EVDIAG_PASSED)
  133: 				loprintf("        *** %s\n",
  134: 					get_diag_string(mem->bnk_diagval));
  135: 		} else {
  136: 			loprintf("        Bank %d: Not populated.\n",
[ 136] 0x900000001fc115f0:  02 20 28 25 move	a1,s1
[ 136] 0x900000001fc115f4:  0f f0 2c e3 jal		loprintf
[ 136] 0x900000001fc115f8:  02 a0 20 25 move	a0,s5
[ 136] 0x900000001fc115fc:  66 52 00 0c daddiu	s2,s2,12
[ 136] 0x900000001fc11600:  10 00 00 1a b		0x900000001fc1166c
[ 136] 0x900000001fc11604:  00 00 00 21 nada
[ 126] 0x900000001fc11608:  92 06 00 08 lbu	a2,8(s0)
[ 126] 0x900000001fc1160c:  92 07 00 09 lbu	a3,9(s0)
[ 126] 0x900000001fc11610:  8e 09 00 00 lw	a5,0(s0)
[ 126] 0x900000001fc11614:  02 20 28 25 move	a1,s1
[ 126] 0x900000001fc11618:  0f f0 2c e3 jal		loprintf
[ 126] 0x900000001fc1161c:  02 c0 20 25 move	a0,s6
[ 129] 0x900000001fc11620:  92 06 00 07 lbu	a2,7(s0)
[ 129] 0x900000001fc11624:  92 05 00 06 lbu	a1,6(s0)
[ 129] 0x900000001fc11628:  03 c0 38 25 move	a3,s8
[ 129] 0x900000001fc1162c:  df a4 00 00 ld	a0,0(sp)
[ 129] 0x900000001fc11630:  92 0d 00 05 lbu	t1,5(s0)
[ 129] 0x900000001fc11634:  0f f0 2c e3 jal		loprintf
[ 129] 0x900000001fc11638:  02 ed 38 0b movn	a3,s7,t1
[ 129] 0x900000001fc1163c:  00 00 00 21 nada
[ 129] 0x900000001fc11640:  00 00 00 21 nada
[ 129] 0x900000001fc11644:  00 00 00 21 nada
[ 132] 0x900000001fc11648:  92 19 00 07 lbu	t9,7(s0)
[ 132] 0x900000001fc1164c:  66 52 00 0c daddiu	s2,s2,12
[ 132] 0x900000001fc11650:  13 20 00 06 beq	t9,zero,0x900000001fc1166c
[ 132] 0x900000001fc11654:  00 00 00 21 nada
[ 133] 0x900000001fc11658:  0f f0 3f 6c jal		get_diag_string
[ 133] 0x900000001fc1165c:  03 20 20 25 move	a0,t9
[ 133] 0x900000001fc11660:  00 40 28 25 move	a1,v0
[ 133] 0x900000001fc11664:  0f f0 2c e3 jal		loprintf
[ 133] 0x900000001fc11668:  df a4 00 08 ld	a0,8(sp)
[ 123] 0x900000001fc1166c:  16 53 ff dd bne	s2,s3,0x900000001fc115e4
[ 123] 0x900000001fc11670:  26 31 00 01 addiu	s1,s1,1
[ 123] 0x900000001fc11674:  df b3 00 38 ld	s3,56(sp)
[ 123] 0x900000001fc11678:  df b1 00 48 ld	s1,72(sp)
[ 123] 0x900000001fc1167c:  df b5 00 28 ld	s5,40(sp)
[ 123] 0x900000001fc11680:  df be 00 10 ld	s8,16(sp)
[ 123] 0x900000001fc11684:  df bf 00 58 ld	ra,88(sp)
[ 123] 0x900000001fc11688:  df b6 00 20 ld	s6,32(sp)
[ 123] 0x900000001fc1168c:  df b4 00 30 ld	s4,48(sp)
[ 123] 0x900000001fc11690:  df b2 00 40 ld	s2,64(sp)
[ 123] 0x900000001fc11694:  df b0 00 50 ld	s0,80(sp)
[ 123] 0x900000001fc11698:  df b7 00 18 ld	s7,24(sp)
[ 123] 0x900000001fc1169c:  03 e0 00 08 jr	ra
[ 123] 0x900000001fc116a0:  67 bd 00 60 daddiu	sp,sp,96
  137: 				i);	
  138: 		}
  139: 	}
  140: }
  141: 
  142: 
  143: void
  144: dump_evconfig_entry(int slot)
  145: {
dump_evconfig_entry:
[ 145] 0x900000001fc116a4:  67 bd ff e0 daddiu	sp,sp,-32
  146: 	evbrdinfo_t *brd;
  147: 
  148: 	brd = &(EVCFGINFO->ecfg_board[slot]);
[ 148] 0x900000001fc116a8:  00 04 38 b8 dsll	a3,a0,2
[ 148] 0x900000001fc116ac:  00 04 19 38 dsll	v1,a0,4
[ 148] 0x900000001fc116b0:  00 04 09 f8 dsll	at,a0,7
  149: 
  150: 	loprintf("Slot 0x%b: Type = 0x%b, Name = ", slot, brd->eb_type);
[ 150] 0x900000001fc116b4:  00 80 28 25 move	a1,a0
[ 150] 0x900000001fc116b8:  3c 02 90 00 lui	v0,0x9000
[ 150] 0x900000001fc116bc:  3c 04 1f c2 lui	a0,0x1fc2
[ 150] 0x900000001fc116c0:  60 42 00 00 daddi	v0,v0,0
[ 150] 0x900000001fc116c4:  60 86 e5 60 daddi	a2,a0,-6816
[ 150] 0x900000001fc116c8:  00 67 38 2d daddu	a3,v1,a3
[ 150] 0x900000001fc116cc:  00 02 10 3c dsll32	v0,v0,0
[ 150] 0x900000001fc116d0:  3c 03 90 00 lui	v1,0x9000
[ 150] 0x900000001fc116d4:  ff b0 00 10 sd	s0,16(sp)
[ 150] 0x900000001fc116d8:  00 46 80 2c dadd	s0,v0,a2
[ 150] 0x900000001fc116dc:  60 63 00 00 daddi	v1,v1,0
[ 150] 0x900000001fc116e0:  3c 04 1f c2 lui	a0,0x1fc2
[ 150] 0x900000001fc116e4:  60 84 e8 08 daddi	a0,a0,-6136
[ 150] 0x900000001fc116e8:  00 27 08 2f dsubu	at,at,a3
[ 150] 0x900000001fc116ec:  de 02 03 00 ld	v0,768(s0)
[ 150] 0x900000001fc116f0:  00 03 18 3c dsll32	v1,v1,0
[ 150] 0x900000001fc116f4:  ff b1 00 08 sd	s1,8(sp)
[ 150] 0x900000001fc116f8:  00 22 88 2f dsubu	s1,at,v0
[ 150] 0x900000001fc116fc:  00 64 20 2c dadd	a0,v1,a0
[ 150] 0x900000001fc11700:  ff bf 00 18 sd	ra,24(sp)
[ 150] 0x900000001fc11704:  0f f0 2c e3 jal		loprintf
[ 150] 0x900000001fc11708:  92 26 00 64 lbu	a2,100(s1)
  151: 	switch(brd->eb_type) {
[ 151] 0x900000001fc1170c:  24 0b 00 13 li	a7,19
[ 151] 0x900000001fc11710:  24 0a 00 21 li	a6,33
[ 151] 0x900000001fc11714:  92 39 00 64 lbu	t9,100(s1)
[ 151] 0x900000001fc11718:  17 20 00 08 bne	t9,zero,0x900000001fc1173c
[ 151] 0x900000001fc1171c:  24 09 00 31 li	a5,49
  152: 	  case EVTYPE_IP25:
  153: 		loprintf("IP25\n");
  154: 		dump_ip(brd);
  155: 		break;
  156: 
  157: 	  case EVTYPE_IO4:
  158: 		loprintf("IO4\n");
  159: 		dump_io4(brd);
  160: 		break;
  161: 
  162: 	  case EVTYPE_MC3:
  163: 		loprintf("MC3\n");
  164: 		dump_mc3(brd);
  165: 		break;
  166: 
  167: 	  case EVTYPE_EMPTY:
  168: 		loprintf("EMPTY\n");
[ 168] 0x900000001fc11720:  0f f0 2c e3 jal		loprintf
[ 168] 0x900000001fc11724:  66 04 02 d8 daddiu	a0,s0,728
  169: 		dump_general(brd);
[ 169] 0x900000001fc11728:  df b0 00 10 ld	s0,16(sp)
[ 169] 0x900000001fc1172c:  0f f0 43 f3 jal		dump_general
[ 169] 0x900000001fc11730:  02 20 20 25 move	a0,s1
  170: 		break;
[ 170] 0x900000001fc11734:  10 00 00 22 b		0x900000001fc117c0
[ 170] 0x900000001fc11738:  df b1 00 08 ld	s1,8(sp)
[ 170] 0x900000001fc1173c:  17 2b 00 08 bne	t9,a7,0x900000001fc11760
[ 170] 0x900000001fc11740:  00 00 00 21 nada
[ 153] 0x900000001fc11744:  0f f0 2c e3 jal		loprintf
[ 153] 0x900000001fc11748:  66 04 02 c8 daddiu	a0,s0,712
[ 154] 0x900000001fc1174c:  df b0 00 10 ld	s0,16(sp)
[ 154] 0x900000001fc11750:  0f f0 44 23 jal		dump_ip
[ 154] 0x900000001fc11754:  02 20 20 25 move	a0,s1
[ 155] 0x900000001fc11758:  10 00 00 19 b		0x900000001fc117c0
[ 155] 0x900000001fc1175c:  df b1 00 08 ld	s1,8(sp)
[ 155] 0x900000001fc11760:  17 2a 00 08 bne	t9,a6,0x900000001fc11784
[ 155] 0x900000001fc11764:  00 00 00 21 nada
[ 158] 0x900000001fc11768:  0f f0 2c e3 jal		loprintf
[ 158] 0x900000001fc1176c:  66 04 02 ce daddiu	a0,s0,718
[ 159] 0x900000001fc11770:  df b0 00 10 ld	s0,16(sp)
[ 159] 0x900000001fc11774:  0f f0 44 94 jal		dump_io4
[ 159] 0x900000001fc11778:  02 20 20 25 move	a0,s1
[ 160] 0x900000001fc1177c:  10 00 00 10 b		0x900000001fc117c0
[ 160] 0x900000001fc11780:  df b1 00 08 ld	s1,8(sp)
[ 160] 0x900000001fc11784:  17 29 00 08 bne	t9,a5,0x900000001fc117a8
[ 160] 0x900000001fc11788:  00 00 00 21 nada
[ 163] 0x900000001fc1178c:  0f f0 2c e3 jal		loprintf
[ 163] 0x900000001fc11790:  66 04 02 d3 daddiu	a0,s0,723
[ 164] 0x900000001fc11794:  df b0 00 10 ld	s0,16(sp)
[ 164] 0x900000001fc11798:  0f f0 45 43 jal		dump_mc3
[ 164] 0x900000001fc1179c:  02 20 20 25 move	a0,s1
[ 165] 0x900000001fc117a0:  10 00 00 07 b		0x900000001fc117c0
[ 165] 0x900000001fc117a4:  df b1 00 08 ld	s1,8(sp)
  171: 
  172: 	  default:
  173: 		loprintf("Unrecognized board type\n");
[ 173] 0x900000001fc117a8:  0f f0 2c e3 jal		loprintf
[ 173] 0x900000001fc117ac:  66 04 02 e0 daddiu	a0,s0,736
  174: 		dump_general(brd);
[ 174] 0x900000001fc117b0:  df b0 00 10 ld	s0,16(sp)
[ 174] 0x900000001fc117b4:  0f f0 43 f3 jal		dump_general
[ 174] 0x900000001fc117b8:  02 20 20 25 move	a0,s1
  175: 		break;
[ 175] 0x900000001fc117bc:  df b1 00 08 ld	s1,8(sp)
[ 175] 0x900000001fc117c0:  df bf 00 18 ld	ra,24(sp)
[ 175] 0x900000001fc117c4:  03 e0 00 08 jr	ra
[ 175] 0x900000001fc117c8:  67 bd 00 20 daddiu	sp,sp,32
Skipping source listing to line 78 of /cores/banyan/stand/arcs/IP25prom/mc3_config.c...
   79: 
   80: /* get_marev(int slot)
   81:  *	Calculates the revision number of the MA chip in the specified slot.
   82:  */
   83: int 
   84: get_marev(int slot)
   85: {
   86: 	evreg_t	revision;
   87: 
   88: 	revision = (EV_GET_CONFIG(slot, MC3_REVLEVEL) & 0xf) << 4;
get_marev:
[  88] 0x900000001fc117cc:  3c 01 90 00 lui	at,0x9000
[  88] 0x900000001fc117d0:  60 21 00 00 daddi	at,at,0
[  88] 0x900000001fc117d4:  3c 03 1f c2 lui	v1,0x1fc2
[  88] 0x900000001fc117d8:  60 63 e8 68 daddi	v1,v1,-6040
[  88] 0x900000001fc117dc:  00 01 08 3c dsll32	at,at,0
[  88] 0x900000001fc117e0:  00 23 18 2c dadd	v1,at,v1
[  88] 0x900000001fc117e4:  00 04 12 c0 sll	v0,a0,11
[  88] 0x900000001fc117e8:  dc 61 00 00 ld	at,0(v1)
   89: 	/* revision[7:4] == MC3_REVLEVEL[3:0]		*/
   90: 	revision |= ((EV_GET_CONFIG(slot, MC3_BISTRESULT) >> 16) & 0xf);
[  90] 0x900000001fc117ec:  00 41 08 2d daddu	at,v0,at
[  90] 0x900000001fc117f0:  dc 63 00 08 ld	v1,8(v1)
[  90] 0x900000001fc117f4:  00 43 10 2d daddu	v0,v0,v1
[  90] 0x900000001fc117f8:  dc 21 00 00 ld	at,0(at)
[  90] 0x900000001fc117fc:  dc 42 00 00 ld	v0,0(v0)
[  90] 0x900000001fc11800:  30 21 00 0f andi	at,at,0xf
[  90] 0x900000001fc11804:  00 02 14 3b dsra	v0,v0,16
[  90] 0x900000001fc11808:  00 01 09 38 dsll	at,at,4
[  90] 0x900000001fc1180c:  30 42 00 0f andi	v0,v0,0xf
[  90] 0x900000001fc11810:  00 22 08 25 or	at,at,v0
   91: 	/* revision[3:0] == MC3_BISTRESULT[19:16]	*/
   92: 
   93: 	return (int)revision;
[  93] 0x900000001fc11814:  03 e0 00 08 jr	ra
[  93] 0x900000001fc11818:  00 01 10 00 sll	v0,at,0
   94: 
   95: 	/* MA rev "1" -> 0.  */
   96: 	/* MA rev "2" -> 16. */
   97: 	/* MA rev "3" -> 19. */
   98: }
   99: 
  100: 
  101: /*
  102:  * build_interleave()
  103:  *	Tries to configure the array of banks such that
  104:  *	all of the interleaves are of the size given in
  105:  *	cap.  This is done by treating the banks array as an
  106:  *	array whose x axis corresponds to leaf numbers and whose
  107:  *	y axis corresponds to banks.  
  108:  *
  109:  *		L0B0 L1B0 L0B1 L1B1 L0B2 L1B2
  110:  *	       +----+----+----+----+----+----+
  111:  *	Bank 0 |    |    |    |    |    |    |
  112:  *	       |----+----+----+----+----+----|
  113:  *	Bank 1 |    |    |    |    |    |    |
  114:  *	       |----+----+----+----+----+----|
  115:  *	Bank 2 |    |    |    |    |    |    |
  116:  *	       |----+----+----+----+----+----|
  117:  *	Bank 3 |    |    |    |    |    |    |
  118:  *	       +----+----+----+----+----+----+
  119:  *
  120:  *	We iterate in row-major order, from left to right and
  121:  *	from top to bottom, doing first all of banks 0, then all
  122:  *	banks 1, etc.  We start by marking the first bank as
  123:  *	used and then scan forward in the array, adding the other
  124:  *	leaves as appropriate.  Each time we find a matching bank,
  125:  *	we add it to the current interleave and continue scanning.
  126:  *	If we can't build an interleave of the size requested by cap,
  127:  *	we do one of two things.  If we're using a stable algorithm,
  128:  *	we simply return, since the stable algorithm resets the used
  129:  *	flags every time the algorithm starts.  If we're using the
  130:  *	optimal algorithm, we deallocate only the current unsuccessful
  131:  *	interleave, because any all of the other interleaves built in
  132:  *	this pass are optimal.
  133:  *	
  134:  * Parameters:
  135:  *	num_banks -- the number of banks in the bank array.
  136:  *	bank -- the array of banks to be configured
  137:  *	cap -- the interleave factor to be used as a goal.
  138:  *	stable -- Flag indicating whether we should use a stable algorithm.
  139:  * Returns:
  140:  *	SUCCEED if all of the banks can be configured with an
  141:  *	  interleave factor of either cap or 1,
  142:  *	FAIL otherwise.
  143:  */
  144: 
  145: #define MARK(_x) 	marked |= (1 << (_x)) 
  146: #define NOT_MARKED(_x) !(marked & (1 << (_x)))
  147: 
  148: static int
  149: build_interleave(int num_banks, evbnkcfg_t *bank[], int cap, int stable)
  150: {
build_interleave:
[ 150] 0x900000001fc1181c:  67 bd ff 20 daddiu	sp,sp,-224
[ 150] 0x900000001fc11820:  ff b4 00 a8 sd	s4,168(sp)
[ 150] 0x900000001fc11824:  00 c0 a0 25 move	s4,a2
  151:     int b, lf;		/* Current bank index */
  152:     int cb, cl;		/* The bank and leaf being checked. */
  153:     int ilv_size;	/* Size of the interleave built thus far */
  154:     int	prev_bank;	/* Index of previously touched bank */
  155:     evbnkcfg_t *bnk;	/* Pointer to first bank in current interleave */
  156:     evbnkcfg_t *cbnk;	/* Pointer to bank currently being checked */
  157:     int marked;		/* Bit set of used leaves */
  158:     int startleaf;	/* Lower index for traversing checked leaves */
  159:     int failed = 0;	/* Flag indicating that all banks aren't interleaved */
  160:  
  161:     DPRINTF(("  Cap is %d, num_banks = %d\n", cap, num_banks));
  162: 
  163:     /* If we're doing a stable interleave erase all of our previous
  164:      * configuration attempts.  If we're doing a optimal interleave,
  165:      * we leave our previous attempts alone, since they are perfectly
  166:      * valid.
  167:      */
  168:     if (stable)
[ 168] 0x900000001fc11828:  ff b7 00 90 sd	s7,144(sp)
[ 168] 0x900000001fc1182c:  00 00 b8 25 move	s7,zero
[ 168] 0x900000001fc11830:  ff a4 00 50 sd	a0,80(sp)
[ 168] 0x900000001fc11834:  df a8 00 50 ld	a4,80(sp)
[ 168] 0x900000001fc11838:  24 81 00 03 addiu	at,a0,3
[ 168] 0x900000001fc1183c:  00 80 10 2a slt	v0,a0,zero
[ 168] 0x900000001fc11840:  df ac 00 50 ld	t0,80(sp)
[ 168] 0x900000001fc11844:  ff a5 00 58 sd	a1,88(sp)
[ 159] 0x900000001fc11848:  ff b2 00 b8 sd	s2,184(sp)
[ 159] 0x900000001fc1184c:  30 92 00 03 andi	s2,a0,0x3
[ 159] 0x900000001fc11850:  00 82 08 0a movz	at,a0,v0
[ 159] 0x900000001fc11854:  00 00 00 21 nada
[ 159] 0x900000001fc11858:  00 00 00 21 nada
[ 159] 0x900000001fc1185c:  00 00 00 21 nada
[ 159] 0x900000001fc11860:  ff b5 00 a0 sd	s5,160(sp)
[ 159] 0x900000001fc11864:  00 01 a8 83 sra	s5,at,2
[ 159] 0x900000001fc11868:  ff b0 00 c8 sd	s0,200(sp)
[ 159] 0x900000001fc1186c:  df b0 00 58 ld	s0,88(sp)
[ 159] 0x900000001fc11870:  ff b1 00 c0 sd	s1,192(sp)
[ 159] 0x900000001fc11874:  ff be 00 88 sd	s8,136(sp)
[ 159] 0x900000001fc11878:  3c 1e 90 00 lui	s8,0x9000
[ 159] 0x900000001fc1187c:  ff a7 00 60 sd	a3,96(sp)
[ 159] 0x900000001fc11880:  63 de 00 00 daddi	s8,s8,0
[ 159] 0x900000001fc11884:  00 1e f0 3c dsll32	s8,s8,0
[ 159] 0x900000001fc11888:  10 e0 00 7b beq	a3,zero,0x900000001fc11a78
[ 159] 0x900000001fc1188c:  ff b3 00 b0 sd	s3,176(sp)
  169: 	for (b = 0; b < num_banks; b++) 
[ 169] 0x900000001fc11890:  59 00 00 7a blezl	a4,0x900000001fc11a7c
[ 169] 0x900000001fc11894:  00 00 50 25 move	a6,zero
[ 169] 0x900000001fc11898:  52 40 00 0d beql	s2,zero,0x900000001fc118d0
[ 169] 0x900000001fc1189c:  df ae 00 58 ld	t2,88(sp)
[ 169] 0x900000001fc118a0:  00 12 48 3c dsll32	a5,s2,0
[ 169] 0x900000001fc118a4:  00 09 4f 7a dsrl	a5,a5,29
[ 169] 0x900000001fc118a8:  00 00 08 25 move	at,zero
[ 169] 0x900000001fc118ac:  02 09 88 2d daddu	s1,s0,a5
  170: 	    bank[b]->bnk_used = bank[b]->bnk_count = 0;
[ 170] 0x900000001fc118b0:  de 0a 00 00 ld	a6,0(s0)
[ 170] 0x900000001fc118b4:  a1 41 00 0b sb	at,11(a6)
[ 170] 0x900000001fc118b8:  de 0a 00 00 ld	a6,0(s0)
[ 169] 0x900000001fc118bc:  66 10 00 08 daddiu	s0,s0,8
[ 169] 0x900000001fc118c0:  26 f7 00 01 addiu	s7,s7,1
[ 169] 0x900000001fc118c4:  16 11 ff fa bne	s0,s1,0x900000001fc118b0
[ 169] 0x900000001fc118c8:  a1 41 00 08 sb	at,8(a6)
[ 169] 0x900000001fc118cc:  df ae 00 58 ld	t2,88(sp)
[ 169] 0x900000001fc118d0:  df ad 00 50 ld	t1,80(sp)
[ 169] 0x900000001fc118d4:  00 17 78 f8 dsll	t3,s7,3
[ 169] 0x900000001fc118d8:  26 eb 00 03 addiu	a7,s7,3
[ 169] 0x900000001fc118dc:  00 0d 68 82 srl	t1,t1,2
[ 169] 0x900000001fc118e0:  01 6c 58 2a slt	a7,a7,t0
[ 169] 0x900000001fc118e4:  51 60 00 65 beql	a7,zero,0x900000001fc11a7c
[ 169] 0x900000001fc118e8:  00 00 50 25 move	a6,zero
[ 169] 0x900000001fc118ec:  00 0d 68 3c dsll32	t1,t1,0
[ 169] 0x900000001fc118f0:  01 cf 80 2d daddu	s0,t2,t3
[ 169] 0x900000001fc118f4:  00 0d 6e fa dsrl	t1,t1,27
[ 169] 0x900000001fc118f8:  02 0d 88 2d daddu	s1,s0,t1
[ 169] 0x900000001fc118fc:  02 00 30 25 move	a2,s0
[ 169] 0x900000001fc11900:  66 12 00 20 daddiu	s2,s0,32
[ 169] 0x900000001fc11904:  12 51 00 4a beq	s2,s1,0x900000001fc11a30
[ 169] 0x900000001fc11908:  00 00 08 25 move	at,zero
[ 169] 0x900000001fc1190c:  24 13 00 20 li	s3,32
[ 169] 0x900000001fc11910:  66 05 00 20 daddiu	a1,s0,32
[ 169] 0x900000001fc11914:  de 03 00 00 ld	v1,0(s0)
[ 169] 0x900000001fc11918:  02 33 10 2f dsubu	v0,s1,s3
[ 169] 0x900000001fc1191c:  a0 61 00 0b sb	at,11(v1)
[ 169] 0x900000001fc11920:  dc c4 00 00 ld	a0,0(a2)
[ 169] 0x900000001fc11924:  a0 81 00 08 sb	at,8(a0)
[ 169] 0x900000001fc11928:  dc c4 00 08 ld	a0,8(a2)
[ 169] 0x900000001fc1192c:  a0 81 00 0b sb	at,11(a0)
[ 169] 0x900000001fc11930:  dc c4 00 08 ld	a0,8(a2)
[ 169] 0x900000001fc11934:  a0 81 00 08 sb	at,8(a0)
[ 169] 0x900000001fc11938:  dc c4 00 10 ld	a0,16(a2)
[ 169] 0x900000001fc1193c:  a0 81 00 0b sb	at,11(a0)
[ 169] 0x900000001fc11940:  dc c4 00 10 ld	a0,16(a2)
[ 169] 0x900000001fc11944:  a0 81 00 08 sb	at,8(a0)
[ 169] 0x900000001fc11948:  dc c4 00 18 ld	a0,24(a2)
[ 169] 0x900000001fc1194c:  a0 81 00 0b sb	at,11(a0)
[ 169] 0x900000001fc11950:  dc c4 00 18 ld	a0,24(a2)
[ 169] 0x900000001fc11954:  a0 81 00 08 sb	at,8(a0)
[ 169] 0x900000001fc11958:  64 a6 00 20 daddiu	a2,a1,32
[ 169] 0x900000001fc1195c:  10 a2 00 24 beq	a1,v0,0x900000001fc119f0
[ 169] 0x900000001fc11960:  dc a3 00 00 ld	v1,0(a1)
[ 169] 0x900000001fc11964:  a0 61 00 0b sb	at,11(v1)
[ 169] 0x900000001fc11968:  dc a4 00 00 ld	a0,0(a1)
[ 169] 0x900000001fc1196c:  a0 81 00 08 sb	at,8(a0)
[ 169] 0x900000001fc11970:  dc a4 00 08 ld	a0,8(a1)
[ 169] 0x900000001fc11974:  a0 81 00 0b sb	at,11(a0)
[ 169] 0x900000001fc11978:  dc a4 00 08 ld	a0,8(a1)
[ 169] 0x900000001fc1197c:  a0 81 00 08 sb	at,8(a0)
[ 169] 0x900000001fc11980:  dc a4 00 10 ld	a0,16(a1)
[ 169] 0x900000001fc11984:  a0 81 00 0b sb	at,11(a0)
[ 169] 0x900000001fc11988:  dc a4 00 10 ld	a0,16(a1)
[ 169] 0x900000001fc1198c:  a0 81 00 08 sb	at,8(a0)
[ 169] 0x900000001fc11990:  dc a4 00 18 ld	a0,24(a1)
[ 169] 0x900000001fc11994:  a0 81 00 0b sb	at,11(a0)
[ 169] 0x900000001fc11998:  dc a4 00 18 ld	a0,24(a1)
[ 169] 0x900000001fc1199c:  a0 81 00 08 sb	at,8(a0)
[ 169] 0x900000001fc119a0:  64 c5 00 20 daddiu	a1,a2,32
[ 169] 0x900000001fc119a4:  14 c2 ff dd bne	a2,v0,0x900000001fc1191c
[ 169] 0x900000001fc119a8:  dc c3 00 00 ld	v1,0(a2)
[ 169] 0x900000001fc119ac:  a0 61 00 0b sb	at,11(v1)
[ 169] 0x900000001fc119b0:  dc d7 00 00 ld	s7,0(a2)
[ 169] 0x900000001fc119b4:  a2 e1 00 08 sb	at,8(s7)
[ 169] 0x900000001fc119b8:  dc d7 00 08 ld	s7,8(a2)
[ 169] 0x900000001fc119bc:  a2 e1 00 0b sb	at,11(s7)
[ 169] 0x900000001fc119c0:  dc d7 00 08 ld	s7,8(a2)
[ 169] 0x900000001fc119c4:  a2 e1 00 08 sb	at,8(s7)
[ 169] 0x900000001fc119c8:  dc d7 00 10 ld	s7,16(a2)
[ 169] 0x900000001fc119cc:  a2 e1 00 0b sb	at,11(s7)
[ 169] 0x900000001fc119d0:  dc d7 00 10 ld	s7,16(a2)
[ 169] 0x900000001fc119d4:  a2 e1 00 08 sb	at,8(s7)
[ 169] 0x900000001fc119d8:  dc d7 00 18 ld	s7,24(a2)
[ 169] 0x900000001fc119dc:  a2 e1 00 0b sb	at,11(s7)
[ 169] 0x900000001fc119e0:  dc d7 00 18 ld	s7,24(a2)
[ 169] 0x900000001fc119e4:  a2 e1 00 08 sb	at,8(s7)
[ 169] 0x900000001fc119e8:  10 00 00 24 b		0x900000001fc11a7c
[ 169] 0x900000001fc119ec:  00 00 50 25 move	a6,zero
[ 169] 0x900000001fc119f0:  a0 61 00 0b sb	at,11(v1)
[ 169] 0x900000001fc119f4:  dc b8 00 00 ld	t8,0(a1)
[ 169] 0x900000001fc119f8:  a3 01 00 08 sb	at,8(t8)
[ 169] 0x900000001fc119fc:  dc b8 00 08 ld	t8,8(a1)
[ 169] 0x900000001fc11a00:  a3 01 00 0b sb	at,11(t8)
[ 169] 0x900000001fc11a04:  dc b8 00 08 ld	t8,8(a1)
[ 169] 0x900000001fc11a08:  a3 01 00 08 sb	at,8(t8)
[ 169] 0x900000001fc11a0c:  dc b8 00 10 ld	t8,16(a1)
[ 169] 0x900000001fc11a10:  a3 01 00 0b sb	at,11(t8)
[ 169] 0x900000001fc11a14:  dc b8 00 10 ld	t8,16(a1)
[ 169] 0x900000001fc11a18:  a3 01 00 08 sb	at,8(t8)
[ 169] 0x900000001fc11a1c:  dc b8 00 18 ld	t8,24(a1)
[ 169] 0x900000001fc11a20:  a3 01 00 0b sb	at,11(t8)
[ 169] 0x900000001fc11a24:  dc b8 00 18 ld	t8,24(a1)
[ 169] 0x900000001fc11a28:  10 00 00 13 b		0x900000001fc11a78
[ 169] 0x900000001fc11a2c:  a3 01 00 08 sb	at,8(t8)
[ 169] 0x900000001fc11a30:  de 19 00 00 ld	t9,0(s0)
[ 169] 0x900000001fc11a34:  a3 21 00 0b sb	at,11(t9)
[ 169] 0x900000001fc11a38:  de 19 00 00 ld	t9,0(s0)
[ 169] 0x900000001fc11a3c:  a3 21 00 08 sb	at,8(t9)
[ 169] 0x900000001fc11a40:  de 19 00 08 ld	t9,8(s0)
[ 169] 0x900000001fc11a44:  a3 21 00 0b sb	at,11(t9)
[ 169] 0x900000001fc11a48:  de 19 00 08 ld	t9,8(s0)
[ 169] 0x900000001fc11a4c:  a3 21 00 08 sb	at,8(t9)
[ 169] 0x900000001fc11a50:  de 19 00 10 ld	t9,16(s0)
[ 169] 0x900000001fc11a54:  a3 21 00 0b sb	at,11(t9)
[ 169] 0x900000001fc11a58:  de 19 00 10 ld	t9,16(s0)
[ 169] 0x900000001fc11a5c:  a3 21 00 08 sb	at,8(t9)
[ 169] 0x900000001fc11a60:  de 19 00 18 ld	t9,24(s0)
[ 169] 0x900000001fc11a64:  a3 21 00 0b sb	at,11(t9)
[ 169] 0x900000001fc11a68:  de 19 00 18 ld	t9,24(s0)
[ 169] 0x900000001fc11a6c:  66 10 00 20 daddiu	s0,s0,32
[ 169] 0x900000001fc11a70:  16 11 ff ef bne	s0,s1,0x900000001fc11a30
[ 169] 0x900000001fc11a74:  a3 21 00 08 sb	at,8(t9)
[ 169] 0x900000001fc11a78:  00 00 50 25 move	a6,zero
  171: 
  172:     /* Now we actually iterate through all of the banks trying to interleave
  173:      * them.  If we get through to the bottom of this loop, we know that
  174:      * we interleaved all of the banks in the system.
  175:      */ 
  176:     for (b = 0; b < 4; b++) {
[ 176] 0x900000001fc11a7c:  3c 01 1f c2 lui	at,0x1fc2
[ 176] 0x900000001fc11a80:  ff b6 00 98 sd	s6,152(sp)
[ 176] 0x900000001fc11a84:  60 21 e8 68 daddi	at,at,-6040
[ 176] 0x900000001fc11a88:  24 02 00 04 li	v0,4
[ 176] 0x900000001fc11a8c:  ff a0 00 68 sd	zero,104(sp)
[ 176] 0x900000001fc11a90:  03 c1 f0 2c dadd	s8,s8,at
[ 176] 0x900000001fc11a94:  00 00 b8 25 move	s7,zero
[ 176] 0x900000001fc11a98:  ff bf 00 d0 sd	ra,208(sp)
[ 176] 0x900000001fc11a9c:  24 13 00 ff li	s3,255
[ 176] 0x900000001fc11aa0:  ff a2 00 78 sd	v0,120(sp)
[ 176] 0x900000001fc11aa4:  24 12 00 01 li	s2,1
[ 176] 0x900000001fc11aa8:  ff be 00 70 sd	s8,112(sp)
[ 176] 0x900000001fc11aac:  df d1 00 10 ld	s1,16(s8)
[ 176] 0x900000001fc11ab0:  24 1f 00 07 li	ra,7
[ 176] 0x900000001fc11ab4:  24 16 00 01 li	s6,1
[ 176] 0x900000001fc11ab8:  00 0a 48 80 sll	a5,a6,2
[ 176] 0x900000001fc11abc:  02 e0 f0 25 move	s8,s7
  177: 	for (lf = 0; lf < NUM_LEAVES(num_banks); lf++) {
[ 177] 0x900000001fc11ac0:  5a a0 00 e6 blezl	s5,0x900000001fc11e5c
[ 177] 0x900000001fc11ac4:  00 00 50 25 move	a6,zero
[ 177] 0x900000001fc11ac8:  03 c9 08 2d daddu	at,s8,a5
[ 177] 0x900000001fc11acc:  00 01 10 f8 dsll	v0,at,3
[ 177] 0x900000001fc11ad0:  df a1 00 58 ld	at,88(sp)
[ 177] 0x900000001fc11ad4:  ff b7 00 80 sd	s7,128(sp)
[ 177] 0x900000001fc11ad8:  00 22 08 2d daddu	at,at,v0
[ 177] 0x900000001fc11adc:  df b0 00 80 ld	s0,128(sp)
[ 177] 0x900000001fc11ae0:  02 c0 28 25 move	a1,s6
[ 177] 0x900000001fc11ae4:  25 57 00 01 addiu	s7,a6,1
  178: 	    bnk = bank[BPOS(lf, b)];
[ 178] 0x900000001fc11ae8:  dc 22 00 00 ld	v0,0(at)
  179: 
  180: 	    /* Skip empty, disabled, and already used banks */
  181: 	    if (bnk->bnk_used || bnk->bnk_size == MC3_NOBANK
[ 181] 0x900000001fc11aec:  01 56 38 04 sllv	a3,s6,a6
[ 181] 0x900000001fc11af0:  90 41 00 08 lbu	at,8(v0)
[ 181] 0x900000001fc11af4:  54 20 00 d1 bnel	at,zero,0x900000001fc11e3c
[ 181] 0x900000001fc11af8:  00 17 48 80 sll	a5,s7,2
[ 181] 0x900000001fc11afc:  90 41 00 0a lbu	at,10(v0)
[ 181] 0x900000001fc11b00:  50 3f 00 ce beql	at,ra,0x900000001fc11e3c
[ 181] 0x900000001fc11b04:  00 17 48 80 sll	a5,s7,2
[ 181] 0x900000001fc11b08:  90 41 00 05 lbu	at,5(v0)
[ 181] 0x900000001fc11b0c:  50 20 00 cb beql	at,zero,0x900000001fc11e3c
[ 181] 0x900000001fc11b10:  00 17 48 80 sll	a5,s7,2
  182: 		|| !bnk->bnk_enable) {
  183: 		DPRINTF(("Skipping leaf %d bank %d\n", lf, b));
  184: 		DPRINTF(("  Bank size: %d Bank used: %d\n", 
  185: 			 bnk->bnk_size, bnk->bnk_used));
  186: 		continue;
  187: 	    }
  188: 
  189: 	    DPRINTF(("   Trying to interleave leaf %d bank %d, size %d\n", 
  190: 		     lf, b, bnk->bnk_size));
  191: 		
  192: 	    /* Build the rest of the interleave chain by scanning
  193: 	     * through the rest of table table looking for banks
  194: 	     * of the required size.  
  195: 	     */
  196: 	    ilv_size = 1;
  197: 	    prev_bank = BPOS(lf, b);
  198: 	    bnk->bnk_used = 1;
  199: 	    marked = 0;
  200: 	    MARK(lf);
  201: 
  202: 	    /* Scan the array looking for banks to add to the interleave.
  203: 	     * Since we should have already used any banks which preceed
  204:  	     * the base bank, we don't rescan the entire array.
  205: 	     */
  206: 	    startleaf = lf+1;
[ 206] 0x900000001fc11b14:  02 e0 58 25 move	a7,s7
  207: 	    for (cb = b; cb < 4 && ilv_size < cap; cb++) {
[ 207] 0x900000001fc11b18:  02 d4 08 2a slt	at,s6,s4
[ 207] 0x900000001fc11b1c:  2a 03 00 04 slti	v1,s0,4
[ 198] 0x900000001fc11b20:  a0 52 00 08 sb	s2,8(v0)
[ 198] 0x900000001fc11b24:  10 60 00 41 beq	v1,zero,0x900000001fc11c2c
[ 198] 0x900000001fc11b28:  02 09 30 21 addu	a2,s0,a5
[ 207] 0x900000001fc11b2c:  10 20 00 3f beq	at,zero,0x900000001fc11c2c
[ 207] 0x900000001fc11b30:  00 00 00 21 nada
  208: 		for (cl = startleaf; 
[ 208] 0x900000001fc11b34:  01 75 40 2a slt	a4,a7,s5
[ 208] 0x900000001fc11b38:  01 60 50 25 move	a6,a7
[ 208] 0x900000001fc11b3c:  02 00 20 25 move	a0,s0
[ 208] 0x900000001fc11b40:  00 b4 08 2a slt	at,a1,s4
[ 208] 0x900000001fc11b44:  df a3 00 58 ld	v1,88(sp)
[ 208] 0x900000001fc11b48:  51 00 00 32 beql	a4,zero,0x900000001fc11c14
[ 208] 0x900000001fc11b4c:  26 10 00 01 addiu	s0,s0,1
[ 208] 0x900000001fc11b50:  50 20 00 30 beql	at,zero,0x900000001fc11c14
[ 208] 0x900000001fc11b54:  26 10 00 01 addiu	s0,s0,1
[ 208] 0x900000001fc11b58:  00 0a 48 80 sll	a5,a6,2
[ 208] 0x900000001fc11b5c:  00 89 08 2d daddu	at,a0,a5
[ 208] 0x900000001fc11b60:  00 01 08 f8 dsll	at,at,3
[ 208] 0x900000001fc11b64:  00 61 58 2d daddu	a7,v1,at
  209: 		     cl < NUM_LEAVES(num_banks) && ilv_size < cap; 
  210: 		     cl++) {
  211: 
  212: 		    cbnk = bank[BPOS(cl,cb)];
[ 212] 0x900000001fc11b68:  dd 68 00 00 ld	a4,0(a7)
  213: 
  214: 	            /* Add the leaf being checked to the current interleave 
  215: 		     * if the bank being checked hasn't been used, is of the 
  216: 		     * correct size, is enabled, and doesn't occupy the same 
  217: 		     * leaf as a bank which is already in the interleave.
  218: 	             */
  219: 		    if (!(cbnk->bnk_used) && 
[ 219] 0x900000001fc11b6c:  91 01 00 08 lbu	at,8(a4)
[ 219] 0x900000001fc11b70:  54 20 00 1e bnel	at,zero,0x900000001fc11bec
[ 219] 0x900000001fc11b74:  00 b4 08 2a slt	at,a1,s4
[ 219] 0x900000001fc11b78:  91 01 00 0a lbu	at,10(a4)
[ 219] 0x900000001fc11b7c:  30 21 00 ff andi	at,at,0xff
[ 219] 0x900000001fc11b80:  90 4b 00 0a lbu	a7,10(v0)
[ 219] 0x900000001fc11b84:  31 6b 00 ff andi	a7,a7,0xff
[ 219] 0x900000001fc11b88:  00 01 08 f8 dsll	at,at,3
[ 219] 0x900000001fc11b8c:  00 0b 58 f8 dsll	a7,a7,3
[ 219] 0x900000001fc11b90:  00 31 08 2d daddu	at,at,s1
[ 219] 0x900000001fc11b94:  01 71 58 2d daddu	a7,a7,s1
[ 219] 0x900000001fc11b98:  dc 21 00 00 ld	at,0(at)
[ 219] 0x900000001fc11b9c:  dd 6b 00 00 ld	a7,0(a7)
[ 219] 0x900000001fc11ba0:  54 2b 00 12 bnel	at,a7,0x900000001fc11bec
[ 219] 0x900000001fc11ba4:  00 b4 08 2a slt	at,a1,s4
[ 219] 0x900000001fc11ba8:  01 56 58 04 sllv	a7,s6,a6
[ 219] 0x900000001fc11bac:  91 0c 00 05 lbu	t0,5(a4)
[ 219] 0x900000001fc11bb0:  11 80 00 0d beq	t0,zero,0x900000001fc11be8
[ 219] 0x900000001fc11bb4:  00 eb 08 24 and	at,a3,a7
[ 219] 0x900000001fc11bb8:  54 20 00 0c bnel	at,zero,0x900000001fc11bec
[ 219] 0x900000001fc11bbc:  00 b4 08 2a slt	at,a1,s4
  220: 		       (MemSizes[cbnk->bnk_size] == MemSizes[bnk->bnk_size]) && 
  221: 		       cbnk->bnk_enable && 
  222: 		       NOT_MARKED(cl)) {
  223: 
  224: 			DPRINTF(("    Adding leaf %d bank %d to interleave\n", 
  225: 				cl, cb));
  226: 			bank[prev_bank]->bnk_next = BPOS(cl, cb);
[ 226] 0x900000001fc11bc0:  00 06 30 f8 dsll	a2,a2,3
[ 226] 0x900000001fc11bc4:  02 09 08 21 addu	at,s0,a5
[ 226] 0x900000001fc11bc8:  00 66 48 2d daddu	a5,v1,a2
[ 226] 0x900000001fc11bcc:  dd 29 00 00 ld	a5,0(a5)
[ 226] 0x900000001fc11bd0:  a1 21 00 09 sb	at,9(a5)
  227: 			cbnk->bnk_next = 0xff;
  228: 			cbnk->bnk_used = 1;
  229: 			ilv_size++;
[ 229] 0x900000001fc11bd4:  24 a5 00 01 addiu	a1,a1,1
[ 229] 0x900000001fc11bd8:  a1 13 00 09 sb	s3,9(a4)
  230: 			prev_bank = BPOS(cl, cb);
  231: 			MARK(cl);
[ 231] 0x900000001fc11bdc:  00 eb 38 25 or	a3,a3,a7
[ 231] 0x900000001fc11be0:  00 20 30 25 move	a2,at
[ 231] 0x900000001fc11be4:  a1 12 00 08 sb	s2,8(a4)
[ 231] 0x900000001fc11be8:  00 b4 08 2a slt	at,a1,s4
[ 210] 0x900000001fc11bec:  25 4a 00 01 addiu	a6,a6,1
[ 208] 0x900000001fc11bf0:  00 0a 48 80 sll	a5,a6,2
[ 208] 0x900000001fc11bf4:  01 55 40 2a slt	a4,a6,s5
[ 208] 0x900000001fc11bf8:  51 00 00 06 beql	a4,zero,0x900000001fc11c14
[ 208] 0x900000001fc11bfc:  26 10 00 01 addiu	s0,s0,1
[ 208] 0x900000001fc11c00:  00 89 40 2d daddu	a4,a0,a5
[ 208] 0x900000001fc11c04:  00 08 40 f8 dsll	a4,a4,3
[ 208] 0x900000001fc11c08:  14 20 ff d7 bne	at,zero,0x900000001fc11b68
[ 208] 0x900000001fc11c0c:  00 68 58 2d daddu	a7,v1,a4
[ 207] 0x900000001fc11c10:  26 10 00 01 addiu	s0,s0,1
  232: 		    } else {
  233: 			DPRINTF(("    ...L%dB%d isn't going to work.\n", 
  234: 				 cl, cb));
  235: 		    }
  236: 		}    /* end for cl */
  237: 
  238: 		startleaf = 0;
[ 238] 0x900000001fc11c14:  00 00 58 25 move	a7,zero
[ 238] 0x900000001fc11c18:  2a 04 00 04 slti	a0,s0,4
[ 238] 0x900000001fc11c1c:  10 80 00 03 beq	a0,zero,0x900000001fc11c2c
[ 238] 0x900000001fc11c20:  00 b4 08 2a slt	at,a1,s4
[ 238] 0x900000001fc11c24:  54 20 ff c4 bnel	at,zero,0x900000001fc11b38
[ 238] 0x900000001fc11c28:  01 75 40 2a slt	a4,a7,s5
  239: 	    }    /* end for cb */
  240: 
  241: 	    if (ilv_size != cap) {
[ 241] 0x900000001fc11c2c:  16 85 00 04 bne	s4,a1,0x900000001fc11c40
[ 241] 0x900000001fc11c30:  30 a1 00 03 andi	at,a1,0x3
[ 241] 0x900000001fc11c34:  a0 45 00 0b sb	a1,11(v0)
  242: 	
  243: 		/* If we're doing an optimal interleave, we need to clean
  244: 	         * up this botched attempt so that the banks can be reused
  245: 		 * in a later try with a different cap.
  246: 		 */
  247: 	        if (!stable) {
  248: 		    DPRINTF(("  Failed to interleave memory start at %d\n", 
  249: 			     b));
  250: 		    cbnk = bnk;
  251: 		    for (cb = 0; cb < ilv_size; cb++) {
  252: 			cbnk->bnk_count = 0;
  253: 			cbnk->bnk_used = 2;	/* Touched but not allocated */
  254: 			cbnk = bank[cbnk->bnk_next];	
  255: 		    }
  256: 
  257: 		    failed = 1;
  258: 		} else {
  259: 		    return FAIL;
  260: 		}
  261: 	    } else {
  262: 		bnk->bnk_count = ilv_size;
[ 262] 0x900000001fc11c38:  10 00 00 80 b		0x900000001fc11e3c
[ 262] 0x900000001fc11c3c:  00 17 48 80 sll	a5,s7,2
[ 247] 0x900000001fc11c40:  00 40 40 25 move	a4,v0
[ 247] 0x900000001fc11c44:  df a2 00 60 ld	v0,96(sp)
[ 247] 0x900000001fc11c48:  00 00 80 25 move	s0,zero
[ 247] 0x900000001fc11c4c:  10 40 00 03 beq	v0,zero,0x900000001fc11c5c
[ 247] 0x900000001fc11c50:  00 00 00 21 nada
[ 259] 0x900000001fc11c54:  10 00 01 3f b		0x900000001fc12154
[ 259] 0x900000001fc11c58:  00 00 10 25 move	v0,zero
[ 251] 0x900000001fc11c5c:  18 a0 00 75 blez	a1,0x900000001fc11e34
[ 251] 0x900000001fc11c60:  00 00 00 21 nada
[ 250] 0x900000001fc11c64:  df a3 00 58 ld	v1,88(sp)
[ 250] 0x900000001fc11c68:  10 20 00 0b beq	at,zero,0x900000001fc11c98
[ 250] 0x900000001fc11c6c:  24 0a 00 04 li	a6,4
[ 254] 0x900000001fc11c70:  91 02 00 09 lbu	v0,9(a4)
[ 254] 0x900000001fc11c74:  30 42 00 ff andi	v0,v0,0xff
[ 254] 0x900000001fc11c78:  00 02 10 f8 dsll	v0,v0,3
[ 252] 0x900000001fc11c7c:  a1 00 00 0b sb	zero,11(a4)
[ 252] 0x900000001fc11c80:  24 04 00 02 li	a0,2
[ 252] 0x900000001fc11c84:  00 62 10 2d daddu	v0,v1,v0
[ 251] 0x900000001fc11c88:  a1 04 00 08 sb	a0,8(a4)
[ 251] 0x900000001fc11c8c:  26 10 00 01 addiu	s0,s0,1
[ 251] 0x900000001fc11c90:  16 01 ff f7 bne	s0,at,0x900000001fc11c70
[ 251] 0x900000001fc11c94:  dc 48 00 00 ld	a4,0(v0)
[ 251] 0x900000001fc11c98:  24 a1 ff fd addiu	at,a1,-3
[ 251] 0x900000001fc11c9c:  26 02 00 03 addiu	v0,s0,3
[ 251] 0x900000001fc11ca0:  02 0a 20 2d daddu	a0,s0,a6
[ 251] 0x900000001fc11ca4:  00 45 10 2a slt	v0,v0,a1
[ 251] 0x900000001fc11ca8:  10 40 00 62 beq	v0,zero,0x900000001fc11e34
[ 251] 0x900000001fc11cac:  00 81 58 2a slt	a7,a0,at
[ 251] 0x900000001fc11cb0:  51 60 00 40 beql	a7,zero,0x900000001fc11db4
[ 251] 0x900000001fc11cb4:  91 02 00 09 lbu	v0,9(a4)
[ 251] 0x900000001fc11cb8:  24 05 00 04 li	a1,4
[ 251] 0x900000001fc11cbc:  01 00 20 25 move	a0,a4
[ 251] 0x900000001fc11cc0:  02 05 28 2d daddu	a1,s0,a1
[ 251] 0x900000001fc11cc4:  a1 00 00 0b sb	zero,11(a4)
[ 251] 0x900000001fc11cc8:  24 02 00 02 li	v0,2
[ 251] 0x900000001fc11ccc:  24 a5 00 04 addiu	a1,a1,4
[ 251] 0x900000001fc11cd0:  a0 82 00 08 sb	v0,8(a0)
[ 251] 0x900000001fc11cd4:  90 86 00 09 lbu	a2,9(a0)
[ 251] 0x900000001fc11cd8:  30 c4 00 ff andi	a0,a2,0xff
[ 251] 0x900000001fc11cdc:  00 04 20 f8 dsll	a0,a0,3
[ 251] 0x900000001fc11ce0:  00 64 20 2d daddu	a0,v1,a0
[ 251] 0x900000001fc11ce4:  dc 84 00 00 ld	a0,0(a0)
[ 251] 0x900000001fc11ce8:  a0 80 00 0b sb	zero,11(a0)
[ 251] 0x900000001fc11cec:  a0 82 00 08 sb	v0,8(a0)
[ 251] 0x900000001fc11cf0:  90 84 00 09 lbu	a0,9(a0)
[ 251] 0x900000001fc11cf4:  30 84 00 ff andi	a0,a0,0xff
[ 251] 0x900000001fc11cf8:  00 04 20 f8 dsll	a0,a0,3
[ 251] 0x900000001fc11cfc:  00 64 20 2d daddu	a0,v1,a0
[ 251] 0x900000001fc11d00:  dc 84 00 00 ld	a0,0(a0)
[ 251] 0x900000001fc11d04:  a0 80 00 0b sb	zero,11(a0)
[ 251] 0x900000001fc11d08:  a0 82 00 08 sb	v0,8(a0)
[ 251] 0x900000001fc11d0c:  90 84 00 09 lbu	a0,9(a0)
[ 251] 0x900000001fc11d10:  30 84 00 ff andi	a0,a0,0xff
[ 251] 0x900000001fc11d14:  00 04 20 f8 dsll	a0,a0,3
[ 251] 0x900000001fc11d18:  00 64 20 2d daddu	a0,v1,a0
[ 251] 0x900000001fc11d1c:  dc 84 00 00 ld	a0,0(a0)
[ 251] 0x900000001fc11d20:  a0 80 00 0b sb	zero,11(a0)
[ 251] 0x900000001fc11d24:  a0 82 00 08 sb	v0,8(a0)
[ 251] 0x900000001fc11d28:  90 84 00 09 lbu	a0,9(a0)
[ 251] 0x900000001fc11d2c:  30 84 00 ff andi	a0,a0,0xff
[ 251] 0x900000001fc11d30:  00 04 20 f8 dsll	a0,a0,3
[ 251] 0x900000001fc11d34:  00 64 20 2d daddu	a0,v1,a0
[ 251] 0x900000001fc11d38:  dc 84 00 00 ld	a0,0(a0)
[ 251] 0x900000001fc11d3c:  00 80 20 25 move	a0,a0
[ 251] 0x900000001fc11d40:  00 a1 30 2a slt	a2,a1,at
[ 251] 0x900000001fc11d44:  a0 80 00 0b sb	zero,11(a0)
[ 251] 0x900000001fc11d48:  14 c0 ff e1 bne	a2,zero,0x900000001fc11cd0
[ 251] 0x900000001fc11d4c:  24 a5 00 04 addiu	a1,a1,4
[ 251] 0x900000001fc11d50:  90 81 00 09 lbu	at,9(a0)
[ 251] 0x900000001fc11d54:  30 22 00 ff andi	v0,at,0xff
[ 251] 0x900000001fc11d58:  00 02 10 f8 dsll	v0,v0,3
[ 251] 0x900000001fc11d5c:  24 01 00 02 li	at,2
[ 251] 0x900000001fc11d60:  00 62 10 2d daddu	v0,v1,v0
[ 251] 0x900000001fc11d64:  a0 81 00 08 sb	at,8(a0)
[ 251] 0x900000001fc11d68:  dc 42 00 00 ld	v0,0(v0)
[ 251] 0x900000001fc11d6c:  a0 41 00 08 sb	at,8(v0)
[ 251] 0x900000001fc11d70:  a0 40 00 0b sb	zero,11(v0)
[ 251] 0x900000001fc11d74:  90 42 00 09 lbu	v0,9(v0)
[ 251] 0x900000001fc11d78:  30 42 00 ff andi	v0,v0,0xff
[ 251] 0x900000001fc11d7c:  00 02 10 f8 dsll	v0,v0,3
[ 251] 0x900000001fc11d80:  00 62 10 2d daddu	v0,v1,v0
[ 251] 0x900000001fc11d84:  dc 42 00 00 ld	v0,0(v0)
[ 251] 0x900000001fc11d88:  a0 41 00 08 sb	at,8(v0)
[ 251] 0x900000001fc11d8c:  a0 40 00 0b sb	zero,11(v0)
[ 251] 0x900000001fc11d90:  90 42 00 09 lbu	v0,9(v0)
[ 251] 0x900000001fc11d94:  30 42 00 ff andi	v0,v0,0xff
[ 251] 0x900000001fc11d98:  00 02 10 f8 dsll	v0,v0,3
[ 251] 0x900000001fc11d9c:  00 62 10 2d daddu	v0,v1,v0
[ 251] 0x900000001fc11da0:  dc 42 00 00 ld	v0,0(v0)
[ 251] 0x900000001fc11da4:  a0 40 00 0b sb	zero,11(v0)
[ 251] 0x900000001fc11da8:  10 00 00 22 b		0x900000001fc11e34
[ 251] 0x900000001fc11dac:  a0 41 00 08 sb	at,8(v0)
[ 251] 0x900000001fc11db0:  91 02 00 09 lbu	v0,9(a4)
[ 251] 0x900000001fc11db4:  30 42 00 ff andi	v0,v0,0xff
[ 251] 0x900000001fc11db8:  00 02 10 f8 dsll	v0,v0,3
[ 251] 0x900000001fc11dbc:  a1 00 00 0b sb	zero,11(a4)
[ 251] 0x900000001fc11dc0:  24 04 00 02 li	a0,2
[ 251] 0x900000001fc11dc4:  00 62 10 2d daddu	v0,v1,v0
[ 251] 0x900000001fc11dc8:  a1 04 00 08 sb	a0,8(a4)
[ 251] 0x900000001fc11dcc:  dc 42 00 00 ld	v0,0(v0)
[ 251] 0x900000001fc11dd0:  a0 44 00 08 sb	a0,8(v0)
[ 251] 0x900000001fc11dd4:  a0 40 00 0b sb	zero,11(v0)
[ 251] 0x900000001fc11dd8:  90 42 00 09 lbu	v0,9(v0)
[ 251] 0x900000001fc11ddc:  30 42 00 ff andi	v0,v0,0xff
[ 251] 0x900000001fc11de0:  00 02 10 f8 dsll	v0,v0,3
[ 251] 0x900000001fc11de4:  00 62 10 2d daddu	v0,v1,v0
[ 251] 0x900000001fc11de8:  dc 42 00 00 ld	v0,0(v0)
[ 251] 0x900000001fc11dec:  a0 44 00 08 sb	a0,8(v0)
[ 251] 0x900000001fc11df0:  a0 40 00 0b sb	zero,11(v0)
[ 251] 0x900000001fc11df4:  90 42 00 09 lbu	v0,9(v0)
[ 251] 0x900000001fc11df8:  30 42 00 ff andi	v0,v0,0xff
[ 251] 0x900000001fc11dfc:  00 02 10 f8 dsll	v0,v0,3
[ 251] 0x900000001fc11e00:  00 62 10 2d daddu	v0,v1,v0
[ 251] 0x900000001fc11e04:  dc 42 00 00 ld	v0,0(v0)
[ 251] 0x900000001fc11e08:  a0 44 00 08 sb	a0,8(v0)
[ 251] 0x900000001fc11e0c:  a0 40 00 0b sb	zero,11(v0)
[ 251] 0x900000001fc11e10:  90 42 00 09 lbu	v0,9(v0)
[ 251] 0x900000001fc11e14:  30 42 00 ff andi	v0,v0,0xff
[ 251] 0x900000001fc11e18:  00 02 10 f8 dsll	v0,v0,3
[ 251] 0x900000001fc11e1c:  00 62 20 2d daddu	a0,v1,v0
[ 251] 0x900000001fc11e20:  26 10 00 04 addiu	s0,s0,4
[ 251] 0x900000001fc11e24:  02 01 10 2a slt	v0,s0,at
[ 251] 0x900000001fc11e28:  dc 88 00 00 ld	a4,0(a0)
[ 251] 0x900000001fc11e2c:  14 40 ff e0 bne	v0,zero,0x900000001fc11db0
[ 251] 0x900000001fc11e30:  00 00 00 21 nada
[ 257] 0x900000001fc11e34:  ff b6 00 68 sd	s6,104(sp)
[ 257] 0x900000001fc11e38:  00 17 48 80 sll	a5,s7,2
[ 177] 0x900000001fc11e3c:  02 e0 50 25 move	a6,s7
[ 177] 0x900000001fc11e40:  03 c9 08 2d daddu	at,s8,a5
[ 177] 0x900000001fc11e44:  00 01 10 f8 dsll	v0,at,3
[ 177] 0x900000001fc11e48:  df a1 00 58 ld	at,88(sp)
[ 177] 0x900000001fc11e4c:  16 f5 ff 23 bne	s7,s5,0x900000001fc11adc
[ 177] 0x900000001fc11e50:  00 22 08 2d daddu	at,at,v0
[ 177] 0x900000001fc11e54:  df b7 00 80 ld	s7,128(sp)
[ 177] 0x900000001fc11e58:  00 00 50 25 move	a6,zero
[ 176] 0x900000001fc11e5c:  26 f7 00 01 addiu	s7,s7,1
[ 176] 0x900000001fc11e60:  df a1 00 78 ld	at,120(sp)
[ 176] 0x900000001fc11e64:  56 e1 ff 15 bnel	s7,at,0x900000001fc11abc
[ 176] 0x900000001fc11e68:  00 0a 48 80 sll	a5,a6,2
[ 176] 0x900000001fc11e6c:  df bf 00 50 ld	ra,80(sp)
[ 176] 0x900000001fc11e70:  df b1 00 58 ld	s1,88(sp)
  263: 	    }
  264: 	}    /* end for lf */
  265:     }    /* end for b */
  266: 
  267:     if (failed) {
[ 267] 0x900000001fc11e74:  df a1 00 68 ld	at,104(sp)
[ 267] 0x900000001fc11e78:  33 f2 00 03 andi	s2,ra,0x3
[ 267] 0x900000001fc11e7c:  24 02 00 01 li	v0,1
[ 267] 0x900000001fc11e80:  df a6 00 50 ld	a2,80(sp)
[ 267] 0x900000001fc11e84:  14 20 00 03 bne	at,zero,0x900000001fc11e94
[ 267] 0x900000001fc11e88:  00 00 80 25 move	s0,zero
  268: 	DPRINTF(("Couldn't build an interleave at some point\n"));
  269: 
  270: 	/* Clean up any unusable banks */
  271: 	for (cb = 0; cb < num_banks; cb++)
  272: 	    if (bank[cb]->bnk_used == 2)
  273: 		bank[cb]->bnk_used = 0;
  274: 
  275: 	    return FAIL;
  276:     } else {
  277: 	DPRINTF(("  Successfully built interleave\n"));
  278: 	return SUCCEED;
[ 278] 0x900000001fc11e8c:  10 00 00 b2 b		0x900000001fc12158
[ 278] 0x900000001fc11e90:  df b1 00 c0 ld	s1,192(sp)
[ 271] 0x900000001fc11e94:  df a2 00 50 ld	v0,80(sp)
[ 271] 0x900000001fc11e98:  58 40 00 ae blezl	v0,0x900000001fc12154
[ 271] 0x900000001fc11e9c:  00 00 10 25 move	v0,zero
[ 271] 0x900000001fc11ea0:  52 40 00 0d beql	s2,zero,0x900000001fc11ed8
[ 271] 0x900000001fc11ea4:  df a8 00 58 ld	a4,88(sp)
[ 271] 0x900000001fc11ea8:  00 12 18 3c dsll32	v1,s2,0
[ 271] 0x900000001fc11eac:  00 03 1f 7a dsrl	v1,v1,29
[ 271] 0x900000001fc11eb0:  24 01 00 02 li	at,2
[ 271] 0x900000001fc11eb4:  02 23 98 2d daddu	s3,s1,v1
[ 272] 0x900000001fc11eb8:  de 34 00 00 ld	s4,0(s1)
[ 272] 0x900000001fc11ebc:  92 84 00 08 lbu	a0,8(s4)
[ 272] 0x900000001fc11ec0:  14 81 00 02 bne	a0,at,0x900000001fc11ecc
[ 272] 0x900000001fc11ec4:  66 31 00 08 daddiu	s1,s1,8
[ 273] 0x900000001fc11ec8:  a2 80 00 08 sb	zero,8(s4)
[ 271] 0x900000001fc11ecc:  16 33 ff fa bne	s1,s3,0x900000001fc11eb8
[ 271] 0x900000001fc11ed0:  26 10 00 01 addiu	s0,s0,1
[ 271] 0x900000001fc11ed4:  df a8 00 58 ld	a4,88(sp)
[ 271] 0x900000001fc11ed8:  df a7 00 50 ld	a3,80(sp)
[ 271] 0x900000001fc11edc:  00 10 48 f8 dsll	a5,s0,3
[ 271] 0x900000001fc11ee0:  26 05 00 03 addiu	a1,s0,3
[ 271] 0x900000001fc11ee4:  00 07 38 82 srl	a3,a3,2
[ 271] 0x900000001fc11ee8:  00 a6 28 2a slt	a1,a1,a2
[ 271] 0x900000001fc11eec:  50 a0 00 99 beql	a1,zero,0x900000001fc12154
[ 271] 0x900000001fc11ef0:  00 00 10 25 move	v0,zero
[ 271] 0x900000001fc11ef4:  00 07 38 3c dsll32	a3,a3,0
[ 271] 0x900000001fc11ef8:  01 09 88 2d daddu	s1,a4,a5
[ 271] 0x900000001fc11efc:  00 07 3e fa dsrl	a3,a3,27
[ 271] 0x900000001fc11f00:  02 27 90 2d daddu	s2,s1,a3
[ 271] 0x900000001fc11f04:  02 20 38 25 move	a3,s1
[ 271] 0x900000001fc11f08:  66 2a 00 20 daddiu	a6,s1,32
[ 271] 0x900000001fc11f0c:  11 52 00 7a beq	a6,s2,0x900000001fc120f8
[ 271] 0x900000001fc11f10:  24 01 00 02 li	at,2
[ 271] 0x900000001fc11f14:  24 0b 00 20 li	a7,32
[ 271] 0x900000001fc11f18:  66 28 00 20 daddiu	a4,s1,32
[ 271] 0x900000001fc11f1c:  de 23 00 00 ld	v1,0(s1)
[ 271] 0x900000001fc11f20:  02 4b 10 2f dsubu	v0,s2,a7
[ 271] 0x900000001fc11f24:  90 64 00 08 lbu	a0,8(v1)
[ 271] 0x900000001fc11f28:  00 81 20 26 xor	a0,a0,at
[ 271] 0x900000001fc11f2c:  67 a5 00 40 daddiu	a1,sp,64
[ 271] 0x900000001fc11f30:  00 64 28 0a movz	a1,v1,a0
[ 271] 0x900000001fc11f34:  00 00 00 21 nada
[ 271] 0x900000001fc11f38:  00 00 00 21 nada
[ 271] 0x900000001fc11f3c:  00 00 00 21 nada
[ 271] 0x900000001fc11f40:  a0 a0 00 08 sb	zero,8(a1)
[ 271] 0x900000001fc11f44:  dc e4 00 08 ld	a0,8(a3)
[ 271] 0x900000001fc11f48:  90 85 00 08 lbu	a1,8(a0)
[ 271] 0x900000001fc11f4c:  00 a1 28 26 xor	a1,a1,at
[ 271] 0x900000001fc11f50:  67 a6 00 40 daddiu	a2,sp,64
[ 271] 0x900000001fc11f54:  00 85 30 0a movz	a2,a0,a1
[ 271] 0x900000001fc11f58:  00 00 00 21 nada
[ 271] 0x900000001fc11f5c:  00 00 00 21 nada
[ 271] 0x900000001fc11f60:  00 00 00 21 nada
[ 271] 0x900000001fc11f64:  a0 c0 00 08 sb	zero,8(a2)
[ 271] 0x900000001fc11f68:  dc e4 00 10 ld	a0,16(a3)
[ 271] 0x900000001fc11f6c:  90 85 00 08 lbu	a1,8(a0)
[ 271] 0x900000001fc11f70:  00 a1 28 26 xor	a1,a1,at
[ 271] 0x900000001fc11f74:  67 a6 00 40 daddiu	a2,sp,64
[ 271] 0x900000001fc11f78:  00 85 30 0a movz	a2,a0,a1
[ 271] 0x900000001fc11f7c:  00 00 00 21 nada
[ 271] 0x900000001fc11f80:  00 00 00 21 nada
[ 271] 0x900000001fc11f84:  00 00 00 21 nada
[ 271] 0x900000001fc11f88:  a0 c0 00 08 sb	zero,8(a2)
[ 271] 0x900000001fc11f8c:  dc e4 00 18 ld	a0,24(a3)
[ 271] 0x900000001fc11f90:  90 85 00 08 lbu	a1,8(a0)
[ 271] 0x900000001fc11f94:  00 a1 28 26 xor	a1,a1,at
[ 271] 0x900000001fc11f98:  67 a6 00 40 daddiu	a2,sp,64
[ 271] 0x900000001fc11f9c:  00 85 30 0a movz	a2,a0,a1
[ 271] 0x900000001fc11fa0:  00 00 00 21 nada
[ 271] 0x900000001fc11fa4:  00 00 00 21 nada
[ 271] 0x900000001fc11fa8:  00 00 00 21 nada
[ 271] 0x900000001fc11fac:  a0 c0 00 08 sb	zero,8(a2)
[ 271] 0x900000001fc11fb0:  65 07 00 20 daddiu	a3,a4,32
[ 271] 0x900000001fc11fb4:  11 02 00 4d beq	a4,v0,0x900000001fc120ec
[ 271] 0x900000001fc11fb8:  dd 03 00 00 ld	v1,0(a4)
[ 271] 0x900000001fc11fbc:  90 64 00 08 lbu	a0,8(v1)
[ 271] 0x900000001fc11fc0:  00 81 20 26 xor	a0,a0,at
[ 271] 0x900000001fc11fc4:  67 a5 00 40 daddiu	a1,sp,64
[ 271] 0x900000001fc11fc8:  00 64 28 0a movz	a1,v1,a0
[ 271] 0x900000001fc11fcc:  00 00 00 21 nada
[ 271] 0x900000001fc11fd0:  00 00 00 21 nada
[ 271] 0x900000001fc11fd4:  00 00 00 21 nada
[ 271] 0x900000001fc11fd8:  a0 a0 00 08 sb	zero,8(a1)
[ 271] 0x900000001fc11fdc:  dd 04 00 08 ld	a0,8(a4)
[ 271] 0x900000001fc11fe0:  90 85 00 08 lbu	a1,8(a0)
[ 271] 0x900000001fc11fe4:  00 a1 28 26 xor	a1,a1,at
[ 271] 0x900000001fc11fe8:  67 a6 00 40 daddiu	a2,sp,64
[ 271] 0x900000001fc11fec:  00 85 30 0a movz	a2,a0,a1
[ 271] 0x900000001fc11ff0:  00 00 00 21 nada
[ 271] 0x900000001fc11ff4:  00 00 00 21 nada
[ 271] 0x900000001fc11ff8:  00 00 00 21 nada
[ 271] 0x900000001fc11ffc:  a0 c0 00 08 sb	zero,8(a2)
[ 271] 0x900000001fc12000:  dd 04 00 10 ld	a0,16(a4)
[ 271] 0x900000001fc12004:  90 85 00 08 lbu	a1,8(a0)
[ 271] 0x900000001fc12008:  00 a1 28 26 xor	a1,a1,at
[ 271] 0x900000001fc1200c:  67 a6 00 40 daddiu	a2,sp,64
[ 271] 0x900000001fc12010:  00 85 30 0a movz	a2,a0,a1
[ 271] 0x900000001fc12014:  00 00 00 21 nada
[ 271] 0x900000001fc12018:  00 00 00 21 nada
[ 271] 0x900000001fc1201c:  00 00 00 21 nada
[ 271] 0x900000001fc12020:  a0 c0 00 08 sb	zero,8(a2)
[ 271] 0x900000001fc12024:  dd 04 00 18 ld	a0,24(a4)
[ 271] 0x900000001fc12028:  90 85 00 08 lbu	a1,8(a0)
[ 271] 0x900000001fc1202c:  00 a1 28 26 xor	a1,a1,at
[ 271] 0x900000001fc12030:  67 a6 00 40 daddiu	a2,sp,64
[ 271] 0x900000001fc12034:  00 85 30 0a movz	a2,a0,a1
[ 271] 0x900000001fc12038:  00 00 00 21 nada
[ 271] 0x900000001fc1203c:  00 00 00 21 nada
[ 271] 0x900000001fc12040:  00 00 00 21 nada
[ 271] 0x900000001fc12044:  a0 c0 00 08 sb	zero,8(a2)
[ 271] 0x900000001fc12048:  64 e8 00 20 daddiu	a4,a3,32
[ 271] 0x900000001fc1204c:  14 e2 ff b5 bne	a3,v0,0x900000001fc11f24
[ 271] 0x900000001fc12050:  dc e3 00 00 ld	v1,0(a3)
[ 271] 0x900000001fc12054:  00 e0 80 25 move	s0,a3
[ 271] 0x900000001fc12058:  00 60 88 25 move	s1,v1
[ 271] 0x900000001fc1205c:  92 32 00 08 lbu	s2,8(s1)
[ 271] 0x900000001fc12060:  67 af 00 40 daddiu	t3,sp,64
[ 271] 0x900000001fc12064:  02 41 90 26 xor	s2,s2,at
[ 271] 0x900000001fc12068:  02 32 78 0a movz	t3,s1,s2
[ 271] 0x900000001fc1206c:  00 00 00 21 nada
[ 271] 0x900000001fc12070:  00 00 00 21 nada
[ 271] 0x900000001fc12074:  00 00 00 21 nada
[ 271] 0x900000001fc12078:  a1 e0 00 08 sb	zero,8(t3)
[ 271] 0x900000001fc1207c:  de 0f 00 08 ld	t3,8(s0)
[ 271] 0x900000001fc12080:  91 f1 00 08 lbu	s1,8(t3)
[ 271] 0x900000001fc12084:  67 ae 00 40 daddiu	t2,sp,64
[ 271] 0x900000001fc12088:  02 21 88 26 xor	s1,s1,at
[ 271] 0x900000001fc1208c:  01 f1 70 0a movz	t2,t3,s1
[ 271] 0x900000001fc12090:  00 00 00 21 nada
[ 271] 0x900000001fc12094:  00 00 00 21 nada
[ 271] 0x900000001fc12098:  00 00 00 21 nada
[ 271] 0x900000001fc1209c:  a1 c0 00 08 sb	zero,8(t2)
[ 271] 0x900000001fc120a0:  de 0e 00 10 ld	t2,16(s0)
[ 271] 0x900000001fc120a4:  91 cf 00 08 lbu	t3,8(t2)
[ 271] 0x900000001fc120a8:  67 ad 00 40 daddiu	t1,sp,64
[ 271] 0x900000001fc120ac:  01 e1 78 26 xor	t3,t3,at
[ 271] 0x900000001fc120b0:  01 cf 68 0a movz	t1,t2,t3
[ 271] 0x900000001fc120b4:  00 00 00 21 nada
[ 271] 0x900000001fc120b8:  00 00 00 21 nada
[ 271] 0x900000001fc120bc:  00 00 00 21 nada
[ 271] 0x900000001fc120c0:  a1 a0 00 08 sb	zero,8(t1)
[ 271] 0x900000001fc120c4:  de 0d 00 18 ld	t1,24(s0)
[ 271] 0x900000001fc120c8:  91 ae 00 08 lbu	t2,8(t1)
[ 271] 0x900000001fc120cc:  67 ac 00 40 daddiu	t0,sp,64
[ 271] 0x900000001fc120d0:  01 c1 70 26 xor	t2,t2,at
[ 271] 0x900000001fc120d4:  01 ae 60 0a movz	t0,t1,t2
[ 271] 0x900000001fc120d8:  00 00 00 21 nada
[ 271] 0x900000001fc120dc:  00 00 00 21 nada
[ 271] 0x900000001fc120e0:  00 00 00 21 nada
[ 271] 0x900000001fc120e4:  10 00 00 1a b		0x900000001fc12150
[ 271] 0x900000001fc120e8:  a1 80 00 08 sb	zero,8(t0)
[ 271] 0x900000001fc120ec:  01 00 80 25 move	s0,a4
[ 271] 0x900000001fc120f0:  10 00 ff da b		0x900000001fc1205c
[ 271] 0x900000001fc120f4:  00 60 88 25 move	s1,v1
[ 271] 0x900000001fc120f8:  de 34 00 00 ld	s4,0(s1)
[ 271] 0x900000001fc120fc:  92 93 00 08 lbu	s3,8(s4)
[ 271] 0x900000001fc12100:  56 61 00 03 bnel	s3,at,0x900000001fc12110
[ 271] 0x900000001fc12104:  de 30 00 08 ld	s0,8(s1)
[ 271] 0x900000001fc12108:  a2 80 00 08 sb	zero,8(s4)
[ 271] 0x900000001fc1210c:  de 30 00 08 ld	s0,8(s1)
[ 271] 0x900000001fc12110:  92 14 00 08 lbu	s4,8(s0)
[ 271] 0x900000001fc12114:  56 81 00 03 bnel	s4,at,0x900000001fc12124
[ 271] 0x900000001fc12118:  de 30 00 10 ld	s0,16(s1)
[ 271] 0x900000001fc1211c:  a2 00 00 08 sb	zero,8(s0)
[ 271] 0x900000001fc12120:  de 30 00 10 ld	s0,16(s1)
[ 271] 0x900000001fc12124:  92 15 00 08 lbu	s5,8(s0)
[ 271] 0x900000001fc12128:  56 a1 00 03 bnel	s5,at,0x900000001fc12138
[ 271] 0x900000001fc1212c:  de 30 00 18 ld	s0,24(s1)
[ 271] 0x900000001fc12130:  a2 00 00 08 sb	zero,8(s0)
[ 271] 0x900000001fc12134:  de 30 00 18 ld	s0,24(s1)
[ 271] 0x900000001fc12138:  92 16 00 08 lbu	s6,8(s0)
[ 271] 0x900000001fc1213c:  16 c1 00 02 bne	s6,at,0x900000001fc12148
[ 271] 0x900000001fc12140:  66 31 00 20 daddiu	s1,s1,32
[ 271] 0x900000001fc12144:  a2 00 00 08 sb	zero,8(s0)
[ 271] 0x900000001fc12148:  56 32 ff ec bnel	s1,s2,0x900000001fc120fc
[ 271] 0x900000001fc1214c:  de 34 00 00 ld	s4,0(s1)
[ 275] 0x900000001fc12150:  00 00 10 25 move	v0,zero
[ 275] 0x900000001fc12154:  df b1 00 c0 ld	s1,192(sp)
[ 275] 0x900000001fc12158:  df b3 00 b0 ld	s3,176(sp)
[ 275] 0x900000001fc1215c:  df b5 00 a0 ld	s5,160(sp)
[ 275] 0x900000001fc12160:  df be 00 88 ld	s8,136(sp)
[ 275] 0x900000001fc12164:  df bf 00 d0 ld	ra,208(sp)
[ 275] 0x900000001fc12168:  df b6 00 98 ld	s6,152(sp)
[ 275] 0x900000001fc1216c:  df b4 00 a8 ld	s4,168(sp)
[ 275] 0x900000001fc12170:  df b2 00 b8 ld	s2,184(sp)
[ 275] 0x900000001fc12174:  df b0 00 c8 ld	s0,200(sp)
[ 275] 0x900000001fc12178:  df b7 00 90 ld	s7,144(sp)
[ 275] 0x900000001fc1217c:  03 e0 00 08 jr	ra
[ 275] 0x900000001fc12180:  67 bd 00 e0 daddiu	sp,sp,224
  279:     }
  280: }
  281: 
  282: 
  283: /*
  284:  * interleave()
  285:  *	Configures the memory banks contained in the banks array
  286:  *	using one of a couple different memory configuration algorithms.
  287:  *	Currently, the following algorithms are supported:
  288:  *		INTLV_ONEWAY -- Use 1-way interleaving for all banks.
  289:  *		INTLV_STABLE -- Use an interleaving technique which provides
  290:  *		   the most stable latency times.  This technique insures that
  291:  *		   all memory will have roughly the same latencies, but it
  292:  *		   sacrifices the spedups of potentially larger interleaves.
  293:  *		INTLV_OPTIMAL -- Use a technique which will always construct
  294:  *		   the largest interleaves possible.  This will produce the
  295:  *		   fastest memory configuration, but the response time 
  296:  *		   variance will increase.
  297:  * 
  298:  * Parameters:
  299:  *	num_banks -- the actual number of banks in the bank array
  300:  *	banks -- the initializes banks array
  301:  *	intlv_type -- Which of three interleave methods to use.
  302:  * Returns:
  303:  *	the most significant 32 bits of a 40 bit physical memory
  304:  *	space value.
  305:  */
  306: 
  307: static unsigned
  308: interleave(int num_banks, evbnkcfg_t *banks[], int intlv_type)
  309: {
interleave:
[ 309] 0x900000001fc12184:  67 bd fe 50 daddiu	sp,sp,-432
[ 309] 0x900000001fc12188:  ff b2 01 48 sd	s2,328(sp)
[ 309] 0x900000001fc1218c:  00 80 90 25 move	s2,a0
  310:     int cap = 16;	/* Start trying to build 16-way interleaves */
  311:     int stable;		/* Flag indicating we should use stable interleaving */
  312:     int b;		/* Bank loop index */
  313:     int base; 		/* Base address for bank interleaving */
  314:     int	ilf;		/* Interleave factor */
  315:     int ilp;		/* Interleave position */
  316:     int i,j;		/* Random index variable */
  317:     int curr_bank;	/* Index of current bank in bank array */
  318:     int prev_bank;	/* previous bank */
  319:     int memdex;		/* Index into memory size table */
  320:     int num_index;	/* Number of interleaves in index array */
  321:     unchar index[64]; /* Array of indices to be sorted by size */
  322:  
  323:     /* Set the cap to 1 to force 1-way interleaving. */
  324:     switch (intlv_type) {
[ 324] 0x900000001fc12190:  24 01 00 01 li	at,1
[ 310] 0x900000001fc12194:  ff b0 01 58 sd	s0,344(sp)
[ 310] 0x900000001fc12198:  24 10 00 01 li	s0,1
[ 310] 0x900000001fc1219c:  ff b1 01 50 sd	s1,336(sp)
[ 310] 0x900000001fc121a0:  24 11 00 01 li	s1,1
[ 310] 0x900000001fc121a4:  ff bf 01 60 sd	ra,352(sp)
[ 310] 0x900000001fc121a8:  14 c0 00 03 bne	a2,zero,0x900000001fc121b8
[ 310] 0x900000001fc121ac:  ff a5 00 50 sd	a1,80(sp)
  325:       case INTLV_ONEWAY:
  326: 	cap = 1;
  327: 	stable = 1;
[ 327] 0x900000001fc121b0:  10 00 00 0c b		0x900000001fc121e4
[ 327] 0x900000001fc121b4:  02 20 38 25 move	a3,s1
[ 327] 0x900000001fc121b8:  54 c1 00 06 bnel	a2,at,0x900000001fc121d4
[ 327] 0x900000001fc121bc:  24 10 00 08 li	s0,8
[ 327] 0x900000001fc121c0:  24 11 00 01 li	s1,1
  328: 	break;
  329: 
  330:       case INTLV_STABLE:
  331: 	cap = 8;
[ 331] 0x900000001fc121c4:  24 10 00 08 li	s0,8
  332: 	stable = 1;
[ 332] 0x900000001fc121c8:  10 00 00 06 b		0x900000001fc121e4
[ 332] 0x900000001fc121cc:  02 20 38 25 move	a3,s1
[ 332] 0x900000001fc121d0:  24 10 00 08 li	s0,8
[ 332] 0x900000001fc121d4:  24 07 00 02 li	a3,2
[ 332] 0x900000001fc121d8:  14 c7 04 62 bne	a2,a3,0x900000001fc13364
[ 332] 0x900000001fc121dc:  00 00 88 25 move	s1,zero
  333: 	break;
  334: 
  335:       case INTLV_OPTIMAL:
  336: 	cap = 8;
  337: 	stable = 0;
  338: 	break;
  339: 
  340:       default:
  341: 	loprintf("interleave: Bad type argument\n");
  342: 	return 0;
  343:     }
  344:  
  345:     /* Configure the memory.  We start by trying to interleave
  346:      * the memory with the largest interleave value possible.
  347:      * If this fails, we try the next smallest interleave factor,
  348:      * and so on. Since a one-way interleave will always work,
  349:      * this loop must eventually terminate.  If we are doing an
  350:      * optimal interleave, we  
  351:      */
  352:     while (build_interleave(num_banks, banks, cap, stable) == FAIL) {
[ 352] 0x900000001fc121e0:  02 20 38 25 move	a3,s1
[ 352] 0x900000001fc121e4:  02 00 30 25 move	a2,s0
[ 352] 0x900000001fc121e8:  02 40 20 25 move	a0,s2
[ 352] 0x900000001fc121ec:  0f f0 46 07 jal		build_interleave
[ 352] 0x900000001fc121f0:  df a5 00 50 ld	a1,80(sp)
[ 352] 0x900000001fc121f4:  54 40 00 0c bnel	v0,zero,0x900000001fc12228
[ 352] 0x900000001fc121f8:  df b1 00 50 ld	s1,80(sp)
[ 352] 0x900000001fc121fc:  02 20 38 25 move	a3,s1
  353: 	cap >>= 1;
[ 353] 0x900000001fc12200:  00 10 80 43 sra	s0,s0,1
  354: 
  355: 	/* This should never happen */
  356: 	if (cap == 0) return FAIL;
[ 356] 0x900000001fc12204:  52 00 04 55 beql	s0,zero,0x900000001fc1335c
[ 356] 0x900000001fc12208:  df b2 01 48 ld	s2,328(sp)
[ 352] 0x900000001fc1220c:  02 00 30 25 move	a2,s0
[ 352] 0x900000001fc12210:  02 40 20 25 move	a0,s2
[ 352] 0x900000001fc12214:  0f f0 46 07 jal		build_interleave
[ 352] 0x900000001fc12218:  df a5 00 50 ld	a1,80(sp)
[ 352] 0x900000001fc1221c:  50 40 ff f8 beql	v0,zero,0x900000001fc12200
[ 352] 0x900000001fc12220:  02 20 38 25 move	a3,s1
[ 352] 0x900000001fc12224:  df b1 00 50 ld	s1,80(sp)
  357:     }
  358: 
  359:     /* At this point, all of the memory in the banks array should
  360:      * be fully configured using the largest stable interleaving
  361:      * possible.  We now go through all of the banks and actually
  362:      * program the configuration registers with the appropriate
  363:      * values.  Because the base address of a memory bank must
  364:      * be an integral multiple of the bank size, we start with
  365:      * the largest bank sizes first and work our way down.
  366:      */
  367: 
  368:     base = 0;
  369: 
  370:     /* Create an array of the indices of the first banks of all of the
  371:      * interleaves.
  372:      */
  373:     num_index = 0;
[ 373] 0x900000001fc12228:  00 00 40 25 move	a4,zero
  374:     for (b = 0; b < num_banks; b++) 
[ 374] 0x900000001fc1222c:  00 00 80 25 move	s0,zero
[ 368] 0x900000001fc12230:  ff a0 00 58 sd	zero,88(sp)
[ 368] 0x900000001fc12234:  1a 40 00 aa blez	s2,0x900000001fc124e0
[ 368] 0x900000001fc12238:  32 41 00 03 andi	at,s2,0x3
[ 368] 0x900000001fc1223c:  ff b3 01 40 sd	s3,320(sp)
[ 368] 0x900000001fc12240:  50 20 00 10 beql	at,zero,0x900000001fc12284
[ 368] 0x900000001fc12244:  df ae 00 50 ld	t2,80(sp)
[ 368] 0x900000001fc12248:  00 01 48 3c dsll32	a5,at,0
[ 368] 0x900000001fc1224c:  00 09 4f 7a dsrl	a5,a5,29
[ 368] 0x900000001fc12250:  02 29 98 2d daddu	s3,s1,a5
[ 368] 0x900000001fc12254:  01 00 58 25 move	a7,a4
  375: 	if (banks[b]->bnk_count) 
[ 375] 0x900000001fc12258:  de 2a 00 00 ld	a6,0(s1)
[ 375] 0x900000001fc1225c:  03 ab 58 2d daddu	a7,sp,a7
[ 375] 0x900000001fc12260:  91 4a 00 0b lbu	a6,11(a6)
[ 375] 0x900000001fc12264:  11 40 00 03 beq	a6,zero,0x900000001fc12274
[ 375] 0x900000001fc12268:  66 31 00 08 daddiu	s1,s1,8
  376: 	   index[num_index++] = b;
[ 376] 0x900000001fc1226c:  25 08 00 01 addiu	a4,a4,1
[ 376] 0x900000001fc12270:  a1 70 01 70 sb	s0,368(a7)
[ 374] 0x900000001fc12274:  16 33 ff f7 bne	s1,s3,0x900000001fc12254
[ 374] 0x900000001fc12278:  26 10 00 01 addiu	s0,s0,1
[ 374] 0x900000001fc1227c:  df b3 01 40 ld	s3,320(sp)
[ 374] 0x900000001fc12280:  df ae 00 50 ld	t2,80(sp)
[ 374] 0x900000001fc12284:  00 12 68 82 srl	t1,s2,2
[ 374] 0x900000001fc12288:  26 0c 00 03 addiu	t0,s0,3
[ 374] 0x900000001fc1228c:  01 92 60 2a slt	t0,t0,s2
[ 374] 0x900000001fc12290:  11 80 00 93 beq	t0,zero,0x900000001fc124e0
[ 374] 0x900000001fc12294:  00 10 78 f8 dsll	t3,s0,3
[ 374] 0x900000001fc12298:  01 00 30 25 move	a2,a4
[ 374] 0x900000001fc1229c:  00 0d 68 3c dsll32	t1,t1,0
[ 374] 0x900000001fc122a0:  01 cf 50 2d daddu	a6,t2,t3
[ 374] 0x900000001fc122a4:  00 0d 6e fa dsrl	t1,t1,27
[ 374] 0x900000001fc122a8:  02 00 38 25 move	a3,s0
[ 374] 0x900000001fc122ac:  01 4d 08 2d daddu	at,a6,t1
[ 374] 0x900000001fc122b0:  dd 42 00 00 ld	v0,0(a6)
[ 374] 0x900000001fc122b4:  03 a6 18 2d daddu	v1,sp,a2
[ 374] 0x900000001fc122b8:  64 63 01 70 daddiu	v1,v1,368
[ 374] 0x900000001fc122bc:  67 a4 00 40 daddiu	a0,sp,64
[ 374] 0x900000001fc122c0:  90 42 00 0b lbu	v0,11(v0)
[ 374] 0x900000001fc122c4:  00 62 20 0b movn	a0,v1,v0
[ 374] 0x900000001fc122c8:  00 00 00 21 nada
[ 374] 0x900000001fc122cc:  00 00 00 21 nada
[ 374] 0x900000001fc122d0:  00 00 00 21 nada
[ 374] 0x900000001fc122d4:  24 e8 00 04 addiu	a4,a3,4
[ 374] 0x900000001fc122d8:  a0 87 00 00 sb	a3,0(a0)
[ 374] 0x900000001fc122dc:  24 c4 00 01 addiu	a0,a2,1
[ 374] 0x900000001fc122e0:  24 e3 00 01 addiu	v1,a3,1
[ 374] 0x900000001fc122e4:  00 82 30 0b movn	a2,a0,v0
[ 374] 0x900000001fc122e8:  00 00 00 21 nada
[ 374] 0x900000001fc122ec:  00 00 00 21 nada
[ 374] 0x900000001fc122f0:  00 00 00 21 nada
[ 374] 0x900000001fc122f4:  dd 42 00 08 ld	v0,8(a6)
[ 374] 0x900000001fc122f8:  24 c4 00 01 addiu	a0,a2,1
[ 374] 0x900000001fc122fc:  03 a6 28 2d daddu	a1,sp,a2
[ 374] 0x900000001fc12300:  64 a5 01 70 daddiu	a1,a1,368
[ 374] 0x900000001fc12304:  67 a9 00 40 daddiu	a5,sp,64
[ 374] 0x900000001fc12308:  90 42 00 0b lbu	v0,11(v0)
[ 374] 0x900000001fc1230c:  00 a2 48 0b movn	a5,a1,v0
[ 374] 0x900000001fc12310:  00 00 00 21 nada
[ 374] 0x900000001fc12314:  00 00 00 21 nada
[ 374] 0x900000001fc12318:  00 00 00 21 nada
[ 374] 0x900000001fc1231c:  00 82 30 0b movn	a2,a0,v0
[ 374] 0x900000001fc12320:  00 00 00 21 nada
[ 374] 0x900000001fc12324:  00 00 00 21 nada
[ 374] 0x900000001fc12328:  00 00 00 21 nada
[ 374] 0x900000001fc1232c:  24 c4 00 01 addiu	a0,a2,1
[ 374] 0x900000001fc12330:  03 a6 10 2d daddu	v0,sp,a2
[ 374] 0x900000001fc12334:  a1 23 00 00 sb	v1,0(a5)
[ 374] 0x900000001fc12338:  64 45 01 70 daddiu	a1,v0,368
[ 374] 0x900000001fc1233c:  dd 43 00 10 ld	v1,16(a6)
[ 374] 0x900000001fc12340:  24 e2 00 02 addiu	v0,a3,2
[ 374] 0x900000001fc12344:  67 a9 00 40 daddiu	a5,sp,64
[ 374] 0x900000001fc12348:  90 63 00 0b lbu	v1,11(v1)
[ 374] 0x900000001fc1234c:  00 a3 48 0b movn	a5,a1,v1
[ 374] 0x900000001fc12350:  00 00 00 21 nada
[ 374] 0x900000001fc12354:  00 00 00 21 nada
[ 374] 0x900000001fc12358:  00 00 00 21 nada
[ 374] 0x900000001fc1235c:  00 83 30 0b movn	a2,a0,v1
[ 374] 0x900000001fc12360:  00 00 00 21 nada
[ 374] 0x900000001fc12364:  00 00 00 21 nada
[ 374] 0x900000001fc12368:  00 00 00 21 nada
[ 374] 0x900000001fc1236c:  24 c4 00 01 addiu	a0,a2,1
[ 374] 0x900000001fc12370:  03 a6 18 2d daddu	v1,sp,a2
[ 374] 0x900000001fc12374:  a1 22 00 00 sb	v0,0(a5)
[ 374] 0x900000001fc12378:  64 65 01 70 daddiu	a1,v1,368
[ 374] 0x900000001fc1237c:  dd 42 00 18 ld	v0,24(a6)
[ 374] 0x900000001fc12380:  67 a9 00 40 daddiu	a5,sp,64
[ 374] 0x900000001fc12384:  90 43 00 0b lbu	v1,11(v0)
[ 374] 0x900000001fc12388:  00 a3 48 0b movn	a5,a1,v1
[ 374] 0x900000001fc1238c:  00 00 00 21 nada
[ 374] 0x900000001fc12390:  00 00 00 21 nada
[ 374] 0x900000001fc12394:  00 00 00 21 nada
[ 374] 0x900000001fc12398:  24 e2 00 03 addiu	v0,a3,3
[ 374] 0x900000001fc1239c:  65 4a 00 20 daddiu	a6,a6,32
[ 374] 0x900000001fc123a0:  a1 22 00 00 sb	v0,0(a5)
[ 374] 0x900000001fc123a4:  00 83 30 0b movn	a2,a0,v1
[ 374] 0x900000001fc123a8:  00 00 00 21 nada
[ 374] 0x900000001fc123ac:  00 00 00 21 nada
[ 374] 0x900000001fc123b0:  00 00 00 21 nada
[ 374] 0x900000001fc123b4:  11 41 00 48 beq	a6,at,0x900000001fc124d8
[ 374] 0x900000001fc123b8:  00 00 00 21 nada
[ 374] 0x900000001fc123bc:  dd 45 00 00 ld	a1,0(a6)
[ 374] 0x900000001fc123c0:  03 a6 10 2d daddu	v0,sp,a2
[ 374] 0x900000001fc123c4:  64 43 01 70 daddiu	v1,v0,368
[ 374] 0x900000001fc123c8:  67 a4 00 40 daddiu	a0,sp,64
[ 374] 0x900000001fc123cc:  90 a2 00 0b lbu	v0,11(a1)
[ 374] 0x900000001fc123d0:  00 62 20 0b movn	a0,v1,v0
[ 374] 0x900000001fc123d4:  00 00 00 21 nada
[ 374] 0x900000001fc123d8:  00 00 00 21 nada
[ 374] 0x900000001fc123dc:  00 00 00 21 nada
[ 374] 0x900000001fc123e0:  25 07 00 04 addiu	a3,a4,4
[ 374] 0x900000001fc123e4:  a0 88 00 00 sb	a4,0(a0)
[ 374] 0x900000001fc123e8:  24 c4 00 01 addiu	a0,a2,1
[ 374] 0x900000001fc123ec:  25 03 00 01 addiu	v1,a4,1
[ 374] 0x900000001fc123f0:  00 82 30 0b movn	a2,a0,v0
[ 374] 0x900000001fc123f4:  00 00 00 21 nada
[ 374] 0x900000001fc123f8:  00 00 00 21 nada
[ 374] 0x900000001fc123fc:  00 00 00 21 nada
[ 374] 0x900000001fc12400:  dd 42 00 08 ld	v0,8(a6)
[ 374] 0x900000001fc12404:  24 c4 00 01 addiu	a0,a2,1
[ 374] 0x900000001fc12408:  03 a6 28 2d daddu	a1,sp,a2
[ 374] 0x900000001fc1240c:  64 a5 01 70 daddiu	a1,a1,368
[ 374] 0x900000001fc12410:  67 a9 00 40 daddiu	a5,sp,64
[ 374] 0x900000001fc12414:  90 42 00 0b lbu	v0,11(v0)
[ 374] 0x900000001fc12418:  00 a2 48 0b movn	a5,a1,v0
[ 374] 0x900000001fc1241c:  00 00 00 21 nada
[ 374] 0x900000001fc12420:  00 00 00 21 nada
[ 374] 0x900000001fc12424:  00 00 00 21 nada
[ 374] 0x900000001fc12428:  00 82 30 0b movn	a2,a0,v0
[ 374] 0x900000001fc1242c:  00 00 00 21 nada
[ 374] 0x900000001fc12430:  00 00 00 21 nada
[ 374] 0x900000001fc12434:  00 00 00 21 nada
[ 374] 0x900000001fc12438:  24 c4 00 01 addiu	a0,a2,1
[ 374] 0x900000001fc1243c:  03 a6 10 2d daddu	v0,sp,a2
[ 374] 0x900000001fc12440:  a1 23 00 00 sb	v1,0(a5)
[ 374] 0x900000001fc12444:  64 45 01 70 daddiu	a1,v0,368
[ 374] 0x900000001fc12448:  dd 43 00 10 ld	v1,16(a6)
[ 374] 0x900000001fc1244c:  25 02 00 02 addiu	v0,a4,2
[ 374] 0x900000001fc12450:  67 a9 00 40 daddiu	a5,sp,64
[ 374] 0x900000001fc12454:  90 63 00 0b lbu	v1,11(v1)
[ 374] 0x900000001fc12458:  00 a3 48 0b movn	a5,a1,v1
[ 374] 0x900000001fc1245c:  00 00 00 21 nada
[ 374] 0x900000001fc12460:  00 00 00 21 nada
[ 374] 0x900000001fc12464:  00 00 00 21 nada
[ 374] 0x900000001fc12468:  00 83 30 0b movn	a2,a0,v1
[ 374] 0x900000001fc1246c:  00 00 00 21 nada
[ 374] 0x900000001fc12470:  00 00 00 21 nada
[ 374] 0x900000001fc12474:  00 00 00 21 nada
[ 374] 0x900000001fc12478:  24 c4 00 01 addiu	a0,a2,1
[ 374] 0x900000001fc1247c:  03 a6 18 2d daddu	v1,sp,a2
[ 374] 0x900000001fc12480:  a1 22 00 00 sb	v0,0(a5)
[ 374] 0x900000001fc12484:  64 65 01 70 daddiu	a1,v1,368
[ 374] 0x900000001fc12488:  dd 42 00 18 ld	v0,24(a6)
[ 374] 0x900000001fc1248c:  67 a9 00 40 daddiu	a5,sp,64
[ 374] 0x900000001fc12490:  90 43 00 0b lbu	v1,11(v0)
[ 374] 0x900000001fc12494:  00 a3 48 0b movn	a5,a1,v1
[ 374] 0x900000001fc12498:  00 00 00 21 nada
[ 374] 0x900000001fc1249c:  00 00 00 21 nada
[ 374] 0x900000001fc124a0:  00 00 00 21 nada
[ 374] 0x900000001fc124a4:  25 02 00 03 addiu	v0,a4,3
[ 374] 0x900000001fc124a8:  65 4a 00 20 daddiu	a6,a6,32
[ 374] 0x900000001fc124ac:  a1 22 00 00 sb	v0,0(a5)
[ 374] 0x900000001fc124b0:  00 83 30 0b movn	a2,a0,v1
[ 374] 0x900000001fc124b4:  00 00 00 21 nada
[ 374] 0x900000001fc124b8:  00 00 00 21 nada
[ 374] 0x900000001fc124bc:  00 00 00 21 nada
[ 374] 0x900000001fc124c0:  15 41 ff 7b bne	a6,at,0x900000001fc122b0
[ 374] 0x900000001fc124c4:  00 00 00 21 nada
[ 374] 0x900000001fc124c8:  ff a6 00 60 sd	a2,96(sp)
[ 374] 0x900000001fc124cc:  df a8 00 60 ld	a4,96(sp)
[ 374] 0x900000001fc124d0:  10 00 00 03 b		0x900000001fc124e0
[ 374] 0x900000001fc124d4:  00 00 00 21 nada
[ 374] 0x900000001fc124d8:  ff a6 00 60 sd	a2,96(sp)
[ 374] 0x900000001fc124dc:  df a8 00 60 ld	a4,96(sp)
[ 374] 0x900000001fc124e0:  ff b3 01 40 sd	s3,320(sp)
  377: 
  378:     /* Sort the indices so that the interleaves are ordered by
  379:      * decreasing interleave size (biggest interleave is first).
  380:      */
  381:     for (i = 0; i < num_index-1; i++) {
[ 381] 0x900000001fc124e4:  25 01 ff ff addiu	at,a4,-1
[ 381] 0x900000001fc124e8:  ff be 01 18 sd	s8,280(sp)
[ 381] 0x900000001fc124ec:  18 20 03 1d blez	at,0x900000001fc13164
[ 381] 0x900000001fc124f0:  00 00 90 25 move	s2,zero
[ 381] 0x900000001fc124f4:  00 01 80 3c dsll32	s0,at,0
[ 381] 0x900000001fc124f8:  32 53 00 ff andi	s3,s2,0xff
[ 381] 0x900000001fc124fc:  03 a0 f8 25 move	ra,sp
[ 381] 0x900000001fc12500:  3c 11 90 00 lui	s1,0x9000
[ 381] 0x900000001fc12504:  25 1e ff ff addiu	s8,a4,-1
[ 381] 0x900000001fc12508:  62 32 00 00 daddi	s2,s1,0
[ 381] 0x900000001fc1250c:  ff b7 01 20 sd	s7,288(sp)
[ 381] 0x900000001fc12510:  3c 11 1f c2 lui	s1,0x1fc2
[ 381] 0x900000001fc12514:  00 10 80 3e dsrl32	s0,s0,0
[ 381] 0x900000001fc12518:  ff b5 01 30 sd	s5,304(sp)
[ 381] 0x900000001fc1251c:  62 35 e8 68 daddi	s5,s1,-6040
[ 381] 0x900000001fc12520:  00 12 90 3c dsll32	s2,s2,0
[ 381] 0x900000001fc12524:  ff b4 01 38 sd	s4,312(sp)
[ 381] 0x900000001fc12528:  03 b0 a0 2d daddu	s4,sp,s0
[ 381] 0x900000001fc1252c:  02 55 90 2c dadd	s2,s2,s5
[ 381] 0x900000001fc12530:  ff b6 01 28 sd	s6,296(sp)
[ 381] 0x900000001fc12534:  24 17 00 01 li	s7,1
[ 381] 0x900000001fc12538:  32 70 00 ff andi	s0,s3,0xff
[ 381] 0x900000001fc1253c:  ff b4 00 70 sd	s4,112(sp)
[ 381] 0x900000001fc12540:  02 e8 88 2a slt	s1,s7,a4
[ 381] 0x900000001fc12544:  03 b0 80 2d daddu	s0,sp,s0
[ 381] 0x900000001fc12548:  ff b2 00 68 sd	s2,104(sp)
[ 381] 0x900000001fc1254c:  de 54 00 10 ld	s4,16(s2)
[ 381] 0x900000001fc12550:  df a2 00 50 ld	v0,80(sp)
  382: 	unchar temp, max;
  383: 	unsigned long size_max, size_j;
  384:  
  385: 	max = i;
  386:         size_max = MemSizes[banks[index[max]]->bnk_size] * 
[ 386] 0x900000001fc12554:  92 16 01 70 lbu	s6,368(s0)
[ 386] 0x900000001fc12558:  32 d6 00 ff andi	s6,s6,0xff
[ 386] 0x900000001fc1255c:  00 16 c0 f8 dsll	t8,s6,3
[ 386] 0x900000001fc12560:  df b6 00 50 ld	s6,80(sp)
[ 386] 0x900000001fc12564:  02 d8 b0 2d daddu	s6,s6,t8
[ 386] 0x900000001fc12568:  de d8 00 00 ld	t8,0(s6)
[ 386] 0x900000001fc1256c:  93 16 00 0a lbu	s6,10(t8)
[ 386] 0x900000001fc12570:  32 d6 00 ff andi	s6,s6,0xff
[ 386] 0x900000001fc12574:  00 16 b0 f8 dsll	s6,s6,3
[ 386] 0x900000001fc12578:  02 d4 b0 2d daddu	s6,s6,s4
[ 386] 0x900000001fc1257c:  93 18 00 0b lbu	t8,11(t8)
[ 386] 0x900000001fc12580:  33 18 00 ff andi	t8,t8,0xff
[ 386] 0x900000001fc12584:  de d6 00 00 ld	s6,0(s6)
[ 386] 0x900000001fc12588:  02 d8 00 1d dmultu	s6,t8
  387: 			banks[index[max]]->bnk_count;	
  388: 	for (j = i+1; j < num_index; j++) {
[ 388] 0x900000001fc1258c:  02 e0 90 25 move	s2,s7
[ 388] 0x900000001fc12590:  93 eb 01 70 lbu	a7,368(ra)
[ 388] 0x900000001fc12594:  33 c1 00 01 andi	at,s8,0x1
[ 385] 0x900000001fc12598:  12 20 02 dd beq	s1,zero,0x900000001fc13110
[ 385] 0x900000001fc1259c:  00 00 b0 12 mflo	s6
[ 385] 0x900000001fc125a0:  50 20 00 1b beql	at,zero,0x900000001fc12610
[ 385] 0x900000001fc125a4:  df a2 00 50 ld	v0,80(sp)
[ 385] 0x900000001fc125a8:  00 01 c8 3c dsll32	t9,at,0
[ 385] 0x900000001fc125ac:  00 19 c8 3e dsrl32	t9,t9,0
[ 385] 0x900000001fc125b0:  03 b7 a8 2d daddu	s5,sp,s7
[ 385] 0x900000001fc125b4:  02 b9 80 2d daddu	s0,s5,t9
  389: 	   size_j   = MemSizes[banks[index[j]]->bnk_size] * 
[ 389] 0x900000001fc125b8:  92 a1 01 70 lbu	at,368(s5)
[ 389] 0x900000001fc125bc:  30 21 00 ff andi	at,at,0xff
[ 389] 0x900000001fc125c0:  00 01 08 f8 dsll	at,at,3
[ 389] 0x900000001fc125c4:  00 41 08 2d daddu	at,v0,at
[ 389] 0x900000001fc125c8:  dc 23 00 00 ld	v1,0(at)
[ 389] 0x900000001fc125cc:  90 61 00 0a lbu	at,10(v1)
[ 389] 0x900000001fc125d0:  30 21 00 ff andi	at,at,0xff
[ 389] 0x900000001fc125d4:  00 01 08 f8 dsll	at,at,3
[ 389] 0x900000001fc125d8:  00 34 08 2d daddu	at,at,s4
[ 389] 0x900000001fc125dc:  90 63 00 0b lbu	v1,11(v1)
[ 389] 0x900000001fc125e0:  30 63 00 ff andi	v1,v1,0xff
[ 389] 0x900000001fc125e4:  dc 21 00 00 ld	at,0(at)
[ 389] 0x900000001fc125e8:  00 23 00 1d dmultu	at,v1
[ 389] 0x900000001fc125ec:  00 00 08 12 mflo	at
  390: 			banks[index[j]]->bnk_count;
  391: 	   if (size_j > size_max) {
[ 391] 0x900000001fc125f0:  02 c1 18 2b sltu	v1,s6,at
[ 391] 0x900000001fc125f4:  10 60 00 03 beq	v1,zero,0x900000001fc12604
[ 391] 0x900000001fc125f8:  66 b5 00 01 daddiu	s5,s5,1
  392: 		max = j;
[ 392] 0x900000001fc125fc:  32 53 00 ff andi	s3,s2,0xff
  393: 		size_max = size_j;
[ 393] 0x900000001fc12600:  00 20 b0 25 move	s6,at
[ 388] 0x900000001fc12604:  16 b0 ff ec bne	s5,s0,0x900000001fc125b8
[ 388] 0x900000001fc12608:  26 52 00 01 addiu	s2,s2,1
[ 388] 0x900000001fc1260c:  df a2 00 50 ld	v0,80(sp)
[ 388] 0x900000001fc12610:  03 b2 a8 2d daddu	s5,sp,s2
[ 388] 0x900000001fc12614:  26 41 00 01 addiu	at,s2,1
[ 388] 0x900000001fc12618:  00 28 08 2a slt	at,at,a4
[ 388] 0x900000001fc1261c:  50 20 02 bd beql	at,zero,0x900000001fc13114
[ 388] 0x900000001fc12620:  32 61 00 ff andi	at,s3,0xff
[ 388] 0x900000001fc12624:  00 1e 08 42 srl	at,s8,1
[ 388] 0x900000001fc12628:  00 01 08 3c dsll32	at,at,0
[ 388] 0x900000001fc1262c:  00 01 08 3e dsrl32	at,at,0
[ 388] 0x900000001fc12630:  00 21 08 2d daddu	at,at,at
[ 388] 0x900000001fc12634:  66 a3 00 02 daddiu	v1,s5,2
[ 388] 0x900000001fc12638:  02 a1 30 2d daddu	a2,s5,at
[ 388] 0x900000001fc1263c:  10 66 02 85 beq	v1,a2,0x900000001fc13054
[ 388] 0x900000001fc12640:  64 61 00 02 daddiu	at,v1,2
[ 388] 0x900000001fc12644:  10 26 02 83 beq	at,a2,0x900000001fc13054
[ 388] 0x900000001fc12648:  64 30 00 02 daddiu	s0,at,2
[ 388] 0x900000001fc1264c:  12 06 02 81 beq	s0,a2,0x900000001fc13054
[ 388] 0x900000001fc12650:  66 01 00 02 daddiu	at,s0,2
[ 388] 0x900000001fc12654:  10 26 02 7f beq	at,a2,0x900000001fc13054
[ 388] 0x900000001fc12658:  64 30 00 02 daddiu	s0,at,2
[ 388] 0x900000001fc1265c:  12 06 02 7d beq	s0,a2,0x900000001fc13054
[ 388] 0x900000001fc12660:  00 00 00 21 nada
[ 388] 0x900000001fc12664:  ff be 01 08 sd	s8,264(sp)
[ 388] 0x900000001fc12668:  92 be 01 70 lbu	s8,368(s5)
[ 388] 0x900000001fc1266c:  ff bf 01 10 sd	ra,272(sp)
[ 388] 0x900000001fc12670:  33 df 00 ff andi	ra,s8,0xff
[ 388] 0x900000001fc12674:  00 1f f8 f8 dsll	ra,ra,3
[ 388] 0x900000001fc12678:  00 5f 08 2d daddu	at,v0,ra
[ 388] 0x900000001fc1267c:  dc 2f 00 00 ld	t3,0(at)
[ 388] 0x900000001fc12680:  92 be 01 71 lbu	s8,369(s5)
[ 388] 0x900000001fc12684:  33 de 00 ff andi	s8,s8,0xff
[ 388] 0x900000001fc12688:  24 03 00 0a li	v1,10
[ 388] 0x900000001fc1268c:  91 ed 00 0a lbu	t1,10(t3)
[ 388] 0x900000001fc12690:  df a1 00 68 ld	at,104(sp)
[ 388] 0x900000001fc12694:  00 1e f0 f8 dsll	s8,s8,3
[ 388] 0x900000001fc12698:  31 ad 00 ff andi	t1,t1,0xff
[ 388] 0x900000001fc1269c:  00 c3 18 2f dsubu	v1,a2,v1
[ 388] 0x900000001fc126a0:  00 0d 68 f8 dsll	t1,t1,3
[ 388] 0x900000001fc126a4:  dc 21 00 10 ld	at,16(at)
[ 388] 0x900000001fc126a8:  00 5e 30 2d daddu	a2,v0,s8
[ 388] 0x900000001fc126ac:  01 a1 80 2d daddu	s0,t1,at
[ 388] 0x900000001fc126b0:  66 a7 00 02 daddiu	a3,s5,2
[ 388] 0x900000001fc126b4:  ff b3 00 78 sd	s3,120(sp)
[ 388] 0x900000001fc126b8:  91 ef 00 0b lbu	t3,11(t3)
[ 388] 0x900000001fc126bc:  31 f3 00 ff andi	s3,t3,0xff
[ 388] 0x900000001fc126c0:  dc d1 00 00 ld	s1,0(a2)
[ 388] 0x900000001fc126c4:  de 10 00 00 ld	s0,0(s0)
[ 388] 0x900000001fc126c8:  90 fe 01 70 lbu	s8,368(a3)
[ 388] 0x900000001fc126cc:  02 13 00 1d dmultu	s0,s3
[ 388] 0x900000001fc126d0:  33 df 00 ff andi	ra,s8,0xff
[ 388] 0x900000001fc126d4:  92 26 00 0a lbu	a2,10(s1)
[ 388] 0x900000001fc126d8:  00 1f f8 f8 dsll	ra,ra,3
[ 388] 0x900000001fc126dc:  30 c6 00 ff andi	a2,a2,0xff
[ 388] 0x900000001fc126e0:  00 06 30 f8 dsll	a2,a2,3
[ 388] 0x900000001fc126e4:  00 5f f8 2d daddu	ra,v0,ra
[ 388] 0x900000001fc126e8:  00 c1 78 2d daddu	t3,a2,at
[ 388] 0x900000001fc126ec:  92 31 00 0b lbu	s1,11(s1)
[ 388] 0x900000001fc126f0:  32 31 00 ff andi	s1,s1,0xff
[ 388] 0x900000001fc126f4:  df e6 00 00 ld	a2,0(ra)
[ 388] 0x900000001fc126f8:  00 00 80 12 mflo	s0
[ 388] 0x900000001fc126fc:  dd ef 00 00 ld	t3,0(t3)
[ 388] 0x900000001fc12700:  90 fe 01 71 lbu	s8,369(a3)
[ 388] 0x900000001fc12704:  01 f1 00 1d dmultu	t3,s1
[ 388] 0x900000001fc12708:  33 de 00 ff andi	s8,s8,0xff
[ 388] 0x900000001fc1270c:  90 df 00 0a lbu	ra,10(a2)
[ 388] 0x900000001fc12710:  00 1e f0 f8 dsll	s8,s8,3
[ 388] 0x900000001fc12714:  33 ff 00 ff andi	ra,ra,0xff
[ 388] 0x900000001fc12718:  00 1f f8 f8 dsll	ra,ra,3
[ 388] 0x900000001fc1271c:  00 5e f0 2d daddu	s8,v0,s8
[ 388] 0x900000001fc12720:  03 e1 f8 2d daddu	ra,ra,at
[ 388] 0x900000001fc12724:  64 e9 00 02 daddiu	a5,a3,2
[ 388] 0x900000001fc12728:  90 c6 00 0b lbu	a2,11(a2)
[ 388] 0x900000001fc1272c:  30 cd 00 ff andi	t1,a2,0xff
[ 388] 0x900000001fc12730:  df c6 00 00 ld	a2,0(s8)
[ 388] 0x900000001fc12734:  00 00 88 12 mflo	s1
[ 388] 0x900000001fc12738:  df ff 00 00 ld	ra,0(ra)
[ 388] 0x900000001fc1273c:  91 24 01 70 lbu	a0,368(a5)
[ 388] 0x900000001fc12740:  03 ed 00 1d dmultu	ra,t1
[ 388] 0x900000001fc12744:  ff ab 00 f8 sd	a7,248(sp)
[ 388] 0x900000001fc12748:  02 c0 58 25 move	a7,s6
[ 388] 0x900000001fc1274c:  30 85 00 ff andi	a1,a0,0xff
[ 388] 0x900000001fc12750:  90 de 00 0a lbu	s8,10(a2)
[ 388] 0x900000001fc12754:  00 05 28 f8 dsll	a1,a1,3
[ 388] 0x900000001fc12758:  33 de 00 ff andi	s8,s8,0xff
[ 388] 0x900000001fc1275c:  02 40 70 25 move	t2,s2
[ 388] 0x900000001fc12760:  00 1e f0 f8 dsll	s8,s8,3
[ 388] 0x900000001fc12764:  ff a8 00 60 sd	a4,96(sp)
[ 388] 0x900000001fc12768:  91 24 01 71 lbu	a0,369(a5)
[ 388] 0x900000001fc1276c:  65 28 00 02 daddiu	a4,a5,2
[ 388] 0x900000001fc12770:  03 c1 f0 2d daddu	s8,s8,at
[ 388] 0x900000001fc12774:  ff b7 01 00 sd	s7,256(sp)
[ 388] 0x900000001fc12778:  30 84 00 ff andi	a0,a0,0xff
[ 388] 0x900000001fc1277c:  00 45 28 2d daddu	a1,v0,a1
[ 388] 0x900000001fc12780:  90 c6 00 0b lbu	a2,11(a2)
[ 388] 0x900000001fc12784:  91 0c 01 70 lbu	t0,368(a4)
[ 388] 0x900000001fc12788:  30 c6 00 ff andi	a2,a2,0xff
[ 388] 0x900000001fc1278c:  00 00 b8 12 mflo	s7
[ 388] 0x900000001fc12790:  df de 00 00 ld	s8,0(s8)
[ 388] 0x900000001fc12794:  31 94 00 ff andi	s4,t0,0xff
[ 388] 0x900000001fc12798:  dc b2 00 00 ld	s2,0(a1)
[ 388] 0x900000001fc1279c:  03 c6 00 1d dmultu	s8,a2
[ 388] 0x900000001fc127a0:  00 04 20 f8 dsll	a0,a0,3
[ 388] 0x900000001fc127a4:  65 0c 00 02 daddiu	t0,a4,2
[ 388] 0x900000001fc127a8:  00 14 a0 f8 dsll	s4,s4,3
[ 388] 0x900000001fc127ac:  00 44 20 2d daddu	a0,v0,a0
[ 388] 0x900000001fc127b0:  92 45 00 0b lbu	a1,11(s2)
[ 388] 0x900000001fc127b4:  92 52 00 0a lbu	s2,10(s2)
[ 388] 0x900000001fc127b8:  00 54 a0 2d daddu	s4,v0,s4
[ 388] 0x900000001fc127bc:  32 52 00 ff andi	s2,s2,0xff
[ 388] 0x900000001fc127c0:  00 12 90 f8 dsll	s2,s2,3
[ 388] 0x900000001fc127c4:  02 d0 78 2b sltu	t3,s6,s0
[ 388] 0x900000001fc127c8:  02 41 98 2d daddu	s3,s2,at
[ 388] 0x900000001fc127cc:  02 0f 58 0b movn	a7,s0,t3
[ 388] 0x900000001fc127d0:  00 00 00 21 nada
[ 388] 0x900000001fc127d4:  00 00 00 21 nada
[ 388] 0x900000001fc127d8:  00 00 00 21 nada
[ 388] 0x900000001fc127dc:  df aa 00 78 ld	a6,120(sp)
[ 388] 0x900000001fc127e0:  91 98 01 70 lbu	t8,368(t0)
[ 388] 0x900000001fc127e4:  01 71 f8 2b sltu	ra,a7,s1
[ 388] 0x900000001fc127e8:  00 00 f0 12 mflo	s8
[ 388] 0x900000001fc127ec:  30 a6 00 ff andi	a2,a1,0xff
[ 388] 0x900000001fc127f0:  02 3f 58 0b movn	a7,s1,ra
[ 388] 0x900000001fc127f4:  00 00 00 21 nada
[ 388] 0x900000001fc127f8:  00 00 00 21 nada
[ 388] 0x900000001fc127fc:  00 00 00 21 nada
[ 388] 0x900000001fc12800:  de 6d 00 00 ld	t1,0(s3)
[ 388] 0x900000001fc12804:  dc 84 00 00 ld	a0,0(a0)
[ 388] 0x900000001fc12808:  33 05 00 ff andi	a1,t8,0xff
[ 388] 0x900000001fc1280c:  01 a6 00 1d dmultu	t1,a2
[ 388] 0x900000001fc12810:  de 8d 00 00 ld	t1,0(s4)
[ 388] 0x900000001fc12814:  00 05 28 f8 dsll	a1,a1,3
[ 388] 0x900000001fc12818:  65 86 00 02 daddiu	a2,t0,2
[ 388] 0x900000001fc1281c:  90 98 00 0a lbu	t8,10(a0)
[ 388] 0x900000001fc12820:  00 45 a0 2d daddu	s4,v0,a1
[ 388] 0x900000001fc12824:  33 18 00 ff andi	t8,t8,0xff
[ 388] 0x900000001fc12828:  91 a5 00 0a lbu	a1,10(t1)
[ 388] 0x900000001fc1282c:  30 a5 00 ff andi	a1,a1,0xff
[ 388] 0x900000001fc12830:  00 18 c0 f8 dsll	t8,t8,3
[ 388] 0x900000001fc12834:  00 05 28 f8 dsll	a1,a1,3
[ 388] 0x900000001fc12838:  03 01 c8 2d daddu	t9,t8,at
[ 388] 0x900000001fc1283c:  91 18 01 71 lbu	t8,369(a4)
[ 388] 0x900000001fc12840:  00 a1 98 2d daddu	s3,a1,at
[ 388] 0x900000001fc12844:  33 05 00 ff andi	a1,t8,0xff
[ 388] 0x900000001fc12848:  90 84 00 0b lbu	a0,11(a0)
[ 388] 0x900000001fc1284c:  00 00 90 12 mflo	s2
[ 388] 0x900000001fc12850:  30 90 00 ff andi	s0,a0,0xff
[ 388] 0x900000001fc12854:  df 38 00 00 ld	t8,0(t9)
[ 388] 0x900000001fc12858:  00 05 20 f8 dsll	a0,a1,3
[ 388] 0x900000001fc1285c:  03 10 00 1d dmultu	t8,s0
[ 388] 0x900000001fc12860:  00 44 b0 2d daddu	s6,v0,a0
[ 388] 0x900000001fc12864:  25 d8 00 02 addiu	t8,t2,2
[ 388] 0x900000001fc12868:  25 c4 00 01 addiu	a0,t2,1
[ 388] 0x900000001fc1286c:  31 c5 00 ff andi	a1,t2,0xff
[ 388] 0x900000001fc12870:  01 77 c8 2b sltu	t9,a7,s7
[ 388] 0x900000001fc12874:  30 84 00 ff andi	a0,a0,0xff
[ 388] 0x900000001fc12878:  02 f9 58 0b movn	a7,s7,t9
[ 388] 0x900000001fc1287c:  00 00 00 21 nada
[ 388] 0x900000001fc12880:  00 00 00 21 nada
[ 388] 0x900000001fc12884:  00 00 00 21 nada
[ 388] 0x900000001fc12888:  00 af 50 0b movn	a6,a1,t3
[ 388] 0x900000001fc1288c:  00 00 00 21 nada
[ 388] 0x900000001fc12890:  00 00 00 21 nada
[ 388] 0x900000001fc12894:  00 00 00 21 nada
[ 388] 0x900000001fc12898:  00 9f 50 0b movn	a6,a0,ra
[ 388] 0x900000001fc1289c:  00 00 00 21 nada
[ 388] 0x900000001fc128a0:  00 00 00 21 nada
[ 388] 0x900000001fc128a4:  00 00 00 21 nada
[ 388] 0x900000001fc128a8:  01 7e f8 2b sltu	ra,a7,s8
[ 388] 0x900000001fc128ac:  00 00 a8 12 mflo	s5
[ 388] 0x900000001fc128b0:  90 c4 01 70 lbu	a0,368(a2)
[ 388] 0x900000001fc128b4:  10 e3 01 d5 beq	a3,v1,0x900000001fc1300c
[ 388] 0x900000001fc128b8:  91 a5 00 0b lbu	a1,11(t1)
[ 388] 0x900000001fc128bc:  30 a7 00 ff andi	a3,a1,0xff
[ 388] 0x900000001fc128c0:  03 df 58 0b movn	a7,s8,ra
[ 388] 0x900000001fc128c4:  00 00 00 21 nada
[ 388] 0x900000001fc128c8:  00 00 00 21 nada
[ 388] 0x900000001fc128cc:  00 00 00 21 nada
[ 388] 0x900000001fc128d0:  de 6d 00 00 ld	t1,0(s3)
[ 388] 0x900000001fc128d4:  de ce 00 00 ld	t2,0(s6)
[ 388] 0x900000001fc128d8:  30 85 00 ff andi	a1,a0,0xff
[ 388] 0x900000001fc128dc:  01 a7 00 1d dmultu	t1,a3
[ 388] 0x900000001fc128e0:  de 8d 00 00 ld	t1,0(s4)
[ 388] 0x900000001fc128e4:  00 05 28 f8 dsll	a1,a1,3
[ 388] 0x900000001fc128e8:  64 c7 00 02 daddiu	a3,a2,2
[ 388] 0x900000001fc128ec:  91 c4 00 0a lbu	a0,10(t2)
[ 388] 0x900000001fc128f0:  00 45 a0 2d daddu	s4,v0,a1
[ 388] 0x900000001fc128f4:  30 84 00 ff andi	a0,a0,0xff
[ 388] 0x900000001fc128f8:  91 a5 00 0a lbu	a1,10(t1)
[ 388] 0x900000001fc128fc:  30 a5 00 ff andi	a1,a1,0xff
[ 388] 0x900000001fc12900:  00 04 20 f8 dsll	a0,a0,3
[ 388] 0x900000001fc12904:  00 05 28 f8 dsll	a1,a1,3
[ 388] 0x900000001fc12908:  00 81 78 2d daddu	t3,a0,at
[ 388] 0x900000001fc1290c:  91 84 01 71 lbu	a0,369(t0)
[ 388] 0x900000001fc12910:  00 a1 98 2d daddu	s3,a1,at
[ 388] 0x900000001fc12914:  30 84 00 ff andi	a0,a0,0xff
[ 388] 0x900000001fc12918:  91 c5 00 0b lbu	a1,11(t2)
[ 388] 0x900000001fc1291c:  00 00 80 12 mflo	s0
[ 388] 0x900000001fc12920:  30 ae 00 ff andi	t2,a1,0xff
[ 388] 0x900000001fc12924:  dd e5 00 00 ld	a1,0(t3)
[ 388] 0x900000001fc12928:  00 04 20 f8 dsll	a0,a0,3
[ 388] 0x900000001fc1292c:  00 ae 00 1d dmultu	a1,t2
[ 388] 0x900000001fc12930:  00 44 b0 2d daddu	s6,v0,a0
[ 388] 0x900000001fc12934:  27 0e 00 02 addiu	t2,t8,2
[ 388] 0x900000001fc12938:  27 04 00 01 addiu	a0,t8,1
[ 388] 0x900000001fc1293c:  33 05 00 ff andi	a1,t8,0xff
[ 388] 0x900000001fc12940:  01 72 78 2b sltu	t3,a7,s2
[ 388] 0x900000001fc12944:  30 84 00 ff andi	a0,a0,0xff
[ 388] 0x900000001fc12948:  02 4f 58 0b movn	a7,s2,t3
[ 388] 0x900000001fc1294c:  00 00 00 21 nada
[ 388] 0x900000001fc12950:  00 00 00 21 nada
[ 388] 0x900000001fc12954:  00 00 00 21 nada
[ 388] 0x900000001fc12958:  00 b9 50 0b movn	a6,a1,t9
[ 388] 0x900000001fc1295c:  00 00 00 21 nada
[ 388] 0x900000001fc12960:  00 00 00 21 nada
[ 388] 0x900000001fc12964:  00 00 00 21 nada
[ 388] 0x900000001fc12968:  00 9f 50 0b movn	a6,a0,ra
[ 388] 0x900000001fc1296c:  00 00 00 21 nada
[ 388] 0x900000001fc12970:  00 00 00 21 nada
[ 388] 0x900000001fc12974:  00 00 00 21 nada
[ 388] 0x900000001fc12978:  01 75 f8 2b sltu	ra,a7,s5
[ 388] 0x900000001fc1297c:  00 00 88 12 mflo	s1
[ 388] 0x900000001fc12980:  90 e4 01 70 lbu	a0,368(a3)
[ 388] 0x900000001fc12984:  11 23 01 8f beq	a5,v1,0x900000001fc12fc4
[ 388] 0x900000001fc12988:  91 a5 00 0b lbu	a1,11(t1)
[ 388] 0x900000001fc1298c:  30 a9 00 ff andi	a5,a1,0xff
[ 388] 0x900000001fc12990:  02 bf 58 0b movn	a7,s5,ra
[ 388] 0x900000001fc12994:  00 00 00 21 nada
[ 388] 0x900000001fc12998:  00 00 00 21 nada
[ 388] 0x900000001fc1299c:  00 00 00 21 nada
[ 388] 0x900000001fc129a0:  de 6d 00 00 ld	t1,0(s3)
[ 388] 0x900000001fc129a4:  de d8 00 00 ld	t8,0(s6)
[ 388] 0x900000001fc129a8:  30 85 00 ff andi	a1,a0,0xff
[ 388] 0x900000001fc129ac:  01 a9 00 1d dmultu	t1,a5
[ 388] 0x900000001fc129b0:  de 8d 00 00 ld	t1,0(s4)
[ 388] 0x900000001fc129b4:  00 05 28 f8 dsll	a1,a1,3
[ 388] 0x900000001fc129b8:  64 e9 00 02 daddiu	a5,a3,2
[ 388] 0x900000001fc129bc:  93 04 00 0a lbu	a0,10(t8)
[ 388] 0x900000001fc129c0:  00 45 a0 2d daddu	s4,v0,a1
[ 388] 0x900000001fc129c4:  30 84 00 ff andi	a0,a0,0xff
[ 388] 0x900000001fc129c8:  91 a5 00 0a lbu	a1,10(t1)
[ 388] 0x900000001fc129cc:  30 a5 00 ff andi	a1,a1,0xff
[ 388] 0x900000001fc129d0:  00 04 20 f8 dsll	a0,a0,3
[ 388] 0x900000001fc129d4:  00 05 28 f8 dsll	a1,a1,3
[ 388] 0x900000001fc129d8:  00 81 98 2d daddu	s3,a0,at
[ 388] 0x900000001fc129dc:  90 c4 01 71 lbu	a0,369(a2)
[ 388] 0x900000001fc129e0:  00 a1 c8 2d daddu	t9,a1,at
[ 388] 0x900000001fc129e4:  30 84 00 ff andi	a0,a0,0xff
[ 388] 0x900000001fc129e8:  93 05 00 0b lbu	a1,11(t8)
[ 388] 0x900000001fc129ec:  00 00 90 12 mflo	s2
[ 388] 0x900000001fc129f0:  30 b8 00 ff andi	t8,a1,0xff
[ 388] 0x900000001fc129f4:  de 65 00 00 ld	a1,0(s3)
[ 388] 0x900000001fc129f8:  00 04 20 f8 dsll	a0,a0,3
[ 388] 0x900000001fc129fc:  00 b8 00 1d dmultu	a1,t8
[ 388] 0x900000001fc12a00:  00 44 b0 2d daddu	s6,v0,a0
[ 388] 0x900000001fc12a04:  25 d8 00 02 addiu	t8,t2,2
[ 388] 0x900000001fc12a08:  25 c4 00 01 addiu	a0,t2,1
[ 388] 0x900000001fc12a0c:  31 c5 00 ff andi	a1,t2,0xff
[ 388] 0x900000001fc12a10:  01 70 98 2b sltu	s3,a7,s0
[ 388] 0x900000001fc12a14:  30 84 00 ff andi	a0,a0,0xff
[ 388] 0x900000001fc12a18:  02 13 58 0b movn	a7,s0,s3
[ 388] 0x900000001fc12a1c:  00 00 00 21 nada
[ 388] 0x900000001fc12a20:  00 00 00 21 nada
[ 388] 0x900000001fc12a24:  00 00 00 21 nada
[ 388] 0x900000001fc12a28:  00 af 50 0b movn	a6,a1,t3
[ 388] 0x900000001fc12a2c:  00 00 00 21 nada
[ 388] 0x900000001fc12a30:  00 00 00 21 nada
[ 388] 0x900000001fc12a34:  00 00 00 21 nada
[ 388] 0x900000001fc12a38:  00 9f 50 0b movn	a6,a0,ra
[ 388] 0x900000001fc12a3c:  00 00 00 21 nada
[ 388] 0x900000001fc12a40:  00 00 00 21 nada
[ 388] 0x900000001fc12a44:  00 00 00 21 nada
[ 388] 0x900000001fc12a48:  01 71 f8 2b sltu	ra,a7,s1
[ 388] 0x900000001fc12a4c:  00 00 a8 12 mflo	s5
[ 388] 0x900000001fc12a50:  91 24 01 70 lbu	a0,368(a5)
[ 388] 0x900000001fc12a54:  11 03 01 49 beq	a4,v1,0x900000001fc12f7c
[ 388] 0x900000001fc12a58:  91 a5 00 0b lbu	a1,11(t1)
[ 388] 0x900000001fc12a5c:  30 a8 00 ff andi	a4,a1,0xff
[ 388] 0x900000001fc12a60:  02 3f 58 0b movn	a7,s1,ra
[ 388] 0x900000001fc12a64:  00 00 00 21 nada
[ 388] 0x900000001fc12a68:  00 00 00 21 nada
[ 388] 0x900000001fc12a6c:  00 00 00 21 nada
[ 388] 0x900000001fc12a70:  df 2d 00 00 ld	t1,0(t9)
[ 388] 0x900000001fc12a74:  de ce 00 00 ld	t2,0(s6)
[ 388] 0x900000001fc12a78:  30 85 00 ff andi	a1,a0,0xff
[ 388] 0x900000001fc12a7c:  01 a8 00 1d dmultu	t1,a4
[ 388] 0x900000001fc12a80:  de 8d 00 00 ld	t1,0(s4)
[ 388] 0x900000001fc12a84:  00 05 28 f8 dsll	a1,a1,3
[ 388] 0x900000001fc12a88:  65 28 00 02 daddiu	a4,a5,2
[ 388] 0x900000001fc12a8c:  91 c4 00 0a lbu	a0,10(t2)
[ 388] 0x900000001fc12a90:  00 45 a0 2d daddu	s4,v0,a1
[ 388] 0x900000001fc12a94:  30 84 00 ff andi	a0,a0,0xff
[ 388] 0x900000001fc12a98:  91 a5 00 0a lbu	a1,10(t1)
[ 388] 0x900000001fc12a9c:  30 a5 00 ff andi	a1,a1,0xff
[ 388] 0x900000001fc12aa0:  00 04 20 f8 dsll	a0,a0,3
[ 388] 0x900000001fc12aa4:  00 05 28 f8 dsll	a1,a1,3
[ 388] 0x900000001fc12aa8:  00 81 c8 2d daddu	t9,a0,at
[ 388] 0x900000001fc12aac:  90 e4 01 71 lbu	a0,369(a3)
[ 388] 0x900000001fc12ab0:  00 a1 78 2d daddu	t3,a1,at
[ 388] 0x900000001fc12ab4:  30 84 00 ff andi	a0,a0,0xff
[ 388] 0x900000001fc12ab8:  91 c5 00 0b lbu	a1,11(t2)
[ 388] 0x900000001fc12abc:  00 00 80 12 mflo	s0
[ 388] 0x900000001fc12ac0:  30 ae 00 ff andi	t2,a1,0xff
[ 388] 0x900000001fc12ac4:  df 25 00 00 ld	a1,0(t9)
[ 388] 0x900000001fc12ac8:  00 04 20 f8 dsll	a0,a0,3
[ 388] 0x900000001fc12acc:  00 ae 00 1d dmultu	a1,t2
[ 388] 0x900000001fc12ad0:  00 44 70 2d daddu	t2,v0,a0
[ 388] 0x900000001fc12ad4:  27 16 00 02 addiu	s6,t8,2
[ 388] 0x900000001fc12ad8:  27 04 00 01 addiu	a0,t8,1
[ 388] 0x900000001fc12adc:  33 05 00 ff andi	a1,t8,0xff
[ 388] 0x900000001fc12ae0:  01 72 c8 2b sltu	t9,a7,s2
[ 388] 0x900000001fc12ae4:  30 84 00 ff andi	a0,a0,0xff
[ 388] 0x900000001fc12ae8:  02 59 58 0b movn	a7,s2,t9
[ 388] 0x900000001fc12aec:  00 00 00 21 nada
[ 388] 0x900000001fc12af0:  00 00 00 21 nada
[ 388] 0x900000001fc12af4:  00 00 00 21 nada
[ 388] 0x900000001fc12af8:  00 b3 50 0b movn	a6,a1,s3
[ 388] 0x900000001fc12afc:  00 00 00 21 nada
[ 388] 0x900000001fc12b00:  00 00 00 21 nada
[ 388] 0x900000001fc12b04:  00 00 00 21 nada
[ 388] 0x900000001fc12b08:  00 9f 50 0b movn	a6,a0,ra
[ 388] 0x900000001fc12b0c:  00 00 00 21 nada
[ 388] 0x900000001fc12b10:  00 00 00 21 nada
[ 388] 0x900000001fc12b14:  00 00 00 21 nada
[ 388] 0x900000001fc12b18:  01 75 f8 2b sltu	ra,a7,s5
[ 388] 0x900000001fc12b1c:  00 00 88 12 mflo	s1
[ 388] 0x900000001fc12b20:  91 04 01 70 lbu	a0,368(a4)
[ 388] 0x900000001fc12b24:  11 83 01 02 beq	t0,v1,0x900000001fc12f30
[ 388] 0x900000001fc12b28:  91 a5 00 0b lbu	a1,11(t1)
[ 388] 0x900000001fc12b2c:  30 ac 00 ff andi	t0,a1,0xff
[ 388] 0x900000001fc12b30:  02 bf 58 0b movn	a7,s5,ra
[ 388] 0x900000001fc12b34:  00 00 00 21 nada
[ 388] 0x900000001fc12b38:  00 00 00 21 nada
[ 388] 0x900000001fc12b3c:  00 00 00 21 nada
[ 388] 0x900000001fc12b40:  dd ed 00 00 ld	t1,0(t3)
[ 388] 0x900000001fc12b44:  dd ce 00 00 ld	t2,0(t2)
[ 388] 0x900000001fc12b48:  30 85 00 ff andi	a1,a0,0xff
[ 388] 0x900000001fc12b4c:  01 ac 00 1d dmultu	t1,t0
[ 388] 0x900000001fc12b50:  de 8d 00 00 ld	t1,0(s4)
[ 388] 0x900000001fc12b54:  00 05 28 f8 dsll	a1,a1,3
[ 388] 0x900000001fc12b58:  65 0c 00 02 daddiu	t0,a4,2
[ 388] 0x900000001fc12b5c:  91 c4 00 0a lbu	a0,10(t2)
[ 388] 0x900000001fc12b60:  00 45 a0 2d daddu	s4,v0,a1
[ 388] 0x900000001fc12b64:  30 84 00 ff andi	a0,a0,0xff
[ 388] 0x900000001fc12b68:  91 a5 00 0a lbu	a1,10(t1)
[ 388] 0x900000001fc12b6c:  30 a5 00 ff andi	a1,a1,0xff
[ 388] 0x900000001fc12b70:  00 04 20 f8 dsll	a0,a0,3
[ 388] 0x900000001fc12b74:  00 05 28 f8 dsll	a1,a1,3
[ 388] 0x900000001fc12b78:  00 81 78 2d daddu	t3,a0,at
[ 388] 0x900000001fc12b7c:  91 24 01 71 lbu	a0,369(a5)
[ 388] 0x900000001fc12b80:  00 a1 98 2d daddu	s3,a1,at
[ 388] 0x900000001fc12b84:  30 84 00 ff andi	a0,a0,0xff
[ 388] 0x900000001fc12b88:  91 c5 00 0b lbu	a1,11(t2)
[ 388] 0x900000001fc12b8c:  00 00 b8 12 mflo	s7
[ 388] 0x900000001fc12b90:  30 ae 00 ff andi	t2,a1,0xff
[ 388] 0x900000001fc12b94:  dd e5 00 00 ld	a1,0(t3)
[ 388] 0x900000001fc12b98:  00 04 20 f8 dsll	a0,a0,3
[ 388] 0x900000001fc12b9c:  00 ae 00 1d dmultu	a1,t2
[ 388] 0x900000001fc12ba0:  00 44 20 2d daddu	a0,v0,a0
[ 388] 0x900000001fc12ba4:  26 ce 00 02 addiu	t2,s6,2
[ 388] 0x900000001fc12ba8:  26 c5 00 01 addiu	a1,s6,1
[ 388] 0x900000001fc12bac:  32 d8 00 ff andi	t8,s6,0xff
[ 388] 0x900000001fc12bb0:  01 70 78 2b sltu	t3,a7,s0
[ 388] 0x900000001fc12bb4:  30 a5 00 ff andi	a1,a1,0xff
[ 388] 0x900000001fc12bb8:  02 0f 58 0b movn	a7,s0,t3
[ 388] 0x900000001fc12bbc:  00 00 00 21 nada
[ 388] 0x900000001fc12bc0:  00 00 00 21 nada
[ 388] 0x900000001fc12bc4:  00 00 00 21 nada
[ 388] 0x900000001fc12bc8:  03 19 50 0b movn	a6,t8,t9
[ 388] 0x900000001fc12bcc:  00 00 00 21 nada
[ 388] 0x900000001fc12bd0:  00 00 00 21 nada
[ 388] 0x900000001fc12bd4:  00 00 00 21 nada
[ 388] 0x900000001fc12bd8:  00 bf 50 0b movn	a6,a1,ra
[ 388] 0x900000001fc12bdc:  00 00 00 21 nada
[ 388] 0x900000001fc12be0:  00 00 00 21 nada
[ 388] 0x900000001fc12be4:  00 00 00 21 nada
[ 388] 0x900000001fc12be8:  01 71 f8 2b sltu	ra,a7,s1
[ 388] 0x900000001fc12bec:  00 00 f0 12 mflo	s8
[ 388] 0x900000001fc12bf0:  91 98 01 70 lbu	t8,368(t0)
[ 388] 0x900000001fc12bf4:  14 c3 fe fd bne	a2,v1,0x900000001fc127ec
[ 388] 0x900000001fc12bf8:  91 a5 00 0b lbu	a1,11(t1)
[ 388] 0x900000001fc12bfc:  ff ac 00 80 sd	t0,128(sp)
[ 388] 0x900000001fc12c00:  ff a8 00 88 sd	a4,136(sp)
[ 388] 0x900000001fc12c04:  ff ae 00 90 sd	t2,144(sp)
[ 388] 0x900000001fc12c08:  ff bf 00 98 sd	ra,152(sp)
[ 388] 0x900000001fc12c0c:  ff be 00 a0 sd	s8,160(sp)
[ 388] 0x900000001fc12c10:  ff b1 00 a8 sd	s1,168(sp)
[ 388] 0x900000001fc12c14:  ff a4 00 b0 sd	a0,176(sp)
[ 388] 0x900000001fc12c18:  ff aa 00 b8 sd	a6,184(sp)
[ 388] 0x900000001fc12c1c:  ff ab 00 c0 sd	a7,192(sp)
[ 388] 0x900000001fc12c20:  ff af 00 c8 sd	t3,200(sp)
[ 388] 0x900000001fc12c24:  ff b7 00 d0 sd	s7,208(sp)
[ 388] 0x900000001fc12c28:  ff a5 00 d8 sd	a1,216(sp)
[ 388] 0x900000001fc12c2c:  ff b3 00 e0 sd	s3,224(sp)
[ 388] 0x900000001fc12c30:  ff b4 00 e8 sd	s4,232(sp)
[ 388] 0x900000001fc12c34:  ff b8 00 f0 sd	t8,240(sp)
[ 388] 0x900000001fc12c38:  df a6 00 d8 ld	a2,216(sp)
[ 388] 0x900000001fc12c3c:  df a4 00 f0 ld	a0,240(sp)
[ 388] 0x900000001fc12c40:  df a7 00 e0 ld	a3,224(sp)
[ 388] 0x900000001fc12c44:  df a9 00 88 ld	a5,136(sp)
[ 388] 0x900000001fc12c48:  df ad 00 b0 ld	t1,176(sp)
[ 388] 0x900000001fc12c4c:  30 8c 00 ff andi	t0,a0,0xff
[ 388] 0x900000001fc12c50:  dc ee 00 00 ld	t2,0(a3)
[ 388] 0x900000001fc12c54:  df a7 00 80 ld	a3,128(sp)
[ 388] 0x900000001fc12c58:  30 d1 00 ff andi	s1,a2,0xff
[ 388] 0x900000001fc12c5c:  00 0c 60 f8 dsll	t0,t0,3
[ 388] 0x900000001fc12c60:  91 29 01 71 lbu	a5,369(a5)
[ 388] 0x900000001fc12c64:  dd b0 00 00 ld	s0,0(t1)
[ 388] 0x900000001fc12c68:  01 d1 00 1d dmultu	t2,s1
[ 388] 0x900000001fc12c6c:  31 29 00 ff andi	a5,a5,0xff
[ 388] 0x900000001fc12c70:  90 e7 01 71 lbu	a3,369(a3)
[ 388] 0x900000001fc12c74:  df ae 00 e8 ld	t2,232(sp)
[ 388] 0x900000001fc12c78:  30 e7 00 ff andi	a3,a3,0xff
[ 388] 0x900000001fc12c7c:  00 09 48 f8 dsll	a5,a5,3
[ 388] 0x900000001fc12c80:  92 0d 00 0a lbu	t1,10(s0)
[ 388] 0x900000001fc12c84:  00 07 38 f8 dsll	a3,a3,3
[ 388] 0x900000001fc12c88:  31 ad 00 ff andi	t1,t1,0xff
[ 388] 0x900000001fc12c8c:  dd ce 00 00 ld	t2,0(t2)
[ 388] 0x900000001fc12c90:  00 4c 60 2d daddu	t0,v0,t0
[ 388] 0x900000001fc12c94:  92 10 00 0b lbu	s0,11(s0)
[ 388] 0x900000001fc12c98:  00 0d 68 f8 dsll	t1,t1,3
[ 388] 0x900000001fc12c9c:  32 10 00 ff andi	s0,s0,0xff
[ 388] 0x900000001fc12ca0:  91 d1 00 0a lbu	s1,10(t2)
[ 388] 0x900000001fc12ca4:  01 a1 68 2d daddu	t1,t1,at
[ 388] 0x900000001fc12ca8:  32 33 00 ff andi	s3,s1,0xff
[ 388] 0x900000001fc12cac:  00 49 48 2d daddu	a5,v0,a5
[ 388] 0x900000001fc12cb0:  dd 8c 00 00 ld	t0,0(t0)
[ 388] 0x900000001fc12cb4:  91 ce 00 0b lbu	t2,11(t2)
[ 388] 0x900000001fc12cb8:  00 47 38 2d daddu	a3,v0,a3
[ 388] 0x900000001fc12cbc:  00 00 c0 12 mflo	t8
[ 388] 0x900000001fc12cc0:  dd ad 00 00 ld	t1,0(t1)
[ 388] 0x900000001fc12cc4:  31 d1 00 ff andi	s1,t2,0xff
[ 388] 0x900000001fc12cc8:  91 8e 00 0a lbu	t2,10(t0)
[ 388] 0x900000001fc12ccc:  01 b0 00 1d dmultu	t1,s0
[ 388] 0x900000001fc12cd0:  dd 2d 00 00 ld	t1,0(a5)
[ 388] 0x900000001fc12cd4:  00 13 98 f8 dsll	s3,s3,3
[ 388] 0x900000001fc12cd8:  31 ce 00 ff andi	t2,t2,0xff
[ 388] 0x900000001fc12cdc:  dc e9 00 00 ld	a5,0(a3)
[ 388] 0x900000001fc12ce0:  02 61 98 2d daddu	s3,s3,at
[ 388] 0x900000001fc12ce4:  00 0e 70 f8 dsll	t2,t2,3
[ 388] 0x900000001fc12ce8:  91 b0 00 0a lbu	s0,10(t1)
[ 388] 0x900000001fc12cec:  32 10 00 ff andi	s0,s0,0xff
[ 388] 0x900000001fc12cf0:  01 c1 70 2d daddu	t2,t2,at
[ 388] 0x900000001fc12cf4:  91 27 00 0a lbu	a3,10(a5)
[ 388] 0x900000001fc12cf8:  30 e7 00 ff andi	a3,a3,0xff
[ 388] 0x900000001fc12cfc:  00 10 80 f8 dsll	s0,s0,3
[ 388] 0x900000001fc12d00:  00 07 38 f8 dsll	a3,a3,3
[ 388] 0x900000001fc12d04:  02 01 80 2d daddu	s0,s0,at
[ 388] 0x900000001fc12d08:  00 e1 38 2d daddu	a3,a3,at
[ 388] 0x900000001fc12d0c:  00 00 a8 12 mflo	s5
[ 388] 0x900000001fc12d10:  de 61 00 00 ld	at,0(s3)
[ 388] 0x900000001fc12d14:  df a5 00 c0 ld	a1,192(sp)
[ 388] 0x900000001fc12d18:  df a4 00 a8 ld	a0,168(sp)
[ 388] 0x900000001fc12d1c:  00 31 00 1d dmultu	at,s1
[ 388] 0x900000001fc12d20:  df b4 00 98 ld	s4,152(sp)
[ 388] 0x900000001fc12d24:  df a6 00 90 ld	a2,144(sp)
[ 388] 0x900000001fc12d28:  00 94 28 0b movn	a1,a0,s4
[ 388] 0x900000001fc12d2c:  00 00 00 21 nada
[ 388] 0x900000001fc12d30:  00 00 00 21 nada
[ 388] 0x900000001fc12d34:  00 00 00 21 nada
[ 388] 0x900000001fc12d38:  24 ca 00 01 addiu	a6,a2,1
[ 388] 0x900000001fc12d3c:  df a3 00 b8 ld	v1,184(sp)
[ 388] 0x900000001fc12d40:  30 c4 00 ff andi	a0,a2,0xff
[ 388] 0x900000001fc12d44:  24 c6 00 02 addiu	a2,a2,2
[ 388] 0x900000001fc12d48:  df af 00 c8 ld	t3,200(sp)
[ 388] 0x900000001fc12d4c:  31 4a 00 ff andi	a6,a6,0xff
[ 388] 0x900000001fc12d50:  00 8f 18 0b movn	v1,a0,t3
[ 388] 0x900000001fc12d54:  00 00 00 21 nada
[ 388] 0x900000001fc12d58:  00 00 00 21 nada
[ 388] 0x900000001fc12d5c:  00 00 00 21 nada
[ 388] 0x900000001fc12d60:  24 c4 00 01 addiu	a0,a2,1
[ 388] 0x900000001fc12d64:  30 cf 00 ff andi	t3,a2,0xff
[ 388] 0x900000001fc12d68:  91 ad 00 0b lbu	t1,11(t1)
[ 388] 0x900000001fc12d6c:  df b6 00 d0 ld	s6,208(sp)
[ 388] 0x900000001fc12d70:  31 ad 00 ff andi	t1,t1,0xff
[ 388] 0x900000001fc12d74:  00 00 88 12 mflo	s1
[ 388] 0x900000001fc12d78:  de 01 00 00 ld	at,0(s0)
[ 388] 0x900000001fc12d7c:  00 b6 90 2b sltu	s2,a1,s6
[ 388] 0x900000001fc12d80:  00 2d 00 1d dmultu	at,t1
[ 388] 0x900000001fc12d84:  24 c6 00 02 addiu	a2,a2,2
[ 388] 0x900000001fc12d88:  02 d2 28 0b movn	a1,s6,s2
[ 388] 0x900000001fc12d8c:  00 00 00 21 nada
[ 388] 0x900000001fc12d90:  00 00 00 21 nada
[ 388] 0x900000001fc12d94:  00 00 00 21 nada
[ 388] 0x900000001fc12d98:  01 54 18 0b movn	v1,a6,s4
[ 388] 0x900000001fc12d9c:  00 00 00 21 nada
[ 388] 0x900000001fc12da0:  00 00 00 21 nada
[ 388] 0x900000001fc12da4:  00 00 00 21 nada
[ 388] 0x900000001fc12da8:  30 8a 00 ff andi	a6,a0,0xff
[ 388] 0x900000001fc12dac:  24 c4 00 01 addiu	a0,a2,1
[ 388] 0x900000001fc12db0:  30 d4 00 ff andi	s4,a2,0xff
[ 388] 0x900000001fc12db4:  24 c6 00 02 addiu	a2,a2,2
[ 388] 0x900000001fc12db8:  01 f2 18 0b movn	v1,t3,s2
[ 388] 0x900000001fc12dbc:  00 00 00 21 nada
[ 388] 0x900000001fc12dc0:  00 00 00 21 nada
[ 388] 0x900000001fc12dc4:  00 00 00 21 nada
[ 388] 0x900000001fc12dc8:  30 92 00 ff andi	s2,a0,0xff
[ 388] 0x900000001fc12dcc:  24 c4 00 01 addiu	a0,a2,1
[ 388] 0x900000001fc12dd0:  91 8c 00 0b lbu	t0,11(t0)
[ 388] 0x900000001fc12dd4:  31 8c 00 ff andi	t0,t0,0xff
[ 388] 0x900000001fc12dd8:  00 00 68 12 mflo	t1
[ 388] 0x900000001fc12ddc:  dd c1 00 00 ld	at,0(t2)
[ 388] 0x900000001fc12de0:  30 cf 00 ff andi	t3,a2,0xff
[ 388] 0x900000001fc12de4:  df b9 00 a0 ld	t9,160(sp)
[ 388] 0x900000001fc12de8:  00 2c 00 1d dmultu	at,t0
[ 388] 0x900000001fc12dec:  24 c6 00 02 addiu	a2,a2,2
[ 388] 0x900000001fc12df0:  00 b9 b0 2b sltu	s6,a1,t9
[ 388] 0x900000001fc12df4:  03 36 28 0b movn	a1,t9,s6
[ 388] 0x900000001fc12df8:  00 00 00 21 nada
[ 388] 0x900000001fc12dfc:  00 00 00 21 nada
[ 388] 0x900000001fc12e00:  00 00 00 21 nada
[ 388] 0x900000001fc12e04:  01 56 18 0b movn	v1,a6,s6
[ 388] 0x900000001fc12e08:  00 00 00 21 nada
[ 388] 0x900000001fc12e0c:  00 00 00 21 nada
[ 388] 0x900000001fc12e10:  00 00 00 21 nada
[ 388] 0x900000001fc12e14:  30 8a 00 ff andi	a6,a0,0xff
[ 388] 0x900000001fc12e18:  24 c4 00 01 addiu	a0,a2,1
[ 388] 0x900000001fc12e1c:  30 c6 00 ff andi	a2,a2,0xff
[ 388] 0x900000001fc12e20:  91 29 00 0b lbu	a5,11(a5)
[ 388] 0x900000001fc12e24:  00 b8 b0 2b sltu	s6,a1,t8
[ 388] 0x900000001fc12e28:  31 29 00 ff andi	a5,a5,0xff
[ 388] 0x900000001fc12e2c:  03 16 28 0b movn	a1,t8,s6
[ 388] 0x900000001fc12e30:  00 00 00 21 nada
[ 388] 0x900000001fc12e34:  00 00 00 21 nada
[ 388] 0x900000001fc12e38:  00 00 00 21 nada
[ 388] 0x900000001fc12e3c:  00 b5 98 2b sltu	s3,a1,s5
[ 388] 0x900000001fc12e40:  00 00 08 12 mflo	at
[ 388] 0x900000001fc12e44:  dc e7 00 00 ld	a3,0(a3)
[ 388] 0x900000001fc12e48:  02 b3 28 0b movn	a1,s5,s3
[ 388] 0x900000001fc12e4c:  00 00 00 21 nada
[ 388] 0x900000001fc12e50:  00 00 00 21 nada
[ 388] 0x900000001fc12e54:  00 00 00 21 nada
[ 388] 0x900000001fc12e58:  00 e9 00 1d dmultu	a3,a5
[ 388] 0x900000001fc12e5c:  30 84 00 ff andi	a0,a0,0xff
[ 388] 0x900000001fc12e60:  00 b1 80 2b sltu	s0,a1,s1
[ 388] 0x900000001fc12e64:  02 96 18 0b movn	v1,s4,s6
[ 388] 0x900000001fc12e68:  00 00 00 21 nada
[ 388] 0x900000001fc12e6c:  00 00 00 21 nada
[ 388] 0x900000001fc12e70:  00 00 00 21 nada
[ 388] 0x900000001fc12e74:  02 30 28 0b movn	a1,s1,s0
[ 388] 0x900000001fc12e78:  00 00 00 21 nada
[ 388] 0x900000001fc12e7c:  00 00 00 21 nada
[ 388] 0x900000001fc12e80:  00 00 00 21 nada
[ 388] 0x900000001fc12e84:  02 53 18 0b movn	v1,s2,s3
[ 388] 0x900000001fc12e88:  00 00 00 21 nada
[ 388] 0x900000001fc12e8c:  00 00 00 21 nada
[ 388] 0x900000001fc12e90:  00 00 00 21 nada
[ 388] 0x900000001fc12e94:  00 ad 60 2b sltu	t0,a1,t1
[ 388] 0x900000001fc12e98:  01 f0 18 0b movn	v1,t3,s0
[ 388] 0x900000001fc12e9c:  00 00 00 21 nada
[ 388] 0x900000001fc12ea0:  00 00 00 21 nada
[ 388] 0x900000001fc12ea4:  00 00 00 21 nada
[ 388] 0x900000001fc12ea8:  01 ac 28 0b movn	a1,t1,t0
[ 388] 0x900000001fc12eac:  00 00 00 21 nada
[ 388] 0x900000001fc12eb0:  00 00 00 21 nada
[ 388] 0x900000001fc12eb4:  00 00 00 21 nada
[ 388] 0x900000001fc12eb8:  df bf 01 10 ld	ra,272(sp)
[ 388] 0x900000001fc12ebc:  01 4c 18 0b movn	v1,a6,t0
[ 388] 0x900000001fc12ec0:  00 00 00 21 nada
[ 388] 0x900000001fc12ec4:  00 00 00 21 nada
[ 388] 0x900000001fc12ec8:  00 00 00 21 nada
[ 388] 0x900000001fc12ecc:  00 a1 38 2b sltu	a3,a1,at
[ 388] 0x900000001fc12ed0:  df be 01 08 ld	s8,264(sp)
[ 388] 0x900000001fc12ed4:  df b4 00 68 ld	s4,104(sp)
[ 388] 0x900000001fc12ed8:  00 27 28 0b movn	a1,at,a3
[ 388] 0x900000001fc12edc:  00 00 00 21 nada
[ 388] 0x900000001fc12ee0:  00 00 00 21 nada
[ 388] 0x900000001fc12ee4:  00 00 00 21 nada
[ 388] 0x900000001fc12ee8:  00 00 08 12 mflo	at
[ 388] 0x900000001fc12eec:  df b7 01 00 ld	s7,256(sp)
[ 388] 0x900000001fc12ef0:  df ab 00 f8 ld	a7,248(sp)
[ 388] 0x900000001fc12ef4:  00 c7 18 0b movn	v1,a2,a3
[ 388] 0x900000001fc12ef8:  00 00 00 21 nada
[ 388] 0x900000001fc12efc:  00 00 00 21 nada
[ 388] 0x900000001fc12f00:  00 00 00 21 nada
[ 388] 0x900000001fc12f04:  00 a1 08 2b sltu	at,a1,at
[ 388] 0x900000001fc12f08:  df a8 00 60 ld	a4,96(sp)
[ 388] 0x900000001fc12f0c:  de 94 00 10 ld	s4,16(s4)
[ 388] 0x900000001fc12f10:  00 81 18 0b movn	v1,a0,at
[ 388] 0x900000001fc12f14:  00 00 00 21 nada
[ 388] 0x900000001fc12f18:  00 00 00 21 nada
[ 388] 0x900000001fc12f1c:  00 00 00 21 nada
[ 388] 0x900000001fc12f20:  ff a3 00 78 sd	v1,120(sp)
[ 388] 0x900000001fc12f24:  df b3 00 78 ld	s3,120(sp)
[ 388] 0x900000001fc12f28:  10 00 00 79 b		0x900000001fc13110
[ 388] 0x900000001fc12f2c:  00 00 00 21 nada
[ 388] 0x900000001fc12f30:  ff a8 00 80 sd	a4,128(sp)
[ 388] 0x900000001fc12f34:  ff a9 00 88 sd	a5,136(sp)
[ 388] 0x900000001fc12f38:  ff b6 00 90 sd	s6,144(sp)
[ 388] 0x900000001fc12f3c:  ff bf 00 98 sd	ra,152(sp)
[ 388] 0x900000001fc12f40:  ff b1 00 a0 sd	s1,160(sp)
[ 388] 0x900000001fc12f44:  ff b5 00 a8 sd	s5,168(sp)
[ 388] 0x900000001fc12f48:  ff ae 00 b0 sd	t2,176(sp)
[ 388] 0x900000001fc12f4c:  ff b9 00 c8 sd	t9,200(sp)
[ 388] 0x900000001fc12f50:  ff b0 00 d0 sd	s0,208(sp)
[ 388] 0x900000001fc12f54:  ff a5 00 d8 sd	a1,216(sp)
[ 388] 0x900000001fc12f58:  ff af 00 e0 sd	t3,224(sp)
[ 388] 0x900000001fc12f5c:  ff b4 00 e8 sd	s4,232(sp)
[ 388] 0x900000001fc12f60:  ff a4 00 f0 sd	a0,240(sp)
[ 388] 0x900000001fc12f64:  01 40 b8 25 move	s7,a6
[ 388] 0x900000001fc12f68:  ff ab 00 c0 sd	a7,192(sp)
[ 388] 0x900000001fc12f6c:  01 60 90 25 move	s2,a7
[ 388] 0x900000001fc12f70:  ff aa 00 b8 sd	a6,184(sp)
[ 388] 0x900000001fc12f74:  10 00 ff 31 b		0x900000001fc12c3c
[ 388] 0x900000001fc12f78:  df a6 00 d8 ld	a2,216(sp)
[ 388] 0x900000001fc12f7c:  ff a9 00 80 sd	a5,128(sp)
[ 388] 0x900000001fc12f80:  ff a7 00 88 sd	a3,136(sp)
[ 388] 0x900000001fc12f84:  ff b8 00 90 sd	t8,144(sp)
[ 388] 0x900000001fc12f88:  ff bf 00 98 sd	ra,152(sp)
[ 388] 0x900000001fc12f8c:  ff b5 00 a0 sd	s5,160(sp)
[ 388] 0x900000001fc12f90:  ff b1 00 a8 sd	s1,168(sp)
[ 388] 0x900000001fc12f94:  ff b6 00 b0 sd	s6,176(sp)
[ 388] 0x900000001fc12f98:  ff ab 00 c0 sd	a7,192(sp)
[ 388] 0x900000001fc12f9c:  ff b3 00 c8 sd	s3,200(sp)
[ 388] 0x900000001fc12fa0:  ff b2 00 d0 sd	s2,208(sp)
[ 388] 0x900000001fc12fa4:  ff a5 00 d8 sd	a1,216(sp)
[ 388] 0x900000001fc12fa8:  ff b9 00 e0 sd	t9,224(sp)
[ 388] 0x900000001fc12fac:  ff b4 00 e8 sd	s4,232(sp)
[ 388] 0x900000001fc12fb0:  ff a4 00 f0 sd	a0,240(sp)
[ 388] 0x900000001fc12fb4:  01 40 b8 25 move	s7,a6
[ 388] 0x900000001fc12fb8:  ff aa 00 b8 sd	a6,184(sp)
[ 388] 0x900000001fc12fbc:  10 00 ff 1f b		0x900000001fc12c3c
[ 388] 0x900000001fc12fc0:  df a6 00 d8 ld	a2,216(sp)
[ 388] 0x900000001fc12fc4:  ff a7 00 80 sd	a3,128(sp)
[ 388] 0x900000001fc12fc8:  ff a6 00 88 sd	a2,136(sp)
[ 388] 0x900000001fc12fcc:  ff ae 00 90 sd	t2,144(sp)
[ 388] 0x900000001fc12fd0:  ff bf 00 98 sd	ra,152(sp)
[ 388] 0x900000001fc12fd4:  ff b1 00 a0 sd	s1,160(sp)
[ 388] 0x900000001fc12fd8:  ff b5 00 a8 sd	s5,168(sp)
[ 388] 0x900000001fc12fdc:  ff b6 00 b0 sd	s6,176(sp)
[ 388] 0x900000001fc12fe0:  ff ab 00 c0 sd	a7,192(sp)
[ 388] 0x900000001fc12fe4:  ff af 00 c8 sd	t3,200(sp)
[ 388] 0x900000001fc12fe8:  ff b0 00 d0 sd	s0,208(sp)
[ 388] 0x900000001fc12fec:  ff a5 00 d8 sd	a1,216(sp)
[ 388] 0x900000001fc12ff0:  ff b3 00 e0 sd	s3,224(sp)
[ 388] 0x900000001fc12ff4:  ff b4 00 e8 sd	s4,232(sp)
[ 388] 0x900000001fc12ff8:  ff a4 00 f0 sd	a0,240(sp)
[ 388] 0x900000001fc12ffc:  01 40 b8 25 move	s7,a6
[ 388] 0x900000001fc13000:  ff aa 00 b8 sd	a6,184(sp)
[ 388] 0x900000001fc13004:  10 00 ff 0d b		0x900000001fc12c3c
[ 388] 0x900000001fc13008:  df a6 00 d8 ld	a2,216(sp)
[ 388] 0x900000001fc1300c:  ff ac 00 88 sd	t0,136(sp)
[ 388] 0x900000001fc13010:  ff a6 00 80 sd	a2,128(sp)
[ 388] 0x900000001fc13014:  ff b8 00 90 sd	t8,144(sp)
[ 388] 0x900000001fc13018:  ff bf 00 98 sd	ra,152(sp)
[ 388] 0x900000001fc1301c:  ff be 00 a8 sd	s8,168(sp)
[ 388] 0x900000001fc13020:  ff b5 00 a0 sd	s5,160(sp)
[ 388] 0x900000001fc13024:  ff b6 00 b0 sd	s6,176(sp)
[ 388] 0x900000001fc13028:  ff ab 00 c0 sd	a7,192(sp)
[ 388] 0x900000001fc1302c:  ff b9 00 c8 sd	t9,200(sp)
[ 388] 0x900000001fc13030:  ff b2 00 d0 sd	s2,208(sp)
[ 388] 0x900000001fc13034:  ff a5 00 d8 sd	a1,216(sp)
[ 388] 0x900000001fc13038:  ff b3 00 e0 sd	s3,224(sp)
[ 388] 0x900000001fc1303c:  ff b4 00 e8 sd	s4,232(sp)
[ 388] 0x900000001fc13040:  ff a4 00 f0 sd	a0,240(sp)
[ 388] 0x900000001fc13044:  01 40 b8 25 move	s7,a6
[ 388] 0x900000001fc13048:  ff aa 00 b8 sd	a6,184(sp)
[ 388] 0x900000001fc1304c:  10 00 fe fb b		0x900000001fc12c3c
[ 388] 0x900000001fc13050:  df a6 00 d8 ld	a2,216(sp)
[ 388] 0x900000001fc13054:  ff a8 00 60 sd	a4,96(sp)
[ 388] 0x900000001fc13058:  26 50 00 01 addiu	s0,s2,1
[ 388] 0x900000001fc1305c:  92 a1 01 70 lbu	at,368(s5)
[ 388] 0x900000001fc13060:  30 21 00 ff andi	at,at,0xff
[ 388] 0x900000001fc13064:  00 01 08 f8 dsll	at,at,3
[ 388] 0x900000001fc13068:  00 41 08 2d daddu	at,v0,at
[ 388] 0x900000001fc1306c:  dc 24 00 00 ld	a0,0(at)
[ 388] 0x900000001fc13070:  90 81 00 0a lbu	at,10(a0)
[ 388] 0x900000001fc13074:  92 a3 01 71 lbu	v1,369(s5)
[ 388] 0x900000001fc13078:  66 b5 00 02 daddiu	s5,s5,2
[ 388] 0x900000001fc1307c:  30 21 00 ff andi	at,at,0xff
[ 388] 0x900000001fc13080:  30 63 00 ff andi	v1,v1,0xff
[ 388] 0x900000001fc13084:  00 01 08 f8 dsll	at,at,3
[ 388] 0x900000001fc13088:  00 03 18 f8 dsll	v1,v1,3
[ 388] 0x900000001fc1308c:  00 34 08 2d daddu	at,at,s4
[ 388] 0x900000001fc13090:  00 43 18 2d daddu	v1,v0,v1
[ 388] 0x900000001fc13094:  90 84 00 0b lbu	a0,11(a0)
[ 388] 0x900000001fc13098:  30 84 00 ff andi	a0,a0,0xff
[ 388] 0x900000001fc1309c:  dc 21 00 00 ld	at,0(at)
[ 388] 0x900000001fc130a0:  dc 65 00 00 ld	a1,0(v1)
[ 388] 0x900000001fc130a4:  00 24 00 1d dmultu	at,a0
[ 388] 0x900000001fc130a8:  90 a3 00 0a lbu	v1,10(a1)
[ 388] 0x900000001fc130ac:  30 63 00 ff andi	v1,v1,0xff
[ 388] 0x900000001fc130b0:  00 03 18 f8 dsll	v1,v1,3
[ 388] 0x900000001fc130b4:  00 74 18 2d daddu	v1,v1,s4
[ 388] 0x900000001fc130b8:  90 a5 00 0b lbu	a1,11(a1)
[ 388] 0x900000001fc130bc:  00 00 08 12 mflo	at
[ 388] 0x900000001fc130c0:  30 a5 00 ff andi	a1,a1,0xff
[ 388] 0x900000001fc130c4:  dc 64 00 00 ld	a0,0(v1)
[ 388] 0x900000001fc130c8:  02 c1 18 2b sltu	v1,s6,at
[ 388] 0x900000001fc130cc:  10 60 00 03 beq	v1,zero,0x900000001fc130dc
[ 388] 0x900000001fc130d0:  00 85 00 1d dmultu	a0,a1
[ 388] 0x900000001fc130d4:  32 53 00 ff andi	s3,s2,0xff
[ 388] 0x900000001fc130d8:  00 20 b0 25 move	s6,at
[ 388] 0x900000001fc130dc:  00 00 08 12 mflo	at
[ 388] 0x900000001fc130e0:  02 c1 18 2b sltu	v1,s6,at
[ 388] 0x900000001fc130e4:  10 60 00 03 beq	v1,zero,0x900000001fc130f4
[ 388] 0x900000001fc130e8:  00 00 00 21 nada
[ 388] 0x900000001fc130ec:  32 13 00 ff andi	s3,s0,0xff
[ 388] 0x900000001fc130f0:  00 20 b0 25 move	s6,at
[ 388] 0x900000001fc130f4:  16 a6 ff d8 bne	s5,a2,0x900000001fc13058
[ 388] 0x900000001fc130f8:  26 52 00 02 addiu	s2,s2,2
[ 388] 0x900000001fc130fc:  ff ab 00 f8 sd	a7,248(sp)
[ 388] 0x900000001fc13100:  ff b3 00 78 sd	s3,120(sp)
[ 388] 0x900000001fc13104:  ff b7 01 00 sd	s7,256(sp)
[ 388] 0x900000001fc13108:  ff be 01 08 sd	s8,264(sp)
[ 388] 0x900000001fc1310c:  ff bf 01 10 sd	ra,272(sp)
  394: 	   }
  395: 	}
  396: 
  397: 	temp = index[max]; index[max] = index[i]; index[i] = temp;
[ 397] 0x900000001fc13110:  32 61 00 ff andi	at,s3,0xff
[ 397] 0x900000001fc13114:  03 a1 10 2d daddu	v0,sp,at
[ 381] 0x900000001fc13118:  27 de ff ff addiu	s8,s8,-1
[ 381] 0x900000001fc1311c:  02 e0 18 25 move	v1,s7
[ 381] 0x900000001fc13120:  26 f7 00 01 addiu	s7,s7,1
[ 381] 0x900000001fc13124:  90 41 01 70 lbu	at,368(v0)
[ 381] 0x900000001fc13128:  30 73 00 ff andi	s3,v1,0xff
[ 381] 0x900000001fc1312c:  02 e8 88 2a slt	s1,s7,a4
[ 381] 0x900000001fc13130:  a0 4b 01 70 sb	a7,368(v0)
[ 397] 0x900000001fc13134:  32 63 00 ff andi	v1,s3,0xff
[ 397] 0x900000001fc13138:  a3 e1 01 70 sb	at,368(ra)
[ 397] 0x900000001fc1313c:  df a1 00 70 ld	at,112(sp)
[ 397] 0x900000001fc13140:  67 ff 00 01 daddiu	ra,ra,1
[ 397] 0x900000001fc13144:  17 e1 fd 02 bne	ra,at,0x900000001fc12550
[ 397] 0x900000001fc13148:  03 a3 80 2d daddu	s0,sp,v1
[ 397] 0x900000001fc1314c:  df b4 01 38 ld	s4,312(sp)
[ 397] 0x900000001fc13150:  df b6 01 28 ld	s6,296(sp)
[ 397] 0x900000001fc13154:  df b7 01 20 ld	s7,288(sp)
[ 397] 0x900000001fc13158:  df b5 01 30 ld	s5,304(sp)
[ 397] 0x900000001fc1315c:  df b3 01 40 ld	s3,320(sp)
[ 397] 0x900000001fc13160:  df be 01 18 ld	s8,280(sp)
[ 397] 0x900000001fc13164:  ff be 01 18 sd	s8,280(sp)
  398:     }
  399: 
  400:     /* Finally, we iterate through the sorted array of interleaves
  401:      * and actually configure them appropriately.
  402:      */ 
  403:     for (b = 0; b < num_index; b++) {
[ 403] 0x900000001fc13168:  59 00 00 79 blezl	a4,0x900000001fc13350
[ 403] 0x900000001fc1316c:  df b2 01 48 ld	s2,328(sp)
[ 403] 0x900000001fc13170:  3c 1e 90 00 lui	s8,0x9000
[ 403] 0x900000001fc13174:  63 de 00 00 daddi	s8,s8,0
[ 403] 0x900000001fc13178:  3c 01 1f c2 lui	at,0x1fc2
[ 403] 0x900000001fc1317c:  ff b7 01 20 sd	s7,288(sp)
[ 403] 0x900000001fc13180:  60 21 e8 68 daddi	at,at,-6040
[ 403] 0x900000001fc13184:  00 1e f0 3c dsll32	s8,s8,0
[ 403] 0x900000001fc13188:  ff b6 01 28 sd	s6,296(sp)
[ 403] 0x900000001fc1318c:  03 c1 f0 2c dadd	s8,s8,at
[ 403] 0x900000001fc13190:  00 08 10 3c dsll32	v0,a4,0
[ 403] 0x900000001fc13194:  ff b5 01 30 sd	s5,304(sp)
[ 403] 0x900000001fc13198:  00 02 10 3e dsrl32	v0,v0,0
[ 403] 0x900000001fc1319c:  ff b4 01 38 sd	s4,312(sp)
[ 403] 0x900000001fc131a0:  00 00 a0 25 move	s4,zero
[ 403] 0x900000001fc131a4:  df cb 00 38 ld	a7,56(s8)
[ 403] 0x900000001fc131a8:  03 a0 f8 25 move	ra,sp
[ 403] 0x900000001fc131ac:  03 a2 50 2d daddu	a6,sp,v0
[ 403] 0x900000001fc131b0:  ff be 00 68 sd	s8,104(sp)
[ 403] 0x900000001fc131b4:  df c9 00 10 ld	a5,16(s8)
[ 403] 0x900000001fc131b8:  ff b3 01 40 sd	s3,320(sp)
[ 403] 0x900000001fc131bc:  00 00 98 25 move	s3,zero
  404:  
  405: 	/* Figure out interleave factor */
  406: 	ilf = 0;
  407: 	i = banks[index[b]]->bnk_count;
[ 407] 0x900000001fc131c0:  93 f0 01 70 lbu	s0,368(ra)
[ 407] 0x900000001fc131c4:  02 00 90 25 move	s2,s0
[ 407] 0x900000001fc131c8:  32 01 00 ff andi	at,s0,0xff
[ 407] 0x900000001fc131cc:  00 01 10 f8 dsll	v0,at,3
[ 407] 0x900000001fc131d0:  df a1 00 50 ld	at,80(sp)
[ 407] 0x900000001fc131d4:  00 22 08 2d daddu	at,at,v0
[ 407] 0x900000001fc131d8:  dc 3e 00 00 ld	s8,0(at)
[ 407] 0x900000001fc131dc:  93 d7 00 0b lbu	s7,11(s8)
  408: 
  409: 	while (i >>= 1) ilf++;
[ 409] 0x900000001fc131e0:  00 17 08 43 sra	at,s7,1
[ 406] 0x900000001fc131e4:  50 20 00 06 beql	at,zero,0x900000001fc13200
[ 406] 0x900000001fc131e8:  df a2 00 50 ld	v0,80(sp)
[ 406] 0x900000001fc131ec:  26 94 00 01 addiu	s4,s4,1
[ 409] 0x900000001fc131f0:  00 01 08 43 sra	at,at,1
[ 409] 0x900000001fc131f4:  54 20 ff fe bnel	at,zero,0x900000001fc131f0
[ 409] 0x900000001fc131f8:  26 94 00 01 addiu	s4,s4,1
[ 409] 0x900000001fc131fc:  df a2 00 50 ld	v0,80(sp)
  410: 
  411: 	/* Configure all the banks for this interleave */
  412: 	curr_bank = index[b];
  413: 	for (ilp = 0; ilp < banks[index[b]]->bnk_count; ilp++) {
[ 413] 0x900000001fc13200:  df b5 00 58 ld	s5,88(sp)
[ 413] 0x900000001fc13204:  1a e0 00 3c blez	s7,0x900000001fc132f8
[ 413] 0x900000001fc13208:  02 80 b0 25 move	s6,s4
[ 413] 0x900000001fc1320c:  32 51 00 03 andi	s1,s2,0x3
[ 413] 0x900000001fc13210:  00 11 28 80 sll	a1,s1,2
[ 413] 0x900000001fc13214:  00 12 08 f8 dsll	at,s2,3
[ 413] 0x900000001fc13218:  32 43 00 04 andi	v1,s2,0x4
[ 413] 0x900000001fc1321c:  00 41 08 2d daddu	at,v0,at
[ 413] 0x900000001fc13220:  00 03 80 83 sra	s0,v1,2
[ 413] 0x900000001fc13224:  00 10 19 80 sll	v1,s0,6
  414: 	    DPRINTF(("Config bank %d, base %d, ilp %d, ilf %d\n",
  415: 		     curr_bank, base, ilp, ilf));
  416: 	    SET_BANKREG(banks[curr_bank]->bnk_slot, curr_bank, BANK_BASE, 
[ 416] 0x900000001fc13228:  dc 24 00 00 ld	a0,0(at)
[ 416] 0x900000001fc1322c:  00 65 28 21 addu	a1,v1,a1
[ 416] 0x900000001fc13230:  90 84 00 04 lbu	a0,4(a0)
[ 416] 0x900000001fc13234:  24 a7 00 11 addiu	a3,a1,17
[ 416] 0x900000001fc13238:  00 04 22 c0 sll	a0,a0,11
[ 416] 0x900000001fc1323c:  00 07 38 c0 sll	a3,a3,3
[ 416] 0x900000001fc13240:  00 87 20 2d daddu	a0,a0,a3
[ 416] 0x900000001fc13244:  00 8b 20 2d daddu	a0,a0,a7
[ 416] 0x900000001fc13248:  fc 95 00 00 sd	s5,0(a0)
  417: 			base);
  418: 	    SET_BANKREG(banks[curr_bank]->bnk_slot,curr_bank,BANK_IF, ilf);
[ 418] 0x900000001fc1324c:  dc 24 00 00 ld	a0,0(at)
[ 418] 0x900000001fc13250:  24 a6 00 12 addiu	a2,a1,18
[ 418] 0x900000001fc13254:  00 06 30 c0 sll	a2,a2,3
[ 418] 0x900000001fc13258:  90 84 00 04 lbu	a0,4(a0)
[ 418] 0x900000001fc1325c:  00 04 22 c0 sll	a0,a0,11
[ 418] 0x900000001fc13260:  00 86 20 2d daddu	a0,a0,a2
[ 418] 0x900000001fc13264:  00 8b 20 2d daddu	a0,a0,a7
[ 418] 0x900000001fc13268:  fc 96 00 00 sd	s6,0(a0)
  419: 	    SET_BANKREG(banks[curr_bank]->bnk_slot,curr_bank,BANK_IP, ilp);
[ 419] 0x900000001fc1326c:  dc 24 00 00 ld	a0,0(at)
[ 419] 0x900000001fc13270:  24 a5 00 13 addiu	a1,a1,19
[ 419] 0x900000001fc13274:  00 05 28 c0 sll	a1,a1,3
[ 419] 0x900000001fc13278:  90 84 00 04 lbu	a0,4(a0)
[ 419] 0x900000001fc1327c:  00 04 22 c0 sll	a0,a0,11
[ 419] 0x900000001fc13280:  00 85 20 2d daddu	a0,a0,a1
[ 419] 0x900000001fc13284:  00 8b 20 2d daddu	a0,a0,a7
[ 419] 0x900000001fc13288:  fc 93 00 00 sd	s3,0(a0)
  420: 
  421: 	    /* Stuff calculated info into banks structure for the
  422: 	     * benefit of diags and other test routines.
  423: 	     */
  424: 	    banks[curr_bank]->bnk_ip = ilp;
[ 424] 0x900000001fc1328c:  dc 24 00 00 ld	a0,0(at)
[ 424] 0x900000001fc13290:  a0 93 00 08 sb	s3,8(a0)
  425: 	    banks[curr_bank]->bnk_bloc = base;
[ 425] 0x900000001fc13294:  dc 25 00 00 ld	a1,0(at)
  426: 	    prev_bank = curr_bank;
  427: 	    curr_bank = banks[curr_bank]->bnk_next;
  428: 	    banks[prev_bank]->bnk_if = ilf; 
[ 428] 0x900000001fc13298:  00 12 18 f8 dsll	v1,s2,3
[ 428] 0x900000001fc1329c:  df a4 00 58 ld	a0,88(sp)
[ 428] 0x900000001fc132a0:  00 43 18 2d daddu	v1,v0,v1
[ 428] 0x900000001fc132a4:  ac a4 00 00 sw	a0,0(a1)
[ 427] 0x900000001fc132a8:  dc 24 00 00 ld	a0,0(at)
[ 427] 0x900000001fc132ac:  dc 61 00 00 ld	at,0(v1)
[ 427] 0x900000001fc132b0:  90 92 00 09 lbu	s2,9(a0)
[ 427] 0x900000001fc132b4:  a0 34 00 09 sb	s4,9(at)
[ 413] 0x900000001fc132b8:  93 e3 01 70 lbu	v1,368(ra)
[ 413] 0x900000001fc132bc:  30 63 00 ff andi	v1,v1,0xff
[ 413] 0x900000001fc132c0:  00 03 18 f8 dsll	v1,v1,3
[ 413] 0x900000001fc132c4:  00 43 18 2d daddu	v1,v0,v1
[ 413] 0x900000001fc132c8:  dc 7e 00 00 ld	s8,0(v1)
[ 413] 0x900000001fc132cc:  32 51 00 03 andi	s1,s2,0x3
[ 413] 0x900000001fc132d0:  00 12 08 f8 dsll	at,s2,3
[ 413] 0x900000001fc132d4:  00 11 28 80 sll	a1,s1,2
[ 413] 0x900000001fc132d8:  00 41 08 2d daddu	at,v0,at
[ 413] 0x900000001fc132dc:  26 73 00 01 addiu	s3,s3,1
[ 413] 0x900000001fc132e0:  93 d7 00 0b lbu	s7,11(s8)
[ 413] 0x900000001fc132e4:  32 44 00 04 andi	a0,s2,0x4
[ 413] 0x900000001fc132e8:  00 04 80 83 sra	s0,a0,2
[ 413] 0x900000001fc132ec:  02 77 18 2a slt	v1,s3,s7
[ 413] 0x900000001fc132f0:  54 60 ff cd bnel	v1,zero,0x900000001fc13228
[ 413] 0x900000001fc132f4:  00 10 19 80 sll	v1,s0,6
[ 413] 0x900000001fc132f8:  00 00 a0 25 move	s4,zero
  429: 	}
  430: 
  431: 	memdex = banks[index[b]]->bnk_size;
[ 431] 0x900000001fc132fc:  93 c1 00 0a lbu	at,10(s8)
  432: 	base += (MemSizes[memdex] * banks[index[b]]->bnk_count);
[ 432] 0x900000001fc13300:  00 01 08 f8 dsll	at,at,3
[ 432] 0x900000001fc13304:  00 29 08 2d daddu	at,at,a5
[ 432] 0x900000001fc13308:  32 e2 00 ff andi	v0,s7,0xff
[ 432] 0x900000001fc1330c:  dc 21 00 00 ld	at,0(at)
[ 432] 0x900000001fc13310:  00 22 00 1d dmultu	at,v0
[ 432] 0x900000001fc13314:  df a2 00 58 ld	v0,88(sp)
[ 432] 0x900000001fc13318:  00 00 08 12 mflo	at
[ 432] 0x900000001fc1331c:  00 22 08 2d daddu	at,at,v0
[ 403] 0x900000001fc13320:  00 01 08 00 sll	at,at,0
[ 403] 0x900000001fc13324:  67 ff 00 01 daddiu	ra,ra,1
[ 403] 0x900000001fc13328:  ff a1 00 58 sd	at,88(sp)
[ 403] 0x900000001fc1332c:  57 ea ff a4 bnel	ra,a6,0x900000001fc131c0
[ 403] 0x900000001fc13330:  00 00 98 25 move	s3,zero
[ 403] 0x900000001fc13334:  df b4 01 38 ld	s4,312(sp)
[ 403] 0x900000001fc13338:  df b6 01 28 ld	s6,296(sp)
[ 403] 0x900000001fc1333c:  df b7 01 20 ld	s7,288(sp)
[ 403] 0x900000001fc13340:  df b5 01 30 ld	s5,304(sp)
[ 403] 0x900000001fc13344:  df b3 01 40 ld	s3,320(sp)
[ 403] 0x900000001fc13348:  df be 01 18 ld	s8,280(sp)
[ 403] 0x900000001fc1334c:  df b2 01 48 ld	s2,328(sp)
  433:     }
  434:     
  435:     return base;
[ 435] 0x900000001fc13350:  10 00 00 0d b		0x900000001fc13388
[ 435] 0x900000001fc13354:  df a2 00 58 ld	v0,88(sp)
[ 435] 0x900000001fc13358:  df b2 01 48 ld	s2,328(sp)
[ 356] 0x900000001fc1335c:  10 00 00 0a b		0x900000001fc13388
[ 356] 0x900000001fc13360:  00 00 10 25 move	v0,zero
[ 356] 0x900000001fc13364:  df b2 01 48 ld	s2,328(sp)
[ 341] 0x900000001fc13368:  3c 1f 90 00 lui	ra,0x9000
[ 341] 0x900000001fc1336c:  3c 01 1f c2 lui	at,0x1fc2
[ 341] 0x900000001fc13370:  63 ff 00 00 daddi	ra,ra,0
[ 341] 0x900000001fc13374:  60 22 e8 80 daddi	v0,at,-6016
[ 341] 0x900000001fc13378:  00 1f 08 3c dsll32	at,ra,0
[ 341] 0x900000001fc1337c:  0f f0 2c e3 jal		loprintf
[ 341] 0x900000001fc13380:  00 22 20 2c dadd	a0,at,v0
[ 342] 0x900000001fc13384:  00 00 10 25 move	v0,zero
[ 342] 0x900000001fc13388:  df bf 01 60 ld	ra,352(sp)
[ 342] 0x900000001fc1338c:  df b0 01 58 ld	s0,344(sp)
[ 342] 0x900000001fc13390:  df b1 01 50 ld	s1,336(sp)
[ 342] 0x900000001fc13394:  03 e0 00 08 jr	ra
[ 342] 0x900000001fc13398:  67 bd 01 b0 daddiu	sp,sp,432
  436: }
  437: 
  438: 
  439: /*
  440:  * activate_memory()
  441:  * 	Switches on all of the configured banks of memory. We
  442:  *	do this here to ensure that everything is configured 
  443:  *	before the memory starts responding to requests.
  444:  * Parameters:
  445:  *	bpos -- the number of banks in the banks array.
  446:  *	bank -- the array containing the actual information about the 
  447:  *	         banks configured in the system.
  448:  * Returns:
  449:  *	Nothing.
  450:  */
  451: 
  452: void
  453: activate_memory(int bpos, evbnkcfg_t *bank[])
  454: {
activate_memory:
[ 454] 0x900000001fc1339c:  00 00 48 25 move	a5,zero
[ 454] 0x900000001fc133a0:  67 bd ff d0 daddiu	sp,sp,-48
[ 454] 0x900000001fc133a4:  3c 01 90 00 lui	at,0x9000
[ 454] 0x900000001fc133a8:  00 00 30 25 move	a2,zero
[ 454] 0x900000001fc133ac:  3c 03 1f c2 lui	v1,0x1fc2
[ 454] 0x900000001fc133b0:  ff b2 00 10 sd	s2,16(sp)
[ 454] 0x900000001fc133b4:  00 80 90 25 move	s2,a0
  455:     int b = 0;			/* Current bank index */
[ 455] 0x900000001fc133b8:  24 08 00 07 li	a4,7
[ 455] 0x900000001fc133bc:  ff b0 00 20 sd	s0,32(sp)
[ 455] 0x900000001fc133c0:  24 10 00 09 li	s0,9
[ 455] 0x900000001fc133c4:  00 a0 50 25 move	a6,a1
[ 455] 0x900000001fc133c8:  24 02 00 01 li	v0,1
[ 455] 0x900000001fc133cc:  ff b1 00 18 sd	s1,24(sp)
[ 455] 0x900000001fc133d0:  ff b3 00 08 sd	s3,8(sp)
[ 455] 0x900000001fc133d4:  5a 40 00 4a blezl	s2,0x900000001fc13500
[ 455] 0x900000001fc133d8:  df b1 00 18 ld	s1,24(sp)
[ 455] 0x900000001fc133dc:  60 21 00 00 daddi	at,at,0
[ 455] 0x900000001fc133e0:  60 63 e8 68 daddi	v1,v1,-6040
[ 455] 0x900000001fc133e4:  00 01 08 3c dsll32	at,at,0
[ 455] 0x900000001fc133e8:  00 23 08 2c dadd	at,at,v1
[ 455] 0x900000001fc133ec:  ff a1 00 00 sd	at,0(sp)
[ 455] 0x900000001fc133f0:  24 04 00 04 li	a0,4
[ 455] 0x900000001fc133f4:  00 40 28 25 move	a1,v0
[ 455] 0x900000001fc133f8:  dc 33 00 38 ld	s3,56(at)
  456:     int ldex, bdex;		/* Leaf and bank indexes */
  457:     int bank_enable;		/* Bank enable information */
  458:     int slot;			/* Slot of MC3 currently being enabled */
  459: 
  460:     while (b < bpos) {
  461: 
  462: 	bank_enable = 0;
[ 462] 0x900000001fc133fc:  00 00 38 25 move	a3,zero
  463: 	slot = bank[b]->bnk_slot;
  464: 	for (ldex = 0; ldex < MC3_NUM_LEAVES; ldex++) {
[ 464] 0x900000001fc13400:  dd 4b 00 00 ld	a7,0(a6)
[ 464] 0x900000001fc13404:  24 03 00 05 li	v1,5
[ 464] 0x900000001fc13408:  91 71 00 04 lbu	s1,4(a7)
[ 464] 0x900000001fc1340c:  00 c2 70 04 sllv	t2,v0,a2
[ 464] 0x900000001fc13410:  25 2b 00 01 addiu	a7,a5,1
  465: 	    for (bdex = 0; bdex < MC3_BANKS_PER_LEAF; bdex++, b++) {
[ 465] 0x900000001fc13414:  dd 59 00 00 ld	t9,0(a6)
[ 465] 0x900000001fc13418:  25 6b 00 01 addiu	a7,a7,1
[ 465] 0x900000001fc1341c:  25 6b 00 01 addiu	a7,a7,1
[ 465] 0x900000001fc13420:  93 2c 00 0a lbu	t0,10(t9)
[ 465] 0x900000001fc13424:  51 88 00 06 beql	t0,a4,0x900000001fc13440
[ 465] 0x900000001fc13428:  dd 59 00 08 ld	t9,8(a6)
[ 465] 0x900000001fc1342c:  93 2d 00 05 lbu	t1,5(t9)
[ 465] 0x900000001fc13430:  51 a0 00 03 beql	t1,zero,0x900000001fc13440
[ 465] 0x900000001fc13434:  dd 59 00 08 ld	t9,8(a6)
[ 465] 0x900000001fc13438:  00 ee 38 25 or	a3,a3,t2
[ 465] 0x900000001fc1343c:  dd 59 00 08 ld	t9,8(a6)
[ 465] 0x900000001fc13440:  65 4a 00 08 daddiu	a6,a6,8
[ 465] 0x900000001fc13444:  24 c6 00 02 addiu	a2,a2,2
[ 465] 0x900000001fc13448:  25 6b 00 01 addiu	a7,a7,1
[ 465] 0x900000001fc1344c:  93 2f 00 0a lbu	t3,10(t9)
[ 465] 0x900000001fc13450:  51 e8 00 07 beql	t3,a4,0x900000001fc13470
[ 465] 0x900000001fc13454:  dd 59 00 08 ld	t9,8(a6)
[ 465] 0x900000001fc13458:  93 38 00 05 lbu	t8,5(t9)
[ 465] 0x900000001fc1345c:  00 a2 c8 04 sllv	t9,v0,a1
[ 465] 0x900000001fc13460:  53 00 00 03 beql	t8,zero,0x900000001fc13470
[ 465] 0x900000001fc13464:  dd 59 00 08 ld	t9,8(a6)
[ 465] 0x900000001fc13468:  00 f9 38 25 or	a3,a3,t9
[ 465] 0x900000001fc1346c:  dd 59 00 08 ld	t9,8(a6)
[ 465] 0x900000001fc13470:  65 4a 00 08 daddiu	a6,a6,8
[ 465] 0x900000001fc13474:  24 a5 00 02 addiu	a1,a1,2
[ 465] 0x900000001fc13478:  01 60 48 25 move	a5,a7
[ 465] 0x900000001fc1347c:  93 21 00 0a lbu	at,10(t9)
[ 465] 0x900000001fc13480:  50 28 00 07 beql	at,a4,0x900000001fc134a0
[ 465] 0x900000001fc13484:  dd 59 00 08 ld	t9,8(a6)
[ 465] 0x900000001fc13488:  93 21 00 05 lbu	at,5(t9)
[ 465] 0x900000001fc1348c:  50 20 00 04 beql	at,zero,0x900000001fc134a0
[ 465] 0x900000001fc13490:  dd 59 00 08 ld	t9,8(a6)
[ 465] 0x900000001fc13494:  00 82 08 04 sllv	at,v0,a0
[ 465] 0x900000001fc13498:  00 e1 38 25 or	a3,a3,at
[ 465] 0x900000001fc1349c:  dd 59 00 08 ld	t9,8(a6)
[ 465] 0x900000001fc134a0:  65 4a 00 08 daddiu	a6,a6,8
[ 465] 0x900000001fc134a4:  65 4a 00 08 daddiu	a6,a6,8
[ 465] 0x900000001fc134a8:  93 21 00 0a lbu	at,10(t9)
[ 465] 0x900000001fc134ac:  50 28 00 07 beql	at,a4,0x900000001fc134cc
[ 465] 0x900000001fc134b0:  24 84 00 02 addiu	a0,a0,2
[ 465] 0x900000001fc134b4:  93 21 00 05 lbu	at,5(t9)
[ 465] 0x900000001fc134b8:  50 20 00 04 beql	at,zero,0x900000001fc134cc
[ 465] 0x900000001fc134bc:  24 84 00 02 addiu	a0,a0,2
[ 465] 0x900000001fc134c0:  00 62 08 04 sllv	at,v0,v1
[ 465] 0x900000001fc134c4:  00 e1 38 25 or	a3,a3,at
[ 465] 0x900000001fc134c8:  24 84 00 02 addiu	a0,a0,2
[ 464] 0x900000001fc134cc:  24 63 00 02 addiu	v1,v1,2
[ 464] 0x900000001fc134d0:  54 70 ff cf bnel	v1,s0,0x900000001fc13410
[ 464] 0x900000001fc134d4:  00 c2 70 04 sllv	t2,v0,a2
[ 464] 0x900000001fc134d8:  01 72 08 2a slt	at,a7,s2
[ 464] 0x900000001fc134dc:  00 11 1a c0 sll	v1,s1,11
[ 460] 0x900000001fc134e0:  00 00 30 25 move	a2,zero
[ 460] 0x900000001fc134e4:  00 73 18 2d daddu	v1,v1,s3
[ 460] 0x900000001fc134e8:  24 04 00 04 li	a0,4
[ 460] 0x900000001fc134ec:  00 40 28 25 move	a1,v0
[ 460] 0x900000001fc134f0:  24 10 00 09 li	s0,9
[ 460] 0x900000001fc134f4:  14 20 ff c1 bne	at,zero,0x900000001fc133fc
[ 460] 0x900000001fc134f8:  fc 67 00 00 sd	a3,0(v1)
[ 460] 0x900000001fc134fc:  df b1 00 18 ld	s1,24(sp)
[ 460] 0x900000001fc13500:  df b2 00 10 ld	s2,16(sp)
[ 460] 0x900000001fc13504:  df b0 00 20 ld	s0,32(sp)
[ 460] 0x900000001fc13508:  df b3 00 08 ld	s3,8(sp)
[ 460] 0x900000001fc1350c:  03 e0 00 08 jr	ra
[ 460] 0x900000001fc13510:  67 bd 00 30 daddiu	sp,sp,48
  466: 		if (bank[b]->bnk_size != MC3_NOBANK &&
  467: 		    			bank[b]->bnk_enable)
  468: 		    bank_enable |= MC3_BENB(ldex, bdex);
  469: 	    }
  470: 	}		
  471: 
  472: 	EV_SET_CONFIG(slot, MC3_BANKENB, bank_enable);
  473:     }
  474: }
  475: 
  476: 
  477: /*
  478:  * check_banks()
  479:  *	Checks all of the configured banks in an attempt to determine
  480:  *	whether the memory actually spans all the space it is supposed
  481:  *	to.  To do this, it examines the base bloc, interleave factor and
  482:  *	bank size and then strides through memory writing to major
  483:  *	addresses.  If an exception occurs, it catches it and deals
  484:  *	with it appropriately.
  485:  * Parameters:
  486:  *	bpos   -- Number of banks in array.
  487:  *	bank   -- the array of pointer to bank info structures.
  488:  *	action -- indicates whether we're writing or reading 
  489:  * Returns:
  490:  *	-1 if something fails horribly, 0 otherwise.
  491:  */
  492: 
  493: int
  494: check_banks(int num_banks, evbnkcfg_t *bank[], uint action)
  495: {
check_banks:
[ 495] 0x900000001fc13514:  3c 07 1f c2 lui	a3,0x1fc2
[ 495] 0x900000001fc13518:  67 bd fe d0 daddiu	sp,sp,-304
[ 495] 0x900000001fc1351c:  ff a5 00 10 sd	a1,16(sp)
  496:     uint	b;		/* Bank index */
  497:     uint 	i;		/* Interleave index */
  498:     uint	j;		/* Index for toggling between beginning and
  499: 				   end of an interleave */
  500:     uint	k;		/* Index for cruising through line */
  501:     uint	count = 1;	/* Counter value */
  502:     ulong	bsize;		/* Current banksize */
  503:     ulong	bloc;		/* Current bloc value */
  504:     jmp_buf	fault_buf;	/* Status buffer */
  505:     uint	*prev_fault;	/* Previous fault handler address */
  506:     uint	result;		/* Result from memory readback */
  507:     ulong	end_o_blk;	/* Last bloc of an interleave */
  508:     evreg_t	ertoip;		/* contents of ertoip register on buserr */
  509:     ulong	addr_bloc;	/* Bloc of address being tested */
  510:     ulong	addr_off;	/* Offset of address being tested */
  511:     ulong	addr_valid;	/* The addr_* numbers are valid */
  512: 
  513:     for (b = 0; b < num_banks; b++) {
[ 513] 0x900000001fc13520:  ff be 00 68 sd	s8,104(sp)
[ 513] 0x900000001fc13524:  00 c0 f0 25 move	s8,a2
[ 513] 0x900000001fc13528:  3c 06 90 00 lui	a2,0x9000
[ 513] 0x900000001fc1352c:  ff a0 00 18 sd	zero,24(sp)
[ 513] 0x900000001fc13530:  df a8 00 18 ld	a4,24(sp)
[ 513] 0x900000001fc13534:  24 01 00 80 li	at,128
[ 501] 0x900000001fc13538:  00 08 40 3c dsll32	a4,a4,0
[ 501] 0x900000001fc1353c:  ff b5 00 80 sd	s5,128(sp)
[ 501] 0x900000001fc13540:  24 15 00 01 li	s5,1
[ 501] 0x900000001fc13544:  00 08 47 7a dsrl	a4,a4,29
[ 501] 0x900000001fc13548:  ff a1 00 20 sd	at,32(sp)
[ 501] 0x900000001fc1354c:  ff b0 00 a8 sd	s0,168(sp)
[ 501] 0x900000001fc13550:  ff b1 00 a0 sd	s1,160(sp)
[ 501] 0x900000001fc13554:  ff b2 00 98 sd	s2,152(sp)
[ 501] 0x900000001fc13558:  ff b3 00 90 sd	s3,144(sp)
[ 501] 0x900000001fc1355c:  ff b4 00 88 sd	s4,136(sp)
[ 501] 0x900000001fc13560:  ff b6 00 78 sd	s6,120(sp)
[ 501] 0x900000001fc13564:  ff b7 00 70 sd	s7,112(sp)
[ 501] 0x900000001fc13568:  ff bf 00 b0 sd	ra,176(sp)
[ 501] 0x900000001fc1356c:  10 80 00 c4 beq	a0,zero,0x900000001fc13880
[ 501] 0x900000001fc13570:  ff a4 00 08 sd	a0,8(sp)
[ 501] 0x900000001fc13574:  60 c6 00 00 daddi	a2,a2,0
[ 501] 0x900000001fc13578:  60 e7 e8 68 daddi	a3,a3,-6040
[ 501] 0x900000001fc1357c:  00 06 30 3c dsll32	a2,a2,0
[ 501] 0x900000001fc13580:  00 c7 30 2c dadd	a2,a2,a3
[ 501] 0x900000001fc13584:  df a7 00 10 ld	a3,16(sp)
[ 501] 0x900000001fc13588:  00 e8 80 2d daddu	s0,a3,a4
[ 501] 0x900000001fc1358c:  ff a6 00 28 sd	a2,40(sp)
[ 501] 0x900000001fc13590:  24 0b 00 07 li	a7,7
[ 501] 0x900000001fc13594:  df ae 00 28 ld	t2,40(sp)
[ 501] 0x900000001fc13598:  67 a5 00 00 daddiu	a1,sp,0
  514: 	
  515: 	addr_valid = 0;	
  516: 	/* Skip uninteresting banks */
  517: 	if (bank[b]->bnk_count == 0 || bank[b]->bnk_size == MC3_NOBANK)
[ 517] 0x900000001fc1359c:  de 09 00 00 ld	a5,0(s0)
[ 517] 0x900000001fc135a0:  67 a4 00 c0 daddiu	a0,sp,192
[ 517] 0x900000001fc135a4:  dd ce 00 10 ld	t2,16(t2)
[ 517] 0x900000001fc135a8:  91 29 00 0b lbu	a5,11(a5)
[ 517] 0x900000001fc135ac:  51 20 00 ac beql	a5,zero,0x900000001fc13860
[ 517] 0x900000001fc135b0:  df b1 00 18 ld	s1,24(sp)
[ 515] 0x900000001fc135b4:  de 0a 00 00 ld	a6,0(s0)
[ 515] 0x900000001fc135b8:  91 4a 00 0a lbu	a6,10(a6)
[ 515] 0x900000001fc135bc:  51 4b 00 a8 beql	a6,a7,0x900000001fc13860
[ 515] 0x900000001fc135c0:  df b1 00 18 ld	s1,24(sp)
  518: 	    continue; 
  519: 
  520: 	/*
  521: 	 * Now we calculate the number of banks in this interleave
  522: 	 * and the size of each bank.
  523: 	 */
  524: 	bsize = MemSizes[bank[b]->bnk_size];
[ 524] 0x900000001fc135c4:  de 0d 00 00 ld	t1,0(s0)
[ 524] 0x900000001fc135c8:  91 ac 00 0a lbu	t0,10(t1)
  525: 	bloc = bank[b]->bnk_bloc;
[ 525] 0x900000001fc135cc:  8d ad 00 00 lw	t1,0(t1)
[ 525] 0x900000001fc135d0:  31 8c 00 ff andi	t0,t0,0xff
[ 525] 0x900000001fc135d4:  00 0d 68 3c dsll32	t1,t1,0
  526: 
  527: 	/* If an exception occurs, return to the following block */
  528: 	if (setfault(fault_buf, &prev_fault)) {
[ 528] 0x900000001fc135d8:  00 0c 60 f8 dsll	t0,t0,3
[ 528] 0x900000001fc135dc:  00 0d 68 3e dsrl32	t1,t1,0
[ 528] 0x900000001fc135e0:  01 8e 60 2d daddu	t0,t0,t2
[ 528] 0x900000001fc135e4:  ff ad 00 30 sd	t1,48(sp)
[ 528] 0x900000001fc135e8:  0f f0 18 7f jal		setfault
[ 528] 0x900000001fc135ec:  dd 91 00 00 ld	s1,0(t0)
[ 528] 0x900000001fc135f0:  ff b0 00 38 sd	s0,56(sp)
[ 528] 0x900000001fc135f4:  66 30 ff ff daddiu	s0,s1,-1
[ 528] 0x900000001fc135f8:  df b1 00 38 ld	s1,56(sp)
[ 528] 0x900000001fc135fc:  14 40 00 71 bne	v0,zero,0x900000001fc137c4
[ 528] 0x900000001fc13600:  24 0f 00 01 li	t3,1
  529: 	    restorefault(prev_fault);
  530: 	    loprintf("\n*** Bus error occurred while checking mem board in slot %d\n",
  531: 							bank[b]->bnk_slot);
  532: 	    if (ertoip = LD(EV_ERTOIP))
  533: 		xlate_ertoip(ertoip);
  534: 	    loprintf("    EPC %x CAUSE %x BADVADDR %x SCCADDR %x\n", 
  535: 		     _epc(0, 0),_cause(0, 0), _badvaddr(0, 0), LD(EV_ERADDR));
  536: 	    if (addr_valid) {
  537: 		loprintf("    Error in ");
  538: 		print_slot_bank(addr_bloc, addr_off);
  539: 		if (disable_slot_bank(addr_bloc, addr_off, bank, num_banks,
  540: 							EVDIAG_MC3TESTBUSERR))
  541: 		    return EVDIAG_MC3DOUBLEDIS;
  542: 	    }
  543: 	    sc_disp(EVDIAG_MC3TESTBUSERR);
  544: 	    return EVDIAG_MC3TESTBUSERR;
  545: 	}
  546: 
  547: 	/*
  548:  	 * We now write/read a count value into the first word of the first
  549: 	 * line of each of the memory interleaves.  When we check throug
  550: 	 * this code by reading back we'll detect any overlapping interleaves.
  551: 	 */
  552: 
  553: 	/* Calculate the last address of the last bloc of the interleave */ 
  554: 	end_o_blk = (bsize - 1) * (1 << bank[b]->bnk_if);
[ 554] 0x900000001fc13604:  de 31 00 00 ld	s1,0(s1)
[ 554] 0x900000001fc13608:  92 31 00 09 lbu	s1,9(s1)
[ 554] 0x900000001fc1360c:  02 2f 78 04 sllv	t3,t3,s1
[ 554] 0x900000001fc13610:  02 0f 00 1d dmultu	s0,t3
  555: 
  556: 	for (i = 0; i < (1 << bank[b]->bnk_if); i++) {
[ 556] 0x900000001fc13614:  ff a0 00 48 sd	zero,72(sp)
[ 556] 0x900000001fc13618:  00 00 80 12 mflo	s0
[ 556] 0x900000001fc1361c:  ff b0 00 40 sd	s0,64(sp)
[ 556] 0x900000001fc13620:  11 e0 00 64 beq	t3,zero,0x900000001fc137b4
[ 556] 0x900000001fc13624:  00 00 00 21 nada
  557: 
  558: 	    for (j = 0; j <= end_o_blk; j += end_o_blk) {
[ 558] 0x900000001fc13628:  ff a0 00 50 sd	zero,80(sp)
[ 558] 0x900000001fc1362c:  df b2 00 48 ld	s2,72(sp)
[ 558] 0x900000001fc13630:  df b4 00 50 ld	s4,80(sp)
[ 558] 0x900000001fc13634:  df b3 00 30 ld	s3,48(sp)
[ 558] 0x900000001fc13638:  10 00 00 01 b		0x900000001fc13640
[ 558] 0x900000001fc1363c:  00 12 b9 c0 sll	s7,s2,7
[ 558] 0x900000001fc13640:  02 74 98 2d daddu	s3,s3,s4
[ 558] 0x900000001fc13644:  00 13 b2 38 dsll	s6,s3,8
[ 558] 0x900000001fc13648:  ff b3 00 58 sd	s3,88(sp)
[ 558] 0x900000001fc1364c:  00 13 a0 00 sll	s4,s3,0
  559: 
  560: 		for (k = 0; k < 128; k += 4) {
[ 560] 0x900000001fc13650:  00 00 98 25 move	s3,zero
[ 560] 0x900000001fc13654:  02 77 c0 21 addu	t8,s3,s7
  561: 		    /* Read or write as desired */
  562: 		    addr_bloc = bloc + j;
  563: 		    addr_off = (i << 7) + k;
  564: 		    addr_valid = 1;
  565: 		    /* avoid touching locore addresses cached since we touch them uncached */
  566: 		    if (action == WRITE) {
[ 566] 0x900000001fc13658:  26 b0 00 01 addiu	s0,s5,1
[ 566] 0x900000001fc1365c:  00 18 c0 3c dsll32	t8,t8,0
[ 566] 0x900000001fc13660:  26 71 00 04 addiu	s1,s3,4
[ 566] 0x900000001fc13664:  00 18 90 3e dsrl32	s2,t8,0
[ 566] 0x900000001fc13668:  02 a0 10 25 move	v0,s5
[ 566] 0x900000001fc1366c:  02 56 f8 2d daddu	ra,s2,s6
[ 566] 0x900000001fc13670:  2f f9 40 00 sltiu	t9,ra,16384
[ 566] 0x900000001fc13674:  24 18 00 01 li	t8,1
[ 566] 0x900000001fc13678:  13 d8 00 2a beq	s8,t8,0x900000001fc13724
[ 566] 0x900000001fc1367c:  2f eb 40 00 sltiu	a7,ra,16384
  567: 			if ((addr_bloc << 8) + addr_off >= 0x4000)
  568: 				u64sw(addr_bloc, addr_off, count);
  569: 		    } else {
  570: 			if ((addr_bloc << 8) + addr_off >= 0x4000)
[ 570] 0x900000001fc13680:  51 60 00 04 beql	a7,zero,0x900000001fc13694
[ 570] 0x900000001fc13684:  00 12 28 00 sll	a1,s2,0
  571: 				result = u64lw(addr_bloc, addr_off);
  572: 			else
  573: 				result = count;
[ 573] 0x900000001fc13688:  10 00 00 04 b		0x900000001fc1369c
[ 573] 0x900000001fc1368c:  00 00 00 21 nada
[ 571] 0x900000001fc13690:  00 12 28 00 sll	a1,s2,0
[ 571] 0x900000001fc13694:  0f f0 0d b4 jal		u64lw
[ 571] 0x900000001fc13698:  02 80 20 25 move	a0,s4
  574: 
  575: 			if (result != count) {
[ 575] 0x900000001fc1369c:  56 a2 00 0a bnel	s5,v0,0x900000001fc136c8
[ 575] 0x900000001fc136a0:  24 11 00 2c li	s1,44
  576: 			    loprintf("\n*** MC3 readback error at address: 0x%x00 + 0x%x\n    ",
  577: 						addr_bloc, addr_off);
  578: 			    print_slot_bank(addr_bloc, addr_off);
  579: 			    if (disable_slot_bank(addr_bloc, addr_off, bank,
  580: 						num_banks,
  581: 						EVDIAG_BANK_FAILED))
  582: 				return EVDIAG_MC3DOUBLEDIS;
  583: 			    sc_disp(EVDIAG_BANK_FAILED); 
  584: 			    return EVDIAG_BANK_FAILED;
  585: 			}
  586: 			u64sw(addr_bloc, addr_off, 0);
[ 586] 0x900000001fc136a4:  00 12 28 00 sll	a1,s2,0
[ 586] 0x900000001fc136a8:  00 00 30 25 move	a2,zero
[ 586] 0x900000001fc136ac:  02 80 20 25 move	a0,s4
[ 586] 0x900000001fc136b0:  0f f0 0d c2 jal		u64sw
[ 586] 0x900000001fc136b4:  26 b0 00 01 addiu	s0,s5,1
[ 586] 0x900000001fc136b8:  26 71 00 04 addiu	s1,s3,4
[ 586] 0x900000001fc136bc:  10 00 00 20 b		0x900000001fc13740
[ 586] 0x900000001fc136c0:  02 20 98 25 move	s3,s1
[ 586] 0x900000001fc136c4:  24 11 00 2c li	s1,44
[ 576] 0x900000001fc136c8:  02 40 30 25 move	a2,s2
[ 576] 0x900000001fc136cc:  df b0 00 58 ld	s0,88(sp)
[ 576] 0x900000001fc136d0:  02 00 28 25 move	a1,s0
[ 576] 0x900000001fc136d4:  df a7 00 28 ld	a3,40(sp)
[ 576] 0x900000001fc136d8:  0f f0 2c e3 jal		loprintf
[ 576] 0x900000001fc136dc:  64 e4 00 c0 daddiu	a0,a3,192
[ 578] 0x900000001fc136e0:  02 40 28 25 move	a1,s2
[ 578] 0x900000001fc136e4:  0f f0 43 3f jal		print_slot_bank
[ 578] 0x900000001fc136e8:  02 00 20 25 move	a0,s0
[ 579] 0x900000001fc136ec:  24 08 00 2c li	a4,44
[ 579] 0x900000001fc136f0:  df a7 00 08 ld	a3,8(sp)
[ 579] 0x900000001fc136f4:  df a6 00 10 ld	a2,16(sp)
[ 579] 0x900000001fc136f8:  02 40 28 25 move	a1,s2
[ 579] 0x900000001fc136fc:  0f f0 42 66 jal		disable_slot_bank
[ 579] 0x900000001fc13700:  02 00 20 25 move	a0,s0
[ 579] 0x900000001fc13704:  24 10 00 31 li	s0,49
[ 579] 0x900000001fc13708:  54 40 00 5f bnel	v0,zero,0x900000001fc13888
[ 579] 0x900000001fc1370c:  df b1 00 a0 ld	s1,160(sp)
[ 583] 0x900000001fc13710:  0f f0 3f 12 jal		sc_disp
[ 583] 0x900000001fc13714:  02 20 20 25 move	a0,s1
[ 584] 0x900000001fc13718:  02 20 80 25 move	s0,s1
[ 584] 0x900000001fc1371c:  10 00 00 5a b		0x900000001fc13888
[ 584] 0x900000001fc13720:  df b1 00 a0 ld	s1,160(sp)
[ 567] 0x900000001fc13724:  57 20 00 06 bnel	t9,zero,0x900000001fc13740
[ 567] 0x900000001fc13728:  02 20 98 25 move	s3,s1
[ 568] 0x900000001fc1372c:  00 12 28 00 sll	a1,s2,0
[ 568] 0x900000001fc13730:  02 a0 30 25 move	a2,s5
[ 568] 0x900000001fc13734:  0f f0 0d c2 jal		u64sw
[ 568] 0x900000001fc13738:  02 80 20 25 move	a0,s4
[ 568] 0x900000001fc1373c:  02 20 98 25 move	s3,s1
  587: 		    }
  588: 		    addr_valid = 0;
  589: 		    count++;
[ 589] 0x900000001fc13740:  02 00 a8 25 move	s5,s0
[ 589] 0x900000001fc13744:  df b2 00 20 ld	s2,32(sp)
[ 560] 0x900000001fc13748:  56 32 ff c3 bnel	s1,s2,0x900000001fc13658
[ 560] 0x900000001fc1374c:  02 77 c0 21 addu	t8,s3,s7
[ 588] 0x900000001fc13750:  df b4 00 50 ld	s4,80(sp)
[ 588] 0x900000001fc13754:  df b3 00 40 ld	s3,64(sp)
[ 558] 0x900000001fc13758:  02 74 a0 2d daddu	s4,s3,s4
[ 558] 0x900000001fc1375c:  00 14 a0 00 sll	s4,s4,0
[ 558] 0x900000001fc13760:  00 14 a0 3c dsll32	s4,s4,0
[ 558] 0x900000001fc13764:  00 14 b0 3e dsrl32	s6,s4,0
[ 558] 0x900000001fc13768:  df b4 00 30 ld	s4,48(sp)
[ 558] 0x900000001fc1376c:  02 96 a0 2d daddu	s4,s4,s6
[ 558] 0x900000001fc13770:  02 76 98 2b sltu	s3,s3,s6
[ 558] 0x900000001fc13774:  ff b6 00 50 sd	s6,80(sp)
[ 558] 0x900000001fc13778:  00 14 b2 38 dsll	s6,s4,8
[ 558] 0x900000001fc1377c:  ff b4 00 58 sd	s4,88(sp)
[ 558] 0x900000001fc13780:  12 60 ff b3 beq	s3,zero,0x900000001fc13650
[ 558] 0x900000001fc13784:  00 14 a0 00 sll	s4,s4,0
[ 556] 0x900000001fc13788:  df b9 00 38 ld	t9,56(sp)
[ 556] 0x900000001fc1378c:  df 39 00 00 ld	t9,0(t9)
[ 556] 0x900000001fc13790:  df b7 00 48 ld	s7,72(sp)
[ 556] 0x900000001fc13794:  24 18 00 01 li	t8,1
[ 556] 0x900000001fc13798:  93 39 00 09 lbu	t9,9(t9)
[ 556] 0x900000001fc1379c:  26 f7 00 01 addiu	s7,s7,1
[ 556] 0x900000001fc137a0:  03 38 c0 04 sllv	t8,t8,t9
[ 556] 0x900000001fc137a4:  ff b7 00 48 sd	s7,72(sp)
[ 556] 0x900000001fc137a8:  02 f8 b8 2b sltu	s7,s7,t8
[ 556] 0x900000001fc137ac:  16 e0 ff 9e bne	s7,zero,0x900000001fc13628
[ 556] 0x900000001fc137b0:  00 00 00 21 nada
  590: 		} 	/* end for k loop */
  591: 	    } 	  /* end for j loop */
  592: 	}    /* end for i loop */
  593: 
  594: 	restorefault(prev_fault);
[ 594] 0x900000001fc137b4:  0f f0 18 86 jal		restorefault
[ 594] 0x900000001fc137b8:  df a4 00 00 ld	a0,0(sp)
[ 594] 0x900000001fc137bc:  10 00 00 28 b		0x900000001fc13860
[ 594] 0x900000001fc137c0:  df b1 00 18 ld	s1,24(sp)
[ 529] 0x900000001fc137c4:  0f f0 18 86 jal		restorefault
[ 529] 0x900000001fc137c8:  df a4 00 00 ld	a0,0(sp)
[ 530] 0x900000001fc137cc:  df bf 00 38 ld	ra,56(sp)
[ 530] 0x900000001fc137d0:  df be 00 28 ld	s8,40(sp)
[ 530] 0x900000001fc137d4:  df e1 00 00 ld	at,0(ra)
[ 530] 0x900000001fc137d8:  67 c4 00 40 daddiu	a0,s8,64
[ 530] 0x900000001fc137dc:  0f f0 2c e3 jal		loprintf
[ 530] 0x900000001fc137e0:  90 25 00 04 lbu	a1,4(at)
[ 532] 0x900000001fc137e4:  df de 00 f8 ld	s8,248(s8)
[ 532] 0x900000001fc137e8:  df de 00 00 ld	s8,0(s8)
[ 532] 0x900000001fc137ec:  13 c0 00 03 beq	s8,zero,0x900000001fc137fc
[ 532] 0x900000001fc137f0:  03 c0 80 25 move	s0,s8
[ 533] 0x900000001fc137f4:  0f f0 18 dd jal		xlate_ertoip
[ 533] 0x900000001fc137f8:  02 00 20 25 move	a0,s0
[ 534] 0x900000001fc137fc:  00 00 28 25 move	a1,zero
[ 534] 0x900000001fc13800:  0f f0 16 bc jal		_epc
[ 534] 0x900000001fc13804:  00 00 20 25 move	a0,zero
[ 534] 0x900000001fc13808:  00 40 80 25 move	s0,v0
[ 534] 0x900000001fc1380c:  00 00 28 25 move	a1,zero
[ 534] 0x900000001fc13810:  0f f0 16 b4 jal		_cause
[ 534] 0x900000001fc13814:  00 00 20 25 move	a0,zero
[ 534] 0x900000001fc13818:  ff a2 00 60 sd	v0,96(sp)
[ 534] 0x900000001fc1381c:  00 00 28 25 move	a1,zero
[ 534] 0x900000001fc13820:  0f f0 16 c4 jal		_badvaddr
[ 534] 0x900000001fc13824:  00 00 20 25 move	a0,zero
[ 534] 0x900000001fc13828:  df a8 00 28 ld	a4,40(sp)
[ 534] 0x900000001fc1382c:  00 40 38 25 move	a3,v0
[ 534] 0x900000001fc13830:  65 04 00 80 daddiu	a0,a4,128
[ 534] 0x900000001fc13834:  dd 08 01 00 ld	a4,256(a4)
[ 534] 0x900000001fc13838:  df a6 00 60 ld	a2,96(sp)
[ 534] 0x900000001fc1383c:  02 00 28 25 move	a1,s0
[ 534] 0x900000001fc13840:  0f f0 2c e3 jal		loprintf
[ 534] 0x900000001fc13844:  dd 08 00 00 ld	a4,0(a4)
[ 543] 0x900000001fc13848:  24 10 00 30 li	s0,48
[ 543] 0x900000001fc1384c:  0f f0 3f 12 jal		sc_disp
[ 543] 0x900000001fc13850:  24 04 00 30 li	a0,48
[ 544] 0x900000001fc13854:  10 00 00 0c b		0x900000001fc13888
[ 544] 0x900000001fc13858:  df b1 00 a0 ld	s1,160(sp)
[ 513] 0x900000001fc1385c:  df b1 00 18 ld	s1,24(sp)
[ 513] 0x900000001fc13860:  26 31 00 01 addiu	s1,s1,1
[ 513] 0x900000001fc13864:  00 11 90 3c dsll32	s2,s1,0
[ 513] 0x900000001fc13868:  00 12 a7 7a dsrl	s4,s2,29
[ 513] 0x900000001fc1386c:  df b3 00 10 ld	s3,16(sp)
[ 513] 0x900000001fc13870:  df b2 00 08 ld	s2,8(sp)
[ 513] 0x900000001fc13874:  ff b1 00 18 sd	s1,24(sp)
[ 513] 0x900000001fc13878:  16 32 ff 45 bne	s1,s2,0x900000001fc13590
[ 513] 0x900000001fc1387c:  02 74 80 2d daddu	s0,s3,s4
  595:     }
  596: 
  597:     return 0;
[ 597] 0x900000001fc13880:  00 00 80 25 move	s0,zero
[ 597] 0x900000001fc13884:  df b1 00 a0 ld	s1,160(sp)
[ 597] 0x900000001fc13888:  df b3 00 90 ld	s3,144(sp)
[ 597] 0x900000001fc1388c:  df b5 00 80 ld	s5,128(sp)
[ 597] 0x900000001fc13890:  df be 00 68 ld	s8,104(sp)
[ 597] 0x900000001fc13894:  df bf 00 b0 ld	ra,176(sp)
[ 597] 0x900000001fc13898:  02 00 10 25 move	v0,s0
[ 597] 0x900000001fc1389c:  df b6 00 78 ld	s6,120(sp)
[ 597] 0x900000001fc138a0:  df b4 00 88 ld	s4,136(sp)
[ 597] 0x900000001fc138a4:  df b2 00 98 ld	s2,152(sp)
[ 597] 0x900000001fc138a8:  df b0 00 a8 ld	s0,168(sp)
[ 597] 0x900000001fc138ac:  df b7 00 70 ld	s7,112(sp)
[ 597] 0x900000001fc138b0:  03 e0 00 08 jr	ra
[ 597] 0x900000001fc138b4:  67 bd 01 30 daddiu	sp,sp,304
  598: }
  599: 
  600: /*
  601:  * mc3_config()
  602:  * 	Top-level memory configuration function.  Given a 
  603:  * 	a base address (in terms of a page frame number), this 
  604:  *	routine will configure all memory boards in the system.
  605:  *
  606:  * Parameters:
  607:  *	cfginfo  -- Initialized Everest config info structure.
  608:  *	no_intlv -- If set, an interleave factor of 1 (no interleaving)
  609:  *		    will be used.  Useful for working around bugs.
  610:  * Returns:
  611:  *	Zero on success, EVDIAG_BIST_FAILED if the BIST fails on any bank,
  612:  *			 EVDIAG_NO_MEM if we cannot configure any memory.
  613:  */
  614: uint
  615: mc3_config(evcfginfo_t *cfginfo)
  616: {
mc3_config:
[ 616] 0x900000001fc138b8:  67 bd fd 30 daddiu	sp,sp,-720
[ 616] 0x900000001fc138bc:  00 80 08 25 move	at,a0
  617: #if SABLE
  618:     /* there's only 8mb of mem in sable. this code will not work. */
  619:     cfginfo->ecfg_memsize = 8 * 1024 * 1024;
  620:     return 0;
  621: #else
  622:     int		slot;		/* The slot index */
  623:     int		leaf;		/* Leaf index */
  624:     int		bank;		/* Bank index */
  625:     int		bpos = 0;	/* position of currently initialized bank */
  626:     int		type;		/* Board type check */
  627:     evbnkcfg_t	*banks[EV_MAX_MC3S * MC3_NUM_BANKS];
  628:     int		retval = 0;	/* Return value: nonzero == error */
  629:     int		c;		/* Character read from bist request */
  630:     int		marev;		/* Current board  MA chip rev level */
  631:     int		min_marev = 999;/* Minimum MA chip rev level */
  632:     uint	size = 0;	/* Total memsize (in blocs) */
  633:  
  634:     /*
  635:      * Scan Everest bus looking for MC3 cards. 
  636:      * Initialize them with base values when found and
  637:      * add their banks to the appropriate lists.
  638:      */
  639: 
  640:     for (slot = 0; slot < EV_MAX_SLOTS; slot++) {
[ 640] 0x900000001fc138c0:  3c 02 90 00 lui	v0,0x9000
[ 640] 0x900000001fc138c4:  3c 03 1f c2 lui	v1,0x1fc2
[ 625] 0x900000001fc138c8:  60 42 00 00 daddi	v0,v0,0
[ 625] 0x900000001fc138cc:  60 63 e8 68 daddi	v1,v1,-6040
[ 625] 0x900000001fc138d0:  ff a0 00 48 sd	zero,72(sp)
[ 628] 0x900000001fc138d4:  00 02 10 3c dsll32	v0,v0,0
[ 628] 0x900000001fc138d8:  ff a0 00 50 sd	zero,80(sp)
[ 628] 0x900000001fc138dc:  24 04 03 e7 li	a0,999
[ 628] 0x900000001fc138e0:  ff a4 00 58 sd	a0,88(sp)
[ 628] 0x900000001fc138e4:  00 43 10 2c dadd	v0,v0,v1
[ 628] 0x900000001fc138e8:  ff a1 00 40 sd	at,64(sp)
[ 628] 0x900000001fc138ec:  64 24 06 c0 daddiu	a0,at,1728
[ 632] 0x900000001fc138f0:  ff b2 00 a8 sd	s2,168(sp)
[ 632] 0x900000001fc138f4:  00 00 90 25 move	s2,zero
[ 632] 0x900000001fc138f8:  ff a4 00 68 sd	a0,104(sp)
[ 632] 0x900000001fc138fc:  ff b6 00 88 sd	s6,136(sp)
[ 632] 0x900000001fc13900:  dc 56 00 38 ld	s6,56(v0)
[ 640] 0x900000001fc13904:  ff b3 00 a0 sd	s3,160(sp)
[ 640] 0x900000001fc13908:  00 00 98 25 move	s3,zero
[ 640] 0x900000001fc1390c:  ff b7 00 80 sd	s7,128(sp)
[ 640] 0x900000001fc13910:  24 17 00 31 li	s7,49
[ 640] 0x900000001fc13914:  ff a2 00 60 sd	v0,96(sp)
[ 640] 0x900000001fc13918:  ff be 00 78 sd	s8,120(sp)
[ 640] 0x900000001fc1391c:  dc 5e 00 10 ld	s8,16(v0)
[ 640] 0x900000001fc13920:  ff b0 00 b8 sd	s0,184(sp)
[ 640] 0x900000001fc13924:  ff b1 00 b0 sd	s1,176(sp)
[ 640] 0x900000001fc13928:  ff b4 00 98 sd	s4,152(sp)
[ 640] 0x900000001fc1392c:  ff b5 00 90 sd	s5,144(sp)
[ 640] 0x900000001fc13930:  ff bf 00 c0 sd	ra,192(sp)
[ 640] 0x900000001fc13934:  24 07 00 02 li	a3,2
[ 640] 0x900000001fc13938:  00 13 8a c0 sll	s1,s3,11
[ 640] 0x900000001fc1393c:  df a6 00 60 ld	a2,96(sp)
  641: 	if (cfginfo->ecfg_board[slot].eb_type == EVTYPE_MC3) {
[ 641] 0x900000001fc13940:  90 25 00 64 lbu	a1,100(at)
[ 641] 0x900000001fc13944:  54 b7 00 36 bnel	a1,s7,0x900000001fc13a20
[ 641] 0x900000001fc13948:  26 73 00 01 addiu	s3,s3,1
  642: 
  643: 	    /* Make sure this really is a memory board */
  644: 	    type = (int)EV_GET_CONFIG(slot, MC3_TYPE);
[ 644] 0x900000001fc1394c:  dc c6 02 d8 ld	a2,728(a2)
[ 644] 0x900000001fc13950:  02 26 30 2d daddu	a2,s1,a2
[ 644] 0x900000001fc13954:  dc c6 00 00 ld	a2,0(a2)
  645: 	    if (type != MC3_TYPE_VALUE)
[ 645] 0x900000001fc13958:  00 06 30 00 sll	a2,a2,0
[ 645] 0x900000001fc1395c:  54 c7 00 30 bnel	a2,a3,0x900000001fc13a20
[ 645] 0x900000001fc13960:  26 73 00 01 addiu	s3,s3,1
  646: 		continue;
  647: 
  648: 	    marev = get_marev(slot);
[ 648] 0x900000001fc13964:  ff a1 00 70 sd	at,112(sp)
[ 648] 0x900000001fc13968:  0f f0 45 f3 jal		get_marev
[ 648] 0x900000001fc1396c:  02 60 20 25 move	a0,s3
  649: 
  650: 	    /* Set MC3 board rev to MA chip rev. */
  651: 	    cfginfo->ecfg_board[slot].eb_rev = marev;
  652: 
  653: 	    if (marev < min_marev) {
  654: 		min_marev = marev;
[ 654] 0x900000001fc13970:  df a8 00 58 ld	a4,88(sp)
[ 654] 0x900000001fc13974:  df b4 00 70 ld	s4,112(sp)
[ 654] 0x900000001fc13978:  00 48 48 2a slt	a5,v0,a4
  655: 	    }
  656: 	    EV_SET_CONFIG(slot, MC3_ACCESS, 0x2 | (!getendian()) );
[ 656] 0x900000001fc1397c:  a2 82 00 65 sb	v0,101(s4)
[ 656] 0x900000001fc13980:  00 49 40 0b movn	a4,v0,a5
[ 656] 0x900000001fc13984:  00 00 00 21 nada
[ 656] 0x900000001fc13988:  00 00 00 21 nada
[ 656] 0x900000001fc1398c:  00 00 00 21 nada
[ 656] 0x900000001fc13990:  0f f0 0d d0 jal		getendian
[ 656] 0x900000001fc13994:  ff a8 00 58 sd	a4,88(sp)
[ 656] 0x900000001fc13998:  df a9 00 60 ld	a5,96(sp)
[ 656] 0x900000001fc1399c:  dd 2b 02 e0 ld	a7,736(a5)
[ 653] 0x900000001fc139a0:  df b0 00 48 ld	s0,72(sp)
[ 653] 0x900000001fc139a4:  2c 4a 00 01 sltiu	a6,v0,1
[ 653] 0x900000001fc139a8:  02 2b 60 2d daddu	t0,s1,a7
[ 653] 0x900000001fc139ac:  00 10 80 f8 dsll	s0,s0,3
[ 653] 0x900000001fc139b0:  35 4a 00 02 ori	a6,a6,0x2
[ 653] 0x900000001fc139b4:  03 b0 80 2d daddu	s0,sp,s0
  657: 	    EV_SET_CONFIG(slot, MC3_MEMERRINT, MC3ERR_VECTOR);
  658: 	    EV_SET_CONFIG(slot, MC3_EBUSERRINT, MC3ERR_VECTOR);
  659: 	    EV_SET_CONFIG(slot, MC3_BANKENB, 0x0);
  660: 	    for (leaf = 0; leaf < MC3_NUM_LEAVES; leaf++) {
[ 660] 0x900000001fc139b8:  02 80 40 25 move	a4,s4
[ 660] 0x900000001fc139bc:  fd 8a 00 00 sd	a6,0(t0)
[ 657] 0x900000001fc139c0:  66 87 00 0c daddiu	a3,s4,12
[ 657] 0x900000001fc139c4:  24 06 00 14 li	a2,20
[ 657] 0x900000001fc139c8:  dd 2a 02 e8 ld	a6,744(a5)
[ 657] 0x900000001fc139cc:  66 85 00 18 daddiu	a1,s4,24
[ 657] 0x900000001fc139d0:  02 2a 60 2d daddu	t0,s1,a6
[ 657] 0x900000001fc139d4:  24 03 00 18 li	v1,24
[ 657] 0x900000001fc139d8:  24 0a 02 40 li	a6,576
[ 657] 0x900000001fc139dc:  66 94 00 24 daddiu	s4,s4,36
[ 657] 0x900000001fc139e0:  24 15 00 1c li	s5,28
[ 657] 0x900000001fc139e4:  fd 8a 00 00 sd	a6,0(t0)
[ 658] 0x900000001fc139e8:  24 17 00 10 li	s7,16
[ 658] 0x900000001fc139ec:  dd 29 02 f0 ld	a5,752(a5)
[ 658] 0x900000001fc139f0:  df ad 00 58 ld	t1,88(sp)
[ 658] 0x900000001fc139f4:  00 17 58 c0 sll	a7,s7,3
[ 658] 0x900000001fc139f8:  02 29 60 2d daddu	t0,s1,a5
[ 658] 0x900000001fc139fc:  ff ad 00 58 sd	t1,88(sp)
[ 659] 0x900000001fc13a00:  02 2b 58 2d daddu	a7,s1,a7
[ 659] 0x900000001fc13a04:  02 36 48 2d daddu	a5,s1,s6
[ 659] 0x900000001fc13a08:  01 76 58 2d daddu	a7,a7,s6
[ 659] 0x900000001fc13a0c:  fd 8a 00 00 sd	a6,0(t0)
[ 660] 0x900000001fc13a10:  fd 20 00 00 sd	zero,0(a5)
[ 660] 0x900000001fc13a14:  10 00 01 3c b		0x900000001fc13f08
[ 660] 0x900000001fc13a18:  24 1f 00 9c li	ra,156
[ 660] 0x900000001fc13a1c:  26 73 00 01 addiu	s3,s3,1
[ 640] 0x900000001fc13a20:  64 21 00 6c daddiu	at,at,108
[ 640] 0x900000001fc13a24:  df b5 00 68 ld	s5,104(sp)
[ 640] 0x900000001fc13a28:  54 35 ff c3 bnel	at,s5,0x900000001fc13938
[ 640] 0x900000001fc13a2c:  24 07 00 02 li	a3,2
[ 640] 0x900000001fc13a30:  67 b4 00 d0 daddiu	s4,sp,208
[ 640] 0x900000001fc13a34:  df be 00 48 ld	s8,72(sp)
[ 640] 0x900000001fc13a38:  24 02 00 29 li	v0,41
  661: 		for (bank = 0; bank < MC3_BANKS_PER_LEAF; bank++) {
  662: 		    DPRINTF(("  Configuring leaf %d, bank %d...", 
  663: 			     leaf, bank));
  664: 		    
  665: 		    banks[bpos] = 
  666: 			&(cfginfo->ecfg_board[slot].eb_banks[4*leaf + bank]);
  667: 		    banks[bpos]->bnk_size = (int)
  668: 			EV_GET_CONFIG(slot, MC3_BANK(leaf, bank,BANK_SIZE));
  669: 		    banks[bpos]->bnk_slot = slot;
  670: 		    DPRINTF((" Addr: %x Size: %d bpos: %d\n", 
  671: 			     banks[bpos], banks[bpos]->bnk_size, bpos));
  672: 
  673: 		    if (banks[bpos]->bnk_enable == 0) 
  674: 			DPRINTF(("  Disabling bank.\n"));
  675: 		    else 
  676: 			size += MemSizes[banks[bpos]->bnk_size];
  677: 			
  678: 		    bpos++;
  679: 		}
  680: 	    } 		/* end for leaf */
  681: 	} 	/* end if */
  682:     } 	/* end for */
  683: 
  684:     if (! bpos) {
[ 684] 0x900000001fc13a3c:  df b6 00 48 ld	s6,72(sp)
[ 684] 0x900000001fc13a40:  df a8 00 48 ld	a4,72(sp)
[ 684] 0x900000001fc13a44:  12 c0 01 24 beq	s6,zero,0x900000001fc13ed8
[ 684] 0x900000001fc13a48:  df b9 00 48 ld	t9,72(sp)
  685: 	DPRINTF(("\n*** CONFIGURATION FAILED: No memory banks were found.\n"));
  686: 	return EVDIAG_NO_MEM;
  687:     }
  688: 
  689:     /* 
  690:      * If we find that we don't have enough memory to load the IO4 PROM
  691:      * but have been disabled.  The rationale here is that if a user has
  692:      * mistakenly disabled too much memory the machine will still be able
  693:      * to come up.
  694:      */
  695:     if (size < 0x20000) {
[ 695] 0x900000001fc13a4c:  00 00 a8 25 move	s5,zero
[ 695] 0x900000001fc13a50:  3c 18 00 02 lui	t8,0x2
[ 695] 0x900000001fc13a54:  00 00 98 25 move	s3,zero
[ 695] 0x900000001fc13a58:  02 58 c0 2b sltu	t8,s2,t8
[ 695] 0x900000001fc13a5c:  13 00 00 7e beq	t8,zero,0x900000001fc13c58
[ 695] 0x900000001fc13a60:  33 31 00 01 andi	s1,t9,0x1
  696: 	int reenabled = 0;
  697: 
  698: 	for (bank = 0; bank < bpos; bank++) {
[ 698] 0x900000001fc13a64:  5b c0 00 78 blezl	s8,0x900000001fc13c48
[ 698] 0x900000001fc13a68:  df ac 00 60 ld	t0,96(sp)
[ 696] 0x900000001fc13a6c:  52 20 00 1a beql	s1,zero,0x900000001fc13ad8
[ 696] 0x900000001fc13a70:  df ab 00 48 ld	a7,72(sp)
[ 696] 0x900000001fc13a74:  00 11 f8 3c dsll32	ra,s1,0
[ 696] 0x900000001fc13a78:  24 02 00 07 li	v0,7
[ 696] 0x900000001fc13a7c:  24 03 00 01 li	v1,1
[ 696] 0x900000001fc13a80:  24 01 00 34 li	at,52
[ 696] 0x900000001fc13a84:  00 1f ff 7a dsrl	ra,ra,29
[ 696] 0x900000001fc13a88:  03 a0 80 25 move	s0,sp
[ 696] 0x900000001fc13a8c:  03 bf 90 2d daddu	s2,sp,ra
[ 696] 0x900000001fc13a90:  26 73 00 01 addiu	s3,s3,1
  699: 	    if ((banks[bank]->bnk_size != MC3_NOBANK) && 
[ 699] 0x900000001fc13a94:  de 04 00 d0 ld	a0,208(s0)
[ 699] 0x900000001fc13a98:  90 84 00 0a lbu	a0,10(a0)
[ 699] 0x900000001fc13a9c:  50 82 00 0b beql	a0,v0,0x900000001fc13acc
[ 699] 0x900000001fc13aa0:  66 10 00 08 daddiu	s0,s0,8
[ 699] 0x900000001fc13aa4:  de 05 00 d0 ld	a1,208(s0)
[ 699] 0x900000001fc13aa8:  90 a5 00 05 lbu	a1,5(a1)
[ 699] 0x900000001fc13aac:  54 a0 00 07 bnel	a1,zero,0x900000001fc13acc
[ 699] 0x900000001fc13ab0:  66 10 00 08 daddiu	s0,s0,8
  700: 					       !(banks[bank]->bnk_enable)) {
  701: 		reenabled = 1;
  702: 		banks[bank]->bnk_enable = 1;
[ 702] 0x900000001fc13ab4:  de 06 00 d0 ld	a2,208(s0)
[ 702] 0x900000001fc13ab8:  a0 c3 00 05 sb	v1,5(a2)
  703: 		banks[bank]->bnk_diagval = EVDIAG_MEMREENABLED;
[ 703] 0x900000001fc13abc:  de 06 00 d0 ld	a2,208(s0)
[ 701] 0x900000001fc13ac0:  24 15 00 01 li	s5,1
[ 701] 0x900000001fc13ac4:  a0 c1 00 07 sb	at,7(a2)
[ 701] 0x900000001fc13ac8:  66 10 00 08 daddiu	s0,s0,8
[ 698] 0x900000001fc13acc:  56 12 ff f1 bnel	s0,s2,0x900000001fc13a94
[ 698] 0x900000001fc13ad0:  26 73 00 01 addiu	s3,s3,1
[ 698] 0x900000001fc13ad4:  df ab 00 48 ld	a7,72(sp)
[ 698] 0x900000001fc13ad8:  00 13 48 f8 dsll	a5,s3,3
[ 698] 0x900000001fc13adc:  26 67 00 01 addiu	a3,s3,1
[ 698] 0x900000001fc13ae0:  24 02 00 07 li	v0,7
[ 698] 0x900000001fc13ae4:  00 e8 38 2a slt	a3,a3,a4
[ 698] 0x900000001fc13ae8:  50 e0 00 57 beql	a3,zero,0x900000001fc13c48
[ 698] 0x900000001fc13aec:  df ac 00 60 ld	t0,96(sp)
[ 698] 0x900000001fc13af0:  24 03 00 01 li	v1,1
[ 698] 0x900000001fc13af4:  00 0b 58 42 srl	a7,a7,1
[ 698] 0x900000001fc13af8:  24 01 00 34 li	at,52
[ 698] 0x900000001fc13afc:  00 0b 58 3c dsll32	a7,a7,0
[ 698] 0x900000001fc13b00:  03 a9 48 2d daddu	a5,sp,a5
[ 698] 0x900000001fc13b04:  00 0b 5f 3a dsrl	a7,a7,28
[ 698] 0x900000001fc13b08:  02 a0 50 25 move	a6,s5
[ 698] 0x900000001fc13b0c:  01 2b 20 2d daddu	a0,a5,a7
[ 698] 0x900000001fc13b10:  dd 2b 00 d0 ld	a7,208(a5)
[ 698] 0x900000001fc13b14:  91 65 00 0a lbu	a1,10(a7)
[ 698] 0x900000001fc13b18:  00 a2 28 26 xor	a1,a1,v0
[ 698] 0x900000001fc13b1c:  00 05 28 2b sltu	a1,zero,a1
[ 698] 0x900000001fc13b20:  67 a6 00 13 daddiu	a2,sp,19
[ 698] 0x900000001fc13b24:  01 65 30 0b movn	a2,a7,a1
[ 698] 0x900000001fc13b28:  00 00 00 21 nada
[ 698] 0x900000001fc13b2c:  00 00 00 21 nada
[ 698] 0x900000001fc13b30:  00 00 00 21 nada
[ 698] 0x900000001fc13b34:  90 c6 00 05 lbu	a2,5(a2)
[ 698] 0x900000001fc13b38:  00 06 30 2b sltu	a2,zero,a2
[ 698] 0x900000001fc13b3c:  67 a7 00 33 daddiu	a3,sp,51
[ 698] 0x900000001fc13b40:  00 c5 28 2a slt	a1,a2,a1
[ 698] 0x900000001fc13b44:  67 a8 00 18 daddiu	a4,sp,24
[ 698] 0x900000001fc13b48:  01 65 38 0b movn	a3,a7,a1
[ 698] 0x900000001fc13b4c:  00 00 00 21 nada
[ 698] 0x900000001fc13b50:  00 00 00 21 nada
[ 698] 0x900000001fc13b54:  00 00 00 21 nada
[ 698] 0x900000001fc13b58:  65 26 00 d0 daddiu	a2,a5,208
[ 698] 0x900000001fc13b5c:  00 c5 40 0b movn	a4,a2,a1
[ 698] 0x900000001fc13b60:  00 00 00 21 nada
[ 698] 0x900000001fc13b64:  00 00 00 21 nada
[ 698] 0x900000001fc13b68:  00 00 00 21 nada
[ 698] 0x900000001fc13b6c:  a0 e3 00 05 sb	v1,5(a3)
[ 698] 0x900000001fc13b70:  67 a7 00 31 daddiu	a3,sp,49
[ 698] 0x900000001fc13b74:  dd 06 00 00 ld	a2,0(a4)
[ 698] 0x900000001fc13b78:  00 c5 38 0b movn	a3,a2,a1
[ 698] 0x900000001fc13b7c:  00 00 00 21 nada
[ 698] 0x900000001fc13b80:  00 00 00 21 nada
[ 698] 0x900000001fc13b84:  00 00 00 21 nada
[ 698] 0x900000001fc13b88:  a0 e1 00 07 sb	at,7(a3)
[ 698] 0x900000001fc13b8c:  dd 26 00 d8 ld	a2,216(a5)
[ 698] 0x900000001fc13b90:  90 c7 00 0a lbu	a3,10(a2)
[ 698] 0x900000001fc13b94:  00 e2 38 26 xor	a3,a3,v0
[ 698] 0x900000001fc13b98:  00 07 38 2b sltu	a3,zero,a3
[ 698] 0x900000001fc13b9c:  67 a8 00 13 daddiu	a4,sp,19
[ 698] 0x900000001fc13ba0:  00 c7 40 0b movn	a4,a2,a3
[ 698] 0x900000001fc13ba4:  00 00 00 21 nada
[ 698] 0x900000001fc13ba8:  00 00 00 21 nada
[ 698] 0x900000001fc13bac:  00 00 00 21 nada
[ 698] 0x900000001fc13bb0:  91 08 00 05 lbu	a4,5(a4)
[ 698] 0x900000001fc13bb4:  00 08 40 2b sltu	a4,zero,a4
[ 698] 0x900000001fc13bb8:  67 ab 00 18 daddiu	a7,sp,24
[ 698] 0x900000001fc13bbc:  01 07 38 2a slt	a3,a4,a3
[ 698] 0x900000001fc13bc0:  67 a8 00 33 daddiu	a4,sp,51
[ 698] 0x900000001fc13bc4:  00 c7 40 0b movn	a4,a2,a3
[ 698] 0x900000001fc13bc8:  00 00 00 21 nada
[ 698] 0x900000001fc13bcc:  00 00 00 21 nada
[ 698] 0x900000001fc13bd0:  00 00 00 21 nada
[ 698] 0x900000001fc13bd4:  65 26 00 d8 daddiu	a2,a5,216
[ 698] 0x900000001fc13bd8:  00 c7 58 0b movn	a7,a2,a3
[ 698] 0x900000001fc13bdc:  00 00 00 21 nada
[ 698] 0x900000001fc13be0:  00 00 00 21 nada
[ 698] 0x900000001fc13be4:  00 00 00 21 nada
[ 698] 0x900000001fc13be8:  a1 03 00 05 sb	v1,5(a4)
[ 698] 0x900000001fc13bec:  67 ac 00 31 daddiu	t0,sp,49
[ 698] 0x900000001fc13bf0:  65 29 00 10 daddiu	a5,a5,16
[ 698] 0x900000001fc13bf4:  dd 68 00 00 ld	a4,0(a7)
[ 698] 0x900000001fc13bf8:  24 06 00 01 li	a2,1
[ 698] 0x900000001fc13bfc:  01 07 60 0b movn	t0,a4,a3
[ 698] 0x900000001fc13c00:  00 00 00 21 nada
[ 698] 0x900000001fc13c04:  00 00 00 21 nada
[ 698] 0x900000001fc13c08:  00 00 00 21 nada
[ 698] 0x900000001fc13c0c:  00 c5 50 0b movn	a6,a2,a1
[ 698] 0x900000001fc13c10:  00 00 00 21 nada
[ 698] 0x900000001fc13c14:  00 00 00 21 nada
[ 698] 0x900000001fc13c18:  00 00 00 21 nada
[ 698] 0x900000001fc13c1c:  24 05 00 01 li	a1,1
[ 698] 0x900000001fc13c20:  a1 81 00 07 sb	at,7(t0)
[ 698] 0x900000001fc13c24:  00 a7 50 0b movn	a6,a1,a3
[ 698] 0x900000001fc13c28:  00 00 00 21 nada
[ 698] 0x900000001fc13c2c:  00 00 00 21 nada
[ 698] 0x900000001fc13c30:  00 00 00 21 nada
[ 698] 0x900000001fc13c34:  15 24 ff b6 bne	a5,a0,0x900000001fc13b10
[ 698] 0x900000001fc13c38:  00 00 00 21 nada
[ 698] 0x900000001fc13c3c:  01 40 a8 25 move	s5,a6
[ 698] 0x900000001fc13c40:  24 17 00 31 li	s7,49
[ 698] 0x900000001fc13c44:  df ac 00 60 ld	t0,96(sp)
  704: 	    }
  705: 	}
  706: 
  707:         if (reenabled)
[ 707] 0x900000001fc13c48:  12 a0 00 03 beq	s5,zero,0x900000001fc13c58
[ 707] 0x900000001fc13c4c:  00 00 00 21 nada
  708: 	    loprintf("\n*** Not enough memory was enabled.  Enabling all banks.");
[ 708] 0x900000001fc13c50:  0f f0 2c e3 jal		loprintf
[ 708] 0x900000001fc13c54:  65 84 01 08 daddiu	a0,t0,264
  709:     }
  710: 
  711:     /* Determine which configuration algorithm to employ */
  712:     if (nvram_okay() && (get_nvreg(NVOFF_FASTMEM) == '1')) {
[ 712] 0x900000001fc13c58:  0f f0 30 ed jal		nvram_okay
[ 712] 0x900000001fc13c5c:  00 00 00 21 nada
[ 712] 0x900000001fc13c60:  50 40 00 07 beql	v0,zero,0x900000001fc13c80
[ 712] 0x900000001fc13c64:  df ae 00 60 ld	t2,96(sp)
[ 712] 0x900000001fc13c68:  0f f0 2f fa jal		get_nvreg
[ 712] 0x900000001fc13c6c:  24 04 03 15 li	a0,789
[ 712] 0x900000001fc13c70:  24 0d 00 31 li	t1,49
[ 712] 0x900000001fc13c74:  10 4d 00 0d beq	v0,t1,0x900000001fc13cac
[ 712] 0x900000001fc13c78:  df b0 00 60 ld	s0,96(sp)
  713: 	loprintf("\n    Using 'fastmem' interleave algorithm.\n");
  714: 	type = INTLV_OPTIMAL;
  715:     } else {
  716: 	loprintf("\n    Using standard interleave algorithm.\n");
[ 716] 0x900000001fc13c7c:  df ae 00 60 ld	t2,96(sp)
[ 716] 0x900000001fc13c80:  0f f0 2c e3 jal		loprintf
[ 716] 0x900000001fc13c84:  65 c4 01 78 daddiu	a0,t2,376
  717: 	type = INTLV_STABLE;
[ 717] 0x900000001fc13c88:  24 16 00 01 li	s6,1
[ 717] 0x900000001fc13c8c:  df ae 00 40 ld	t2,64(sp)
[ 717] 0x900000001fc13c90:  24 12 00 79 li	s2,121
[ 717] 0x900000001fc13c94:  24 11 00 79 li	s1,121
[ 717] 0x900000001fc13c98:  df af 00 58 ld	t3,88(sp)
[ 717] 0x900000001fc13c9c:  29 f0 00 10 slti	s0,t3,16
[ 717] 0x900000001fc13ca0:  8d ce 06 d8 lw	t2,1752(t2)
[ 717] 0x900000001fc13ca4:  10 00 00 0b b		0x900000001fc13cd4
[ 717] 0x900000001fc13ca8:  31 c1 00 04 andi	at,t2,0x4
[ 713] 0x900000001fc13cac:  0f f0 2c e3 jal		loprintf
[ 713] 0x900000001fc13cb0:  66 04 01 48 daddiu	a0,s0,328
[ 714] 0x900000001fc13cb4:  df b3 00 40 ld	s3,64(sp)
[ 714] 0x900000001fc13cb8:  24 16 00 02 li	s6,2
[ 714] 0x900000001fc13cbc:  24 12 00 79 li	s2,121
[ 714] 0x900000001fc13cc0:  24 11 00 79 li	s1,121
[ 714] 0x900000001fc13cc4:  df b0 00 58 ld	s0,88(sp)
[ 714] 0x900000001fc13cc8:  8e 73 06 d8 lw	s3,1752(s3)
[ 714] 0x900000001fc13ccc:  2a 10 00 10 slti	s0,s0,16
[ 714] 0x900000001fc13cd0:  32 61 00 04 andi	at,s3,0x4
[ 714] 0x900000001fc13cd4:  df b5 00 60 ld	s5,96(sp)
  718:     }
  719: 
  720:     if (!(cfginfo->ecfg_debugsw & VDS_NOMEMCLEAR)) {
[ 720] 0x900000001fc13cd8:  54 20 00 24 bnel	at,zero,0x900000001fc13d6c
[ 720] 0x900000001fc13cdc:  df a1 00 60 ld	at,96(sp)
  721: 	/*
  722: 	* Run the BIST on demand. (only if rev. 0 MA chips are present
  723: 	*/
  724: 	if (min_marev < 16) {
[ 724] 0x900000001fc13ce0:  16 00 00 03 bne	s0,zero,0x900000001fc13cf0
[ 724] 0x900000001fc13ce4:  00 00 00 21 nada
  725: 	    loprintf("\n\nBIST? (y/n)  ");
  726: 	    pod_flush(); 
  727: 	    c = pod_getc();
  728: 	    pod_putc(c);
  729: 	} else {
  730: 	    c = 'y';/* Always run BIST on machines without MA2s (rev 1). */
[ 730] 0x900000001fc13ce8:  10 00 00 0b b		0x900000001fc13d18
[ 730] 0x900000001fc13cec:  df be 00 60 ld	s8,96(sp)
[ 725] 0x900000001fc13cf0:  0f f0 2c e3 jal		loprintf
[ 725] 0x900000001fc13cf4:  66 a4 01 a8 daddiu	a0,s5,424
[ 726] 0x900000001fc13cf8:  0f f0 15 1b jal		pod_flush
[ 726] 0x900000001fc13cfc:  00 00 00 21 nada
[ 727] 0x900000001fc13d00:  0f f0 15 0b jal		pod_getc
[ 727] 0x900000001fc13d04:  00 00 00 21 nada
[ 727] 0x900000001fc13d08:  30 51 00 ff andi	s1,v0,0xff
[ 728] 0x900000001fc13d0c:  0f f0 15 13 jal		pod_putc
[ 728] 0x900000001fc13d10:  32 24 00 ff andi	a0,s1,0xff
[ 728] 0x900000001fc13d14:  df be 00 60 ld	s8,96(sp)
  731: 	}
  732: 
  733: 	if (c == 'y') {
[ 733] 0x900000001fc13d18:  12 32 00 06 beq	s1,s2,0x900000001fc13d34
[ 733] 0x900000001fc13d1c:  df b8 00 60 ld	t8,96(sp)
  734: 	    loprintf("Running built-in memory test...");
  735: 	    sysctlr_message("Running BIST..");
  736: 	    retval = pod_check_rawmem(bpos, banks) ? EVDIAG_BIST_FAILED : 0;
  737: 	} else {
  738: 	    loprintf("\nSkipping BIST\n");
[ 738] 0x900000001fc13d20:  0f f0 2c e3 jal		loprintf
[ 738] 0x900000001fc13d24:  67 04 01 e8 daddiu	a0,t8,488
  739: 	    retval = 0;
[ 739] 0x900000001fc13d28:  ff a0 00 50 sd	zero,80(sp)
[ 739] 0x900000001fc13d2c:  10 00 00 0f b		0x900000001fc13d6c
[ 739] 0x900000001fc13d30:  df a1 00 60 ld	at,96(sp)
[ 734] 0x900000001fc13d34:  0f f0 2c e3 jal		loprintf
[ 734] 0x900000001fc13d38:  67 c4 01 b8 daddiu	a0,s8,440
[ 735] 0x900000001fc13d3c:  0f f0 11 7c jal		sysctlr_message
[ 735] 0x900000001fc13d40:  67 c4 01 d8 daddiu	a0,s8,472
[ 736] 0x900000001fc13d44:  02 80 28 25 move	a1,s4
[ 736] 0x900000001fc13d48:  0f f0 40 d7 jal		pod_check_rawmem
[ 736] 0x900000001fc13d4c:  df a4 00 48 ld	a0,72(sp)
[ 736] 0x900000001fc13d50:  24 19 00 28 li	t9,40
[ 736] 0x900000001fc13d54:  00 02 c8 0a movz	t9,zero,v0
[ 736] 0x900000001fc13d58:  00 00 00 21 nada
[ 736] 0x900000001fc13d5c:  00 00 00 21 nada
[ 736] 0x900000001fc13d60:  00 00 00 21 nada
[ 736] 0x900000001fc13d64:  ff b9 00 50 sd	t9,80(sp)
[ 736] 0x900000001fc13d68:  df a1 00 60 ld	at,96(sp)
  740: 	}
  741:     }
  742: 
  743:     sysctlr_message("Configuring memory.."); 
[ 743] 0x900000001fc13d6c:  0f f0 11 7c jal		sysctlr_message
[ 743] 0x900000001fc13d70:  64 24 01 f8 daddiu	a0,at,504
  744:     while (cfginfo->ecfg_memsize = interleave(bpos, banks, type)) {
[ 744] 0x900000001fc13d74:  02 c0 30 25 move	a2,s6
[ 744] 0x900000001fc13d78:  02 80 28 25 move	a1,s4
[ 744] 0x900000001fc13d7c:  0f f0 48 61 jal		interleave
[ 744] 0x900000001fc13d80:  df a4 00 48 ld	a0,72(sp)
[ 744] 0x900000001fc13d84:  df a1 00 60 ld	at,96(sp)
[ 744] 0x900000001fc13d88:  df bf 00 40 ld	ra,64(sp)
[ 744] 0x900000001fc13d8c:  64 35 02 28 daddiu	s5,at,552
[ 744] 0x900000001fc13d90:  64 31 02 10 daddiu	s1,at,528
[ 744] 0x900000001fc13d94:  af e2 06 d0 sw	v0,1744(ra)
[ 744] 0x900000001fc13d98:  64 32 02 50 daddiu	s2,at,592
[ 744] 0x900000001fc13d9c:  50 40 00 32 beql	v0,zero,0x900000001fc13e68
[ 744] 0x900000001fc13da0:  df a8 00 40 ld	a4,64(sp)
[ 744] 0x900000001fc13da4:  24 03 00 01 li	v1,1
[ 744] 0x900000001fc13da8:  64 33 02 78 daddiu	s3,at,632
  745: 	int tmp_retval;
  746: 	sysctlr_message("Testing memory...");
[ 746] 0x900000001fc13dac:  0f f0 11 7c jal		sysctlr_message
[ 746] 0x900000001fc13db0:  02 20 20 25 move	a0,s1
  747: 	activate_memory(bpos, banks);
[ 747] 0x900000001fc13db4:  02 80 28 25 move	a1,s4
[ 747] 0x900000001fc13db8:  0f f0 4c e7 jal		activate_memory
[ 747] 0x900000001fc13dbc:  df a4 00 48 ld	a0,72(sp)
  748: 	if (!(cfginfo->ecfg_debugsw & (VDS_NO_DIAGS | VDS_NOMEMCLEAR))) {
[ 748] 0x900000001fc13dc0:  02 80 28 25 move	a1,s4
[ 748] 0x900000001fc13dc4:  24 03 00 01 li	v1,1
[ 748] 0x900000001fc13dc8:  df a2 00 40 ld	v0,64(sp)
[ 748] 0x900000001fc13dcc:  00 60 30 25 move	a2,v1
[ 748] 0x900000001fc13dd0:  8c 42 06 d8 lw	v0,1752(v0)
[ 748] 0x900000001fc13dd4:  30 42 00 14 andi	v0,v0,0x14
[ 748] 0x900000001fc13dd8:  54 40 00 23 bnel	v0,zero,0x900000001fc13e68
[ 748] 0x900000001fc13ddc:  df a8 00 40 ld	a4,64(sp)
  749: 
  750: 		/*
  751: 		 * Run a simple check to insure that the basic bank
  752: 		 * arrangement is complete.
  753: 		 */
  754: 		if (tmp_retval = check_banks(bpos, banks, WRITE)) {
[ 754] 0x900000001fc13de0:  0f f0 4d 45 jal		check_banks
[ 754] 0x900000001fc13de4:  df a4 00 48 ld	a0,72(sp)
[ 754] 0x900000001fc13de8:  24 03 00 01 li	v1,1
[ 754] 0x900000001fc13dec:  00 40 80 25 move	s0,v0
[ 754] 0x900000001fc13df0:  52 00 00 06 beql	s0,zero,0x900000001fc13e0c
[ 754] 0x900000001fc13df4:  00 00 30 25 move	a2,zero
  755: 		    loprintf("*** Bank check write pass failed\n");
[ 755] 0x900000001fc13df8:  0f f0 2c e3 jal		loprintf
[ 755] 0x900000001fc13dfc:  02 a0 20 25 move	a0,s5
  756: 		    retval = tmp_retval;
[ 756] 0x900000001fc13e00:  ff b0 00 50 sd	s0,80(sp)
[ 756] 0x900000001fc13e04:  24 03 00 01 li	v1,1
[ 756] 0x900000001fc13e08:  00 00 30 25 move	a2,zero
  757: 		}
  758: 		if (tmp_retval = check_banks(bpos, banks, READ)) {
[ 758] 0x900000001fc13e0c:  02 80 28 25 move	a1,s4
[ 758] 0x900000001fc13e10:  0f f0 4d 45 jal		check_banks
[ 758] 0x900000001fc13e14:  df a4 00 48 ld	a0,72(sp)
[ 758] 0x900000001fc13e18:  24 03 00 01 li	v1,1
[ 758] 0x900000001fc13e1c:  00 40 80 25 move	s0,v0
[ 758] 0x900000001fc13e20:  52 00 00 11 beql	s0,zero,0x900000001fc13e68
[ 758] 0x900000001fc13e24:  df a8 00 40 ld	a4,64(sp)
  759: 		    loprintf("*** Bank check read pass failed\n");
[ 759] 0x900000001fc13e28:  0f f0 2c e3 jal		loprintf
[ 759] 0x900000001fc13e2c:  02 40 20 25 move	a0,s2
  760: 		    retval = tmp_retval;
[ 760] 0x900000001fc13e30:  ff b0 00 50 sd	s0,80(sp)
[ 760] 0x900000001fc13e34:  12 17 00 25 beq	s0,s7,0x900000001fc13ecc
[ 760] 0x900000001fc13e38:  24 03 00 01 li	v1,1
  761: 		} else {
  762: 		    break;
  763: 		}
  764: 
  765: 		/* If this happens, we may be infinite-looping */
  766:                 if (retval == EVDIAG_MC3DOUBLEDIS) {
  767:     
  768: 		    return retval;
  769:                 }
  770: 	} else {
  771: 		break;
  772: 	} /* If diags are on */
  773: 	loprintf("NOTE: Reconfiguring memory.\n");
[ 773] 0x900000001fc13e3c:  0f f0 2c e3 jal		loprintf
[ 773] 0x900000001fc13e40:  02 60 20 25 move	a0,s3
[ 744] 0x900000001fc13e44:  02 c0 30 25 move	a2,s6
[ 744] 0x900000001fc13e48:  02 80 28 25 move	a1,s4
[ 744] 0x900000001fc13e4c:  0f f0 48 61 jal		interleave
[ 744] 0x900000001fc13e50:  df a4 00 48 ld	a0,72(sp)
[ 744] 0x900000001fc13e54:  df a7 00 40 ld	a3,64(sp)
[ 744] 0x900000001fc13e58:  24 03 00 01 li	v1,1
[ 744] 0x900000001fc13e5c:  14 40 ff d3 bne	v0,zero,0x900000001fc13dac
[ 744] 0x900000001fc13e60:  ac e2 06 d0 sw	v0,1744(a3)
  774:     } /* while */
  775:     if (!cfginfo->ecfg_memsize) {
[ 775] 0x900000001fc13e64:  df a8 00 40 ld	a4,64(sp)
[ 775] 0x900000001fc13e68:  df a9 00 40 ld	a5,64(sp)
[ 775] 0x900000001fc13e6c:  df ac 00 60 ld	t0,96(sp)
[ 775] 0x900000001fc13e70:  8d 08 06 d0 lw	a4,1744(a4)
[ 775] 0x900000001fc13e74:  51 00 00 10 beql	a4,zero,0x900000001fc13eb8
[ 775] 0x900000001fc13e78:  df b1 00 b0 ld	s1,176(sp)
  776: 	loprintf("\n*** CONFIGURATION FAILED: No operational memory was found\n");
  777: 	return EVDIAG_NO_MEM;
  778:     }
  779: 
  780:     if (!(cfginfo->ecfg_debugsw & (VDS_NO_DIAGS | VDS_NOMEMCLEAR))) {
[ 780] 0x900000001fc13e7c:  8d 29 06 d8 lw	a5,1752(a5)
[ 780] 0x900000001fc13e80:  31 29 00 14 andi	a5,a5,0x14
[ 780] 0x900000001fc13e84:  df aa 00 40 ld	a6,64(sp)
[ 780] 0x900000001fc13e88:  55 20 00 08 bnel	a5,zero,0x900000001fc13eac
[ 780] 0x900000001fc13e8c:  df b1 00 b0 ld	s1,176(sp)
  781: 	if (pod_check_mem(cfginfo->ecfg_memsize))
[ 781] 0x900000001fc13e90:  0f f0 3f c4 jal		pod_check_mem
[ 781] 0x900000001fc13e94:  8d 44 06 d0 lw	a0,1744(a6)
[ 781] 0x900000001fc13e98:  24 0b 00 2a li	a7,42
[ 781] 0x900000001fc13e9c:  50 40 00 03 beql	v0,zero,0x900000001fc13eac
[ 781] 0x900000001fc13ea0:  df b1 00 b0 ld	s1,176(sp)
  782: 	    retval = EVDIAG_BAD_ADDRLINE;
[ 782] 0x900000001fc13ea4:  ff ab 00 50 sd	a7,80(sp)
[ 782] 0x900000001fc13ea8:  df b1 00 b0 ld	s1,176(sp)
  783:     }
  784:     DPRINTF(("mc3_config: return(%d)\n", retval));
  785:     return retval;
[ 785] 0x900000001fc13eac:  10 00 00 0b b		0x900000001fc13edc
[ 785] 0x900000001fc13eb0:  df a2 00 50 ld	v0,80(sp)
[ 776] 0x900000001fc13eb4:  df b1 00 b0 ld	s1,176(sp)
[ 776] 0x900000001fc13eb8:  0f f0 2c e3 jal		loprintf
[ 776] 0x900000001fc13ebc:  65 84 02 98 daddiu	a0,t0,664
[ 777] 0x900000001fc13ec0:  24 02 00 29 li	v0,41
[ 777] 0x900000001fc13ec4:  10 00 00 06 b		0x900000001fc13ee0
[ 777] 0x900000001fc13ec8:  df b3 00 a0 ld	s3,160(sp)
[ 777] 0x900000001fc13ecc:  df b1 00 b0 ld	s1,176(sp)
[ 768] 0x900000001fc13ed0:  10 00 00 02 b		0x900000001fc13edc
[ 768] 0x900000001fc13ed4:  02 00 10 25 move	v0,s0
[ 768] 0x900000001fc13ed8:  df b1 00 b0 ld	s1,176(sp)
[ 686] 0x900000001fc13edc:  df b3 00 a0 ld	s3,160(sp)
[ 686] 0x900000001fc13ee0:  df b5 00 90 ld	s5,144(sp)
[ 686] 0x900000001fc13ee4:  df be 00 78 ld	s8,120(sp)
[ 686] 0x900000001fc13ee8:  df bf 00 c0 ld	ra,192(sp)
[ 686] 0x900000001fc13eec:  df b6 00 88 ld	s6,136(sp)
[ 686] 0x900000001fc13ef0:  df b4 00 98 ld	s4,152(sp)
[ 686] 0x900000001fc13ef4:  df b2 00 a8 ld	s2,168(sp)
[ 686] 0x900000001fc13ef8:  df b0 00 b8 ld	s0,184(sp)
[ 686] 0x900000001fc13efc:  df b7 00 80 ld	s7,128(sp)
[ 686] 0x900000001fc13f00:  03 e0 00 08 jr	ra
[ 686] 0x900000001fc13f04:  67 bd 02 d0 daddiu	sp,sp,720
[ 686] 0x900000001fc13f08:  00 03 c8 c0 sll	t9,v1,3
[ 686] 0x900000001fc13f0c:  26 f7 00 40 addiu	s7,s7,64
[ 661] 0x900000001fc13f10:  fe 08 00 d0 sd	a4,208(s0)
[ 661] 0x900000001fc13f14:  dd 6d 00 00 ld	t1,0(a7)
[ 661] 0x900000001fc13f18:  24 63 00 40 addiu	v1,v1,64
[ 661] 0x900000001fc13f1c:  a1 0d 00 0a sb	t1,10(a4)
[ 661] 0x900000001fc13f20:  65 08 00 30 daddiu	a4,a4,48
[ 661] 0x900000001fc13f24:  de 0d 00 d0 ld	t1,208(s0)
[ 661] 0x900000001fc13f28:  02 39 c8 2d daddu	t9,s1,t9
[ 661] 0x900000001fc13f2c:  a1 b3 00 04 sb	s3,4(t1)
[ 661] 0x900000001fc13f30:  00 06 70 c0 sll	t2,a2,3
[ 661] 0x900000001fc13f34:  24 c6 00 40 addiu	a2,a2,64
[ 661] 0x900000001fc13f38:  de 0d 00 d0 ld	t1,208(s0)
[ 661] 0x900000001fc13f3c:  03 36 58 2d daddu	a7,t9,s6
[ 661] 0x900000001fc13f40:  02 2e 70 2d daddu	t2,s1,t2
[ 661] 0x900000001fc13f44:  01 d6 50 2d daddu	a6,t2,s6
[ 661] 0x900000001fc13f48:  df ae 00 48 ld	t2,72(sp)
[ 661] 0x900000001fc13f4c:  91 ad 00 05 lbu	t1,5(t1)
[ 661] 0x900000001fc13f50:  11 a0 00 0b beq	t1,zero,0x900000001fc13f80
[ 661] 0x900000001fc13f54:  25 c1 00 01 addiu	at,t2,1
[ 661] 0x900000001fc13f58:  de 0f 00 d0 ld	t3,208(s0)
[ 661] 0x900000001fc13f5c:  91 ef 00 0a lbu	t3,10(t3)
[ 661] 0x900000001fc13f60:  31 ef 00 ff andi	t3,t3,0xff
[ 661] 0x900000001fc13f64:  00 0f 78 f8 dsll	t3,t3,3
[ 661] 0x900000001fc13f68:  01 fe 78 2d daddu	t3,t3,s8
[ 661] 0x900000001fc13f6c:  00 12 90 3c dsll32	s2,s2,0
[ 661] 0x900000001fc13f70:  00 12 90 3e dsrl32	s2,s2,0
[ 661] 0x900000001fc13f74:  dd ef 00 00 ld	t3,0(t3)
[ 661] 0x900000001fc13f78:  01 f2 78 2d daddu	t3,t3,s2
[ 661] 0x900000001fc13f7c:  00 0f 90 00 sll	s2,t3,0
[ 661] 0x900000001fc13f80:  00 12 20 3c dsll32	a0,s2,0
[ 661] 0x900000001fc13f84:  fe 07 00 d8 sd	a3,216(s0)
[ 661] 0x900000001fc13f88:  dd 58 00 00 ld	t8,0(a6)
[ 661] 0x900000001fc13f8c:  a0 f8 00 0a sb	t8,10(a3)
[ 661] 0x900000001fc13f90:  64 e7 00 30 daddiu	a3,a3,48
[ 661] 0x900000001fc13f94:  de 18 00 d8 ld	t8,216(s0)
[ 661] 0x900000001fc13f98:  24 21 00 01 addiu	at,at,1
[ 661] 0x900000001fc13f9c:  a3 13 00 04 sb	s3,4(t8)
[ 661] 0x900000001fc13fa0:  de 18 00 d8 ld	t8,216(s0)
[ 661] 0x900000001fc13fa4:  66 10 00 08 daddiu	s0,s0,8
[ 661] 0x900000001fc13fa8:  93 18 00 05 lbu	t8,5(t8)
[ 661] 0x900000001fc13fac:  13 00 00 09 beq	t8,zero,0x900000001fc13fd4
[ 661] 0x900000001fc13fb0:  00 04 20 3e dsrl32	a0,a0,0
[ 661] 0x900000001fc13fb4:  de 02 00 d0 ld	v0,208(s0)
[ 661] 0x900000001fc13fb8:  90 42 00 0a lbu	v0,10(v0)
[ 661] 0x900000001fc13fbc:  30 42 00 ff andi	v0,v0,0xff
[ 661] 0x900000001fc13fc0:  00 02 10 f8 dsll	v0,v0,3
[ 661] 0x900000001fc13fc4:  00 5e 10 2d daddu	v0,v0,s8
[ 661] 0x900000001fc13fc8:  dc 42 00 00 ld	v0,0(v0)
[ 661] 0x900000001fc13fcc:  00 44 10 2d daddu	v0,v0,a0
[ 661] 0x900000001fc13fd0:  00 02 90 00 sll	s2,v0,0
[ 661] 0x900000001fc13fd4:  fe 05 00 d8 sd	a1,216(s0)
[ 661] 0x900000001fc13fd8:  dd 62 00 00 ld	v0,0(a7)
[ 661] 0x900000001fc13fdc:  a0 a2 00 0a sb	v0,10(a1)
[ 661] 0x900000001fc13fe0:  64 a5 00 30 daddiu	a1,a1,48
[ 661] 0x900000001fc13fe4:  de 02 00 d8 ld	v0,216(s0)
[ 661] 0x900000001fc13fe8:  a0 53 00 04 sb	s3,4(v0)
[ 661] 0x900000001fc13fec:  00 15 20 c0 sll	a0,s5,3
[ 661] 0x900000001fc13ff0:  de 02 00 d8 ld	v0,216(s0)
[ 661] 0x900000001fc13ff4:  66 10 00 08 daddiu	s0,s0,8
[ 661] 0x900000001fc13ff8:  02 24 20 2d daddu	a0,s1,a0
[ 661] 0x900000001fc13ffc:  00 96 50 2d daddu	a6,a0,s6
[ 661] 0x900000001fc14000:  90 42 00 05 lbu	v0,5(v0)
[ 661] 0x900000001fc14004:  10 40 00 0a beq	v0,zero,0x900000001fc14030
[ 661] 0x900000001fc14008:  00 12 20 3c dsll32	a0,s2,0
[ 661] 0x900000001fc1400c:  de 02 00 d0 ld	v0,208(s0)
[ 661] 0x900000001fc14010:  90 42 00 0a lbu	v0,10(v0)
[ 661] 0x900000001fc14014:  30 42 00 ff andi	v0,v0,0xff
[ 661] 0x900000001fc14018:  00 02 10 f8 dsll	v0,v0,3
[ 661] 0x900000001fc1401c:  00 5e 10 2d daddu	v0,v0,s8
[ 661] 0x900000001fc14020:  00 04 20 3e dsrl32	a0,a0,0
[ 661] 0x900000001fc14024:  dc 42 00 00 ld	v0,0(v0)
[ 661] 0x900000001fc14028:  00 44 10 2d daddu	v0,v0,a0
[ 661] 0x900000001fc1402c:  00 02 90 00 sll	s2,v0,0
[ 661] 0x900000001fc14030:  fe 14 00 d8 sd	s4,216(s0)
[ 661] 0x900000001fc14034:  dd 42 00 00 ld	v0,0(a6)
[ 661] 0x900000001fc14038:  a2 82 00 0a sb	v0,10(s4)
[ 661] 0x900000001fc1403c:  de 02 00 d8 ld	v0,216(s0)
[ 661] 0x900000001fc14040:  66 94 00 30 daddiu	s4,s4,48
[ 661] 0x900000001fc14044:  a0 53 00 04 sb	s3,4(v0)
[ 661] 0x900000001fc14048:  de 02 00 d8 ld	v0,216(s0)
[ 661] 0x900000001fc1404c:  24 21 00 01 addiu	at,at,1
[ 661] 0x900000001fc14050:  00 17 20 c0 sll	a0,s7,3
[ 661] 0x900000001fc14054:  24 21 00 01 addiu	at,at,1
[ 661] 0x900000001fc14058:  ff a1 00 48 sd	at,72(sp)
[ 661] 0x900000001fc1405c:  66 10 00 08 daddiu	s0,s0,8
[ 661] 0x900000001fc14060:  02 24 48 2d daddu	a5,s1,a0
[ 661] 0x900000001fc14064:  90 42 00 05 lbu	v0,5(v0)
[ 661] 0x900000001fc14068:  50 40 00 0c beql	v0,zero,0x900000001fc1409c
[ 661] 0x900000001fc1406c:  66 10 00 08 daddiu	s0,s0,8
[ 661] 0x900000001fc14070:  de 02 00 d0 ld	v0,208(s0)
[ 661] 0x900000001fc14074:  90 42 00 0a lbu	v0,10(v0)
[ 661] 0x900000001fc14078:  30 42 00 ff andi	v0,v0,0xff
[ 661] 0x900000001fc1407c:  00 02 10 f8 dsll	v0,v0,3
[ 661] 0x900000001fc14080:  00 5e 10 2d daddu	v0,v0,s8
[ 661] 0x900000001fc14084:  00 12 20 3c dsll32	a0,s2,0
[ 661] 0x900000001fc14088:  00 04 20 3e dsrl32	a0,a0,0
[ 661] 0x900000001fc1408c:  dc 42 00 00 ld	v0,0(v0)
[ 661] 0x900000001fc14090:  00 44 10 2d daddu	v0,v0,a0
[ 661] 0x900000001fc14094:  00 02 90 00 sll	s2,v0,0
[ 661] 0x900000001fc14098:  66 10 00 08 daddiu	s0,s0,8
[ 660] 0x900000001fc1409c:  26 b5 00 40 addiu	s5,s5,64
[ 660] 0x900000001fc140a0:  16 bf ff 99 bne	s5,ra,0x900000001fc13f08
[ 660] 0x900000001fc140a4:  01 36 58 2d daddu	a7,a5,s6
[ 660] 0x900000001fc140a8:  df a1 00 70 ld	at,112(sp)
[ 660] 0x900000001fc140ac:  10 00 fe 5b b		0x900000001fc13a1c
[ 660] 0x900000001fc140b0:  24 17 00 31 li	s7,49
  786: #endif
  787: }
  788: 
  789: int
  790: mc3_reconfig(evcfginfo_t *cfginfo, int intlv_type) {
mc3_reconfig:
[ 790] 0x900000001fc140b4:  67 bd fd e0 daddiu	sp,sp,-544
[ 790] 0x900000001fc140b8:  ff b1 00 08 sd	s1,8(sp)
[ 790] 0x900000001fc140bc:  00 80 88 25 move	s1,a0
[ 790] 0x900000001fc140c0:  ff b2 00 00 sd	s2,0(sp)
[ 790] 0x900000001fc140c4:  00 a0 90 25 move	s2,a1
[ 790] 0x900000001fc140c8:  67 a5 00 20 daddiu	a1,sp,32
  791:     int		bpos = 0;	/* position of currently initialized bank */
[ 791] 0x900000001fc140cc:  ff b0 00 10 sd	s0,16(sp)
[ 791] 0x900000001fc140d0:  00 00 80 25 move	s0,zero
  792:     int		type;		/* Board type check */
  793:     evbnkcfg_t	*banks[EV_MAX_MC3S * MC3_NUM_BANKS];
  794:     int		slot;		/* The slot index */
  795:     int		bank;		/* Bank index */
  796:     int		leaf;		/* Leaf index */
  797: 
  798:     for (slot = 0; slot < EV_MAX_SLOTS; slot++) {
[ 798] 0x900000001fc140d4:  24 02 00 30 li	v0,48
[ 798] 0x900000001fc140d8:  02 20 30 25 move	a2,s1
[ 798] 0x900000001fc140dc:  66 23 06 c0 daddiu	v1,s1,1728
[ 798] 0x900000001fc140e0:  64 ca 00 0c daddiu	a6,a2,12
[ 798] 0x900000001fc140e4:  00 c0 58 25 move	a7,a2
  799: 	/* Make sure this really is a memory board */
  800: 	type = cfginfo->ecfg_board[slot].eb_type & EVCLASS_MASK;
[ 800] 0x900000001fc140e8:  90 c1 00 64 lbu	at,100(a2)
[ 800] 0x900000001fc140ec:  64 c9 00 18 daddiu	a5,a2,24
[ 800] 0x900000001fc140f0:  30 21 00 f0 andi	at,at,0xf0
  801: 	if (type != EVCLASS_MEM)
[ 801] 0x900000001fc140f4:  54 22 00 07 bnel	at,v0,0x900000001fc14114
[ 801] 0x900000001fc140f8:  64 c6 00 6c daddiu	a2,a2,108
  802: 	    continue;
  803: 
  804: 	for (leaf = 0; leaf < MC3_NUM_LEAVES; leaf++) {
[ 804] 0x900000001fc140fc:  64 c8 00 24 daddiu	a4,a2,36
[ 804] 0x900000001fc14100:  64 c7 00 84 daddiu	a3,a2,132
[ 804] 0x900000001fc14104:  00 10 20 f8 dsll	a0,s0,3
[ 804] 0x900000001fc14108:  10 00 00 22 b		0x900000001fc14194
[ 804] 0x900000001fc1410c:  03 a4 c8 2d daddu	t9,sp,a0
[ 798] 0x900000001fc14110:  64 c6 00 6c daddiu	a2,a2,108
[ 798] 0x900000001fc14114:  54 c3 ff f3 bnel	a2,v1,0x900000001fc140e4
[ 798] 0x900000001fc14118:  64 ca 00 0c daddiu	a6,a2,12
[ 798] 0x900000001fc1411c:  02 40 30 25 move	a2,s2
  805: 	    for (bank = 0; bank < MC3_BANKS_PER_LEAF; bank++) {
  806: 		DPRINTF(("  Configuring leaf %d, bank %d...", leaf, bank));
  807: 		banks[bpos] = 
  808: 		    &(cfginfo->ecfg_board[slot].eb_banks[4*leaf + bank]);
  809: 		bpos++;
  810: 	    }
  811: 	}
  812:     }
  813: 
  814:     if (cfginfo->ecfg_memsize = interleave(bpos, banks, intlv_type)) {
[ 814] 0x900000001fc14120:  ff bf 00 18 sd	ra,24(sp)
[ 814] 0x900000001fc14124:  df b2 00 00 ld	s2,0(sp)
[ 814] 0x900000001fc14128:  0f f0 48 61 jal		interleave
[ 814] 0x900000001fc1412c:  02 00 20 25 move	a0,s0
[ 814] 0x900000001fc14130:  3c 08 1f c2 lui	a4,0x1fc2
[ 814] 0x900000001fc14134:  3c 07 90 00 lui	a3,0x9000
[ 814] 0x900000001fc14138:  54 40 00 0d bnel	v0,zero,0x900000001fc14170
[ 814] 0x900000001fc1413c:  67 a5 00 20 daddiu	a1,sp,32
[ 814] 0x900000001fc14140:  df b0 00 10 ld	s0,16(sp)
  815: 	activate_memory(bpos, banks);
  816:     } else {
  817: 	loprintf("\n*** WARNING: No operational memory was found\n");
[ 817] 0x900000001fc14144:  60 e7 00 00 daddi	a3,a3,0
[ 817] 0x900000001fc14148:  61 08 eb 60 daddi	a4,a4,-5280
[ 817] 0x900000001fc1414c:  00 07 38 3c dsll32	a3,a3,0
[ 817] 0x900000001fc14150:  ae 22 06 d0 sw	v0,1744(s1)
[ 817] 0x900000001fc14154:  df b1 00 08 ld	s1,8(sp)
[ 817] 0x900000001fc14158:  0f f0 2c e3 jal		loprintf
[ 817] 0x900000001fc1415c:  00 e8 20 2c dadd	a0,a3,a4
  818: 	return EVDIAG_NO_MEM;
[ 818] 0x900000001fc14160:  24 02 00 29 li	v0,41
[ 818] 0x900000001fc14164:  10 00 00 09 b		0x900000001fc1418c
[ 818] 0x900000001fc14168:  df bf 00 18 ld	ra,24(sp)
[ 815] 0x900000001fc1416c:  67 a5 00 20 daddiu	a1,sp,32
[ 815] 0x900000001fc14170:  ae 22 06 d0 sw	v0,1744(s1)
[ 815] 0x900000001fc14174:  df b1 00 08 ld	s1,8(sp)
[ 815] 0x900000001fc14178:  0f f0 4c e7 jal		activate_memory
[ 815] 0x900000001fc1417c:  02 00 20 25 move	a0,s0
  819:     }
  820: 
  821:     return 0;
[ 821] 0x900000001fc14180:  df b0 00 10 ld	s0,16(sp)
[ 821] 0x900000001fc14184:  df bf 00 18 ld	ra,24(sp)
[ 821] 0x900000001fc14188:  00 00 10 25 move	v0,zero
[ 821] 0x900000001fc1418c:  03 e0 00 08 jr	ra
[ 821] 0x900000001fc14190:  67 bd 02 20 daddiu	sp,sp,544
[ 805] 0x900000001fc14194:  ff 28 00 38 sd	a4,56(t9)
[ 805] 0x900000001fc14198:  ff 2b 00 20 sd	a7,32(t9)
[ 805] 0x900000001fc1419c:  ff 2a 00 28 sd	a6,40(t9)
[ 805] 0x900000001fc141a0:  26 10 00 04 addiu	s0,s0,4
[ 804] 0x900000001fc141a4:  ff 29 00 30 sd	a5,48(t9)
[ 804] 0x900000001fc141a8:  67 39 00 20 daddiu	t9,t9,32
[ 804] 0x900000001fc141ac:  65 6b 00 30 daddiu	a7,a7,48
[ 804] 0x900000001fc141b0:  65 4a 00 30 daddiu	a6,a6,48
[ 804] 0x900000001fc141b4:  65 08 00 30 daddiu	a4,a4,48
[ 804] 0x900000001fc141b8:  15 07 ff f6 bne	a4,a3,0x900000001fc14194
[ 804] 0x900000001fc141bc:  65 29 00 30 daddiu	a5,a5,48
[ 805] 0x900000001fc141c0:  10 00 ff d4 b		0x900000001fc14114
[ 805] 0x900000001fc141c4:  64 c6 00 6c daddiu	a2,a2,108
  822: }
  823: 
  824: 
  825: /*
  826:  * mc3_clear_err
  827:  *	Clears the MC3's error registers.  This isn't done 
  828:  *	automatically by the config routines because the OS
  829:  *	may want to examine these registers in certain circumstances.
  830:  */
  831: 
  832: void
  833: mc3_clear_err()
  834: {
mc3_clear_err:
[ 834] 0x900000001fc141c8:  03 e0 00 08 jr	ra
[ 834] 0x900000001fc141cc:  00 00 00 21 nada
Skipping source listing to line 38 of /cores/banyan/stand/arcs/IP25prom/config.c...
   39:  
   40: /* any_mc_boards()
   41:  *	returns 1 if there's at least one MC3 board, else returns 0
   42:  */
   43: uint
   44: any_mc_boards(void)
   45: {
   46:     uint 	config_hi;		/* High-order bits of sysconfig */
   47: 
   48:     config_hi = LD_HI(EV_SYSCONFIG);
any_mc_boards:
[  48] 0x900000001fc141d0:  3c 01 90 00 lui	at,0x9000
[  48] 0x900000001fc141d4:  60 21 00 00 daddi	at,at,0
[  48] 0x900000001fc141d8:  3c 03 1f c2 lui	v1,0x1fc2
[  48] 0x900000001fc141dc:  60 63 eb 90 daddi	v1,v1,-5232
[  48] 0x900000001fc141e0:  00 01 08 3c dsll32	at,at,0
[  48] 0x900000001fc141e4:  00 23 08 2c dadd	at,at,v1
[  48] 0x900000001fc141e8:  dc 23 00 08 ld	v1,8(at)
[  48] 0x900000001fc141ec:  dc 21 00 00 ld	at,0(at)
[  48] 0x900000001fc141f0:  dc 21 00 00 ld	at,0(at)
[  48] 0x900000001fc141f4:  00 23 08 24 and	at,at,v1
[  48] 0x900000001fc141f8:  00 01 08 3e dsrl32	at,at,0
   49:     
   50:     if (config_hi)
   51: 	return 1;
[  51] 0x900000001fc141fc:  24 02 00 01 li	v0,1
[  51] 0x900000001fc14200:  00 01 08 00 sll	at,at,0
[  51] 0x900000001fc14204:  00 01 10 0a movz	v0,zero,at
[  51] 0x900000001fc14208:  00 00 00 21 nada
[  51] 0x900000001fc1420c:  00 00 00 21 nada
[  51] 0x900000001fc14210:  00 00 00 21 nada
   52:     else
   53: 	return 0;
[  53] 0x900000001fc14214:  03 e0 00 08 jr	ra
[  53] 0x900000001fc14218:  00 00 00 21 nada
   54: }
   55: 
   56: 
   57: /* any_io_boards()
   58:  *	returns 1 if there's at least one IO4 board, else returns 0
   59:  */
   60: uint
   61: any_io_boards(void)
   62: {
   63:     uint 	config_hi;		/* High-order bits of sysconfig */
   64:     uint	config_lo;		/* Low-order bits of sysconfig */
   65: 
   66:     config_lo = LD_LO(EV_SYSCONFIG);
any_io_boards:
[  66] 0x900000001fc1421c:  3c 01 90 00 lui	at,0x9000
[  66] 0x900000001fc14220:  60 21 00 00 daddi	at,at,0
[  66] 0x900000001fc14224:  3c 03 1f c2 lui	v1,0x1fc2
[  66] 0x900000001fc14228:  60 63 eb 90 daddi	v1,v1,-5232
[  66] 0x900000001fc1422c:  00 01 08 3c dsll32	at,at,0
[  66] 0x900000001fc14230:  00 23 20 2c dadd	a0,at,v1
[  66] 0x900000001fc14234:  34 05 ff ff ori	a1,zero,0xffff
[  66] 0x900000001fc14238:  dc 83 00 00 ld	v1,0(a0)
[  66] 0x900000001fc1423c:  00 05 2c 38 dsll	a1,a1,16
[  66] 0x900000001fc14240:  34 a5 ff ff ori	a1,a1,0xffff
[  66] 0x900000001fc14244:  dc 61 00 00 ld	at,0(v1)
   67:     config_hi = LD_HI(EV_SYSCONFIG);
[  67] 0x900000001fc14248:  00 25 08 24 and	at,at,a1
[  67] 0x900000001fc1424c:  dc 84 00 08 ld	a0,8(a0)
[  67] 0x900000001fc14250:  dc 63 00 00 ld	v1,0(v1)
[  67] 0x900000001fc14254:  00 64 18 24 and	v1,v1,a0
[  67] 0x900000001fc14258:  00 01 08 00 sll	at,at,0
[  67] 0x900000001fc1425c:  00 03 18 3e dsrl32	v1,v1,0
   68:    
   69:     if ((config_lo & 0xffff) & ~(((config_lo >> 16) & 0xffff) |
[  69] 0x900000001fc14260:  00 01 24 02 srl	a0,at,16
[  69] 0x900000001fc14264:  00 03 18 00 sll	v1,v1,0
[  69] 0x900000001fc14268:  00 64 18 27 nor	v1,v1,a0
[  69] 0x900000001fc1426c:  3c 04 ff ff lui	a0,0xffff
[  69] 0x900000001fc14270:  30 21 ff ff andi	at,at,0xffff
[  69] 0x900000001fc14274:  00 64 18 25 or	v1,v1,a0
   70: 						(config_hi & 0xffff)))
   71: 	return 1;
[  71] 0x900000001fc14278:  24 02 00 01 li	v0,1
[  71] 0x900000001fc1427c:  00 23 08 24 and	at,at,v1
[  71] 0x900000001fc14280:  00 01 10 0a movz	v0,zero,at
[  71] 0x900000001fc14284:  00 00 00 21 nada
[  71] 0x900000001fc14288:  00 00 00 21 nada
[  71] 0x900000001fc1428c:  00 00 00 21 nada
   72:     else
   73: 	return 0;
[  73] 0x900000001fc14290:  03 e0 00 08 jr	ra
[  73] 0x900000001fc14294:  00 00 00 21 nada
   74: }
   75: 
   76: /*
   77:  * init_cfginfo()
   78:  *	Initializes the parameters in the evcfginfo to rational 
   79:  *	default values.  
   80:  */
   81: 
   82: void
   83: init_cfginfo(evcfginfo_t *cfginfo)
   84: {
init_cfginfo:
[  84] 0x900000001fc14298:  67 bd ff a0 daddiu	sp,sp,-96
   85:     uint  	config_hi;		/* High-order bits of sysconfig */
   86:     uint	config_lo;		/* Low-order bits of sysconfig */
   87:     uint	i;			/* Iteration variable */
   88:     uint 	type;			/* Board type */
   89:     evbrdinfo_t *brd;			/* Board pointer for referencing */
   90: 
   91:     /* Set basic fields in the config information structure.
   92:      */
   93:     cfginfo->ecfg_magic = EVCFGINFO_MAGIC;
   94:     cfginfo->ecfg_secs = cfginfo->ecfg_nanosecs = 0;
[  94] 0x900000001fc1429c:  ac 80 06 c8 sw	zero,1736(a0)
[  93] 0x900000001fc142a0:  ff b1 00 48 sd	s1,72(sp)
[  93] 0x900000001fc142a4:  00 80 88 25 move	s1,a0
[  93] 0x900000001fc142a8:  ac 80 06 c4 sw	zero,1732(a0)
[  93] 0x900000001fc142ac:  3c 01 de ad lui	at,0xdead
   95:     cfginfo->ecfg_memsize = 0;
[  95] 0x900000001fc142b0:  ac 80 06 d0 sw	zero,1744(a0)
[  95] 0x900000001fc142b4:  34 21 ba be ori	at,at,0xbabe
[  95] 0x900000001fc142b8:  ff bf 00 08 sd	ra,8(sp)
[  95] 0x900000001fc142bc:  0f f0 0d 2c jal		initCPUSpeed
[  95] 0x900000001fc142c0:  ac 81 06 c0 sw	at,1728(a0)
[  95] 0x900000001fc142c4:  00 40 38 25 move	a3,v0
   96: 
   97:     DPRINTF(("init_cfginfo: init_cpuSpeed()\n"));
   98:     cfginfo->ecfg_clkfreq = initCPUSpeed();
   99: 
  100:     /*
  101:      * Iterate through all the boards and fill out the slot information.
  102:      */
  103:     config_lo = LD_LO(EV_SYSCONFIG);
  104:     config_hi = LD_HI(EV_SYSCONFIG);
  105:     DPRINTF(("Sysconfig register: %x %x\n", config_hi, config_lo));
  106:     DPRINTF(("Sysconfig register: %x\n", *(volatile ulong *)EV_SYSCONFIG));
  107: 
  108:     for (i = 0; i < EV_MAX_SLOTS; i++) {
[ 108] 0x900000001fc142c8:  00 00 40 25 move	a4,zero
[ 108] 0x900000001fc142cc:  ff b7 00 18 sd	s7,24(sp)
[ 108] 0x900000001fc142d0:  ff be 00 10 sd	s8,16(sp)
[ 108] 0x900000001fc142d4:  24 1e 00 10 li	s8,16
[ 108] 0x900000001fc142d8:  ff b2 00 40 sd	s2,64(sp)
[ 108] 0x900000001fc142dc:  24 12 00 ff li	s2,255
[ 108] 0x900000001fc142e0:  ff b6 00 20 sd	s6,32(sp)
[ 108] 0x900000001fc142e4:  24 16 00 03 li	s6,3
[ 108] 0x900000001fc142e8:  24 17 00 02 li	s7,2
[ 103] 0x900000001fc142ec:  24 06 00 01 li	a2,1
[ 103] 0x900000001fc142f0:  3c 01 90 00 lui	at,0x9000
[ 103] 0x900000001fc142f4:  60 21 00 00 daddi	at,at,0
[ 103] 0x900000001fc142f8:  34 03 ff ff ori	v1,zero,0xffff
[ 103] 0x900000001fc142fc:  3c 02 1f c2 lui	v0,0x1fc2
[ 103] 0x900000001fc14300:  00 03 2c 38 dsll	a1,v1,16
[ 103] 0x900000001fc14304:  ff b5 00 28 sd	s5,40(sp)
[ 103] 0x900000001fc14308:  60 42 eb 90 daddi	v0,v0,-5232
[ 103] 0x900000001fc1430c:  00 01 08 3c dsll32	at,at,0
[ 103] 0x900000001fc14310:  ff b4 00 30 sd	s4,48(sp)
[ 103] 0x900000001fc14314:  00 00 18 3c dsll32	v1,zero,0
[ 103] 0x900000001fc14318:  00 22 20 2c dadd	a0,at,v0
[ 103] 0x900000001fc1431c:  ae 27 06 cc sw	a3,1740(s1)
[ 103] 0x900000001fc14320:  00 03 38 3e dsrl32	a3,v1,0
[ 103] 0x900000001fc14324:  24 03 00 01 li	v1,1
[ 103] 0x900000001fc14328:  ff b0 00 50 sd	s0,80(sp)
[ 103] 0x900000001fc1432c:  24 1f 00 13 li	ra,19
[ 103] 0x900000001fc14330:  00 03 58 04 sllv	a7,v1,zero
[ 103] 0x900000001fc14334:  dc 94 00 10 ld	s4,16(a0)
[ 103] 0x900000001fc14338:  dc 81 00 00 ld	at,0(a0)
[ 103] 0x900000001fc1433c:  24 10 00 10 li	s0,16
[ 103] 0x900000001fc14340:  00 07 50 b8 dsll	a6,a3,2
[ 103] 0x900000001fc14344:  ff a4 00 00 sd	a0,0(sp)
[ 103] 0x900000001fc14348:  34 a5 ff ff ori	a1,a1,0xffff
[ 103] 0x900000001fc1434c:  00 07 49 38 dsll	a5,a3,4
[ 103] 0x900000001fc14350:  dc 95 00 18 ld	s5,24(a0)
[ 103] 0x900000001fc14354:  dc 22 00 00 ld	v0,0(at)
[ 104] 0x900000001fc14358:  00 07 39 f8 dsll	a3,a3,7
[ 104] 0x900000001fc1435c:  00 45 10 24 and	v0,v0,a1
[ 104] 0x900000001fc14360:  dc 84 00 08 ld	a0,8(a0)
[ 104] 0x900000001fc14364:  dc 21 00 00 ld	at,0(at)
[ 104] 0x900000001fc14368:  00 24 08 24 and	at,at,a0
[ 104] 0x900000001fc1436c:  00 02 28 00 sll	a1,v0,0
[ 104] 0x900000001fc14370:  00 ab 60 24 and	t0,a1,a7
[ 104] 0x900000001fc14374:  01 2a 48 2d daddu	a5,a5,a6
[ 104] 0x900000001fc14378:  00 01 08 3e dsrl32	at,at,0
[ 104] 0x900000001fc1437c:  00 e9 c8 2f dsubu	t9,a3,a5
[ 104] 0x900000001fc14380:  ff b3 00 38 sd	s3,56(sp)
[ 104] 0x900000001fc14384:  00 01 98 00 sll	s3,at,0
[ 104] 0x900000001fc14388:  25 0d 00 10 addiu	t1,a4,16
  109: 	/* 
  110: 	 * Set the board info fields to rational default values.
  111: 	 */
  112: 	brd = &(cfginfo->ecfg_board[i]);
[ 112] 0x900000001fc1438c:  02 39 38 2d daddu	a3,s1,t9
  113: 	brd->eb_type 	  = EVTYPE_EMPTY;
[ 113] 0x900000001fc14390:  02 6b 50 24 and	a6,s3,a7
[ 113] 0x900000001fc14394:  01 a3 68 04 sllv	t1,v1,t1
[ 113] 0x900000001fc14398:  00 ad 68 24 and	t1,a1,t1
[ 113] 0x900000001fc1439c:  00 08 72 c0 sll	t2,a4,11
[ 113] 0x900000001fc143a0:  a0 e0 00 64 sb	zero,100(a3)
  114: 	brd->eb_rev	  = 0;
[ 114] 0x900000001fc143a4:  00 0e 70 3c dsll32	t2,t2,0
[ 114] 0x900000001fc143a8:  a0 e0 00 65 sb	zero,101(a3)
  115: 	brd->eb_enabled   = 0;
[ 115] 0x900000001fc143ac:  00 0e c8 3e dsrl32	t9,t2,0
[ 115] 0x900000001fc143b0:  a0 e0 00 66 sb	zero,102(a3)
  116: 	brd->eb_inventory = EVTYPE_EMPTY;
[ 116] 0x900000001fc143b4:  a0 e0 00 67 sb	zero,103(a3)
  117: 	brd->eb_diagval	  = EVDIAG_NOTFOUND;
[ 117] 0x900000001fc143b8:  a0 f2 00 68 sb	s2,104(a3)
  118: 	brd->eb_slot      = i;
[ 118] 0x900000001fc143bc:  a0 e8 00 69 sb	a4,105(a3)
[ 118] 0x900000001fc143c0:  51 80 00 37 beql	t0,zero,0x900000001fc144a0
[ 118] 0x900000001fc143c4:  25 08 00 01 addiu	a4,a4,1
  119: 	
  120: 	/*
  121:  	 * Check to whether slot is occupied 
  122: 	 */ 
  123:         if (config_lo & (1 << i)) {
  124: 
  125: 	    /* Slot is occupied, so figure out what's actually in it */	    
  126: 	    if (config_lo & (1 << (i+16))) {
[ 126] 0x900000001fc143c8:  15 a0 00 24 bne	t1,zero,0x900000001fc1445c
[ 126] 0x900000001fc143cc:  03 34 48 2d daddu	a5,t9,s4
  127: 
  128: 		/* Slot contains a CPU board */
  129: 		type = (uint)EV_GET_CONFIG(i, EV_A_BOARD_TYPE);
  130: 		DPRINTF(("CPU: Slot %x type %x\n", i, type));
  131: 		if (type == EV_IP19_BOARD) 
  132: 		    cfginfo->ecfg_board[i].eb_type = EVTYPE_IP25;
  133: 		else  
  134: 		    cfginfo->ecfg_board[i].eb_type = EVTYPE_WEIRDCPU;
  135: 		 cfginfo->ecfg_board[i].eb_rev = 
  136: 		     (unsigned char)EV_GET_CONFIG(i, EV_A_LEVEL);
  137: 
  138: 	    } else if (config_hi & (1 << i)) {
[ 138] 0x900000001fc143d0:  55 40 00 13 bnel	a6,zero,0x900000001fc14420
[ 138] 0x900000001fc143d4:  dd 21 00 00 ld	at,0(a5)
  139: 
  140: 		/* Slot contains a memory board */
  141: 		type = (uint)EV_GET_CONFIG(i, MC3_TYPE);
  142: 		DPRINTF(("Mem: Slot %x type %x\n", i, type));
  143: 	        if (type == MC3_TYPE_VALUE)
  144: 		    cfginfo->ecfg_board[i].eb_type = EVTYPE_MC3;
  145: 		else  
  146: 		    cfginfo->ecfg_board[i].eb_type = EVTYPE_WEIRDMEM;
  147: 
  148: 	    } else {
  149: 		/* Check for an IO4 */
  150: 		type = (uint)EV_GET_CONFIG(i, IO4_CONF_REVTYPE);
[ 150] 0x900000001fc143d8:  dd 2f 00 00 ld	t3,0(a5)
[ 150] 0x900000001fc143dc:  00 0f 78 00 sll	t3,t3,0
  151: 		DPRINTF(("IO4: Slot %x type %x\n", i, type));
  152: 
  153: 		if ((type & IO4_TYPE_MASK) == IO4_TYPE_VALUE)
[ 153] 0x900000001fc143e0:  31 ef 00 0f andi	t3,t3,0xf
[ 153] 0x900000001fc143e4:  11 f6 00 07 beq	t3,s6,0x900000001fc14404
[ 153] 0x900000001fc143e8:  00 00 00 21 nada
  154: 		    cfginfo->ecfg_board[i].eb_type = EVTYPE_IO4;
  155: 		else 
  156: 	 	    cfginfo->ecfg_board[i].eb_type = EVTYPE_WEIRDIO;	
[ 156] 0x900000001fc143ec:  a0 e6 00 66 sb	a2,102(a3)
[ 156] 0x900000001fc143f0:  a0 e0 00 68 sb	zero,104(a3)
[ 156] 0x900000001fc143f4:  24 18 00 20 li	t8,32
[ 156] 0x900000001fc143f8:  a0 f8 00 64 sb	t8,100(a3)
[ 156] 0x900000001fc143fc:  10 00 00 28 b		0x900000001fc144a0
[ 156] 0x900000001fc14400:  25 08 00 01 addiu	a4,a4,1
[ 154] 0x900000001fc14404:  a0 e6 00 66 sb	a2,102(a3)
[ 154] 0x900000001fc14408:  a0 e0 00 68 sb	zero,104(a3)
[ 154] 0x900000001fc1440c:  24 19 00 21 li	t9,33
[ 154] 0x900000001fc14410:  a0 f9 00 64 sb	t9,100(a3)
[ 154] 0x900000001fc14414:  10 00 00 22 b		0x900000001fc144a0
[ 154] 0x900000001fc14418:  25 08 00 01 addiu	a4,a4,1
[ 141] 0x900000001fc1441c:  dd 21 00 00 ld	at,0(a5)
[ 141] 0x900000001fc14420:  00 01 08 00 sll	at,at,0
[ 143] 0x900000001fc14424:  10 37 00 07 beq	at,s7,0x900000001fc14444
[ 143] 0x900000001fc14428:  00 00 00 21 nada
[ 146] 0x900000001fc1442c:  a0 e6 00 66 sb	a2,102(a3)
[ 146] 0x900000001fc14430:  a0 e0 00 68 sb	zero,104(a3)
[ 146] 0x900000001fc14434:  24 01 00 30 li	at,48
[ 146] 0x900000001fc14438:  a0 e1 00 64 sb	at,100(a3)
[ 146] 0x900000001fc1443c:  10 00 00 18 b		0x900000001fc144a0
[ 146] 0x900000001fc14440:  25 08 00 01 addiu	a4,a4,1
[ 144] 0x900000001fc14444:  a0 e6 00 66 sb	a2,102(a3)
[ 144] 0x900000001fc14448:  a0 e0 00 68 sb	zero,104(a3)
[ 144] 0x900000001fc1444c:  24 01 00 31 li	at,49
[ 144] 0x900000001fc14450:  a0 e1 00 64 sb	at,100(a3)
[ 144] 0x900000001fc14454:  10 00 00 12 b		0x900000001fc144a0
[ 144] 0x900000001fc14458:  25 08 00 01 addiu	a4,a4,1
[ 144] 0x900000001fc1445c:  03 35 58 2d daddu	a7,t9,s5
[ 129] 0x900000001fc14460:  dd 21 00 00 ld	at,0(a5)
[ 129] 0x900000001fc14464:  00 01 08 00 sll	at,at,0
[ 131] 0x900000001fc14468:  10 26 00 07 beq	at,a2,0x900000001fc14488
[ 131] 0x900000001fc1446c:  00 00 00 21 nada
[ 134] 0x900000001fc14470:  a0 fe 00 64 sb	s8,100(a3)
[ 134] 0x900000001fc14474:  dd 61 00 00 ld	at,0(a7)
[ 134] 0x900000001fc14478:  a0 e1 00 65 sb	at,101(a3)
[ 134] 0x900000001fc1447c:  a0 e6 00 66 sb	a2,102(a3)
[ 134] 0x900000001fc14480:  10 00 00 06 b		0x900000001fc1449c
[ 134] 0x900000001fc14484:  a0 e0 00 68 sb	zero,104(a3)
[ 132] 0x900000001fc14488:  a0 ff 00 64 sb	ra,100(a3)
[ 132] 0x900000001fc1448c:  dd 61 00 00 ld	at,0(a7)
[ 132] 0x900000001fc14490:  a0 e1 00 65 sb	at,101(a3)
[ 132] 0x900000001fc14494:  a0 e6 00 66 sb	a2,102(a3)
[ 132] 0x900000001fc14498:  a0 e0 00 68 sb	zero,104(a3)
[ 108] 0x900000001fc1449c:  25 08 00 01 addiu	a4,a4,1
[ 108] 0x900000001fc144a0:  01 03 58 04 sllv	a7,v1,a4
[ 108] 0x900000001fc144a4:  00 ab 60 24 and	t0,a1,a7
[ 108] 0x900000001fc144a8:  00 08 08 3c dsll32	at,a4,0
[ 108] 0x900000001fc144ac:  00 01 08 3e dsrl32	at,at,0
[ 108] 0x900000001fc144b0:  00 01 20 b8 dsll	a0,at,2
[ 108] 0x900000001fc144b4:  00 01 11 38 dsll	v0,at,4
[ 108] 0x900000001fc144b8:  00 01 09 f8 dsll	at,at,7
[ 108] 0x900000001fc144bc:  00 44 10 2d daddu	v0,v0,a0
[ 108] 0x900000001fc144c0:  15 10 ff b1 bne	a4,s0,0x900000001fc14388
[ 108] 0x900000001fc144c4:  00 22 c8 2f dsubu	t9,at,v0
[ 108] 0x900000001fc144c8:  df b4 00 30 ld	s4,48(sp)
[ 108] 0x900000001fc144cc:  df b2 00 40 ld	s2,64(sp)
[ 108] 0x900000001fc144d0:  df b6 00 20 ld	s6,32(sp)
[ 108] 0x900000001fc144d4:  df b3 00 38 ld	s3,56(sp)
[ 108] 0x900000001fc144d8:  df b0 00 50 ld	s0,80(sp)
[ 108] 0x900000001fc144dc:  df b7 00 18 ld	s7,24(sp)
  157: 	    }
  158: 
  159: 	    brd->eb_enabled  = 1;
  160: 	    brd->eb_diagval  = EVDIAG_PASSED;
  161: 	} 		/* end if */
  162:     }		/* end for */
  163: 
  164:     /* Get the debug switch settings from the system controller and
  165:      * store them in the config structure
  166:      */
  167: 
  168:     cfginfo->ecfg_debugsw = (uint)sysctlr_getdebug();
[ 168] 0x900000001fc144e0:  0f f0 11 8a jal		sysctlr_getdebug
[ 168] 0x900000001fc144e4:  00 00 00 21 nada
[ 168] 0x900000001fc144e8:  df b5 00 28 ld	s5,40(sp)
[ 168] 0x900000001fc144ec:  df bf 00 08 ld	ra,8(sp)
[ 168] 0x900000001fc144f0:  00 02 f0 00 sll	s8,v0,0
  169: }
[ 169] 0x900000001fc144f4:  ae 3e 06 d8 sw	s8,1752(s1)
[ 169] 0x900000001fc144f8:  df b1 00 48 ld	s1,72(sp)
[ 169] 0x900000001fc144fc:  df be 00 10 ld	s8,16(sp)
[ 169] 0x900000001fc14500:  03 e0 00 08 jr	ra
[ 169] 0x900000001fc14504:  67 bd 00 60 daddiu	sp,sp,96
  170: 
  171: 
  172: /*
  173:  * set_timeouts()
  174:  * 	Goes through all of the boards in the system and ensures that
  175:  *	the various timeout registers are set to the correct value.
  176:  */
  177: 
  178: void
  179: set_timeouts(evcfginfo_t *cfginfo)
  180: {
set_timeouts:
[ 180] 0x900000001fc14508:  67 bd ff a0 daddiu	sp,sp,-96
[ 180] 0x900000001fc1450c:  ff b0 00 50 sd	s0,80(sp)
[ 180] 0x900000001fc14510:  00 80 80 25 move	s0,a0
  181:     int 	slot;
  182:     evbrdinfo_t	*brd;
  183: 
  184:     for (slot = 0; slot < EV_MAX_SLOTS; slot++) {
[ 184] 0x900000001fc14514:  ff b1 00 48 sd	s1,72(sp)
[ 184] 0x900000001fc14518:  00 00 88 25 move	s1,zero
[ 184] 0x900000001fc1451c:  ff b3 00 38 sd	s3,56(sp)
[ 184] 0x900000001fc14520:  24 13 00 13 li	s3,19
[ 184] 0x900000001fc14524:  ff b5 00 28 sd	s5,40(sp)
[ 184] 0x900000001fc14528:  24 15 00 21 li	s5,33
[ 184] 0x900000001fc1452c:  ff b7 00 18 sd	s7,24(sp)
[ 184] 0x900000001fc14530:  24 17 00 31 li	s7,49
[ 184] 0x900000001fc14534:  3c 01 90 00 lui	at,0x9000
[ 184] 0x900000001fc14538:  60 23 00 00 daddi	v1,at,0
[ 184] 0x900000001fc1453c:  3c 01 90 00 lui	at,0x9000
[ 184] 0x900000001fc14540:  60 21 00 00 daddi	at,at,0
[ 184] 0x900000001fc14544:  3c 02 1f c2 lui	v0,0x1fc2
[ 184] 0x900000001fc14548:  60 44 eb 90 daddi	a0,v0,-5232
[ 184] 0x900000001fc1454c:  3c 02 1f c2 lui	v0,0x1fc2
[ 184] 0x900000001fc14550:  60 42 eb b0 daddi	v0,v0,-5200
[ 184] 0x900000001fc14554:  3c 05 00 4c lui	a1,0x4c
[ 184] 0x900000001fc14558:  ff b4 00 30 sd	s4,48(sp)
[ 184] 0x900000001fc1455c:  34 b4 4b 40 ori	s4,a1,0x4b40
[ 184] 0x900000001fc14560:  3c 05 00 3d lui	a1,0x3d
[ 184] 0x900000001fc14564:  ff b6 00 20 sd	s6,32(sp)
[ 184] 0x900000001fc14568:  34 b6 09 00 ori	s6,a1,0x900
[ 184] 0x900000001fc1456c:  00 03 18 3c dsll32	v1,v1,0
[ 184] 0x900000001fc14570:  ff b2 00 40 sd	s2,64(sp)
[ 184] 0x900000001fc14574:  66 12 06 c0 daddiu	s2,s0,1728
[ 184] 0x900000001fc14578:  00 01 08 3c dsll32	at,at,0
[ 184] 0x900000001fc1457c:  ff bf 00 58 sd	ra,88(sp)
[ 184] 0x900000001fc14580:  00 64 c8 2c dadd	t9,v1,a0
[ 184] 0x900000001fc14584:  ff be 00 10 sd	s8,16(sp)
[ 184] 0x900000001fc14588:  00 22 f0 2c dadd	s8,at,v0
  185: 	brd = &(cfginfo->ecfg_board[slot]);
  186: 
  187: 
  188: 	switch (brd->eb_type) {
[ 188] 0x900000001fc1458c:  92 05 00 64 lbu	a1,100(s0)
[ 188] 0x900000001fc14590:  66 10 00 6c daddiu	s0,s0,108
[ 188] 0x900000001fc14594:  10 a0 00 19 beq	a1,zero,0x900000001fc145fc
[ 188] 0x900000001fc14598:  00 00 00 21 nada
[ 185] 0x900000001fc1459c:  10 b3 00 17 beq	a1,s3,0x900000001fc145fc
[ 185] 0x900000001fc145a0:  00 00 00 21 nada
[ 185] 0x900000001fc145a4:  14 b5 00 09 bne	a1,s5,0x900000001fc145cc
[ 185] 0x900000001fc145a8:  00 00 00 21 nada
  189: 	  case EVTYPE_IP25:
  190: 	    /* Already done in startup code -- see entry.s */
  191: 	    break;
  192: 
  193: 	  case EVTYPE_MC3:
  194: 	    EV_SET_CONFIG(slot, MC3_DRSCTIMEOUT, RSC_TIMEOUT);
  195: 	    break;
  196: 
  197: 	  case EVTYPE_IO4:
  198: 	    EV_SET_CONFIG(slot, IO4_CONF_RTIMEOUT, RSC_TIMEOUT);
[ 198] 0x900000001fc145ac:  00 11 32 c0 sll	a2,s1,11
[ 198] 0x900000001fc145b0:  df 27 00 58 ld	a3,88(t9)
[ 198] 0x900000001fc145b4:  00 c7 38 2d daddu	a3,a2,a3
[ 198] 0x900000001fc145b8:  fc f4 00 00 sd	s4,0(a3)
  199: 	    EV_SET_CONFIG(slot, IO4_CONF_ETIMEOUT, EBUS_TIMEOUT);
[ 199] 0x900000001fc145bc:  df 27 00 60 ld	a3,96(t9)
[ 199] 0x900000001fc145c0:  00 c7 30 2d daddu	a2,a2,a3
  200: 	    break;
[ 200] 0x900000001fc145c4:  10 00 00 0d b		0x900000001fc145fc
[ 200] 0x900000001fc145c8:  fc d6 00 00 sd	s6,0(a2)
[ 200] 0x900000001fc145cc:  14 b7 00 06 bne	a1,s7,0x900000001fc145e8
[ 200] 0x900000001fc145d0:  00 00 00 21 nada
[ 194] 0x900000001fc145d4:  00 11 42 c0 sll	a4,s1,11
[ 194] 0x900000001fc145d8:  df 29 00 50 ld	a5,80(t9)
[ 194] 0x900000001fc145dc:  01 09 40 2d daddu	a4,a4,a5
[ 195] 0x900000001fc145e0:  10 00 00 06 b		0x900000001fc145fc
[ 195] 0x900000001fc145e4:  fd 14 00 00 sd	s4,0(a4)
  201: 
  202: 	  case EVTYPE_EMPTY:
  203: 	    /* Don't do anything--just want to avoid dropping into
  204: 	       next case */
  205: 	    break;
  206: 
  207: 	  default:
  208: 	    ccloprintf("Unknown board type (%d) encountered (slot %d).\n", 
[ 208] 0x900000001fc145e8:  ff b9 00 08 sd	t9,8(sp)
[ 208] 0x900000001fc145ec:  02 20 30 25 move	a2,s1
[ 208] 0x900000001fc145f0:  0f f0 2c fa jal		ccloprintf
[ 208] 0x900000001fc145f4:  03 c0 20 25 move	a0,s8
  209: 		       brd->eb_type, slot);
  210: 	    break;
[ 210] 0x900000001fc145f8:  df b9 00 08 ld	t9,8(sp)
[ 184] 0x900000001fc145fc:  16 12 ff e3 bne	s0,s2,0x900000001fc1458c
[ 184] 0x900000001fc14600:  26 31 00 01 addiu	s1,s1,1
[ 184] 0x900000001fc14604:  df b3 00 38 ld	s3,56(sp)
[ 184] 0x900000001fc14608:  df b1 00 48 ld	s1,72(sp)
[ 184] 0x900000001fc1460c:  df b5 00 28 ld	s5,40(sp)
[ 184] 0x900000001fc14610:  df bf 00 58 ld	ra,88(sp)
  211: 	}
  212:     }
  213: 
  214:     /* send sync interupt to all *A chips. */
  215:     SD_LO(EV_SENDINT, SYNC_DEST);
[ 215] 0x900000001fc14614:  df 2b 00 68 ld	a7,104(t9)
  216: 
  217: }
[ 217] 0x900000001fc14618:  df b7 00 18 ld	s7,24(sp)
[ 217] 0x900000001fc1461c:  df be 00 10 ld	s8,16(sp)
[ 217] 0x900000001fc14620:  df b6 00 20 ld	s6,32(sp)
[ 217] 0x900000001fc14624:  df b4 00 30 ld	s4,48(sp)
[ 217] 0x900000001fc14628:  df b2 00 40 ld	s2,64(sp)
[ 217] 0x900000001fc1462c:  24 0a 00 50 li	a6,80
[ 217] 0x900000001fc14630:  df b0 00 50 ld	s0,80(sp)
[ 217] 0x900000001fc14634:  fd 6a 00 00 sd	a6,0(a7)
[ 217] 0x900000001fc14638:  03 e0 00 08 jr	ra
[ 217] 0x900000001fc1463c:  67 bd 00 60 daddiu	sp,sp,96
  218: 
  219: 
  220: /*
  221:  * init_inventory()
  222:  *	Reads the NVRAM and fills in the inventory and virtual
  223:  *	adapter fields for all of the boards in the system. This
  224:  * 	also sets up board enable  value. This needs to be called
  225:  *	before the diagnostic and initialization routines for 
  226:  *	specific boards are invoked.
  227:  */
  228: 
  229: int
  230: init_inventory(evcfginfo_t *cfginfo, uint nv_valid)
  231: {
init_inventory:
[ 231] 0x900000001fc14640:  67 bd fe f0 daddiu	sp,sp,-272
[ 231] 0x900000001fc14644:  ff b6 00 60 sd	s6,96(sp)
[ 231] 0x900000001fc14648:  00 a0 b0 25 move	s6,a1
  232:     uint 	slot;		/* Slot containing board being inited */
  233:     uint	unit;		/* Unit number for iterating */	
  234:     evbrdinfo_t *brd;		/* Pointer for dereferencing */
  235:     jmp_buf	fault_buf;	/* Buffer for jumping if a fault occurs */
  236:     unsigned	*old_buf;	/* Previous fault buffer value */
  237:     uint	mult_exc = 0;	/* Flag for multiple exceptions */
  238: 
  239:     /* Set up an exception handler.  If something goes wrong while
  240:      * we're trying to set up the inventory, we'll jump back to here
  241:      * and clean up after ourselves.  We do this by making the nvram
  242:      * look invalid.
  243:      */
  244:     if (setfault(fault_buf, &old_buf)) {
[ 244] 0x900000001fc1464c:  67 a5 00 00 daddiu	a1,sp,0
[ 244] 0x900000001fc14650:  ff a4 00 10 sd	a0,16(sp)
[ 244] 0x900000001fc14654:  ff bf 00 48 sd	ra,72(sp)
[ 244] 0x900000001fc14658:  0f f0 18 7f jal		setfault
[ 244] 0x900000001fc1465c:  67 a4 00 a0 daddiu	a0,sp,160
[ 244] 0x900000001fc14660:  ff b7 00 58 sd	s7,88(sp)
[ 244] 0x900000001fc14664:  3c 01 90 00 lui	at,0x9000
[ 244] 0x900000001fc14668:  ff b3 00 78 sd	s3,120(sp)
[ 244] 0x900000001fc1466c:  60 21 00 00 daddi	at,at,0
[ 244] 0x900000001fc14670:  3c 03 1f c2 lui	v1,0x1fc2
[ 244] 0x900000001fc14674:  ff b2 00 80 sd	s2,128(sp)
[ 244] 0x900000001fc14678:  60 63 eb 90 daddi	v1,v1,-5232
[ 244] 0x900000001fc1467c:  00 01 08 3c dsll32	at,at,0
[ 244] 0x900000001fc14680:  ff b0 00 90 sd	s0,144(sp)
[ 244] 0x900000001fc14684:  00 23 80 2c dadd	s0,at,v1
[ 244] 0x900000001fc14688:  ff b1 00 88 sd	s1,136(sp)
[ 244] 0x900000001fc1468c:  ff b4 00 70 sd	s4,112(sp)
[ 244] 0x900000001fc14690:  10 40 00 04 beq	v0,zero,0x900000001fc146a4
[ 244] 0x900000001fc14694:  ff b5 00 68 sd	s5,104(sp)
  245: 	if (mult_exc) {
  246: 	    loprintf("*** Multiple exceptions while initializing inventory.\n");
  247: 	    restorefault(old_buf);
  248: 	    return -1;
  249: 	} else 
  250: 	    mult_exc = 1;
  251:  
  252: 	loprintf("*** Error occurred while reading NVRAM -- using defaults.\n");
[ 252] 0x900000001fc14698:  0f f0 2c e3 jal		loprintf
[ 252] 0x900000001fc1469c:  66 04 00 a8 daddiu	a0,s0,168
  253: 	nv_valid = 0;
[ 253] 0x900000001fc146a0:  00 00 b0 25 move	s6,zero
  254:     }
  255: 
  256:     /* Switch off nv_valid if it the valid inventory flag isn't set */
  257:     if (nv_valid) 
[ 257] 0x900000001fc146a4:  ff be 00 50 sd	s8,80(sp)
[ 257] 0x900000001fc146a8:  12 c0 00 08 beq	s6,zero,0x900000001fc146cc
[ 257] 0x900000001fc146ac:  24 17 00 01 li	s7,1
  258: 	if (get_nvreg(NVOFF_INVENT_VALID) != INVENT_VALID) 
[ 258] 0x900000001fc146b0:  0f f0 2f fa jal		get_nvreg
[ 258] 0x900000001fc146b4:  24 04 01 14 li	a0,276
  259: 	    nv_valid = 0;
[ 259] 0x900000001fc146b8:  38 46 00 4a xori	a2,v0,0x4a
[ 259] 0x900000001fc146bc:  00 06 b0 0b movn	s6,zero,a2
[ 259] 0x900000001fc146c0:  00 00 00 21 nada
[ 259] 0x900000001fc146c4:  00 00 00 21 nada
[ 259] 0x900000001fc146c8:  00 00 00 21 nada
  260: 
  261:     /* Iterate through all the boards and try to read in the
  262:      * appropriate configuration info.
  263:      */
  264:     for (slot = 0; slot < EV_MAX_SLOTS; slot++) {
[ 264] 0x900000001fc146cc:  ff a0 00 18 sd	zero,24(sp)
[ 264] 0x900000001fc146d0:  df a8 00 18 ld	a4,24(sp)
[ 264] 0x900000001fc146d4:  66 07 00 e8 daddiu	a3,s0,232
[ 264] 0x900000001fc146d8:  00 08 40 3c dsll32	a4,a4,0
[ 264] 0x900000001fc146dc:  ff a0 00 28 sd	zero,40(sp)
[ 264] 0x900000001fc146e0:  00 08 40 3e dsrl32	a4,a4,0
[ 264] 0x900000001fc146e4:  ff a7 00 20 sd	a3,32(sp)
[ 264] 0x900000001fc146e8:  24 07 01 15 li	a3,277
[ 264] 0x900000001fc146ec:  ff a7 00 30 sd	a3,48(sp)
[ 264] 0x900000001fc146f0:  24 07 01 18 li	a3,280
[ 264] 0x900000001fc146f4:  ff a7 00 38 sd	a3,56(sp)
[ 264] 0x900000001fc146f8:  24 07 02 d8 li	a3,728
[ 264] 0x900000001fc146fc:  24 1e 00 fe li	s8,254
[ 264] 0x900000001fc14700:  ff a7 00 40 sd	a3,64(sp)
[ 264] 0x900000001fc14704:  00 08 50 b8 dsll	a6,a4,2
  265: 	brd = &cfginfo->ecfg_board[slot];
[ 265] 0x900000001fc14708:  00 08 49 38 dsll	a5,a4,4
[ 265] 0x900000001fc1470c:  00 08 41 f8 dsll	a4,a4,7
[ 265] 0x900000001fc14710:  01 2a 48 2d daddu	a5,a5,a6
  266: 
  267: 	if (nv_valid) {
[ 267] 0x900000001fc14714:  01 09 48 2f dsubu	a5,a4,a5
[ 267] 0x900000001fc14718:  df a8 00 10 ld	a4,16(sp)
[ 267] 0x900000001fc1471c:  16 c0 00 1b bne	s6,zero,0x900000001fc1478c
[ 267] 0x900000001fc14720:  01 09 a8 2d daddu	s5,a4,a5
  268: 
  269: 	    brd->eb_inventory = INV_READ(slot, INV_TYPE);
  270: 
  271:  	    /* We don't want to mess with the enable and diagval fields
  272: 	     * if it looks like the board currently in the slot doesn't
  273: 	     * correspond to the NVRAM
  274: 	     */
  275: 	    if (brd->eb_inventory == brd->eb_type) {
  276: 		brd->eb_diagval = 0; 
  277: 		brd->eb_enabled  = INV_READ(slot, INV_ENABLE);
  278: 	    } else if (brd->eb_type == EVTYPE_EMPTY) {
  279: 		brd->eb_diagval = 0;
  280: 		brd->eb_enabled  = 0;
  281: 	    } else {
  282: 		brd->eb_diagval = EVDIAG_PASSED;
  283: 		brd->eb_enabled  = 1;
  284: 	    }
  285: 
  286: 	} else {
  287: 
  288: 	    /* NVRAM is broken.  We take our best guess and hope
  289: 	     * that everything is okay.
  290: 	     */
  291: 	    if (brd->eb_type != EVTYPE_EMPTY) {
[ 291] 0x900000001fc14724:  92 a5 00 64 lbu	a1,100(s5)
[ 291] 0x900000001fc14728:  14 a0 00 0d bne	a1,zero,0x900000001fc14760
[ 291] 0x900000001fc1472c:  00 00 00 21 nada
  292: 		brd->eb_inventory = brd->eb_type;
  293: 		brd->eb_diagval   = EVDIAG_PASSED;
  294: 		brd->eb_enabled   = 1;
  295: 	    } else {
  296: 		brd->eb_inventory = EVTYPE_EMPTY;
[ 296] 0x900000001fc14730:  a2 a0 00 67 sb	zero,103(s5)
  297: 		brd->eb_diagval	  = EVDIAG_NOTFOUND;
[ 297] 0x900000001fc14734:  df ab 00 28 ld	a7,40(sp)
[ 297] 0x900000001fc14738:  24 0c 00 ff li	t0,255
[ 297] 0x900000001fc1473c:  a2 a0 00 66 sb	zero,102(s5)
[ 297] 0x900000001fc14740:  92 a5 00 64 lbu	a1,100(s5)
[ 297] 0x900000001fc14744:  25 73 01 19 addiu	s3,a7,281
[ 297] 0x900000001fc14748:  25 74 01 33 addiu	s4,a7,307
[ 297] 0x900000001fc1474c:  a2 ac 00 68 sb	t0,104(s5)
[ 297] 0x900000001fc14750:  25 72 01 1b addiu	s2,a7,283
[ 297] 0x900000001fc14754:  00 00 88 25 move	s1,zero
[ 297] 0x900000001fc14758:  10 00 00 33 b		0x900000001fc14828
[ 297] 0x900000001fc1475c:  df b0 00 28 ld	s0,40(sp)
[ 292] 0x900000001fc14760:  a2 a5 00 67 sb	a1,103(s5)
[ 293] 0x900000001fc14764:  df ad 00 28 ld	t1,40(sp)
[ 293] 0x900000001fc14768:  a2 a0 00 68 sb	zero,104(s5)
[ 293] 0x900000001fc1476c:  00 00 88 25 move	s1,zero
[ 293] 0x900000001fc14770:  25 b3 01 19 addiu	s3,t1,281
[ 293] 0x900000001fc14774:  25 b4 01 33 addiu	s4,t1,307
[ 293] 0x900000001fc14778:  a2 b7 00 66 sb	s7,102(s5)
[ 293] 0x900000001fc1477c:  92 a5 00 64 lbu	a1,100(s5)
[ 293] 0x900000001fc14780:  25 b2 01 1b addiu	s2,t1,283
[ 293] 0x900000001fc14784:  10 00 00 28 b		0x900000001fc14828
[ 293] 0x900000001fc14788:  df b0 00 28 ld	s0,40(sp)
[ 269] 0x900000001fc1478c:  0f f0 2f fa jal		get_nvreg
[ 269] 0x900000001fc14790:  df a4 00 30 ld	a0,48(sp)
[ 269] 0x900000001fc14794:  a2 a2 00 67 sb	v0,103(s5)
[ 275] 0x900000001fc14798:  92 a5 00 64 lbu	a1,100(s5)
[ 275] 0x900000001fc1479c:  92 ae 00 67 lbu	t2,103(s5)
[ 275] 0x900000001fc147a0:  df a4 00 38 ld	a0,56(sp)
[ 275] 0x900000001fc147a4:  11 c5 00 16 beq	t2,a1,0x900000001fc14800
[ 275] 0x900000001fc147a8:  00 00 00 21 nada
[ 278] 0x900000001fc147ac:  df b0 00 28 ld	s0,40(sp)
[ 278] 0x900000001fc147b0:  50 a0 00 0b beql	a1,zero,0x900000001fc147e0
[ 278] 0x900000001fc147b4:  00 00 88 25 move	s1,zero
[ 283] 0x900000001fc147b8:  00 00 88 25 move	s1,zero
[ 282] 0x900000001fc147bc:  a2 a0 00 68 sb	zero,104(s5)
[ 282] 0x900000001fc147c0:  26 13 01 19 addiu	s3,s0,281
[ 282] 0x900000001fc147c4:  26 14 01 33 addiu	s4,s0,307
[ 282] 0x900000001fc147c8:  26 12 01 1b addiu	s2,s0,283
[ 282] 0x900000001fc147cc:  a2 b7 00 66 sb	s7,102(s5)
[ 282] 0x900000001fc147d0:  92 a5 00 64 lbu	a1,100(s5)
[ 282] 0x900000001fc147d4:  10 00 00 14 b		0x900000001fc14828
[ 282] 0x900000001fc147d8:  df b0 00 28 ld	s0,40(sp)
[ 280] 0x900000001fc147dc:  00 00 88 25 move	s1,zero
[ 279] 0x900000001fc147e0:  a2 a0 00 68 sb	zero,104(s5)
[ 279] 0x900000001fc147e4:  26 13 01 19 addiu	s3,s0,281
[ 279] 0x900000001fc147e8:  26 14 01 33 addiu	s4,s0,307
[ 279] 0x900000001fc147ec:  26 12 01 1b addiu	s2,s0,283
[ 279] 0x900000001fc147f0:  a2 a0 00 66 sb	zero,102(s5)
[ 279] 0x900000001fc147f4:  92 a5 00 64 lbu	a1,100(s5)
[ 279] 0x900000001fc147f8:  10 00 00 0b b		0x900000001fc14828
[ 279] 0x900000001fc147fc:  df b0 00 28 ld	s0,40(sp)
[ 276] 0x900000001fc14800:  a2 a0 00 68 sb	zero,104(s5)
[ 276] 0x900000001fc14804:  0f f0 2f fa jal		get_nvreg
[ 276] 0x900000001fc14808:  df b0 00 28 ld	s0,40(sp)
[ 276] 0x900000001fc1480c:  00 00 88 25 move	s1,zero
[ 276] 0x900000001fc14810:  26 13 01 19 addiu	s3,s0,281
[ 276] 0x900000001fc14814:  92 a5 00 64 lbu	a1,100(s5)
[ 276] 0x900000001fc14818:  26 12 01 1b addiu	s2,s0,283
[ 276] 0x900000001fc1481c:  26 14 01 33 addiu	s4,s0,307
[ 276] 0x900000001fc14820:  a2 a2 00 66 sb	v0,102(s5)
[ 276] 0x900000001fc14824:  df b0 00 28 ld	s0,40(sp)
  298: 		brd->eb_enabled   = 0;
  299: 	    }	
  300: 	}    
  301:      
  302: 	switch (brd->eb_type) {
[ 302] 0x900000001fc14828:  10 a0 00 70 beq	a1,zero,0x900000001fc149ec
[ 302] 0x900000001fc1482c:  df a7 00 28 ld	a3,40(sp)
[ 302] 0x900000001fc14830:  24 0f 00 13 li	t3,19
[ 302] 0x900000001fc14834:  54 af 00 23 bnel	a1,t3,0x900000001fc148c4
[ 302] 0x900000001fc14838:  24 06 00 21 li	a2,33
  303: 	  case EVTYPE_IP25:
  304: 	    for (unit = 0; unit < EV_CPU_PER_BOARD; unit++) {
[ 304] 0x900000001fc1483c:  00 00 88 25 move	s1,zero
[ 304] 0x900000001fc14840:  26 13 01 19 addiu	s3,s0,281
[ 304] 0x900000001fc14844:  26 12 01 1b addiu	s2,s0,283
[ 304] 0x900000001fc14848:  26 14 01 27 addiu	s4,s0,295
[ 304] 0x900000001fc1484c:  00 11 c0 3c dsll32	t8,s1,0
  305: 		evcpucfg_t *cpu = &(brd->eb_cpuarr[unit]);
  306: 
  307: 		if (nv_valid && (brd->eb_type == brd->eb_inventory)) {
[ 307] 0x900000001fc14850:  00 18 c7 3a dsrl	t8,t8,28
[ 307] 0x900000001fc14854:  12 c0 00 05 beq	s6,zero,0x900000001fc1486c
[ 307] 0x900000001fc14858:  02 b8 80 2d daddu	s0,s5,t8
[ 307] 0x900000001fc1485c:  92 b9 00 64 lbu	t9,100(s5)
[ 307] 0x900000001fc14860:  92 bf 00 67 lbu	ra,103(s5)
[ 307] 0x900000001fc14864:  13 3f 00 08 beq	t9,ra,0x900000001fc14888
[ 307] 0x900000001fc14868:  00 00 00 21 nada
[ 307] 0x900000001fc1486c:  26 52 00 03 addiu	s2,s2,3
  308: 		    cpu->cpu_inventory = INV_READU(slot, unit, INVU_TYPE);
  309: 		    cpu->cpu_diagval   = EVDIAG_NOT_SET;
  310: 		    cpu->cpu_enable    = INV_READU(slot, unit, INVU_ENABLE);
  311: 		} else {
  312: 		    cpu->cpu_inventory = 1;
[ 312] 0x900000001fc14870:  a2 17 00 0a sb	s7,10(s0)
  313: 		    cpu->cpu_diagval   = EVDIAG_NOT_SET;
[ 313] 0x900000001fc14874:  a2 1e 00 0b sb	s8,11(s0)
[ 313] 0x900000001fc14878:  26 31 00 01 addiu	s1,s1,1
[ 313] 0x900000001fc1487c:  a2 17 00 09 sb	s7,9(s0)
[ 313] 0x900000001fc14880:  10 00 00 0b b		0x900000001fc148b0
[ 313] 0x900000001fc14884:  26 73 00 03 addiu	s3,s3,3
[ 308] 0x900000001fc14888:  0f f0 2f fa jal		get_nvreg
[ 308] 0x900000001fc1488c:  02 60 20 25 move	a0,s3
[ 308] 0x900000001fc14890:  a2 02 00 0a sb	v0,10(s0)
[ 309] 0x900000001fc14894:  a2 1e 00 0b sb	s8,11(s0)
[ 309] 0x900000001fc14898:  02 40 20 25 move	a0,s2
[ 309] 0x900000001fc1489c:  0f f0 2f fa jal		get_nvreg
[ 309] 0x900000001fc148a0:  26 31 00 01 addiu	s1,s1,1
[ 309] 0x900000001fc148a4:  26 73 00 03 addiu	s3,s3,3
[ 309] 0x900000001fc148a8:  26 52 00 03 addiu	s2,s2,3
[ 309] 0x900000001fc148ac:  a2 02 00 09 sb	v0,9(s0)
[ 304] 0x900000001fc148b0:  56 54 ff e7 bnel	s2,s4,0x900000001fc14850
[ 304] 0x900000001fc148b4:  00 11 c0 3c dsll32	t8,s1,0
[ 304] 0x900000001fc148b8:  10 00 00 4d b		0x900000001fc149f0
[ 304] 0x900000001fc148bc:  df b9 00 38 ld	t9,56(sp)
[ 304] 0x900000001fc148c0:  24 06 00 21 li	a2,33
[ 304] 0x900000001fc148c4:  14 a6 00 25 bne	a1,a2,0x900000001fc1495c
[ 304] 0x900000001fc148c8:  24 0c 00 31 li	t0,49
  314: 		    cpu->cpu_enable    = 1;
  315: 		}
  316: 		DPRINTF(("CPU %x/%x: enable %x\n", 
  317: 			 slot, unit, cpu->cpu_enable));
  318: 	    } 
  319: 	    break;
  320: 
  321: 	  case EVTYPE_IO4:
  322: 	    for (unit = 0; unit < IO4_MAX_PADAPS; unit++) {
[ 322] 0x900000001fc148cc:  00 00 88 25 move	s1,zero
[ 322] 0x900000001fc148d0:  24 f3 01 19 addiu	s3,a3,281
[ 322] 0x900000001fc148d4:  24 f2 01 1b addiu	s2,a3,283
[ 322] 0x900000001fc148d8:  24 f4 01 33 addiu	s4,a3,307
[ 322] 0x900000001fc148dc:  00 11 40 3c dsll32	a4,s1,0
  323: 		evioacfg_t *ioa = &(brd->eb_ioarr[unit]);
[ 323] 0x900000001fc148e0:  00 08 40 3e dsrl32	a4,a4,0
[ 323] 0x900000001fc148e4:  00 08 48 b8 dsll	a5,a4,2
[ 323] 0x900000001fc148e8:  00 08 40 f8 dsll	a4,a4,3
  324: 		
  325: 		if (nv_valid && (brd->eb_type == brd->eb_inventory)) {
[ 325] 0x900000001fc148ec:  01 09 40 2d daddu	a4,a4,a5
[ 325] 0x900000001fc148f0:  12 c0 00 05 beq	s6,zero,0x900000001fc14908
[ 325] 0x900000001fc148f4:  02 a8 80 2d daddu	s0,s5,a4
[ 325] 0x900000001fc148f8:  92 aa 00 64 lbu	a6,100(s5)
[ 325] 0x900000001fc148fc:  92 ab 00 67 lbu	a7,103(s5)
[ 325] 0x900000001fc14900:  11 4b 00 08 beq	a6,a7,0x900000001fc14924
[ 325] 0x900000001fc14904:  00 00 00 21 nada
[ 325] 0x900000001fc14908:  26 52 00 03 addiu	s2,s2,3
  326: 		    ioa->ioa_inventory = INV_READU(slot, unit, INVU_TYPE);
  327: 		    ioa->ioa_diagval   = EVDIAG_PASSED;
  328: 		    ioa->ioa_enable    = INV_READU(slot, unit, INVU_ENABLE);
  329: 		} else {
  330: 		    ioa->ioa_inventory = 0;
[ 330] 0x900000001fc1490c:  a2 00 00 05 sb	zero,5(s0)
  331: 		    ioa->ioa_diagval   = EVDIAG_PASSED;
[ 331] 0x900000001fc14910:  a2 00 00 06 sb	zero,6(s0)
[ 331] 0x900000001fc14914:  26 31 00 01 addiu	s1,s1,1
[ 331] 0x900000001fc14918:  a2 17 00 04 sb	s7,4(s0)
[ 331] 0x900000001fc1491c:  10 00 00 0b b		0x900000001fc1494c
[ 331] 0x900000001fc14920:  26 73 00 03 addiu	s3,s3,3
[ 326] 0x900000001fc14924:  0f f0 2f fa jal		get_nvreg
[ 326] 0x900000001fc14928:  02 60 20 25 move	a0,s3
[ 326] 0x900000001fc1492c:  a2 02 00 05 sb	v0,5(s0)
[ 327] 0x900000001fc14930:  a2 00 00 06 sb	zero,6(s0)
[ 327] 0x900000001fc14934:  02 40 20 25 move	a0,s2
[ 327] 0x900000001fc14938:  0f f0 2f fa jal		get_nvreg
[ 327] 0x900000001fc1493c:  26 31 00 01 addiu	s1,s1,1
[ 327] 0x900000001fc14940:  26 73 00 03 addiu	s3,s3,3
[ 327] 0x900000001fc14944:  26 52 00 03 addiu	s2,s2,3
[ 327] 0x900000001fc14948:  a2 02 00 04 sb	v0,4(s0)
[ 322] 0x900000001fc1494c:  56 54 ff e4 bnel	s2,s4,0x900000001fc148e0
[ 322] 0x900000001fc14950:  00 11 40 3c dsll32	a4,s1,0
[ 322] 0x900000001fc14954:  10 00 00 26 b		0x900000001fc149f0
[ 322] 0x900000001fc14958:  df b9 00 38 ld	t9,56(sp)
[ 322] 0x900000001fc1495c:  14 ac 00 21 bne	a1,t0,0x900000001fc149e4
[ 322] 0x900000001fc14960:  00 00 00 21 nada
  332: 		    ioa->ioa_enable    = 1;
  333: 		}
  334: 	    }
  335: 	    break;
  336: 
  337:  	  case EVTYPE_MC3:
  338: 	    for (unit = 0; unit < MC3_NUM_BANKS; unit++) {
  339: 		evbnkcfg_t *bnk = &(brd->eb_banks[unit]);
[ 339] 0x900000001fc14964:  00 11 68 3c dsll32	t1,s1,0
[ 339] 0x900000001fc14968:  00 0d 68 3e dsrl32	t1,t1,0
[ 339] 0x900000001fc1496c:  00 0d 70 b8 dsll	t2,t1,2
[ 339] 0x900000001fc14970:  00 0d 68 f8 dsll	t1,t1,3
  340: 		if (nv_valid && (brd->eb_type == brd->eb_inventory)) {
[ 340] 0x900000001fc14974:  01 ae 68 2d daddu	t1,t1,t2
[ 340] 0x900000001fc14978:  12 c0 00 05 beq	s6,zero,0x900000001fc14990
[ 340] 0x900000001fc1497c:  02 ad 80 2d daddu	s0,s5,t1
[ 340] 0x900000001fc14980:  92 af 00 64 lbu	t3,100(s5)
[ 340] 0x900000001fc14984:  92 b8 00 67 lbu	t8,103(s5)
[ 340] 0x900000001fc14988:  11 f8 00 08 beq	t3,t8,0x900000001fc149ac
[ 340] 0x900000001fc1498c:  00 00 00 21 nada
[ 340] 0x900000001fc14990:  26 52 00 03 addiu	s2,s2,3
  341: 		    bnk->bnk_inventory = INV_READU(slot, unit, INVU_TYPE);
  342: 		    bnk->bnk_diagval   = EVDIAG_PASSED;
  343: 		    bnk->bnk_enable    = INV_READU(slot, unit, INVU_ENABLE);
  344: 		} else {
  345: 		    bnk->bnk_inventory = 0;
[ 345] 0x900000001fc14994:  a2 00 00 06 sb	zero,6(s0)
  346: 		    bnk->bnk_diagval   = EVDIAG_PASSED;
[ 346] 0x900000001fc14998:  a2 00 00 07 sb	zero,7(s0)
[ 346] 0x900000001fc1499c:  26 31 00 01 addiu	s1,s1,1
[ 346] 0x900000001fc149a0:  a2 17 00 05 sb	s7,5(s0)
[ 346] 0x900000001fc149a4:  10 00 00 0b b		0x900000001fc149d4
[ 346] 0x900000001fc149a8:  26 73 00 03 addiu	s3,s3,3
[ 341] 0x900000001fc149ac:  0f f0 2f fa jal		get_nvreg
[ 341] 0x900000001fc149b0:  02 60 20 25 move	a0,s3
[ 341] 0x900000001fc149b4:  a2 02 00 06 sb	v0,6(s0)
[ 342] 0x900000001fc149b8:  a2 00 00 07 sb	zero,7(s0)
[ 342] 0x900000001fc149bc:  02 40 20 25 move	a0,s2
[ 342] 0x900000001fc149c0:  0f f0 2f fa jal		get_nvreg
[ 342] 0x900000001fc149c4:  26 31 00 01 addiu	s1,s1,1
[ 342] 0x900000001fc149c8:  26 73 00 03 addiu	s3,s3,3
[ 342] 0x900000001fc149cc:  26 52 00 03 addiu	s2,s2,3
[ 342] 0x900000001fc149d0:  a2 02 00 05 sb	v0,5(s0)
[ 338] 0x900000001fc149d4:  56 54 ff e4 bnel	s2,s4,0x900000001fc14968
[ 338] 0x900000001fc149d8:  00 11 68 3c dsll32	t1,s1,0
[ 338] 0x900000001fc149dc:  10 00 00 04 b		0x900000001fc149f0
[ 338] 0x900000001fc149e0:  df b9 00 38 ld	t9,56(sp)
  347: 		    bnk->bnk_enable    = 1;
  348: 		}
  349: 
  350: 	    }
  351: 	    break;
  352: 	
  353: 	  case EVTYPE_EMPTY:
  354: 	    /* Place-holder which allows the empty slots to be ignored */
  355: 	    break;
  356: 
  357: 	  default:
  358: 	    loprintf("*** Warning: unexpected board type %d\n", brd->eb_type);
[ 358] 0x900000001fc149e4:  0f f0 2c e3 jal		loprintf
[ 358] 0x900000001fc149e8:  df a4 00 20 ld	a0,32(sp)
[ 264] 0x900000001fc149ec:  df b9 00 38 ld	t9,56(sp)
[ 264] 0x900000001fc149f0:  df bf 00 18 ld	ra,24(sp)
[ 264] 0x900000001fc149f4:  27 e2 00 01 addiu	v0,ra,1
[ 264] 0x900000001fc149f8:  df a1 00 28 ld	at,40(sp)
[ 264] 0x900000001fc149fc:  df bf 00 30 ld	ra,48(sp)
[ 264] 0x900000001fc14a00:  24 21 00 1c addiu	at,at,28
[ 264] 0x900000001fc14a04:  ff a2 00 18 sd	v0,24(sp)
[ 264] 0x900000001fc14a08:  df a8 00 18 ld	a4,24(sp)
[ 264] 0x900000001fc14a0c:  27 ff 00 1c addiu	ra,ra,28
[ 264] 0x900000001fc14a10:  00 08 40 3c dsll32	a4,a4,0
[ 264] 0x900000001fc14a14:  ff a1 00 28 sd	at,40(sp)
[ 264] 0x900000001fc14a18:  27 39 00 1c addiu	t9,t9,28
[ 264] 0x900000001fc14a1c:  00 08 40 3e dsrl32	a4,a4,0
[ 264] 0x900000001fc14a20:  ff bf 00 30 sd	ra,48(sp)
[ 264] 0x900000001fc14a24:  df bf 00 40 ld	ra,64(sp)
[ 264] 0x900000001fc14a28:  ff b9 00 38 sd	t9,56(sp)
[ 264] 0x900000001fc14a2c:  57 3f ff 36 bnel	t9,ra,0x900000001fc14708
[ 264] 0x900000001fc14a30:  00 08 50 b8 dsll	a6,a4,2
[ 264] 0x900000001fc14a34:  df b2 00 80 ld	s2,128(sp)
[ 264] 0x900000001fc14a38:  df b4 00 70 ld	s4,112(sp)
[ 264] 0x900000001fc14a3c:  df be 00 50 ld	s8,80(sp)
  359: 	    /* Bad stuff */
  360: 	    break;
  361: 	}
  362:     } 
  363: 
  364:     /* Make sure that the previous fault handler is restored */
  365:     restorefault(old_buf);
[ 365] 0x900000001fc14a40:  df b3 00 78 ld	s3,120(sp)
[ 365] 0x900000001fc14a44:  df b1 00 88 ld	s1,136(sp)
[ 365] 0x900000001fc14a48:  df b0 00 90 ld	s0,144(sp)
[ 365] 0x900000001fc14a4c:  0f f0 18 86 jal		restorefault
[ 365] 0x900000001fc14a50:  df a4 00 00 ld	a0,0(sp)
  366:     return 0;
[ 366] 0x900000001fc14a54:  df b7 00 58 ld	s7,88(sp)
[ 366] 0x900000001fc14a58:  df bf 00 48 ld	ra,72(sp)
[ 366] 0x900000001fc14a5c:  00 00 10 25 move	v0,zero
[ 366] 0x900000001fc14a60:  df b5 00 68 ld	s5,104(sp)
[ 366] 0x900000001fc14a64:  df b6 00 60 ld	s6,96(sp)
[ 366] 0x900000001fc14a68:  03 e0 00 08 jr	ra
[ 366] 0x900000001fc14a6c:  67 bd 01 10 daddiu	sp,sp,272
  367: }	
  368: 
  369: /*
  370:  * configure_cpus()
  371:  * 	Reads the IP0 register to determine which processors have
  372:  * 	sent us the "alive" interrrupt and prints a string indicating
  373:  *	that the processors are alive.  Processors which don't 
  374:  *	respond get their enable entry switched off in the evcfginfo
  375:  *	structure.
  376:  */
  377: 
  378: void
  379: configure_cpus(evcfginfo_t *info)
  380: {
configure_cpus:
[ 380] 0x900000001fc14a70:  67 bd fe f0 daddiu	sp,sp,-272
  381:     uint	ip0[4];		/* Contents of the IP registers */
  382:     uint	i;		/* Random index register */
  383:     uint 	c;		/* CPU index register */
  384:     evbrdinfo_t *brd;		/* Board information */ 
  385:     uint 	bit;		/* Mask selecting processor alive bit */
  386:     int		slot, slice;	/* bootmaster's position on the midplane */
  387:     uint 	vpid = 0;	/* CPUS virtual processor ID */
  388:     char	cpuinfo[EV_MAX_CPUS+1];
  389:     char	*currcpu = cpuinfo;
  390: 
  391:     /* First capture the IP register contents */
  392:     ip0[0] = LD_LO(EV_IP0);
[ 392] 0x900000001fc14a74:  3c 01 90 00 lui	at,0x9000
[ 392] 0x900000001fc14a78:  60 22 00 00 daddi	v0,at,0
[ 392] 0x900000001fc14a7c:  3c 01 1f c2 lui	at,0x1fc2
[ 392] 0x900000001fc14a80:  60 23 eb 90 daddi	v1,at,-5232
[ 392] 0x900000001fc14a84:  00 02 10 3c dsll32	v0,v0,0
[ 392] 0x900000001fc14a88:  00 43 10 2c dadd	v0,v0,v1
[ 392] 0x900000001fc14a8c:  34 01 ff ff ori	at,zero,0xffff
[ 392] 0x900000001fc14a90:  ff a4 00 60 sd	a0,96(sp)
[ 392] 0x900000001fc14a94:  24 08 00 20 li	a4,32
[ 392] 0x900000001fc14a98:  24 0a 00 04 li	a6,4
[ 392] 0x900000001fc14a9c:  dc 44 02 08 ld	a0,520(v0)
[ 392] 0x900000001fc14aa0:  00 01 2c 38 dsll	a1,at,16
[ 392] 0x900000001fc14aa4:  ff a2 00 68 sd	v0,104(sp)
[ 392] 0x900000001fc14aa8:  34 a5 ff ff ori	a1,a1,0xffff
[ 392] 0x900000001fc14aac:  dc 83 00 00 ld	v1,0(a0)
[ 392] 0x900000001fc14ab0:  00 65 18 24 and	v1,v1,a1
[ 392] 0x900000001fc14ab4:  00 03 18 00 sll	v1,v1,0
[ 392] 0x900000001fc14ab8:  af a3 00 00 sw	v1,0(sp)
  393:     ip0[1] = LD_HI(EV_IP0);
[ 393] 0x900000001fc14abc:  dc 43 00 08 ld	v1,8(v0)
[ 393] 0x900000001fc14ac0:  dc 84 00 00 ld	a0,0(a0)
[ 393] 0x900000001fc14ac4:  ff bf 00 b8 sd	ra,184(sp)
[ 393] 0x900000001fc14ac8:  00 83 20 24 and	a0,a0,v1
[ 393] 0x900000001fc14acc:  ff be 00 c0 sd	s8,192(sp)
[ 393] 0x900000001fc14ad0:  00 04 20 3e dsrl32	a0,a0,0
  394:     ip0[2] = LD_LO(EV_IP1);
[ 394] 0x900000001fc14ad4:  ff b7 00 c8 sd	s7,200(sp)
[ 394] 0x900000001fc14ad8:  00 04 20 00 sll	a0,a0,0
[ 394] 0x900000001fc14adc:  dc 42 02 10 ld	v0,528(v0)
[ 394] 0x900000001fc14ae0:  ff b5 00 d8 sd	s5,216(sp)
[ 394] 0x900000001fc14ae4:  af a4 00 04 sw	a0,4(sp)
[ 387] 0x900000001fc14ae8:  00 00 f0 25 move	s8,zero
  395:     ip0[3] = LD_HI(EV_IP1);
  396: 
  397:     DPRINTF(("configure_cpus: ip %x %x %x %x\n", 
  398: 	     ip0[0], ip0[1], ip0[2], ip0[3]));
  399: 
  400:     /* Make sure there aren't any extraneous interrupts which might 
  401:        confuse the bootmaster disable/rearbitrate checking code below. */
  402:     ip0[0] &= 0xffffff00;
  403: 
  404:     /* Clear out the cpuinfo character array */
  405:     for (i = 0; i < EV_MAX_CPUS; i++)
[ 405] 0x900000001fc14aec:  00 00 a8 25 move	s5,zero
[ 405] 0x900000001fc14af0:  26 a9 00 04 addiu	a5,s5,4
[ 405] 0x900000001fc14af4:  dc 44 00 00 ld	a0,0(v0)
[ 405] 0x900000001fc14af8:  24 01 00 04 li	at,4
[ 405] 0x900000001fc14afc:  ff b4 00 e0 sd	s4,224(sp)
[ 405] 0x900000001fc14b00:  00 85 20 24 and	a0,a0,a1
[ 405] 0x900000001fc14b04:  00 01 08 2d daddu	at,zero,at
[ 405] 0x900000001fc14b08:  ff b1 00 f8 sd	s1,248(sp)
[ 405] 0x900000001fc14b0c:  00 04 20 00 sll	a0,a0,0
[ 389] 0x900000001fc14b10:  67 b4 00 10 daddiu	s4,sp,16
[ 389] 0x900000001fc14b14:  ff b0 01 00 sd	s0,256(sp)
[ 389] 0x900000001fc14b18:  24 11 00 31 li	s1,49
[ 389] 0x900000001fc14b1c:  af a4 00 08 sw	a0,8(sp)
[ 395] 0x900000001fc14b20:  03 a0 80 25 move	s0,sp
[ 395] 0x900000001fc14b24:  02 a0 38 25 move	a3,s5
[ 395] 0x900000001fc14b28:  00 31 08 2b sltu	at,at,s1
[ 395] 0x900000001fc14b2c:  dc 42 00 00 ld	v0,0(v0)
[ 402] 0x900000001fc14b30:  ff b6 00 d0 sd	s6,208(sp)
[ 402] 0x900000001fc14b34:  00 43 10 24 and	v0,v0,v1
[ 402] 0x900000001fc14b38:  24 04 ff 00 li	a0,-256
[ 402] 0x900000001fc14b3c:  8f a3 00 00 lw	v1,0(sp)
[ 402] 0x900000001fc14b40:  ff b3 00 e8 sd	s3,232(sp)
[ 402] 0x900000001fc14b44:  00 02 10 3e dsrl32	v0,v0,0
[ 402] 0x900000001fc14b48:  00 64 18 24 and	v1,v1,a0
[ 402] 0x900000001fc14b4c:  ff b2 00 f0 sd	s2,240(sp)
[ 402] 0x900000001fc14b50:  00 02 10 00 sll	v0,v0,0
[ 402] 0x900000001fc14b54:  af a3 00 00 sw	v1,0(sp)
[ 402] 0x900000001fc14b58:  26 a3 00 01 addiu	v1,s5,1
[ 402] 0x900000001fc14b5c:  af a2 00 0c sw	v0,12(sp)
[ 402] 0x900000001fc14b60:  50 20 00 65 beql	at,zero,0x900000001fc14cf8
[ 402] 0x900000001fc14b64:  26 b2 00 03 addiu	s2,s5,3
[ 402] 0x900000001fc14b68:  24 01 00 20 li	at,32
[ 402] 0x900000001fc14b6c:  00 09 30 3c dsll32	a2,a5,0
[ 402] 0x900000001fc14b70:  02 2a 10 2f dsubu	v0,s1,a6
[ 402] 0x900000001fc14b74:  a2 08 00 10 sb	a4,16(s0)
[ 402] 0x900000001fc14b78:  00 06 30 3e dsrl32	a2,a2,0
[ 402] 0x900000001fc14b7c:  00 03 20 3c dsll32	a0,v1,0
[ 402] 0x900000001fc14b80:  25 28 00 04 addiu	a4,a5,4
[ 402] 0x900000001fc14b84:  00 04 20 3e dsrl32	a0,a0,0
[ 402] 0x900000001fc14b88:  24 e5 00 02 addiu	a1,a3,2
[ 402] 0x900000001fc14b8c:  00 05 28 3c dsll32	a1,a1,0
[ 402] 0x900000001fc14b90:  03 a6 50 2d daddu	a6,sp,a2
[ 402] 0x900000001fc14b94:  00 05 28 3e dsrl32	a1,a1,0
[ 402] 0x900000001fc14b98:  24 e6 00 03 addiu	a2,a3,3
[ 402] 0x900000001fc14b9c:  03 a4 20 2d daddu	a0,sp,a0
[ 402] 0x900000001fc14ba0:  00 06 30 3c dsll32	a2,a2,0
[ 402] 0x900000001fc14ba4:  a1 41 00 10 sb	at,16(a6)
[ 402] 0x900000001fc14ba8:  03 a5 28 2d daddu	a1,sp,a1
[ 402] 0x900000001fc14bac:  00 06 30 3e dsrl32	a2,a2,0
[ 402] 0x900000001fc14bb0:  a0 81 00 10 sb	at,16(a0)
[ 402] 0x900000001fc14bb4:  03 a6 20 2d daddu	a0,sp,a2
[ 402] 0x900000001fc14bb8:  00 08 30 3c dsll32	a2,a4,0
[ 402] 0x900000001fc14bbc:  a0 a1 00 10 sb	at,16(a1)
[ 402] 0x900000001fc14bc0:  00 06 30 3e dsrl32	a2,a2,0
[ 402] 0x900000001fc14bc4:  01 22 28 2b sltu	a1,a5,v0
[ 402] 0x900000001fc14bc8:  a0 81 00 10 sb	at,16(a0)
[ 402] 0x900000001fc14bcc:  10 a0 00 45 beq	a1,zero,0x900000001fc14ce4
[ 402] 0x900000001fc14bd0:  25 23 00 01 addiu	v1,a5,1
[ 402] 0x900000001fc14bd4:  00 03 20 3c dsll32	a0,v1,0
[ 402] 0x900000001fc14bd8:  25 07 00 04 addiu	a3,a4,4
[ 402] 0x900000001fc14bdc:  00 04 20 3e dsrl32	a0,a0,0
[ 402] 0x900000001fc14be0:  25 25 00 02 addiu	a1,a5,2
[ 402] 0x900000001fc14be4:  00 05 28 3c dsll32	a1,a1,0
[ 402] 0x900000001fc14be8:  03 a6 50 2d daddu	a6,sp,a2
[ 402] 0x900000001fc14bec:  00 05 28 3e dsrl32	a1,a1,0
[ 402] 0x900000001fc14bf0:  25 26 00 03 addiu	a2,a5,3
[ 402] 0x900000001fc14bf4:  03 a4 20 2d daddu	a0,sp,a0
[ 402] 0x900000001fc14bf8:  00 06 30 3c dsll32	a2,a2,0
[ 402] 0x900000001fc14bfc:  a1 41 00 10 sb	at,16(a6)
[ 402] 0x900000001fc14c00:  03 a5 28 2d daddu	a1,sp,a1
[ 402] 0x900000001fc14c04:  00 06 30 3e dsrl32	a2,a2,0
[ 402] 0x900000001fc14c08:  a0 81 00 10 sb	at,16(a0)
[ 402] 0x900000001fc14c0c:  03 a6 20 2d daddu	a0,sp,a2
[ 402] 0x900000001fc14c10:  00 07 30 3c dsll32	a2,a3,0
[ 402] 0x900000001fc14c14:  a0 a1 00 10 sb	at,16(a1)
[ 402] 0x900000001fc14c18:  00 06 30 3e dsrl32	a2,a2,0
[ 402] 0x900000001fc14c1c:  01 02 28 2b sltu	a1,a4,v0
[ 402] 0x900000001fc14c20:  a0 81 00 10 sb	at,16(a0)
[ 402] 0x900000001fc14c24:  10 a0 00 2b beq	a1,zero,0x900000001fc14cd4
[ 402] 0x900000001fc14c28:  25 03 00 01 addiu	v1,a4,1
[ 402] 0x900000001fc14c2c:  00 03 20 3c dsll32	a0,v1,0
[ 402] 0x900000001fc14c30:  24 e9 00 04 addiu	a5,a3,4
[ 402] 0x900000001fc14c34:  00 04 20 3e dsrl32	a0,a0,0
[ 402] 0x900000001fc14c38:  25 05 00 02 addiu	a1,a4,2
[ 402] 0x900000001fc14c3c:  00 05 28 3c dsll32	a1,a1,0
[ 402] 0x900000001fc14c40:  03 a6 50 2d daddu	a6,sp,a2
[ 402] 0x900000001fc14c44:  00 05 28 3e dsrl32	a1,a1,0
[ 402] 0x900000001fc14c48:  25 06 00 03 addiu	a2,a4,3
[ 402] 0x900000001fc14c4c:  03 a4 20 2d daddu	a0,sp,a0
[ 402] 0x900000001fc14c50:  00 06 30 3c dsll32	a2,a2,0
[ 402] 0x900000001fc14c54:  a1 41 00 10 sb	at,16(a6)
[ 402] 0x900000001fc14c58:  03 a5 28 2d daddu	a1,sp,a1
[ 402] 0x900000001fc14c5c:  00 06 30 3e dsrl32	a2,a2,0
[ 402] 0x900000001fc14c60:  a0 81 00 10 sb	at,16(a0)
[ 402] 0x900000001fc14c64:  03 a6 20 2d daddu	a0,sp,a2
[ 402] 0x900000001fc14c68:  00 09 30 3c dsll32	a2,a5,0
[ 402] 0x900000001fc14c6c:  a0 a1 00 10 sb	at,16(a1)
[ 402] 0x900000001fc14c70:  00 06 30 3e dsrl32	a2,a2,0
[ 402] 0x900000001fc14c74:  00 e2 28 2b sltu	a1,a3,v0
[ 402] 0x900000001fc14c78:  a0 81 00 10 sb	at,16(a0)
[ 402] 0x900000001fc14c7c:  14 a0 ff bf bne	a1,zero,0x900000001fc14b7c
[ 402] 0x900000001fc14c80:  24 e3 00 01 addiu	v1,a3,1
[ 402] 0x900000001fc14c84:  00 c0 88 25 move	s1,a2
[ 402] 0x900000001fc14c88:  00 e0 90 25 move	s2,a3
[ 402] 0x900000001fc14c8c:  00 60 98 25 move	s3,v1
[ 402] 0x900000001fc14c90:  00 13 68 3c dsll32	t1,s3,0
[ 402] 0x900000001fc14c94:  26 4b 00 02 addiu	a7,s2,2
[ 402] 0x900000001fc14c98:  00 0d 68 3e dsrl32	t1,t1,0
[ 402] 0x900000001fc14c9c:  26 4c 00 03 addiu	t0,s2,3
[ 402] 0x900000001fc14ca0:  00 0b 58 3c dsll32	a7,a7,0
[ 402] 0x900000001fc14ca4:  00 0c 60 3c dsll32	t0,t0,0
[ 402] 0x900000001fc14ca8:  00 0b 58 3e dsrl32	a7,a7,0
[ 402] 0x900000001fc14cac:  03 ad 70 2d daddu	t2,sp,t1
[ 402] 0x900000001fc14cb0:  00 0c 60 3e dsrl32	t0,t0,0
[ 402] 0x900000001fc14cb4:  03 ab 68 2d daddu	t1,sp,a7
[ 402] 0x900000001fc14cb8:  24 0b 00 20 li	a7,32
[ 402] 0x900000001fc14cbc:  03 ac 60 2d daddu	t0,sp,t0
[ 402] 0x900000001fc14cc0:  a1 cb 00 10 sb	a7,16(t2)
[ 402] 0x900000001fc14cc4:  03 b1 80 2d daddu	s0,sp,s1
[ 402] 0x900000001fc14cc8:  a1 ab 00 10 sb	a7,16(t1)
[ 402] 0x900000001fc14ccc:  10 00 00 23 b		0x900000001fc14d5c
[ 402] 0x900000001fc14cd0:  a1 8b 00 10 sb	a7,16(t0)
[ 402] 0x900000001fc14cd4:  00 c0 88 25 move	s1,a2
[ 402] 0x900000001fc14cd8:  01 00 90 25 move	s2,a4
[ 402] 0x900000001fc14cdc:  10 00 ff ec b		0x900000001fc14c90
[ 402] 0x900000001fc14ce0:  00 60 98 25 move	s3,v1
[ 402] 0x900000001fc14ce4:  00 c0 88 25 move	s1,a2
[ 402] 0x900000001fc14ce8:  01 20 90 25 move	s2,a5
[ 402] 0x900000001fc14cec:  10 00 ff e8 b		0x900000001fc14c90
[ 402] 0x900000001fc14cf0:  00 60 98 25 move	s3,v1
[ 402] 0x900000001fc14cf4:  26 b2 00 03 addiu	s2,s5,3
[ 402] 0x900000001fc14cf8:  00 12 98 3c dsll32	s3,s2,0
[ 402] 0x900000001fc14cfc:  00 13 98 3e dsrl32	s3,s3,0
[ 402] 0x900000001fc14d00:  26 af 00 01 addiu	t3,s5,1
[ 402] 0x900000001fc14d04:  00 0f b0 3c dsll32	s6,t3,0
[ 402] 0x900000001fc14d08:  26 af 00 02 addiu	t3,s5,2
[ 402] 0x900000001fc14d0c:  00 0f 78 3c dsll32	t3,t3,0
[ 402] 0x900000001fc14d10:  00 16 b0 3e dsrl32	s6,s6,0
[ 402] 0x900000001fc14d14:  24 12 00 20 li	s2,32
[ 402] 0x900000001fc14d18:  00 0f 78 3e dsrl32	t3,t3,0
[ 402] 0x900000001fc14d1c:  03 b6 b0 2d daddu	s6,sp,s6
[ 402] 0x900000001fc14d20:  a2 12 00 10 sb	s2,16(s0)
[ 402] 0x900000001fc14d24:  26 b5 00 04 addiu	s5,s5,4
[ 402] 0x900000001fc14d28:  03 af 78 2d daddu	t3,sp,t3
[ 402] 0x900000001fc14d2c:  00 15 80 3c dsll32	s0,s5,0
[ 402] 0x900000001fc14d30:  03 b3 98 2d daddu	s3,sp,s3
[ 402] 0x900000001fc14d34:  a2 d2 00 10 sb	s2,16(s6)
[ 402] 0x900000001fc14d38:  00 10 80 3e dsrl32	s0,s0,0
[ 402] 0x900000001fc14d3c:  a1 f2 00 10 sb	s2,16(t3)
[ 402] 0x900000001fc14d40:  02 b1 78 2b sltu	t3,s5,s1
[ 402] 0x900000001fc14d44:  a2 72 00 10 sb	s2,16(s3)
[ 402] 0x900000001fc14d48:  26 b2 00 03 addiu	s2,s5,3
[ 402] 0x900000001fc14d4c:  00 12 98 3c dsll32	s3,s2,0
[ 402] 0x900000001fc14d50:  03 b0 80 2d daddu	s0,sp,s0
[ 402] 0x900000001fc14d54:  15 e0 ff ea bne	t3,zero,0x900000001fc14d00
[ 402] 0x900000001fc14d58:  00 13 98 3e dsrl32	s3,s3,0
  406: 	cpuinfo[i] = ' ';
  407:     cpuinfo[i] = '\0';   /* Null terminate */
  408:  
  409:     /* Grab our slot and slice numbers for future reference */
  410:     slot =  (uint)((LD(EV_SPNUM) & EV_SLOTNUM_MASK) >> EV_SLOTNUM_SHFT);
[ 410] 0x900000001fc14d5c:  df b7 00 68 ld	s7,104(sp)
  411:     slice = (uint)((LD(EV_SPNUM) & EV_PROCNUM_MASK) >> EV_PROCNUM_SHFT);
  412: 
  413:     for (i = 1; i < EV_MAX_SLOTS; i++) {
[ 413] 0x900000001fc14d60:  66 e4 01 88 daddiu	a0,s7,392
[ 413] 0x900000001fc14d64:  66 e3 01 b0 daddiu	v1,s7,432
[ 413] 0x900000001fc14d68:  66 e2 01 40 daddiu	v0,s7,320
[ 413] 0x900000001fc14d6c:  66 e1 01 70 daddiu	at,s7,368
[ 413] 0x900000001fc14d70:  66 ff 01 d8 daddiu	ra,s7,472
[ 413] 0x900000001fc14d74:  66 f8 01 10 daddiu	t8,s7,272
[ 413] 0x900000001fc14d78:  de f7 02 18 ld	s7,536(s7)
[ 407] 0x900000001fc14d7c:  a2 00 00 10 sb	zero,16(s0)
[ 407] 0x900000001fc14d80:  de e5 00 00 ld	a1,0(s7)
[ 407] 0x900000001fc14d84:  30 a5 00 3c andi	a1,a1,0x3c
[ 407] 0x900000001fc14d88:  00 05 28 bb dsra	a1,a1,2
[ 407] 0x900000001fc14d8c:  00 05 28 00 sll	a1,a1,0
[ 407] 0x900000001fc14d90:  ff a5 00 70 sd	a1,112(sp)
[ 411] 0x900000001fc14d94:  24 15 00 01 li	s5,1
[ 411] 0x900000001fc14d98:  de f7 00 00 ld	s7,0(s7)
[ 411] 0x900000001fc14d9c:  00 15 c8 3c dsll32	t9,s5,0
[ 411] 0x900000001fc14da0:  ff a4 00 80 sd	a0,128(sp)
[ 411] 0x900000001fc14da4:  00 19 c8 3e dsrl32	t9,t9,0
[ 411] 0x900000001fc14da8:  ff a3 00 88 sd	v1,136(sp)
[ 411] 0x900000001fc14dac:  00 19 38 b8 dsll	a3,t9,2
[ 411] 0x900000001fc14db0:  ff a2 00 90 sd	v0,144(sp)
[ 411] 0x900000001fc14db4:  24 02 00 13 li	v0,19
[ 411] 0x900000001fc14db8:  00 19 31 38 dsll	a2,t9,4
[ 411] 0x900000001fc14dbc:  ff a1 00 98 sd	at,152(sp)
[ 411] 0x900000001fc14dc0:  00 19 c9 f8 dsll	t9,t9,7
[ 411] 0x900000001fc14dc4:  ff bf 00 a0 sd	ra,160(sp)
[ 411] 0x900000001fc14dc8:  24 1f 00 10 li	ra,16
[ 411] 0x900000001fc14dcc:  00 c7 30 2d daddu	a2,a2,a3
[ 411] 0x900000001fc14dd0:  32 f7 00 03 andi	s7,s7,0x3
[ 411] 0x900000001fc14dd4:  ff bf 00 a8 sd	ra,168(sp)
[ 411] 0x900000001fc14dd8:  03 26 c8 2f dsubu	t9,t9,a2
[ 411] 0x900000001fc14ddc:  ff b8 00 b0 sd	t8,176(sp)
[ 411] 0x900000001fc14de0:  00 17 b8 00 sll	s7,s7,0
[ 411] 0x900000001fc14de4:  df b8 00 60 ld	t8,96(sp)
[ 411] 0x900000001fc14de8:  03 19 b0 2d daddu	s6,t8,t9
[ 411] 0x900000001fc14dec:  ff b7 00 78 sd	s7,120(sp)
[ 411] 0x900000001fc14df0:  32 a4 00 03 andi	a0,s5,0x3
[ 411] 0x900000001fc14df4:  00 00 88 25 move	s1,zero
  414: 	brd = &(info->ecfg_board[i]);
  415: 
  416: 	/* Skip non-IP25 boards */
  417:         if (brd->eb_type != EVTYPE_IP25)
[ 417] 0x900000001fc14df8:  92 c1 00 64 lbu	at,100(s6)
[ 417] 0x900000001fc14dfc:  54 22 00 15 bnel	at,v0,0x900000001fc14e54
[ 417] 0x900000001fc14e00:  24 02 00 13 li	v0,19
[ 414] 0x900000001fc14e04:  00 04 98 c0 sll	s3,a0,3
  418: 	    continue;
  419: 	   
  420: 	/* Check to see if this board has been disabled */
  421: 	if (!brd->eb_enabled) {
[ 421] 0x900000001fc14e08:  92 c3 00 66 lbu	v1,102(s6)
[ 421] 0x900000001fc14e0c:  54 60 00 09 bnel	v1,zero,0x900000001fc14e34
[ 421] 0x900000001fc14e10:  df ab 00 70 ld	a7,112(sp)
  422: 	    loprintf("\tAll processors in slot %d have been disabled\n", i);
[ 422] 0x900000001fc14e14:  02 a0 28 25 move	a1,s5
[ 422] 0x900000001fc14e18:  0f f0 2c e3 jal		loprintf
[ 422] 0x900000001fc14e1c:  df a4 00 b0 ld	a0,176(sp)
  423: 	    for (c = 0; c < EV_CPU_PER_BOARD; c++)
[ 423] 0x900000001fc14e20:  a2 c0 00 09 sb	zero,9(s6)
[ 423] 0x900000001fc14e24:  a2 c0 00 19 sb	zero,25(s6)
[ 423] 0x900000001fc14e28:  a2 c0 00 29 sb	zero,41(s6)
[ 423] 0x900000001fc14e2c:  a2 c0 00 39 sb	zero,57(s6)
[ 423] 0x900000001fc14e30:  df ab 00 70 ld	a7,112(sp)
[ 423] 0x900000001fc14e34:  24 01 00 20 li	at,32
  424: 		brd->eb_cpuarr[c].cpu_enable = 0;
  425: 	}
  426: 
  427: 	for (c = 0; c < EV_CPU_PER_BOARD; c++) {
[ 427] 0x900000001fc14e38:  02 60 80 25 move	s0,s3
[ 427] 0x900000001fc14e3c:  26 77 00 08 addiu	s7,s3,8
[ 427] 0x900000001fc14e40:  00 00 30 3c dsll32	a2,zero,0
[ 427] 0x900000001fc14e44:  00 06 37 3a dsrl	a2,a2,28
[ 427] 0x900000001fc14e48:  10 00 00 22 b		0x900000001fc14ed4
[ 427] 0x900000001fc14e4c:  02 c6 90 2d daddu	s2,s6,a2
[ 427] 0x900000001fc14e50:  24 02 00 13 li	v0,19
[ 413] 0x900000001fc14e54:  26 b5 00 01 addiu	s5,s5,1
[ 413] 0x900000001fc14e58:  00 15 38 3c dsll32	a3,s5,0
[ 413] 0x900000001fc14e5c:  00 07 38 3e dsrl32	a3,a3,0
[ 413] 0x900000001fc14e60:  00 07 48 b8 dsll	a5,a3,2
[ 413] 0x900000001fc14e64:  00 07 41 38 dsll	a4,a3,4
[ 413] 0x900000001fc14e68:  00 07 39 f8 dsll	a3,a3,7
[ 413] 0x900000001fc14e6c:  01 09 40 2d daddu	a4,a4,a5
[ 413] 0x900000001fc14e70:  00 e8 48 2f dsubu	a5,a3,a4
[ 413] 0x900000001fc14e74:  df a8 00 60 ld	a4,96(sp)
[ 413] 0x900000001fc14e78:  df a7 00 a8 ld	a3,168(sp)
[ 413] 0x900000001fc14e7c:  16 a7 ff dc bne	s5,a3,0x900000001fc14df0
[ 413] 0x900000001fc14e80:  01 09 b0 2d daddu	s6,a4,a5
[ 413] 0x900000001fc14e84:  df aa 00 68 ld	a6,104(sp)
[ 413] 0x900000001fc14e88:  df be 00 c0 ld	s8,192(sp)
  428: 
  429: 	    /* Special case the behaviour for the bootmaster */
  430: 
  431: 	    if (slot == i && slice == c) {
  432: 
  433: 		/* Check to see whether the bootmaster is disabled. */
  434: 		if (!brd->eb_cpuarr[c].cpu_enable) {
  435: 		    if (ip0[0] | ip0[1] | ip0[2] | ip0[3]) {
  436: 			loprintf("*** Current bootmaster (%a/%a) is disabled.",
  437: 								i, c);
  438: 			loprintf("  Rearbitrating...\n");
  439: 			prom_abdicate(0);
  440: 		    } else {
  441: 			loprintf("*** WARNING: All available CPUs are ");
  442:  			loprintf("disabled.  Re-enabling CPU %a/%a.\n", i, c);
  443: 			brd->eb_cpuarr[c].cpu_diagval = EVDIAG_CPUREENABLED;
  444: 			brd->eb_cpuarr[c].cpu_enable = 1;
  445: 		    }
  446: 		}
  447: 
  448: 		brd->eb_cpuarr[c].cpu_vpid = vpid++;
  449: 		loprintf("    CPU %a/%a is bootmaster\n", i, c);
  450: 	        *currcpu++ = SCSTAT_BOOTMASTER;
  451: 		continue;
  452: 	    }
  453: 
  454: 	    /* Check to see whether processor is alive */
  455: 	    bit = 1 << (((i % 4) * (EV_MAX_CPUS_BOARD * 2)) + (c*2));
  456: 	    if (ip0[i/4] & bit) {
  457: 		brd->eb_cpuarr[c].cpu_vpid = vpid++;
  458: 		/* See if processor is enabled */
  459: 		if (brd->eb_cpuarr[c].cpu_enable == 0) {
  460: 		    DPRINTF(("but disabled"));
  461: 		    *currcpu++ = SCSTAT_DISABLED;
  462: 		} else 
  463: 		    *currcpu++ = SCSTAT_WORKING;
  464: 
  465: 		DPRINTF(("(%d)\n", brd->eb_cpuarr[c].cpu_vpid));
  466: 	    } else {
  467: 		/* Processor didn't respond, either it isn't there
  468: 		   or it is seriously hosed */
  469: 		brd->eb_cpuarr[c].cpu_enable = 0;
  470: 		brd->eb_cpuarr[c].cpu_vpid = CPUST_NORESP;
  471: 		brd->eb_cpuarr[c].cpu_diagval = EVDIAG_NOTFOUND;
  472: 		*currcpu++ = SCSTAT_UNKNOWN; 
  473: 		DPRINTF(("CPU %x/%x: no response (bit %x)\n", i, c, bit));
  474: 	    }
  475: 
  476: 	    /* Switch off the bit corresponding to cpu being checked */
  477: 	    ip0[i/4] &= ~bit;
  478: 	}
  479:     }
  480: 
  481:     /* Fire the CPU status string off to the system controller */
  482:     sysctlr_message("CPU Status:");
[ 482] 0x900000001fc14e8c:  df b6 00 d0 ld	s6,208(sp)
[ 482] 0x900000001fc14e90:  df b7 00 c8 ld	s7,200(sp)
[ 482] 0x900000001fc14e94:  0f f0 11 7c jal		sysctlr_message
[ 482] 0x900000001fc14e98:  65 44 01 f8 daddiu	a0,a6,504
  483:     sysctlr_bootstat(cpuinfo, 0);
[ 483] 0x900000001fc14e9c:  df b4 00 e0 ld	s4,224(sp)
[ 483] 0x900000001fc14ea0:  df b5 00 d8 ld	s5,216(sp)
[ 483] 0x900000001fc14ea4:  00 00 28 25 move	a1,zero
[ 483] 0x900000001fc14ea8:  df b2 00 f0 ld	s2,240(sp)
[ 483] 0x900000001fc14eac:  df b3 00 e8 ld	s3,232(sp)
[ 483] 0x900000001fc14eb0:  0f f0 3e 16 jal		sysctlr_bootstat
[ 483] 0x900000001fc14eb4:  67 a4 00 10 daddiu	a0,sp,16
  484: 
  485:     /* We're all finished with the interrupts, so clear them out */
  486:     pod_clear_ints();
[ 486] 0x900000001fc14eb8:  df b0 01 00 ld	s0,256(sp)
[ 486] 0x900000001fc14ebc:  df b1 00 f8 ld	s1,248(sp)
[ 486] 0x900000001fc14ec0:  0f f0 14 d8 jal		pod_clear_ints
[ 486] 0x900000001fc14ec4:  00 00 00 21 nada
  487: }
[ 487] 0x900000001fc14ec8:  df bf 00 b8 ld	ra,184(sp)
[ 487] 0x900000001fc14ecc:  03 e0 00 08 jr	ra
[ 487] 0x900000001fc14ed0:  67 bd 01 10 daddiu	sp,sp,272
[ 487] 0x900000001fc14ed4:  df ac 00 78 ld	t0,120(sp)
[ 487] 0x900000001fc14ed8:  8f a8 00 08 lw	a4,8(sp)
[ 487] 0x900000001fc14edc:  02 a0 28 25 move	a1,s5
[ 487] 0x900000001fc14ee0:  66 93 00 01 daddiu	s3,s4,1
[ 431] 0x900000001fc14ee4:  8f a9 00 00 lw	a5,0(sp)
[ 431] 0x900000001fc14ee8:  56 ab 00 05 bnel	s5,a7,0x900000001fc14f00
[ 431] 0x900000001fc14eec:  00 15 68 82 srl	t1,s5,2
[ 431] 0x900000001fc14ef0:  8f ab 00 0c lw	a7,12(sp)
[ 431] 0x900000001fc14ef4:  12 2c 00 40 beq	s1,t0,0x900000001fc14ff8
[ 431] 0x900000001fc14ef8:  02 20 30 25 move	a2,s1
[ 456] 0x900000001fc14efc:  00 15 68 82 srl	t1,s5,2
[ 456] 0x900000001fc14f00:  03 c0 f8 25 move	ra,s8
[ 456] 0x900000001fc14f04:  00 0d 68 3c dsll32	t1,t1,0
[ 456] 0x900000001fc14f08:  00 0d 6f ba dsrl	t1,t1,30
[ 456] 0x900000001fc14f0c:  03 ad 58 2d daddu	a7,sp,t1
[ 455] 0x900000001fc14f10:  24 0e 00 01 li	t2,1
[ 455] 0x900000001fc14f14:  02 0e 08 04 sllv	at,t2,s0
[ 455] 0x900000001fc14f18:  8d 6d 00 00 lw	t1,0(a7)
[ 455] 0x900000001fc14f1c:  00 2d 68 24 and	t1,at,t1
[ 455] 0x900000001fc14f20:  55 a0 00 14 bnel	t1,zero,0x900000001fc14f74
[ 455] 0x900000001fc14f24:  92 59 00 09 lbu	t9,9(s2)
[ 469] 0x900000001fc14f28:  a2 40 00 09 sb	zero,9(s2)
[ 472] 0x900000001fc14f2c:  24 0f 00 ff li	t3,255
[ 472] 0x900000001fc14f30:  a2 4f 00 0c sb	t3,12(s2)
[ 472] 0x900000001fc14f34:  26 31 00 01 addiu	s1,s1,1
[ 471] 0x900000001fc14f38:  00 20 c0 27 nor	t8,at,zero
[ 471] 0x900000001fc14f3c:  a2 4f 00 0b sb	t3,11(s2)
[ 471] 0x900000001fc14f40:  24 12 00 20 li	s2,32
[ 471] 0x900000001fc14f44:  00 11 78 3c dsll32	t3,s1,0
[ 471] 0x900000001fc14f48:  26 10 00 02 addiu	s0,s0,2
[ 471] 0x900000001fc14f4c:  a2 92 00 00 sb	s2,0(s4)
[ 471] 0x900000001fc14f50:  00 0f 7f 3a dsrl	t3,t3,28
[ 471] 0x900000001fc14f54:  02 60 a0 25 move	s4,s3
[ 471] 0x900000001fc14f58:  02 cf 90 2d daddu	s2,s6,t3
[ 471] 0x900000001fc14f5c:  8d 6f 00 00 lw	t3,0(a7)
[ 471] 0x900000001fc14f60:  01 f8 78 24 and	t3,t3,t8
[ 471] 0x900000001fc14f64:  ad 6f 00 00 sw	t3,0(a7)
[ 471] 0x900000001fc14f68:  10 00 00 51 b		0x900000001fc150b0
[ 471] 0x900000001fc14f6c:  df ab 00 70 ld	a7,112(sp)
[ 457] 0x900000001fc14f70:  92 59 00 09 lbu	t9,9(s2)
[ 457] 0x900000001fc14f74:  53 20 00 12 beql	t9,zero,0x900000001fc14fc0
[ 457] 0x900000001fc14f78:  24 04 00 44 li	a0,68
[ 463] 0x900000001fc14f7c:  00 20 18 27 nor	v1,at,zero
[ 463] 0x900000001fc14f80:  24 01 00 2b li	at,43
[ 463] 0x900000001fc14f84:  a2 5f 00 0c sb	ra,12(s2)
[ 463] 0x900000001fc14f88:  26 10 00 02 addiu	s0,s0,2
[ 463] 0x900000001fc14f8c:  a2 81 00 00 sb	at,0(s4)
[ 463] 0x900000001fc14f90:  26 31 00 01 addiu	s1,s1,1
[ 463] 0x900000001fc14f94:  02 60 a0 25 move	s4,s3
[ 463] 0x900000001fc14f98:  00 11 10 3c dsll32	v0,s1,0
[ 463] 0x900000001fc14f9c:  8d 61 00 00 lw	at,0(a7)
[ 463] 0x900000001fc14fa0:  00 02 17 3a dsrl	v0,v0,28
[ 463] 0x900000001fc14fa4:  00 23 08 24 and	at,at,v1
[ 463] 0x900000001fc14fa8:  ad 61 00 00 sw	at,0(a7)
[ 463] 0x900000001fc14fac:  02 c2 90 2d daddu	s2,s6,v0
[ 463] 0x900000001fc14fb0:  27 de 00 01 addiu	s8,s8,1
[ 463] 0x900000001fc14fb4:  10 00 00 3e b		0x900000001fc150b0
[ 463] 0x900000001fc14fb8:  df ab 00 70 ld	a7,112(sp)
[ 461] 0x900000001fc14fbc:  24 04 00 44 li	a0,68
[ 461] 0x900000001fc14fc0:  00 20 30 27 nor	a2,at,zero
[ 461] 0x900000001fc14fc4:  a2 5f 00 0c sb	ra,12(s2)
[ 461] 0x900000001fc14fc8:  a2 84 00 00 sb	a0,0(s4)
[ 461] 0x900000001fc14fcc:  26 31 00 01 addiu	s1,s1,1
[ 461] 0x900000001fc14fd0:  26 10 00 02 addiu	s0,s0,2
[ 461] 0x900000001fc14fd4:  00 11 28 3c dsll32	a1,s1,0
[ 461] 0x900000001fc14fd8:  8d 64 00 00 lw	a0,0(a7)
[ 461] 0x900000001fc14fdc:  00 05 2f 3a dsrl	a1,a1,28
[ 461] 0x900000001fc14fe0:  00 86 20 24 and	a0,a0,a2
[ 461] 0x900000001fc14fe4:  02 60 a0 25 move	s4,s3
[ 461] 0x900000001fc14fe8:  ad 64 00 00 sw	a0,0(a7)
[ 461] 0x900000001fc14fec:  27 de 00 01 addiu	s8,s8,1
[ 477] 0x900000001fc14ff0:  10 00 00 2e b		0x900000001fc150ac
[ 477] 0x900000001fc14ff4:  02 c5 90 2d daddu	s2,s6,a1
[ 434] 0x900000001fc14ff8:  92 47 00 09 lbu	a3,9(s2)
[ 434] 0x900000001fc14ffc:  54 e0 00 1c bnel	a3,zero,0x900000001fc15070
[ 434] 0x900000001fc15000:  02 20 30 25 move	a2,s1
[ 435] 0x900000001fc15004:  8f aa 00 04 lw	a6,4(sp)
[ 435] 0x900000001fc15008:  01 0b 40 25 or	a4,a4,a7
[ 435] 0x900000001fc1500c:  01 2a 48 25 or	a5,a5,a6
[ 435] 0x900000001fc15010:  01 09 40 25 or	a4,a4,a5
[ 435] 0x900000001fc15014:  15 00 00 0e bne	a4,zero,0x900000001fc15050
[ 435] 0x900000001fc15018:  00 00 00 21 nada
[ 441] 0x900000001fc1501c:  0f f0 2c e3 jal		loprintf
[ 441] 0x900000001fc15020:  df a4 00 80 ld	a0,128(sp)
[ 442] 0x900000001fc15024:  02 20 30 25 move	a2,s1
[ 442] 0x900000001fc15028:  02 a0 28 25 move	a1,s5
[ 442] 0x900000001fc1502c:  0f f0 2c e3 jal		loprintf
[ 442] 0x900000001fc15030:  df a4 00 88 ld	a0,136(sp)
[ 444] 0x900000001fc15034:  24 01 00 20 li	at,32
[ 444] 0x900000001fc15038:  24 0c 00 7d li	t0,125
[ 444] 0x900000001fc1503c:  a2 4c 00 0b sb	t0,11(s2)
[ 444] 0x900000001fc15040:  24 0c 00 01 li	t0,1
[ 444] 0x900000001fc15044:  a2 4c 00 09 sb	t0,9(s2)
[ 444] 0x900000001fc15048:  10 00 00 09 b		0x900000001fc15070
[ 444] 0x900000001fc1504c:  02 20 30 25 move	a2,s1
[ 436] 0x900000001fc15050:  0f f0 2c e3 jal		loprintf
[ 436] 0x900000001fc15054:  df a4 00 90 ld	a0,144(sp)
[ 438] 0x900000001fc15058:  0f f0 2c e3 jal		loprintf
[ 438] 0x900000001fc1505c:  df a4 00 98 ld	a0,152(sp)
[ 439] 0x900000001fc15060:  0f f0 12 88 jal		prom_abdicate
[ 439] 0x900000001fc15064:  00 00 20 25 move	a0,zero
[ 439] 0x900000001fc15068:  24 01 00 20 li	at,32
[ 439] 0x900000001fc1506c:  02 20 30 25 move	a2,s1
[ 449] 0x900000001fc15070:  03 c0 68 25 move	t1,s8
[ 449] 0x900000001fc15074:  02 a0 28 25 move	a1,s5
[ 449] 0x900000001fc15078:  a2 4d 00 0c sb	t1,12(s2)
[ 449] 0x900000001fc1507c:  df a4 00 a0 ld	a0,160(sp)
[ 449] 0x900000001fc15080:  0f f0 2c e3 jal		loprintf
[ 449] 0x900000001fc15084:  27 de 00 01 addiu	s8,s8,1
[ 451] 0x900000001fc15088:  26 10 00 02 addiu	s0,s0,2
[ 451] 0x900000001fc1508c:  26 31 00 01 addiu	s1,s1,1
[ 451] 0x900000001fc15090:  24 01 00 20 li	at,32
[ 451] 0x900000001fc15094:  00 11 68 3c dsll32	t1,s1,0
[ 450] 0x900000001fc15098:  24 0e 00 42 li	t2,66
[ 450] 0x900000001fc1509c:  00 0d 6f 3a dsrl	t1,t1,28
[ 450] 0x900000001fc150a0:  a2 8e 00 00 sb	t2,0(s4)
[ 450] 0x900000001fc150a4:  02 60 a0 25 move	s4,s3
[ 450] 0x900000001fc150a8:  02 cd 90 2d daddu	s2,s6,t1
[ 450] 0x900000001fc150ac:  df ab 00 70 ld	a7,112(sp)
[ 427] 0x900000001fc150b0:  56 17 ff 89 bnel	s0,s7,0x900000001fc14ed8
[ 427] 0x900000001fc150b4:  df ac 00 78 ld	t0,120(sp)
[ 427] 0x900000001fc150b8:  10 00 ff 66 b		0x900000001fc14e54
[ 427] 0x900000001fc150bc:  24 02 00 13 li	v0,19
  488: 
  489: /*
  490:  * Convert secondary cache size from CC local register format
  491:  * to log2 format since all the higher level code assumes the
  492:  * scachesz is in log2 format.
  493:  */
  494: __uint32_t log2vals[] = {
  495: 	24,	/*  0 = 16MB */
  496: 	23,	/*  1 = 8MB  */
  497: 	22,	/*  2 = 4MB  */
  498: 	21,	/*  3 = 2MB  */
  499: 	20,	/*  4 = 1MB  */
  500: 	0,	/*  5 = invalid */
  501: 	0,	/*  6 = invalid */
  502: 	0,	/*  7 = invalid */
  503:     };
  504: 
  505: /*
  506:  * init_mpconf()
  507:  * 	Sends out an interrupt instructing the slave processors
  508:  *	to initialize their MPCONF entries.  Initializes the 
  509:  *	master CPU's MPCONF.
  510:  */
  511: 
  512: void
  513: init_mpconf(void)
  514: {
init_mpconf:
[ 514] 0x900000001fc150c0:  67 bd ff 90 daddiu	sp,sp,-112
  515:     extern void *get_epcuart_base(void);
  516:     mpconf_t *mpconf;		/* work around ragnarok compiler bug */
  517:     evcfginfo_t *evcfginfo;	/* work around ragnarok compiler bug */
  518:     uint ppid, vpid;		/* Virtual and physical processor ID's */
  519:     uint slot, proc;
  520:     uint scachesz;
  521: 
  522:     /* Zero the MPCONF region */
  523:     for (vpid = 0; vpid < EV_MAX_CPUS; vpid++) {
[ 523] 0x900000001fc150c4:  3c 01 90 00 lui	at,0x9000
[ 523] 0x900000001fc150c8:  60 21 00 00 daddi	at,at,0
[ 523] 0x900000001fc150cc:  3c 03 1f c2 lui	v1,0x1fc2
[ 523] 0x900000001fc150d0:  24 02 00 04 li	v0,4
[ 523] 0x900000001fc150d4:  60 63 eb 90 daddi	v1,v1,-5232
[ 523] 0x900000001fc150d8:  ff b5 00 38 sd	s5,56(sp)
[ 523] 0x900000001fc150dc:  00 02 10 2d daddu	v0,zero,v0
[ 523] 0x900000001fc150e0:  00 01 08 3c dsll32	at,at,0
[ 523] 0x900000001fc150e4:  ff b4 00 40 sd	s4,64(sp)
[ 523] 0x900000001fc150e8:  24 06 00 04 li	a2,4
[ 523] 0x900000001fc150ec:  24 0b 00 31 li	a7,49
[ 523] 0x900000001fc150f0:  ff b3 00 48 sd	s3,72(sp)
[ 523] 0x900000001fc150f4:  00 4b 10 2b sltu	v0,v0,a7
[ 523] 0x900000001fc150f8:  00 23 a8 2c dadd	s5,at,v1
[ 523] 0x900000001fc150fc:  ff b0 00 60 sd	s0,96(sp)
[ 523] 0x900000001fc15100:  00 00 80 25 move	s0,zero
[ 523] 0x900000001fc15104:  ff b1 00 58 sd	s1,88(sp)
[ 523] 0x900000001fc15108:  26 04 00 01 addiu	a0,s0,1
[ 523] 0x900000001fc1510c:  00 10 28 3c dsll32	a1,s0,0
[ 523] 0x900000001fc15110:  de a1 02 60 ld	at,608(s5)
[ 523] 0x900000001fc15114:  ff b2 00 50 sd	s2,80(sp)
[ 523] 0x900000001fc15118:  00 05 2e ba dsrl	a1,a1,26
[ 523] 0x900000001fc1511c:  02 00 48 25 move	a5,s0
[ 523] 0x900000001fc15120:  ff b6 00 28 sd	s6,40(sp)
[ 523] 0x900000001fc15124:  ff bf 00 30 sd	ra,48(sp)
[ 523] 0x900000001fc15128:  50 40 00 60 beql	v0,zero,0x900000001fc152ac
[ 523] 0x900000001fc1512c:  00 10 50 3c dsll32	a6,s0,0
[ 523] 0x900000001fc15130:  26 08 00 04 addiu	a4,s0,4
[ 523] 0x900000001fc15134:  00 a1 18 2f dsubu	v1,a1,at
[ 523] 0x900000001fc15138:  00 04 20 3c dsll32	a0,a0,0
[ 523] 0x900000001fc1513c:  01 66 10 2f dsubu	v0,a7,a2
[ 523] 0x900000001fc15140:  00 04 26 ba dsrl	a0,a0,26
[ 523] 0x900000001fc15144:  ac 60 00 00 sw	zero,0(v1)
[ 523] 0x900000001fc15148:  a0 60 00 08 sb	zero,8(v1)
[ 523] 0x900000001fc1514c:  00 81 28 2f dsubu	a1,a0,at
[ 523] 0x900000001fc15150:  25 26 00 02 addiu	a2,a5,2
[ 523] 0x900000001fc15154:  a0 60 00 09 sb	zero,9(v1)
[ 523] 0x900000001fc15158:  00 06 30 3c dsll32	a2,a2,0
[ 523] 0x900000001fc1515c:  ac a0 00 00 sw	zero,0(a1)
[ 523] 0x900000001fc15160:  00 06 36 ba dsrl	a2,a2,26
[ 523] 0x900000001fc15164:  a0 a0 00 08 sb	zero,8(a1)
[ 523] 0x900000001fc15168:  00 c1 30 2f dsubu	a2,a2,at
[ 523] 0x900000001fc1516c:  25 27 00 03 addiu	a3,a5,3
[ 523] 0x900000001fc15170:  a0 a0 00 09 sb	zero,9(a1)
[ 523] 0x900000001fc15174:  00 07 28 3c dsll32	a1,a3,0
[ 523] 0x900000001fc15178:  ac c0 00 00 sw	zero,0(a2)
[ 523] 0x900000001fc1517c:  00 05 2e ba dsrl	a1,a1,26
[ 523] 0x900000001fc15180:  a0 c0 00 08 sb	zero,8(a2)
[ 523] 0x900000001fc15184:  00 a1 28 2f dsubu	a1,a1,at
[ 523] 0x900000001fc15188:  a0 c0 00 09 sb	zero,9(a2)
[ 523] 0x900000001fc1518c:  00 08 18 3c dsll32	v1,a4,0
[ 523] 0x900000001fc15190:  ac a0 00 00 sw	zero,0(a1)
[ 523] 0x900000001fc15194:  00 03 1e ba dsrl	v1,v1,26
[ 523] 0x900000001fc15198:  25 09 00 04 addiu	a5,a4,4
[ 523] 0x900000001fc1519c:  a0 a0 00 08 sb	zero,8(a1)
[ 523] 0x900000001fc151a0:  00 61 18 2f dsubu	v1,v1,at
[ 523] 0x900000001fc151a4:  25 04 00 01 addiu	a0,a4,1
[ 523] 0x900000001fc151a8:  a0 a0 00 09 sb	zero,9(a1)
[ 523] 0x900000001fc151ac:  00 04 20 3c dsll32	a0,a0,0
[ 523] 0x900000001fc151b0:  01 02 28 2b sltu	a1,a4,v0
[ 523] 0x900000001fc151b4:  ac 60 00 00 sw	zero,0(v1)
[ 523] 0x900000001fc151b8:  10 a0 00 37 beq	a1,zero,0x900000001fc15298
[ 523] 0x900000001fc151bc:  00 04 26 ba dsrl	a0,a0,26
[ 523] 0x900000001fc151c0:  a0 60 00 08 sb	zero,8(v1)
[ 523] 0x900000001fc151c4:  00 81 28 2f dsubu	a1,a0,at
[ 523] 0x900000001fc151c8:  25 06 00 02 addiu	a2,a4,2
[ 523] 0x900000001fc151cc:  a0 60 00 09 sb	zero,9(v1)
[ 523] 0x900000001fc151d0:  00 06 30 3c dsll32	a2,a2,0
[ 523] 0x900000001fc151d4:  ac a0 00 00 sw	zero,0(a1)
[ 523] 0x900000001fc151d8:  00 06 36 ba dsrl	a2,a2,26
[ 523] 0x900000001fc151dc:  a0 a0 00 08 sb	zero,8(a1)
[ 523] 0x900000001fc151e0:  00 c1 30 2f dsubu	a2,a2,at
[ 523] 0x900000001fc151e4:  25 07 00 03 addiu	a3,a4,3
[ 523] 0x900000001fc151e8:  a0 a0 00 09 sb	zero,9(a1)
[ 523] 0x900000001fc151ec:  00 07 28 3c dsll32	a1,a3,0
[ 523] 0x900000001fc151f0:  ac c0 00 00 sw	zero,0(a2)
[ 523] 0x900000001fc151f4:  00 05 2e ba dsrl	a1,a1,26
[ 523] 0x900000001fc151f8:  a0 c0 00 08 sb	zero,8(a2)
[ 523] 0x900000001fc151fc:  00 a1 28 2f dsubu	a1,a1,at
[ 523] 0x900000001fc15200:  a0 c0 00 09 sb	zero,9(a2)
[ 523] 0x900000001fc15204:  00 09 30 3c dsll32	a2,a5,0
[ 523] 0x900000001fc15208:  ac a0 00 00 sw	zero,0(a1)
[ 523] 0x900000001fc1520c:  00 06 1e ba dsrl	v1,a2,26
[ 523] 0x900000001fc15210:  25 28 00 04 addiu	a4,a5,4
[ 523] 0x900000001fc15214:  a0 a0 00 08 sb	zero,8(a1)
[ 523] 0x900000001fc15218:  00 61 18 2f dsubu	v1,v1,at
[ 523] 0x900000001fc1521c:  25 24 00 01 addiu	a0,a5,1
[ 523] 0x900000001fc15220:  a0 a0 00 09 sb	zero,9(a1)
[ 523] 0x900000001fc15224:  00 04 20 3c dsll32	a0,a0,0
[ 523] 0x900000001fc15228:  01 22 28 2b sltu	a1,a5,v0
[ 523] 0x900000001fc1522c:  ac 60 00 00 sw	zero,0(v1)
[ 523] 0x900000001fc15230:  14 a0 ff c5 bne	a1,zero,0x900000001fc15148
[ 523] 0x900000001fc15234:  00 04 26 ba dsrl	a0,a0,26
[ 523] 0x900000001fc15238:  01 20 80 25 move	s0,a5
[ 523] 0x900000001fc1523c:  00 80 88 25 move	s1,a0
[ 523] 0x900000001fc15240:  00 60 90 25 move	s2,v1
[ 523] 0x900000001fc15244:  26 08 00 02 addiu	a4,s0,2
[ 523] 0x900000001fc15248:  02 21 48 2f dsubu	a5,s1,at
[ 523] 0x900000001fc1524c:  a2 40 00 08 sb	zero,8(s2)
[ 523] 0x900000001fc15250:  a2 40 00 09 sb	zero,9(s2)
[ 523] 0x900000001fc15254:  00 08 40 3c dsll32	a4,a4,0
[ 523] 0x900000001fc15258:  00 08 46 ba dsrl	a4,a4,26
[ 523] 0x900000001fc1525c:  a1 20 00 08 sb	zero,8(a5)
[ 523] 0x900000001fc15260:  26 07 00 03 addiu	a3,s0,3
[ 523] 0x900000001fc15264:  ad 20 00 00 sw	zero,0(a5)
[ 523] 0x900000001fc15268:  01 01 40 2f dsubu	a4,a4,at
[ 523] 0x900000001fc1526c:  00 07 38 3c dsll32	a3,a3,0
[ 523] 0x900000001fc15270:  a1 20 00 09 sb	zero,9(a5)
[ 523] 0x900000001fc15274:  00 07 3e ba dsrl	a3,a3,26
[ 523] 0x900000001fc15278:  a1 00 00 08 sb	zero,8(a4)
[ 523] 0x900000001fc1527c:  00 e1 38 2f dsubu	a3,a3,at
[ 523] 0x900000001fc15280:  ad 00 00 00 sw	zero,0(a4)
[ 523] 0x900000001fc15284:  a1 00 00 09 sb	zero,9(a4)
[ 523] 0x900000001fc15288:  a0 e0 00 08 sb	zero,8(a3)
[ 523] 0x900000001fc1528c:  ac e0 00 00 sw	zero,0(a3)
[ 523] 0x900000001fc15290:  10 00 00 24 b		0x900000001fc15324
[ 523] 0x900000001fc15294:  a0 e0 00 09 sb	zero,9(a3)
[ 523] 0x900000001fc15298:  01 00 80 25 move	s0,a4
[ 523] 0x900000001fc1529c:  00 80 88 25 move	s1,a0
[ 523] 0x900000001fc152a0:  10 00 ff e8 b		0x900000001fc15244
[ 523] 0x900000001fc152a4:  00 60 90 25 move	s2,v1
[ 523] 0x900000001fc152a8:  00 10 50 3c dsll32	a6,s0,0
[ 523] 0x900000001fc152ac:  00 0a 76 ba dsrl	t2,a6,26
[ 523] 0x900000001fc152b0:  26 0a 00 01 addiu	a6,s0,1
[ 523] 0x900000001fc152b4:  01 c1 70 2f dsubu	t2,t2,at
[ 523] 0x900000001fc152b8:  00 0a 68 3c dsll32	t1,a6,0
[ 523] 0x900000001fc152bc:  00 0d 6e ba dsrl	t1,t1,26
[ 523] 0x900000001fc152c0:  a1 c0 00 08 sb	zero,8(t2)
[ 523] 0x900000001fc152c4:  26 0a 00 02 addiu	a6,s0,2
[ 523] 0x900000001fc152c8:  01 a1 68 2f dsubu	t1,t1,at
[ 523] 0x900000001fc152cc:  ad c0 00 00 sw	zero,0(t2)
[ 523] 0x900000001fc152d0:  00 0a 50 3c dsll32	a6,a6,0
[ 523] 0x900000001fc152d4:  a1 c0 00 09 sb	zero,9(t2)
[ 523] 0x900000001fc152d8:  00 0a 56 ba dsrl	a6,a6,26
[ 523] 0x900000001fc152dc:  a1 a0 00 08 sb	zero,8(t1)
[ 523] 0x900000001fc152e0:  26 0c 00 03 addiu	t0,s0,3
[ 523] 0x900000001fc152e4:  01 41 50 2f dsubu	a6,a6,at
[ 523] 0x900000001fc152e8:  ad a0 00 00 sw	zero,0(t1)
[ 523] 0x900000001fc152ec:  00 0c 60 3c dsll32	t0,t0,0
[ 523] 0x900000001fc152f0:  a1 a0 00 09 sb	zero,9(t1)
[ 523] 0x900000001fc152f4:  00 0c 66 ba dsrl	t0,t0,26
[ 523] 0x900000001fc152f8:  a1 40 00 08 sb	zero,8(a6)
[ 523] 0x900000001fc152fc:  01 81 60 2f dsubu	t0,t0,at
[ 523] 0x900000001fc15300:  ad 40 00 00 sw	zero,0(a6)
[ 523] 0x900000001fc15304:  a1 40 00 09 sb	zero,9(a6)
[ 523] 0x900000001fc15308:  a1 80 00 08 sb	zero,8(t0)
[ 523] 0x900000001fc1530c:  26 10 00 04 addiu	s0,s0,4
[ 523] 0x900000001fc15310:  ad 80 00 00 sw	zero,0(t0)
[ 523] 0x900000001fc15314:  02 0b 50 2b sltu	a6,s0,a7
[ 523] 0x900000001fc15318:  a1 80 00 09 sb	zero,9(t0)
[ 523] 0x900000001fc1531c:  55 40 ff e3 bnel	a6,zero,0x900000001fc152ac
[ 523] 0x900000001fc15320:  00 10 50 3c dsll32	a6,s0,0
  524: 	mpconf = &MPCONF[vpid];
  525: 	mpconf->mpconf_magic = 0;
  526:         mpconf->phys_id = 0;
  527: 	mpconf->virt_id = 0;
  528:     }
  529: 
  530:     /* Tell the slaves to initialize their MPCONF entries */
  531: 
  532:     SENDINT_SLAVES(MPCONF_INIT_LEVEL);
[ 532] 0x900000001fc15324:  de b0 00 68 ld	s0,104(s5)
[ 532] 0x900000001fc15328:  24 0f 07 41 li	t3,1857
[ 532] 0x900000001fc1532c:  fe 0f 00 00 sd	t3,0(s0)
  533: 
  534:     /* Initialize this processor's MPCONF block */
  535: 
  536:     evcfginfo = EVCFGINFO;
  537:     ppid = (uint)(LD(EV_SPNUM) & EV_SPNUM_MASK);
[ 537] 0x900000001fc15330:  de af 02 18 ld	t3,536(s5)
[ 536] 0x900000001fc15334:  de b2 02 68 ld	s2,616(s5)
[ 536] 0x900000001fc15338:  dd ef 00 00 ld	t3,0(t3)
[ 536] 0x900000001fc1533c:  31 ef 00 3f andi	t3,t3,0x3f
[ 536] 0x900000001fc15340:  00 0f 98 00 sll	s3,t3,0
  538:     slot = (ppid & EV_SLOTNUM_MASK) >> EV_SLOTNUM_SHFT;
[ 538] 0x900000001fc15344:  32 6f 00 3c andi	t3,s3,0x3c
[ 538] 0x900000001fc15348:  00 0f b0 82 srl	s6,t3,2
  539:     proc = (ppid & EV_PROCNUM_MASK) >> EV_PROCNUM_SHFT;
  540:     vpid = evcfginfo->ecfg_board[slot].eb_cpuarr[proc].cpu_vpid;
[ 540] 0x900000001fc1534c:  00 16 78 3c dsll32	t3,s6,0
[ 540] 0x900000001fc15350:  00 0f 78 3e dsrl32	t3,t3,0
[ 540] 0x900000001fc15354:  00 0f c0 b8 dsll	t8,t3,2
[ 539] 0x900000001fc15358:  32 71 00 03 andi	s1,s3,0x3
[ 539] 0x900000001fc1535c:  00 0f a1 38 dsll	s4,t3,4
[ 539] 0x900000001fc15360:  00 0f 79 f8 dsll	t3,t3,7
[ 539] 0x900000001fc15364:  02 98 a0 2d daddu	s4,s4,t8
[ 539] 0x900000001fc15368:  00 11 80 3c dsll32	s0,s1,0
[ 539] 0x900000001fc1536c:  01 f4 78 2f dsubu	t3,t3,s4
[ 539] 0x900000001fc15370:  00 10 87 3a dsrl	s0,s0,28
[ 539] 0x900000001fc15374:  02 4f 78 2d daddu	t3,s2,t3
[ 539] 0x900000001fc15378:  01 f0 a0 2d daddu	s4,t3,s0
  541:   
  542:     /* Get this processor's speed */
  543: 
  544:     evcfginfo->ecfg_board[slot].eb_cpuarr[proc].cpu_speed = initCPUSpeed();
[ 544] 0x900000001fc1537c:  0f f0 0d 2c jal		initCPUSpeed
[ 544] 0x900000001fc15380:  92 90 00 0c lbu	s0,12(s4)
  545:  
  546:     /* Set this processor's cache size information */
  547: 
  548:     scachesz = (__uint32_t)EV_GETCONFIG_REG(slot, proc,EV_CACHE_SZ);
[ 548] 0x900000001fc15384:  de a1 02 78 ld	at,632(s5)
[ 548] 0x900000001fc15388:  00 16 7a c0 sll	t3,s6,11
[ 548] 0x900000001fc1538c:  ff b1 00 20 sd	s1,32(sp)
[ 548] 0x900000001fc15390:  00 11 89 80 sll	s1,s1,6
[ 548] 0x900000001fc15394:  26 38 00 3e addiu	t8,s1,62
[ 548] 0x900000001fc15398:  00 0f 78 3c dsll32	t3,t3,0
[ 548] 0x900000001fc1539c:  00 18 c0 c0 sll	t8,t8,3
[ 548] 0x900000001fc153a0:  00 0f 78 3e dsrl32	t3,t3,0
[ 548] 0x900000001fc153a4:  00 18 c0 3c dsll32	t8,t8,0
[ 548] 0x900000001fc153a8:  00 18 c0 3e dsrl32	t8,t8,0
[ 548] 0x900000001fc153ac:  01 f8 78 2d daddu	t3,t3,t8
[ 548] 0x900000001fc153b0:  de b8 02 70 ld	t8,624(s5)
[ 548] 0x900000001fc153b4:  01 f8 78 2d daddu	t3,t3,t8
[ 548] 0x900000001fc153b8:  a2 82 00 0d sb	v0,13(s4)
  549:     if (scachesz > (sizeof(log2vals)/sizeof(log2vals[0]))
[ 549] 0x900000001fc153bc:  00 10 88 3c dsll32	s1,s0,0
[ 549] 0x900000001fc153c0:  dd ef 00 00 ld	t3,0(t3)
[ 549] 0x900000001fc153c4:  00 0f 38 00 sll	a3,t3,0
[ 549] 0x900000001fc153c8:  00 07 78 3c dsll32	t3,a3,0
[ 549] 0x900000001fc153cc:  00 0f 58 3e dsrl32	a7,t3,0
[ 549] 0x900000001fc153d0:  00 11 8e ba dsrl	s1,s1,26
[ 549] 0x900000001fc153d4:  de b9 02 60 ld	t9,608(s5)
[ 549] 0x900000001fc153d8:  2d 6f 00 09 sltiu	t3,a7,9
[ 549] 0x900000001fc153dc:  ff b6 00 18 sd	s6,24(sp)
[ 549] 0x900000001fc153e0:  11 e0 00 06 beq	t3,zero,0x900000001fc153fc
[ 549] 0x900000001fc153e4:  02 39 88 2f dsubu	s1,s1,t9
[ 549] 0x900000001fc153e8:  00 0b f8 b8 dsll	ra,a7,2
[ 549] 0x900000001fc153ec:  03 e1 f8 2d daddu	ra,ra,at
[ 549] 0x900000001fc153f0:  8f ff 00 00 lw	ra,0(ra)
[ 549] 0x900000001fc153f4:  57 e0 00 07 bnel	ra,zero,0x900000001fc15414
[ 549] 0x900000001fc153f8:  00 0b 40 b8 dsll	a4,a7,2
  550: 		    || log2vals[scachesz] == 0) {
  551: 	loprintf("*** slot %d proc %d Invalid cache size (%x), "
[ 551] 0x900000001fc153fc:  66 a4 02 20 daddiu	a0,s5,544
[ 551] 0x900000001fc15400:  df a6 00 20 ld	a2,32(sp)
[ 551] 0x900000001fc15404:  0f f0 2c e3 jal		loprintf
[ 551] 0x900000001fc15408:  df a5 00 18 ld	a1,24(sp)
  552: 		 "assuming 1 MB.\n",
  553: 		 slot,proc, scachesz);
  554: 	scachesz = 3;
[ 554] 0x900000001fc1540c:  24 0b 00 03 li	a7,3
[ 554] 0x900000001fc15410:  00 0b 40 b8 dsll	a4,a7,2
  555:     }
  556: 
  557:     evcfginfo->ecfg_board[slot].eb_cpuarr[proc].cpu_cachesz =
[ 557] 0x900000001fc15414:  de a9 02 78 ld	a5,632(s5)
[ 557] 0x900000001fc15418:  01 09 b0 2d daddu	s6,a4,a5
[ 557] 0x900000001fc1541c:  8e c8 00 00 lw	a4,0(s6)
[ 557] 0x900000001fc15420:  a2 88 00 0e sb	a4,14(s4)
[ 557] 0x900000001fc15424:  df b4 00 40 ld	s4,64(sp)
  558: 							log2vals[scachesz];
  559: 
  560:  
  561:     mpconf = &MPCONF[vpid];
  562:     mpconf->phys_id = ppid;
[ 562] 0x900000001fc15428:  a2 33 00 08 sb	s3,8(s1)
  563:     mpconf->virt_id = vpid;
[ 563] 0x900000001fc1542c:  a2 30 00 09 sb	s0,9(s1)
  564:     mpconf->errno = 0;
[ 564] 0x900000001fc15430:  0f f0 0d 9a jal		get_ERTOIP
[ 564] 0x900000001fc15434:  a2 20 00 0a sb	zero,10(s1)
[ 564] 0x900000001fc15438:  00 02 40 00 sll	a4,v0,0
  565:     mpconf->ertoip = (int)get_ERTOIP();
  566:     mpconf->proc_type = EV_CPU_R10000;
[ 566] 0x900000001fc1543c:  ae 28 00 14 sw	a4,20(s1)
[ 566] 0x900000001fc15440:  24 08 00 03 li	a4,3
[ 566] 0x900000001fc15444:  a2 28 00 0b sb	a4,11(s1)
  567:     mpconf->launch = 0;
[ 567] 0x900000001fc15448:  ae 20 00 0c sw	zero,12(s1)
  568:     mpconf->rendezvous = 0;
[ 568] 0x900000001fc1544c:  ae 20 00 10 sw	zero,16(s1)
  569:     mpconf->bevnormal = 0;
[ 569] 0x900000001fc15450:  ae 20 00 18 sw	zero,24(s1)
  570:     mpconf->scache_size = log2vals[scachesz];
[ 570] 0x900000001fc15454:  8e c9 00 00 lw	a5,0(s6)
[ 570] 0x900000001fc15458:  df b6 00 28 ld	s6,40(sp)
[ 570] 0x900000001fc1545c:  ae 29 00 20 sw	a5,32(s1)
  571:     mpconf->nonbss = 0;
[ 571] 0x900000001fc15460:  ae 20 00 24 sw	zero,36(s1)
  572:     mpconf->stack = 0;
[ 572] 0x900000001fc15464:  ae 20 00 28 sw	zero,40(s1)
  573:     mpconf->lnch_parm = mpconf->rndv_parm = 0;
  574:     mpconf->mpconf_magic = MPCONF_MAGIC;
  575:     mpconf->pr_id = (int)readCP0(C0_PRID);
[ 575] 0x900000001fc15468:  3c 08 ba dd lui	a4,0xbadd
[ 575] 0x900000001fc1546c:  24 04 00 0f li	a0,15
[ 575] 0x900000001fc15470:  ae 20 00 30 sw	zero,48(s1)
[ 575] 0x900000001fc15474:  35 08 ee d2 ori	a4,a4,0xeed2
[ 575] 0x900000001fc15478:  ae 20 00 2c sw	zero,44(s1)
[ 575] 0x900000001fc1547c:  0f f0 17 53 jal		readCP0
[ 575] 0x900000001fc15480:  ae 28 00 00 sw	a4,0(s1)
[ 575] 0x900000001fc15484:  00 02 40 00 sll	a4,v0,0
  576: 
  577:     /* Setup the GDA */
  578:     GDA->g_promop = 0;
[ 578] 0x900000001fc15488:  de b0 02 80 ld	s0,640(s5)
[ 578] 0x900000001fc1548c:  df b5 00 38 ld	s5,56(sp)
[ 578] 0x900000001fc15490:  ae 28 00 34 sw	a4,52(s1)
[ 578] 0x900000001fc15494:  df b1 00 58 ld	s1,88(sp)
  579:     GDA->g_nmivec = 0;
  580:     GDA->g_masterspnum = ppid;
[ 580] 0x900000001fc15498:  ae 13 00 10 sw	s3,16(s0)
[ 580] 0x900000001fc1549c:  df b3 00 48 ld	s3,72(sp)
[ 579] 0x900000001fc154a0:  3c 08 58 46 lui	a4,0x5846
[ 579] 0x900000001fc154a4:  ae 00 00 08 sw	zero,8(s0)
[ 579] 0x900000001fc154a8:  35 08 45 52 ori	a4,a4,0x4552
[ 579] 0x900000001fc154ac:  ae 00 00 04 sw	zero,4(s0)
[ 579] 0x900000001fc154b0:  ae 08 00 00 sw	a4,0(s0)
  581:     GDA->g_magic = GDA_MAGIC;
  582:     GDA->g_vds = evcfginfo->ecfg_debugsw;
  583:     GDA->g_epc =  get_epcuart_base();
[ 583] 0x900000001fc154b4:  8e 48 06 d8 lw	a4,1752(s2)
[ 583] 0x900000001fc154b8:  df b2 00 50 ld	s2,80(sp)
[ 583] 0x900000001fc154bc:  0f f0 0d a1 jal		get_epcuart_base
[ 583] 0x900000001fc154c0:  ae 08 00 28 sw	a4,40(s0)
  584: 
  585: } 
[ 585] 0x900000001fc154c4:  df bf 00 30 ld	ra,48(sp)
[ 585] 0x900000001fc154c8:  fe 02 00 40 sd	v0,64(s0)
[ 585] 0x900000001fc154cc:  df b0 00 60 ld	s0,96(sp)
[ 585] 0x900000001fc154d0:  03 e0 00 08 jr	ra
[ 585] 0x900000001fc154d4:  67 bd 00 70 daddiu	sp,sp,112
Skipping source listing to line 95 of /cores/banyan/stand/arcs/IP25prom/epc_regtest.c...
   96: };
   97: 
   98: #define NUM_TEST_PATS	6
   99: 
  100: uint test_patterns[NUM_TEST_PATS] = {
  101:     0x0, 0xFFFFFFFF, 0x55555555, 0xAAAAAAAA, 0xA5A5A5A5, 0x5A5A5A5A
  102: };
  103: 
  104: int pod_check_epc(int slot, int adap, int window)
  105: {
pod_check_epc:
[ 105] 0x900000001fc154d8:  67 bd fe f0 daddiu	sp,sp,-272
[ 105] 0x900000001fc154dc:  ff b0 00 90 sd	s0,144(sp)
[ 105] 0x900000001fc154e0:  00 a0 80 25 move	s0,a1
  106:     uint pat_num, retval, readback, wroteout, int_mask;
  107:     T_Regs *treg;
  108:     uint storage[28];
  109: 
  110:     retval=0;
  111: 
  112:     ccloprintf("Testing master EPC (slot %b, adap %a)...\n", slot, adap);
[ 112] 0x900000001fc154e4:  ff b1 00 88 sd	s1,136(sp)
[ 112] 0x900000001fc154e8:  00 c0 88 25 move	s1,a2
[ 112] 0x900000001fc154ec:  3c 01 90 00 lui	at,0x9000
[ 112] 0x900000001fc154f0:  00 a0 30 25 move	a2,a1
[ 112] 0x900000001fc154f4:  60 21 00 00 daddi	at,at,0
[ 112] 0x900000001fc154f8:  3c 03 90 00 lui	v1,0x9000
[ 112] 0x900000001fc154fc:  3c 02 1f c2 lui	v0,0x1fc2
[ 112] 0x900000001fc15500:  60 63 00 00 daddi	v1,v1,0
[ 112] 0x900000001fc15504:  60 42 ef 60 daddi	v0,v0,-4256
[ 112] 0x900000001fc15508:  ff b3 00 78 sd	s3,120(sp)
[ 112] 0x900000001fc1550c:  3c 07 1f c2 lui	a3,0x1fc2
[ 112] 0x900000001fc15510:  00 01 08 3c dsll32	at,at,0
[ 112] 0x900000001fc15514:  ff b2 00 80 sd	s2,128(sp)
[ 112] 0x900000001fc15518:  60 f3 ee 18 daddi	s3,a3,-4584
[ 112] 0x900000001fc1551c:  00 03 90 3c dsll32	s2,v1,0
[ 112] 0x900000001fc15520:  ff a4 00 00 sd	a0,0(sp)
[ 112] 0x900000001fc15524:  ff a5 00 08 sd	a1,8(sp)
[ 112] 0x900000001fc15528:  00 80 28 25 move	a1,a0
[ 112] 0x900000001fc1552c:  ff bf 00 98 sd	ra,152(sp)
[ 112] 0x900000001fc15530:  0f f0 2c fa jal		ccloprintf
[ 112] 0x900000001fc15534:  00 22 20 2c dadd	a0,at,v0
[ 112] 0x900000001fc15538:  02 53 18 2c dadd	v1,s2,s3
  113: 
  114:     /*
  115:      * Get the current interrupt mask contents and disable all interrupt
  116:      * sources - if cannot disable interrupts, exit
  117:      */
  118: /* XXX - deal with me.
  119:     setup_err_intr(slot, adap);
  120: */
  121:     int_mask = (0xFF & (uint)EPC_PROMGET(window, adap, EPC_ISTAT));
[ 121] 0x900000001fc1553c:  00 11 0c c0 sll	at,s1,19
[ 121] 0x900000001fc15540:  00 10 14 00 sll	v0,s0,16
[ 121] 0x900000001fc15544:  ff b6 00 60 sd	s6,96(sp)
[ 121] 0x900000001fc15548:  00 22 b0 2d daddu	s6,at,v0
[ 121] 0x900000001fc1554c:  dc 61 02 60 ld	at,608(v1)
[ 121] 0x900000001fc15550:  34 02 ff ff ori	v0,zero,0xffff
[ 121] 0x900000001fc15554:  02 c1 08 2d daddu	at,s6,at
[ 121] 0x900000001fc15558:  00 02 14 38 dsll	v0,v0,16
[ 121] 0x900000001fc1555c:  ff b7 00 58 sd	s7,88(sp)
[ 121] 0x900000001fc15560:  34 57 ff ff ori	s7,v0,0xffff
[ 121] 0x900000001fc15564:  dc 22 00 00 ld	v0,0(at)
[ 121] 0x900000001fc15568:  00 57 10 24 and	v0,v0,s7
  122:     EPC_PROMSET(window, adap, EPC_IMRST, int_mask);
[ 122] 0x900000001fc1556c:  30 42 00 ff andi	v0,v0,0xff
[ 122] 0x900000001fc15570:  ff be 00 50 sd	s8,80(sp)
[ 122] 0x900000001fc15574:  24 1e ff ff li	s8,-1
[ 122] 0x900000001fc15578:  00 5e 10 24 and	v0,v0,s8
[ 122] 0x900000001fc1557c:  ff a3 00 10 sd	v1,16(sp)
[ 122] 0x900000001fc15580:  dc 63 02 68 ld	v1,616(v1)
[ 122] 0x900000001fc15584:  00 02 10 3c dsll32	v0,v0,0
[ 122] 0x900000001fc15588:  02 c3 18 2d daddu	v1,s6,v1
[ 122] 0x900000001fc1558c:  00 02 10 3e dsrl32	v0,v0,0
[ 122] 0x900000001fc15590:  ff b5 00 68 sd	s5,104(sp)
[ 122] 0x900000001fc15594:  ff a2 00 18 sd	v0,24(sp)
[ 122] 0x900000001fc15598:  fc 62 00 00 sd	v0,0(v1)
  123:     readback = (uint)EPC_PROMGET(window, adap, EPC_ISTAT);
[ 123] 0x900000001fc1559c:  dc 21 00 00 ld	at,0(at)
[ 123] 0x900000001fc155a0:  00 37 08 24 and	at,at,s7
  124:     if (readback != 0) {
[ 124] 0x900000001fc155a4:  00 01 90 00 sll	s2,at,0
[ 124] 0x900000001fc155a8:  df b8 00 10 ld	t8,16(sp)
[ 124] 0x900000001fc155ac:  ff b4 00 70 sd	s4,112(sp)
[ 124] 0x900000001fc155b0:  56 40 00 6f bnel	s2,zero,0x900000001fc15770
[ 124] 0x900000001fc155b4:  df b3 00 10 ld	s3,16(sp)
  125: 	ccloprintf("*** ERROR: epc_regtest - slot %b, adap %b, register %s\n",
  126: 		slot, adap, "EPC_ISTAT");
  127: 	ccloprintf("    read back %x, expected 0\n", readback);
  128: 	ccloprintf("    unable to disable EPC interrupts\n");
  129: 	retval++;
  130: 	goto TEST_DONE;
  131:     }
  132: 
  133: 
  134:     /*
  135:      * save existing values from the registers to be tested
  136:      */
  137:     for (treg = epc_testregs; treg->offset != -1; treg++)
[ 137] 0x900000001fc155b8:  df 14 02 78 ld	s4,632(t8)
[ 137] 0x900000001fc155bc:  df 18 02 70 ld	t8,624(t8)
[ 137] 0x900000001fc155c0:  03 00 88 25 move	s1,t8
[ 137] 0x900000001fc155c4:  24 02 00 06 li	v0,6
[ 137] 0x900000001fc155c8:  ff a0 00 28 sd	zero,40(sp)
[ 137] 0x900000001fc155cc:  8f 18 00 04 lw	t8,4(t8)
[ 137] 0x900000001fc155d0:  ff a2 00 20 sd	v0,32(sp)
[ 137] 0x900000001fc155d4:  24 15 ff ff li	s5,-1
[ 137] 0x900000001fc155d8:  00 00 18 3c dsll32	v1,zero,0
[ 137] 0x900000001fc155dc:  df a4 00 10 ld	a0,16(sp)
[ 137] 0x900000001fc155e0:  13 15 00 10 beq	t8,s5,0x900000001fc15624
[ 137] 0x900000001fc155e4:  df b9 00 28 ld	t9,40(sp)
  138: 	storage[treg->index] = EPC_PROMGET(window, adap, treg->offset);
[ 138] 0x900000001fc155e8:  8e 3f 00 04 lw	ra,4(s1)
[ 138] 0x900000001fc155ec:  02 df f8 2d daddu	ra,s6,ra
[ 138] 0x900000001fc155f0:  8e 21 00 00 lw	at,0(s1)
[ 138] 0x900000001fc155f4:  03 f4 f8 2d daddu	ra,ra,s4
[ 138] 0x900000001fc155f8:  00 01 08 3c dsll32	at,at,0
[ 138] 0x900000001fc155fc:  00 01 0f ba dsrl	at,at,30
[ 138] 0x900000001fc15600:  df ff 00 00 ld	ra,0(ra)
[ 138] 0x900000001fc15604:  03 a1 08 2d daddu	at,sp,at
[ 138] 0x900000001fc15608:  03 f7 f8 24 and	ra,ra,s7
[ 137] 0x900000001fc1560c:  00 1f f8 00 sll	ra,ra,0
[ 137] 0x900000001fc15610:  66 31 00 18 daddiu	s1,s1,24
[ 137] 0x900000001fc15614:  ac 3f 00 a0 sw	ra,160(at)
[ 137] 0x900000001fc15618:  8e 3f 00 04 lw	ra,4(s1)
[ 137] 0x900000001fc1561c:  57 f5 ff f3 bnel	ra,s5,0x900000001fc155ec
[ 137] 0x900000001fc15620:  8e 3f 00 04 lw	ra,4(s1)
  139:     
  140:     /*
  141:      * run all test patterns, now
  142:      */
  143:     for (pat_num = 0; pat_num < NUM_TEST_PATS; pat_num++) {
[ 143] 0x900000001fc15624:  df a1 00 10 ld	at,16(sp)
[ 143] 0x900000001fc15628:  ff a0 00 30 sd	zero,48(sp)
[ 143] 0x900000001fc1562c:  64 22 02 08 daddiu	v0,at,520
[ 143] 0x900000001fc15630:  ff a2 00 40 sd	v0,64(sp)
[ 143] 0x900000001fc15634:  64 22 02 40 daddiu	v0,at,576
[ 143] 0x900000001fc15638:  dc 21 02 70 ld	at,624(at)
[ 143] 0x900000001fc1563c:  ff a2 00 48 sd	v0,72(sp)
[ 143] 0x900000001fc15640:  64 21 02 a0 daddiu	at,at,672
[ 143] 0x900000001fc15644:  dc 84 02 70 ld	a0,624(a0)
[ 143] 0x900000001fc15648:  ff a1 00 38 sd	at,56(sp)
[ 143] 0x900000001fc1564c:  df a5 00 38 ld	a1,56(sp)
[ 143] 0x900000001fc15650:  00 03 87 ba dsrl	s0,v1,30
  144: 
  145: 	/*
  146: 	 * write new test pattern
  147: 	 */
  148: 	for (treg = epc_testregs; treg->offset != -1; treg++)
[ 148] 0x900000001fc15654:  02 05 98 2d daddu	s3,s0,a1
[ 148] 0x900000001fc15658:  00 80 88 25 move	s1,a0
[ 148] 0x900000001fc1565c:  8c 84 00 04 lw	a0,4(a0)
[ 148] 0x900000001fc15660:  50 95 00 10 beql	a0,s5,0x900000001fc156a4
[ 148] 0x900000001fc15664:  df a8 00 10 ld	a4,16(sp)
  149: 	    EPC_PROMSET(window, adap, treg->offset,
[ 149] 0x900000001fc15668:  8e 26 00 08 lw	a2,8(s1)
[ 149] 0x900000001fc1566c:  8e 67 00 00 lw	a3,0(s3)
[ 149] 0x900000001fc15670:  00 c7 30 24 and	a2,a2,a3
[ 149] 0x900000001fc15674:  8e 27 00 04 lw	a3,4(s1)
[ 149] 0x900000001fc15678:  02 c7 38 2d daddu	a3,s6,a3
[ 149] 0x900000001fc1567c:  00 de 30 24 and	a2,a2,s8
[ 149] 0x900000001fc15680:  00 f4 38 2d daddu	a3,a3,s4
[ 149] 0x900000001fc15684:  00 06 30 3c dsll32	a2,a2,0
[ 148] 0x900000001fc15688:  00 06 30 3e dsrl32	a2,a2,0
[ 148] 0x900000001fc1568c:  66 31 00 18 daddiu	s1,s1,24
[ 148] 0x900000001fc15690:  fc e6 00 00 sd	a2,0(a3)
[ 148] 0x900000001fc15694:  8e 26 00 04 lw	a2,4(s1)
[ 148] 0x900000001fc15698:  54 d5 ff f4 bnel	a2,s5,0x900000001fc1566c
[ 148] 0x900000001fc1569c:  8e 26 00 08 lw	a2,8(s1)
  150: 		    treg->mask & test_patterns[pat_num]);
  151: 
  152: 	/*
  153: 	 * verify test patterns in the registers
  154: 	 */
  155: 	for (treg = epc_testregs; treg->offset != -1; treg++) {
[ 155] 0x900000001fc156a0:  df a8 00 10 ld	a4,16(sp)
[ 155] 0x900000001fc156a4:  df a9 00 30 ld	a5,48(sp)
[ 155] 0x900000001fc156a8:  dd 08 02 70 ld	a4,624(a4)
[ 155] 0x900000001fc156ac:  00 09 48 3c dsll32	a5,a5,0
[ 155] 0x900000001fc156b0:  00 09 4f ba dsrl	a5,a5,30
[ 155] 0x900000001fc156b4:  df aa 00 38 ld	a6,56(sp)
[ 155] 0x900000001fc156b8:  01 00 88 25 move	s1,a4
[ 155] 0x900000001fc156bc:  01 2a 98 2d daddu	s3,a5,a6
[ 155] 0x900000001fc156c0:  8d 08 00 04 lw	a4,4(a4)
[ 155] 0x900000001fc156c4:  51 15 00 1d beql	a4,s5,0x900000001fc1573c
[ 155] 0x900000001fc156c8:  df a4 00 10 ld	a0,16(sp)
[ 155] 0x900000001fc156cc:  df a6 00 08 ld	a2,8(sp)
  156: 	    wroteout = (test_patterns[pat_num] & treg->mask);
  157: 	    readback =  (uint)EPC_PROMGET(window, adap, treg->offset);
[ 157] 0x900000001fc156d0:  8e 2b 00 04 lw	a7,4(s1)
[ 157] 0x900000001fc156d4:  df a5 00 00 ld	a1,0(sp)
[ 157] 0x900000001fc156d8:  02 cb 58 2d daddu	a7,s6,a7
[ 157] 0x900000001fc156dc:  01 74 58 2d daddu	a7,a7,s4
[ 156] 0x900000001fc156e0:  8e 2c 00 08 lw	t0,8(s1)
[ 156] 0x900000001fc156e4:  8e 6d 00 00 lw	t1,0(s3)
[ 156] 0x900000001fc156e8:  dd 6b 00 00 ld	a7,0(a7)
[ 156] 0x900000001fc156ec:  01 77 58 24 and	a7,a7,s7
[ 156] 0x900000001fc156f0:  01 8d 80 24 and	s0,t0,t1
[ 156] 0x900000001fc156f4:  00 0b 90 00 sll	s2,a7,0
  158: 
  159: 	    if (readback != wroteout) {
[ 159] 0x900000001fc156f8:  52 50 00 0c beql	s2,s0,0x900000001fc1572c
[ 159] 0x900000001fc156fc:  66 31 00 18 daddiu	s1,s1,24
  160: 		ccloprintf("*** ERROR: epc_regtest - slot %b, adap %b, register %s\n",
[ 160] 0x900000001fc15700:  de 27 00 10 ld	a3,16(s1)
[ 160] 0x900000001fc15704:  ff b9 00 28 sd	t9,40(sp)
[ 160] 0x900000001fc15708:  0f f0 2c fa jal		ccloprintf
[ 160] 0x900000001fc1570c:  df a4 00 40 ld	a0,64(sp)
  161: 			slot, adap, treg->name);
  162: 		ccloprintf("    read back %x, expected %x\n",
[ 162] 0x900000001fc15710:  02 00 30 25 move	a2,s0
[ 162] 0x900000001fc15714:  02 40 28 25 move	a1,s2
[ 162] 0x900000001fc15718:  0f f0 2c fa jal		ccloprintf
[ 162] 0x900000001fc1571c:  df a4 00 48 ld	a0,72(sp)
  163: 			readback, wroteout);
  164: 		retval++;
[ 164] 0x900000001fc15720:  df ae 00 28 ld	t2,40(sp)
[ 164] 0x900000001fc15724:  25 d9 00 01 addiu	t9,t2,1
[ 164] 0x900000001fc15728:  66 31 00 18 daddiu	s1,s1,24
[ 155] 0x900000001fc1572c:  8e 2f 00 04 lw	t3,4(s1)
[ 155] 0x900000001fc15730:  55 f5 ff e7 bnel	t3,s5,0x900000001fc156d0
[ 155] 0x900000001fc15734:  df a6 00 08 ld	a2,8(sp)
[ 155] 0x900000001fc15738:  df a4 00 10 ld	a0,16(sp)
[ 143] 0x900000001fc1573c:  df b0 00 30 ld	s0,48(sp)
[ 143] 0x900000001fc15740:  df a5 00 38 ld	a1,56(sp)
[ 143] 0x900000001fc15744:  26 11 00 01 addiu	s1,s0,1
[ 143] 0x900000001fc15748:  00 11 80 3c dsll32	s0,s1,0
[ 143] 0x900000001fc1574c:  df b2 00 20 ld	s2,32(sp)
[ 143] 0x900000001fc15750:  ff b1 00 30 sd	s1,48(sp)
[ 143] 0x900000001fc15754:  dc 84 02 70 ld	a0,624(a0)
[ 143] 0x900000001fc15758:  16 32 ff be bne	s1,s2,0x900000001fc15654
[ 143] 0x900000001fc1575c:  00 10 87 ba dsrl	s0,s0,30
[ 143] 0x900000001fc15760:  df b4 00 10 ld	s4,16(sp)
[ 143] 0x900000001fc15764:  10 00 00 13 b		0x900000001fc157b4
[ 143] 0x900000001fc15768:  df b3 00 78 ld	s3,120(sp)
[ 125] 0x900000001fc1576c:  df b3 00 10 ld	s3,16(sp)
[ 125] 0x900000001fc15770:  ff a0 00 28 sd	zero,40(sp)
[ 125] 0x900000001fc15774:  66 67 01 b0 daddiu	a3,s3,432
[ 125] 0x900000001fc15778:  df a6 00 08 ld	a2,8(sp)
[ 125] 0x900000001fc1577c:  df a5 00 00 ld	a1,0(sp)
[ 125] 0x900000001fc15780:  24 02 00 06 li	v0,6
[ 125] 0x900000001fc15784:  ff a2 00 20 sd	v0,32(sp)
[ 125] 0x900000001fc15788:  0f f0 2c fa jal		ccloprintf
[ 125] 0x900000001fc1578c:  66 64 01 78 daddiu	a0,s3,376
[ 127] 0x900000001fc15790:  02 40 28 25 move	a1,s2
[ 127] 0x900000001fc15794:  0f f0 2c fa jal		ccloprintf
[ 127] 0x900000001fc15798:  66 64 01 c0 daddiu	a0,s3,448
[ 128] 0x900000001fc1579c:  0f f0 2c fa jal		ccloprintf
[ 128] 0x900000001fc157a0:  66 64 01 e0 daddiu	a0,s3,480
[ 129] 0x900000001fc157a4:  df b4 00 10 ld	s4,16(sp)
[ 129] 0x900000001fc157a8:  24 19 00 01 li	t9,1
[ 130] 0x900000001fc157ac:  24 15 ff ff li	s5,-1
[ 130] 0x900000001fc157b0:  df b3 00 78 ld	s3,120(sp)
  165: 	    }
  166: 	}
  167:     }
  168: 	
  169: TEST_DONE:
  170: 
  171:     /*
  172:      * restore existing values to the registers tested
  173:      */
  174:     for (treg = epc_testregs; treg->offset != -1; treg++)
[ 174] 0x900000001fc157b4:  de 94 02 70 ld	s4,624(s4)
[ 174] 0x900000001fc157b8:  df b0 00 90 ld	s0,144(sp)
[ 174] 0x900000001fc157bc:  df b2 00 80 ld	s2,128(sp)
[ 174] 0x900000001fc157c0:  02 80 88 25 move	s1,s4
[ 174] 0x900000001fc157c4:  df b7 00 10 ld	s7,16(sp)
[ 174] 0x900000001fc157c8:  8e 94 00 04 lw	s4,4(s4)
[ 174] 0x900000001fc157cc:  52 95 00 13 beql	s4,s5,0x900000001fc1581c
[ 174] 0x900000001fc157d0:  df bf 00 98 ld	ra,152(sp)
[ 174] 0x900000001fc157d4:  de f4 02 78 ld	s4,632(s7)
[ 174] 0x900000001fc157d8:  8e 38 00 00 lw	t8,0(s1)
  175: 	EPC_PROMSET(window, adap, treg->offset, storage[treg->index]);
[ 175] 0x900000001fc157dc:  00 18 c0 3c dsll32	t8,t8,0
[ 175] 0x900000001fc157e0:  00 18 c7 ba dsrl	t8,t8,30
[ 175] 0x900000001fc157e4:  03 b8 c0 2d daddu	t8,sp,t8
[ 175] 0x900000001fc157e8:  8e 3f 00 04 lw	ra,4(s1)
[ 175] 0x900000001fc157ec:  8f 18 00 a0 lw	t8,160(t8)
[ 175] 0x900000001fc157f0:  02 df f8 2d daddu	ra,s6,ra
[ 175] 0x900000001fc157f4:  03 1e c0 24 and	t8,t8,s8
[ 175] 0x900000001fc157f8:  03 f4 f8 2d daddu	ra,ra,s4
[ 175] 0x900000001fc157fc:  00 18 c0 3c dsll32	t8,t8,0
[ 174] 0x900000001fc15800:  00 18 c0 3e dsrl32	t8,t8,0
[ 174] 0x900000001fc15804:  66 31 00 18 daddiu	s1,s1,24
[ 174] 0x900000001fc15808:  ff f8 00 00 sd	t8,0(ra)
[ 174] 0x900000001fc1580c:  8e 38 00 04 lw	t8,4(s1)
[ 174] 0x900000001fc15810:  57 15 ff f2 bnel	t8,s5,0x900000001fc157dc
[ 174] 0x900000001fc15814:  8e 38 00 00 lw	t8,0(s1)
[ 174] 0x900000001fc15818:  df bf 00 98 ld	ra,152(sp)
  176: 
  177:     /*
  178:      * restore original interrupt mask and return
  179:      */
  180:     EPC_PROMSET(window, adap, EPC_IERR, 0x1000000);
[ 180] 0x900000001fc1581c:  df a3 00 10 ld	v1,16(sp)
[ 180] 0x900000001fc15820:  df b7 00 58 ld	s7,88(sp)
[ 180] 0x900000001fc15824:  df be 00 50 ld	s8,80(sp)
[ 180] 0x900000001fc15828:  df b5 00 68 ld	s5,104(sp)
[ 180] 0x900000001fc1582c:  dc 61 02 80 ld	at,640(v1)
[ 180] 0x900000001fc15830:  df b4 00 70 ld	s4,112(sp)
[ 180] 0x900000001fc15834:  02 c1 20 2d daddu	a0,s6,at
[ 180] 0x900000001fc15838:  3c 01 01 00 lui	at,0x100
[ 180] 0x900000001fc1583c:  df b1 00 88 ld	s1,136(sp)
[ 180] 0x900000001fc15840:  fc 81 00 00 sd	at,0(a0)
  181:     readback = (uint)EPC_PROMGET(window, adap, EPC_IERRC);
[ 181] 0x900000001fc15844:  dc 61 02 88 ld	at,648(v1)
  182:     EPC_PROMSET(window, adap, EPC_IMSET, int_mask);
[ 182] 0x900000001fc15848:  02 c1 08 2d daddu	at,s6,at
[ 182] 0x900000001fc1584c:  dc 63 02 90 ld	v1,656(v1)
[ 182] 0x900000001fc15850:  02 c3 18 2d daddu	v1,s6,v1
[ 182] 0x900000001fc15854:  df b6 00 60 ld	s6,96(sp)
  183: 
  184:     if (retval)
  185: 	return EVDIAG_EPCREG_FAILED;
[ 185] 0x900000001fc15858:  24 02 00 57 li	v0,87
[ 185] 0x900000001fc1585c:  dc 20 00 00 ld	zero,0(at)
[ 185] 0x900000001fc15860:  df a1 00 18 ld	at,24(sp)
[ 185] 0x900000001fc15864:  00 19 10 0a movz	v0,zero,t9
[ 185] 0x900000001fc15868:  00 00 00 21 nada
[ 185] 0x900000001fc1586c:  00 00 00 21 nada
[ 185] 0x900000001fc15870:  00 00 00 21 nada
[ 185] 0x900000001fc15874:  fc 61 00 00 sd	at,0(v1)
  186:     else
  187: 	return EVDIAG_PASSED;
[ 187] 0x900000001fc15878:  03 e0 00 08 jr	ra
[ 187] 0x900000001fc1587c:  67 bd 01 10 daddiu	sp,sp,272
Skipping source listing to line 22 of /cores/banyan/stand/arcs/IP25prom/pod_iaram.c...
   23: 
   24: /* 
   25:  * Function : check_iaram
   26:  * Description:
   27:  *	Run tests to check the IARAM. 
   28:  *	Since the IARAM is a static ram, chances of an error are far less.
   29:  *	so we just limit ourselves to a few tests.
   30:  */
   31: uint check_iaram(unsigned window, int io4slot)
   32: {
check_iaram:
[  32] 0x900000001fc15880:  67 bd ff 50 daddiu	sp,sp,-176
   33:     unchar	cur_test = 0;
   34:     jmp_buf	mapbuf;
   35:     uint	*prev_fault;
   36:     uint	result;
   37: 
   38:     ccloprintf("Testing map RAM in master IO4's IA chip (slot %b)...\n", io4slot);
[  38] 0x900000001fc15884:  3c 01 90 00 lui	at,0x9000
[  38] 0x900000001fc15888:  60 21 00 00 daddi	at,at,0
[  38] 0x900000001fc1588c:  3c 02 1f c2 lui	v0,0x1fc2
[  38] 0x900000001fc15890:  60 42 f0 b0 daddi	v0,v0,-3920
[  38] 0x900000001fc15894:  00 01 08 3c dsll32	at,at,0
[  38] 0x900000001fc15898:  ff a4 00 10 sd	a0,16(sp)
[  38] 0x900000001fc1589c:  00 22 20 2c dadd	a0,at,v0
[  38] 0x900000001fc158a0:  ff bf 00 30 sd	ra,48(sp)
[  38] 0x900000001fc158a4:  0f f0 2c fa jal		ccloprintf
[  38] 0x900000001fc158a8:  ff a4 00 18 sd	a0,24(sp)
   39: 
   40:     if (setfault(mapbuf, &prev_fault) == 0) {
[  40] 0x900000001fc158ac:  67 a5 00 00 daddiu	a1,sp,0
[  40] 0x900000001fc158b0:  0f f0 18 7f jal		setfault
[  40] 0x900000001fc158b4:  67 a4 00 40 daddiu	a0,sp,64
[  40] 0x900000001fc158b8:  ff b0 00 28 sd	s0,40(sp)
[  40] 0x900000001fc158bc:  df b0 00 18 ld	s0,24(sp)
[  40] 0x900000001fc158c0:  50 40 00 0c beql	v0,zero,0x900000001fc158f4
[  40] 0x900000001fc158c4:  df b0 00 10 ld	s0,16(sp)
   41:         result = iaram_rdwr(window);
   42: 	cur_test++;
   43: 	result = iaram_addr(window);
   44: 	cur_test++;
   45:         result = iaram_walk1s(window);
   46:     } else {
   47: 	/* Returned here due to an exception	*/
   48: 	ccloprintf("*** Map RAM test took an exception.\n");
[  48] 0x900000001fc158c8:  0f f0 2c fa jal		ccloprintf
[  48] 0x900000001fc158cc:  66 04 00 38 daddiu	a0,s0,56
   49: 	result = (uint)FAILURE;
   50: 	switch(cur_test) {
   51: 	    case 0 :
   52: 		ccloprintf("*** Map RAM read/write test FAILED\n");
[  52] 0x900000001fc158d0:  0f f0 2c fa jal		ccloprintf
[  52] 0x900000001fc158d4:  66 04 00 60 daddiu	a0,s0,96
   53: 		result = EVDIAG_MAPRDWR_BUSERR;
   54: 		break;
[  54] 0x900000001fc158d8:  df b0 00 28 ld	s0,40(sp)
[  54] 0x900000001fc158dc:  0f f0 18 86 jal		restorefault
[  54] 0x900000001fc158e0:  df a4 00 00 ld	a0,0(sp)
   55: 	    case 1 :
   56: 		ccloprintf("*** Map RAM addres test FAILED\n");
   57: 		result = EVDIAG_MAPADDR_BUSERR;
   58: 		break;
   59: 	    case 2 :
   60: 		ccloprintf("*** Map RAM walking 1 test FAILED\n");
   61: 		result = EVDIAG_MAPWALK_BUSERR;
   62: 		break;
   63: 	    default:
   64: 		ccloprintf("*** Map RAM test unknown error\n");
   65: 		result = EVDIAG_MAP_BUSERR;
   66: 		break;
   67: 	}
   68: 	restorefault(prev_fault);
   69: 	return result;
[  69] 0x900000001fc158e4:  24 19 00 58 li	t9,88
[  69] 0x900000001fc158e8:  10 00 00 10 b		0x900000001fc1592c
[  69] 0x900000001fc158ec:  df bf 00 30 ld	ra,48(sp)
[  41] 0x900000001fc158f0:  df b0 00 10 ld	s0,16(sp)
[  41] 0x900000001fc158f4:  0f f0 56 65 jal		iaram_rdwr
[  41] 0x900000001fc158f8:  02 00 20 25 move	a0,s0
[  43] 0x900000001fc158fc:  0f f0 56 a3 jal		iaram_addr
[  43] 0x900000001fc15900:  02 00 20 25 move	a0,s0
[  45] 0x900000001fc15904:  0f f0 56 d2 jal		iaram_walk1s
[  45] 0x900000001fc15908:  02 00 20 25 move	a0,s0
   70:     }
   71: 
   72:     clear_iaram(window);
[  72] 0x900000001fc1590c:  ff a2 00 20 sd	v0,32(sp)
[  72] 0x900000001fc15910:  0f f0 56 4e jal		clear_iaram
[  72] 0x900000001fc15914:  02 00 20 25 move	a0,s0
   73: 
   74:     restorefault(prev_fault);
[  74] 0x900000001fc15918:  df b0 00 28 ld	s0,40(sp)
[  74] 0x900000001fc1591c:  0f f0 18 86 jal		restorefault
[  74] 0x900000001fc15920:  df a4 00 00 ld	a0,0(sp)
   75:     return result;
[  75] 0x900000001fc15924:  df bf 00 30 ld	ra,48(sp)
[  75] 0x900000001fc15928:  df b9 00 20 ld	t9,32(sp)
[  75] 0x900000001fc1592c:  03 20 10 25 move	v0,t9
[  75] 0x900000001fc15930:  03 e0 00 08 jr	ra
[  75] 0x900000001fc15934:  67 bd 00 b0 daddiu	sp,sp,176
   76: }
   77: 
   78: 
   79: void clear_iaram(uint window)
   80: {
clear_iaram:
[  80] 0x900000001fc15938:  00 00 30 25 move	a2,zero
[  80] 0x900000001fc1593c:  67 bd ff e0 daddiu	sp,sp,-32
[  80] 0x900000001fc15940:  ff b1 00 08 sd	s1,8(sp)
[  80] 0x900000001fc15944:  00 80 88 25 move	s1,a0
   81:     uint	i;
   82: 
   83:     for(i = 4; i < IO4_MAPRAM_SIZE; i += 8)
[  83] 0x900000001fc15948:  ff b0 00 10 sd	s0,16(sp)
[  83] 0x900000001fc1594c:  24 10 00 04 li	s0,4
[  83] 0x900000001fc15950:  02 00 28 25 move	a1,s0
[  83] 0x900000001fc15954:  ff b2 00 00 sd	s2,0(sp)
[  83] 0x900000001fc15958:  3c 12 00 01 lui	s2,0x1
[  83] 0x900000001fc1595c:  ff bf 00 18 sd	ra,24(sp)
   84: 	    store_lwin_word(window, i, 0);
[  84] 0x900000001fc15960:  0f f0 0d 77 jal		store_lwin_word
[  84] 0x900000001fc15964:  02 20 20 25 move	a0,s1
[  83] 0x900000001fc15968:  00 00 30 25 move	a2,zero
[  83] 0x900000001fc1596c:  26 10 00 08 addiu	s0,s0,8
[  83] 0x900000001fc15970:  02 12 08 2b sltu	at,s0,s2
[  83] 0x900000001fc15974:  14 20 ff fa bne	at,zero,0x900000001fc15960
[  83] 0x900000001fc15978:  02 00 28 25 move	a1,s0
[  83] 0x900000001fc1597c:  df bf 00 18 ld	ra,24(sp)
[  83] 0x900000001fc15980:  df b2 00 00 ld	s2,0(sp)
[  83] 0x900000001fc15984:  df b0 00 10 ld	s0,16(sp)
[  83] 0x900000001fc15988:  df b1 00 08 ld	s1,8(sp)
[  83] 0x900000001fc1598c:  03 e0 00 08 jr	ra
[  83] 0x900000001fc15990:  67 bd 00 20 daddiu	sp,sp,32
   85: }
   86: 
   87: 
   88: uint iaram_rdwr(uint window)
   89: {
iaram_rdwr:
[  89] 0x900000001fc15994:  67 bd ff b0 daddiu	sp,sp,-80
   90:     uint	i, j, value;
   91: 
   92:     /*
   93:      * IARAM memory is available at each double word address.
   94:      * Hence the i += 8; 
   95:      */
   96: 
   97:     for(i = 4; i < IO4_MAPRAM_SIZE; i += 8) {
[  97] 0x900000001fc15998:  3c 01 90 00 lui	at,0x9000
[  97] 0x900000001fc1599c:  60 21 00 00 daddi	at,at,0
[  97] 0x900000001fc159a0:  3c 02 1f c2 lui	v0,0x1fc2
[  97] 0x900000001fc159a4:  60 42 f0 b0 daddi	v0,v0,-3920
[  97] 0x900000001fc159a8:  00 01 08 3c dsll32	at,at,0
[  97] 0x900000001fc159ac:  ff b2 00 28 sd	s2,40(sp)
[  97] 0x900000001fc159b0:  00 22 08 2c dadd	at,at,v0
[  97] 0x900000001fc159b4:  ff b3 00 20 sd	s3,32(sp)
[  97] 0x900000001fc159b8:  00 80 98 25 move	s3,a0
[  97] 0x900000001fc159bc:  ff b1 00 30 sd	s1,48(sp)
[  97] 0x900000001fc159c0:  ff b5 00 10 sd	s5,16(sp)
[  97] 0x900000001fc159c4:  24 15 00 04 li	s5,4
[  97] 0x900000001fc159c8:  ff b6 00 08 sd	s6,8(sp)
[  97] 0x900000001fc159cc:  3c 16 00 01 lui	s6,0x1
[  97] 0x900000001fc159d0:  ff b0 00 38 sd	s0,56(sp)
[  97] 0x900000001fc159d4:  ff b4 00 18 sd	s4,24(sp)
[  97] 0x900000001fc159d8:  24 14 00 04 li	s4,4
[  97] 0x900000001fc159dc:  ff a1 00 00 sd	at,0(sp)
[  97] 0x900000001fc159e0:  dc 32 01 28 ld	s2,296(at)
[  97] 0x900000001fc159e4:  ff bf 00 40 sd	ra,64(sp)
[  97] 0x900000001fc159e8:  02 a0 28 25 move	a1,s5
   98: 	for (j = 0; j < PATRN_SIZE; j++) {
[  98] 0x900000001fc159ec:  00 00 18 3c dsll32	v1,zero,0
[  98] 0x900000001fc159f0:  00 03 1f ba dsrl	v1,v1,30
[  98] 0x900000001fc159f4:  00 00 80 25 move	s0,zero
[  98] 0x900000001fc159f8:  00 72 88 2d daddu	s1,v1,s2
[  98] 0x900000001fc159fc:  26 10 00 01 addiu	s0,s0,1
   99: 	    value = store_load_lwin_word(window, i, patterns[j]);
[  99] 0x900000001fc15a00:  8e 26 00 00 lw	a2,0(s1)
[  99] 0x900000001fc15a04:  0f f0 0d 7f jal		store_load_lwin_word
[  99] 0x900000001fc15a08:  02 60 20 25 move	a0,s3
  100: 	    if (value != patterns[j]) {
[ 100] 0x900000001fc15a0c:  00 10 38 3c dsll32	a3,s0,0
[ 100] 0x900000001fc15a10:  02 a0 28 25 move	a1,s5
[ 100] 0x900000001fc15a14:  8e 39 00 00 lw	t9,0(s1)
[ 100] 0x900000001fc15a18:  54 59 00 0b bnel	v0,t9,0x900000001fc15a48
[ 100] 0x900000001fc15a1c:  00 40 38 25 move	a3,v0
[  98] 0x900000001fc15a20:  00 07 3f ba dsrl	a3,a3,30
[  98] 0x900000001fc15a24:  16 14 ff f5 bne	s0,s4,0x900000001fc159fc
[  98] 0x900000001fc15a28:  00 f2 88 2d daddu	s1,a3,s2
[  98] 0x900000001fc15a2c:  26 b5 00 08 addiu	s5,s5,8
[  98] 0x900000001fc15a30:  02 b6 80 2b sltu	s0,s5,s6
[  97] 0x900000001fc15a34:  56 00 ff ed bnel	s0,zero,0x900000001fc159ec
[  97] 0x900000001fc15a38:  02 a0 28 25 move	a1,s5
  101: 		ccloprintf("*** ERROR in map RAM at 0x%x, Wrote %x, Read %x\n",
  102: 			i, patterns[j], 
  103: 			(unsigned)value);
  104: 		return EVDIAG_MAPRDWR_FAILED;
  105: 	    }
  106: 	}
  107:     }
  108: 
  109:     return 0;
[ 109] 0x900000001fc15a3c:  10 00 00 08 b		0x900000001fc15a60
[ 109] 0x900000001fc15a40:  00 00 80 25 move	s0,zero
[ 101] 0x900000001fc15a44:  00 40 38 25 move	a3,v0
[ 101] 0x900000001fc15a48:  03 20 30 25 move	a2,t9
[ 101] 0x900000001fc15a4c:  02 a0 28 25 move	a1,s5
[ 101] 0x900000001fc15a50:  df a8 00 00 ld	a4,0(sp)
[ 101] 0x900000001fc15a54:  0f f0 2c fa jal		ccloprintf
[ 101] 0x900000001fc15a58:  65 04 00 f0 daddiu	a0,a4,240
[ 104] 0x900000001fc15a5c:  24 10 00 5c li	s0,92
[ 104] 0x900000001fc15a60:  df b1 00 30 ld	s1,48(sp)
[ 104] 0x900000001fc15a64:  df b3 00 20 ld	s3,32(sp)
[ 104] 0x900000001fc15a68:  df b6 00 08 ld	s6,8(sp)
[ 104] 0x900000001fc15a6c:  df bf 00 40 ld	ra,64(sp)
[ 104] 0x900000001fc15a70:  02 00 10 25 move	v0,s0
[ 104] 0x900000001fc15a74:  df b4 00 18 ld	s4,24(sp)
[ 104] 0x900000001fc15a78:  df b2 00 28 ld	s2,40(sp)
[ 104] 0x900000001fc15a7c:  df b0 00 38 ld	s0,56(sp)
[ 104] 0x900000001fc15a80:  df b5 00 10 ld	s5,16(sp)
[ 104] 0x900000001fc15a84:  03 e0 00 08 jr	ra
[ 104] 0x900000001fc15a88:  67 bd 00 50 daddiu	sp,sp,80
  110: }
  111: 
  112: uint iaram_addr(uint window)
  113: {
iaram_addr:
[ 113] 0x900000001fc15a8c:  67 bd ff e0 daddiu	sp,sp,-32
[ 113] 0x900000001fc15a90:  ff b1 00 08 sd	s1,8(sp)
[ 113] 0x900000001fc15a94:  00 80 88 25 move	s1,a0
  114:     int	i;
  115:     unsigned value;
  116: 
  117:     for (i = 4; i < IO4_MAPRAM_SIZE; i += 8)
[ 117] 0x900000001fc15a98:  ff b0 00 10 sd	s0,16(sp)
[ 117] 0x900000001fc15a9c:  24 10 00 04 li	s0,4
[ 117] 0x900000001fc15aa0:  02 00 30 25 move	a2,s0
[ 117] 0x900000001fc15aa4:  ff b2 00 00 sd	s2,0(sp)
[ 117] 0x900000001fc15aa8:  3c 12 00 01 lui	s2,0x1
[ 117] 0x900000001fc15aac:  02 00 28 25 move	a1,s0
[ 117] 0x900000001fc15ab0:  ff bf 00 18 sd	ra,24(sp)
  118: 	store_lwin_word(window, i, i);
[ 118] 0x900000001fc15ab4:  0f f0 0d 77 jal		store_lwin_word
[ 118] 0x900000001fc15ab8:  02 20 20 25 move	a0,s1
[ 117] 0x900000001fc15abc:  26 10 00 08 addiu	s0,s0,8
[ 117] 0x900000001fc15ac0:  02 00 28 25 move	a1,s0
[ 117] 0x900000001fc15ac4:  02 12 08 2a slt	at,s0,s2
[ 117] 0x900000001fc15ac8:  14 20 ff fa bne	at,zero,0x900000001fc15ab4
[ 117] 0x900000001fc15acc:  02 00 30 25 move	a2,s0
[ 117] 0x900000001fc15ad0:  24 10 00 04 li	s0,4
[ 117] 0x900000001fc15ad4:  02 00 28 25 move	a1,s0
  119: 
  120:     for (i = 4; i < IO4_MAPRAM_SIZE; i += 8) {
  121: 	value = load_lwin_word(window, i);
[ 121] 0x900000001fc15ad8:  0f f0 0d 56 jal		load_lwin_word
[ 121] 0x900000001fc15adc:  02 20 20 25 move	a0,s1
  122:         if(value != i) {
[ 122] 0x900000001fc15ae0:  54 50 00 08 bnel	v0,s0,0x900000001fc15b04
[ 122] 0x900000001fc15ae4:  00 40 38 25 move	a3,v0
[ 120] 0x900000001fc15ae8:  26 10 00 08 addiu	s0,s0,8
[ 120] 0x900000001fc15aec:  02 12 38 2a slt	a3,s0,s2
[ 120] 0x900000001fc15af0:  14 e0 ff f9 bne	a3,zero,0x900000001fc15ad8
[ 120] 0x900000001fc15af4:  02 00 28 25 move	a1,s0
  123:             ccloprintf("*** ERROR in addressing at 0x%x, Wrote %x, Read %x\n",
  124: 						i, i, value);
  125: 	    return EVDIAG_MAPADDR_FAILED;
  126:         }
  127:     }
  128: 
  129:     return 0;
[ 129] 0x900000001fc15af8:  10 00 00 0c b		0x900000001fc15b2c
[ 129] 0x900000001fc15afc:  00 00 88 25 move	s1,zero
[ 123] 0x900000001fc15b00:  00 40 38 25 move	a3,v0
[ 123] 0x900000001fc15b04:  02 00 30 25 move	a2,s0
[ 123] 0x900000001fc15b08:  02 00 28 25 move	a1,s0
[ 123] 0x900000001fc15b0c:  3c 08 90 00 lui	a4,0x9000
[ 123] 0x900000001fc15b10:  3c 09 1f c2 lui	a5,0x1fc2
[ 123] 0x900000001fc15b14:  61 08 00 00 daddi	a4,a4,0
[ 123] 0x900000001fc15b18:  61 29 f1 e0 daddi	a5,a5,-3616
[ 123] 0x900000001fc15b1c:  00 08 40 3c dsll32	a4,a4,0
[ 123] 0x900000001fc15b20:  0f f0 2c fa jal		ccloprintf
[ 123] 0x900000001fc15b24:  01 09 20 2c dadd	a0,a4,a5
[ 125] 0x900000001fc15b28:  24 11 00 5d li	s1,93
[ 125] 0x900000001fc15b2c:  df b2 00 00 ld	s2,0(sp)
[ 125] 0x900000001fc15b30:  df bf 00 18 ld	ra,24(sp)
[ 125] 0x900000001fc15b34:  02 20 10 25 move	v0,s1
[ 125] 0x900000001fc15b38:  df b0 00 10 ld	s0,16(sp)
[ 125] 0x900000001fc15b3c:  df b1 00 08 ld	s1,8(sp)
[ 125] 0x900000001fc15b40:  03 e0 00 08 jr	ra
[ 125] 0x900000001fc15b44:  67 bd 00 20 daddiu	sp,sp,32
  130: }
  131: 
  132: /*
  133:  * Function : iaram_walk1s
  134:  * Description :  Walk 1s in IARAM Memory and check if it's ok
  135:  */
  136: uint iaram_walk1s(uint window)
  137: {
iaram_walk1s:
[ 137] 0x900000001fc15b48:  67 bd ff c0 daddiu	sp,sp,-64
[ 137] 0x900000001fc15b4c:  ff b3 00 18 sd	s3,24(sp)
[ 137] 0x900000001fc15b50:  00 80 98 25 move	s3,a0
  138:     int i, j;
  139:     unsigned mask, value;
  140: 
  141:     for(i = 4; i < IO4_MAPRAM_SIZE; i += 8) {
[ 141] 0x900000001fc15b54:  ff b5 00 08 sd	s5,8(sp)
[ 141] 0x900000001fc15b58:  24 15 00 04 li	s5,4
[ 141] 0x900000001fc15b5c:  ff b6 00 00 sd	s6,0(sp)
[ 141] 0x900000001fc15b60:  3c 16 00 01 lui	s6,0x1
[ 141] 0x900000001fc15b64:  ff b4 00 10 sd	s4,16(sp)
[ 141] 0x900000001fc15b68:  24 14 00 04 li	s4,4
[ 141] 0x900000001fc15b6c:  ff b2 00 20 sd	s2,32(sp)
[ 141] 0x900000001fc15b70:  24 12 00 01 li	s2,1
[ 141] 0x900000001fc15b74:  ff b0 00 30 sd	s0,48(sp)
[ 141] 0x900000001fc15b78:  00 00 80 25 move	s0,zero
[ 141] 0x900000001fc15b7c:  ff b1 00 28 sd	s1,40(sp)
[ 141] 0x900000001fc15b80:  00 12 88 04 sllv	s1,s2,zero
[ 141] 0x900000001fc15b84:  ff bf 00 38 sd	ra,56(sp)
  142: 	for(j = 0; j < sizeof(unsigned); j++) {
  143: 	    mask = (1 << j);
  144: 	    value = store_load_lwin_word(window, i, mask);
[ 144] 0x900000001fc15b88:  02 20 30 25 move	a2,s1
[ 144] 0x900000001fc15b8c:  02 a0 28 25 move	a1,s5
[ 144] 0x900000001fc15b90:  0f f0 0d 7f jal		store_load_lwin_word
[ 144] 0x900000001fc15b94:  02 60 20 25 move	a0,s3
  145: 	    if (value != mask) {
[ 145] 0x900000001fc15b98:  26 10 00 01 addiu	s0,s0,1
[ 145] 0x900000001fc15b9c:  16 22 00 0b bne	s1,v0,0x900000001fc15bcc
[ 145] 0x900000001fc15ba0:  02 14 c8 2b sltu	t9,s0,s4
[ 142] 0x900000001fc15ba4:  17 20 ff f8 bne	t9,zero,0x900000001fc15b88
[ 142] 0x900000001fc15ba8:  02 12 88 04 sllv	s1,s2,s0
[ 141] 0x900000001fc15bac:  26 b5 00 08 addiu	s5,s5,8
[ 141] 0x900000001fc15bb0:  00 00 80 25 move	s0,zero
[ 141] 0x900000001fc15bb4:  00 12 88 04 sllv	s1,s2,zero
[ 141] 0x900000001fc15bb8:  02 b6 38 2a slt	a3,s5,s6
[ 141] 0x900000001fc15bbc:  54 e0 ff f3 bnel	a3,zero,0x900000001fc15b8c
[ 141] 0x900000001fc15bc0:  02 20 30 25 move	a2,s1
  146:                 ccloprintf("*** ERROR in walking 1s at 0x%x, Wrote %x, Read %x\n",
  147: 				i, mask, value);
  148: 		return EVDIAG_MAPWALK_FAILED;
  149: 	    }
  150: 	}
  151:     }
  152: 
  153:     return 0;
[ 153] 0x900000001fc15bc4:  10 00 00 0c b		0x900000001fc15bf8
[ 153] 0x900000001fc15bc8:  00 00 80 25 move	s0,zero
[ 146] 0x900000001fc15bcc:  00 40 38 25 move	a3,v0
[ 146] 0x900000001fc15bd0:  02 20 30 25 move	a2,s1
[ 146] 0x900000001fc15bd4:  02 a0 28 25 move	a1,s5
[ 146] 0x900000001fc15bd8:  3c 08 90 00 lui	a4,0x9000
[ 146] 0x900000001fc15bdc:  3c 09 1f c2 lui	a5,0x1fc2
[ 146] 0x900000001fc15be0:  61 08 00 00 daddi	a4,a4,0
[ 146] 0x900000001fc15be4:  61 29 f2 18 daddi	a5,a5,-3560
[ 146] 0x900000001fc15be8:  00 08 40 3c dsll32	a4,a4,0
[ 146] 0x900000001fc15bec:  0f f0 2c fa jal		ccloprintf
[ 146] 0x900000001fc15bf0:  01 09 20 2c dadd	a0,a4,a5
[ 148] 0x900000001fc15bf4:  24 10 00 5e li	s0,94
[ 148] 0x900000001fc15bf8:  df b1 00 28 ld	s1,40(sp)
[ 148] 0x900000001fc15bfc:  df b3 00 18 ld	s3,24(sp)
[ 148] 0x900000001fc15c00:  df b6 00 00 ld	s6,0(sp)
[ 148] 0x900000001fc15c04:  df bf 00 38 ld	ra,56(sp)
[ 148] 0x900000001fc15c08:  02 00 10 25 move	v0,s0
[ 148] 0x900000001fc15c0c:  df b4 00 10 ld	s4,16(sp)
[ 148] 0x900000001fc15c10:  df b2 00 20 ld	s2,32(sp)
[ 148] 0x900000001fc15c14:  df b0 00 30 ld	s0,48(sp)
[ 148] 0x900000001fc15c18:  df b5 00 08 ld	s5,8(sp)
[ 148] 0x900000001fc15c1c:  03 e0 00 08 jr	ra
[ 148] 0x900000001fc15c20:  67 bd 00 40 daddiu	sp,sp,64
Skipping source listing to line 56 of /cores/banyan/stand/arcs/IP25prom/main.c...
   57: 
   58: static void
   59: promVersionDisplay(evcfginfo_t *e)
   60: /*
   61:  * Function: 	promVersionDisplay
   62:  * Purpose:	print out (in a pretty way), the version of the prom
   63:  * Parameters:	e - pointer to everest config structure.
   64:  * Returns:	Nothing
   65:  */
   66: {
promVersionDisplay:
[  66] 0x900000001fc15c24:  67 bd ff b0 daddiu	sp,sp,-80
   67:     static const char *csd[] = {
   68: 	"rsvd", "1", "1.5", "2",
   69: 	"2.5", "3", "3.5", "4", 
   70: 	"rsvd", "rsvd", "rsvd", "rsvd", 
   71: 	"rsvd", "rsvd", "rsvd", "rsvd"
   72:     };
   73:     static const char *sccd[] = {
   74: 	"rsvd", "1", "1.5", "2", "2.5", "3", "rsvd", "rsvd"
   75:     };
   76:     static const char *scs[] = {
   77: 	"512K", "1MB", "2MB", "4MB", "8MB", "16MB", "*", "*"
   78:     };
   79:     __uint32_t	c, cc, v;
   80:     __uint32_t	prid = (__uint32_t)readCP0(C0_PRID);
[  80] 0x900000001fc15c28:  ff b6 00 10 sd	s6,16(sp)
[  80] 0x900000001fc15c2c:  00 80 b0 25 move	s6,a0
[  80] 0x900000001fc15c30:  ff bf 00 48 sd	ra,72(sp)
[  80] 0x900000001fc15c34:  0f f0 17 53 jal		readCP0
[  80] 0x900000001fc15c38:  24 04 00 0f li	a0,15
   81: 
   82:     c = (__uint32_t)DWORD_UNSWAP(*((__uint64_t *)IP25_CONFIG_ADDR));
[  82] 0x900000001fc15c3c:  ff b0 00 40 sd	s0,64(sp)
[  82] 0x900000001fc15c40:  00 02 80 00 sll	s0,v0,0
[  82] 0x900000001fc15c44:  3c 01 90 00 lui	at,0x9000
[  82] 0x900000001fc15c48:  60 21 00 00 daddi	at,at,0
[  82] 0x900000001fc15c4c:  3c 02 1f c2 lui	v0,0x1fc2
[  82] 0x900000001fc15c50:  60 42 f2 50 daddi	v0,v0,-3504
[  82] 0x900000001fc15c54:  00 01 08 3c dsll32	at,at,0
[  82] 0x900000001fc15c58:  ff b1 00 38 sd	s1,56(sp)
[  82] 0x900000001fc15c5c:  00 22 88 2c dadd	s1,at,v0
[  82] 0x900000001fc15c60:  de 21 01 80 ld	at,384(s1)
   83:     cc = (__uint32_t)GET_CC_REV();
[  83] 0x900000001fc15c64:  de 22 01 88 ld	v0,392(s1)
[  83] 0x900000001fc15c68:  dc 23 00 00 ld	v1,0(at)
   84: 
   85:     loprintf("\n\nIP25 SCC(%c) %s\n", cc + 'A', getversion());
[  85] 0x900000001fc15c6c:  3c 04 90 00 lui	a0,0x9000
[  85] 0x900000001fc15c70:  dc 41 00 00 ld	at,0(v0)
[  85] 0x900000001fc15c74:  60 84 00 00 daddi	a0,a0,0
[  85] 0x900000001fc15c78:  30 21 00 03 andi	at,at,0x3
[  85] 0x900000001fc15c7c:  dc 42 00 00 ld	v0,0(v0)
[  85] 0x900000001fc15c80:  00 01 09 b8 dsll	at,at,6
[  85] 0x900000001fc15c84:  30 42 00 3f andi	v0,v0,0x3f
[  85] 0x900000001fc15c88:  64 21 00 20 daddiu	at,at,32
[  85] 0x900000001fc15c8c:  00 02 10 bb dsra	v0,v0,2
[  85] 0x900000001fc15c90:  3c 05 1f c2 lui	a1,0x1fc2
[  85] 0x900000001fc15c94:  00 01 08 f8 dsll	at,at,3
[  85] 0x900000001fc15c98:  ff b4 00 20 sd	s4,32(sp)
[  85] 0x900000001fc15c9c:  60 b4 f2 d0 daddi	s4,a1,-3376
[  85] 0x900000001fc15ca0:  00 02 12 f8 dsll	v0,v0,11
[  85] 0x900000001fc15ca4:  ff b3 00 28 sd	s3,40(sp)
[  85] 0x900000001fc15ca8:  00 04 98 3c dsll32	s3,a0,0
[  85] 0x900000001fc15cac:  00 22 08 2d daddu	at,at,v0
[  85] 0x900000001fc15cb0:  de 22 01 90 ld	v0,400(s1)
[  85] 0x900000001fc15cb4:  00 03 18 3e dsrl32	v1,v1,0
[  85] 0x900000001fc15cb8:  00 22 08 2d daddu	at,at,v0
[  85] 0x900000001fc15cbc:  ff b2 00 30 sd	s2,48(sp)
[  85] 0x900000001fc15cc0:  00 03 90 00 sll	s2,v1,0
[  85] 0x900000001fc15cc4:  ff b5 00 18 sd	s5,24(sp)
[  85] 0x900000001fc15cc8:  0f f0 5b fc jal		getversion
[  85] 0x900000001fc15ccc:  dc 35 00 00 ld	s5,0(at)
[  85] 0x900000001fc15cd0:  00 15 0f 3b dsra	at,s5,28
[  85] 0x900000001fc15cd4:  02 74 20 2c dadd	a0,s3,s4
[  85] 0x900000001fc15cd8:  00 40 30 25 move	a2,v0
[  85] 0x900000001fc15cdc:  30 21 00 0f andi	at,at,0xf
[  85] 0x900000001fc15ce0:  00 01 08 00 sll	at,at,0
[  85] 0x900000001fc15ce4:  0f f0 2c e3 jal		loprintf
[  85] 0x900000001fc15ce8:  24 25 00 41 addiu	a1,at,65
   86: 
   87:     loprintf("R10000 %d.%d %dMHz %s", 
[  87] 0x900000001fc15cec:  32 01 00 f0 andi	at,s0,0xf0
[  87] 0x900000001fc15cf0:  32 19 00 0f andi	t9,s0,0xf
[  87] 0x900000001fc15cf4:  ff b7 00 08 sd	s7,8(sp)
[  87] 0x900000001fc15cf8:  00 01 b9 02 srl	s7,at,4
[  87] 0x900000001fc15cfc:  3c 01 00 38 lui	at,0x38
[  87] 0x900000001fc15d00:  02 41 08 24 and	at,s2,at
[  87] 0x900000001fc15d04:  3c 02 1e 00 lui	v0,0x1e00
[  87] 0x900000001fc15d08:  02 42 10 24 and	v0,s2,v0
[  87] 0x900000001fc15d0c:  32 43 1e 00 andi	v1,s2,0x1e00
[  87] 0x900000001fc15d10:  00 03 9a 42 srl	s3,v1,9
[  87] 0x900000001fc15d14:  32 43 01 80 andi	v1,s2,0x180
[  87] 0x900000001fc15d18:  00 03 a9 c2 srl	s5,v1,7
[  87] 0x900000001fc15d1c:  03 20 58 25 move	a7,t9
[  87] 0x900000001fc15d20:  00 01 a4 c2 srl	s4,at,19
[  87] 0x900000001fc15d24:  24 01 00 01 li	at,1
[  87] 0x900000001fc15d28:  ff be 00 00 sd	s8,0(sp)
[  87] 0x900000001fc15d2c:  16 e1 00 09 bne	s7,at,0x900000001fc15d54
[  87] 0x900000001fc15d30:  00 02 f6 42 srl	s8,v0,25
[  87] 0x900000001fc15d34:  24 0b 00 04 li	a7,4
[  87] 0x900000001fc15d38:  3b 38 00 01 xori	t8,t9,0x1
[  87] 0x900000001fc15d3c:  03 38 58 0b movn	a7,t9,t8
[  87] 0x900000001fc15d40:  00 00 00 21 nada
[  87] 0x900000001fc15d44:  00 00 00 21 nada
[  87] 0x900000001fc15d48:  00 00 00 21 nada
[  87] 0x900000001fc15d4c:  10 00 00 01 b		0x900000001fc15d54
[  87] 0x900000001fc15d50:  00 00 00 21 nada
[  87] 0x900000001fc15d54:  0f f0 0d d0 jal		getendian
[  87] 0x900000001fc15d58:  01 60 80 25 move	s0,a7
[  87] 0x900000001fc15d5c:  02 00 30 25 move	a2,s0
[  87] 0x900000001fc15d60:  66 28 00 b1 daddiu	a4,s1,177
[  87] 0x900000001fc15d64:  50 40 00 04 beql	v0,zero,0x900000001fc15d78
[  87] 0x900000001fc15d68:  02 e0 28 25 move	a1,s7
[  87] 0x900000001fc15d6c:  10 00 00 01 b		0x900000001fc15d74
[  87] 0x900000001fc15d70:  66 28 00 ae daddiu	a4,s1,174
[  87] 0x900000001fc15d74:  02 e0 28 25 move	a1,s7
[  87] 0x900000001fc15d78:  df b7 00 08 ld	s7,8(sp)
[  87] 0x900000001fc15d7c:  66 24 00 98 daddiu	a0,s1,152
[  87] 0x900000001fc15d80:  8e d9 06 cc lw	t9,1740(s6)
[  87] 0x900000001fc15d84:  0f f0 2c e3 jal		loprintf
[  87] 0x900000001fc15d88:  03 39 38 21 addu	a3,t9,t9
   88: 	     MAJOR(prid), MINOR(prid),
   89: 	     e->ecfg_clkfreq * 2,
   90: 	     (getendian() ? "LE" : "BE") );
   91:     loprintf(" (%d-%d-%d/%d) %s\n\n",
[  91] 0x900000001fc15d8c:  03 c0 40 25 move	a4,s8
[  91] 0x900000001fc15d90:  3c 19 00 07 lui	t9,0x7
[  91] 0x900000001fc15d94:  26 a7 00 01 addiu	a3,s5,1
[  91] 0x900000001fc15d98:  02 59 c8 24 and	t9,s2,t9
[  91] 0x900000001fc15d9c:  02 80 30 25 move	a2,s4
[  91] 0x900000001fc15da0:  de 3f 01 98 ld	ra,408(s1)
[  91] 0x900000001fc15da4:  00 19 cc 02 srl	t9,t9,16
[  91] 0x900000001fc15da8:  67 ff 00 c0 daddiu	ra,ra,192
[  91] 0x900000001fc15dac:  00 19 c8 f8 dsll	t9,t9,3
[  91] 0x900000001fc15db0:  02 60 28 25 move	a1,s3
[  91] 0x900000001fc15db4:  03 3f c8 2d daddu	t9,t9,ra
[  91] 0x900000001fc15db8:  66 24 00 b8 daddiu	a0,s1,184
[  91] 0x900000001fc15dbc:  0f f0 2c e3 jal		loprintf
[  91] 0x900000001fc15dc0:  df 29 00 00 ld	a5,0(t9)
   92: 	     (c & R10000_SCD_MASK) >> R10000_SCD_SHFT, 
   93: 	     (c & R10000_SCCD_MASK) >> R10000_SCCD_SHFT,
   94: 	     ((c & R10000_PRM_MASK) >> R10000_PRM_SHFT) + 1,
   95: 	     (c & R10000_SCCT_MASK) >> R10000_SCCT_SHFT,
   96: 	     scs[(c & R10000_SCS_MASK) >> R10000_SCS_SHFT]);
   97: 
   98:     if (e->ecfg_debugsw & VDS_DEBUG_PROM) {
[  98] 0x900000001fc15dc4:  02 40 28 25 move	a1,s2
[  98] 0x900000001fc15dc8:  8e d9 06 d8 lw	t9,1752(s6)
[  98] 0x900000001fc15dcc:  df b6 00 10 ld	s6,16(sp)
[  98] 0x900000001fc15dd0:  33 39 00 01 andi	t9,t9,0x1
[  98] 0x900000001fc15dd4:  53 20 00 26 beql	t9,zero,0x900000001fc15e70
[  98] 0x900000001fc15dd8:  df b1 00 38 ld	s1,56(sp)
   99: 	loprintf("R10000 Configuration (0x%x): \n", c);
[  99] 0x900000001fc15ddc:  0f f0 2c e3 jal		loprintf
[  99] 0x900000001fc15de0:  66 24 00 d0 daddiu	a0,s1,208
  100: 	v = (c & R10000_PRM_MASK) >> R10000_PRM_SHFT;
  101: 	loprintf("\t%d(%d)\toutstanding reads\n", v+1, v);
[ 101] 0x900000001fc15de4:  02 a0 30 25 move	a2,s5
[ 101] 0x900000001fc15de8:  26 a5 00 01 addiu	a1,s5,1
[ 101] 0x900000001fc15dec:  0f f0 2c e3 jal		loprintf
[ 101] 0x900000001fc15df0:  66 24 00 f0 daddiu	a0,s1,240
  102: 	v = (c & R10000_SCD_MASK) >> R10000_SCD_SHFT;
  103: 	loprintf("\t%s(%d)\tPClk divisor\n", csd[v], v);
[ 103] 0x900000001fc15df4:  00 13 08 3c dsll32	at,s3,0
[ 103] 0x900000001fc15df8:  00 01 0f 7a dsrl	at,at,29
[ 103] 0x900000001fc15dfc:  de 30 01 98 ld	s0,408(s1)
[ 103] 0x900000001fc15e00:  02 60 30 25 move	a2,s3
[ 103] 0x900000001fc15e04:  00 30 08 2d daddu	at,at,s0
[ 103] 0x900000001fc15e08:  66 24 01 10 daddiu	a0,s1,272
[ 103] 0x900000001fc15e0c:  0f f0 2c e3 jal		loprintf
[ 103] 0x900000001fc15e10:  dc 25 00 00 ld	a1,0(at)
  104: 	v = (c & R10000_SCCD_MASK) >> R10000_SCCD_SHFT;
  105: 	loprintf("\t%s(%d)\tSClk divisor\n", sccd[v], v);
[ 105] 0x900000001fc15e14:  00 14 08 3c dsll32	at,s4,0
[ 105] 0x900000001fc15e18:  66 02 00 80 daddiu	v0,s0,128
[ 105] 0x900000001fc15e1c:  00 01 0f 7a dsrl	at,at,29
[ 105] 0x900000001fc15e20:  02 80 30 25 move	a2,s4
[ 105] 0x900000001fc15e24:  00 22 08 2d daddu	at,at,v0
[ 105] 0x900000001fc15e28:  66 24 01 28 daddiu	a0,s1,296
[ 105] 0x900000001fc15e2c:  66 30 01 54 daddiu	s0,s1,340
[ 105] 0x900000001fc15e30:  0f f0 2c e3 jal		loprintf
[ 105] 0x900000001fc15e34:  dc 25 00 00 ld	a1,0(at)
  106: 	loprintf("\t%s\tTandem Mode\n", c&R10000_SCCE_MASK ? "on" : "off");
[ 106] 0x900000001fc15e38:  32 41 40 00 andi	at,s2,0x4000
[ 106] 0x900000001fc15e3c:  50 20 00 04 beql	at,zero,0x900000001fc15e50
[ 106] 0x900000001fc15e40:  02 00 28 25 move	a1,s0
[ 104] 0x900000001fc15e44:  10 00 00 01 b		0x900000001fc15e4c
[ 104] 0x900000001fc15e48:  66 30 01 51 daddiu	s0,s1,337
[ 104] 0x900000001fc15e4c:  02 00 28 25 move	a1,s0
[ 104] 0x900000001fc15e50:  0f f0 2c e3 jal		loprintf
[ 104] 0x900000001fc15e54:  66 24 01 40 daddiu	a0,s1,320
  107: 	loprintf("\t%d\tSecondary Cache clock tap\n", 
[ 107] 0x900000001fc15e58:  03 c0 28 25 move	a1,s8
[ 107] 0x900000001fc15e5c:  0f f0 2c e3 jal		loprintf
[ 107] 0x900000001fc15e60:  66 24 01 58 daddiu	a0,s1,344
  108: 		 (c & R10000_SCCT_MASK) >> R10000_SCCT_SHFT);
  109: 	loprintf("\n");
[ 109] 0x900000001fc15e64:  0f f0 2c e3 jal		loprintf
[ 109] 0x900000001fc15e68:  66 24 01 77 daddiu	a0,s1,375
[ 109] 0x900000001fc15e6c:  df b1 00 38 ld	s1,56(sp)
[ 109] 0x900000001fc15e70:  df b3 00 28 ld	s3,40(sp)
[ 109] 0x900000001fc15e74:  df b5 00 18 ld	s5,24(sp)
[ 109] 0x900000001fc15e78:  df be 00 00 ld	s8,0(sp)
[ 109] 0x900000001fc15e7c:  df bf 00 48 ld	ra,72(sp)
[ 109] 0x900000001fc15e80:  df b4 00 20 ld	s4,32(sp)
[ 109] 0x900000001fc15e84:  df b2 00 30 ld	s2,48(sp)
[ 109] 0x900000001fc15e88:  df b0 00 40 ld	s0,64(sp)
[ 109] 0x900000001fc15e8c:  03 e0 00 08 jr	ra
[ 109] 0x900000001fc15e90:  67 bd 00 50 daddiu	sp,sp,80
  110:     }
  111: }
  112: 
  113: 
  114: /*
  115:  * main()
  116:  * 	The PROM main-line code, called only by the Boot Master
  117:  *	processor once a stack in the primary d cache has been
  118:  *	constructed (see entry.s and master.s for more info).
  119:  *
  120:  */
  121: 
  122: void
  123: main()
  124: {
main:
[ 124] 0x900000001fc15e94:  67 bd f8 80 daddiu	sp,sp,-1920
  125:     evcfginfo_t cfginfo;	/* Master system inventory */ 
  126:     uint io4_err;		/* Flag indicating cw a broken IO4 */
  127:     int	memval;			/* return value from memory configuration */
  128:     int diagval;		/* diagnostic value */
  129:     int slot, slice;		/* Our position on the midplane */
  130: #if DEBUG
  131:     int mslot;
  132:     int type;
  133: #endif
  134: #if IP25MON || SABLE
  135:     promVersionDisplay(1);
  136:     invalidateCCtags();
  137:     invalidateIcache();
  138:     invalidateScache();
  139:     podMode(EVDIAG_DEBUG, "\n\rIP25mon Ready\r\n");
  140: #endif
  141:     
  142:     ccloprintf("\nWelcome to Everest manufacturing mode.\n");
[ 142] 0x900000001fc15e98:  3c 01 90 00 lui	at,0x9000
[ 142] 0x900000001fc15e9c:  60 21 00 00 daddi	at,at,0
[ 142] 0x900000001fc15ea0:  3c 02 1f c2 lui	v0,0x1fc2
[ 142] 0x900000001fc15ea4:  60 42 f3 f0 daddi	v0,v0,-3088
[ 142] 0x900000001fc15ea8:  3c 03 90 00 lui	v1,0x9000
[ 142] 0x900000001fc15eac:  ff b1 00 78 sd	s1,120(sp)
[ 142] 0x900000001fc15eb0:  60 71 00 00 daddi	s1,v1,0
[ 142] 0x900000001fc15eb4:  ff b0 00 80 sd	s0,128(sp)
[ 142] 0x900000001fc15eb8:  3c 10 1f c2 lui	s0,0x1fc2
[ 142] 0x900000001fc15ebc:  00 01 08 3c dsll32	at,at,0
[ 142] 0x900000001fc15ec0:  ff bf 00 60 sd	ra,96(sp)
[ 142] 0x900000001fc15ec4:  0f f0 2c fa jal		ccloprintf
[ 142] 0x900000001fc15ec8:  00 22 20 2c dadd	a0,at,v0
[ 142] 0x900000001fc15ecc:  62 10 f2 50 daddi	s0,s0,-3504
[ 142] 0x900000001fc15ed0:  00 11 08 3c dsll32	at,s1,0
[ 142] 0x900000001fc15ed4:  00 30 80 2c dadd	s0,at,s0
  143: 
  144:     sysctlr_message("Initing Config Info");
[ 144] 0x900000001fc15ed8:  3c 01 90 00 lui	at,0x9000
[ 144] 0x900000001fc15edc:  3c 02 1f c2 lui	v0,0x1fc2
[ 144] 0x900000001fc15ee0:  60 21 00 00 daddi	at,at,0
[ 144] 0x900000001fc15ee4:  60 42 f4 20 daddi	v0,v0,-3040
[ 144] 0x900000001fc15ee8:  00 01 08 3c dsll32	at,at,0
[ 144] 0x900000001fc15eec:  0f f0 11 7c jal		sysctlr_message
[ 144] 0x900000001fc15ef0:  00 22 20 2c dadd	a0,at,v0
  145: 
  146:     init_cfginfo(&cfginfo);
[ 146] 0x900000001fc15ef4:  ff b2 00 70 sd	s2,112(sp)
[ 146] 0x900000001fc15ef8:  67 b2 00 90 daddiu	s2,sp,144
[ 146] 0x900000001fc15efc:  0f f0 50 a6 jal		init_cfginfo
[ 146] 0x900000001fc15f00:  67 a4 00 90 daddiu	a0,sp,144
  147: 
  148:     slot = (int)((LD(EV_SPNUM) & EV_SLOTNUM_MASK) >> EV_SLOTNUM_SHFT);
[ 148] 0x900000001fc15f04:  de 01 01 88 ld	at,392(s0)
  149:     slice = (int)((LD(EV_SPNUM) & EV_PROCNUM_MASK) >> EV_PROCNUM_SHFT);
  150: 
  151:     sysctlr_message("Setting timeouts.."); 
[ 151] 0x900000001fc15f08:  3c 02 90 00 lui	v0,0x9000
[ 151] 0x900000001fc15f0c:  60 43 00 00 daddi	v1,v0,0
[ 151] 0x900000001fc15f10:  dc 22 00 00 ld	v0,0(at)
[ 151] 0x900000001fc15f14:  00 03 18 3c dsll32	v1,v1,0
[ 151] 0x900000001fc15f18:  30 42 00 3c andi	v0,v0,0x3c
[ 151] 0x900000001fc15f1c:  3c 04 1f c2 lui	a0,0x1fc2
[ 151] 0x900000001fc15f20:  00 02 10 bb dsra	v0,v0,2
[ 151] 0x900000001fc15f24:  60 84 f4 38 daddi	a0,a0,-3016
[ 151] 0x900000001fc15f28:  00 02 88 00 sll	s1,v0,0
[ 151] 0x900000001fc15f2c:  00 64 20 2c dadd	a0,v1,a0
[ 151] 0x900000001fc15f30:  ff b3 00 68 sd	s3,104(sp)
[ 151] 0x900000001fc15f34:  ff b1 00 28 sd	s1,40(sp)
[ 149] 0x900000001fc15f38:  0f f0 11 7c jal		sysctlr_message
[ 149] 0x900000001fc15f3c:  dc 33 00 00 ld	s3,0(at)
  152:     set_timeouts(&cfginfo);
[ 152] 0x900000001fc15f40:  0f f0 51 42 jal		set_timeouts
[ 152] 0x900000001fc15f44:  67 a4 00 90 daddiu	a0,sp,144
  153: 
  154: 
  155:     if (get_BSR() & BSR_NODIAG)
[ 155] 0x900000001fc15f48:  0f f0 0d 97 jal		get_BSR
[ 155] 0x900000001fc15f4c:  00 00 00 21 nada
[ 155] 0x900000001fc15f50:  8f b8 07 68 lw	t8,1896(sp)
[ 155] 0x900000001fc15f54:  00 11 20 b8 dsll	a0,s1,2
[ 155] 0x900000001fc15f58:  32 73 00 03 andi	s3,s3,0x3
[ 155] 0x900000001fc15f5c:  37 18 00 10 ori	t8,t8,0x10
[ 155] 0x900000001fc15f60:  00 11 09 38 dsll	at,s1,4
[ 155] 0x900000001fc15f64:  00 13 98 00 sll	s3,s3,0
[ 155] 0x900000001fc15f68:  00 24 20 2d daddu	a0,at,a0
[ 155] 0x900000001fc15f6c:  00 40 08 25 move	at,v0
[ 155] 0x900000001fc15f70:  00 11 11 f8 dsll	v0,s1,7
[ 155] 0x900000001fc15f74:  00 13 19 38 dsll	v1,s3,4
[ 155] 0x900000001fc15f78:  00 44 10 2f dsubu	v0,v0,a0
[ 155] 0x900000001fc15f7c:  30 21 00 80 andi	at,at,0x80
[ 155] 0x900000001fc15f80:  03 a2 10 2d daddu	v0,sp,v0
[ 155] 0x900000001fc15f84:  10 20 00 02 beq	at,zero,0x900000001fc15f90
[ 155] 0x900000001fc15f88:  00 43 88 2d daddu	s1,v0,v1
  156: 	cfginfo.ecfg_debugsw |= VDS_NO_DIAGS;
[ 156] 0x900000001fc15f8c:  af b8 07 68 sw	t8,1896(sp)
  157: 
  158:     /*
  159:      * Initialize the IO subsystems.
  160:      */
  161: 
  162:     if (!any_io_boards()) {
[ 162] 0x900000001fc15f90:  ff b3 00 30 sd	s3,48(sp)
[ 162] 0x900000001fc15f94:  0f f0 50 87 jal		any_io_boards
[ 162] 0x900000001fc15f98:  00 00 00 21 nada
[ 162] 0x900000001fc15f9c:  10 40 00 26 beq	v0,zero,0x900000001fc16038
[ 162] 0x900000001fc15fa0:  00 00 00 21 nada
  163: 	ccloprintf("*** No IO boards found in Ebus information.\n");
  164: 	io4_err = EVDIAG_NOIO4;
  165: 	sc_disp(EVDIAG_NOIO4);
  166: 	set_BSR(get_BSR() & ~BSR_EPCUART);
  167:     } else {
  168: 	sysctlr_message("Initing master IO4..");
[ 168] 0x900000001fc15fa4:  0f f0 11 7c jal		sysctlr_message
[ 168] 0x900000001fc15fa8:  66 04 02 30 daddiu	a0,s0,560
  169: 	io4_err = io4_initmaster(&cfginfo);
[ 169] 0x900000001fc15fac:  0f f0 3b 6f jal		io4_initmaster
[ 169] 0x900000001fc15fb0:  02 40 20 25 move	a0,s2
[ 169] 0x900000001fc15fb4:  00 40 08 25 move	at,v0
  170: 	if (io4_err) {
[ 170] 0x900000001fc15fb8:  10 20 00 0c beq	at,zero,0x900000001fc15fec
[ 170] 0x900000001fc15fbc:  00 20 98 25 move	s3,at
  171: 	    sc_disp(io4_err);
[ 171] 0x900000001fc15fc0:  30 24 00 ff andi	a0,at,0xff
[ 171] 0x900000001fc15fc4:  0f f0 3f 12 jal		sc_disp
[ 171] 0x900000001fc15fc8:  ff a1 00 38 sd	at,56(sp)
  172: 	    ccloprintf("*** IO4 error: %s\n", get_diag_string(io4_err));
[ 172] 0x900000001fc15fcc:  0f f0 3f 6c jal		get_diag_string
[ 172] 0x900000001fc15fd0:  02 60 20 25 move	a0,s3
[ 172] 0x900000001fc15fd4:  00 40 28 25 move	a1,v0
[ 172] 0x900000001fc15fd8:  0f f0 2c fa jal		ccloprintf
[ 172] 0x900000001fc15fdc:  66 04 02 48 daddiu	a0,s0,584
  173: 	}
  174: 
  175: 	/* test EPC */
  176: 	
  177: 	if (!io4_err) {
[ 177] 0x900000001fc15fe0:  df b9 00 38 ld	t9,56(sp)
[ 177] 0x900000001fc15fe4:  17 20 00 1f bne	t9,zero,0x900000001fc16064
[ 177] 0x900000001fc15fe8:  00 00 00 21 nada
  178: 	    sysctlr_message("Initing EPC UART"); 
[ 178] 0x900000001fc15fec:  0f f0 11 7c jal		sysctlr_message
[ 178] 0x900000001fc15ff0:  66 04 02 60 daddiu	a0,s0,608
  179: 	    ccloprintf("Initializing EPC UART...\n");
[ 179] 0x900000001fc15ff4:  0f f0 2c fa jal		ccloprintf
[ 179] 0x900000001fc15ff8:  66 04 02 78 daddiu	a0,s0,632
  180: 	    init_epc_uart();
[ 180] 0x900000001fc15ffc:  0f f0 59 e7 jal		init_epc_uart
[ 180] 0x900000001fc16000:  00 00 00 21 nada
  181: 
  182: 	    /* If we're not in manufacturing mode, switch over to
  183: 	     * the EPC UART.
  184: 	     */
  185: 	    if (! (get_BSR() & BSR_MANUMODE)) {
[ 185] 0x900000001fc16004:  0f f0 0d 97 jal		get_BSR
[ 185] 0x900000001fc16008:  00 00 00 21 nada
[ 185] 0x900000001fc1600c:  30 5f 00 40 andi	ra,v0,0x40
[ 185] 0x900000001fc16010:  17 e0 00 14 bne	ra,zero,0x900000001fc16064
[ 185] 0x900000001fc16014:  00 00 00 21 nada
  186: 		set_BSR(get_BSR() | BSR_EPCUART);
[ 186] 0x900000001fc16018:  0f f0 0d 97 jal		get_BSR
[ 186] 0x900000001fc1601c:  00 00 00 21 nada
[ 186] 0x900000001fc16020:  0f f0 0d 94 jal		set_BSR
[ 186] 0x900000001fc16024:  34 44 01 00 ori	a0,v0,0x100
  187: 		sysctlr_message("Output to EPC UART");
[ 187] 0x900000001fc16028:  0f f0 11 7c jal		sysctlr_message
[ 187] 0x900000001fc1602c:  66 04 02 98 daddiu	a0,s0,664
[ 187] 0x900000001fc16030:  10 00 00 0c b		0x900000001fc16064
[ 187] 0x900000001fc16034:  00 00 00 21 nada
[ 163] 0x900000001fc16038:  0f f0 2c fa jal		ccloprintf
[ 163] 0x900000001fc1603c:  66 04 02 00 daddiu	a0,s0,512
[ 164] 0x900000001fc16040:  24 13 00 46 li	s3,70
[ 164] 0x900000001fc16044:  0f f0 3f 12 jal		sc_disp
[ 164] 0x900000001fc16048:  24 04 00 46 li	a0,70
[ 166] 0x900000001fc1604c:  0f f0 0d 97 jal		get_BSR
[ 166] 0x900000001fc16050:  00 00 00 21 nada
[ 166] 0x900000001fc16054:  24 05 fe ff li	a1,-257
[ 166] 0x900000001fc16058:  00 45 20 24 and	a0,v0,a1
[ 166] 0x900000001fc1605c:  0f f0 0d 94 jal		set_BSR
[ 166] 0x900000001fc16060:  00 00 00 21 nada
  188: 	    }
  189: 	}
  190:     } /* no IO4 boards. */
  191: 
  192:     if (get_BSR() & BSR_POD)
[ 192] 0x900000001fc16064:  0f f0 0d 97 jal		get_BSR
[ 192] 0x900000001fc16068:  00 00 00 21 nada
[ 192] 0x900000001fc1606c:  30 46 00 04 andi	a2,v0,0x4
[ 192] 0x900000001fc16070:  10 c0 00 03 beq	a2,zero,0x900000001fc16080
[ 192] 0x900000001fc16074:  66 05 02 b0 daddiu	a1,s0,688
  193: 	podMode(EVDIAG_DEBUG, "Jumping to POD mode\r\n");
[ 193] 0x900000001fc16078:  0f f0 15 fd jal		podMode
[ 193] 0x900000001fc1607c:  24 04 00 fd li	a0,253
  194: 
  195:     /* Print header string */
  196: 
  197:     promVersionDisplay(&cfginfo);
[ 197] 0x900000001fc16080:  0f f0 57 09 jal		promVersionDisplay
[ 197] 0x900000001fc16084:  02 40 20 25 move	a0,s2
  198:     if (cfginfo.ecfg_debugsw & VDS_MANUMODE)
[ 198] 0x900000001fc16088:  8f a7 07 68 lw	a3,1896(sp)
[ 198] 0x900000001fc1608c:  30 e7 00 80 andi	a3,a3,0x80
[ 198] 0x900000001fc16090:  50 e0 00 04 beql	a3,zero,0x900000001fc160a4
[ 198] 0x900000001fc16094:  8f a8 07 68 lw	a4,1896(sp)
  199: 	loprintf(" -- USING SYS. CTLR. UART -- \n");
[ 199] 0x900000001fc16098:  0f f0 2c e3 jal		loprintf
[ 199] 0x900000001fc1609c:  66 04 02 c8 daddiu	a0,s0,712
[ 199] 0x900000001fc160a0:  8f a8 07 68 lw	a4,1896(sp)
  200: 
  201:     if (cfginfo.ecfg_debugsw & VDS_NO_DIAGS)
[ 201] 0x900000001fc160a4:  31 08 00 10 andi	a4,a4,0x10
[ 201] 0x900000001fc160a8:  51 00 00 04 beql	a4,zero,0x900000001fc160bc
[ 201] 0x900000001fc160ac:  8f a9 07 68 lw	a5,1896(sp)
  202: 	loprintf(" -- DIAGNOSTICS DISABLED  -- \n");
[ 202] 0x900000001fc160b0:  0f f0 2c e3 jal		loprintf
[ 202] 0x900000001fc160b4:  66 04 02 e8 daddiu	a0,s0,744
[ 202] 0x900000001fc160b8:  8f a9 07 68 lw	a5,1896(sp)
  203: 
  204:     if (cfginfo.ecfg_debugsw & VDS_PODMODE)
[ 204] 0x900000001fc160bc:  31 29 00 20 andi	a5,a5,0x20
[ 204] 0x900000001fc160c0:  51 20 00 04 beql	a5,zero,0x900000001fc160d4
[ 204] 0x900000001fc160c4:  8f aa 07 68 lw	a6,1896(sp)
  205: 	loprintf(" --   POD MODE ENABLED    -- \n");
[ 205] 0x900000001fc160c8:  0f f0 2c e3 jal		loprintf
[ 205] 0x900000001fc160cc:  66 04 03 08 daddiu	a0,s0,776
[ 205] 0x900000001fc160d0:  8f aa 07 68 lw	a6,1896(sp)
  206: 
  207:     if (cfginfo.ecfg_debugsw & VDS_DEFAULTS)
[ 207] 0x900000001fc160d4:  31 4a 00 08 andi	a6,a6,0x8
[ 207] 0x900000001fc160d8:  51 40 00 04 beql	a6,zero,0x900000001fc160ec
[ 207] 0x900000001fc160dc:  8f ab 07 68 lw	a7,1896(sp)
  208: 	loprintf(" -- DEFAULTS MODE ENABLED -- \n");
[ 208] 0x900000001fc160e0:  0f f0 2c e3 jal		loprintf
[ 208] 0x900000001fc160e4:  66 04 03 28 daddiu	a0,s0,808
[ 208] 0x900000001fc160e8:  8f ab 07 68 lw	a7,1896(sp)
  209: 
  210:     if (cfginfo.ecfg_debugsw & VDS_NOMEMCLEAR)
[ 210] 0x900000001fc160ec:  31 6b 00 04 andi	a7,a7,0x4
[ 210] 0x900000001fc160f0:  51 60 00 04 beql	a7,zero,0x900000001fc16104
[ 210] 0x900000001fc160f4:  8f ac 07 68 lw	t0,1896(sp)
  211: 	loprintf(" -- LEAVING MEMORY INTACT -- \n");
[ 211] 0x900000001fc160f8:  0f f0 2c e3 jal		loprintf
[ 211] 0x900000001fc160fc:  66 04 03 48 daddiu	a0,s0,840
[ 211] 0x900000001fc16100:  8f ac 07 68 lw	t0,1896(sp)
  212: 
  213:     if (cfginfo.ecfg_debugsw & VDS_2ND_IO4)
[ 213] 0x900000001fc16104:  31 8c 00 02 andi	t0,t0,0x2
[ 213] 0x900000001fc16108:  51 80 00 04 beql	t0,zero,0x900000001fc1611c
[ 213] 0x900000001fc1610c:  8f ad 07 68 lw	t1,1896(sp)
  214: 	loprintf(" -- BOOTING FROM 2ND IO4  -- \n");
[ 214] 0x900000001fc16110:  0f f0 2c e3 jal		loprintf
[ 214] 0x900000001fc16114:  66 04 03 68 daddiu	a0,s0,872
[ 214] 0x900000001fc16118:  8f ad 07 68 lw	t1,1896(sp)
  215: 
  216:     if (cfginfo.ecfg_debugsw & VDS_DEBUG_PROM)
[ 216] 0x900000001fc1611c:  31 ad 00 01 andi	t1,t1,0x1
[ 216] 0x900000001fc16120:  11 a0 00 03 beq	t1,zero,0x900000001fc16130
[ 216] 0x900000001fc16124:  00 00 00 21 nada
  217: 	loprintf(" --    DEBUG SWITCH ON    -- \n");
[ 217] 0x900000001fc16128:  0f f0 2c e3 jal		loprintf
[ 217] 0x900000001fc1612c:  66 04 03 88 daddiu	a0,s0,904
  218: 
  219:     loprintf("Initializing hardware inventory...              ");
[ 219] 0x900000001fc16130:  0f f0 2c e3 jal		loprintf
[ 219] 0x900000001fc16134:  66 04 03 a8 daddiu	a0,s0,936
  220:     sysctlr_message("Reading inventory..");
[ 220] 0x900000001fc16138:  0f f0 11 7c jal		sysctlr_message
[ 220] 0x900000001fc1613c:  66 04 03 e0 daddiu	a0,s0,992
  221:     init_inventory(&cfginfo, (!io4_err && nvram_okay()));
[ 221] 0x900000001fc16140:  00 00 28 25 move	a1,zero
[ 221] 0x900000001fc16144:  16 60 00 07 bne	s3,zero,0x900000001fc16164
[ 221] 0x900000001fc16148:  00 00 00 21 nada
[ 221] 0x900000001fc1614c:  0f f0 30 ed jal		nvram_okay
[ 221] 0x900000001fc16150:  ff a5 00 40 sd	a1,64(sp)
[ 221] 0x900000001fc16154:  df a5 00 40 ld	a1,64(sp)
[ 221] 0x900000001fc16158:  10 40 00 02 beq	v0,zero,0x900000001fc16164
[ 221] 0x900000001fc1615c:  00 00 00 21 nada
[ 221] 0x900000001fc16160:  24 05 00 01 li	a1,1
[ 221] 0x900000001fc16164:  0f f0 51 90 jal		init_inventory
[ 221] 0x900000001fc16168:  02 40 20 25 move	a0,s2
  222:     loprintf("...done.\n");
[ 222] 0x900000001fc1616c:  0f f0 2c e3 jal		loprintf
[ 222] 0x900000001fc16170:  66 04 03 f8 daddiu	a0,s0,1016
  223: 
  224:     MYDIAGVAL = EVDIAG_PASSED;
  225:     (cfginfo.ecfg_board[slot].eb_cpuarr[slice].cpu_promrev ) =
[ 225] 0x900000001fc16174:  de 04 08 a0 ld	a0,2208(s0)
[ 224] 0x900000001fc16178:  0f f0 0d 88 jal		get_char
[ 224] 0x900000001fc1617c:  a2 20 00 9b sb	zero,155(s1)
  226: 			get_char(&(prom_versnum));
  227: 
  228:     configure_cpus(&cfginfo);
[ 228] 0x900000001fc16180:  a2 22 00 9f sb	v0,159(s1)
[ 228] 0x900000001fc16184:  0f f0 52 9c jal		configure_cpus
[ 228] 0x900000001fc16188:  02 40 20 25 move	a0,s2
  229: 
  230:     /*
  231:      * Test and initialize bus tags
  232:      */
  233: 
  234:     if (!(cfginfo.ecfg_debugsw & VDS_NO_DIAGS)) {
[ 234] 0x900000001fc1618c:  8f ae 07 68 lw	t2,1896(sp)
[ 234] 0x900000001fc16190:  31 ce 00 10 andi	t2,t2,0x10
[ 234] 0x900000001fc16194:  15 c0 00 58 bne	t2,zero,0x900000001fc162f8
[ 234] 0x900000001fc16198:  00 00 00 21 nada
  235: 	int (*f)(void);
  236: 
  237: 	sysctlr_message("Testing Scache..");
[ 237] 0x900000001fc1619c:  0f f0 11 7c jal		sysctlr_message
[ 237] 0x900000001fc161a0:  66 04 04 08 daddiu	a0,s0,1032
  238: 	loprintf("Testing Secondary Cache...\t\t\t");
[ 238] 0x900000001fc161a4:  0f f0 2c e3 jal		loprintf
[ 238] 0x900000001fc161a8:  66 04 04 20 daddiu	a0,s0,1056
  239: 	if (diagval = testScache()) {
[ 239] 0x900000001fc161ac:  0f f0 08 ed jal		testScache
[ 239] 0x900000001fc161b0:  00 00 00 21 nada
[ 239] 0x900000001fc161b4:  00 40 08 25 move	at,v0
[ 239] 0x900000001fc161b8:  14 20 00 05 bne	at,zero,0x900000001fc161d0
[ 239] 0x900000001fc161bc:  00 20 58 25 move	a7,at
  240: 	    sc_disp(diagval);
  241: 	    loprintf("*FAILED*\n");
  242: 	    MYDIAGVAL = diagval;
  243: 	    prom_abdicate(diagval);
  244: 	} else {
  245: 	    loprintf("...passed.\n");
[ 245] 0x900000001fc161c0:  0f f0 2c e3 jal		loprintf
[ 245] 0x900000001fc161c4:  66 04 04 50 daddiu	a0,s0,1104
[ 245] 0x900000001fc161c8:  10 00 00 09 b		0x900000001fc161f0
[ 245] 0x900000001fc161cc:  00 00 00 21 nada
[ 240] 0x900000001fc161d0:  30 24 00 ff andi	a0,at,0xff
[ 240] 0x900000001fc161d4:  0f f0 3f 12 jal		sc_disp
[ 240] 0x900000001fc161d8:  ff ab 00 48 sd	a7,72(sp)
[ 241] 0x900000001fc161dc:  0f f0 2c e3 jal		loprintf
[ 241] 0x900000001fc161e0:  66 04 04 40 daddiu	a0,s0,1088
[ 242] 0x900000001fc161e4:  df a4 00 48 ld	a0,72(sp)
[ 243] 0x900000001fc161e8:  0f f0 12 88 jal		prom_abdicate
[ 243] 0x900000001fc161ec:  a2 24 00 9b sb	a0,155(s1)
  246: 	}
  247: 
  248: 	sysctlr_message("Testing Bus Tags..");
[ 248] 0x900000001fc161f0:  0f f0 11 7c jal		sysctlr_message
[ 248] 0x900000001fc161f4:  66 04 04 60 daddiu	a0,s0,1120
  249: 	loprintf("Testing and clearing bus tags...\t\t");
[ 249] 0x900000001fc161f8:  0f f0 2c e3 jal		loprintf
[ 249] 0x900000001fc161fc:  66 04 04 78 daddiu	a0,s0,1144
  250: 
  251: 	if (GET_CC_REV() == 0) {
[ 251] 0x900000001fc16200:  de 01 08 a8 ld	at,2216(s0)
[ 251] 0x900000001fc16204:  de 19 01 88 ld	t9,392(s0)
[ 251] 0x900000001fc16208:  de 04 08 a8 ld	a0,2216(s0)
[ 251] 0x900000001fc1620c:  df 2f 00 00 ld	t3,0(t9)
[ 251] 0x900000001fc16210:  31 ef 00 03 andi	t3,t3,0x3
[ 251] 0x900000001fc16214:  df 39 00 00 ld	t9,0(t9)
[ 251] 0x900000001fc16218:  00 0f 79 b8 dsll	t3,t3,6
[ 251] 0x900000001fc1621c:  33 39 00 3f andi	t9,t9,0x3f
[ 251] 0x900000001fc16220:  65 ef 00 20 daddiu	t3,t3,32
[ 251] 0x900000001fc16224:  00 19 c8 bb dsra	t9,t9,2
[ 251] 0x900000001fc16228:  00 0f 78 f8 dsll	t3,t3,3
[ 251] 0x900000001fc1622c:  00 19 ca f8 dsll	t9,t9,11
[ 251] 0x900000001fc16230:  01 f9 78 2d daddu	t3,t3,t9
[ 251] 0x900000001fc16234:  de 19 01 90 ld	t9,400(s0)
[ 251] 0x900000001fc16238:  01 f9 78 2d daddu	t3,t3,t9
[ 251] 0x900000001fc1623c:  34 18 f0 00 ori	t8,zero,0xf000
[ 251] 0x900000001fc16240:  00 18 c4 38 dsll	t8,t8,16
[ 251] 0x900000001fc16244:  dd ef 00 00 ld	t3,0(t3)
[ 251] 0x900000001fc16248:  01 f8 78 24 and	t3,t3,t8
[ 251] 0x900000001fc1624c:  ff b4 00 58 sd	s4,88(sp)
[ 251] 0x900000001fc16250:  51 e0 00 04 beql	t3,zero,0x900000001fc16264
[ 251] 0x900000001fc16254:  de 01 08 b0 ld	at,2224(s0)
  252: 	    f = (int (*)(void))copyToICache((void *)testCCtags, 
  253: 			(__uint64_t)testCCtags_END - (__uint64_t)testCCtags);
  254: 	} else {
  255: 	    f = testCCtags;
[ 255] 0x900000001fc16258:  10 00 00 05 b		0x900000001fc16270
[ 255] 0x900000001fc1625c:  00 00 00 21 nada
[ 252] 0x900000001fc16260:  de 01 08 b0 ld	at,2224(s0)
[ 252] 0x900000001fc16264:  0f f0 0b 99 jal		copyToICache
[ 252] 0x900000001fc16268:  00 24 28 2f dsubu	a1,at,a0
[ 252] 0x900000001fc1626c:  00 40 08 25 move	at,v0
  256: 	}
  257: 
  258: 	diagval = f();
[ 258] 0x900000001fc16270:  00 20 f8 09 jalr	ra,at
[ 258] 0x900000001fc16274:  00 00 00 21 nada
[ 258] 0x900000001fc16278:  ff a2 00 50 sd	v0,80(sp)
[ 258] 0x900000001fc1627c:  00 40 a0 25 move	s4,v0
  259: 	invalidateCCtags();
[ 259] 0x900000001fc16280:  0f f0 07 ff jal		invalidateCCtags
[ 259] 0x900000001fc16284:  ff a2 00 48 sd	v0,72(sp)
  260: 	if (diagval) {
[ 260] 0x900000001fc16288:  df a1 00 50 ld	at,80(sp)
[ 260] 0x900000001fc1628c:  16 80 00 05 bne	s4,zero,0x900000001fc162a4
[ 260] 0x900000001fc16290:  00 00 00 21 nada
  261: 	    sc_disp(diagval);
  262: 	    loprintf("*FAILED*\n");
  263: 	    MYDIAGVAL = diagval;
  264: 	    /* Give up the job of bootmaster */
  265: 	    loprintf("*** Current bootmaster (%a/%a) failed diagnostics",
  266: 								slot, slice);
  267: 	    loprintf("  Rearbitrating...\n");
  268: 	    prom_abdicate(diagval);
  269: 	} else {
  270: 	    loprintf("...passed.\n");
[ 270] 0x900000001fc16294:  0f f0 2c e3 jal		loprintf
[ 270] 0x900000001fc16298:  66 04 05 00 daddiu	a0,s0,1280
[ 270] 0x900000001fc1629c:  10 00 00 10 b		0x900000001fc162e0
[ 270] 0x900000001fc162a0:  df b4 00 58 ld	s4,88(sp)
[ 261] 0x900000001fc162a4:  0f f0 3f 12 jal		sc_disp
[ 261] 0x900000001fc162a8:  30 24 00 ff andi	a0,at,0xff
[ 262] 0x900000001fc162ac:  0f f0 2c e3 jal		loprintf
[ 262] 0x900000001fc162b0:  66 04 04 a0 daddiu	a0,s0,1184
[ 265] 0x900000001fc162b4:  df a6 00 30 ld	a2,48(sp)
[ 263] 0x900000001fc162b8:  df a5 00 28 ld	a1,40(sp)
[ 263] 0x900000001fc162bc:  66 04 04 b0 daddiu	a0,s0,1200
[ 263] 0x900000001fc162c0:  df b4 00 48 ld	s4,72(sp)
[ 263] 0x900000001fc162c4:  0f f0 2c e3 jal		loprintf
[ 263] 0x900000001fc162c8:  a2 34 00 9b sb	s4,155(s1)
[ 267] 0x900000001fc162cc:  0f f0 2c e3 jal		loprintf
[ 267] 0x900000001fc162d0:  66 04 04 e8 daddiu	a0,s0,1256
[ 268] 0x900000001fc162d4:  0f f0 12 88 jal		prom_abdicate
[ 268] 0x900000001fc162d8:  02 80 20 25 move	a0,s4
[ 268] 0x900000001fc162dc:  df b4 00 58 ld	s4,88(sp)
  271: 	}
  272: 	invalidateCCtags();		/* avoid snooping */
[ 272] 0x900000001fc162e0:  0f f0 07 ff jal		invalidateCCtags
[ 272] 0x900000001fc162e4:  00 00 00 21 nada
  273: 	invalidateIcache();		/* since we just used it */
[ 273] 0x900000001fc162e8:  0f f0 07 a9 jal		invalidateIcache
[ 273] 0x900000001fc162ec:  00 00 00 21 nada
  274: 	invalidateScache();		/* and we used this too */
[ 274] 0x900000001fc162f0:  0f f0 08 c3 jal		invalidateScache
[ 274] 0x900000001fc162f4:  00 00 00 21 nada
  275:     }
  276: 
  277:     if (!any_mc_boards())
[ 277] 0x900000001fc162f8:  0f f0 50 74 jal		any_mc_boards
[ 277] 0x900000001fc162fc:  00 00 00 21 nada
[ 277] 0x900000001fc16300:  66 05 05 10 daddiu	a1,s0,1296
[ 277] 0x900000001fc16304:  14 40 00 03 bne	v0,zero,0x900000001fc16314
[ 277] 0x900000001fc16308:  00 00 00 21 nada
  278: 	podMode(EVDIAG_NOMC3, "\r\n*** No memory configured\r\n");
[ 278] 0x900000001fc1630c:  0f f0 15 fd jal		podMode
[ 278] 0x900000001fc16310:  24 04 00 33 li	a0,51
  279: 
  280:     /* 
  281:      * Test and configure memory.
  282:      */
  283:     loprintf("Configuring memory...");
[ 283] 0x900000001fc16314:  0f f0 2c e3 jal		loprintf
[ 283] 0x900000001fc16318:  66 04 05 30 daddiu	a0,s0,1328
  284: 
  285:     memval = mc3_config(&cfginfo);
[ 285] 0x900000001fc1631c:  0f f0 4e 2e jal		mc3_config
[ 285] 0x900000001fc16320:  02 40 20 25 move	a0,s2
[ 285] 0x900000001fc16324:  00 40 88 25 move	s1,v0
  286: 
  287:     if (memval != EVDIAG_PASSED)
[ 287] 0x900000001fc16328:  12 20 00 03 beq	s1,zero,0x900000001fc16338
[ 287] 0x900000001fc1632c:  00 00 00 21 nada
  288: 	sc_disp(memval);
[ 288] 0x900000001fc16330:  0f f0 3f 12 jal		sc_disp
[ 288] 0x900000001fc16334:  32 24 00 ff andi	a0,s1,0xff
  289: 
  290:     switch (memval) {
[ 290] 0x900000001fc16338:  06 20 00 24 bltz	s1,0x900000001fc163cc
[ 290] 0x900000001fc1633c:  2a 21 00 32 slti	at,s1,50
[ 290] 0x900000001fc16340:  50 20 00 23 beql	at,zero,0x900000001fc163d0
[ 290] 0x900000001fc16344:  8f a5 07 68 lw	a1,1896(sp)
[ 290] 0x900000001fc16348:  00 11 f8 00 sll	ra,s1,0
[ 290] 0x900000001fc1634c:  00 1f f8 f8 dsll	ra,ra,3
[ 290] 0x900000001fc16350:  66 01 05 48 daddiu	at,s0,1352
[ 290] 0x900000001fc16354:  03 e1 f8 2d daddu	ra,ra,at
[ 290] 0x900000001fc16358:  df ff 00 00 ld	ra,0(ra)
[ 290] 0x900000001fc1635c:  03 e0 00 08 jr	ra
[ 290] 0x900000001fc16360:  00 00 00 21 nada
  291: 	case EVDIAG_BIST_FAILED:
  292: 	    loprintf("*** Built-in memory self-test FAILED.\r\n");
  293: 	    break;
  294: 	case EVDIAG_BAD_ADDRLINE:
  295: 	    loprintf("*** Address line test FAILED.\r\n");
  296: 	    break;
  297: 	case EVDIAG_BAD_DATALINE:
  298: 	    loprintf("*** Data line test FAILED.\r\n");
  299: 	    break;
  300: 	case EVDIAG_BANK_FAILED:
  301: 	    loprintf("*** Bank that passed self-test FAILED software test.\r\n");
  302: 	    break;
  303: 	case EVDIAG_MC3DOUBLEDIS:
  304: 	    loprintf("\r\n*** Unrecoverable config failure.\r\n");
  305: 	    break;
  306: 	case EVDIAG_NO_MEM:
  307: 	    loprintf("\r\n*** No memory configured\r\n");
  308: 	    break;
  309: 	case EVDIAG_PASSED:
  310: 	    loprintf("\n                                                ...passed.\n");	
[ 310] 0x900000001fc16364:  0f f0 2c e3 jal		loprintf
[ 310] 0x900000001fc16368:  66 04 07 c8 daddiu	a0,s0,1992
  311: 	    break;
[ 311] 0x900000001fc1636c:  10 00 00 18 b		0x900000001fc163d0
[ 311] 0x900000001fc16370:  8f a5 07 68 lw	a1,1896(sp)
[ 292] 0x900000001fc16374:  0f f0 2c e3 jal		loprintf
[ 292] 0x900000001fc16378:  66 04 06 e0 daddiu	a0,s0,1760
[ 293] 0x900000001fc1637c:  10 00 00 14 b		0x900000001fc163d0
[ 293] 0x900000001fc16380:  8f a5 07 68 lw	a1,1896(sp)
[ 307] 0x900000001fc16384:  0f f0 2c e3 jal		loprintf
[ 307] 0x900000001fc16388:  66 04 07 a8 daddiu	a0,s0,1960
[ 308] 0x900000001fc1638c:  10 00 00 10 b		0x900000001fc163d0
[ 308] 0x900000001fc16390:  8f a5 07 68 lw	a1,1896(sp)
[ 295] 0x900000001fc16394:  0f f0 2c e3 jal		loprintf
[ 295] 0x900000001fc16398:  66 04 07 08 daddiu	a0,s0,1800
[ 296] 0x900000001fc1639c:  10 00 00 0c b		0x900000001fc163d0
[ 296] 0x900000001fc163a0:  8f a5 07 68 lw	a1,1896(sp)
[ 298] 0x900000001fc163a4:  0f f0 2c e3 jal		loprintf
[ 298] 0x900000001fc163a8:  66 04 07 28 daddiu	a0,s0,1832
[ 299] 0x900000001fc163ac:  10 00 00 08 b		0x900000001fc163d0
[ 299] 0x900000001fc163b0:  8f a5 07 68 lw	a1,1896(sp)
[ 301] 0x900000001fc163b4:  0f f0 2c e3 jal		loprintf
[ 301] 0x900000001fc163b8:  66 04 07 48 daddiu	a0,s0,1864
[ 302] 0x900000001fc163bc:  10 00 00 04 b		0x900000001fc163d0
[ 302] 0x900000001fc163c0:  8f a5 07 68 lw	a1,1896(sp)
[ 304] 0x900000001fc163c4:  0f f0 2c e3 jal		loprintf
[ 304] 0x900000001fc163c8:  66 04 07 80 daddiu	a0,s0,1920
  312:     }
  313: 
  314:     /*
  315:      * Transfer the evcfginfo data structure into memory. Initialize
  316:      * the Everest MPCONF blocks. 
  317:      */
  318: #if DEBUG
  319:     for (slot = 0; slot < EV_MAX_SLOTS; slot++) {
  320:         if (cfginfo.ecfg_board[slot].eb_type == EVTYPE_MC3) {
  321:             /* Make sure this really is a memory board */
  322:             type = EV_GET_CONFIG(slot, MC3_TYPE);
  323:             if (type != MC3_TYPE_VALUE)
  324:                 continue;
  325: 	    mslot = slot;
  326:         }
  327:     }
  328: 
  329:     dump_evconfig_entry(mslot); 
  330: #endif
  331: 
  332:     if (!(cfginfo.ecfg_debugsw & VDS_NOMEMCLEAR)) {
[ 332] 0x900000001fc163cc:  8f a5 07 68 lw	a1,1896(sp)
[ 332] 0x900000001fc163d0:  30 a5 00 04 andi	a1,a1,0x4
[ 332] 0x900000001fc163d4:  54 a0 00 58 bnel	a1,zero,0x900000001fc16538
[ 332] 0x900000001fc163d8:  df b2 00 70 ld	s2,112(sp)
  333: 	sysctlr_message("Writing CFGINFO..");
[ 333] 0x900000001fc163dc:  0f f0 11 7c jal		sysctlr_message
[ 333] 0x900000001fc163e0:  66 04 08 08 daddiu	a0,s0,2056
  334: 	loprintf("Writing cfginfo to memory\n");
[ 334] 0x900000001fc163e4:  0f f0 2c e3 jal		loprintf
[ 334] 0x900000001fc163e8:  66 04 08 20 daddiu	a0,s0,2080
  335: 	*EVCFGINFO = cfginfo;
[ 335] 0x900000001fc163ec:  24 0d ff fc li	t1,-4
[ 335] 0x900000001fc163f0:  3c 06 90 00 lui	a2,0x9000
[ 335] 0x900000001fc163f4:  60 c7 00 00 daddi	a3,a2,0
[ 335] 0x900000001fc163f8:  3c 09 1f c2 lui	a5,0x1fc2
[ 335] 0x900000001fc163fc:  24 0b 01 b8 li	a7,440
[ 335] 0x900000001fc16400:  24 06 ff fc li	a2,-4
[ 335] 0x900000001fc16404:  de 08 08 b8 ld	a4,2232(s0)
[ 335] 0x900000001fc16408:  61 29 f2 50 daddi	a5,a5,-3504
[ 335] 0x900000001fc1640c:  01 66 30 2d daddu	a2,a7,a2
[ 335] 0x900000001fc16410:  8f ac 00 90 lw	t0,144(sp)
[ 335] 0x900000001fc16414:  00 07 38 3c dsll32	a3,a3,0
[ 335] 0x900000001fc16418:  ad 0c 00 00 sw	t0,0(a4)
[ 335] 0x900000001fc1641c:  24 01 00 03 li	at,3
[ 335] 0x900000001fc16420:  00 26 30 2a slt	a2,at,a2
[ 335] 0x900000001fc16424:  00 e9 80 2c dadd	s0,a3,a5
[ 335] 0x900000001fc16428:  8f a7 00 94 lw	a3,148(sp)
[ 335] 0x900000001fc1642c:  01 6d 68 2d daddu	t1,a7,t1
[ 335] 0x900000001fc16430:  67 aa 00 08 daddiu	a6,sp,8
[ 335] 0x900000001fc16434:  de 09 09 18 ld	a5,2328(s0)
[ 335] 0x900000001fc16438:  10 c0 00 30 beq	a2,zero,0x900000001fc164fc
[ 335] 0x900000001fc1643c:  ad 07 00 04 sw	a3,4(a4)
[ 335] 0x900000001fc16440:  01 40 20 25 move	a0,a6
[ 335] 0x900000001fc16444:  8d 42 00 90 lw	v0,144(a6)
[ 335] 0x900000001fc16448:  01 20 30 25 move	a2,a5
[ 335] 0x900000001fc1644c:  25 a7 ff fc addiu	a3,t1,-4
[ 335] 0x900000001fc16450:  ac c2 00 00 sw	v0,0(a2)
[ 335] 0x900000001fc16454:  8c 83 00 94 lw	v1,148(a0)
[ 335] 0x900000001fc16458:  ac c3 00 04 sw	v1,4(a2)
[ 335] 0x900000001fc1645c:  8c 83 00 98 lw	v1,152(a0)
[ 335] 0x900000001fc16460:  ac c3 00 08 sw	v1,8(a2)
[ 335] 0x900000001fc16464:  64 85 00 10 daddiu	a1,a0,16
[ 335] 0x900000001fc16468:  8c 83 00 9c lw	v1,156(a0)
[ 335] 0x900000001fc1646c:  ac c3 00 0c sw	v1,12(a2)
[ 335] 0x900000001fc16470:  64 c6 00 10 daddiu	a2,a2,16
[ 335] 0x900000001fc16474:  00 27 18 2a slt	v1,at,a3
[ 335] 0x900000001fc16478:  24 e7 ff fc addiu	a3,a3,-4
[ 335] 0x900000001fc1647c:  10 60 00 17 beq	v1,zero,0x900000001fc164dc
[ 335] 0x900000001fc16480:  8c a2 00 90 lw	v0,144(a1)
[ 335] 0x900000001fc16484:  ac c2 00 00 sw	v0,0(a2)
[ 335] 0x900000001fc16488:  8c a3 00 94 lw	v1,148(a1)
[ 335] 0x900000001fc1648c:  ac c3 00 04 sw	v1,4(a2)
[ 335] 0x900000001fc16490:  8c a3 00 98 lw	v1,152(a1)
[ 335] 0x900000001fc16494:  ac c3 00 08 sw	v1,8(a2)
[ 335] 0x900000001fc16498:  64 a4 00 10 daddiu	a0,a1,16
[ 335] 0x900000001fc1649c:  8c a3 00 9c lw	v1,156(a1)
[ 335] 0x900000001fc164a0:  ac c3 00 0c sw	v1,12(a2)
[ 335] 0x900000001fc164a4:  64 c6 00 10 daddiu	a2,a2,16
[ 335] 0x900000001fc164a8:  00 27 18 2a slt	v1,at,a3
[ 335] 0x900000001fc164ac:  24 e7 ff fc addiu	a3,a3,-4
[ 335] 0x900000001fc164b0:  14 60 ff e7 bne	v1,zero,0x900000001fc16450
[ 335] 0x900000001fc164b4:  8c 82 00 90 lw	v0,144(a0)
[ 335] 0x900000001fc164b8:  ac c2 00 00 sw	v0,0(a2)
[ 335] 0x900000001fc164bc:  8c 8e 00 94 lw	t2,148(a0)
[ 335] 0x900000001fc164c0:  ac ce 00 04 sw	t2,4(a2)
[ 335] 0x900000001fc164c4:  8c 8e 00 98 lw	t2,152(a0)
[ 335] 0x900000001fc164c8:  ac ce 00 08 sw	t2,8(a2)
[ 335] 0x900000001fc164cc:  8c 8e 00 9c lw	t2,156(a0)
[ 335] 0x900000001fc164d0:  ac ce 00 0c sw	t2,12(a2)
[ 335] 0x900000001fc164d4:  10 00 00 18 b		0x900000001fc16538
[ 335] 0x900000001fc164d8:  df b2 00 70 ld	s2,112(sp)
[ 335] 0x900000001fc164dc:  ac c2 00 00 sw	v0,0(a2)
[ 335] 0x900000001fc164e0:  8c af 00 94 lw	t3,148(a1)
[ 335] 0x900000001fc164e4:  ac cf 00 04 sw	t3,4(a2)
[ 335] 0x900000001fc164e8:  8c af 00 98 lw	t3,152(a1)
[ 335] 0x900000001fc164ec:  ac cf 00 08 sw	t3,8(a2)
[ 335] 0x900000001fc164f0:  8c af 00 9c lw	t3,156(a1)
[ 335] 0x900000001fc164f4:  10 00 00 0f b		0x900000001fc16534
[ 335] 0x900000001fc164f8:  ac cf 00 0c sw	t3,12(a2)
[ 335] 0x900000001fc164fc:  8d 52 00 90 lw	s2,144(a6)
[ 335] 0x900000001fc16500:  ad 32 00 00 sw	s2,0(a5)
[ 335] 0x900000001fc16504:  8d 52 00 94 lw	s2,148(a6)
[ 335] 0x900000001fc16508:  ad 32 00 04 sw	s2,4(a5)
[ 335] 0x900000001fc1650c:  8d 52 00 98 lw	s2,152(a6)
[ 335] 0x900000001fc16510:  ad 32 00 08 sw	s2,8(a5)
[ 335] 0x900000001fc16514:  25 6b ff fc addiu	a7,a7,-4
[ 335] 0x900000001fc16518:  8d 58 00 9c lw	t8,156(a6)
[ 335] 0x900000001fc1651c:  65 4a 00 10 daddiu	a6,a6,16
[ 335] 0x900000001fc16520:  00 2b 90 2a slt	s2,at,a7
[ 335] 0x900000001fc16524:  ad 38 00 0c sw	t8,12(a5)
[ 335] 0x900000001fc16528:  65 29 00 10 daddiu	a5,a5,16
[ 335] 0x900000001fc1652c:  56 40 ff f4 bnel	s2,zero,0x900000001fc16500
[ 335] 0x900000001fc16530:  8d 52 00 90 lw	s2,144(a6)
[ 335] 0x900000001fc16534:  df b2 00 70 ld	s2,112(sp)
  336:     }
  337: #if DEBUG
  338:     dump_evconfig_entry(mslot); 
  339: #endif
  340: 
  341:     sysctlr_message("Initing MPCONF blk..");
[ 341] 0x900000001fc16538:  0f f0 11 7c jal		sysctlr_message
[ 341] 0x900000001fc1653c:  66 04 08 40 daddiu	a0,s0,2112
  342:     loprintf("Initializing MPCONF blocks\n");
[ 342] 0x900000001fc16540:  0f f0 2c e3 jal		loprintf
[ 342] 0x900000001fc16544:  66 04 08 58 daddiu	a0,s0,2136
  343:     init_mpconf();
[ 343] 0x900000001fc16548:  0f f0 54 30 jal		init_mpconf
[ 343] 0x900000001fc1654c:  00 00 00 21 nada
  344: 
  345:     if (memval != EVDIAG_PASSED) {
[ 345] 0x900000001fc16550:  32 24 00 ff andi	a0,s1,0xff
[ 345] 0x900000001fc16554:  52 20 00 04 beql	s1,zero,0x900000001fc16568
[ 345] 0x900000001fc16558:  de 04 08 c0 ld	a0,2240(s0)
  346: 	podMode(memval, "*** Memory test/configuration failed.\r\n");
[ 346] 0x900000001fc1655c:  0f f0 15 fd jal		podMode
[ 346] 0x900000001fc16560:  66 05 08 78 daddiu	a1,s0,2168
[ 346] 0x900000001fc16564:  de 04 08 c0 ld	a0,2240(s0)
  347:     }
  348: 
  349:     /* Slaves will start testing their caches now. */
  350: 
  351:     /* Put stack in _uncached_ memory.  Run scache test. */
  352:     run_uncached(test_master, io4_err);
[ 352] 0x900000001fc16568:  0f f0 15 a7 jal		run_uncached
[ 352] 0x900000001fc1656c:  02 60 28 25 move	a1,s3
  353: 
  354:     /* Doesn't return */
  355: }
[ 355] 0x900000001fc16570:  df b3 00 68 ld	s3,104(sp)
[ 355] 0x900000001fc16574:  df bf 00 60 ld	ra,96(sp)
[ 355] 0x900000001fc16578:  df b0 00 80 ld	s0,128(sp)
[ 355] 0x900000001fc1657c:  df b1 00 78 ld	s1,120(sp)
[ 355] 0x900000001fc16580:  03 e0 00 08 jr	ra
[ 355] 0x900000001fc16584:  67 bd 07 80 daddiu	sp,sp,1920
  356: 
  357: void
  358: realWait(void)
  359: {
realWait:
[ 359] 0x900000001fc16588:  67 bd ff b0 daddiu	sp,sp,-80
[ 359] 0x900000001fc1658c:  3c 01 90 00 lui	at,0x9000
[ 359] 0x900000001fc16590:  60 21 00 00 daddi	at,at,0
[ 359] 0x900000001fc16594:  3c 02 1f c2 lui	v0,0x1fc2
[ 359] 0x900000001fc16598:  60 42 f2 50 daddi	v0,v0,-3504
[ 359] 0x900000001fc1659c:  00 01 08 3c dsll32	at,at,0
[ 359] 0x900000001fc165a0:  00 22 10 2c dadd	v0,at,v0
[ 359] 0x900000001fc165a4:  dc 41 01 98 ld	at,408(v0)
[ 359] 0x900000001fc165a8:  90 23 01 00 lbu	v1,256(at)
  360:     char	flags[32] = {0};
[ 360] 0x900000001fc165ac:  ff b3 00 30 sd	s3,48(sp)
[ 360] 0x900000001fc165b0:  a3 a3 00 00 sb	v1,0(sp)
[ 360] 0x900000001fc165b4:  90 23 01 01 lbu	v1,257(at)
[ 360] 0x900000001fc165b8:  a3 a3 00 01 sb	v1,1(sp)
[ 360] 0x900000001fc165bc:  90 23 01 02 lbu	v1,258(at)
[ 360] 0x900000001fc165c0:  a3 a3 00 02 sb	v1,2(sp)
[ 360] 0x900000001fc165c4:  90 23 01 03 lbu	v1,259(at)
[ 360] 0x900000001fc165c8:  a3 a3 00 03 sb	v1,3(sp)
[ 360] 0x900000001fc165cc:  90 23 01 04 lbu	v1,260(at)
[ 360] 0x900000001fc165d0:  a3 a3 00 04 sb	v1,4(sp)
[ 360] 0x900000001fc165d4:  90 23 01 05 lbu	v1,261(at)
[ 360] 0x900000001fc165d8:  a3 a3 00 05 sb	v1,5(sp)
[ 360] 0x900000001fc165dc:  90 23 01 06 lbu	v1,262(at)
[ 360] 0x900000001fc165e0:  a3 a3 00 06 sb	v1,6(sp)
[ 360] 0x900000001fc165e4:  90 23 01 07 lbu	v1,263(at)
[ 360] 0x900000001fc165e8:  a3 a3 00 07 sb	v1,7(sp)
[ 360] 0x900000001fc165ec:  90 23 01 08 lbu	v1,264(at)
[ 360] 0x900000001fc165f0:  a3 a3 00 08 sb	v1,8(sp)
[ 360] 0x900000001fc165f4:  90 23 01 09 lbu	v1,265(at)
[ 360] 0x900000001fc165f8:  a3 a3 00 09 sb	v1,9(sp)
[ 360] 0x900000001fc165fc:  90 23 01 0a lbu	v1,266(at)
[ 360] 0x900000001fc16600:  a3 a3 00 0a sb	v1,10(sp)
[ 360] 0x900000001fc16604:  90 23 01 0b lbu	v1,267(at)
[ 360] 0x900000001fc16608:  a3 a3 00 0b sb	v1,11(sp)
[ 360] 0x900000001fc1660c:  90 23 01 0c lbu	v1,268(at)
[ 360] 0x900000001fc16610:  a3 a3 00 0c sb	v1,12(sp)
[ 360] 0x900000001fc16614:  90 23 01 0d lbu	v1,269(at)
[ 360] 0x900000001fc16618:  a3 a3 00 0d sb	v1,13(sp)
[ 360] 0x900000001fc1661c:  90 23 01 0e lbu	v1,270(at)
[ 360] 0x900000001fc16620:  a3 a3 00 0e sb	v1,14(sp)
[ 360] 0x900000001fc16624:  90 23 01 0f lbu	v1,271(at)
[ 360] 0x900000001fc16628:  a3 a3 00 0f sb	v1,15(sp)
[ 360] 0x900000001fc1662c:  90 23 01 10 lbu	v1,272(at)
[ 360] 0x900000001fc16630:  a3 a3 00 10 sb	v1,16(sp)
[ 360] 0x900000001fc16634:  90 23 01 11 lbu	v1,273(at)
[ 360] 0x900000001fc16638:  a3 a3 00 11 sb	v1,17(sp)
[ 360] 0x900000001fc1663c:  90 23 01 12 lbu	v1,274(at)
[ 360] 0x900000001fc16640:  a3 a3 00 12 sb	v1,18(sp)
[ 360] 0x900000001fc16644:  90 23 01 13 lbu	v1,275(at)
[ 360] 0x900000001fc16648:  a3 a3 00 13 sb	v1,19(sp)
[ 360] 0x900000001fc1664c:  90 23 01 14 lbu	v1,276(at)
[ 360] 0x900000001fc16650:  a3 a3 00 14 sb	v1,20(sp)
[ 360] 0x900000001fc16654:  90 23 01 15 lbu	v1,277(at)
[ 360] 0x900000001fc16658:  a3 a3 00 15 sb	v1,21(sp)
[ 360] 0x900000001fc1665c:  90 23 01 16 lbu	v1,278(at)
[ 360] 0x900000001fc16660:  a3 a3 00 16 sb	v1,22(sp)
[ 360] 0x900000001fc16664:  90 23 01 17 lbu	v1,279(at)
[ 360] 0x900000001fc16668:  a3 a3 00 17 sb	v1,23(sp)
[ 360] 0x900000001fc1666c:  90 23 01 18 lbu	v1,280(at)
[ 360] 0x900000001fc16670:  a3 a3 00 18 sb	v1,24(sp)
[ 360] 0x900000001fc16674:  90 23 01 19 lbu	v1,281(at)
[ 360] 0x900000001fc16678:  a3 a3 00 19 sb	v1,25(sp)
[ 360] 0x900000001fc1667c:  90 23 01 1a lbu	v1,282(at)
[ 360] 0x900000001fc16680:  a3 a3 00 1a sb	v1,26(sp)
[ 360] 0x900000001fc16684:  90 23 01 1b lbu	v1,283(at)
[ 360] 0x900000001fc16688:  a3 a3 00 1b sb	v1,27(sp)
[ 360] 0x900000001fc1668c:  90 23 01 1c lbu	v1,284(at)
[ 360] 0x900000001fc16690:  a3 a3 00 1c sb	v1,28(sp)
[ 360] 0x900000001fc16694:  90 23 01 1d lbu	v1,285(at)
[ 360] 0x900000001fc16698:  a3 a3 00 1d sb	v1,29(sp)
[ 360] 0x900000001fc1669c:  ff a2 00 20 sd	v0,32(sp)
[ 360] 0x900000001fc166a0:  90 23 01 1e lbu	v1,286(at)
[ 360] 0x900000001fc166a4:  a3 a3 00 1e sb	v1,30(sp)
  361:     __uint64_t	addr;
  362: 
  363:     SD(EV_SCRATCH, 0);
  364:     SD(EV_CERTOIP, (__int64_t)-1);
  365:     ccuart_puts("\n\n\rWaiting for launch .....");
[ 365] 0x900000001fc166a8:  3c 04 90 00 lui	a0,0x9000
[ 365] 0x900000001fc166ac:  90 21 01 1f lbu	at,287(at)
[ 365] 0x900000001fc166b0:  dc 53 09 00 ld	s3,2304(v0)
[ 365] 0x900000001fc166b4:  60 84 00 00 daddi	a0,a0,0
[ 365] 0x900000001fc166b8:  3c 05 1f c2 lui	a1,0x1fc2
[ 365] 0x900000001fc166bc:  a3 a1 00 1f sb	at,31(sp)
[ 365] 0x900000001fc166c0:  60 a5 fb 18 daddi	a1,a1,-1256
[ 365] 0x900000001fc166c4:  00 04 20 3c dsll32	a0,a0,0
[ 365] 0x900000001fc166c8:  fe 60 00 00 sd	zero,0(s3)
[ 364] 0x900000001fc166cc:  00 85 20 2c dadd	a0,a0,a1
[ 364] 0x900000001fc166d0:  dc 42 09 08 ld	v0,2312(v0)
[ 364] 0x900000001fc166d4:  24 01 ff ff li	at,-1
[ 364] 0x900000001fc166d8:  ff b2 00 38 sd	s2,56(sp)
[ 364] 0x900000001fc166dc:  ff bf 00 28 sd	ra,40(sp)
[ 364] 0x900000001fc166e0:  0f f0 0d 14 jal		ccuart_puts
[ 364] 0x900000001fc166e4:  fc 41 00 00 sd	at,0(v0)
  366:     while (((addr = LD(EV_SCRATCH)) && 
[ 366] 0x900000001fc166e8:  3c 01 00 2d lui	at,0x2d
[ 366] 0x900000001fc166ec:  24 12 00 2e li	s2,46
[ 366] 0x900000001fc166f0:  ff b1 00 40 sd	s1,64(sp)
[ 366] 0x900000001fc166f4:  34 31 c6 c0 ori	s1,at,0xc6c0
[ 366] 0x900000001fc166f8:  de 61 00 00 ld	at,0(s3)
[ 366] 0x900000001fc166fc:  ff b0 00 48 sd	s0,72(sp)
[ 366] 0x900000001fc16700:  14 20 00 08 bne	at,zero,0x900000001fc16724
[ 366] 0x900000001fc16704:  00 20 80 25 move	s0,at
  367: 	   0x00000000ffffffff) == 0) {
  368: 	delay(3000000);
[ 368] 0x900000001fc16708:  0f f0 0d a4 jal		delay
[ 368] 0x900000001fc1670c:  02 20 20 25 move	a0,s1
  369: 	ccuart_putc('.');
[ 369] 0x900000001fc16710:  0f f0 0c d6 jal		ccuart_putc
[ 369] 0x900000001fc16714:  02 40 20 25 move	a0,s2
[ 366] 0x900000001fc16718:  de 66 00 00 ld	a2,0(s3)
[ 366] 0x900000001fc1671c:  10 c0 ff fa beq	a2,zero,0x900000001fc16708
[ 366] 0x900000001fc16720:  00 c0 80 25 move	s0,a2
[ 366] 0x900000001fc16724:  df b2 00 38 ld	s2,56(sp)
  370:     }
  371: 
  372:     ccuart_puts(" .... and they're off\n\r");
[ 372] 0x900000001fc16728:  df a7 00 20 ld	a3,32(sp)
[ 372] 0x900000001fc1672c:  df b1 00 40 ld	s1,64(sp)
[ 372] 0x900000001fc16730:  0f f0 0d 14 jal		ccuart_puts
[ 372] 0x900000001fc16734:  64 e4 08 e8 daddiu	a0,a3,2280
  373:     SD(EV_SCRATCH, 0);
  374: 
  375:     jump_addr(addr, 0, 0, (void *)flags);
[ 375] 0x900000001fc16738:  67 a7 00 00 daddiu	a3,sp,0
[ 375] 0x900000001fc1673c:  00 00 30 25 move	a2,zero
[ 373] 0x900000001fc16740:  fe 60 00 00 sd	zero,0(s3)
[ 373] 0x900000001fc16744:  df b3 00 30 ld	s3,48(sp)
[ 373] 0x900000001fc16748:  00 00 28 25 move	a1,zero
[ 373] 0x900000001fc1674c:  0f f0 2b 49 jal		jump_addr
[ 373] 0x900000001fc16750:  02 00 20 25 move	a0,s0
  376: }    
[ 376] 0x900000001fc16754:  df b0 00 48 ld	s0,72(sp)
[ 376] 0x900000001fc16758:  df bf 00 28 ld	ra,40(sp)
[ 376] 0x900000001fc1675c:  03 e0 00 08 jr	ra
[ 376] 0x900000001fc16760:  67 bd 00 50 daddiu	sp,sp,80
  377: 
  378: void
  379: wait(void)
  380: {
wait:
[ 380] 0x900000001fc16764:  67 bd ff f0 daddiu	sp,sp,-16
  381:     run_uncached(realWait, 0);
[ 381] 0x900000001fc16768:  3c 01 90 00 lui	at,0x9000
[ 381] 0x900000001fc1676c:  60 21 00 00 daddi	at,at,0
[ 381] 0x900000001fc16770:  3c 02 1f c2 lui	v0,0x1fc2
[ 381] 0x900000001fc16774:  60 42 f2 50 daddi	v0,v0,-3504
[ 381] 0x900000001fc16778:  00 01 08 3c dsll32	at,at,0
[ 381] 0x900000001fc1677c:  00 22 08 2c dadd	at,at,v0
[ 381] 0x900000001fc16780:  00 00 28 25 move	a1,zero
[ 381] 0x900000001fc16784:  ff bf 00 00 sd	ra,0(sp)
[ 381] 0x900000001fc16788:  0f f0 15 a7 jal		run_uncached
[ 381] 0x900000001fc1678c:  dc 24 09 10 ld	a0,2320(at)
  382: }
[ 382] 0x900000001fc16790:  df bf 00 00 ld	ra,0(sp)
[ 382] 0x900000001fc16794:  03 e0 00 08 jr	ra
[ 382] 0x900000001fc16798:  67 bd 00 10 daddiu	sp,sp,16
Skipping source listing to line 17 of /cores/banyan/stand/arcs/IP25prom/init_epcuart.c...
   18: static unsigned int get_baudrate(uint);
   19: 
   20: /*
   21:  * init_epc_uart
   22:  *	Initializes the first uart port on the Master IO4.
   23:  */
   24: 
   25: void
   26: init_epc_uart(void)
   27: {
init_epc_uart:
[  27] 0x900000001fc1679c:  67 bd ff e0 daddiu	sp,sp,-32
   28: 	__scunsigned_t	baseaddr;	/* Base address of EPC DUART1 */
   29: 
   30: 	sysctlr_message("Initing UART Chan A");
[  30] 0x900000001fc167a0:  3c 01 90 00 lui	at,0x9000
[  30] 0x900000001fc167a4:  60 21 00 00 daddi	at,at,0
[  30] 0x900000001fc167a8:  3c 02 1f c2 lui	v0,0x1fc2
[  30] 0x900000001fc167ac:  60 42 fb 70 daddi	v0,v0,-1168
[  30] 0x900000001fc167b0:  00 01 08 3c dsll32	at,at,0
[  30] 0x900000001fc167b4:  ff b0 00 08 sd	s0,8(sp)
[  30] 0x900000001fc167b8:  00 22 80 2c dadd	s0,at,v0
[  30] 0x900000001fc167bc:  ff bf 00 00 sd	ra,0(sp)
[  30] 0x900000001fc167c0:  0f f0 11 7c jal		sysctlr_message
[  30] 0x900000001fc167c4:  02 00 20 25 move	a0,s0
   31: 	configure_port(CHN_A);
[  31] 0x900000001fc167c8:  0f f0 5a 18 jal		configure_port
[  31] 0x900000001fc167cc:  24 04 60 08 li	a0,24584
   32: 
   33: 	sysctlr_message("Initing UART Chan B");
[  33] 0x900000001fc167d0:  3c 01 90 00 lui	at,0x9000
[  33] 0x900000001fc167d4:  3c 02 1f c2 lui	v0,0x1fc2
[  33] 0x900000001fc167d8:  60 21 00 00 daddi	at,at,0
[  33] 0x900000001fc167dc:  60 42 fb 88 daddi	v0,v0,-1144
[  33] 0x900000001fc167e0:  00 01 08 3c dsll32	at,at,0
[  33] 0x900000001fc167e4:  0f f0 11 7c jal		sysctlr_message
[  33] 0x900000001fc167e8:  00 22 20 2c dadd	a0,at,v0
   34: 	configure_port(CHN_B);
[  34] 0x900000001fc167ec:  24 04 50 00 li	a0,20480
[  34] 0x900000001fc167f0:  0f f0 5a 18 jal		configure_port
[  34] 0x900000001fc167f4:  24 00 50 00 li	zero,20480
   35: 
   36: 	baseaddr = SWIN_BASE(EPC_REGION, master_epc_adap())  + 
[  36] 0x900000001fc167f8:  0f f0 3d 04 jal		master_epc_adap
[  36] 0x900000001fc167fc:  00 00 00 21 nada
[  36] 0x900000001fc16800:  ff b1 00 10 sd	s1,16(sp)
[  36] 0x900000001fc16804:  00 02 8c 38 dsll	s1,v0,16
[  36] 0x900000001fc16808:  0f f0 0d d0 jal		getendian
[  36] 0x900000001fc1680c:  00 00 00 21 nada
[  36] 0x900000001fc16810:  2c 42 00 01 sltiu	v0,v0,1
[  36] 0x900000001fc16814:  00 02 08 c0 sll	at,v0,3
[  36] 0x900000001fc16818:  00 22 08 23 subu	at,at,v0
   37: 			(7 * (!getendian()));
   38: 	set_epcuart_base(baseaddr);
[  38] 0x900000001fc1681c:  02 21 08 2d daddu	at,s1,at
[  38] 0x900000001fc16820:  df b1 00 10 ld	s1,16(sp)
[  38] 0x900000001fc16824:  de 02 00 58 ld	v0,88(s0)
[  38] 0x900000001fc16828:  df b0 00 08 ld	s0,8(sp)
[  38] 0x900000001fc1682c:  0f f0 0d 9e jal		set_epcuart_base
[  38] 0x900000001fc16830:  00 22 20 2f dsubu	a0,at,v0
[  38] 0x900000001fc16834:  24 05 50 00 li	a1,20480
   39: 
   40: 	epcuart_puts("Testing Channel B on the EPC UART", CHN_B);
[  40] 0x900000001fc16838:  3c 01 90 00 lui	at,0x9000
[  40] 0x900000001fc1683c:  3c 02 1f c2 lui	v0,0x1fc2
[  40] 0x900000001fc16840:  60 21 00 00 daddi	at,at,0
[  40] 0x900000001fc16844:  60 42 fb a0 daddi	v0,v0,-1120
[  40] 0x900000001fc16848:  00 01 08 3c dsll32	at,at,0
[  40] 0x900000001fc1684c:  0f f0 15 7b jal		epcuart_puts
[  40] 0x900000001fc16850:  00 22 20 2c dadd	a0,at,v0
   41: }
[  41] 0x900000001fc16854:  df bf 00 00 ld	ra,0(sp)
[  41] 0x900000001fc16858:  03 e0 00 08 jr	ra
[  41] 0x900000001fc1685c:  67 bd 00 20 daddiu	sp,sp,32
   42: 
   43: static void 
   44: configure_port(uint chan)
   45: {
configure_port:
[  45] 0x900000001fc16860:  67 bd ff d0 daddiu	sp,sp,-48
   46:     register volatile u_char	*cntrl;
   47:     uint baud;			/* Computed baud rate */
   48:     __scunsigned_t padap = master_epc_adap();
[  48] 0x900000001fc16864:  ff bf 00 28 sd	ra,40(sp)
[  48] 0x900000001fc16868:  0f f0 3d 04 jal		master_epc_adap
[  48] 0x900000001fc1686c:  ff a4 00 00 sd	a0,0(sp)
   49: 
   50:     /* Setup the control pointer */
   51:     cntrl = (volatile u_char*) (SWIN_BASE(EPC_REGION, padap) +
[  51] 0x900000001fc16870:  ff b0 00 20 sd	s0,32(sp)
[  51] 0x900000001fc16874:  00 02 84 38 dsll	s0,v0,16
[  51] 0x900000001fc16878:  0f f0 0d d0 jal		getendian
[  51] 0x900000001fc1687c:  00 00 00 21 nada
[  51] 0x900000001fc16880:  3c 01 90 00 lui	at,0x9000
[  51] 0x900000001fc16884:  00 40 18 25 move	v1,v0
[  51] 0x900000001fc16888:  3c 02 1f c2 lui	v0,0x1fc2
[  51] 0x900000001fc1688c:  60 21 00 00 daddi	at,at,0
[  51] 0x900000001fc16890:  60 42 fb 70 daddi	v0,v0,-1168
[  51] 0x900000001fc16894:  00 01 08 3c dsll32	at,at,0
   52: 		(7 * !getendian()) + chan);
   53: 
   54:     if (chan == CHN_A) {
[  54] 0x900000001fc16898:  24 0b 00 09 li	a7,9
[  54] 0x900000001fc1689c:  24 19 00 40 li	t9,64
[  54] 0x900000001fc168a0:  2c 65 00 01 sltiu	a1,v1,1
[  54] 0x900000001fc168a4:  00 22 08 2c dadd	at,at,v0
[  54] 0x900000001fc168a8:  df a4 00 00 ld	a0,0(sp)
[  54] 0x900000001fc168ac:  24 1f 00 0f li	ra,15
[  54] 0x900000001fc168b0:  00 05 10 c0 sll	v0,a1,3
[  54] 0x900000001fc168b4:  00 04 18 3c dsll32	v1,a0,0
[  54] 0x900000001fc168b8:  00 45 10 23 subu	v0,v0,a1
[  54] 0x900000001fc168bc:  00 03 18 3e dsrl32	v1,v1,0
[  54] 0x900000001fc168c0:  02 02 10 2d daddu	v0,s0,v0
[  54] 0x900000001fc168c4:  ff b3 00 18 sd	s3,24(sp)
[  54] 0x900000001fc168c8:  00 43 10 2d daddu	v0,v0,v1
[  54] 0x900000001fc168cc:  dc 23 00 58 ld	v1,88(at)
[  54] 0x900000001fc168d0:  24 01 60 08 li	at,24584
[  54] 0x900000001fc168d4:  ff b1 00 08 sd	s1,8(sp)
[  54] 0x900000001fc168d8:  ff b2 00 10 sd	s2,16(sp)
[  54] 0x900000001fc168dc:  10 81 00 07 beq	a0,at,0x900000001fc168fc
[  54] 0x900000001fc168e0:  00 43 80 2f dsubu	s0,v0,v1
[  54] 0x900000001fc168e4:  24 12 00 03 li	s2,3
[  54] 0x900000001fc168e8:  24 13 00 01 li	s3,1
   55:         WR_CNTRL(cntrl, WR9, WR9_RST_CHNA);
   56:     } else {
   57:         WR_CNTRL(cntrl, WR9, WR9_RST_CHNB);
[  57] 0x900000001fc168ec:  a2 0b 00 00 sb	a7,0(s0)
[  57] 0x900000001fc168f0:  24 11 00 05 li	s1,5
[  57] 0x900000001fc168f4:  10 00 00 07 b		0x900000001fc16914
[  57] 0x900000001fc168f8:  a2 19 00 00 sb	t9,0(s0)
[  57] 0x900000001fc168fc:  24 13 00 01 li	s3,1
[  55] 0x900000001fc16900:  a2 0b 00 00 sb	a7,0(s0)
[  55] 0x900000001fc16904:  24 18 00 80 li	t8,128
[  55] 0x900000001fc16908:  24 11 00 05 li	s1,5
[  55] 0x900000001fc1690c:  24 12 00 03 li	s2,3
[  55] 0x900000001fc16910:  a2 18 00 00 sb	t8,0(s0)
   58:     }
   59: 
   60:     /* Allow extended mode commands; among other things, this allows us
   61:      * to read some of the write registers using read register aliases
   62:      */
   63:     WR_CNTRL(cntrl, WR15, WR15_Z85130_EXTENDED);
[  63] 0x900000001fc16914:  a2 1f 00 00 sb	ra,0(s0)
   64:     WR_CNTRL(cntrl, WR7, WR7_EXTENDED_READ);
[  64] 0x900000001fc16918:  a2 13 00 00 sb	s3,0(s0)
[  64] 0x900000001fc1691c:  24 1f 00 07 li	ra,7
[  64] 0x900000001fc16920:  a2 1f 00 00 sb	ra,0(s0)
   65: 
   66:     /* Set clock factor, parity, and stop bits */
   67:     WR_CNTRL(cntrl, WR4, WR4_X16_CLK | WR4_1_STOP);
[  67] 0x900000001fc16924:  a2 19 00 00 sb	t9,0(s0)
[  67] 0x900000001fc16928:  24 19 00 04 li	t9,4
[  67] 0x900000001fc1692c:  a2 19 00 00 sb	t9,0(s0)
[  67] 0x900000001fc16930:  24 19 00 44 li	t9,68
   68: 
   69:     /* Set up receiver/transmitter operating parameters */
   70:     WR_CNTRL(cntrl, WR3, WR3_RX_8BIT);
[  70] 0x900000001fc16934:  a2 19 00 00 sb	t9,0(s0)
[  70] 0x900000001fc16938:  a2 12 00 00 sb	s2,0(s0)
[  70] 0x900000001fc1693c:  24 19 00 c0 li	t9,192
   71:     WR_CNTRL(cntrl, WR5, WR5_TX_8BIT);
[  71] 0x900000001fc16940:  a2 19 00 00 sb	t9,0(s0)
[  71] 0x900000001fc16944:  a2 11 00 00 sb	s1,0(s0)
[  71] 0x900000001fc16948:  24 19 00 60 li	t9,96
   72: 
   73:     /* Set encoding to NRZ mode */
   74:     WR_CNTRL(cntrl, WR10, 0);
[  74] 0x900000001fc1694c:  a2 19 00 00 sb	t9,0(s0)
[  74] 0x900000001fc16950:  24 19 00 0a li	t9,10
[  74] 0x900000001fc16954:  a2 19 00 00 sb	t9,0(s0)
   75: 
   76:     /* receiver/transmitter clock source is baud rate generator */
   77:     WR_CNTRL(cntrl, WR11, WR11_RCLK_BRG | WR11_TCLK_BRG);
[  77] 0x900000001fc16958:  a2 00 00 00 sb	zero,0(s0)
[  77] 0x900000001fc1695c:  24 19 00 0b li	t9,11
   78: 
   79:     /* Figure out what the baud rate is and write it into the
   80:     * BRG count down registers.
   81:     */
   82:     baud = get_baudrate(chan);
[  82] 0x900000001fc16960:  a2 19 00 00 sb	t9,0(s0)
[  82] 0x900000001fc16964:  24 19 00 50 li	t9,80
[  82] 0x900000001fc16968:  0f f0 5a 9c jal		get_baudrate
[  82] 0x900000001fc1696c:  a2 19 00 00 sb	t9,0(s0)
[  82] 0x900000001fc16970:  00 40 c8 25 move	t9,v0
   83:     baud = ((CLK_SPEED + baud * CLK_FACTOR) / (baud * CLK_FACTOR * 2) - 2 ); 
[  83] 0x900000001fc16974:  3c 01 00 38 lui	at,0x38
[  83] 0x900000001fc16978:  00 19 f9 00 sll	ra,t9,4
[  83] 0x900000001fc1697c:  34 22 07 c0 ori	v0,at,0x7c0
[  83] 0x900000001fc16980:  00 19 09 40 sll	at,t9,5
[  83] 0x900000001fc16984:  03 e2 f8 21 addu	ra,ra,v0
[  83] 0x900000001fc16988:  03 e1 00 1b divu	ra,at
   84: 
   85:     /* Set the baud rate, safer to disable BRG first */
   86:     WR_CNTRL(cntrl, WR14, 0x00);
[  86] 0x900000001fc1698c:  24 19 00 0e li	t9,14
[  86] 0x900000001fc16990:  a2 19 00 00 sb	t9,0(s0)
[  86] 0x900000001fc16994:  00 00 f8 12 mflo	ra
   87:     WR_CNTRL(cntrl, WR12, baud & 0xff);
[  87] 0x900000001fc16998:  a2 00 00 00 sb	zero,0(s0)
[  87] 0x900000001fc1699c:  24 01 00 0c li	at,12
[  87] 0x900000001fc169a0:  27 ff ff fe addiu	ra,ra,-2
[  87] 0x900000001fc169a4:  a2 01 00 00 sb	at,0(s0)
[  87] 0x900000001fc169a8:  33 e1 00 ff andi	at,ra,0xff
   88:     WR_CNTRL(cntrl, WR13, (baud >> 8) & 0xff);
[  88] 0x900000001fc169ac:  00 1f fa 02 srl	ra,ra,8
[  88] 0x900000001fc169b0:  a2 01 00 00 sb	at,0(s0)
[  88] 0x900000001fc169b4:  24 01 00 0d li	at,13
[  88] 0x900000001fc169b8:  33 ff 00 ff andi	ra,ra,0xff
[  88] 0x900000001fc169bc:  a2 01 00 00 sb	at,0(s0)
[  88] 0x900000001fc169c0:  a2 1f 00 00 sb	ra,0(s0)
   89:     WR_CNTRL(cntrl, WR14, WR14_BRG_ENBL);
[  89] 0x900000001fc169c4:  a2 19 00 00 sb	t9,0(s0)
[  89] 0x900000001fc169c8:  a2 13 00 00 sb	s3,0(s0)
   90: 
   91:     /* Enable receiver and transmitter */
   92:     WR_CNTRL(cntrl, WR3, WR3_RX_8BIT | WR3_RX_ENBL);
[  92] 0x900000001fc169cc:  a2 12 00 00 sb	s2,0(s0)
[  92] 0x900000001fc169d0:  24 19 00 c1 li	t9,193
[  92] 0x900000001fc169d4:  a2 19 00 00 sb	t9,0(s0)
   93:     WR_CNTRL(cntrl, WR5, WR5_TX_8BIT | WR5_TX_ENBL);
[  93] 0x900000001fc169d8:  a2 11 00 00 sb	s1,0(s0)
[  93] 0x900000001fc169dc:  24 19 00 68 li	t9,104
   94: 
   95:     /* Try to avoid the "mysterious" BREAK signal */
   96:     WR_WR0(cntrl, WR0_RST_EXT_INT);
[  96] 0x900000001fc169e0:  a2 19 00 00 sb	t9,0(s0)
[  96] 0x900000001fc169e4:  24 19 00 10 li	t9,16
[  96] 0x900000001fc169e8:  a2 19 00 00 sb	t9,0(s0)
   97:     if (RD_RR0(cntrl) & RR0_BRK) {
[  97] 0x900000001fc169ec:  92 19 00 00 lbu	t9,0(s0)
[  97] 0x900000001fc169f0:  33 39 00 80 andi	t9,t9,0x80
[  97] 0x900000001fc169f4:  53 20 00 0b beql	t9,zero,0x900000001fc16a24
[  97] 0x900000001fc169f8:  df b3 00 18 ld	s3,24(sp)
   98: 	while (RD_RR0(cntrl) & RR0_RX_CHR) /* LOOP */ ;
[  98] 0x900000001fc169fc:  92 01 00 00 lbu	at,0(s0)
[  98] 0x900000001fc16a00:  30 21 00 01 andi	at,at,0x1
[  98] 0x900000001fc16a04:  10 20 00 05 beq	at,zero,0x900000001fc16a1c
[  98] 0x900000001fc16a08:  24 03 00 10 li	v1,16
[  98] 0x900000001fc16a0c:  92 02 00 00 lbu	v0,0(s0)
[  98] 0x900000001fc16a10:  30 42 00 01 andi	v0,v0,0x1
[  98] 0x900000001fc16a14:  54 40 ff fe bnel	v0,zero,0x900000001fc16a10
[  98] 0x900000001fc16a18:  92 02 00 00 lbu	v0,0(s0)
   99: 	WR_WR0(cntrl, WR0_RST_EXT_INT);
[  99] 0x900000001fc16a1c:  a2 03 00 00 sb	v1,0(s0)
[  99] 0x900000001fc16a20:  df b3 00 18 ld	s3,24(sp)
  100:     }
  101: 
  102:     /* Clear FIFO and any outstanding errors */
  103:     while (RD_RR0(cntrl) & RR0_RX_CHR) {
[ 103] 0x900000001fc16a24:  92 04 00 00 lbu	a0,0(s0)
[ 103] 0x900000001fc16a28:  24 19 00 08 li	t9,8
[ 103] 0x900000001fc16a2c:  df b1 00 08 ld	s1,8(sp)
[ 103] 0x900000001fc16a30:  df bf 00 28 ld	ra,40(sp)
[ 103] 0x900000001fc16a34:  30 84 00 01 andi	a0,a0,0x1
[ 103] 0x900000001fc16a38:  24 0b 00 30 li	a7,48
[ 103] 0x900000001fc16a3c:  df b2 00 10 ld	s2,16(sp)
[ 103] 0x900000001fc16a40:  50 80 00 09 beql	a0,zero,0x900000001fc16a68
[ 103] 0x900000001fc16a44:  df b0 00 20 ld	s0,32(sp)
  104: 	RD_CNTRL(cntrl, RR8);
[ 104] 0x900000001fc16a48:  a2 19 00 00 sb	t9,0(s0)
[ 104] 0x900000001fc16a4c:  92 00 00 00 lbu	zero,0(s0)
  105: 	WR_WR0(cntrl, WR0_RST_ERR);
[ 105] 0x900000001fc16a50:  a2 0b 00 00 sb	a7,0(s0)
[ 103] 0x900000001fc16a54:  92 05 00 00 lbu	a1,0(s0)
[ 103] 0x900000001fc16a58:  30 a5 00 01 andi	a1,a1,0x1
[ 103] 0x900000001fc16a5c:  14 a0 ff fa bne	a1,zero,0x900000001fc16a48
[ 103] 0x900000001fc16a60:  00 00 00 21 nada
[ 103] 0x900000001fc16a64:  df b0 00 20 ld	s0,32(sp)
[ 103] 0x900000001fc16a68:  03 e0 00 08 jr	ra
[ 103] 0x900000001fc16a6c:  67 bd 00 30 daddiu	sp,sp,48
  106:     }
  107: }
  108: 
  109: static unsigned int
  110: get_baudrate(uint chan)
  111: {
get_baudrate:
[ 111] 0x900000001fc16a70:  67 bd ff d0 daddiu	sp,sp,-48
  112:     char baudstr[NVLEN_LBAUD + 1];
  113:     unsigned i;
  114:     unsigned baud_rate = 0;
[ 114] 0x900000001fc16a74:  ff b0 00 20 sd	s0,32(sp)
[ 114] 0x900000001fc16a78:  00 00 80 25 move	s0,zero
  115:     unsigned default_baud;
  116: 
  117:     if (chan == CHN_A)
[ 117] 0x900000001fc16a7c:  24 01 60 08 li	at,24584
[ 117] 0x900000001fc16a80:  ff b2 00 10 sd	s2,16(sp)
[ 117] 0x900000001fc16a84:  ff a4 00 08 sd	a0,8(sp)
[ 117] 0x900000001fc16a88:  10 81 00 03 beq	a0,at,0x900000001fc16a98
[ 117] 0x900000001fc16a8c:  24 12 25 80 li	s2,9600
  118: 	default_baud = 9600;
  119:     else
  120: 	default_baud = 19200;
[ 120] 0x900000001fc16a90:  10 00 00 01 b		0x900000001fc16a98
[ 120] 0x900000001fc16a94:  24 12 4b 00 li	s2,19200
  121: 
  122:     /* Don't try to read the baud rate out of the NVRAM if the defaults
  123:      * switch is set 
  124:      */
  125:     if (sysctlr_getdebug() & VDS_DEFAULTS)
[ 125] 0x900000001fc16a98:  ff bf 00 28 sd	ra,40(sp)
[ 125] 0x900000001fc16a9c:  0f f0 11 8a jal		sysctlr_getdebug
[ 125] 0x900000001fc16aa0:  00 00 00 21 nada
[ 125] 0x900000001fc16aa4:  02 40 c8 25 move	t9,s2
[ 125] 0x900000001fc16aa8:  30 45 00 08 andi	a1,v0,0x8
[ 125] 0x900000001fc16aac:  ff b1 00 18 sd	s1,24(sp)
[ 125] 0x900000001fc16ab0:  14 a0 00 41 bne	a1,zero,0x900000001fc16bb8
[ 125] 0x900000001fc16ab4:  24 11 00 39 li	s1,57
  126: 	return default_baud;
  127: 
  128:     if (nvram_okay()) {
[ 128] 0x900000001fc16ab8:  0f f0 30 ed jal		nvram_okay
[ 128] 0x900000001fc16abc:  00 00 00 21 nada
[ 128] 0x900000001fc16ac0:  24 08 60 08 li	a4,24584
[ 128] 0x900000001fc16ac4:  24 05 00 05 li	a1,5
[ 128] 0x900000001fc16ac8:  14 40 00 03 bne	v0,zero,0x900000001fc16ad8
[ 128] 0x900000001fc16acc:  df a7 00 08 ld	a3,8(sp)
  129: 
  130: 	/* Read the baud rate out of the prom and convert it to an
  131: 	 * integer
  132: 	 */
  133: 	if (chan == CHN_A) 
  134: 	    get_nvram(NVOFF_LBAUD, NVLEN_LBAUD, baudstr);
  135: 	else
  136: 	    get_nvram(NVOFF_RBAUD, NVLEN_RBAUD, baudstr);
  137: 
  138: 	for (i = 0; baudstr[i] >= '0' && baudstr[i] <= '9';  i++)
  139: 	    baud_rate = baud_rate*10 + baudstr[i] - '0';
  140: 
  141: 	if (baud_rate < 50 || baud_rate > 38400 || ((baud_rate % 300) != 0))
  142: 	    baud_rate = default_baud;
  143:     } else {
  144: 	baud_rate = default_baud;
[ 144] 0x900000001fc16ad0:  10 00 00 39 b		0x900000001fc16bb8
[ 144] 0x900000001fc16ad4:  02 40 c8 25 move	t9,s2
[ 133] 0x900000001fc16ad8:  10 e8 00 07 beq	a3,a4,0x900000001fc16af8
[ 133] 0x900000001fc16adc:  67 a6 00 00 daddiu	a2,sp,0
[ 136] 0x900000001fc16ae0:  0f f0 30 cb jal		get_nvram
[ 136] 0x900000001fc16ae4:  24 04 03 16 li	a0,790
[ 136] 0x900000001fc16ae8:  00 00 c8 25 move	t9,zero
[ 136] 0x900000001fc16aec:  93 a9 00 00 lbu	a5,0(sp)
[ 136] 0x900000001fc16af0:  10 00 00 06 b		0x900000001fc16b0c
[ 136] 0x900000001fc16af4:  29 2b 00 30 slti	a7,a5,48
[ 134] 0x900000001fc16af8:  0f f0 30 cb jal		get_nvram
[ 134] 0x900000001fc16afc:  24 04 00 74 li	a0,116
[ 134] 0x900000001fc16b00:  93 aa 00 00 lbu	a6,0(sp)
[ 134] 0x900000001fc16b04:  00 00 c8 25 move	t9,zero
[ 134] 0x900000001fc16b08:  29 4b 00 30 slti	a7,a6,48
[ 138] 0x900000001fc16b0c:  55 60 00 18 bnel	a7,zero,0x900000001fc16b70
[ 138] 0x900000001fc16b10:  02 00 c8 25 move	t9,s0
[ 138] 0x900000001fc16b14:  02 10 70 21 addu	t2,s0,s0
[ 138] 0x900000001fc16b18:  93 ab 00 00 lbu	a7,0(sp)
[ 138] 0x900000001fc16b1c:  00 10 68 c0 sll	t1,s0,3
[ 138] 0x900000001fc16b20:  01 ae 50 21 addu	a6,t1,t2
[ 138] 0x900000001fc16b24:  29 6c 00 3a slti	t0,a7,58
[ 138] 0x900000001fc16b28:  51 80 00 11 beql	t0,zero,0x900000001fc16b70
[ 138] 0x900000001fc16b2c:  02 00 c8 25 move	t9,s0
[ 138] 0x900000001fc16b30:  27 39 00 01 addiu	t9,t9,1
[ 138] 0x900000001fc16b34:  00 19 78 3c dsll32	t3,t9,0
[ 138] 0x900000001fc16b38:  00 0f 78 3e dsrl32	t3,t3,0
[ 138] 0x900000001fc16b3c:  03 af 78 2d daddu	t3,sp,t3
[ 139] 0x900000001fc16b40:  01 4b 80 21 addu	s0,a6,a7
[ 139] 0x900000001fc16b44:  91 eb 00 00 lbu	a7,0(t3)
[ 139] 0x900000001fc16b48:  26 10 ff d0 addiu	s0,s0,-48
[ 139] 0x900000001fc16b4c:  02 2b 48 2a slt	a5,s1,a7
[ 139] 0x900000001fc16b50:  29 6f 00 30 slti	t3,a7,48
[ 139] 0x900000001fc16b54:  55 e0 00 06 bnel	t3,zero,0x900000001fc16b70
[ 139] 0x900000001fc16b58:  02 00 c8 25 move	t9,s0
[ 139] 0x900000001fc16b5c:  02 10 f8 21 addu	ra,s0,s0
[ 139] 0x900000001fc16b60:  00 10 c0 c0 sll	t8,s0,3
[ 139] 0x900000001fc16b64:  11 20 ff f2 beq	a5,zero,0x900000001fc16b30
[ 139] 0x900000001fc16b68:  03 1f 50 21 addu	a6,t8,ra
[ 139] 0x900000001fc16b6c:  02 00 c8 25 move	t9,s0
[ 141] 0x900000001fc16b70:  2e 01 00 32 sltiu	at,s0,50
[ 141] 0x900000001fc16b74:  14 20 00 0e bne	at,zero,0x900000001fc16bb0
[ 141] 0x900000001fc16b78:  00 00 00 21 nada
[ 141] 0x900000001fc16b7c:  34 02 96 00 ori	v0,zero,0x9600
[ 141] 0x900000001fc16b80:  00 50 10 2b sltu	v0,v0,s0
[ 141] 0x900000001fc16b84:  14 40 00 0a bne	v0,zero,0x900000001fc16bb0
[ 141] 0x900000001fc16b88:  00 00 00 21 nada
[ 141] 0x900000001fc16b8c:  24 03 01 2c li	v1,300
[ 141] 0x900000001fc16b90:  02 03 00 1b divu	s0,v1
[ 142] 0x900000001fc16b94:  00 00 18 10 mfhi	v1
[ 142] 0x900000001fc16b98:  02 43 c8 0b movn	t9,s2,v1
[ 142] 0x900000001fc16b9c:  00 00 00 21 nada
[ 142] 0x900000001fc16ba0:  00 00 00 21 nada
[ 142] 0x900000001fc16ba4:  00 00 00 21 nada
[ 142] 0x900000001fc16ba8:  10 00 00 03 b		0x900000001fc16bb8
[ 142] 0x900000001fc16bac:  00 00 00 21 nada
  145:     }
  146: 
  147:     return baud_rate;
[ 147] 0x900000001fc16bb0:  10 00 00 01 b		0x900000001fc16bb8
[ 147] 0x900000001fc16bb4:  02 40 c8 25 move	t9,s2
[ 126] 0x900000001fc16bb8:  df b2 00 10 ld	s2,16(sp)
[ 126] 0x900000001fc16bbc:  df bf 00 28 ld	ra,40(sp)
[ 126] 0x900000001fc16bc0:  03 20 10 25 move	v0,t9
[ 126] 0x900000001fc16bc4:  df b0 00 20 ld	s0,32(sp)
[ 126] 0x900000001fc16bc8:  df b1 00 18 ld	s1,24(sp)
[ 126] 0x900000001fc16bcc:  03 e0 00 08 jr	ra
[ 126] 0x900000001fc16bd0:  67 bd 00 30 daddiu	sp,sp,48
Skipping source listing to line 37 of /cores/banyan/stand/arcs/IP25prom/transfer.c...
   38: #define MEG	(1024 * 1024)
   39: 
   40: int	jump_addr(__psunsigned_t, uint, uint, struct flag_struct *);
   41: uint	load_lwin_half_store_mult(int, int, __scunsigned_t, int);
   42: 
   43: uint
   44: copy_prom(register __scunsigned_t src,
   45: 	  register __scunsigned_t dest, 
   46:           uint numbytes)
   47: {
copy_prom:
[  47] 0x900000001fc16bd4:  67 bd ff b0 daddiu	sp,sp,-80
[  47] 0x900000001fc16bd8:  ff b5 00 18 sd	s5,24(sp)
[  47] 0x900000001fc16bdc:  00 80 a8 25 move	s5,a0
   48:     register __scunsigned_t offset = (master_epc_adap()<<LWIN_PADAPSHIFT) + src;
[  48] 0x900000001fc16be0:  ff b4 00 20 sd	s4,32(sp)
[  48] 0x900000001fc16be4:  00 a0 a0 25 move	s4,a1
[  48] 0x900000001fc16be8:  ff b6 00 10 sd	s6,16(sp)
[  48] 0x900000001fc16bec:  ff bf 00 48 sd	ra,72(sp)
[  48] 0x900000001fc16bf0:  0f f0 3d 04 jal		master_epc_adap
[  48] 0x900000001fc16bf4:  00 c0 b0 25 move	s6,a2
   49:     register uint cksum = 0;
[  49] 0x900000001fc16bf8:  ff b3 00 28 sd	s3,40(sp)
[  49] 0x900000001fc16bfc:  ff be 00 00 sd	s8,0(sp)
[  49] 0x900000001fc16c00:  00 00 f0 25 move	s8,zero
[  49] 0x900000001fc16c04:  ff b7 00 08 sd	s7,8(sp)
[  49] 0x900000001fc16c08:  3c 17 00 08 lui	s7,0x8
[  49] 0x900000001fc16c0c:  02 b7 c8 2b sltu	t9,s5,s7
[  49] 0x900000001fc16c10:  ff b2 00 30 sd	s2,48(sp)
[  49] 0x900000001fc16c14:  00 02 0e f8 dsll	at,v0,27
[  49] 0x900000001fc16c18:  02 a1 58 2d daddu	a7,s5,at
[  49] 0x900000001fc16c1c:  ff b0 00 40 sd	s0,64(sp)
[  49] 0x900000001fc16c20:  ff b1 00 38 sd	s1,56(sp)
[  49] 0x900000001fc16c24:  52 c0 00 2a beql	s6,zero,0x900000001fc16cd0
[  49] 0x900000001fc16c28:  df b1 00 38 ld	s1,56(sp)
   50:     register uint numtocopy;
   51: 
   52:     while (numbytes) {
   53: 
   54: 	/* We can't allow the transfer to cross the boundary between
   55: 	 * Flash PROM windows 0 and 1, so we break up the transfer into
   56: 	 * two pieces if necessary and select the proper window.
   57: 	 */
   58: 	if (src < SPLIT) {
[  58] 0x900000001fc16c2c:  57 20 00 0d bnel	t9,zero,0x900000001fc16c64
[  58] 0x900000001fc16c30:  00 16 30 3c dsll32	a2,s6,0
   59: 	    numtocopy = ((numbytes < (SPLIT - src)) ? numbytes : (SPLIT - src));
   60: 	    offset += EPC_LWIN_LOPROM;
   61: 	} else {
   62: 	    numtocopy = numbytes;
   63: 	    offset += EPC_LWIN_HIPROM - SPLIT;
[  63] 0x900000001fc16c34:  00 16 18 3c dsll32	v1,s6,0
[  63] 0x900000001fc16c38:  01 77 20 2d daddu	a0,a7,s7
[  62] 0x900000001fc16c3c:  02 c0 38 25 move	a3,s6
[  62] 0x900000001fc16c40:  00 00 98 25 move	s3,zero
[  62] 0x900000001fc16c44:  02 80 30 25 move	a2,s4
[  62] 0x900000001fc16c48:  00 03 18 3e dsrl32	v1,v1,0
[  62] 0x900000001fc16c4c:  00 04 28 00 sll	a1,a0,0
[  62] 0x900000001fc16c50:  02 83 80 2d daddu	s0,s4,v1
[  62] 0x900000001fc16c54:  00 83 88 2d daddu	s1,a0,v1
[  62] 0x900000001fc16c58:  10 00 00 13 b		0x900000001fc16ca8
[  62] 0x900000001fc16c5c:  02 a3 90 2d daddu	s2,s5,v1
[  59] 0x900000001fc16c60:  00 16 30 3c dsll32	a2,s6,0
[  59] 0x900000001fc16c64:  00 06 38 3e dsrl32	a3,a2,0
[  59] 0x900000001fc16c68:  02 f5 40 2f dsubu	a4,s7,s5
[  59] 0x900000001fc16c6c:  01 00 30 25 move	a2,a4
[  59] 0x900000001fc16c70:  00 e8 40 2b sltu	a4,a3,a4
[  60] 0x900000001fc16c74:  00 0b 28 00 sll	a1,a7,0
[  60] 0x900000001fc16c78:  00 e8 30 0b movn	a2,a3,a4
[  60] 0x900000001fc16c7c:  00 00 00 21 nada
[  60] 0x900000001fc16c80:  00 00 00 21 nada
[  60] 0x900000001fc16c84:  00 00 00 21 nada
[  60] 0x900000001fc16c88:  00 06 38 00 sll	a3,a2,0
[  60] 0x900000001fc16c8c:  00 07 30 3c dsll32	a2,a3,0
[  60] 0x900000001fc16c90:  00 06 30 3e dsrl32	a2,a2,0
[  60] 0x900000001fc16c94:  02 c7 98 23 subu	s3,s6,a3
[  60] 0x900000001fc16c98:  02 86 80 2d daddu	s0,s4,a2
[  60] 0x900000001fc16c9c:  01 66 88 2d daddu	s1,a7,a2
[  60] 0x900000001fc16ca0:  02 a6 90 2d daddu	s2,s5,a2
[  60] 0x900000001fc16ca4:  02 80 30 25 move	a2,s4
   64: 	}
   65: 	cksum += load_lwin_half_store_mult(EPC_REGION, offset, dest, numtocopy);
[  65] 0x900000001fc16ca8:  0f f0 0d 5e jal		load_lwin_half_store_mult
[  65] 0x900000001fc16cac:  24 04 00 01 li	a0,1
   66: 	dest += numtocopy;
[  66] 0x900000001fc16cb0:  02 00 a0 25 move	s4,s0
   67: 	offset += numtocopy;
[  67] 0x900000001fc16cb4:  02 20 58 25 move	a7,s1
   68: 	src += numtocopy;
[  68] 0x900000001fc16cb8:  02 40 a8 25 move	s5,s2
   69: 	numbytes -= numtocopy;
[  69] 0x900000001fc16cbc:  02 60 b0 25 move	s6,s3
[  52] 0x900000001fc16cc0:  03 c2 f0 21 addu	s8,s8,v0
[  52] 0x900000001fc16cc4:  16 60 ff d9 bne	s3,zero,0x900000001fc16c2c
[  52] 0x900000001fc16cc8:  02 57 c8 2b sltu	t9,s2,s7
[  52] 0x900000001fc16ccc:  df b1 00 38 ld	s1,56(sp)
[  52] 0x900000001fc16cd0:  df b3 00 28 ld	s3,40(sp)
[  52] 0x900000001fc16cd4:  df b5 00 18 ld	s5,24(sp)
[  52] 0x900000001fc16cd8:  df bf 00 48 ld	ra,72(sp)
   70:     }
   71: 
   72:     return cksum;
[  72] 0x900000001fc16cdc:  03 c0 10 25 move	v0,s8
[  72] 0x900000001fc16ce0:  df be 00 00 ld	s8,0(sp)
[  72] 0x900000001fc16ce4:  df b6 00 10 ld	s6,16(sp)
[  72] 0x900000001fc16ce8:  df b4 00 20 ld	s4,32(sp)
[  72] 0x900000001fc16cec:  df b2 00 30 ld	s2,48(sp)
[  72] 0x900000001fc16cf0:  df b0 00 40 ld	s0,64(sp)
[  72] 0x900000001fc16cf4:  df b7 00 08 ld	s7,8(sp)
[  72] 0x900000001fc16cf8:  03 e0 00 08 jr	ra
[  72] 0x900000001fc16cfc:  67 bd 00 50 daddiu	sp,sp,80
   73: }
   74: 
   75: 
   76: /*
   77:  * load_io4prom()
   78:  *	Copies the IO4 PROM out of the Flash EPROM and loads it
   79:  *	into memory.
   80:  */
   81: 
   82: int
   83: load_io4prom()
   84: {
load_io4prom:
[  84] 0x900000001fc16d00:  67 bd fc 20 daddiu	sp,sp,-992
   85:     evpromhdr_t promhdr;
   86:     seginfo_t seginfo;
   87:     uint cksum;
   88:     struct flag_struct flags;
   89:     jmp_buf  fault_buf;		/* Fault status buffer */
   90:     unsigned *old_buf;		/* Previous fault handler buf ptr */
   91:     __psunsigned_t startaddr, entry;
   92: 
   93:     sysctlr_message("Loading IO4 PROM...");
[  93] 0x900000001fc16d04:  3c 01 90 00 lui	at,0x9000
[  93] 0x900000001fc16d08:  60 21 00 00 daddi	at,at,0
[  93] 0x900000001fc16d0c:  3c 02 1f c2 lui	v0,0x1fc2
[  93] 0x900000001fc16d10:  60 42 fb d0 daddi	v0,v0,-1072
[  93] 0x900000001fc16d14:  00 01 08 3c dsll32	at,at,0
[  93] 0x900000001fc16d18:  ff b0 00 58 sd	s0,88(sp)
[  93] 0x900000001fc16d1c:  00 22 80 2c dadd	s0,at,v0
[  93] 0x900000001fc16d20:  ff bf 00 60 sd	ra,96(sp)
[  93] 0x900000001fc16d24:  0f f0 11 7c jal		sysctlr_message
[  93] 0x900000001fc16d28:  02 00 20 25 move	a0,s0
   94: 
   95:     /*
   96:      * Pull in the PROM header and check it
   97:      */
   98:     if (setfault(fault_buf, &old_buf)) {
[  98] 0x900000001fc16d2c:  67 a5 00 30 daddiu	a1,sp,48
[  98] 0x900000001fc16d30:  0f f0 18 7f jal		setfault
[  98] 0x900000001fc16d34:  67 a4 00 70 daddiu	a0,sp,112
[  98] 0x900000001fc16d38:  14 40 00 a3 bne	v0,zero,0x900000001fc16fc8
[  98] 0x900000001fc16d3c:  00 00 00 21 nada
   99: 	loprintf("*** A bus error occurred while downloading IO4 PROM.\n");
  100: 	restorefault(old_buf);
  101: 	return EVDIAG_DLBUSERR;
  102:     }
  103: 
  104:     /* Set the LEDs appropriately */
  105:     set_cc_leds(PLED_LOADPROM);
[ 105] 0x900000001fc16d40:  0f f0 0c 78 jal		set_cc_leds
[ 105] 0x900000001fc16d44:  24 04 00 25 li	a0,37
  106: 
  107:     loprintf("Downloading PROM header information...");
[ 107] 0x900000001fc16d48:  0f f0 2c e3 jal		loprintf
[ 107] 0x900000001fc16d4c:  66 04 00 50 daddiu	a0,s0,80
  108:     (void) copy_prom(0, (__scunsigned_t)&promhdr, sizeof(promhdr));
[ 108] 0x900000001fc16d50:  24 06 00 18 li	a2,24
[ 108] 0x900000001fc16d54:  67 a5 00 00 daddiu	a1,sp,0
[ 108] 0x900000001fc16d58:  0f f0 5a f5 jal		copy_prom
[ 108] 0x900000001fc16d5c:  00 00 20 25 move	a0,zero
  109:     DPRINTF(("Prom header transfer complete"));
  110:     (void) copy_prom(SEGINFO_OFFSET, (__scunsigned_t)&seginfo, sizeof(seginfo_t));
[ 110] 0x900000001fc16d60:  24 06 03 08 li	a2,776
[ 110] 0x900000001fc16d64:  67 a5 00 d8 daddiu	a1,sp,216
[ 110] 0x900000001fc16d68:  0f f0 5a f5 jal		copy_prom
[ 110] 0x900000001fc16d6c:  24 04 01 00 li	a0,256
  111: 
  112:     DPRINTF(("Completed downloading IO4prom\n"));
  113:     if (promhdr.prom_magic != PROM_MAGIC) {
[ 113] 0x900000001fc16d70:  66 04 00 78 daddiu	a0,s0,120
[ 113] 0x900000001fc16d74:  df aa 00 f0 ld	a6,240(sp)
[ 113] 0x900000001fc16d78:  3c 06 4a 46 lui	a2,0x4a46
[ 113] 0x900000001fc16d7c:  34 c7 4b 34 ori	a3,a2,0x4b34
[ 113] 0x900000001fc16d80:  3c 08 53 45 lui	a4,0x5345
[ 113] 0x900000001fc16d84:  8f a6 00 00 lw	a2,0(sp)
[ 113] 0x900000001fc16d88:  8f b9 00 d8 lw	t9,216(sp)
[ 113] 0x900000001fc16d8c:  14 c7 00 86 bne	a2,a3,0x900000001fc16fa8
[ 113] 0x900000001fc16d90:  35 0b 47 32 ori	a7,a4,0x4732
  114: 	loprintf("*** ERROR: Invalid magic number (%x) for IO4 PROM.\n",
  115: 							promhdr.prom_magic);
  116:         restorefault(old_buf);
  117: 	return EVDIAG_BADMAGIC;
  118:     }
  119: 
  120:     if (seginfo.si_magic != SI_MAGIC) {
[ 120] 0x900000001fc16d94:  57 2b 00 7c bnel	t9,a7,0x900000001fc16f88
[ 120] 0x900000001fc16d98:  03 20 28 25 move	a1,t9
  121: 	loprintf("*** ERROR: Invalid segment magic number (%x) for IO4 PROM.\n",
  122: 							seginfo.si_magic);
  123:         restorefault(old_buf);
  124: 	return EVDIAG_BADMAGIC;
  125:     }
  126: 
  127:     startaddr = seginfo.si_segs[0].seg_startaddr;
  128:     entry = seginfo.si_segs[0].seg_entry;
  129:     if (! IS_KSEGDM(startaddr)) {
[ 129] 0x900000001fc16d9c:  de 09 02 48 ld	a5,584(s0)
[ 128] 0x900000001fc16da0:  01 49 48 2b sltu	a5,a6,a5
[ 128] 0x900000001fc16da4:  df ab 00 e8 ld	a7,232(sp)
[ 128] 0x900000001fc16da8:  ff ab 00 38 sd	a7,56(sp)
[ 128] 0x900000001fc16dac:  55 20 00 06 bnel	a5,zero,0x900000001fc16dc8
[ 128] 0x900000001fc16db0:  de 0d 02 58 ld	t1,600(s0)
[ 128] 0x900000001fc16db4:  de 0c 02 50 ld	t0,592(s0)
[ 128] 0x900000001fc16db8:  01 4c 60 2b sltu	t0,a6,t0
[ 128] 0x900000001fc16dbc:  55 80 00 0a bnel	t0,zero,0x900000001fc16de8
[ 128] 0x900000001fc16dc0:  3c 0f 00 10 lui	t3,0x10
[ 128] 0x900000001fc16dc4:  de 0d 02 58 ld	t1,600(s0)
[ 128] 0x900000001fc16dc8:  01 4d 68 2b sltu	t1,a6,t1
[ 128] 0x900000001fc16dcc:  55 a0 00 65 bnel	t1,zero,0x900000001fc16f64
[ 128] 0x900000001fc16dd0:  01 40 28 25 move	a1,a6
[ 128] 0x900000001fc16dd4:  de 0e 02 60 ld	t2,608(s0)
[ 128] 0x900000001fc16dd8:  01 4e 70 2b sltu	t2,a6,t2
[ 128] 0x900000001fc16ddc:  51 c0 00 61 beql	t2,zero,0x900000001fc16f64
[ 128] 0x900000001fc16de0:  01 40 28 25 move	a1,a6
  130: 	loprintf("*** ERROR: IO4 PROM start address 0x%x is invalid\n",
  131: 		 startaddr);
  132:         restorefault(old_buf);
  133: 	return EVDIAG_BADSTART;
  134:      }
  135: 
  136:     if (promhdr.prom_length > MEG) {
[ 136] 0x900000001fc16de4:  3c 0f 00 10 lui	t3,0x10
[ 136] 0x900000001fc16de8:  8f b8 00 0c lw	t8,12(sp)
[ 136] 0x900000001fc16dec:  01 f8 78 2b sltu	t3,t3,t8
[ 136] 0x900000001fc16df0:  55 e0 00 53 bnel	t3,zero,0x900000001fc16f40
[ 136] 0x900000001fc16df4:  66 04 01 28 daddiu	a0,s0,296
  137: 	loprintf("*** ERROR: IO4 PROM length 0x%x is excessive.\n",
  138: 		 promhdr.prom_length);
  139:         restorefault(old_buf);
  140: 	return EVDIAG_TOOLONG;
  141:     }
  142: 
  143:     /*
  144:      * Actually copy the bulk of the PROM into main memory UNCACHED
  145:      */
  146:     loprintf("\nDownloading PROM code...");
[ 146] 0x900000001fc16df8:  ff aa 00 40 sd	a6,64(sp)
[ 146] 0x900000001fc16dfc:  0f f0 2c e3 jal		loprintf
[ 146] 0x900000001fc16e00:  66 04 01 58 daddiu	a0,s0,344
  147:     DPRINTF(("Reading 0x%x %d(0x%x) bytes\n", startaddr, 
  148: 	     promhdr.prom_length, promhdr.prom_length));
  149:     if (IS_KSEG0(startaddr)) {
[ 149] 0x900000001fc16e04:  de 19 02 48 ld	t9,584(s0)
[ 149] 0x900000001fc16e08:  df aa 00 40 ld	a6,64(sp)
[ 149] 0x900000001fc16e0c:  de 1f 02 68 ld	ra,616(s0)
[ 149] 0x900000001fc16e10:  01 59 c8 2b sltu	t9,a6,t9
[ 149] 0x900000001fc16e14:  01 5f f8 24 and	ra,a6,ra
[ 149] 0x900000001fc16e18:  de 01 02 58 ld	at,600(s0)
[ 149] 0x900000001fc16e1c:  ff b1 00 50 sd	s1,80(sp)
[ 149] 0x900000001fc16e20:  17 20 00 01 bne	t9,zero,0x900000001fc16e28
[ 149] 0x900000001fc16e24:  03 e1 28 25 or	a1,ra,at
  150: 	DPRINTF(("Converting IO4prom address to uncached for loading\n"));
  151:     }
  152:     cksum = copy_prom(PROM_OFF, K0_TO_K1(startaddr), promhdr.prom_length);
[ 152] 0x900000001fc16e28:  ff aa 00 40 sd	a6,64(sp)
[ 152] 0x900000001fc16e2c:  8f a6 00 0c lw	a2,12(sp)
[ 152] 0x900000001fc16e30:  0f f0 5a f5 jal		copy_prom
[ 152] 0x900000001fc16e34:  24 04 10 00 li	a0,4096
[ 152] 0x900000001fc16e38:  00 40 88 25 move	s1,v0
  153:     loprintf("\n");
[ 153] 0x900000001fc16e3c:  ff a2 00 48 sd	v0,72(sp)
[ 153] 0x900000001fc16e40:  0f f0 2c e3 jal		loprintf
[ 153] 0x900000001fc16e44:  66 04 01 72 daddiu	a0,s0,370
  154: 
  155:     if (cksum != promhdr.prom_cksum) {
[ 155] 0x900000001fc16e48:  df a2 00 38 ld	v0,56(sp)
[ 155] 0x900000001fc16e4c:  df aa 00 40 ld	a6,64(sp)
[ 155] 0x900000001fc16e50:  8f b8 00 0c lw	t8,12(sp)
[ 155] 0x900000001fc16e54:  00 4a c8 2b sltu	t9,v0,a6
[ 155] 0x900000001fc16e58:  8f a1 00 04 lw	at,4(sp)
[ 155] 0x900000001fc16e5c:  56 21 00 2b bnel	s1,at,0x900000001fc16f0c
[ 155] 0x900000001fc16e60:  df b1 00 50 ld	s1,80(sp)
  156: 	loprintf("*** WARNING: IO4 PROM checksums don't match.\n");
  157: 	loprintf("\t Calculated 0x%x != stored 0x%x\n", cksum, 
  158: 		 promhdr.prom_cksum);
  159:         restorefault(old_buf);
  160: 	return EVDIAG_BADCKSUM;
  161:     }
  162: 
  163:     if ((entry < startaddr) || (entry > startaddr + promhdr.prom_length)) {
[ 163] 0x900000001fc16e64:  17 20 00 1e bne	t9,zero,0x900000001fc16ee0
[ 163] 0x900000001fc16e68:  df b1 00 50 ld	s1,80(sp)
[ 163] 0x900000001fc16e6c:  00 18 c0 3c dsll32	t8,t8,0
[ 163] 0x900000001fc16e70:  00 18 c0 3e dsrl32	t8,t8,0
[ 163] 0x900000001fc16e74:  01 58 c0 2d daddu	t8,a6,t8
[ 163] 0x900000001fc16e78:  df b9 00 38 ld	t9,56(sp)
[ 163] 0x900000001fc16e7c:  03 19 c0 2b sltu	t8,t8,t9
[ 163] 0x900000001fc16e80:  57 00 00 18 bnel	t8,zero,0x900000001fc16ee4
[ 163] 0x900000001fc16e84:  df b1 00 50 ld	s1,80(sp)
  164: 	loprintf("*** ERROR: IO4 PROM entry point (0x%x) is outside of PROM\n",
  165: 		 entry);
  166:         restorefault(old_buf);
  167: 	return EVDIAG_BADENTRY;
  168:     }
  169:     /* Let the world know we're about to jump. */
  170:     set_cc_leds(PLED_PROMJUMP);
[ 170] 0x900000001fc16e88:  0f f0 0c 78 jal		set_cc_leds
[ 170] 0x900000001fc16e8c:  24 04 00 29 li	a0,41
  171:     loprintf("Jumping into IO4 PROM.\n");
[ 171] 0x900000001fc16e90:  0f f0 2c e3 jal		loprintf
[ 171] 0x900000001fc16e94:  66 04 02 10 daddiu	a0,s0,528
  172:     flags.mem = 1;	/* Yes, we have memory */
  173:     flags.silent = 1;	/* Don't squawk about clearing cache, jumping to... */
  174:     setfault(0, &old_buf);
[ 174] 0x900000001fc16e98:  67 a5 00 30 daddiu	a1,sp,48
[ 172] 0x900000001fc16e9c:  00 00 20 25 move	a0,zero
[ 172] 0x900000001fc16ea0:  24 1f 00 01 li	ra,1
[ 173] 0x900000001fc16ea4:  af bf 00 18 sw	ra,24(sp)
[ 173] 0x900000001fc16ea8:  24 01 00 01 li	at,1
[ 173] 0x900000001fc16eac:  0f f0 18 7f jal		setfault
[ 173] 0x900000001fc16eb0:  a3 a1 00 2f sb	at,47(sp)
  175:     jump_addr(entry, 0, 0, &flags);
[ 175] 0x900000001fc16eb4:  67 a7 00 18 daddiu	a3,sp,24
[ 175] 0x900000001fc16eb8:  00 00 30 25 move	a2,zero
[ 175] 0x900000001fc16ebc:  00 00 28 25 move	a1,zero
[ 175] 0x900000001fc16ec0:  0f f0 2b 49 jal		jump_addr
[ 175] 0x900000001fc16ec4:  df a4 00 38 ld	a0,56(sp)
  176: 
  177:     loprintf("IO4 PROM returned.  Weird.\n");
[ 177] 0x900000001fc16ec8:  0f f0 2c e3 jal		loprintf
[ 177] 0x900000001fc16ecc:  66 04 02 28 daddiu	a0,s0,552
  178:     return 0;
[ 178] 0x900000001fc16ed0:  df bf 00 60 ld	ra,96(sp)
[ 178] 0x900000001fc16ed4:  00 00 58 25 move	a7,zero
[ 178] 0x900000001fc16ed8:  10 00 00 42 b		0x900000001fc16fe4
[ 178] 0x900000001fc16edc:  df b0 00 58 ld	s0,88(sp)
[ 178] 0x900000001fc16ee0:  df b1 00 50 ld	s1,80(sp)
[ 164] 0x900000001fc16ee4:  66 04 01 d0 daddiu	a0,s0,464
[ 164] 0x900000001fc16ee8:  0f f0 2c e3 jal		loprintf
[ 164] 0x900000001fc16eec:  df a5 00 38 ld	a1,56(sp)
[ 166] 0x900000001fc16ef0:  df b0 00 58 ld	s0,88(sp)
[ 166] 0x900000001fc16ef4:  0f f0 18 86 jal		restorefault
[ 166] 0x900000001fc16ef8:  df a4 00 30 ld	a0,48(sp)
[ 167] 0x900000001fc16efc:  24 0b 00 48 li	a7,72
[ 167] 0x900000001fc16f00:  10 00 00 38 b		0x900000001fc16fe4
[ 167] 0x900000001fc16f04:  df bf 00 60 ld	ra,96(sp)
[ 167] 0x900000001fc16f08:  df b1 00 50 ld	s1,80(sp)
[ 156] 0x900000001fc16f0c:  0f f0 2c e3 jal		loprintf
[ 156] 0x900000001fc16f10:  66 04 01 78 daddiu	a0,s0,376
[ 156] 0x900000001fc16f14:  8f a6 00 04 lw	a2,4(sp)
[ 157] 0x900000001fc16f18:  df a5 00 48 ld	a1,72(sp)
[ 157] 0x900000001fc16f1c:  0f f0 2c e3 jal		loprintf
[ 157] 0x900000001fc16f20:  66 04 01 a8 daddiu	a0,s0,424
[ 159] 0x900000001fc16f24:  df b0 00 58 ld	s0,88(sp)
[ 159] 0x900000001fc16f28:  0f f0 18 86 jal		restorefault
[ 159] 0x900000001fc16f2c:  df a4 00 30 ld	a0,48(sp)
[ 160] 0x900000001fc16f30:  24 0b 00 47 li	a7,71
[ 160] 0x900000001fc16f34:  10 00 00 2b b		0x900000001fc16fe4
[ 160] 0x900000001fc16f38:  df bf 00 60 ld	ra,96(sp)
[ 137] 0x900000001fc16f3c:  66 04 01 28 daddiu	a0,s0,296
[ 137] 0x900000001fc16f40:  df b0 00 58 ld	s0,88(sp)
[ 137] 0x900000001fc16f44:  0f f0 2c e3 jal		loprintf
[ 137] 0x900000001fc16f48:  8f a5 00 0c lw	a1,12(sp)
[ 139] 0x900000001fc16f4c:  0f f0 18 86 jal		restorefault
[ 139] 0x900000001fc16f50:  df a4 00 30 ld	a0,48(sp)
[ 140] 0x900000001fc16f54:  24 0b 00 49 li	a7,73
[ 140] 0x900000001fc16f58:  10 00 00 22 b		0x900000001fc16fe4
[ 140] 0x900000001fc16f5c:  df bf 00 60 ld	ra,96(sp)
[ 130] 0x900000001fc16f60:  01 40 28 25 move	a1,a6
[ 130] 0x900000001fc16f64:  0f f0 2c e3 jal		loprintf
[ 130] 0x900000001fc16f68:  66 04 00 f0 daddiu	a0,s0,240
[ 132] 0x900000001fc16f6c:  df b0 00 58 ld	s0,88(sp)
[ 132] 0x900000001fc16f70:  0f f0 18 86 jal		restorefault
[ 132] 0x900000001fc16f74:  df a4 00 30 ld	a0,48(sp)
[ 133] 0x900000001fc16f78:  24 0b 00 4a li	a7,74
[ 133] 0x900000001fc16f7c:  10 00 00 19 b		0x900000001fc16fe4
[ 133] 0x900000001fc16f80:  df bf 00 60 ld	ra,96(sp)
[ 121] 0x900000001fc16f84:  03 20 28 25 move	a1,t9
[ 121] 0x900000001fc16f88:  0f f0 2c e3 jal		loprintf
[ 121] 0x900000001fc16f8c:  66 04 00 b0 daddiu	a0,s0,176
[ 123] 0x900000001fc16f90:  df b0 00 58 ld	s0,88(sp)
[ 123] 0x900000001fc16f94:  0f f0 18 86 jal		restorefault
[ 123] 0x900000001fc16f98:  df a4 00 30 ld	a0,48(sp)
[ 124] 0x900000001fc16f9c:  24 0b 00 4b li	a7,75
[ 124] 0x900000001fc16fa0:  10 00 00 10 b		0x900000001fc16fe4
[ 124] 0x900000001fc16fa4:  df bf 00 60 ld	ra,96(sp)
[ 114] 0x900000001fc16fa8:  df b0 00 58 ld	s0,88(sp)
[ 114] 0x900000001fc16fac:  0f f0 2c e3 jal		loprintf
[ 114] 0x900000001fc16fb0:  8f a5 00 00 lw	a1,0(sp)
[ 116] 0x900000001fc16fb4:  0f f0 18 86 jal		restorefault
[ 116] 0x900000001fc16fb8:  df a4 00 30 ld	a0,48(sp)
[ 117] 0x900000001fc16fbc:  24 0b 00 4b li	a7,75
[ 117] 0x900000001fc16fc0:  10 00 00 08 b		0x900000001fc16fe4
[ 117] 0x900000001fc16fc4:  df bf 00 60 ld	ra,96(sp)
[  99] 0x900000001fc16fc8:  0f f0 2c e3 jal		loprintf
[  99] 0x900000001fc16fcc:  66 04 00 18 daddiu	a0,s0,24
[ 100] 0x900000001fc16fd0:  df b0 00 58 ld	s0,88(sp)
[ 100] 0x900000001fc16fd4:  0f f0 18 86 jal		restorefault
[ 100] 0x900000001fc16fd8:  df a4 00 30 ld	a0,48(sp)
[ 101] 0x900000001fc16fdc:  df bf 00 60 ld	ra,96(sp)
[ 101] 0x900000001fc16fe0:  24 0b 00 4e li	a7,78
[ 101] 0x900000001fc16fe4:  01 60 10 25 move	v0,a7
[ 101] 0x900000001fc16fe8:  03 e0 00 08 jr	ra
[ 101] 0x900000001fc16fec:  67 bd 03 e0 daddiu	sp,sp,992
    1: /* Configuration Control File */
    2: char *prom_version = "SGI Version 3  built 11:59:23 AM Feb 22, 1996";
    3: char *getversion(void) {return prom_version;}
getversion:
[   3] 0x900000001fc16ff0:  3c 01 90 00 lui	at,0x9000
[   3] 0x900000001fc16ff4:  60 21 00 00 daddi	at,at,0
[   3] 0x900000001fc16ff8:  3c 02 1f c2 lui	v0,0x1fc2
[   3] 0x900000001fc16ffc:  60 42 fe 40 daddi	v0,v0,-448
[   3] 0x900000001fc17000:  00 01 08 3c dsll32	at,at,0
[   3] 0x900000001fc17004:  00 22 08 2c dadd	at,at,v0
[   3] 0x900000001fc17008:  dc 21 00 30 ld	at,48(at)
[   3] 0x900000001fc1700c:  03 e0 00 08 jr	ra
[   3] 0x900000001fc17010:  dc 22 00 00 ld	v0,0(at)
